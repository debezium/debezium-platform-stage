"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimationState = void 0;
var _defaults2 = _interopRequireDefault(require("lodash/defaults"));
var _react = _interopRequireDefault(require("react"));
var Collection = _interopRequireWildcard(require("../collection"));
var Transitions = _interopRequireWildcard(require("../transitions"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INITIAL_STATE = {
  nodesShouldLoad: false,
  nodesDoneLoad: false,
  animating: true
};
const useAnimationState = function (initialState) {
  if (initialState === void 0) {
    initialState = INITIAL_STATE;
  }
  const [state, _setState] = _react.default.useState(initialState);

  // This allows us to use a state object and maintain the same API as this.setState
  const setState = _react.default.useCallback(newState => {
    _setState(oldState => ({
      ...oldState,
      ...newState
    }));
  }, [_setState]);

  // This is a copy of Wrapper.getAnimationProps
  const getAnimationProps = _react.default.useCallback((props, child, index) => {
    if (!props?.animate) {
      return child.props.animate;
    }
    const getFilteredState = () => {
      let childrenTransitions = state && state.childrenTransitions;
      childrenTransitions = Collection.isArrayOfArrays(childrenTransitions) ? childrenTransitions[index] : childrenTransitions;
      return (0, _defaults2.default)({
        childrenTransitions
      }, state);
    };
    let getTransitions = props.animate && props.animate.getTransitions;
    const filteredState = getFilteredState();
    const parentState = props.animate && props.animate.parentState || filteredState;
    if (!getTransitions) {
      const getTransitionProps = Transitions.getTransitionPropsFactory(props, filteredState, newState => setState(newState));
      getTransitions = childComponent => getTransitionProps(childComponent, index);
    }
    return (0, _defaults2.default)({
      getTransitions,
      parentState
    }, props.animate, child.props.animate);
  }, [state, setState]);

  // This is a copy of Wrapper.setAnimationState
  const setAnimationState = _react.default.useCallback((props, nextProps) => {
    if (!props?.animate) {
      return;
    }
    if (props.animate.parentState) {
      const nodesWillExit = props.animate.parentState.nodesWillExit;
      const oldProps = nodesWillExit ? props : null;
      const newState = (0, _defaults2.default)({
        oldProps,
        nextProps
      }, props.animate.parentState);
      setState(newState);
    } else {
      const oldChildren = _react.default.Children.toArray(props.children);
      const nextChildren = _react.default.Children.toArray(nextProps.children);
      const isContinuous = child => {
        const check = c => c.type && c.type.continuous;
        return Array.isArray(child) ? child.some(check) : check(child);
      };
      const continuous = !props.polar && oldChildren.some(child => {
        return isContinuous(child) || child?.props?.children && isContinuous(child.props.children);
      });
      const {
        nodesWillExit,
        nodesWillEnter,
        childrenTransitions,
        nodesShouldEnter
      } = Transitions.getInitialTransitionState(oldChildren, nextChildren);
      setState({
        nodesWillExit,
        nodesWillEnter,
        nodesShouldEnter,
        childrenTransitions: Collection.isArrayOfArrays(childrenTransitions) ? childrenTransitions[0] : childrenTransitions,
        oldProps: nodesWillExit ? props : undefined,
        nextProps,
        continuous
      });
    }
  }, [setState]);
  const getProps = _react.default.useCallback(initialProps => {
    return state && state.nodesWillExit ? state.oldProps || initialProps : initialProps;
  }, [state]);
  return {
    state,
    setState,
    getAnimationProps,
    setAnimationState,
    getProps
  };
};
exports.useAnimationState = useAnimationState;