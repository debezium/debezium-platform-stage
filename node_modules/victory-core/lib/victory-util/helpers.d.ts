import React from "react";
import { CallbackArgs } from "../types/callbacks";
import { ValueOrAccessor } from "../types/prop-types";
/**
 * Creates an object composed of the inverted keys and values of object.
 * If object contains duplicate values, subsequent values overwrite property assignments of previous values.
 */
export declare function invert(original: Record<string, string | number>): {};
/**
 * creates an object with some keys excluded
 * replacement for lodash.omit for performance. does not mimic the entire lodash.omit api
 * @param {Object} originalObject: created object will be based on this object
 * @param {Array<String>} ks: an array of keys to omit from the new object
 * @returns {Object} new object with same properties as originalObject
 */
export declare function omit<T, Keys extends keyof T>(originalObject: T, ks?: Array<Keys>): Omit<T, Keys>;
export declare function getPoint(datum: any): any;
export declare function scalePoint(props: any, datum: any): {
    x: any;
    x0: any;
    y: any;
    y0: any;
};
export declare function getPadding(props: any, name?: string): {
    top: any;
    bottom: any;
    left: any;
    right: any;
};
export declare function isTooltip(component: any): boolean;
export declare function getDefaultStyles(props: any, role: any): any;
export declare function getStyles(style: any, defaultStyles: any): any;
export declare function evaluateProp<TValue>(prop: ValueOrAccessor<TValue, CallbackArgs>, props: CallbackArgs): TValue;
export declare function evaluateStyle(style: any, props: any): any;
export declare function degreesToRadians(degrees: any): any;
export declare function radiansToDegrees(radians: any): any;
export declare function getRadius(props: any): number;
export declare function getPolarOrigin(props: any): {
    x: number;
    y: number;
};
export declare function getRange(props: any, axis: any): any;
/**
 * Checks if `value` is `null` or `undefined`.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 */
export declare function isNil(value: any): boolean;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @since 0.1.0
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 */
export declare function isFunction(value: any): value is (...args: any[]) => any;
export declare function createAccessor(key: any): (...args: any[]) => any;
export declare function modifyProps(props: any, fallbackProps?: any, role?: any): any;
/**
 * Returns the given axis or the opposite axis when horizontal
 * @param {string} axis: the given axis, either "x" pr "y"
 * @param {Boolean} horizontal: true when the chart is flipped to the horizontal orientation
 * @returns {String} the dimension appropriate for the axis given its props "x" or "y"
 */
export declare function getCurrentAxis(axis: any, horizontal: any): any;
/**
 * Creates an object with the same keys as object and values generated by running
 * each own enumerable string keyed property of object through the function fn
 */
export declare function mapValues<T>(values: T, fn: (value?: any) => any): T | undefined;
/**
 * Creates an array of numbers (positive and/or negative) progressing
 * from start up to, but not including, end.
 * A step of -1 is used if a negative start is specified without an end or step.
 * If end is not specified, it's set to start with start then set to 0.
 *
 * @param start The length of the array to create, or the start value
 * @param end [The end value] If this is defined, start is the start value
 * @returns An array of the given length
 */
export declare function range(start: number, end?: number, increment?: number): number[];
/**
 * @param {Array} children: an array of child components
 * @param {Function} iteratee: a function with arguments "child", "childName", and "parent"
 * @param {Object} parentProps: props from the parent that are applied to children
 * @param {any}  initialMemo: The object in which the iteration results are combined.
 * @param {Function} combine: Combines the result of the iteratee with the current memo
 *   to the memo for the next iteration step
 * @returns {Array} returns an array of results from calling the iteratee on all nested children
 */
export declare function reduceChildren<TChildren extends React.ReactNode, TItem, TResult = TItem[]>(children: TChildren[], iteratee: (child: TChildren, childName: string, parent?: TChildren) => TItem | null, parentProps?: {}, initialMemo?: TResult, combine?: (memo: TResult, item: TItem) => TResult): TResult;
/**
 * @param {Object} props: the props object
 * @returns {Boolean} returns true if the props object contains `horizontal: true` of if any
 * children or nested children are horizontal
 */
export declare function isHorizontal(props: any): any;
//# sourceMappingURL=helpers.d.ts.map