"use strict";
var U0 = Object.create;
var wi = Object.defineProperty;
var K0 = Object.getOwnPropertyDescriptor;
var W0 = Object.getOwnPropertyNames;
var Y0 = Object.getPrototypeOf, X0 = Object.prototype.hasOwnProperty;
var s = (e, t) => wi(e, "name", { value: t, configurable: !0 });
var v = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), J0 = (e, t) => {
  for (var r in t)
    wi(e, r, { get: t[r], enumerable: !0 });
}, Tp = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of W0(t))
      !X0.call(e, n) && n !== r && wi(e, n, { get: () => t[n], enumerable: !(i = K0(t, n)) || i.enumerable });
  return e;
};
var Ge = (e, t, r) => (r = e != null ? U0(Y0(e)) : {}, Tp(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? wi(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), $0 = (e) => Tp(wi({}, "__esModule", { value: !0 }), e);

// ../node_modules/ts-dedent/dist/index.js
var Ls = v((Oi) => {
  "use strict";
  Object.defineProperty(Oi, "__esModule", { value: !0 });
  Oi.dedent = void 0;
  function gp(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    var i = Array.from(typeof e == "string" ? [e] : e);
    i[i.length - 1] = i[i.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var n = i.reduce(function(l, u) {
      var c = u.match(/\n([\t ]+|(?!\s).)/g);
      return c ? l.concat(c.map(function(p) {
        var g, P;
        return (P = (g = p.match(/[\t ]/g)) === null || g === void 0 ? void 0 : g.length) !== null && P !== void 0 ? P : 0;
      })) : l;
    }, []);
    if (n.length) {
      var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, n) + "}", "g");
      i = i.map(function(l) {
        return l.replace(a, `
`);
      });
    }
    i[0] = i[0].replace(/^\r?\n/, "");
    var o = i[0];
    return t.forEach(function(l, u) {
      var c = o.match(/(?:^|\n)( *)$/), p = c ? c[1] : "", g = l;
      typeof l == "string" && l.includes(`
`) && (g = String(l).split(`
`).map(function(P, A) {
        return A === 0 ? P : "" + p + P;
      }).join(`
`)), o += g + i[u + 1];
    }), o;
  }
  s(gp, "dedent");
  Oi.dedent = gp;
  Oi.default = gp;
});

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var Ms = v((ga) => {
  "use strict";
  Object.defineProperty(ga, "__esModule", {
    value: !0
  });
  ga.default = H0;
  function H0(e, t) {
    let r = Object.keys(t);
    for (let i of r)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  s(H0, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var Ni = v((ba) => {
  "use strict";
  Object.defineProperty(ba, "__esModule", {
    value: !0
  });
  ba.default = G0;
  var bp = /* @__PURE__ */ new Set();
  function G0(e, t, r = "") {
    if (bp.has(e)) return;
    bp.add(e);
    let {
      internal: i,
      trace: n
    } = z0(1, 2);
    i || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${n}`);
  }
  s(G0, "deprecationWarning");
  function z0(e, t) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: i
    } = Error, n;
    if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(o, l) {
      n = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = i, !n) return {
      internal: !1,
      trace: ""
    };
    let a = n.slice(1 + e, 1 + e + t);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  s(z0, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var We = v((d) => {
  "use strict";
  Object.defineProperty(d, "__esModule", {
    value: !0
  });
  d.isAccessor = pP;
  d.isAnyTypeAnnotation = Db;
  d.isArgumentPlaceholder = ox;
  d.isArrayExpression = Q0;
  d.isArrayPattern = Gg;
  d.isArrayTypeAnnotation = kb;
  d.isArrowFunctionExpression = zg;
  d.isAssignmentExpression = Z0;
  d.isAssignmentPattern = Hg;
  d.isAwaitExpression = Sb;
  d.isBigIntLiteral = Eb;
  d.isBinary = LE;
  d.isBinaryExpression = eg;
  d.isBindExpression = lx;
  d.isBlock = BE;
  d.isBlockParent = FE;
  d.isBlockStatement = sg;
  d.isBooleanLiteral = vg;
  d.isBooleanLiteralTypeAnnotation = Mb;
  d.isBooleanTypeAnnotation = Lb;
  d.isBreakStatement = ng;
  d.isCallExpression = ag;
  d.isCatchClause = og;
  d.isClass = lP;
  d.isClassAccessorProperty = Ib;
  d.isClassBody = Qg;
  d.isClassDeclaration = eb;
  d.isClassExpression = Zg;
  d.isClassImplements = Bb;
  d.isClassMethod = fb;
  d.isClassPrivateMethod = Ob;
  d.isClassPrivateProperty = wb;
  d.isClassProperty = Cb;
  d.isCompletionStatement = qE;
  d.isConditional = VE;
  d.isConditionalExpression = lg;
  d.isContinueStatement = ug;
  d.isDebuggerStatement = cg;
  d.isDecimalLiteral = mx;
  d.isDeclaration = GE;
  d.isDeclareClass = jb;
  d.isDeclareExportAllDeclaration = Jb;
  d.isDeclareExportDeclaration = Xb;
  d.isDeclareFunction = Rb;
  d.isDeclareInterface = qb;
  d.isDeclareModule = Vb;
  d.isDeclareModuleExports = Ub;
  d.isDeclareOpaqueType = Wb;
  d.isDeclareTypeAlias = Kb;
  d.isDeclareVariable = Yb;
  d.isDeclaredPredicate = $b;
  d.isDecorator = cx;
  d.isDirective = rg;
  d.isDirectiveLiteral = ig;
  d.isDoExpression = px;
  d.isDoWhileStatement = pg;
  d.isEmptyStatement = fg;
  d.isEmptyTypeAnnotation = nS;
  d.isEnumBody = gP;
  d.isEnumBooleanBody = kS;
  d.isEnumBooleanMember = BS;
  d.isEnumDeclaration = DS;
  d.isEnumDefaultedMember = qS;
  d.isEnumMember = bP;
  d.isEnumNumberBody = LS;
  d.isEnumNumberMember = jS;
  d.isEnumStringBody = MS;
  d.isEnumStringMember = RS;
  d.isEnumSymbolBody = FS;
  d.isExistsTypeAnnotation = Hb;
  d.isExportAllDeclaration = tb;
  d.isExportDeclaration = uP;
  d.isExportDefaultDeclaration = rb;
  d.isExportDefaultSpecifier = fx;
  d.isExportNamedDeclaration = ib;
  d.isExportNamespaceSpecifier = Pb;
  d.isExportSpecifier = sb;
  d.isExpression = kE;
  d.isExpressionStatement = hg;
  d.isExpressionWrapper = WE;
  d.isFile = dg;
  d.isFlow = hP;
  d.isFlowBaseAnnotation = mP;
  d.isFlowDeclaration = yP;
  d.isFlowPredicate = TP;
  d.isFlowType = dP;
  d.isFor = YE;
  d.isForInStatement = mg;
  d.isForOfStatement = nb;
  d.isForStatement = yg;
  d.isForXStatement = XE;
  d.isFunction = JE;
  d.isFunctionDeclaration = Tg;
  d.isFunctionExpression = gg;
  d.isFunctionParent = $E;
  d.isFunctionTypeAnnotation = Gb;
  d.isFunctionTypeParam = zb;
  d.isGenericTypeAnnotation = Qb;
  d.isIdentifier = bg;
  d.isIfStatement = Sg;
  d.isImmutable = tP;
  d.isImport = xb;
  d.isImportAttribute = ux;
  d.isImportDeclaration = ab;
  d.isImportDefaultSpecifier = ob;
  d.isImportExpression = cb;
  d.isImportNamespaceSpecifier = lb;
  d.isImportOrExportDeclaration = Sp;
  d.isImportSpecifier = ub;
  d.isIndexedAccessType = VS;
  d.isInferredPredicate = Zb;
  d.isInterfaceDeclaration = tS;
  d.isInterfaceExtends = eS;
  d.isInterfaceTypeAnnotation = rS;
  d.isInterpreterDirective = tg;
  d.isIntersectionTypeAnnotation = iS;
  d.isJSX = SP;
  d.isJSXAttribute = KS;
  d.isJSXClosingElement = WS;
  d.isJSXClosingFragment = ix;
  d.isJSXElement = YS;
  d.isJSXEmptyExpression = XS;
  d.isJSXExpressionContainer = JS;
  d.isJSXFragment = tx;
  d.isJSXIdentifier = HS;
  d.isJSXMemberExpression = GS;
  d.isJSXNamespacedName = zS;
  d.isJSXOpeningElement = QS;
  d.isJSXOpeningFragment = rx;
  d.isJSXSpreadAttribute = ZS;
  d.isJSXSpreadChild = $S;
  d.isJSXText = ex;
  d.isLVal = QE;
  d.isLabeledStatement = xg;
  d.isLiteral = eP;
  d.isLogicalExpression = Ig;
  d.isLoop = UE;
  d.isMemberExpression = wg;
  d.isMetaProperty = pb;
  d.isMethod = iP;
  d.isMiscellaneous = xP;
  d.isMixedTypeAnnotation = sS;
  d.isModuleDeclaration = NP;
  d.isModuleExpression = yx;
  d.isModuleSpecifier = cP;
  d.isNewExpression = Og;
  d.isNoop = sx;
  d.isNullLiteral = Ag;
  d.isNullLiteralTypeAnnotation = Fb;
  d.isNullableTypeAnnotation = aS;
  d.isNumberLiteral = CP;
  d.isNumberLiteralTypeAnnotation = oS;
  d.isNumberTypeAnnotation = lS;
  d.isNumericLiteral = Pg;
  d.isObjectExpression = _g;
  d.isObjectMember = sP;
  d.isObjectMethod = Dg;
  d.isObjectPattern = hb;
  d.isObjectProperty = kg;
  d.isObjectTypeAnnotation = uS;
  d.isObjectTypeCallProperty = pS;
  d.isObjectTypeIndexer = fS;
  d.isObjectTypeInternalSlot = cS;
  d.isObjectTypeProperty = hS;
  d.isObjectTypeSpreadProperty = dS;
  d.isOpaqueType = mS;
  d.isOptionalCallExpression = vb;
  d.isOptionalIndexedAccessType = US;
  d.isOptionalMemberExpression = Ab;
  d.isParenthesizedExpression = Bg;
  d.isPattern = oP;
  d.isPatternLike = zE;
  d.isPipelineBareFunction = bx;
  d.isPipelinePrimaryTopicReference = Sx;
  d.isPipelineTopicExpression = gx;
  d.isPlaceholder = nx;
  d.isPrivate = fP;
  d.isPrivateName = Nb;
  d.isProgram = Ng;
  d.isProperty = nP;
  d.isPureish = HE;
  d.isQualifiedTypeIdentifier = yS;
  d.isRecordExpression = hx;
  d.isRegExpLiteral = Cg;
  d.isRegexLiteral = IP;
  d.isRestElement = Lg;
  d.isRestProperty = wP;
  d.isReturnStatement = Mg;
  d.isScopable = ME;
  d.isSequenceExpression = Fg;
  d.isSpreadElement = db;
  d.isSpreadProperty = OP;
  d.isStandardized = DE;
  d.isStatement = jE;
  d.isStaticBlock = _b;
  d.isStringLiteral = Eg;
  d.isStringLiteralTypeAnnotation = TS;
  d.isStringTypeAnnotation = gS;
  d.isSuper = mb;
  d.isSwitchCase = jg;
  d.isSwitchStatement = Rg;
  d.isSymbolTypeAnnotation = bS;
  d.isTSAnyKeyword = Nx;
  d.isTSArrayType = Gx;
  d.isTSAsExpression = mE;
  d.isTSBaseType = vP;
  d.isTSBigIntKeyword = Dx;
  d.isTSBooleanKeyword = _x;
  d.isTSCallSignatureDeclaration = vx;
  d.isTSConditionalType = iE;
  d.isTSConstructSignatureDeclaration = Cx;
  d.isTSConstructorType = Yx;
  d.isTSDeclareFunction = Ex;
  d.isTSDeclareMethod = Px;
  d.isTSEntityName = ZE;
  d.isTSEnumDeclaration = gE;
  d.isTSEnumMember = bE;
  d.isTSExportAssignment = CE;
  d.isTSExpressionWithTypeArguments = cE;
  d.isTSExternalModuleReference = AE;
  d.isTSFunctionType = Wx;
  d.isTSImportEqualsDeclaration = PE;
  d.isTSImportType = EE;
  d.isTSIndexSignature = Ox;
  d.isTSIndexedAccessType = oE;
  d.isTSInferType = sE;
  d.isTSInstantiationExpression = dE;
  d.isTSInterfaceBody = fE;
  d.isTSInterfaceDeclaration = pE;
  d.isTSIntersectionType = rE;
  d.isTSIntrinsicKeyword = kx;
  d.isTSLiteralType = uE;
  d.isTSMappedType = lE;
  d.isTSMethodSignature = wx;
  d.isTSModuleBlock = xE;
  d.isTSModuleDeclaration = SE;
  d.isTSNamedTupleMember = eE;
  d.isTSNamespaceExportDeclaration = IE;
  d.isTSNeverKeyword = Lx;
  d.isTSNonNullExpression = vE;
  d.isTSNullKeyword = Mx;
  d.isTSNumberKeyword = Fx;
  d.isTSObjectKeyword = Bx;
  d.isTSOptionalType = Qx;
  d.isTSParameterProperty = xx;
  d.isTSParenthesizedType = nE;
  d.isTSPropertySignature = Ix;
  d.isTSQualifiedName = Ax;
  d.isTSRestType = Zx;
  d.isTSSatisfiesExpression = yE;
  d.isTSStringKeyword = jx;
  d.isTSSymbolKeyword = Rx;
  d.isTSThisType = Kx;
  d.isTSTupleType = zx;
  d.isTSType = AP;
  d.isTSTypeAliasDeclaration = hE;
  d.isTSTypeAnnotation = wE;
  d.isTSTypeAssertion = TE;
  d.isTSTypeElement = PP;
  d.isTSTypeLiteral = Hx;
  d.isTSTypeOperator = aE;
  d.isTSTypeParameter = _E;
  d.isTSTypeParameterDeclaration = NE;
  d.isTSTypeParameterInstantiation = OE;
  d.isTSTypePredicate = Jx;
  d.isTSTypeQuery = $x;
  d.isTSTypeReference = Xx;
  d.isTSUndefinedKeyword = qx;
  d.isTSUnionType = tE;
  d.isTSUnknownKeyword = Vx;
  d.isTSVoidKeyword = Ux;
  d.isTaggedTemplateExpression = yb;
  d.isTemplateElement = Tb;
  d.isTemplateLiteral = gb;
  d.isTerminatorless = RE;
  d.isThisExpression = qg;
  d.isThisTypeAnnotation = SS;
  d.isThrowStatement = Vg;
  d.isTopicReference = Tx;
  d.isTryStatement = Ug;
  d.isTupleExpression = dx;
  d.isTupleTypeAnnotation = xS;
  d.isTypeAlias = PS;
  d.isTypeAnnotation = AS;
  d.isTypeCastExpression = vS;
  d.isTypeParameter = CS;
  d.isTypeParameterDeclaration = IS;
  d.isTypeParameterInstantiation = wS;
  d.isTypeScript = EP;
  d.isTypeofTypeAnnotation = ES;
  d.isUnaryExpression = Kg;
  d.isUnaryLike = aP;
  d.isUnionTypeAnnotation = OS;
  d.isUpdateExpression = Wg;
  d.isUserWhitespacable = rP;
  d.isV8IntrinsicIdentifier = ax;
  d.isVariableDeclaration = Yg;
  d.isVariableDeclarator = Xg;
  d.isVariance = NS;
  d.isVoidTypeAnnotation = _S;
  d.isWhile = KE;
  d.isWhileStatement = Jg;
  d.isWithStatement = $g;
  d.isYieldExpression = bb;
  var T = Ms(), _i = Ni();
  function Q0(e, t) {
    return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Q0, "isArrayExpression");
  function Z0(e, t) {
    return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Z0, "isAssignmentExpression");
  function eg(e, t) {
    return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(eg, "isBinaryExpression");
  function tg(e, t) {
    return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tg, "isInterpreterDirective");
  function rg(e, t) {
    return !e || e.type !== "Directive" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rg, "isDirective");
  function ig(e, t) {
    return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ig, "isDirectiveLiteral");
  function sg(e, t) {
    return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sg, "isBlockStatement");
  function ng(e, t) {
    return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ng, "isBreakStatement");
  function ag(e, t) {
    return !e || e.type !== "CallExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ag, "isCallExpression");
  function og(e, t) {
    return !e || e.type !== "CatchClause" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(og, "isCatchClause");
  function lg(e, t) {
    return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lg, "isConditionalExpression");
  function ug(e, t) {
    return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ug, "isContinueStatement");
  function cg(e, t) {
    return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cg, "isDebuggerStatement");
  function pg(e, t) {
    return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(pg, "isDoWhileStatement");
  function fg(e, t) {
    return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fg, "isEmptyStatement");
  function hg(e, t) {
    return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hg, "isExpressionStatement");
  function dg(e, t) {
    return !e || e.type !== "File" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(dg, "isFile");
  function mg(e, t) {
    return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mg, "isForInStatement");
  function yg(e, t) {
    return !e || e.type !== "ForStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yg, "isForStatement");
  function Tg(e, t) {
    return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Tg, "isFunctionDeclaration");
  function gg(e, t) {
    return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gg, "isFunctionExpression");
  function bg(e, t) {
    return !e || e.type !== "Identifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bg, "isIdentifier");
  function Sg(e, t) {
    return !e || e.type !== "IfStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Sg, "isIfStatement");
  function xg(e, t) {
    return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xg, "isLabeledStatement");
  function Eg(e, t) {
    return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Eg, "isStringLiteral");
  function Pg(e, t) {
    return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Pg, "isNumericLiteral");
  function Ag(e, t) {
    return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ag, "isNullLiteral");
  function vg(e, t) {
    return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(vg, "isBooleanLiteral");
  function Cg(e, t) {
    return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Cg, "isRegExpLiteral");
  function Ig(e, t) {
    return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ig, "isLogicalExpression");
  function wg(e, t) {
    return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wg, "isMemberExpression");
  function Og(e, t) {
    return !e || e.type !== "NewExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Og, "isNewExpression");
  function Ng(e, t) {
    return !e || e.type !== "Program" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ng, "isProgram");
  function _g(e, t) {
    return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(_g, "isObjectExpression");
  function Dg(e, t) {
    return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Dg, "isObjectMethod");
  function kg(e, t) {
    return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(kg, "isObjectProperty");
  function Lg(e, t) {
    return !e || e.type !== "RestElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Lg, "isRestElement");
  function Mg(e, t) {
    return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Mg, "isReturnStatement");
  function Fg(e, t) {
    return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Fg, "isSequenceExpression");
  function Bg(e, t) {
    return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Bg, "isParenthesizedExpression");
  function jg(e, t) {
    return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(jg, "isSwitchCase");
  function Rg(e, t) {
    return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Rg, "isSwitchStatement");
  function qg(e, t) {
    return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(qg, "isThisExpression");
  function Vg(e, t) {
    return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Vg, "isThrowStatement");
  function Ug(e, t) {
    return !e || e.type !== "TryStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ug, "isTryStatement");
  function Kg(e, t) {
    return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Kg, "isUnaryExpression");
  function Wg(e, t) {
    return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Wg, "isUpdateExpression");
  function Yg(e, t) {
    return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Yg, "isVariableDeclaration");
  function Xg(e, t) {
    return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Xg, "isVariableDeclarator");
  function Jg(e, t) {
    return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Jg, "isWhileStatement");
  function $g(e, t) {
    return !e || e.type !== "WithStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s($g, "isWithStatement");
  function Hg(e, t) {
    return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Hg, "isAssignmentPattern");
  function Gg(e, t) {
    return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Gg, "isArrayPattern");
  function zg(e, t) {
    return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(zg, "isArrowFunctionExpression");
  function Qg(e, t) {
    return !e || e.type !== "ClassBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Qg, "isClassBody");
  function Zg(e, t) {
    return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Zg, "isClassExpression");
  function eb(e, t) {
    return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(eb, "isClassDeclaration");
  function tb(e, t) {
    return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tb, "isExportAllDeclaration");
  function rb(e, t) {
    return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rb, "isExportDefaultDeclaration");
  function ib(e, t) {
    return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ib, "isExportNamedDeclaration");
  function sb(e, t) {
    return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sb, "isExportSpecifier");
  function nb(e, t) {
    return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(nb, "isForOfStatement");
  function ab(e, t) {
    return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ab, "isImportDeclaration");
  function ob(e, t) {
    return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ob, "isImportDefaultSpecifier");
  function lb(e, t) {
    return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lb, "isImportNamespaceSpecifier");
  function ub(e, t) {
    return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ub, "isImportSpecifier");
  function cb(e, t) {
    return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cb, "isImportExpression");
  function pb(e, t) {
    return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(pb, "isMetaProperty");
  function fb(e, t) {
    return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fb, "isClassMethod");
  function hb(e, t) {
    return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hb, "isObjectPattern");
  function db(e, t) {
    return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(db, "isSpreadElement");
  function mb(e, t) {
    return !e || e.type !== "Super" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mb, "isSuper");
  function yb(e, t) {
    return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yb, "isTaggedTemplateExpression");
  function Tb(e, t) {
    return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Tb, "isTemplateElement");
  function gb(e, t) {
    return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gb, "isTemplateLiteral");
  function bb(e, t) {
    return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bb, "isYieldExpression");
  function Sb(e, t) {
    return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Sb, "isAwaitExpression");
  function xb(e, t) {
    return !e || e.type !== "Import" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xb, "isImport");
  function Eb(e, t) {
    return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Eb, "isBigIntLiteral");
  function Pb(e, t) {
    return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Pb, "isExportNamespaceSpecifier");
  function Ab(e, t) {
    return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ab, "isOptionalMemberExpression");
  function vb(e, t) {
    return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(vb, "isOptionalCallExpression");
  function Cb(e, t) {
    return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Cb, "isClassProperty");
  function Ib(e, t) {
    return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ib, "isClassAccessorProperty");
  function wb(e, t) {
    return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wb, "isClassPrivateProperty");
  function Ob(e, t) {
    return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ob, "isClassPrivateMethod");
  function Nb(e, t) {
    return !e || e.type !== "PrivateName" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Nb, "isPrivateName");
  function _b(e, t) {
    return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(_b, "isStaticBlock");
  function Db(e, t) {
    return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Db, "isAnyTypeAnnotation");
  function kb(e, t) {
    return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(kb, "isArrayTypeAnnotation");
  function Lb(e, t) {
    return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Lb, "isBooleanTypeAnnotation");
  function Mb(e, t) {
    return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Mb, "isBooleanLiteralTypeAnnotation");
  function Fb(e, t) {
    return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Fb, "isNullLiteralTypeAnnotation");
  function Bb(e, t) {
    return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Bb, "isClassImplements");
  function jb(e, t) {
    return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(jb, "isDeclareClass");
  function Rb(e, t) {
    return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Rb, "isDeclareFunction");
  function qb(e, t) {
    return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(qb, "isDeclareInterface");
  function Vb(e, t) {
    return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Vb, "isDeclareModule");
  function Ub(e, t) {
    return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ub, "isDeclareModuleExports");
  function Kb(e, t) {
    return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Kb, "isDeclareTypeAlias");
  function Wb(e, t) {
    return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Wb, "isDeclareOpaqueType");
  function Yb(e, t) {
    return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Yb, "isDeclareVariable");
  function Xb(e, t) {
    return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Xb, "isDeclareExportDeclaration");
  function Jb(e, t) {
    return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Jb, "isDeclareExportAllDeclaration");
  function $b(e, t) {
    return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, T.default)(e, t);
  }
  s($b, "isDeclaredPredicate");
  function Hb(e, t) {
    return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Hb, "isExistsTypeAnnotation");
  function Gb(e, t) {
    return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Gb, "isFunctionTypeAnnotation");
  function zb(e, t) {
    return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(zb, "isFunctionTypeParam");
  function Qb(e, t) {
    return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Qb, "isGenericTypeAnnotation");
  function Zb(e, t) {
    return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Zb, "isInferredPredicate");
  function eS(e, t) {
    return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(eS, "isInterfaceExtends");
  function tS(e, t) {
    return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tS, "isInterfaceDeclaration");
  function rS(e, t) {
    return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rS, "isInterfaceTypeAnnotation");
  function iS(e, t) {
    return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(iS, "isIntersectionTypeAnnotation");
  function sS(e, t) {
    return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sS, "isMixedTypeAnnotation");
  function nS(e, t) {
    return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(nS, "isEmptyTypeAnnotation");
  function aS(e, t) {
    return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(aS, "isNullableTypeAnnotation");
  function oS(e, t) {
    return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(oS, "isNumberLiteralTypeAnnotation");
  function lS(e, t) {
    return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lS, "isNumberTypeAnnotation");
  function uS(e, t) {
    return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(uS, "isObjectTypeAnnotation");
  function cS(e, t) {
    return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cS, "isObjectTypeInternalSlot");
  function pS(e, t) {
    return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(pS, "isObjectTypeCallProperty");
  function fS(e, t) {
    return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fS, "isObjectTypeIndexer");
  function hS(e, t) {
    return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hS, "isObjectTypeProperty");
  function dS(e, t) {
    return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(dS, "isObjectTypeSpreadProperty");
  function mS(e, t) {
    return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mS, "isOpaqueType");
  function yS(e, t) {
    return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yS, "isQualifiedTypeIdentifier");
  function TS(e, t) {
    return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(TS, "isStringLiteralTypeAnnotation");
  function gS(e, t) {
    return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gS, "isStringTypeAnnotation");
  function bS(e, t) {
    return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bS, "isSymbolTypeAnnotation");
  function SS(e, t) {
    return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(SS, "isThisTypeAnnotation");
  function xS(e, t) {
    return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xS, "isTupleTypeAnnotation");
  function ES(e, t) {
    return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ES, "isTypeofTypeAnnotation");
  function PS(e, t) {
    return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(PS, "isTypeAlias");
  function AS(e, t) {
    return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(AS, "isTypeAnnotation");
  function vS(e, t) {
    return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(vS, "isTypeCastExpression");
  function CS(e, t) {
    return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(CS, "isTypeParameter");
  function IS(e, t) {
    return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(IS, "isTypeParameterDeclaration");
  function wS(e, t) {
    return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wS, "isTypeParameterInstantiation");
  function OS(e, t) {
    return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(OS, "isUnionTypeAnnotation");
  function NS(e, t) {
    return !e || e.type !== "Variance" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(NS, "isVariance");
  function _S(e, t) {
    return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(_S, "isVoidTypeAnnotation");
  function DS(e, t) {
    return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(DS, "isEnumDeclaration");
  function kS(e, t) {
    return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(kS, "isEnumBooleanBody");
  function LS(e, t) {
    return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(LS, "isEnumNumberBody");
  function MS(e, t) {
    return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(MS, "isEnumStringBody");
  function FS(e, t) {
    return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(FS, "isEnumSymbolBody");
  function BS(e, t) {
    return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(BS, "isEnumBooleanMember");
  function jS(e, t) {
    return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(jS, "isEnumNumberMember");
  function RS(e, t) {
    return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(RS, "isEnumStringMember");
  function qS(e, t) {
    return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(qS, "isEnumDefaultedMember");
  function VS(e, t) {
    return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(VS, "isIndexedAccessType");
  function US(e, t) {
    return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(US, "isOptionalIndexedAccessType");
  function KS(e, t) {
    return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(KS, "isJSXAttribute");
  function WS(e, t) {
    return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(WS, "isJSXClosingElement");
  function YS(e, t) {
    return !e || e.type !== "JSXElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(YS, "isJSXElement");
  function XS(e, t) {
    return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(XS, "isJSXEmptyExpression");
  function JS(e, t) {
    return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(JS, "isJSXExpressionContainer");
  function $S(e, t) {
    return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, T.default)(e, t);
  }
  s($S, "isJSXSpreadChild");
  function HS(e, t) {
    return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(HS, "isJSXIdentifier");
  function GS(e, t) {
    return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(GS, "isJSXMemberExpression");
  function zS(e, t) {
    return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(zS, "isJSXNamespacedName");
  function QS(e, t) {
    return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(QS, "isJSXOpeningElement");
  function ZS(e, t) {
    return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ZS, "isJSXSpreadAttribute");
  function ex(e, t) {
    return !e || e.type !== "JSXText" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ex, "isJSXText");
  function tx(e, t) {
    return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tx, "isJSXFragment");
  function rx(e, t) {
    return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rx, "isJSXOpeningFragment");
  function ix(e, t) {
    return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ix, "isJSXClosingFragment");
  function sx(e, t) {
    return !e || e.type !== "Noop" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sx, "isNoop");
  function nx(e, t) {
    return !e || e.type !== "Placeholder" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(nx, "isPlaceholder");
  function ax(e, t) {
    return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ax, "isV8IntrinsicIdentifier");
  function ox(e, t) {
    return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ox, "isArgumentPlaceholder");
  function lx(e, t) {
    return !e || e.type !== "BindExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lx, "isBindExpression");
  function ux(e, t) {
    return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ux, "isImportAttribute");
  function cx(e, t) {
    return !e || e.type !== "Decorator" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cx, "isDecorator");
  function px(e, t) {
    return !e || e.type !== "DoExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(px, "isDoExpression");
  function fx(e, t) {
    return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fx, "isExportDefaultSpecifier");
  function hx(e, t) {
    return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hx, "isRecordExpression");
  function dx(e, t) {
    return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(dx, "isTupleExpression");
  function mx(e, t) {
    return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mx, "isDecimalLiteral");
  function yx(e, t) {
    return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yx, "isModuleExpression");
  function Tx(e, t) {
    return !e || e.type !== "TopicReference" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Tx, "isTopicReference");
  function gx(e, t) {
    return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gx, "isPipelineTopicExpression");
  function bx(e, t) {
    return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bx, "isPipelineBareFunction");
  function Sx(e, t) {
    return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Sx, "isPipelinePrimaryTopicReference");
  function xx(e, t) {
    return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xx, "isTSParameterProperty");
  function Ex(e, t) {
    return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ex, "isTSDeclareFunction");
  function Px(e, t) {
    return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Px, "isTSDeclareMethod");
  function Ax(e, t) {
    return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ax, "isTSQualifiedName");
  function vx(e, t) {
    return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(vx, "isTSCallSignatureDeclaration");
  function Cx(e, t) {
    return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Cx, "isTSConstructSignatureDeclaration");
  function Ix(e, t) {
    return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ix, "isTSPropertySignature");
  function wx(e, t) {
    return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wx, "isTSMethodSignature");
  function Ox(e, t) {
    return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ox, "isTSIndexSignature");
  function Nx(e, t) {
    return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Nx, "isTSAnyKeyword");
  function _x(e, t) {
    return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(_x, "isTSBooleanKeyword");
  function Dx(e, t) {
    return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Dx, "isTSBigIntKeyword");
  function kx(e, t) {
    return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(kx, "isTSIntrinsicKeyword");
  function Lx(e, t) {
    return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Lx, "isTSNeverKeyword");
  function Mx(e, t) {
    return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Mx, "isTSNullKeyword");
  function Fx(e, t) {
    return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Fx, "isTSNumberKeyword");
  function Bx(e, t) {
    return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Bx, "isTSObjectKeyword");
  function jx(e, t) {
    return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(jx, "isTSStringKeyword");
  function Rx(e, t) {
    return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Rx, "isTSSymbolKeyword");
  function qx(e, t) {
    return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(qx, "isTSUndefinedKeyword");
  function Vx(e, t) {
    return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Vx, "isTSUnknownKeyword");
  function Ux(e, t) {
    return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ux, "isTSVoidKeyword");
  function Kx(e, t) {
    return !e || e.type !== "TSThisType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Kx, "isTSThisType");
  function Wx(e, t) {
    return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Wx, "isTSFunctionType");
  function Yx(e, t) {
    return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Yx, "isTSConstructorType");
  function Xx(e, t) {
    return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Xx, "isTSTypeReference");
  function Jx(e, t) {
    return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Jx, "isTSTypePredicate");
  function $x(e, t) {
    return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, T.default)(e, t);
  }
  s($x, "isTSTypeQuery");
  function Hx(e, t) {
    return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Hx, "isTSTypeLiteral");
  function Gx(e, t) {
    return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Gx, "isTSArrayType");
  function zx(e, t) {
    return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(zx, "isTSTupleType");
  function Qx(e, t) {
    return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Qx, "isTSOptionalType");
  function Zx(e, t) {
    return !e || e.type !== "TSRestType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Zx, "isTSRestType");
  function eE(e, t) {
    return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(eE, "isTSNamedTupleMember");
  function tE(e, t) {
    return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tE, "isTSUnionType");
  function rE(e, t) {
    return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rE, "isTSIntersectionType");
  function iE(e, t) {
    return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(iE, "isTSConditionalType");
  function sE(e, t) {
    return !e || e.type !== "TSInferType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sE, "isTSInferType");
  function nE(e, t) {
    return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(nE, "isTSParenthesizedType");
  function aE(e, t) {
    return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(aE, "isTSTypeOperator");
  function oE(e, t) {
    return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(oE, "isTSIndexedAccessType");
  function lE(e, t) {
    return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lE, "isTSMappedType");
  function uE(e, t) {
    return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(uE, "isTSLiteralType");
  function cE(e, t) {
    return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cE, "isTSExpressionWithTypeArguments");
  function pE(e, t) {
    return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(pE, "isTSInterfaceDeclaration");
  function fE(e, t) {
    return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fE, "isTSInterfaceBody");
  function hE(e, t) {
    return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hE, "isTSTypeAliasDeclaration");
  function dE(e, t) {
    return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(dE, "isTSInstantiationExpression");
  function mE(e, t) {
    return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mE, "isTSAsExpression");
  function yE(e, t) {
    return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yE, "isTSSatisfiesExpression");
  function TE(e, t) {
    return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(TE, "isTSTypeAssertion");
  function gE(e, t) {
    return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gE, "isTSEnumDeclaration");
  function bE(e, t) {
    return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bE, "isTSEnumMember");
  function SE(e, t) {
    return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(SE, "isTSModuleDeclaration");
  function xE(e, t) {
    return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xE, "isTSModuleBlock");
  function EE(e, t) {
    return !e || e.type !== "TSImportType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(EE, "isTSImportType");
  function PE(e, t) {
    return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(PE, "isTSImportEqualsDeclaration");
  function AE(e, t) {
    return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(AE, "isTSExternalModuleReference");
  function vE(e, t) {
    return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(vE, "isTSNonNullExpression");
  function CE(e, t) {
    return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(CE, "isTSExportAssignment");
  function IE(e, t) {
    return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(IE, "isTSNamespaceExportDeclaration");
  function wE(e, t) {
    return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wE, "isTSTypeAnnotation");
  function OE(e, t) {
    return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(OE, "isTSTypeParameterInstantiation");
  function NE(e, t) {
    return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(NE, "isTSTypeParameterDeclaration");
  function _E(e, t) {
    return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(_E, "isTSTypeParameter");
  function DE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(DE, "isStandardized");
  function kE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(kE, "isExpression");
  function LE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(LE, "isBinary");
  function ME(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(ME, "isScopable");
  function FE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(FE, "isBlockParent");
  function BE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(BE, "isBlock");
  function jE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(jE, "isStatement");
  function RE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(RE, "isTerminatorless");
  function qE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(qE, "isCompletionStatement");
  function VE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(VE, "isConditional");
  function UE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(UE, "isLoop");
  function KE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(KE, "isWhile");
  function WE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(WE, "isExpressionWrapper");
  function YE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(YE, "isFor");
  function XE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(XE, "isForXStatement");
  function JE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(JE, "isFunction");
  function $E(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s($E, "isFunctionParent");
  function HE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(HE, "isPureish");
  function GE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (e.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(GE, "isDeclaration");
  function zE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(zE, "isPatternLike");
  function QE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(QE, "isLVal");
  function ZE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(ZE, "isTSEntityName");
  function eP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(eP, "isLiteral");
  function tP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(tP, "isImmutable");
  function rP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(rP, "isUserWhitespacable");
  function iP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(iP, "isMethod");
  function sP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(sP, "isObjectMember");
  function nP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(nP, "isProperty");
  function aP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(aP, "isUnaryLike");
  function oP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(oP, "isPattern");
  function lP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(lP, "isClass");
  function Sp(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(Sp, "isImportOrExportDeclaration");
  function uP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(uP, "isExportDeclaration");
  function cP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(cP, "isModuleSpecifier");
  function pP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(pP, "isAccessor");
  function fP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(fP, "isPrivate");
  function hP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(hP, "isFlow");
  function dP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(dP, "isFlowType");
  function mP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(mP, "isFlowBaseAnnotation");
  function yP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(yP, "isFlowDeclaration");
  function TP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(TP, "isFlowPredicate");
  function gP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(gP, "isEnumBody");
  function bP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(bP, "isEnumMember");
  function SP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(SP, "isJSX");
  function xP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(xP, "isMiscellaneous");
  function EP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(EP, "isTypeScript");
  function PP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(PP, "isTSTypeElement");
  function AP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(AP, "isTSType");
  function vP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(vP, "isTSBaseType");
  function CP(e, t) {
    return (0, _i.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(CP, "isNumberLiteral");
  function IP(e, t) {
    return (0, _i.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(IP, "isRegexLiteral");
  function wP(e, t) {
    return (0, _i.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wP, "isRestProperty");
  function OP(e, t) {
    return (0, _i.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(OP, "isSpreadProperty");
  function NP(e, t) {
    return (0, _i.default)("isModuleDeclaration", "isImportOrExportDeclaration"), Sp(e, t);
  }
  s(NP, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var xa = v((Sa) => {
  "use strict";
  Object.defineProperty(Sa, "__esModule", {
    value: !0
  });
  Sa.default = _P;
  var Di = We();
  function _P(e, t, r) {
    if (!(0, Di.isMemberExpression)(e)) return !1;
    let i = Array.isArray(t) ? t : t.split("."), n = [], a;
    for (a = e; (0, Di.isMemberExpression)(a); a = a.object)
      n.push(a.property);
    if (n.push(a), n.length < i.length || !r && n.length > i.length) return !1;
    for (let o = 0, l = n.length - 1; o < i.length; o++, l--) {
      let u = n[l], c;
      if ((0, Di.isIdentifier)(u))
        c = u.name;
      else if ((0, Di.isStringLiteral)(u))
        c = u.value;
      else if ((0, Di.isThisExpression)(u))
        c = "this";
      else
        return !1;
      if (i[o] !== c) return !1;
    }
    return !0;
  }
  s(_P, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var Pa = v((Ea) => {
  "use strict";
  Object.defineProperty(Ea, "__esModule", {
    value: !0
  });
  Ea.default = kP;
  var DP = xa();
  function kP(e, t) {
    let r = e.split(".");
    return (i) => (0, DP.default)(i, r, t);
  }
  s(kP, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var xp = v((Fs) => {
  "use strict";
  Object.defineProperty(Fs, "__esModule", {
    value: !0
  });
  Fs.default = void 0;
  var LP = Pa(), MP = (0, LP.default)("React.Component"), JJ = Fs.default = MP;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var Ep = v((Aa) => {
  "use strict";
  Object.defineProperty(Aa, "__esModule", {
    value: !0
  });
  Aa.default = FP;
  function FP(e) {
    return !!e && /^[a-z]/.test(e);
  }
  s(FP, "isCompatTag");
});

// ../node_modules/to-fast-properties/index.js
var Ap = v((zJ, Pp) => {
  "use strict";
  var ki = null;
  function Li(e) {
    if (ki !== null && typeof ki.property) {
      let t = ki;
      return ki = Li.prototype = null, t;
    }
    return ki = Li.prototype = e ?? /* @__PURE__ */ Object.create(null), new Li();
  }
  s(Li, "FastObject");
  Li();
  Pp.exports = /* @__PURE__ */ s(function(t) {
    return Li(t);
  }, "toFastproperties");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var Bs = v((va) => {
  "use strict";
  Object.defineProperty(va, "__esModule", {
    value: !0
  });
  va.default = BP;
  var vp = Et();
  function BP(e, t) {
    if (e === t) return !0;
    if (e == null || vp.ALIAS_KEYS[t]) return !1;
    let r = vp.FLIPPED_ALIAS_KEYS[t];
    if (r) {
      if (r[0] === e) return !0;
      for (let i of r)
        if (e === i) return !0;
    }
    return !1;
  }
  s(BP, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var Ia = v((Ca) => {
  "use strict";
  Object.defineProperty(Ca, "__esModule", {
    value: !0
  });
  Ca.default = RP;
  var jP = Et();
  function RP(e, t) {
    if (e === t) return !0;
    let r = jP.PLACEHOLDERS_ALIAS[e];
    if (r) {
      for (let i of r)
        if (t === i) return !0;
    }
    return !1;
  }
  s(RP, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var zr = v((wa) => {
  "use strict";
  Object.defineProperty(wa, "__esModule", {
    value: !0
  });
  wa.default = WP;
  var qP = Ms(), VP = Bs(), UP = Ia(), KP = Et();
  function WP(e, t, r) {
    return t ? (0, VP.default)(t.type, e) ? typeof r > "u" ? !0 : (0, qP.default)(t, r) : !r && t.type === "Placeholder" && e in KP.FLIPPED_ALIAS_KEYS ?
    (0, UP.default)(t.expectedNode, e) : !1 : !1;
  }
  s(WP, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var Np = v((Mi) => {
  "use strict";
  Object.defineProperty(Mi, "__esModule", {
    value: !0
  });
  Mi.isIdentifierChar = Op;
  Mi.isIdentifierName = $P;
  Mi.isIdentifierStart = wp;
  var Na = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  Cp = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", YP = new RegExp("[" + Na + "]"), XP = new RegExp("[" + Na + Cp + "]");
  Na = Cp = null;
  var Ip = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], JP = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2,
  5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6,
  1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Oa(e, t) {
    let r = 65536;
    for (let i = 0, n = t.length; i < n; i += 2) {
      if (r += t[i], r > e) return !1;
      if (r += t[i + 1], r >= e) return !0;
    }
    return !1;
  }
  s(Oa, "isInAstralSet");
  function wp(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && YP.test(String.fromCharCode(e)) :
    Oa(e, Ip);
  }
  s(wp, "isIdentifierStart");
  function Op(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && XP.test(
    String.fromCharCode(e)) : Oa(e, Ip) || Oa(e, JP);
  }
  s(Op, "isIdentifierChar");
  function $P(e) {
    let t = !0;
    for (let r = 0; r < e.length; r++) {
      let i = e.charCodeAt(r);
      if ((i & 64512) === 55296 && r + 1 < e.length) {
        let n = e.charCodeAt(++r);
        (n & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (n & 1023));
      }
      if (t) {
        if (t = !1, !wp(i))
          return !1;
      } else if (!Op(i))
        return !1;
    }
    return !t;
  }
  s($P, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var Lp = v((Or) => {
  "use strict";
  Object.defineProperty(Or, "__esModule", {
    value: !0
  });
  Or.isKeyword = ZP;
  Or.isReservedWord = _p;
  Or.isStrictBindOnlyReservedWord = kp;
  Or.isStrictBindReservedWord = QP;
  Or.isStrictReservedWord = Dp;
  var _a = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, HP = new Set(_a.keyword), GP = new Set(_a.strict), zP = new Set(_a.strictBind);
  function _p(e, t) {
    return t && e === "await" || e === "enum";
  }
  s(_p, "isReservedWord");
  function Dp(e, t) {
    return _p(e, t) || GP.has(e);
  }
  s(Dp, "isStrictReservedWord");
  function kp(e) {
    return zP.has(e);
  }
  s(kp, "isStrictBindOnlyReservedWord");
  function QP(e, t) {
    return Dp(e, t) || kp(e);
  }
  s(QP, "isStrictBindReservedWord");
  function ZP(e) {
    return HP.has(e);
  }
  s(ZP, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var Bi = v((Bt) => {
  "use strict";
  Object.defineProperty(Bt, "__esModule", {
    value: !0
  });
  Object.defineProperty(Bt, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Da.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(Bt, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Da.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(Bt, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Da.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(Bt, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Fi.isKeyword;
    }, "get")
  });
  Object.defineProperty(Bt, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Fi.isReservedWord;
    }, "get")
  });
  Object.defineProperty(Bt, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Fi.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(Bt, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Fi.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(Bt, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Fi.isStrictReservedWord;
    }, "get")
  });
  var Da = Np(), Fi = Lp();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var Qr = v((La) => {
  "use strict";
  Object.defineProperty(La, "__esModule", {
    value: !0
  });
  La.default = eA;
  var ka = Bi();
  function eA(e, t = !0) {
    return typeof e != "string" || t && ((0, ka.isKeyword)(e) || (0, ka.isStrictReservedWord)(e, !0)) ? !1 : (0, ka.isIdentifierName)(e);
  }
  s(eA, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var jp = v((ji) => {
  "use strict";
  Object.defineProperty(ji, "__esModule", {
    value: !0
  });
  ji.readCodePoint = Bp;
  ji.readInt = Fp;
  ji.readStringContents = rA;
  var tA = /* @__PURE__ */ s(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), Mp = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, js = {
    bin: /* @__PURE__ */ s((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ s((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ s((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ s((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function rA(e, t, r, i, n, a) {
    let o = r, l = i, u = n, c = "", p = null, g = r, {
      length: P
    } = t;
    for (; ; ) {
      if (r >= P) {
        a.unterminated(o, l, u), c += t.slice(g, r);
        break;
      }
      let A = t.charCodeAt(r);
      if (iA(e, A, t, r)) {
        c += t.slice(g, r);
        break;
      }
      if (A === 92) {
        c += t.slice(g, r);
        let C = sA(t, r, i, n, e === "template", a);
        C.ch === null && !p ? p = {
          pos: r,
          lineStart: i,
          curLine: n
        } : c += C.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = C, g = r;
      } else A === 8232 || A === 8233 ? (++r, ++n, i = r) : A === 10 || A === 13 ? e === "template" ? (c += t.slice(g, r) + `
`, ++r, A === 13 && t.charCodeAt(r) === 10 && ++r, ++n, g = i = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: n,
      containsInvalid: !!p
    };
  }
  s(rA, "readStringContents");
  function iA(e, t, r, i) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  s(iA, "isStringEnd");
  function sA(e, t, r, i, n, a) {
    let o = !n;
    t++;
    let l = /* @__PURE__ */ s((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: i
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = Ma(e, t, r, i, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = Bp(e, t, r, i, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(t - 1, r, i);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, g = e.slice(c, t + 2).match(/^[0-7]+/)[0], P = parseInt(g, 8);
          P > 255 && (g = g.slice(0, -1), P = parseInt(g, 8)), t += g.length - 1;
          let A = e.charCodeAt(t);
          if (g !== "0" || A === 56 || A === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(c, r, i);
          }
          return l(String.fromCharCode(P));
        }
        return l(String.fromCharCode(u));
    }
  }
  s(sA, "readEscapedChar");
  function Ma(e, t, r, i, n, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = Fp(e, t, r, i, 16, n, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, i) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  s(Ma, "readHexChar");
  function Fp(e, t, r, i, n, a, o, l, u, c) {
    let p = t, g = n === 16 ? Mp.hex : Mp.decBinOct, P = n === 16 ? js.hex : n === 10 ? js.dec : n === 8 ? js.oct : js.bin, A = !1, C = 0;
    for (let _ = 0, k = a ?? 1 / 0; _ < k; ++_) {
      let O = e.charCodeAt(t), M;
      if (O === 95 && l !== "bail") {
        let F = e.charCodeAt(t - 1), G = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(G) || !P(G) || g.has(F) || g.has(G)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, i);
        }
        ++t;
        continue;
      }
      if (O >= 97 ? M = O - 97 + 10 : O >= 65 ? M = O - 65 + 10 : tA(O) ? M = O - 48 : M = 1 / 0, M >= n) {
        if (M <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (M <= 9 && u.invalidDigit(t, r, i, n))
          M = 0;
        else if (o)
          M = 0, A = !0;
        else
          break;
      }
      ++t, C = C * n + M;
    }
    return t === p || a != null && t - p !== a || A ? {
      n: null,
      pos: t
    } : {
      n: C,
      pos: t
    };
  }
  s(Fp, "readInt");
  function Bp(e, t, r, i, n, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = Ma(e, t, r, i, e.indexOf("}", t) - t, !0, n, a), ++t, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(t, r, i);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = Ma(e, t, r, i, 4, !1, n, a));
    return {
      code: l,
      pos: t
    };
  }
  s(Bp, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var ir = v((pe) => {
  "use strict";
  Object.defineProperty(pe, "__esModule", {
    value: !0
  });
  pe.UPDATE_OPERATORS = pe.UNARY_OPERATORS = pe.STRING_UNARY_OPERATORS = pe.STATEMENT_OR_BLOCK_KEYS = pe.NUMBER_UNARY_OPERATORS = pe.NUMBER_BINARY_OPERATORS =
  pe.NOT_LOCAL_BINDING = pe.LOGICAL_OPERATORS = pe.INHERIT_KEYS = pe.FOR_INIT_KEYS = pe.FLATTENABLE_KEYS = pe.EQUALITY_BINARY_OPERATORS = pe.
  COMPARISON_BINARY_OPERATORS = pe.COMMENT_KEYS = pe.BOOLEAN_UNARY_OPERATORS = pe.BOOLEAN_NUMBER_BINARY_OPERATORS = pe.BOOLEAN_BINARY_OPERATORS =
  pe.BLOCK_SCOPED_SYMBOL = pe.BINARY_OPERATORS = pe.ASSIGNMENT_OPERATORS = void 0;
  var m$ = pe.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], y$ = pe.FLATTENABLE_KEYS = ["body", "expressions"], T$ = pe.FOR_INIT_KEYS =
  ["left", "init"], g$ = pe.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], nA = pe.LOGICAL_OPERATORS = ["||", "&&",
  "??"], b$ = pe.UPDATE_OPERATORS = ["++", "--"], aA = pe.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], oA = pe.EQUALITY_BINARY_OPERATORS =
  ["==", "===", "!=", "!=="], lA = pe.COMPARISON_BINARY_OPERATORS = [...oA, "in", "instanceof"], uA = pe.BOOLEAN_BINARY_OPERATORS = [...lA, ...aA],
  Rp = pe.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], S$ = pe.BINARY_OPERATORS = ["+", ...Rp, ...uA,
  "|>"], x$ = pe.ASSIGNMENT_OPERATORS = ["=", "+=", ...Rp.map((e) => e + "="), ...nA.map((e) => e + "=")], cA = pe.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], pA = pe.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], fA = pe.STRING_UNARY_OPERATORS = ["typeof"], E$ = pe.UNARY_OPERATORS = [
  "void", "throw", ...cA, ...pA, ...fA], P$ = pe.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, A$ = pe.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), v$ = pe.NOT_LOCAL_BINDING = Symbol.for("should not be consider\
ed a local binding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var Ut = v((ge) => {
  "use strict";
  Object.defineProperty(ge, "__esModule", {
    value: !0
  });
  ge.VISITOR_KEYS = ge.NODE_PARENT_VALIDATIONS = ge.NODE_FIELDS = ge.FLIPPED_ALIAS_KEYS = ge.DEPRECATED_KEYS = ge.BUILDER_KEYS = ge.ALIAS_KEYS =
  void 0;
  ge.arrayOf = Vp;
  ge.arrayOfType = Up;
  ge.assertEach = Kp;
  ge.assertNodeOrValueType = AA;
  ge.assertNodeType = Ba;
  ge.assertOneOf = PA;
  ge.assertOptionalChainStart = CA;
  ge.assertShape = vA;
  ge.assertValueType = qa;
  ge.chain = Wp;
  ge.default = Yp;
  ge.defineAliasedType = OA;
  ge.typeIs = Vs;
  ge.validate = Ra;
  ge.validateArrayOfType = EA;
  ge.validateOptional = SA;
  ge.validateOptionalType = xA;
  ge.validateType = bA;
  var qp = zr(), qs = Us(), hA = ge.VISITOR_KEYS = {}, dA = ge.ALIAS_KEYS = {}, Fa = ge.FLIPPED_ALIAS_KEYS = {}, mA = ge.NODE_FIELDS = {}, yA = ge.
  BUILDER_KEYS = {}, TA = ge.DEPRECATED_KEYS = {}, gA = ge.NODE_PARENT_VALIDATIONS = {};
  function Rs(e) {
    return Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
  }
  s(Rs, "getType");
  function Ra(e) {
    return {
      validate: e
    };
  }
  s(Ra, "validate");
  function Vs(e) {
    return typeof e == "string" ? Ba(e) : Ba(...e);
  }
  s(Vs, "typeIs");
  function bA(e) {
    return Ra(Vs(e));
  }
  s(bA, "validateType");
  function SA(e) {
    return {
      validate: e,
      optional: !0
    };
  }
  s(SA, "validateOptional");
  function xA(e) {
    return {
      validate: Vs(e),
      optional: !0
    };
  }
  s(xA, "validateOptionalType");
  function Vp(e) {
    return Wp(qa("array"), Kp(e));
  }
  s(Vp, "arrayOf");
  function Up(e) {
    return Vp(Vs(e));
  }
  s(Up, "arrayOfType");
  function EA(e) {
    return Ra(Up(e));
  }
  s(EA, "validateArrayOfType");
  function Kp(e) {
    function t(r, i, n) {
      if (Array.isArray(n))
        for (let a = 0; a < n.length; a++) {
          let o = `${i}[${a}]`, l = n[a];
          e(r, o, l), process.env.BABEL_TYPES_8_BREAKING && (0, qs.validateChild)(r, o, l);
        }
    }
    return s(t, "validator"), t.each = e, t;
  }
  s(Kp, "assertEach");
  function PA(...e) {
    function t(r, i, n) {
      if (e.indexOf(n) < 0)
        throw new TypeError(`Property ${i} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(n)}`);
    }
    return s(t, "validate"), t.oneOf = e, t;
  }
  s(PA, "assertOneOf");
  function Ba(...e) {
    function t(r, i, n) {
      for (let a of e)
        if ((0, qp.default)(a, n)) {
          (0, qs.validateChild)(r, i, n);
          return;
        }
      throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return s(t, "validate"), t.oneOfNodeTypes = e, t;
  }
  s(Ba, "assertNodeType");
  function AA(...e) {
    function t(r, i, n) {
      for (let a of e)
        if (Rs(n) === a || (0, qp.default)(a, n)) {
          (0, qs.validateChild)(r, i, n);
          return;
        }
      throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return s(t, "validate"), t.oneOfNodeOrValueTypes = e, t;
  }
  s(AA, "assertNodeOrValueType");
  function qa(e) {
    function t(r, i, n) {
      if (!(Rs(n) === e))
        throw new TypeError(`Property ${i} expected type of ${e} but got ${Rs(n)}`);
    }
    return s(t, "validate"), t.type = e, t;
  }
  s(qa, "assertValueType");
  function vA(e) {
    function t(r, i, n) {
      let a = [];
      for (let o of Object.keys(e))
        try {
          (0, qs.validateField)(r, o, n[o], e[o]);
        } catch (l) {
          if (l instanceof TypeError) {
            a.push(l.message);
            continue;
          }
          throw l;
        }
      if (a.length)
        throw new TypeError(`Property ${i} of ${r.type} expected to have the following:
${a.join(`
`)}`);
    }
    return s(t, "validate"), t.shapeOf = e, t;
  }
  s(vA, "assertShape");
  function CA() {
    function e(t) {
      var r;
      let i = t;
      for (; t; ) {
        let {
          type: n
        } = i;
        if (n === "OptionalCallExpression") {
          if (i.optional) return;
          i = i.callee;
          continue;
        }
        if (n === "OptionalMemberExpression") {
          if (i.optional) return;
          i = i.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = i) == null ? void 0 : r.type}`);
    }
    return s(e, "validate"), e;
  }
  s(CA, "assertOptionalChainStart");
  function Wp(...e) {
    function t(...r) {
      for (let i of e)
        i(...r);
    }
    if (s(t, "validate"), t.chainOf = e, e.length >= 2 && "type" in e[0] && e[0].type === "array" && !("each" in e[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return t;
  }
  s(Wp, "chain");
  var IA = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], wA = ["default", "optional", "deprecated",
  "validate"], ja = {};
  function OA(...e) {
    return (t, r = {}) => {
      let i = r.aliases;
      if (!i) {
        var n, a;
        r.inherits && (i = (n = ja[r.inherits].aliases) == null ? void 0 : n.slice()), (a = i) != null || (i = []), r.aliases = i;
      }
      let o = e.filter((l) => !i.includes(l));
      i.unshift(...o), Yp(t, r);
    };
  }
  s(OA, "defineAliasedType");
  function Yp(e, t = {}) {
    let r = t.inherits && ja[t.inherits] || {}, i = t.fields;
    if (!i && (i = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let c = r.fields[u], p = c.default;
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        i[u] = {
          default: Array.isArray(p) ? [] : p,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let n = t.visitor || r.visitor || [], a = t.aliases || r.aliases || [], o = t.builder || r.builder || t.visitor || [];
    for (let l of Object.keys(t))
      if (IA.indexOf(l) === -1)
        throw new Error(`Unknown type option "${l}" on ${e}`);
    t.deprecatedAlias && (TA[t.deprecatedAlias] = e);
    for (let l of n.concat(o))
      i[l] = i[l] || {};
    for (let l of Object.keys(i)) {
      let u = i[l];
      u.default !== void 0 && o.indexOf(l) === -1 && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default !=
      null && (u.validate = qa(Rs(u.default)));
      for (let c of Object.keys(u))
        if (wA.indexOf(c) === -1)
          throw new Error(`Unknown field key "${c}" on ${e}.${l}`);
    }
    hA[e] = t.visitor = n, yA[e] = t.builder = o, mA[e] = t.fields = i, dA[e] = t.aliases = a, a.forEach((l) => {
      Fa[l] = Fa[l] || [], Fa[l].push(e);
    }), t.validate && (gA[e] = t.validate), ja[e] = t;
  }
  s(Yp, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var Ua = v((yt) => {
  "use strict";
  Object.defineProperty(yt, "__esModule", {
    value: !0
  });
  yt.patternLikeCommon = yt.functionTypeAnnotationCommon = yt.functionDeclarationCommon = yt.functionCommon = yt.classMethodOrPropertyCommon =
  yt.classMethodOrDeclareMethodCommon = void 0;
  var at = zr(), NA = Qr(), Xp = Bi(), _A = jp(), Ri = ir(), f = Ut(), q = (0, f.defineAliasedType)("Standardized");
  q("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeOrValueType)("null", "Expression", "Spread\
Element"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  q("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, f.assertValueType)("string");
          let e = (0, f.assertOneOf)(...Ri.ASSIGNMENT_OPERATORS), t = (0, f.assertOneOf)("=");
          return function(r, i, n) {
            ((0, at.default)("Pattern", r.left) ? t : e)(r, i, n);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, f.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  q("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, f.assertOneOf)(...Ri.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let e = (0, f.assertNodeType)("Expression"), t = (0, f.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(i, n, a) {
            (i.operator === "in" ? t : e)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  q("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("string")
      }
    }
  });
  q("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, f.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  q("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("string")
      }
    }
  });
  q("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  q("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  q("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, f.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, f.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  q("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, f.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  q("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, f.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, f.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  q("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  q("DebuggerStatement", {
    aliases: ["Statement"]
  });
  q("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  q("EmptyStatement", {
    aliases: ["Statement"]
  });
  q("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, f.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  q("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, f.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertEach)((0, f.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, f.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  q("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, f.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, f.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  var Zr = /* @__PURE__ */ s(() => ({
    params: {
      validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  yt.functionCommon = Zr;
  var Nr = /* @__PURE__ */ s(() => ({
    returnType: {
      validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, f.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  yt.functionTypeAnnotationCommon = Nr;
  var Jp = /* @__PURE__ */ s(() => Object.assign({}, Zr(), {
    declare: {
      validate: (0, f.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, f.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  yt.functionDeclarationCommon = Jp;
  q("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, Jp(), Nr(), {
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, f.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
      };
      let e = (0, f.assertNodeType)("Identifier");
      return function(t, r, i) {
        (0, at.default)("ExportDefaultDeclaration", t) || e(i, "id", i.id);
      };
    }()
  });
  q("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Zr(), Nr(), {
      id: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, f.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var ei = /* @__PURE__ */ s(() => ({
    typeAnnotation: {
      validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, f.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "patternLikeCommon");
  yt.patternLikeCommon = ei;
  q("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, ei(), {
      name: {
        validate: (0, f.chain)((0, f.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, NA.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(e, t, r) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let i = /\.(\w+)$/.exec(t);
      if (!i) return;
      let [, n] = i, a = {
        computed: !1
      };
      if (n === "property") {
        if ((0, at.default)("MemberExpression", e, a) || (0, at.default)("OptionalMemberExpression", e, a)) return;
      } else if (n === "key") {
        if ((0, at.default)("Property", e, a) || (0, at.default)("Method", e, a)) return;
      } else if (n === "exported") {
        if ((0, at.default)("ExportSpecifier", e)) return;
      } else if (n === "imported") {
        if ((0, at.default)("ImportSpecifier", e, {
          imported: r
        })) return;
      } else if (n === "meta" && (0, at.default)("MetaProperty", e, {
        meta: r
      }))
        return;
      if (((0, Xp.isKeyword)(r.name) || (0, Xp.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    }
  });
  q("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, f.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, f.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, f.chain)((0, f.assertValueType)("number"), Object.assign(function(e, t, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let i = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, f.assertValueType)("string")
      },
      flags: {
        validate: (0, f.chain)((0, f.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let i = /[^gimsuy]/.exec(r);
          if (i)
            throw new TypeError(`"${i[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  q("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, f.assertOneOf)(...Ri.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, f.assertNodeType)("Expression")
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, f.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let e = (0, f.assertNodeType)("Identifier", "PrivateName"), t = (0, f.assertNodeType)("Expression"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, f.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  });
  q("NewExpression", {
    inherits: "CallExpression"
  });
  q("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, f.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, f.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  q("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ObjectMethod", "ObjectProperty", "S\
preadElement")))
      }
    }
  });
  q("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, Zr(), Nr(), {
      kind: Object.assign({
        validate: (0, f.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, f.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  q("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t = (0, f.
          assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, f.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, f.chain)((0, f.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !(0, at.default)("Identifier", e.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      let e = (0, f.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), t = (0, f.assertNodeType)("Expression");
      return function(r, i, n) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, at.default)("ObjectPattern", r) ? e : t)(n, "value", n.value);
      };
    }()
  });
  q("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, ei(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, f.assertNodeType)("LVal")
      }
    }),
    validate(e, t) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let r = /(\w+)\[(\d+)\]/.exec(t);
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, i, n] = r;
      if (e[i].length > +n + 1)
        throw new TypeError(`RestElement must be last element of ${i}`);
    }
  });
  q("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  q("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  q("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Statement")))
      }
    }
  });
  q("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, f.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("SwitchCase")))
      }
    }
  });
  q("ThisExpression", {
    aliases: ["Expression"]
  });
  q("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, f.chain)((0, f.assertNodeType)("BlockStatement"), Object.assign(function(e) {
          if (process.env.BABEL_TYPES_8_BREAKING && !e.handler && !e.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, f.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    }
  });
  q("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, f.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, f.assertOneOf)(...Ri.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  q("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "MemberExpression") : (0, f.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, f.assertOneOf)(...Ri.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  q("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, f.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(e, t, r) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, at.default)("ForXStatement", e, {
        left: r
      }) && r.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`);
    }
  });
  q("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, f.assertNodeType)("LVal");
          let e = (0, f.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), t = (0, f.assertNodeType)("Identifier");
          return function(r, i, n) {
            (r.init ? e : t)(r, i, n);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, f.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, ei(), {
      left: {
        validate: (0, f.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  });
  q("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, ei(), {
      elements: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  q("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Zr(), Nr(), {
      expression: {
        validate: (0, f.assertValueType)("boolean")
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, f.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  q("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ClassMethod", "ClassPrivateMethod",
        "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  q("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, f.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, f.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  q("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, f.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, f.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      let e = (0, f.assertNodeType)("Identifier");
      return function(t, r, i) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, at.default)("ExportDefaultDeclaration", t) || e(i, "id", i.id));
      };
    }()
  });
  q("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, f.assertNodeType)("StringLiteral")
      },
      exportKind: (0, f.validateOptional)((0, f.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      }
    }
  });
  q("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, f.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, f.validateOptional)((0, f.assertOneOf)("value"))
    }
  });
  q("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertNodeType)("Declaration"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)(function() {
          let e = (0, f.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t = (0, f.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(r, i, n) {
            (r.source ? e : t)(r, i, n);
          } : e;
        }()))
      },
      source: {
        validate: (0, f.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, f.validateOptional)((0, f.assertOneOf)("type", "value"))
    }
  });
  q("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, f.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, f.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, f.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  q("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, f.assertNodeType)("VariableDeclaration", "LVal");
          let e = (0, f.assertNodeType)("VariableDeclaration"), t = (0, f.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(r, i, n) {
            (0, at.default)("VariableDeclaration", n) ? e(r, i, n) : t(r, i, n);
          };
        }()
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  q("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, f.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, f.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportSpecifier", "ImportDefaultSpe\
cifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, f.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, f.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  q("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  q("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  q("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, f.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, f.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, f.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  q("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, f.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, f.assertNodeType)("Expression")
      },
      options: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  q("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, f.chain)((0, f.assertNodeType)("Identifier"), Object.assign(function(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let i;
          switch (r.name) {
            case "function":
              i = "sent";
              break;
            case "new":
              i = "target";
              break;
            case "import":
              i = "meta";
              break;
          }
          if (!(0, at.default)("Identifier", e.property, {
            name: i
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  var Ks = /* @__PURE__ */ s(() => ({
    abstract: {
      validate: (0, f.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, f.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, f.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, f.chain)(function() {
        let e = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, f.assertNodeType)("Expressi\
on");
        return function(r, i, n) {
          (r.computed ? t : e)(r, i, n);
        };
      }(), (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  yt.classMethodOrPropertyCommon = Ks;
  var Va = /* @__PURE__ */ s(() => Object.assign({}, Zr(), Ks(), {
    params: {
      validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Identifier", "Pattern", "RestElement",
      "TSParameterProperty")))
    },
    kind: {
      validate: (0, f.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, f.chain)((0, f.assertValueType)("string"), (0, f.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  yt.classMethodOrDeclareMethodCommon = Va;
  q("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, Va(), Nr(), {
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    })
  });
  q("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, ei(), {
      properties: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  q("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("Super", {
    aliases: ["Expression"]
  });
  q("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, f.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, f.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  q("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, f.chain)((0, f.assertShape)({
          raw: {
            validate: (0, f.assertValueType)("string")
          },
          cooked: {
            validate: (0, f.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ s(function(t) {
          let r = t.value.raw, i = !1, n = /* @__PURE__ */ s(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, _A.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              i = !0;
            },
            strictNumericEscape: n,
            invalidEscapeSequence: n,
            numericSeparatorInEscapeSequence: n,
            unexpectedNumericSeparator: n,
            invalidDigit: n,
            invalidCodePoint: n
          });
          if (!i) throw new Error("Invalid raw");
          t.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  q("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Expression", "TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  q("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, f.chain)((0, f.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !e.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("Import", {
    aliases: ["Expression"]
  });
  q("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  q("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, f.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let e = (0, f.assertNodeType)("Identifier"), t = (0, f.assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("boolean"), (0, f.assertOptionalChainStart)()) : (0, f.
        assertValueType)("boolean")
      }
    }
  });
  q("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, f.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("boolean"), (0, f.assertOptionalChainStart)()) : (0, f.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  q("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, Ks(), {
      value: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, f.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  q("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, Ks(), {
      key: {
        validate: (0, f.chain)(function() {
          let e = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t = (0, f.assertNodeType)(
          "Expression");
          return function(r, i, n) {
            (r.computed ? t : e)(r, i, n);
          };
        }(), (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, f.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  q("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, f.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, f.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, f.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  q("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, Va(), Nr(), {
      kind: {
        validate: (0, f.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, f.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    })
  });
  q("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  q("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var $p = v(() => {
  "use strict";
  var I = Ut(), H = (0, I.defineAliasedType)("Flow"), Ka = /* @__PURE__ */ s((e) => {
    let t = e === "DeclareClass";
    H(e, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...t ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, I.validateType)("Identifier"),
        typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, I.validateOptional)((0, I.arrayOfType)("InterfaceExtends"))
      }, t ? {
        mixins: (0, I.validateOptional)((0, I.arrayOfType)("InterfaceExtends")),
        implements: (0, I.validateOptional)((0, I.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, I.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  H("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, I.validateType)("FlowType")
    }
  });
  H("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ka("DeclareClass");
  H("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      predicate: (0, I.validateOptionalType)("DeclaredPredicate")
    }
  });
  Ka("DeclareInterface");
  H("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)(["Identifier", "StringLiteral"]),
      body: (0, I.validateType)("BlockStatement"),
      kind: (0, I.validateOptional)((0, I.assertOneOf)("CommonJS", "ES"))
    }
  });
  H("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, I.validateType)("TypeAnnotation")
    }
  });
  H("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, I.validateType)("FlowType")
    }
  });
  H("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, I.validateOptionalType)("FlowType"),
      impltype: (0, I.validateOptionalType)("FlowType")
    }
  });
  H("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier")
    }
  });
  H("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, I.validateOptionalType)("Flow"),
      specifiers: (0, I.validateOptional)((0, I.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, I.validateOptionalType)("StringLiteral"),
      default: (0, I.validateOptional)((0, I.assertValueType)("boolean"))
    }
  });
  H("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, I.validateType)("StringLiteral"),
      exportKind: (0, I.validateOptional)((0, I.assertOneOf)("type", "value"))
    }
  });
  H("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, I.validateType)("Flow")
    }
  });
  H("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  H("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, I.validate)((0, I.arrayOfType)("FunctionTypeParam")),
      rest: (0, I.validateOptionalType)("FunctionTypeParam"),
      this: (0, I.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, I.validateType)("FlowType")
    }
  });
  H("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, I.validateOptionalType)("Identifier"),
      typeAnnotation: (0, I.validateType)("FlowType"),
      optional: (0, I.validateOptional)((0, I.assertValueType)("boolean"))
    }
  });
  H("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, I.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, I.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  H("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  H("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, I.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, I.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ka("InterfaceDeclaration");
  H("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, I.validateOptional)((0, I.arrayOfType)("InterfaceExtends")),
      body: (0, I.validateType)("ObjectTypeAnnotation")
    }
  });
  H("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, I.validate)((0, I.arrayOfType)("FlowType"))
    }
  });
  H("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, I.validateType)("FlowType")
    }
  });
  H("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, I.validate)((0, I.assertValueType)("number"))
    }
  });
  H("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, I.validate)((0, I.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, I.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, I.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, I.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, I.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, I.validateOptional)((0, I.assertValueType)("boolean"))
    }
  });
  H("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      value: (0, I.validateType)("FlowType"),
      optional: (0, I.validate)((0, I.assertValueType)("boolean")),
      static: (0, I.validate)((0, I.assertValueType)("boolean")),
      method: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, I.validateType)("FlowType"),
      static: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, I.validateOptionalType)("Identifier"),
      key: (0, I.validateType)("FlowType"),
      value: (0, I.validateType)("FlowType"),
      static: (0, I.validate)((0, I.assertValueType)("boolean")),
      variance: (0, I.validateOptionalType)("Variance")
    }
  });
  H("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, I.validateType)(["Identifier", "StringLiteral"]),
      value: (0, I.validateType)("FlowType"),
      kind: (0, I.validate)((0, I.assertOneOf)("init", "get", "set")),
      static: (0, I.validate)((0, I.assertValueType)("boolean")),
      proto: (0, I.validate)((0, I.assertValueType)("boolean")),
      optional: (0, I.validate)((0, I.assertValueType)("boolean")),
      variance: (0, I.validateOptionalType)("Variance"),
      method: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, I.validateType)("FlowType")
    }
  });
  H("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, I.validateOptionalType)("FlowType"),
      impltype: (0, I.validateType)("FlowType")
    }
  });
  H("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      qualification: (0, I.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  H("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, I.validate)((0, I.assertValueType)("string"))
    }
  });
  H("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, I.validate)((0, I.arrayOfType)("FlowType"))
    }
  });
  H("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, I.validateType)("FlowType")
    }
  });
  H("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, I.validateType)("FlowType")
    }
  });
  H("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, I.validateType)("FlowType")
    }
  });
  H("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, I.validateType)("Expression"),
      typeAnnotation: (0, I.validateType)("TypeAnnotation")
    }
  });
  H("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, I.validate)((0, I.assertValueType)("string")),
      bound: (0, I.validateOptionalType)("TypeAnnotation"),
      default: (0, I.validateOptionalType)("FlowType"),
      variance: (0, I.validateOptionalType)("Variance")
    }
  });
  H("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, I.validate)((0, I.arrayOfType)("TypeParameter"))
    }
  });
  H("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, I.validate)((0, I.arrayOfType)("FlowType"))
    }
  });
  H("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, I.validate)((0, I.arrayOfType)("FlowType"))
    }
  });
  H("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, I.validate)((0, I.assertOneOf)("minus", "plus"))
    }
  });
  H("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      body: (0, I.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  H("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, I.validate)((0, I.assertValueType)("boolean")),
      members: (0, I.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, I.validate)((0, I.assertValueType)("boolean")),
      members: (0, I.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, I.validate)((0, I.assertValueType)("boolean")),
      members: (0, I.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, I.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      init: (0, I.validateType)("BooleanLiteral")
    }
  });
  H("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      init: (0, I.validateType)("NumericLiteral")
    }
  });
  H("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      init: (0, I.validateType)("StringLiteral")
    }
  });
  H("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, I.validateType)("Identifier")
    }
  });
  H("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, I.validateType)("FlowType"),
      indexType: (0, I.validateType)("FlowType")
    }
  });
  H("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, I.validateType)("FlowType"),
      indexType: (0, I.validateType)("FlowType"),
      optional: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var Hp = v(() => {
  "use strict";
  var Ee = Ut(), ot = (0, Ee.defineAliasedType)("JSX");
  ot("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, Ee.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  ot("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  ot("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, Ee.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, Ee.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, Ee.chain)((0, Ee.assertValueType)("array"), (0, Ee.assertEach)((0, Ee.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, Ee.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  ot("JSXEmptyExpression", {});
  ot("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, Ee.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  ot("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, Ee.assertNodeType)("Expression")
      }
    }
  });
  ot("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Ee.assertValueType)("string")
      }
    }
  });
  ot("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, Ee.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ot("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ot("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, Ee.chain)((0, Ee.assertValueType)("array"), (0, Ee.assertEach)((0, Ee.assertNodeType)("JSXAttribute", "JSXSpreadAttrib\
ute")))
      },
      typeParameters: {
        validate: (0, Ee.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  ot("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, Ee.assertNodeType)("Expression")
      }
    }
  });
  ot("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, Ee.assertValueType)("string")
      }
    }
  });
  ot("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, Ee.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, Ee.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, Ee.chain)((0, Ee.assertValueType)("array"), (0, Ee.assertEach)((0, Ee.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  ot("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  ot("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Xa = v((sr) => {
  "use strict";
  Object.defineProperty(sr, "__esModule", {
    value: !0
  });
  sr.PLACEHOLDERS_FLIPPED_ALIAS = sr.PLACEHOLDERS_ALIAS = sr.PLACEHOLDERS = void 0;
  var DA = Ut(), kA = sr.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBo\
dy", "Pattern"], Ya = sr.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let e of kA) {
    let t = DA.ALIAS_KEYS[e];
    t != null && t.length && (Ya[e] = t);
  }
  var Wa = sr.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(Ya).forEach((e) => {
    Ya[e].forEach((t) => {
      hasOwnProperty.call(Wa, t) || (Wa[t] = []), Wa[t].push(e);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var Gp = v(() => {
  "use strict";
  var Ws = Ut(), LA = Xa(), Ja = (0, Ws.defineAliasedType)("Miscellaneous");
  Ja("Noop", {
    visitor: []
  });
  Ja("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, Ws.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, Ws.assertOneOf)(...LA.PLACEHOLDERS)
      }
    }
  });
  Ja("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Ws.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var zp = v(() => {
  "use strict";
  var be = Ut();
  (0, be.default)("ArgumentPlaceholder", {});
  (0, be.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, be.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, be.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, be.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, be.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, be.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, be.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, be.assertNodeType)("Expression")
      }
    }
  });
  (0, be.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, be.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, be.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, be.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, be.assertNodeType)("Identifier")
      }
    }
  });
  (0, be.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, be.chain)((0, be.assertValueType)("array"), (0, be.assertEach)((0, be.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, be.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, be.chain)((0, be.assertValueType)("array"), (0, be.assertEach)((0, be.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, be.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, be.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, be.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, be.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, be.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, be.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, be.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, be.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, be.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, be.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var af = v(() => {
  "use strict";
  var D = Ut(), Qp = Ua(), MA = zr(), se = (0, D.defineAliasedType)("TypeScript"), Tt = (0, D.assertValueType)("boolean"), Zp = /* @__PURE__ */ s(
  () => ({
    returnType: {
      validate: (0, D.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, D.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  se("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, D.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, D.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, D.chain)((0, D.assertValueType)("array"), (0, D.assertEach)((0, D.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  });
  se("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Qp.functionDeclarationCommon)(), Zp())
  });
  se("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Qp.classMethodOrDeclareMethodCommon)(), Zp())
  });
  se("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, D.validateType)("TSEntityName"),
      right: (0, D.validateType)("Identifier")
    }
  });
  var Ys = /* @__PURE__ */ s(() => ({
    typeParameters: (0, D.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, D.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, D.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), ef = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Ys()
  };
  se("TSCallSignatureDeclaration", ef);
  se("TSConstructSignatureDeclaration", ef);
  var tf = /* @__PURE__ */ s(() => ({
    key: (0, D.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, D.validateOptional)(Tt)
  }), "namedTypeElementCommon");
  se("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, tf(), {
      readonly: (0, D.validateOptional)(Tt),
      typeAnnotation: (0, D.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, D.assertOneOf)("get", "set")
      }
    })
  });
  se("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Ys(), tf(), {
      kind: {
        validate: (0, D.assertOneOf)("method", "get", "set")
      }
    })
  });
  se("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, D.validateOptional)(Tt),
      static: (0, D.validateOptional)(Tt),
      parameters: (0, D.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, D.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var FA = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword",
  "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let e of FA)
    se(e, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  se("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var rf = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  se("TSFunctionType", Object.assign({}, rf, {
    fields: Ys()
  }));
  se("TSConstructorType", Object.assign({}, rf, {
    fields: Object.assign({}, Ys(), {
      abstract: (0, D.validateOptional)(Tt)
    })
  }));
  se("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, D.validateType)("TSEntityName"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  se("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, D.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, D.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, D.validateOptional)(Tt)
    }
  });
  se("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, D.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  se("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, D.validateArrayOfType)("TSTypeElement")
    }
  });
  se("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, D.validateType)("TSType")
    }
  });
  se("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, D.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  se("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, D.validateType)("Identifier"),
      optional: {
        validate: Tt,
        default: !1
      },
      elementType: (0, D.validateType)("TSType")
    }
  });
  var sf = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, D.validateArrayOfType)("TSType")
    }
  };
  se("TSUnionType", sf);
  se("TSIntersectionType", sf);
  se("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, D.validateType)("TSType"),
      extendsType: (0, D.validateType)("TSType"),
      trueType: (0, D.validateType)("TSType"),
      falseType: (0, D.validateType)("TSType")
    }
  });
  se("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, D.validateType)("TSTypeParameter")
    }
  });
  se("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, D.validate)((0, D.assertValueType)("string")),
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, D.validateType)("TSType"),
      indexType: (0, D.validateType)("TSType")
    }
  });
  se("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, D.validateOptional)((0, D.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, D.validateType)("TSTypeParameter"),
      optional: (0, D.validateOptional)((0, D.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, D.validateOptionalType)("TSType"),
      nameType: (0, D.validateOptionalType)("TSType")
    }
  });
  se("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let e = (0, D.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, D.assertOneOf)("-"), r = (0, D.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function i(n, a, o) {
            (0, MA.default)("UnaryExpression", o) ? (t(o, "operator", o.operator), e(o, "argument", o.argument)) : r(n, a, o);
          }
          return s(i, "validator"), i.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], i;
        }()
      }
    }
  });
  se("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, D.validateType)("TSEntityName"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  se("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, D.validateOptional)(Tt),
      id: (0, D.validateType)("Identifier"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, D.validateOptional)((0, D.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, D.validateType)("TSInterfaceBody")
    }
  });
  se("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, D.validateArrayOfType)("TSTypeElement")
    }
  });
  se("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, D.validateOptional)(Tt),
      id: (0, D.validateType)("Identifier"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, D.validateType)("Expression"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var nf = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, D.validateType)("Expression"),
      typeAnnotation: (0, D.validateType)("TSType")
    }
  };
  se("TSAsExpression", nf);
  se("TSSatisfiesExpression", nf);
  se("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, D.validateType)("TSType"),
      expression: (0, D.validateType)("Expression")
    }
  });
  se("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, D.validateOptional)(Tt),
      const: (0, D.validateOptional)(Tt),
      id: (0, D.validateType)("Identifier"),
      members: (0, D.validateArrayOfType)("TSEnumMember"),
      initializer: (0, D.validateOptionalType)("Expression")
    }
  });
  se("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, D.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, D.validateOptionalType)("Expression")
    }
  });
  se("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, D.validateOptional)(Tt),
      global: (0, D.validateOptional)(Tt),
      id: (0, D.validateType)(["Identifier", "StringLiteral"]),
      body: (0, D.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  se("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, D.validateArrayOfType)("Statement")
    }
  });
  se("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, D.validateType)("StringLiteral"),
      qualifier: (0, D.validateOptionalType)("TSEntityName"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, D.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  se("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, D.validate)(Tt),
      id: (0, D.validateType)("Identifier"),
      moduleReference: (0, D.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, D.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  se("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, D.validateType)("StringLiteral")
    }
  });
  se("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, D.validateType)("Expression")
    }
  });
  se("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, D.validateType)("Expression")
    }
  });
  se("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, D.validateType)("Identifier")
    }
  });
  se("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, D.assertNodeType)("TSType")
      }
    }
  });
  se("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, D.chain)((0, D.assertValueType)("array"), (0, D.assertEach)((0, D.assertNodeType)("TSType")))
      }
    }
  });
  se("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, D.chain)((0, D.assertValueType)("array"), (0, D.assertEach)((0, D.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  se("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, D.assertValueType)("string")
      },
      in: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, D.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, D.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var of = v((Xs) => {
  "use strict";
  Object.defineProperty(Xs, "__esModule", {
    value: !0
  });
  Xs.DEPRECATED_ALIASES = void 0;
  var W$ = Xs.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var Et = v((lt) => {
  "use strict";
  Object.defineProperty(lt, "__esModule", {
    value: !0
  });
  Object.defineProperty(lt, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ze.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(lt, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ze.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(lt, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $a.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(lt, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ze.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(lt, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ze.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(lt, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ze.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(lt, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ze.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(lt, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qi.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(lt, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qi.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(lt, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qi.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  lt.TYPES = void 0;
  Object.defineProperty(lt, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ze.VISITOR_KEYS;
    }, "get")
  });
  var nr = Ap();
  Ua();
  $p();
  Hp();
  Gp();
  zp();
  af();
  var ze = Ut(), qi = Xa(), $a = of();
  Object.keys($a.DEPRECATED_ALIASES).forEach((e) => {
    ze.FLIPPED_ALIAS_KEYS[e] = ze.FLIPPED_ALIAS_KEYS[$a.DEPRECATED_ALIASES[e]];
  });
  nr(ze.VISITOR_KEYS);
  nr(ze.ALIAS_KEYS);
  nr(ze.FLIPPED_ALIAS_KEYS);
  nr(ze.NODE_FIELDS);
  nr(ze.BUILDER_KEYS);
  nr(ze.DEPRECATED_KEYS);
  nr(qi.PLACEHOLDERS_ALIAS);
  nr(qi.PLACEHOLDERS_FLIPPED_ALIAS);
  var X$ = lt.TYPES = [].concat(Object.keys(ze.VISITOR_KEYS), Object.keys(ze.FLIPPED_ALIAS_KEYS), Object.keys(ze.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var Us = v((Vi) => {
  "use strict";
  Object.defineProperty(Vi, "__esModule", {
    value: !0
  });
  Vi.default = BA;
  Vi.validateChild = cf;
  Vi.validateField = uf;
  var lf = Et();
  function BA(e, t, r) {
    if (!e) return;
    let i = lf.NODE_FIELDS[e.type];
    if (!i) return;
    let n = i[t];
    uf(e, t, r, n), cf(e, t, r);
  }
  s(BA, "validate");
  function uf(e, t, r, i) {
    i != null && i.validate && (i.optional && r == null || i.validate(e, t, r));
  }
  s(uf, "validateField");
  function cf(e, t, r) {
    if (r == null) return;
    let i = lf.NODE_PARENT_VALIDATIONS[r.type];
    i && i(e, t, r);
  }
  s(cf, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/validateNode.js
var pf = v((Ha) => {
  "use strict";
  Object.defineProperty(Ha, "__esModule", {
    value: !0
  });
  Ha.default = qA;
  var jA = Us(), RA = le();
  function qA(e) {
    let t = RA.BUILDER_KEYS[e.type];
    for (let r of t)
      (0, jA.default)(e, r, e[r]);
    return e;
  }
  s(qA, "validateNode");
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var ut = v((h) => {
  "use strict";
  Object.defineProperty(h, "__esModule", {
    value: !0
  });
  h.anyTypeAnnotation = T1;
  h.argumentPlaceholder = XC;
  h.arrayExpression = VA;
  h.arrayPattern = Fv;
  h.arrayTypeAnnotation = g1;
  h.arrowFunctionExpression = Bv;
  h.assignmentExpression = UA;
  h.assignmentPattern = Mv;
  h.awaitExpression = n1;
  h.bigIntLiteral = o1;
  h.binaryExpression = KA;
  h.bindExpression = JC;
  h.blockStatement = JA;
  h.booleanLiteral = hv;
  h.booleanLiteralTypeAnnotation = S1;
  h.booleanTypeAnnotation = b1;
  h.breakStatement = $A;
  h.callExpression = HA;
  h.catchClause = GA;
  h.classAccessorProperty = f1;
  h.classBody = jv;
  h.classDeclaration = qv;
  h.classExpression = Rv;
  h.classImplements = E1;
  h.classMethod = Qv;
  h.classPrivateMethod = d1;
  h.classPrivateProperty = h1;
  h.classProperty = p1;
  h.conditionalExpression = zA;
  h.continueStatement = QA;
  h.debuggerStatement = ZA;
  h.decimalLiteral = eI;
  h.declareClass = P1;
  h.declareExportAllDeclaration = D1;
  h.declareExportDeclaration = _1;
  h.declareFunction = A1;
  h.declareInterface = v1;
  h.declareModule = C1;
  h.declareModuleExports = I1;
  h.declareOpaqueType = O1;
  h.declareTypeAlias = w1;
  h.declareVariable = N1;
  h.declaredPredicate = k1;
  h.decorator = HC;
  h.directive = YA;
  h.directiveLiteral = XA;
  h.doExpression = GC;
  h.doWhileStatement = ev;
  h.emptyStatement = tv;
  h.emptyTypeAnnotation = W1;
  h.enumBooleanBody = gC;
  h.enumBooleanMember = EC;
  h.enumDeclaration = TC;
  h.enumDefaultedMember = vC;
  h.enumNumberBody = bC;
  h.enumNumberMember = PC;
  h.enumStringBody = SC;
  h.enumStringMember = AC;
  h.enumSymbolBody = xC;
  h.existsTypeAnnotation = L1;
  h.exportAllDeclaration = Vv;
  h.exportDefaultDeclaration = Uv;
  h.exportDefaultSpecifier = zC;
  h.exportNamedDeclaration = Kv;
  h.exportNamespaceSpecifier = l1;
  h.exportSpecifier = Wv;
  h.expressionStatement = rv;
  h.file = iv;
  h.forInStatement = sv;
  h.forOfStatement = Yv;
  h.forStatement = nv;
  h.functionDeclaration = av;
  h.functionExpression = ov;
  h.functionTypeAnnotation = M1;
  h.functionTypeParam = F1;
  h.genericTypeAnnotation = B1;
  h.identifier = lv;
  h.ifStatement = uv;
  h.import = a1;
  h.importAttribute = $C;
  h.importDeclaration = Xv;
  h.importDefaultSpecifier = Jv;
  h.importExpression = Gv;
  h.importNamespaceSpecifier = $v;
  h.importSpecifier = Hv;
  h.indexedAccessType = CC;
  h.inferredPredicate = j1;
  h.interfaceDeclaration = q1;
  h.interfaceExtends = R1;
  h.interfaceTypeAnnotation = V1;
  h.interpreterDirective = WA;
  h.intersectionTypeAnnotation = U1;
  h.jSXAttribute = h.jsxAttribute = wC;
  h.jSXClosingElement = h.jsxClosingElement = OC;
  h.jSXClosingFragment = h.jsxClosingFragment = UC;
  h.jSXElement = h.jsxElement = NC;
  h.jSXEmptyExpression = h.jsxEmptyExpression = _C;
  h.jSXExpressionContainer = h.jsxExpressionContainer = DC;
  h.jSXFragment = h.jsxFragment = qC;
  h.jSXIdentifier = h.jsxIdentifier = LC;
  h.jSXMemberExpression = h.jsxMemberExpression = MC;
  h.jSXNamespacedName = h.jsxNamespacedName = FC;
  h.jSXOpeningElement = h.jsxOpeningElement = BC;
  h.jSXOpeningFragment = h.jsxOpeningFragment = VC;
  h.jSXSpreadAttribute = h.jsxSpreadAttribute = jC;
  h.jSXSpreadChild = h.jsxSpreadChild = kC;
  h.jSXText = h.jsxText = RC;
  h.labeledStatement = cv;
  h.logicalExpression = dv;
  h.memberExpression = mv;
  h.metaProperty = zv;
  h.mixedTypeAnnotation = K1;
  h.moduleExpression = tI;
  h.newExpression = yv;
  h.noop = KC;
  h.nullLiteral = fv;
  h.nullLiteralTypeAnnotation = x1;
  h.nullableTypeAnnotation = Y1;
  h.numberLiteral = Tw;
  h.numberLiteralTypeAnnotation = X1;
  h.numberTypeAnnotation = J1;
  h.numericLiteral = ff;
  h.objectExpression = gv;
  h.objectMethod = bv;
  h.objectPattern = Zv;
  h.objectProperty = Sv;
  h.objectTypeAnnotation = $1;
  h.objectTypeCallProperty = G1;
  h.objectTypeIndexer = z1;
  h.objectTypeInternalSlot = H1;
  h.objectTypeProperty = Q1;
  h.objectTypeSpreadProperty = Z1;
  h.opaqueType = eC;
  h.optionalCallExpression = c1;
  h.optionalIndexedAccessType = IC;
  h.optionalMemberExpression = u1;
  h.parenthesizedExpression = Pv;
  h.pipelineBareFunction = sI;
  h.pipelinePrimaryTopicReference = nI;
  h.pipelineTopicExpression = iI;
  h.placeholder = WC;
  h.privateName = m1;
  h.program = Tv;
  h.qualifiedTypeIdentifier = tC;
  h.recordExpression = QC;
  h.regExpLiteral = hf;
  h.regexLiteral = gw;
  h.restElement = df;
  h.restProperty = bw;
  h.returnStatement = xv;
  h.sequenceExpression = Ev;
  h.spreadElement = mf;
  h.spreadProperty = Sw;
  h.staticBlock = y1;
  h.stringLiteral = pv;
  h.stringLiteralTypeAnnotation = rC;
  h.stringTypeAnnotation = iC;
  h.super = e1;
  h.switchCase = Av;
  h.switchStatement = vv;
  h.symbolTypeAnnotation = sC;
  h.taggedTemplateExpression = t1;
  h.templateElement = r1;
  h.templateLiteral = i1;
  h.thisExpression = Cv;
  h.thisTypeAnnotation = nC;
  h.throwStatement = Iv;
  h.topicReference = rI;
  h.tryStatement = wv;
  h.tSAnyKeyword = h.tsAnyKeyword = mI;
  h.tSArrayType = h.tsArrayType = MI;
  h.tSAsExpression = h.tsAsExpression = ew;
  h.tSBigIntKeyword = h.tsBigIntKeyword = TI;
  h.tSBooleanKeyword = h.tsBooleanKeyword = yI;
  h.tSCallSignatureDeclaration = h.tsCallSignatureDeclaration = cI;
  h.tSConditionalType = h.tsConditionalType = UI;
  h.tSConstructSignatureDeclaration = h.tsConstructSignatureDeclaration = pI;
  h.tSConstructorType = h.tsConstructorType = NI;
  h.tSDeclareFunction = h.tsDeclareFunction = oI;
  h.tSDeclareMethod = h.tsDeclareMethod = lI;
  h.tSEnumDeclaration = h.tsEnumDeclaration = iw;
  h.tSEnumMember = h.tsEnumMember = sw;
  h.tSExportAssignment = h.tsExportAssignment = pw;
  h.tSExpressionWithTypeArguments = h.tsExpressionWithTypeArguments = HI;
  h.tSExternalModuleReference = h.tsExternalModuleReference = uw;
  h.tSFunctionType = h.tsFunctionType = OI;
  h.tSImportEqualsDeclaration = h.tsImportEqualsDeclaration = lw;
  h.tSImportType = h.tsImportType = ow;
  h.tSIndexSignature = h.tsIndexSignature = dI;
  h.tSIndexedAccessType = h.tsIndexedAccessType = XI;
  h.tSInferType = h.tsInferType = KI;
  h.tSInstantiationExpression = h.tsInstantiationExpression = ZI;
  h.tSInterfaceBody = h.tsInterfaceBody = zI;
  h.tSInterfaceDeclaration = h.tsInterfaceDeclaration = GI;
  h.tSIntersectionType = h.tsIntersectionType = VI;
  h.tSIntrinsicKeyword = h.tsIntrinsicKeyword = gI;
  h.tSLiteralType = h.tsLiteralType = $I;
  h.tSMappedType = h.tsMappedType = JI;
  h.tSMethodSignature = h.tsMethodSignature = hI;
  h.tSModuleBlock = h.tsModuleBlock = aw;
  h.tSModuleDeclaration = h.tsModuleDeclaration = nw;
  h.tSNamedTupleMember = h.tsNamedTupleMember = RI;
  h.tSNamespaceExportDeclaration = h.tsNamespaceExportDeclaration = fw;
  h.tSNeverKeyword = h.tsNeverKeyword = bI;
  h.tSNonNullExpression = h.tsNonNullExpression = cw;
  h.tSNullKeyword = h.tsNullKeyword = SI;
  h.tSNumberKeyword = h.tsNumberKeyword = xI;
  h.tSObjectKeyword = h.tsObjectKeyword = EI;
  h.tSOptionalType = h.tsOptionalType = BI;
  h.tSParameterProperty = h.tsParameterProperty = aI;
  h.tSParenthesizedType = h.tsParenthesizedType = WI;
  h.tSPropertySignature = h.tsPropertySignature = fI;
  h.tSQualifiedName = h.tsQualifiedName = uI;
  h.tSRestType = h.tsRestType = jI;
  h.tSSatisfiesExpression = h.tsSatisfiesExpression = tw;
  h.tSStringKeyword = h.tsStringKeyword = PI;
  h.tSSymbolKeyword = h.tsSymbolKeyword = AI;
  h.tSThisType = h.tsThisType = wI;
  h.tSTupleType = h.tsTupleType = FI;
  h.tSTypeAliasDeclaration = h.tsTypeAliasDeclaration = QI;
  h.tSTypeAnnotation = h.tsTypeAnnotation = hw;
  h.tSTypeAssertion = h.tsTypeAssertion = rw;
  h.tSTypeLiteral = h.tsTypeLiteral = LI;
  h.tSTypeOperator = h.tsTypeOperator = YI;
  h.tSTypeParameter = h.tsTypeParameter = yw;
  h.tSTypeParameterDeclaration = h.tsTypeParameterDeclaration = mw;
  h.tSTypeParameterInstantiation = h.tsTypeParameterInstantiation = dw;
  h.tSTypePredicate = h.tsTypePredicate = DI;
  h.tSTypeQuery = h.tsTypeQuery = kI;
  h.tSTypeReference = h.tsTypeReference = _I;
  h.tSUndefinedKeyword = h.tsUndefinedKeyword = vI;
  h.tSUnionType = h.tsUnionType = qI;
  h.tSUnknownKeyword = h.tsUnknownKeyword = CI;
  h.tSVoidKeyword = h.tsVoidKeyword = II;
  h.tupleExpression = ZC;
  h.tupleTypeAnnotation = aC;
  h.typeAlias = lC;
  h.typeAnnotation = uC;
  h.typeCastExpression = cC;
  h.typeParameter = pC;
  h.typeParameterDeclaration = fC;
  h.typeParameterInstantiation = hC;
  h.typeofTypeAnnotation = oC;
  h.unaryExpression = Ov;
  h.unionTypeAnnotation = dC;
  h.updateExpression = Nv;
  h.v8IntrinsicIdentifier = YC;
  h.variableDeclaration = _v;
  h.variableDeclarator = Dv;
  h.variance = mC;
  h.voidTypeAnnotation = yC;
  h.whileStatement = kv;
  h.withStatement = Lv;
  h.yieldExpression = s1;
  var E = pf(), Js = Ni();
  function VA(e = []) {
    return (0, E.default)({
      type: "ArrayExpression",
      elements: e
    });
  }
  s(VA, "arrayExpression");
  function UA(e, t, r) {
    return (0, E.default)({
      type: "AssignmentExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  s(UA, "assignmentExpression");
  function KA(e, t, r) {
    return (0, E.default)({
      type: "BinaryExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  s(KA, "binaryExpression");
  function WA(e) {
    return (0, E.default)({
      type: "InterpreterDirective",
      value: e
    });
  }
  s(WA, "interpreterDirective");
  function YA(e) {
    return (0, E.default)({
      type: "Directive",
      value: e
    });
  }
  s(YA, "directive");
  function XA(e) {
    return (0, E.default)({
      type: "DirectiveLiteral",
      value: e
    });
  }
  s(XA, "directiveLiteral");
  function JA(e, t = []) {
    return (0, E.default)({
      type: "BlockStatement",
      body: e,
      directives: t
    });
  }
  s(JA, "blockStatement");
  function $A(e = null) {
    return (0, E.default)({
      type: "BreakStatement",
      label: e
    });
  }
  s($A, "breakStatement");
  function HA(e, t) {
    return (0, E.default)({
      type: "CallExpression",
      callee: e,
      arguments: t
    });
  }
  s(HA, "callExpression");
  function GA(e = null, t) {
    return (0, E.default)({
      type: "CatchClause",
      param: e,
      body: t
    });
  }
  s(GA, "catchClause");
  function zA(e, t, r) {
    return (0, E.default)({
      type: "ConditionalExpression",
      test: e,
      consequent: t,
      alternate: r
    });
  }
  s(zA, "conditionalExpression");
  function QA(e = null) {
    return (0, E.default)({
      type: "ContinueStatement",
      label: e
    });
  }
  s(QA, "continueStatement");
  function ZA() {
    return {
      type: "DebuggerStatement"
    };
  }
  s(ZA, "debuggerStatement");
  function ev(e, t) {
    return (0, E.default)({
      type: "DoWhileStatement",
      test: e,
      body: t
    });
  }
  s(ev, "doWhileStatement");
  function tv() {
    return {
      type: "EmptyStatement"
    };
  }
  s(tv, "emptyStatement");
  function rv(e) {
    return (0, E.default)({
      type: "ExpressionStatement",
      expression: e
    });
  }
  s(rv, "expressionStatement");
  function iv(e, t = null, r = null) {
    return (0, E.default)({
      type: "File",
      program: e,
      comments: t,
      tokens: r
    });
  }
  s(iv, "file");
  function sv(e, t, r) {
    return (0, E.default)({
      type: "ForInStatement",
      left: e,
      right: t,
      body: r
    });
  }
  s(sv, "forInStatement");
  function nv(e = null, t = null, r = null, i) {
    return (0, E.default)({
      type: "ForStatement",
      init: e,
      test: t,
      update: r,
      body: i
    });
  }
  s(nv, "forStatement");
  function av(e = null, t, r, i = !1, n = !1) {
    return (0, E.default)({
      type: "FunctionDeclaration",
      id: e,
      params: t,
      body: r,
      generator: i,
      async: n
    });
  }
  s(av, "functionDeclaration");
  function ov(e = null, t, r, i = !1, n = !1) {
    return (0, E.default)({
      type: "FunctionExpression",
      id: e,
      params: t,
      body: r,
      generator: i,
      async: n
    });
  }
  s(ov, "functionExpression");
  function lv(e) {
    return (0, E.default)({
      type: "Identifier",
      name: e
    });
  }
  s(lv, "identifier");
  function uv(e, t, r = null) {
    return (0, E.default)({
      type: "IfStatement",
      test: e,
      consequent: t,
      alternate: r
    });
  }
  s(uv, "ifStatement");
  function cv(e, t) {
    return (0, E.default)({
      type: "LabeledStatement",
      label: e,
      body: t
    });
  }
  s(cv, "labeledStatement");
  function pv(e) {
    return (0, E.default)({
      type: "StringLiteral",
      value: e
    });
  }
  s(pv, "stringLiteral");
  function ff(e) {
    return (0, E.default)({
      type: "NumericLiteral",
      value: e
    });
  }
  s(ff, "numericLiteral");
  function fv() {
    return {
      type: "NullLiteral"
    };
  }
  s(fv, "nullLiteral");
  function hv(e) {
    return (0, E.default)({
      type: "BooleanLiteral",
      value: e
    });
  }
  s(hv, "booleanLiteral");
  function hf(e, t = "") {
    return (0, E.default)({
      type: "RegExpLiteral",
      pattern: e,
      flags: t
    });
  }
  s(hf, "regExpLiteral");
  function dv(e, t, r) {
    return (0, E.default)({
      type: "LogicalExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  s(dv, "logicalExpression");
  function mv(e, t, r = !1, i = null) {
    return (0, E.default)({
      type: "MemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: i
    });
  }
  s(mv, "memberExpression");
  function yv(e, t) {
    return (0, E.default)({
      type: "NewExpression",
      callee: e,
      arguments: t
    });
  }
  s(yv, "newExpression");
  function Tv(e, t = [], r = "script", i = null) {
    return (0, E.default)({
      type: "Program",
      body: e,
      directives: t,
      sourceType: r,
      interpreter: i
    });
  }
  s(Tv, "program");
  function gv(e) {
    return (0, E.default)({
      type: "ObjectExpression",
      properties: e
    });
  }
  s(gv, "objectExpression");
  function bv(e = "method", t, r, i, n = !1, a = !1, o = !1) {
    return (0, E.default)({
      type: "ObjectMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      computed: n,
      generator: a,
      async: o
    });
  }
  s(bv, "objectMethod");
  function Sv(e, t, r = !1, i = !1, n = null) {
    return (0, E.default)({
      type: "ObjectProperty",
      key: e,
      value: t,
      computed: r,
      shorthand: i,
      decorators: n
    });
  }
  s(Sv, "objectProperty");
  function df(e) {
    return (0, E.default)({
      type: "RestElement",
      argument: e
    });
  }
  s(df, "restElement");
  function xv(e = null) {
    return (0, E.default)({
      type: "ReturnStatement",
      argument: e
    });
  }
  s(xv, "returnStatement");
  function Ev(e) {
    return (0, E.default)({
      type: "SequenceExpression",
      expressions: e
    });
  }
  s(Ev, "sequenceExpression");
  function Pv(e) {
    return (0, E.default)({
      type: "ParenthesizedExpression",
      expression: e
    });
  }
  s(Pv, "parenthesizedExpression");
  function Av(e = null, t) {
    return (0, E.default)({
      type: "SwitchCase",
      test: e,
      consequent: t
    });
  }
  s(Av, "switchCase");
  function vv(e, t) {
    return (0, E.default)({
      type: "SwitchStatement",
      discriminant: e,
      cases: t
    });
  }
  s(vv, "switchStatement");
  function Cv() {
    return {
      type: "ThisExpression"
    };
  }
  s(Cv, "thisExpression");
  function Iv(e) {
    return (0, E.default)({
      type: "ThrowStatement",
      argument: e
    });
  }
  s(Iv, "throwStatement");
  function wv(e, t = null, r = null) {
    return (0, E.default)({
      type: "TryStatement",
      block: e,
      handler: t,
      finalizer: r
    });
  }
  s(wv, "tryStatement");
  function Ov(e, t, r = !0) {
    return (0, E.default)({
      type: "UnaryExpression",
      operator: e,
      argument: t,
      prefix: r
    });
  }
  s(Ov, "unaryExpression");
  function Nv(e, t, r = !1) {
    return (0, E.default)({
      type: "UpdateExpression",
      operator: e,
      argument: t,
      prefix: r
    });
  }
  s(Nv, "updateExpression");
  function _v(e, t) {
    return (0, E.default)({
      type: "VariableDeclaration",
      kind: e,
      declarations: t
    });
  }
  s(_v, "variableDeclaration");
  function Dv(e, t = null) {
    return (0, E.default)({
      type: "VariableDeclarator",
      id: e,
      init: t
    });
  }
  s(Dv, "variableDeclarator");
  function kv(e, t) {
    return (0, E.default)({
      type: "WhileStatement",
      test: e,
      body: t
    });
  }
  s(kv, "whileStatement");
  function Lv(e, t) {
    return (0, E.default)({
      type: "WithStatement",
      object: e,
      body: t
    });
  }
  s(Lv, "withStatement");
  function Mv(e, t) {
    return (0, E.default)({
      type: "AssignmentPattern",
      left: e,
      right: t
    });
  }
  s(Mv, "assignmentPattern");
  function Fv(e) {
    return (0, E.default)({
      type: "ArrayPattern",
      elements: e
    });
  }
  s(Fv, "arrayPattern");
  function Bv(e, t, r = !1) {
    return (0, E.default)({
      type: "ArrowFunctionExpression",
      params: e,
      body: t,
      async: r,
      expression: null
    });
  }
  s(Bv, "arrowFunctionExpression");
  function jv(e) {
    return (0, E.default)({
      type: "ClassBody",
      body: e
    });
  }
  s(jv, "classBody");
  function Rv(e = null, t = null, r, i = null) {
    return (0, E.default)({
      type: "ClassExpression",
      id: e,
      superClass: t,
      body: r,
      decorators: i
    });
  }
  s(Rv, "classExpression");
  function qv(e = null, t = null, r, i = null) {
    return (0, E.default)({
      type: "ClassDeclaration",
      id: e,
      superClass: t,
      body: r,
      decorators: i
    });
  }
  s(qv, "classDeclaration");
  function Vv(e) {
    return (0, E.default)({
      type: "ExportAllDeclaration",
      source: e
    });
  }
  s(Vv, "exportAllDeclaration");
  function Uv(e) {
    return (0, E.default)({
      type: "ExportDefaultDeclaration",
      declaration: e
    });
  }
  s(Uv, "exportDefaultDeclaration");
  function Kv(e = null, t = [], r = null) {
    return (0, E.default)({
      type: "ExportNamedDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    });
  }
  s(Kv, "exportNamedDeclaration");
  function Wv(e, t) {
    return (0, E.default)({
      type: "ExportSpecifier",
      local: e,
      exported: t
    });
  }
  s(Wv, "exportSpecifier");
  function Yv(e, t, r, i = !1) {
    return (0, E.default)({
      type: "ForOfStatement",
      left: e,
      right: t,
      body: r,
      await: i
    });
  }
  s(Yv, "forOfStatement");
  function Xv(e, t) {
    return (0, E.default)({
      type: "ImportDeclaration",
      specifiers: e,
      source: t
    });
  }
  s(Xv, "importDeclaration");
  function Jv(e) {
    return (0, E.default)({
      type: "ImportDefaultSpecifier",
      local: e
    });
  }
  s(Jv, "importDefaultSpecifier");
  function $v(e) {
    return (0, E.default)({
      type: "ImportNamespaceSpecifier",
      local: e
    });
  }
  s($v, "importNamespaceSpecifier");
  function Hv(e, t) {
    return (0, E.default)({
      type: "ImportSpecifier",
      local: e,
      imported: t
    });
  }
  s(Hv, "importSpecifier");
  function Gv(e, t = null) {
    return (0, E.default)({
      type: "ImportExpression",
      source: e,
      options: t
    });
  }
  s(Gv, "importExpression");
  function zv(e, t) {
    return (0, E.default)({
      type: "MetaProperty",
      meta: e,
      property: t
    });
  }
  s(zv, "metaProperty");
  function Qv(e = "method", t, r, i, n = !1, a = !1, o = !1, l = !1) {
    return (0, E.default)({
      type: "ClassMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      computed: n,
      static: a,
      generator: o,
      async: l
    });
  }
  s(Qv, "classMethod");
  function Zv(e) {
    return (0, E.default)({
      type: "ObjectPattern",
      properties: e
    });
  }
  s(Zv, "objectPattern");
  function mf(e) {
    return (0, E.default)({
      type: "SpreadElement",
      argument: e
    });
  }
  s(mf, "spreadElement");
  function e1() {
    return {
      type: "Super"
    };
  }
  s(e1, "_super");
  function t1(e, t) {
    return (0, E.default)({
      type: "TaggedTemplateExpression",
      tag: e,
      quasi: t
    });
  }
  s(t1, "taggedTemplateExpression");
  function r1(e, t = !1) {
    return (0, E.default)({
      type: "TemplateElement",
      value: e,
      tail: t
    });
  }
  s(r1, "templateElement");
  function i1(e, t) {
    return (0, E.default)({
      type: "TemplateLiteral",
      quasis: e,
      expressions: t
    });
  }
  s(i1, "templateLiteral");
  function s1(e = null, t = !1) {
    return (0, E.default)({
      type: "YieldExpression",
      argument: e,
      delegate: t
    });
  }
  s(s1, "yieldExpression");
  function n1(e) {
    return (0, E.default)({
      type: "AwaitExpression",
      argument: e
    });
  }
  s(n1, "awaitExpression");
  function a1() {
    return {
      type: "Import"
    };
  }
  s(a1, "_import");
  function o1(e) {
    return (0, E.default)({
      type: "BigIntLiteral",
      value: e
    });
  }
  s(o1, "bigIntLiteral");
  function l1(e) {
    return (0, E.default)({
      type: "ExportNamespaceSpecifier",
      exported: e
    });
  }
  s(l1, "exportNamespaceSpecifier");
  function u1(e, t, r = !1, i) {
    return (0, E.default)({
      type: "OptionalMemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: i
    });
  }
  s(u1, "optionalMemberExpression");
  function c1(e, t, r) {
    return (0, E.default)({
      type: "OptionalCallExpression",
      callee: e,
      arguments: t,
      optional: r
    });
  }
  s(c1, "optionalCallExpression");
  function p1(e, t = null, r = null, i = null, n = !1, a = !1) {
    return (0, E.default)({
      type: "ClassProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    });
  }
  s(p1, "classProperty");
  function f1(e, t = null, r = null, i = null, n = !1, a = !1) {
    return (0, E.default)({
      type: "ClassAccessorProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    });
  }
  s(f1, "classAccessorProperty");
  function h1(e, t = null, r = null, i = !1) {
    return (0, E.default)({
      type: "ClassPrivateProperty",
      key: e,
      value: t,
      decorators: r,
      static: i
    });
  }
  s(h1, "classPrivateProperty");
  function d1(e = "method", t, r, i, n = !1) {
    return (0, E.default)({
      type: "ClassPrivateMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      static: n
    });
  }
  s(d1, "classPrivateMethod");
  function m1(e) {
    return (0, E.default)({
      type: "PrivateName",
      id: e
    });
  }
  s(m1, "privateName");
  function y1(e) {
    return (0, E.default)({
      type: "StaticBlock",
      body: e
    });
  }
  s(y1, "staticBlock");
  function T1() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  s(T1, "anyTypeAnnotation");
  function g1(e) {
    return (0, E.default)({
      type: "ArrayTypeAnnotation",
      elementType: e
    });
  }
  s(g1, "arrayTypeAnnotation");
  function b1() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  s(b1, "booleanTypeAnnotation");
  function S1(e) {
    return (0, E.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: e
    });
  }
  s(S1, "booleanLiteralTypeAnnotation");
  function x1() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  s(x1, "nullLiteralTypeAnnotation");
  function E1(e, t = null) {
    return (0, E.default)({
      type: "ClassImplements",
      id: e,
      typeParameters: t
    });
  }
  s(E1, "classImplements");
  function P1(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "DeclareClass",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    });
  }
  s(P1, "declareClass");
  function A1(e) {
    return (0, E.default)({
      type: "DeclareFunction",
      id: e
    });
  }
  s(A1, "declareFunction");
  function v1(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "DeclareInterface",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    });
  }
  s(v1, "declareInterface");
  function C1(e, t, r = null) {
    return (0, E.default)({
      type: "DeclareModule",
      id: e,
      body: t,
      kind: r
    });
  }
  s(C1, "declareModule");
  function I1(e) {
    return (0, E.default)({
      type: "DeclareModuleExports",
      typeAnnotation: e
    });
  }
  s(I1, "declareModuleExports");
  function w1(e, t = null, r) {
    return (0, E.default)({
      type: "DeclareTypeAlias",
      id: e,
      typeParameters: t,
      right: r
    });
  }
  s(w1, "declareTypeAlias");
  function O1(e, t = null, r = null) {
    return (0, E.default)({
      type: "DeclareOpaqueType",
      id: e,
      typeParameters: t,
      supertype: r
    });
  }
  s(O1, "declareOpaqueType");
  function N1(e) {
    return (0, E.default)({
      type: "DeclareVariable",
      id: e
    });
  }
  s(N1, "declareVariable");
  function _1(e = null, t = null, r = null) {
    return (0, E.default)({
      type: "DeclareExportDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    });
  }
  s(_1, "declareExportDeclaration");
  function D1(e) {
    return (0, E.default)({
      type: "DeclareExportAllDeclaration",
      source: e
    });
  }
  s(D1, "declareExportAllDeclaration");
  function k1(e) {
    return (0, E.default)({
      type: "DeclaredPredicate",
      value: e
    });
  }
  s(k1, "declaredPredicate");
  function L1() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  s(L1, "existsTypeAnnotation");
  function M1(e = null, t, r = null, i) {
    return (0, E.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: e,
      params: t,
      rest: r,
      returnType: i
    });
  }
  s(M1, "functionTypeAnnotation");
  function F1(e = null, t) {
    return (0, E.default)({
      type: "FunctionTypeParam",
      name: e,
      typeAnnotation: t
    });
  }
  s(F1, "functionTypeParam");
  function B1(e, t = null) {
    return (0, E.default)({
      type: "GenericTypeAnnotation",
      id: e,
      typeParameters: t
    });
  }
  s(B1, "genericTypeAnnotation");
  function j1() {
    return {
      type: "InferredPredicate"
    };
  }
  s(j1, "inferredPredicate");
  function R1(e, t = null) {
    return (0, E.default)({
      type: "InterfaceExtends",
      id: e,
      typeParameters: t
    });
  }
  s(R1, "interfaceExtends");
  function q1(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "InterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    });
  }
  s(q1, "interfaceDeclaration");
  function V1(e = null, t) {
    return (0, E.default)({
      type: "InterfaceTypeAnnotation",
      extends: e,
      body: t
    });
  }
  s(V1, "interfaceTypeAnnotation");
  function U1(e) {
    return (0, E.default)({
      type: "IntersectionTypeAnnotation",
      types: e
    });
  }
  s(U1, "intersectionTypeAnnotation");
  function K1() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  s(K1, "mixedTypeAnnotation");
  function W1() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  s(W1, "emptyTypeAnnotation");
  function Y1(e) {
    return (0, E.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: e
    });
  }
  s(Y1, "nullableTypeAnnotation");
  function X1(e) {
    return (0, E.default)({
      type: "NumberLiteralTypeAnnotation",
      value: e
    });
  }
  s(X1, "numberLiteralTypeAnnotation");
  function J1() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  s(J1, "numberTypeAnnotation");
  function $1(e, t = [], r = [], i = [], n = !1) {
    return (0, E.default)({
      type: "ObjectTypeAnnotation",
      properties: e,
      indexers: t,
      callProperties: r,
      internalSlots: i,
      exact: n
    });
  }
  s($1, "objectTypeAnnotation");
  function H1(e, t, r, i, n) {
    return (0, E.default)({
      type: "ObjectTypeInternalSlot",
      id: e,
      value: t,
      optional: r,
      static: i,
      method: n
    });
  }
  s(H1, "objectTypeInternalSlot");
  function G1(e) {
    return (0, E.default)({
      type: "ObjectTypeCallProperty",
      value: e,
      static: null
    });
  }
  s(G1, "objectTypeCallProperty");
  function z1(e = null, t, r, i = null) {
    return (0, E.default)({
      type: "ObjectTypeIndexer",
      id: e,
      key: t,
      value: r,
      variance: i,
      static: null
    });
  }
  s(z1, "objectTypeIndexer");
  function Q1(e, t, r = null) {
    return (0, E.default)({
      type: "ObjectTypeProperty",
      key: e,
      value: t,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  s(Q1, "objectTypeProperty");
  function Z1(e) {
    return (0, E.default)({
      type: "ObjectTypeSpreadProperty",
      argument: e
    });
  }
  s(Z1, "objectTypeSpreadProperty");
  function eC(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "OpaqueType",
      id: e,
      typeParameters: t,
      supertype: r,
      impltype: i
    });
  }
  s(eC, "opaqueType");
  function tC(e, t) {
    return (0, E.default)({
      type: "QualifiedTypeIdentifier",
      id: e,
      qualification: t
    });
  }
  s(tC, "qualifiedTypeIdentifier");
  function rC(e) {
    return (0, E.default)({
      type: "StringLiteralTypeAnnotation",
      value: e
    });
  }
  s(rC, "stringLiteralTypeAnnotation");
  function iC() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  s(iC, "stringTypeAnnotation");
  function sC() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  s(sC, "symbolTypeAnnotation");
  function nC() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  s(nC, "thisTypeAnnotation");
  function aC(e) {
    return (0, E.default)({
      type: "TupleTypeAnnotation",
      types: e
    });
  }
  s(aC, "tupleTypeAnnotation");
  function oC(e) {
    return (0, E.default)({
      type: "TypeofTypeAnnotation",
      argument: e
    });
  }
  s(oC, "typeofTypeAnnotation");
  function lC(e, t = null, r) {
    return (0, E.default)({
      type: "TypeAlias",
      id: e,
      typeParameters: t,
      right: r
    });
  }
  s(lC, "typeAlias");
  function uC(e) {
    return (0, E.default)({
      type: "TypeAnnotation",
      typeAnnotation: e
    });
  }
  s(uC, "typeAnnotation");
  function cC(e, t) {
    return (0, E.default)({
      type: "TypeCastExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  s(cC, "typeCastExpression");
  function pC(e = null, t = null, r = null) {
    return (0, E.default)({
      type: "TypeParameter",
      bound: e,
      default: t,
      variance: r,
      name: null
    });
  }
  s(pC, "typeParameter");
  function fC(e) {
    return (0, E.default)({
      type: "TypeParameterDeclaration",
      params: e
    });
  }
  s(fC, "typeParameterDeclaration");
  function hC(e) {
    return (0, E.default)({
      type: "TypeParameterInstantiation",
      params: e
    });
  }
  s(hC, "typeParameterInstantiation");
  function dC(e) {
    return (0, E.default)({
      type: "UnionTypeAnnotation",
      types: e
    });
  }
  s(dC, "unionTypeAnnotation");
  function mC(e) {
    return (0, E.default)({
      type: "Variance",
      kind: e
    });
  }
  s(mC, "variance");
  function yC() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  s(yC, "voidTypeAnnotation");
  function TC(e, t) {
    return (0, E.default)({
      type: "EnumDeclaration",
      id: e,
      body: t
    });
  }
  s(TC, "enumDeclaration");
  function gC(e) {
    return (0, E.default)({
      type: "EnumBooleanBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  s(gC, "enumBooleanBody");
  function bC(e) {
    return (0, E.default)({
      type: "EnumNumberBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  s(bC, "enumNumberBody");
  function SC(e) {
    return (0, E.default)({
      type: "EnumStringBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  s(SC, "enumStringBody");
  function xC(e) {
    return (0, E.default)({
      type: "EnumSymbolBody",
      members: e,
      hasUnknownMembers: null
    });
  }
  s(xC, "enumSymbolBody");
  function EC(e) {
    return (0, E.default)({
      type: "EnumBooleanMember",
      id: e,
      init: null
    });
  }
  s(EC, "enumBooleanMember");
  function PC(e, t) {
    return (0, E.default)({
      type: "EnumNumberMember",
      id: e,
      init: t
    });
  }
  s(PC, "enumNumberMember");
  function AC(e, t) {
    return (0, E.default)({
      type: "EnumStringMember",
      id: e,
      init: t
    });
  }
  s(AC, "enumStringMember");
  function vC(e) {
    return (0, E.default)({
      type: "EnumDefaultedMember",
      id: e
    });
  }
  s(vC, "enumDefaultedMember");
  function CC(e, t) {
    return (0, E.default)({
      type: "IndexedAccessType",
      objectType: e,
      indexType: t
    });
  }
  s(CC, "indexedAccessType");
  function IC(e, t) {
    return (0, E.default)({
      type: "OptionalIndexedAccessType",
      objectType: e,
      indexType: t,
      optional: null
    });
  }
  s(IC, "optionalIndexedAccessType");
  function wC(e, t = null) {
    return (0, E.default)({
      type: "JSXAttribute",
      name: e,
      value: t
    });
  }
  s(wC, "jsxAttribute");
  function OC(e) {
    return (0, E.default)({
      type: "JSXClosingElement",
      name: e
    });
  }
  s(OC, "jsxClosingElement");
  function NC(e, t = null, r, i = null) {
    return (0, E.default)({
      type: "JSXElement",
      openingElement: e,
      closingElement: t,
      children: r,
      selfClosing: i
    });
  }
  s(NC, "jsxElement");
  function _C() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  s(_C, "jsxEmptyExpression");
  function DC(e) {
    return (0, E.default)({
      type: "JSXExpressionContainer",
      expression: e
    });
  }
  s(DC, "jsxExpressionContainer");
  function kC(e) {
    return (0, E.default)({
      type: "JSXSpreadChild",
      expression: e
    });
  }
  s(kC, "jsxSpreadChild");
  function LC(e) {
    return (0, E.default)({
      type: "JSXIdentifier",
      name: e
    });
  }
  s(LC, "jsxIdentifier");
  function MC(e, t) {
    return (0, E.default)({
      type: "JSXMemberExpression",
      object: e,
      property: t
    });
  }
  s(MC, "jsxMemberExpression");
  function FC(e, t) {
    return (0, E.default)({
      type: "JSXNamespacedName",
      namespace: e,
      name: t
    });
  }
  s(FC, "jsxNamespacedName");
  function BC(e, t, r = !1) {
    return (0, E.default)({
      type: "JSXOpeningElement",
      name: e,
      attributes: t,
      selfClosing: r
    });
  }
  s(BC, "jsxOpeningElement");
  function jC(e) {
    return (0, E.default)({
      type: "JSXSpreadAttribute",
      argument: e
    });
  }
  s(jC, "jsxSpreadAttribute");
  function RC(e) {
    return (0, E.default)({
      type: "JSXText",
      value: e
    });
  }
  s(RC, "jsxText");
  function qC(e, t, r) {
    return (0, E.default)({
      type: "JSXFragment",
      openingFragment: e,
      closingFragment: t,
      children: r
    });
  }
  s(qC, "jsxFragment");
  function VC() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  s(VC, "jsxOpeningFragment");
  function UC() {
    return {
      type: "JSXClosingFragment"
    };
  }
  s(UC, "jsxClosingFragment");
  function KC() {
    return {
      type: "Noop"
    };
  }
  s(KC, "noop");
  function WC(e, t) {
    return (0, E.default)({
      type: "Placeholder",
      expectedNode: e,
      name: t
    });
  }
  s(WC, "placeholder");
  function YC(e) {
    return (0, E.default)({
      type: "V8IntrinsicIdentifier",
      name: e
    });
  }
  s(YC, "v8IntrinsicIdentifier");
  function XC() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  s(XC, "argumentPlaceholder");
  function JC(e, t) {
    return (0, E.default)({
      type: "BindExpression",
      object: e,
      callee: t
    });
  }
  s(JC, "bindExpression");
  function $C(e, t) {
    return (0, E.default)({
      type: "ImportAttribute",
      key: e,
      value: t
    });
  }
  s($C, "importAttribute");
  function HC(e) {
    return (0, E.default)({
      type: "Decorator",
      expression: e
    });
  }
  s(HC, "decorator");
  function GC(e, t = !1) {
    return (0, E.default)({
      type: "DoExpression",
      body: e,
      async: t
    });
  }
  s(GC, "doExpression");
  function zC(e) {
    return (0, E.default)({
      type: "ExportDefaultSpecifier",
      exported: e
    });
  }
  s(zC, "exportDefaultSpecifier");
  function QC(e) {
    return (0, E.default)({
      type: "RecordExpression",
      properties: e
    });
  }
  s(QC, "recordExpression");
  function ZC(e = []) {
    return (0, E.default)({
      type: "TupleExpression",
      elements: e
    });
  }
  s(ZC, "tupleExpression");
  function eI(e) {
    return (0, E.default)({
      type: "DecimalLiteral",
      value: e
    });
  }
  s(eI, "decimalLiteral");
  function tI(e) {
    return (0, E.default)({
      type: "ModuleExpression",
      body: e
    });
  }
  s(tI, "moduleExpression");
  function rI() {
    return {
      type: "TopicReference"
    };
  }
  s(rI, "topicReference");
  function iI(e) {
    return (0, E.default)({
      type: "PipelineTopicExpression",
      expression: e
    });
  }
  s(iI, "pipelineTopicExpression");
  function sI(e) {
    return (0, E.default)({
      type: "PipelineBareFunction",
      callee: e
    });
  }
  s(sI, "pipelineBareFunction");
  function nI() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  s(nI, "pipelinePrimaryTopicReference");
  function aI(e) {
    return (0, E.default)({
      type: "TSParameterProperty",
      parameter: e
    });
  }
  s(aI, "tsParameterProperty");
  function oI(e = null, t = null, r, i = null) {
    return (0, E.default)({
      type: "TSDeclareFunction",
      id: e,
      typeParameters: t,
      params: r,
      returnType: i
    });
  }
  s(oI, "tsDeclareFunction");
  function lI(e = null, t, r = null, i, n = null) {
    return (0, E.default)({
      type: "TSDeclareMethod",
      decorators: e,
      key: t,
      typeParameters: r,
      params: i,
      returnType: n
    });
  }
  s(lI, "tsDeclareMethod");
  function uI(e, t) {
    return (0, E.default)({
      type: "TSQualifiedName",
      left: e,
      right: t
    });
  }
  s(uI, "tsQualifiedName");
  function cI(e = null, t, r = null) {
    return (0, E.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(cI, "tsCallSignatureDeclaration");
  function pI(e = null, t, r = null) {
    return (0, E.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(pI, "tsConstructSignatureDeclaration");
  function fI(e, t = null) {
    return (0, E.default)({
      type: "TSPropertySignature",
      key: e,
      typeAnnotation: t,
      kind: null
    });
  }
  s(fI, "tsPropertySignature");
  function hI(e, t = null, r, i = null) {
    return (0, E.default)({
      type: "TSMethodSignature",
      key: e,
      typeParameters: t,
      parameters: r,
      typeAnnotation: i,
      kind: null
    });
  }
  s(hI, "tsMethodSignature");
  function dI(e, t = null) {
    return (0, E.default)({
      type: "TSIndexSignature",
      parameters: e,
      typeAnnotation: t
    });
  }
  s(dI, "tsIndexSignature");
  function mI() {
    return {
      type: "TSAnyKeyword"
    };
  }
  s(mI, "tsAnyKeyword");
  function yI() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  s(yI, "tsBooleanKeyword");
  function TI() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  s(TI, "tsBigIntKeyword");
  function gI() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  s(gI, "tsIntrinsicKeyword");
  function bI() {
    return {
      type: "TSNeverKeyword"
    };
  }
  s(bI, "tsNeverKeyword");
  function SI() {
    return {
      type: "TSNullKeyword"
    };
  }
  s(SI, "tsNullKeyword");
  function xI() {
    return {
      type: "TSNumberKeyword"
    };
  }
  s(xI, "tsNumberKeyword");
  function EI() {
    return {
      type: "TSObjectKeyword"
    };
  }
  s(EI, "tsObjectKeyword");
  function PI() {
    return {
      type: "TSStringKeyword"
    };
  }
  s(PI, "tsStringKeyword");
  function AI() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  s(AI, "tsSymbolKeyword");
  function vI() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  s(vI, "tsUndefinedKeyword");
  function CI() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  s(CI, "tsUnknownKeyword");
  function II() {
    return {
      type: "TSVoidKeyword"
    };
  }
  s(II, "tsVoidKeyword");
  function wI() {
    return {
      type: "TSThisType"
    };
  }
  s(wI, "tsThisType");
  function OI(e = null, t, r = null) {
    return (0, E.default)({
      type: "TSFunctionType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(OI, "tsFunctionType");
  function NI(e = null, t, r = null) {
    return (0, E.default)({
      type: "TSConstructorType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(NI, "tsConstructorType");
  function _I(e, t = null) {
    return (0, E.default)({
      type: "TSTypeReference",
      typeName: e,
      typeParameters: t
    });
  }
  s(_I, "tsTypeReference");
  function DI(e, t = null, r = null) {
    return (0, E.default)({
      type: "TSTypePredicate",
      parameterName: e,
      typeAnnotation: t,
      asserts: r
    });
  }
  s(DI, "tsTypePredicate");
  function kI(e, t = null) {
    return (0, E.default)({
      type: "TSTypeQuery",
      exprName: e,
      typeParameters: t
    });
  }
  s(kI, "tsTypeQuery");
  function LI(e) {
    return (0, E.default)({
      type: "TSTypeLiteral",
      members: e
    });
  }
  s(LI, "tsTypeLiteral");
  function MI(e) {
    return (0, E.default)({
      type: "TSArrayType",
      elementType: e
    });
  }
  s(MI, "tsArrayType");
  function FI(e) {
    return (0, E.default)({
      type: "TSTupleType",
      elementTypes: e
    });
  }
  s(FI, "tsTupleType");
  function BI(e) {
    return (0, E.default)({
      type: "TSOptionalType",
      typeAnnotation: e
    });
  }
  s(BI, "tsOptionalType");
  function jI(e) {
    return (0, E.default)({
      type: "TSRestType",
      typeAnnotation: e
    });
  }
  s(jI, "tsRestType");
  function RI(e, t, r = !1) {
    return (0, E.default)({
      type: "TSNamedTupleMember",
      label: e,
      elementType: t,
      optional: r
    });
  }
  s(RI, "tsNamedTupleMember");
  function qI(e) {
    return (0, E.default)({
      type: "TSUnionType",
      types: e
    });
  }
  s(qI, "tsUnionType");
  function VI(e) {
    return (0, E.default)({
      type: "TSIntersectionType",
      types: e
    });
  }
  s(VI, "tsIntersectionType");
  function UI(e, t, r, i) {
    return (0, E.default)({
      type: "TSConditionalType",
      checkType: e,
      extendsType: t,
      trueType: r,
      falseType: i
    });
  }
  s(UI, "tsConditionalType");
  function KI(e) {
    return (0, E.default)({
      type: "TSInferType",
      typeParameter: e
    });
  }
  s(KI, "tsInferType");
  function WI(e) {
    return (0, E.default)({
      type: "TSParenthesizedType",
      typeAnnotation: e
    });
  }
  s(WI, "tsParenthesizedType");
  function YI(e) {
    return (0, E.default)({
      type: "TSTypeOperator",
      typeAnnotation: e,
      operator: null
    });
  }
  s(YI, "tsTypeOperator");
  function XI(e, t) {
    return (0, E.default)({
      type: "TSIndexedAccessType",
      objectType: e,
      indexType: t
    });
  }
  s(XI, "tsIndexedAccessType");
  function JI(e, t = null, r = null) {
    return (0, E.default)({
      type: "TSMappedType",
      typeParameter: e,
      typeAnnotation: t,
      nameType: r
    });
  }
  s(JI, "tsMappedType");
  function $I(e) {
    return (0, E.default)({
      type: "TSLiteralType",
      literal: e
    });
  }
  s($I, "tsLiteralType");
  function HI(e, t = null) {
    return (0, E.default)({
      type: "TSExpressionWithTypeArguments",
      expression: e,
      typeParameters: t
    });
  }
  s(HI, "tsExpressionWithTypeArguments");
  function GI(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "TSInterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    });
  }
  s(GI, "tsInterfaceDeclaration");
  function zI(e) {
    return (0, E.default)({
      type: "TSInterfaceBody",
      body: e
    });
  }
  s(zI, "tsInterfaceBody");
  function QI(e, t = null, r) {
    return (0, E.default)({
      type: "TSTypeAliasDeclaration",
      id: e,
      typeParameters: t,
      typeAnnotation: r
    });
  }
  s(QI, "tsTypeAliasDeclaration");
  function ZI(e, t = null) {
    return (0, E.default)({
      type: "TSInstantiationExpression",
      expression: e,
      typeParameters: t
    });
  }
  s(ZI, "tsInstantiationExpression");
  function ew(e, t) {
    return (0, E.default)({
      type: "TSAsExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  s(ew, "tsAsExpression");
  function tw(e, t) {
    return (0, E.default)({
      type: "TSSatisfiesExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  s(tw, "tsSatisfiesExpression");
  function rw(e, t) {
    return (0, E.default)({
      type: "TSTypeAssertion",
      typeAnnotation: e,
      expression: t
    });
  }
  s(rw, "tsTypeAssertion");
  function iw(e, t) {
    return (0, E.default)({
      type: "TSEnumDeclaration",
      id: e,
      members: t
    });
  }
  s(iw, "tsEnumDeclaration");
  function sw(e, t = null) {
    return (0, E.default)({
      type: "TSEnumMember",
      id: e,
      initializer: t
    });
  }
  s(sw, "tsEnumMember");
  function nw(e, t) {
    return (0, E.default)({
      type: "TSModuleDeclaration",
      id: e,
      body: t
    });
  }
  s(nw, "tsModuleDeclaration");
  function aw(e) {
    return (0, E.default)({
      type: "TSModuleBlock",
      body: e
    });
  }
  s(aw, "tsModuleBlock");
  function ow(e, t = null, r = null) {
    return (0, E.default)({
      type: "TSImportType",
      argument: e,
      qualifier: t,
      typeParameters: r
    });
  }
  s(ow, "tsImportType");
  function lw(e, t) {
    return (0, E.default)({
      type: "TSImportEqualsDeclaration",
      id: e,
      moduleReference: t,
      isExport: null
    });
  }
  s(lw, "tsImportEqualsDeclaration");
  function uw(e) {
    return (0, E.default)({
      type: "TSExternalModuleReference",
      expression: e
    });
  }
  s(uw, "tsExternalModuleReference");
  function cw(e) {
    return (0, E.default)({
      type: "TSNonNullExpression",
      expression: e
    });
  }
  s(cw, "tsNonNullExpression");
  function pw(e) {
    return (0, E.default)({
      type: "TSExportAssignment",
      expression: e
    });
  }
  s(pw, "tsExportAssignment");
  function fw(e) {
    return (0, E.default)({
      type: "TSNamespaceExportDeclaration",
      id: e
    });
  }
  s(fw, "tsNamespaceExportDeclaration");
  function hw(e) {
    return (0, E.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: e
    });
  }
  s(hw, "tsTypeAnnotation");
  function dw(e) {
    return (0, E.default)({
      type: "TSTypeParameterInstantiation",
      params: e
    });
  }
  s(dw, "tsTypeParameterInstantiation");
  function mw(e) {
    return (0, E.default)({
      type: "TSTypeParameterDeclaration",
      params: e
    });
  }
  s(mw, "tsTypeParameterDeclaration");
  function yw(e = null, t = null, r) {
    return (0, E.default)({
      type: "TSTypeParameter",
      constraint: e,
      default: t,
      name: r
    });
  }
  s(yw, "tsTypeParameter");
  function Tw(e) {
    return (0, Js.default)("NumberLiteral", "NumericLiteral", "The node type "), ff(e);
  }
  s(Tw, "NumberLiteral");
  function gw(e, t = "") {
    return (0, Js.default)("RegexLiteral", "RegExpLiteral", "The node type "), hf(e, t);
  }
  s(gw, "RegexLiteral");
  function bw(e) {
    return (0, Js.default)("RestProperty", "RestElement", "The node type "), df(e);
  }
  s(bw, "RestProperty");
  function Sw(e) {
    return (0, Js.default)("SpreadProperty", "SpreadElement", "The node type "), mf(e);
  }
  s(Sw, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var yf = v((Ga) => {
  "use strict";
  Object.defineProperty(Ga, "__esModule", {
    value: !0
  });
  Ga.default = Pw;
  var xw = ut(), Ew = le();
  function Pw(e, t) {
    let r = e.value.split(/\r\n|\n|\r/), i = 0;
    for (let a = 0; a < r.length; a++)
      r[a].match(/[^ \t]/) && (i = a);
    let n = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, c = a === i, p = o.replace(/\t/g, " ");
      l || (p = p.replace(/^[ ]+/, "")), u || (p = p.replace(/[ ]+$/, "")), p && (c || (p += " "), n += p);
    }
    n && t.push((0, Ew.inherits)((0, xw.stringLiteral)(n), e));
  }
  s(Pw, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var Tf = v((Qa) => {
  "use strict";
  Object.defineProperty(Qa, "__esModule", {
    value: !0
  });
  Qa.default = vw;
  var za = We(), Aw = yf();
  function vw(e) {
    let t = [];
    for (let r = 0; r < e.children.length; r++) {
      let i = e.children[r];
      if ((0, za.isJSXText)(i)) {
        (0, Aw.default)(i, t);
        continue;
      }
      (0, za.isJSXExpressionContainer)(i) && (i = i.expression), !(0, za.isJSXEmptyExpression)(i) && t.push(i);
    }
    return t;
  }
  s(vw, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var eo = v((Za) => {
  "use strict";
  Object.defineProperty(Za, "__esModule", {
    value: !0
  });
  Za.default = Iw;
  var Cw = Et();
  function Iw(e) {
    return !!(e && Cw.VISITOR_KEYS[e.type]);
  }
  s(Iw, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var gf = v((to) => {
  "use strict";
  Object.defineProperty(to, "__esModule", {
    value: !0
  });
  to.default = Ow;
  var ww = eo();
  function Ow(e) {
    if (!(0, ww.default)(e)) {
      var t;
      let r = (t = e?.type) != null ? t : JSON.stringify(e);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  s(Ow, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var bf = v((m) => {
  "use strict";
  Object.defineProperty(m, "__esModule", {
    value: !0
  });
  m.assertAccessor = YD;
  m.assertAnyTypeAnnotation = pN;
  m.assertArgumentPlaceholder = q_;
  m.assertArrayExpression = _w;
  m.assertArrayPattern = OO;
  m.assertArrayTypeAnnotation = fN;
  m.assertArrowFunctionExpression = NO;
  m.assertAssignmentExpression = Dw;
  m.assertAssignmentPattern = wO;
  m.assertAwaitExpression = ZO;
  m.assertBigIntLiteral = tN;
  m.assertBinary = hD;
  m.assertBinaryExpression = kw;
  m.assertBindExpression = V_;
  m.assertBlock = yD;
  m.assertBlockParent = mD;
  m.assertBlockStatement = Bw;
  m.assertBooleanLiteral = sO;
  m.assertBooleanLiteralTypeAnnotation = dN;
  m.assertBooleanTypeAnnotation = hN;
  m.assertBreakStatement = jw;
  m.assertCallExpression = Rw;
  m.assertCatchClause = qw;
  m.assertClass = VD;
  m.assertClassAccessorProperty = aN;
  m.assertClassBody = _O;
  m.assertClassDeclaration = kO;
  m.assertClassExpression = DO;
  m.assertClassImplements = yN;
  m.assertClassMethod = YO;
  m.assertClassPrivateMethod = lN;
  m.assertClassPrivateProperty = oN;
  m.assertClassProperty = nN;
  m.assertCompletionStatement = bD;
  m.assertConditional = SD;
  m.assertConditionalExpression = Vw;
  m.assertContinueStatement = Uw;
  m.assertDebuggerStatement = Kw;
  m.assertDecimalLiteral = $_;
  m.assertDeclaration = OD;
  m.assertDeclareClass = TN;
  m.assertDeclareExportAllDeclaration = CN;
  m.assertDeclareExportDeclaration = vN;
  m.assertDeclareFunction = gN;
  m.assertDeclareInterface = bN;
  m.assertDeclareModule = SN;
  m.assertDeclareModuleExports = xN;
  m.assertDeclareOpaqueType = PN;
  m.assertDeclareTypeAlias = EN;
  m.assertDeclareVariable = AN;
  m.assertDeclaredPredicate = IN;
  m.assertDecorator = K_;
  m.assertDirective = Mw;
  m.assertDirectiveLiteral = Fw;
  m.assertDoExpression = W_;
  m.assertDoWhileStatement = Ww;
  m.assertEmptyStatement = Yw;
  m.assertEmptyTypeAnnotation = jN;
  m.assertEnumBody = QD;
  m.assertEnumBooleanBody = f_;
  m.assertEnumBooleanMember = y_;
  m.assertEnumDeclaration = p_;
  m.assertEnumDefaultedMember = b_;
  m.assertEnumMember = ZD;
  m.assertEnumNumberBody = h_;
  m.assertEnumNumberMember = T_;
  m.assertEnumStringBody = d_;
  m.assertEnumStringMember = g_;
  m.assertEnumSymbolBody = m_;
  m.assertExistsTypeAnnotation = wN;
  m.assertExportAllDeclaration = LO;
  m.assertExportDeclaration = KD;
  m.assertExportDefaultDeclaration = MO;
  m.assertExportDefaultSpecifier = Y_;
  m.assertExportNamedDeclaration = FO;
  m.assertExportNamespaceSpecifier = rN;
  m.assertExportSpecifier = BO;
  m.assertExpression = fD;
  m.assertExpressionStatement = Xw;
  m.assertExpressionWrapper = PD;
  m.assertFile = Jw;
  m.assertFlow = JD;
  m.assertFlowBaseAnnotation = HD;
  m.assertFlowDeclaration = GD;
  m.assertFlowPredicate = zD;
  m.assertFlowType = $D;
  m.assertFor = AD;
  m.assertForInStatement = $w;
  m.assertForOfStatement = jO;
  m.assertForStatement = Hw;
  m.assertForXStatement = vD;
  m.assertFunction = CD;
  m.assertFunctionDeclaration = Gw;
  m.assertFunctionExpression = zw;
  m.assertFunctionParent = ID;
  m.assertFunctionTypeAnnotation = ON;
  m.assertFunctionTypeParam = NN;
  m.assertGenericTypeAnnotation = _N;
  m.assertIdentifier = Qw;
  m.assertIfStatement = Zw;
  m.assertImmutable = LD;
  m.assertImport = eN;
  m.assertImportAttribute = U_;
  m.assertImportDeclaration = RO;
  m.assertImportDefaultSpecifier = qO;
  m.assertImportExpression = KO;
  m.assertImportNamespaceSpecifier = VO;
  m.assertImportOrExportDeclaration = UD;
  m.assertImportSpecifier = UO;
  m.assertIndexedAccessType = S_;
  m.assertInferredPredicate = DN;
  m.assertInterfaceDeclaration = LN;
  m.assertInterfaceExtends = kN;
  m.assertInterfaceTypeAnnotation = MN;
  m.assertInterpreterDirective = Lw;
  m.assertIntersectionTypeAnnotation = FN;
  m.assertJSX = ek;
  m.assertJSXAttribute = E_;
  m.assertJSXClosingElement = P_;
  m.assertJSXClosingFragment = F_;
  m.assertJSXElement = A_;
  m.assertJSXEmptyExpression = v_;
  m.assertJSXExpressionContainer = C_;
  m.assertJSXFragment = L_;
  m.assertJSXIdentifier = w_;
  m.assertJSXMemberExpression = O_;
  m.assertJSXNamespacedName = N_;
  m.assertJSXOpeningElement = __;
  m.assertJSXOpeningFragment = M_;
  m.assertJSXSpreadAttribute = D_;
  m.assertJSXSpreadChild = I_;
  m.assertJSXText = k_;
  m.assertLVal = _D;
  m.assertLabeledStatement = eO;
  m.assertLiteral = kD;
  m.assertLogicalExpression = aO;
  m.assertLoop = xD;
  m.assertMemberExpression = oO;
  m.assertMetaProperty = WO;
  m.assertMethod = FD;
  m.assertMiscellaneous = tk;
  m.assertMixedTypeAnnotation = BN;
  m.assertModuleDeclaration = ck;
  m.assertModuleExpression = H_;
  m.assertModuleSpecifier = WD;
  m.assertNewExpression = lO;
  m.assertNoop = B_;
  m.assertNullLiteral = iO;
  m.assertNullLiteralTypeAnnotation = mN;
  m.assertNullableTypeAnnotation = RN;
  m.assertNumberLiteral = ak;
  m.assertNumberLiteralTypeAnnotation = qN;
  m.assertNumberTypeAnnotation = VN;
  m.assertNumericLiteral = rO;
  m.assertObjectExpression = cO;
  m.assertObjectMember = BD;
  m.assertObjectMethod = pO;
  m.assertObjectPattern = XO;
  m.assertObjectProperty = fO;
  m.assertObjectTypeAnnotation = UN;
  m.assertObjectTypeCallProperty = WN;
  m.assertObjectTypeIndexer = YN;
  m.assertObjectTypeInternalSlot = KN;
  m.assertObjectTypeProperty = XN;
  m.assertObjectTypeSpreadProperty = JN;
  m.assertOpaqueType = $N;
  m.assertOptionalCallExpression = sN;
  m.assertOptionalIndexedAccessType = x_;
  m.assertOptionalMemberExpression = iN;
  m.assertParenthesizedExpression = yO;
  m.assertPattern = qD;
  m.assertPatternLike = ND;
  m.assertPipelineBareFunction = Q_;
  m.assertPipelinePrimaryTopicReference = Z_;
  m.assertPipelineTopicExpression = z_;
  m.assertPlaceholder = j_;
  m.assertPrivate = XD;
  m.assertPrivateName = uN;
  m.assertProgram = uO;
  m.assertProperty = jD;
  m.assertPureish = wD;
  m.assertQualifiedTypeIdentifier = HN;
  m.assertRecordExpression = X_;
  m.assertRegExpLiteral = nO;
  m.assertRegexLiteral = ok;
  m.assertRestElement = hO;
  m.assertRestProperty = lk;
  m.assertReturnStatement = dO;
  m.assertScopable = dD;
  m.assertSequenceExpression = mO;
  m.assertSpreadElement = JO;
  m.assertSpreadProperty = uk;
  m.assertStandardized = pD;
  m.assertStatement = TD;
  m.assertStaticBlock = cN;
  m.assertStringLiteral = tO;
  m.assertStringLiteralTypeAnnotation = GN;
  m.assertStringTypeAnnotation = zN;
  m.assertSuper = $O;
  m.assertSwitchCase = TO;
  m.assertSwitchStatement = gO;
  m.assertSymbolTypeAnnotation = QN;
  m.assertTSAnyKeyword = u2;
  m.assertTSArrayType = O2;
  m.assertTSAsExpression = $2;
  m.assertTSBaseType = nk;
  m.assertTSBigIntKeyword = p2;
  m.assertTSBooleanKeyword = c2;
  m.assertTSCallSignatureDeclaration = s2;
  m.assertTSConditionalType = F2;
  m.assertTSConstructSignatureDeclaration = n2;
  m.assertTSConstructorType = A2;
  m.assertTSDeclareFunction = t2;
  m.assertTSDeclareMethod = r2;
  m.assertTSEntityName = DD;
  m.assertTSEnumDeclaration = z2;
  m.assertTSEnumMember = Q2;
  m.assertTSExportAssignment = nD;
  m.assertTSExpressionWithTypeArguments = K2;
  m.assertTSExternalModuleReference = iD;
  m.assertTSFunctionType = P2;
  m.assertTSImportEqualsDeclaration = rD;
  m.assertTSImportType = tD;
  m.assertTSIndexSignature = l2;
  m.assertTSIndexedAccessType = q2;
  m.assertTSInferType = B2;
  m.assertTSInstantiationExpression = J2;
  m.assertTSInterfaceBody = Y2;
  m.assertTSInterfaceDeclaration = W2;
  m.assertTSIntersectionType = M2;
  m.assertTSIntrinsicKeyword = f2;
  m.assertTSLiteralType = U2;
  m.assertTSMappedType = V2;
  m.assertTSMethodSignature = o2;
  m.assertTSModuleBlock = eD;
  m.assertTSModuleDeclaration = Z2;
  m.assertTSNamedTupleMember = k2;
  m.assertTSNamespaceExportDeclaration = aD;
  m.assertTSNeverKeyword = h2;
  m.assertTSNonNullExpression = sD;
  m.assertTSNullKeyword = d2;
  m.assertTSNumberKeyword = m2;
  m.assertTSObjectKeyword = y2;
  m.assertTSOptionalType = _2;
  m.assertTSParameterProperty = e2;
  m.assertTSParenthesizedType = j2;
  m.assertTSPropertySignature = a2;
  m.assertTSQualifiedName = i2;
  m.assertTSRestType = D2;
  m.assertTSSatisfiesExpression = H2;
  m.assertTSStringKeyword = T2;
  m.assertTSSymbolKeyword = g2;
  m.assertTSThisType = E2;
  m.assertTSTupleType = N2;
  m.assertTSType = sk;
  m.assertTSTypeAliasDeclaration = X2;
  m.assertTSTypeAnnotation = oD;
  m.assertTSTypeAssertion = G2;
  m.assertTSTypeElement = ik;
  m.assertTSTypeLiteral = w2;
  m.assertTSTypeOperator = R2;
  m.assertTSTypeParameter = cD;
  m.assertTSTypeParameterDeclaration = uD;
  m.assertTSTypeParameterInstantiation = lD;
  m.assertTSTypePredicate = C2;
  m.assertTSTypeQuery = I2;
  m.assertTSTypeReference = v2;
  m.assertTSUndefinedKeyword = b2;
  m.assertTSUnionType = L2;
  m.assertTSUnknownKeyword = S2;
  m.assertTSVoidKeyword = x2;
  m.assertTaggedTemplateExpression = HO;
  m.assertTemplateElement = GO;
  m.assertTemplateLiteral = zO;
  m.assertTerminatorless = gD;
  m.assertThisExpression = bO;
  m.assertThisTypeAnnotation = ZN;
  m.assertThrowStatement = SO;
  m.assertTopicReference = G_;
  m.assertTryStatement = xO;
  m.assertTupleExpression = J_;
  m.assertTupleTypeAnnotation = e_;
  m.assertTypeAlias = r_;
  m.assertTypeAnnotation = i_;
  m.assertTypeCastExpression = s_;
  m.assertTypeParameter = n_;
  m.assertTypeParameterDeclaration = a_;
  m.assertTypeParameterInstantiation = o_;
  m.assertTypeScript = rk;
  m.assertTypeofTypeAnnotation = t_;
  m.assertUnaryExpression = EO;
  m.assertUnaryLike = RD;
  m.assertUnionTypeAnnotation = l_;
  m.assertUpdateExpression = PO;
  m.assertUserWhitespacable = MD;
  m.assertV8IntrinsicIdentifier = R_;
  m.assertVariableDeclaration = AO;
  m.assertVariableDeclarator = vO;
  m.assertVariance = u_;
  m.assertVoidTypeAnnotation = c_;
  m.assertWhile = ED;
  m.assertWhileStatement = CO;
  m.assertWithStatement = IO;
  m.assertYieldExpression = QO;
  var Nw = zr(), Ui = Ni();
  function y(e, t, r) {
    if (!(0, Nw.default)(e, t, r))
      throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
  }
  s(y, "assert");
  function _w(e, t) {
    y("ArrayExpression", e, t);
  }
  s(_w, "assertArrayExpression");
  function Dw(e, t) {
    y("AssignmentExpression", e, t);
  }
  s(Dw, "assertAssignmentExpression");
  function kw(e, t) {
    y("BinaryExpression", e, t);
  }
  s(kw, "assertBinaryExpression");
  function Lw(e, t) {
    y("InterpreterDirective", e, t);
  }
  s(Lw, "assertInterpreterDirective");
  function Mw(e, t) {
    y("Directive", e, t);
  }
  s(Mw, "assertDirective");
  function Fw(e, t) {
    y("DirectiveLiteral", e, t);
  }
  s(Fw, "assertDirectiveLiteral");
  function Bw(e, t) {
    y("BlockStatement", e, t);
  }
  s(Bw, "assertBlockStatement");
  function jw(e, t) {
    y("BreakStatement", e, t);
  }
  s(jw, "assertBreakStatement");
  function Rw(e, t) {
    y("CallExpression", e, t);
  }
  s(Rw, "assertCallExpression");
  function qw(e, t) {
    y("CatchClause", e, t);
  }
  s(qw, "assertCatchClause");
  function Vw(e, t) {
    y("ConditionalExpression", e, t);
  }
  s(Vw, "assertConditionalExpression");
  function Uw(e, t) {
    y("ContinueStatement", e, t);
  }
  s(Uw, "assertContinueStatement");
  function Kw(e, t) {
    y("DebuggerStatement", e, t);
  }
  s(Kw, "assertDebuggerStatement");
  function Ww(e, t) {
    y("DoWhileStatement", e, t);
  }
  s(Ww, "assertDoWhileStatement");
  function Yw(e, t) {
    y("EmptyStatement", e, t);
  }
  s(Yw, "assertEmptyStatement");
  function Xw(e, t) {
    y("ExpressionStatement", e, t);
  }
  s(Xw, "assertExpressionStatement");
  function Jw(e, t) {
    y("File", e, t);
  }
  s(Jw, "assertFile");
  function $w(e, t) {
    y("ForInStatement", e, t);
  }
  s($w, "assertForInStatement");
  function Hw(e, t) {
    y("ForStatement", e, t);
  }
  s(Hw, "assertForStatement");
  function Gw(e, t) {
    y("FunctionDeclaration", e, t);
  }
  s(Gw, "assertFunctionDeclaration");
  function zw(e, t) {
    y("FunctionExpression", e, t);
  }
  s(zw, "assertFunctionExpression");
  function Qw(e, t) {
    y("Identifier", e, t);
  }
  s(Qw, "assertIdentifier");
  function Zw(e, t) {
    y("IfStatement", e, t);
  }
  s(Zw, "assertIfStatement");
  function eO(e, t) {
    y("LabeledStatement", e, t);
  }
  s(eO, "assertLabeledStatement");
  function tO(e, t) {
    y("StringLiteral", e, t);
  }
  s(tO, "assertStringLiteral");
  function rO(e, t) {
    y("NumericLiteral", e, t);
  }
  s(rO, "assertNumericLiteral");
  function iO(e, t) {
    y("NullLiteral", e, t);
  }
  s(iO, "assertNullLiteral");
  function sO(e, t) {
    y("BooleanLiteral", e, t);
  }
  s(sO, "assertBooleanLiteral");
  function nO(e, t) {
    y("RegExpLiteral", e, t);
  }
  s(nO, "assertRegExpLiteral");
  function aO(e, t) {
    y("LogicalExpression", e, t);
  }
  s(aO, "assertLogicalExpression");
  function oO(e, t) {
    y("MemberExpression", e, t);
  }
  s(oO, "assertMemberExpression");
  function lO(e, t) {
    y("NewExpression", e, t);
  }
  s(lO, "assertNewExpression");
  function uO(e, t) {
    y("Program", e, t);
  }
  s(uO, "assertProgram");
  function cO(e, t) {
    y("ObjectExpression", e, t);
  }
  s(cO, "assertObjectExpression");
  function pO(e, t) {
    y("ObjectMethod", e, t);
  }
  s(pO, "assertObjectMethod");
  function fO(e, t) {
    y("ObjectProperty", e, t);
  }
  s(fO, "assertObjectProperty");
  function hO(e, t) {
    y("RestElement", e, t);
  }
  s(hO, "assertRestElement");
  function dO(e, t) {
    y("ReturnStatement", e, t);
  }
  s(dO, "assertReturnStatement");
  function mO(e, t) {
    y("SequenceExpression", e, t);
  }
  s(mO, "assertSequenceExpression");
  function yO(e, t) {
    y("ParenthesizedExpression", e, t);
  }
  s(yO, "assertParenthesizedExpression");
  function TO(e, t) {
    y("SwitchCase", e, t);
  }
  s(TO, "assertSwitchCase");
  function gO(e, t) {
    y("SwitchStatement", e, t);
  }
  s(gO, "assertSwitchStatement");
  function bO(e, t) {
    y("ThisExpression", e, t);
  }
  s(bO, "assertThisExpression");
  function SO(e, t) {
    y("ThrowStatement", e, t);
  }
  s(SO, "assertThrowStatement");
  function xO(e, t) {
    y("TryStatement", e, t);
  }
  s(xO, "assertTryStatement");
  function EO(e, t) {
    y("UnaryExpression", e, t);
  }
  s(EO, "assertUnaryExpression");
  function PO(e, t) {
    y("UpdateExpression", e, t);
  }
  s(PO, "assertUpdateExpression");
  function AO(e, t) {
    y("VariableDeclaration", e, t);
  }
  s(AO, "assertVariableDeclaration");
  function vO(e, t) {
    y("VariableDeclarator", e, t);
  }
  s(vO, "assertVariableDeclarator");
  function CO(e, t) {
    y("WhileStatement", e, t);
  }
  s(CO, "assertWhileStatement");
  function IO(e, t) {
    y("WithStatement", e, t);
  }
  s(IO, "assertWithStatement");
  function wO(e, t) {
    y("AssignmentPattern", e, t);
  }
  s(wO, "assertAssignmentPattern");
  function OO(e, t) {
    y("ArrayPattern", e, t);
  }
  s(OO, "assertArrayPattern");
  function NO(e, t) {
    y("ArrowFunctionExpression", e, t);
  }
  s(NO, "assertArrowFunctionExpression");
  function _O(e, t) {
    y("ClassBody", e, t);
  }
  s(_O, "assertClassBody");
  function DO(e, t) {
    y("ClassExpression", e, t);
  }
  s(DO, "assertClassExpression");
  function kO(e, t) {
    y("ClassDeclaration", e, t);
  }
  s(kO, "assertClassDeclaration");
  function LO(e, t) {
    y("ExportAllDeclaration", e, t);
  }
  s(LO, "assertExportAllDeclaration");
  function MO(e, t) {
    y("ExportDefaultDeclaration", e, t);
  }
  s(MO, "assertExportDefaultDeclaration");
  function FO(e, t) {
    y("ExportNamedDeclaration", e, t);
  }
  s(FO, "assertExportNamedDeclaration");
  function BO(e, t) {
    y("ExportSpecifier", e, t);
  }
  s(BO, "assertExportSpecifier");
  function jO(e, t) {
    y("ForOfStatement", e, t);
  }
  s(jO, "assertForOfStatement");
  function RO(e, t) {
    y("ImportDeclaration", e, t);
  }
  s(RO, "assertImportDeclaration");
  function qO(e, t) {
    y("ImportDefaultSpecifier", e, t);
  }
  s(qO, "assertImportDefaultSpecifier");
  function VO(e, t) {
    y("ImportNamespaceSpecifier", e, t);
  }
  s(VO, "assertImportNamespaceSpecifier");
  function UO(e, t) {
    y("ImportSpecifier", e, t);
  }
  s(UO, "assertImportSpecifier");
  function KO(e, t) {
    y("ImportExpression", e, t);
  }
  s(KO, "assertImportExpression");
  function WO(e, t) {
    y("MetaProperty", e, t);
  }
  s(WO, "assertMetaProperty");
  function YO(e, t) {
    y("ClassMethod", e, t);
  }
  s(YO, "assertClassMethod");
  function XO(e, t) {
    y("ObjectPattern", e, t);
  }
  s(XO, "assertObjectPattern");
  function JO(e, t) {
    y("SpreadElement", e, t);
  }
  s(JO, "assertSpreadElement");
  function $O(e, t) {
    y("Super", e, t);
  }
  s($O, "assertSuper");
  function HO(e, t) {
    y("TaggedTemplateExpression", e, t);
  }
  s(HO, "assertTaggedTemplateExpression");
  function GO(e, t) {
    y("TemplateElement", e, t);
  }
  s(GO, "assertTemplateElement");
  function zO(e, t) {
    y("TemplateLiteral", e, t);
  }
  s(zO, "assertTemplateLiteral");
  function QO(e, t) {
    y("YieldExpression", e, t);
  }
  s(QO, "assertYieldExpression");
  function ZO(e, t) {
    y("AwaitExpression", e, t);
  }
  s(ZO, "assertAwaitExpression");
  function eN(e, t) {
    y("Import", e, t);
  }
  s(eN, "assertImport");
  function tN(e, t) {
    y("BigIntLiteral", e, t);
  }
  s(tN, "assertBigIntLiteral");
  function rN(e, t) {
    y("ExportNamespaceSpecifier", e, t);
  }
  s(rN, "assertExportNamespaceSpecifier");
  function iN(e, t) {
    y("OptionalMemberExpression", e, t);
  }
  s(iN, "assertOptionalMemberExpression");
  function sN(e, t) {
    y("OptionalCallExpression", e, t);
  }
  s(sN, "assertOptionalCallExpression");
  function nN(e, t) {
    y("ClassProperty", e, t);
  }
  s(nN, "assertClassProperty");
  function aN(e, t) {
    y("ClassAccessorProperty", e, t);
  }
  s(aN, "assertClassAccessorProperty");
  function oN(e, t) {
    y("ClassPrivateProperty", e, t);
  }
  s(oN, "assertClassPrivateProperty");
  function lN(e, t) {
    y("ClassPrivateMethod", e, t);
  }
  s(lN, "assertClassPrivateMethod");
  function uN(e, t) {
    y("PrivateName", e, t);
  }
  s(uN, "assertPrivateName");
  function cN(e, t) {
    y("StaticBlock", e, t);
  }
  s(cN, "assertStaticBlock");
  function pN(e, t) {
    y("AnyTypeAnnotation", e, t);
  }
  s(pN, "assertAnyTypeAnnotation");
  function fN(e, t) {
    y("ArrayTypeAnnotation", e, t);
  }
  s(fN, "assertArrayTypeAnnotation");
  function hN(e, t) {
    y("BooleanTypeAnnotation", e, t);
  }
  s(hN, "assertBooleanTypeAnnotation");
  function dN(e, t) {
    y("BooleanLiteralTypeAnnotation", e, t);
  }
  s(dN, "assertBooleanLiteralTypeAnnotation");
  function mN(e, t) {
    y("NullLiteralTypeAnnotation", e, t);
  }
  s(mN, "assertNullLiteralTypeAnnotation");
  function yN(e, t) {
    y("ClassImplements", e, t);
  }
  s(yN, "assertClassImplements");
  function TN(e, t) {
    y("DeclareClass", e, t);
  }
  s(TN, "assertDeclareClass");
  function gN(e, t) {
    y("DeclareFunction", e, t);
  }
  s(gN, "assertDeclareFunction");
  function bN(e, t) {
    y("DeclareInterface", e, t);
  }
  s(bN, "assertDeclareInterface");
  function SN(e, t) {
    y("DeclareModule", e, t);
  }
  s(SN, "assertDeclareModule");
  function xN(e, t) {
    y("DeclareModuleExports", e, t);
  }
  s(xN, "assertDeclareModuleExports");
  function EN(e, t) {
    y("DeclareTypeAlias", e, t);
  }
  s(EN, "assertDeclareTypeAlias");
  function PN(e, t) {
    y("DeclareOpaqueType", e, t);
  }
  s(PN, "assertDeclareOpaqueType");
  function AN(e, t) {
    y("DeclareVariable", e, t);
  }
  s(AN, "assertDeclareVariable");
  function vN(e, t) {
    y("DeclareExportDeclaration", e, t);
  }
  s(vN, "assertDeclareExportDeclaration");
  function CN(e, t) {
    y("DeclareExportAllDeclaration", e, t);
  }
  s(CN, "assertDeclareExportAllDeclaration");
  function IN(e, t) {
    y("DeclaredPredicate", e, t);
  }
  s(IN, "assertDeclaredPredicate");
  function wN(e, t) {
    y("ExistsTypeAnnotation", e, t);
  }
  s(wN, "assertExistsTypeAnnotation");
  function ON(e, t) {
    y("FunctionTypeAnnotation", e, t);
  }
  s(ON, "assertFunctionTypeAnnotation");
  function NN(e, t) {
    y("FunctionTypeParam", e, t);
  }
  s(NN, "assertFunctionTypeParam");
  function _N(e, t) {
    y("GenericTypeAnnotation", e, t);
  }
  s(_N, "assertGenericTypeAnnotation");
  function DN(e, t) {
    y("InferredPredicate", e, t);
  }
  s(DN, "assertInferredPredicate");
  function kN(e, t) {
    y("InterfaceExtends", e, t);
  }
  s(kN, "assertInterfaceExtends");
  function LN(e, t) {
    y("InterfaceDeclaration", e, t);
  }
  s(LN, "assertInterfaceDeclaration");
  function MN(e, t) {
    y("InterfaceTypeAnnotation", e, t);
  }
  s(MN, "assertInterfaceTypeAnnotation");
  function FN(e, t) {
    y("IntersectionTypeAnnotation", e, t);
  }
  s(FN, "assertIntersectionTypeAnnotation");
  function BN(e, t) {
    y("MixedTypeAnnotation", e, t);
  }
  s(BN, "assertMixedTypeAnnotation");
  function jN(e, t) {
    y("EmptyTypeAnnotation", e, t);
  }
  s(jN, "assertEmptyTypeAnnotation");
  function RN(e, t) {
    y("NullableTypeAnnotation", e, t);
  }
  s(RN, "assertNullableTypeAnnotation");
  function qN(e, t) {
    y("NumberLiteralTypeAnnotation", e, t);
  }
  s(qN, "assertNumberLiteralTypeAnnotation");
  function VN(e, t) {
    y("NumberTypeAnnotation", e, t);
  }
  s(VN, "assertNumberTypeAnnotation");
  function UN(e, t) {
    y("ObjectTypeAnnotation", e, t);
  }
  s(UN, "assertObjectTypeAnnotation");
  function KN(e, t) {
    y("ObjectTypeInternalSlot", e, t);
  }
  s(KN, "assertObjectTypeInternalSlot");
  function WN(e, t) {
    y("ObjectTypeCallProperty", e, t);
  }
  s(WN, "assertObjectTypeCallProperty");
  function YN(e, t) {
    y("ObjectTypeIndexer", e, t);
  }
  s(YN, "assertObjectTypeIndexer");
  function XN(e, t) {
    y("ObjectTypeProperty", e, t);
  }
  s(XN, "assertObjectTypeProperty");
  function JN(e, t) {
    y("ObjectTypeSpreadProperty", e, t);
  }
  s(JN, "assertObjectTypeSpreadProperty");
  function $N(e, t) {
    y("OpaqueType", e, t);
  }
  s($N, "assertOpaqueType");
  function HN(e, t) {
    y("QualifiedTypeIdentifier", e, t);
  }
  s(HN, "assertQualifiedTypeIdentifier");
  function GN(e, t) {
    y("StringLiteralTypeAnnotation", e, t);
  }
  s(GN, "assertStringLiteralTypeAnnotation");
  function zN(e, t) {
    y("StringTypeAnnotation", e, t);
  }
  s(zN, "assertStringTypeAnnotation");
  function QN(e, t) {
    y("SymbolTypeAnnotation", e, t);
  }
  s(QN, "assertSymbolTypeAnnotation");
  function ZN(e, t) {
    y("ThisTypeAnnotation", e, t);
  }
  s(ZN, "assertThisTypeAnnotation");
  function e_(e, t) {
    y("TupleTypeAnnotation", e, t);
  }
  s(e_, "assertTupleTypeAnnotation");
  function t_(e, t) {
    y("TypeofTypeAnnotation", e, t);
  }
  s(t_, "assertTypeofTypeAnnotation");
  function r_(e, t) {
    y("TypeAlias", e, t);
  }
  s(r_, "assertTypeAlias");
  function i_(e, t) {
    y("TypeAnnotation", e, t);
  }
  s(i_, "assertTypeAnnotation");
  function s_(e, t) {
    y("TypeCastExpression", e, t);
  }
  s(s_, "assertTypeCastExpression");
  function n_(e, t) {
    y("TypeParameter", e, t);
  }
  s(n_, "assertTypeParameter");
  function a_(e, t) {
    y("TypeParameterDeclaration", e, t);
  }
  s(a_, "assertTypeParameterDeclaration");
  function o_(e, t) {
    y("TypeParameterInstantiation", e, t);
  }
  s(o_, "assertTypeParameterInstantiation");
  function l_(e, t) {
    y("UnionTypeAnnotation", e, t);
  }
  s(l_, "assertUnionTypeAnnotation");
  function u_(e, t) {
    y("Variance", e, t);
  }
  s(u_, "assertVariance");
  function c_(e, t) {
    y("VoidTypeAnnotation", e, t);
  }
  s(c_, "assertVoidTypeAnnotation");
  function p_(e, t) {
    y("EnumDeclaration", e, t);
  }
  s(p_, "assertEnumDeclaration");
  function f_(e, t) {
    y("EnumBooleanBody", e, t);
  }
  s(f_, "assertEnumBooleanBody");
  function h_(e, t) {
    y("EnumNumberBody", e, t);
  }
  s(h_, "assertEnumNumberBody");
  function d_(e, t) {
    y("EnumStringBody", e, t);
  }
  s(d_, "assertEnumStringBody");
  function m_(e, t) {
    y("EnumSymbolBody", e, t);
  }
  s(m_, "assertEnumSymbolBody");
  function y_(e, t) {
    y("EnumBooleanMember", e, t);
  }
  s(y_, "assertEnumBooleanMember");
  function T_(e, t) {
    y("EnumNumberMember", e, t);
  }
  s(T_, "assertEnumNumberMember");
  function g_(e, t) {
    y("EnumStringMember", e, t);
  }
  s(g_, "assertEnumStringMember");
  function b_(e, t) {
    y("EnumDefaultedMember", e, t);
  }
  s(b_, "assertEnumDefaultedMember");
  function S_(e, t) {
    y("IndexedAccessType", e, t);
  }
  s(S_, "assertIndexedAccessType");
  function x_(e, t) {
    y("OptionalIndexedAccessType", e, t);
  }
  s(x_, "assertOptionalIndexedAccessType");
  function E_(e, t) {
    y("JSXAttribute", e, t);
  }
  s(E_, "assertJSXAttribute");
  function P_(e, t) {
    y("JSXClosingElement", e, t);
  }
  s(P_, "assertJSXClosingElement");
  function A_(e, t) {
    y("JSXElement", e, t);
  }
  s(A_, "assertJSXElement");
  function v_(e, t) {
    y("JSXEmptyExpression", e, t);
  }
  s(v_, "assertJSXEmptyExpression");
  function C_(e, t) {
    y("JSXExpressionContainer", e, t);
  }
  s(C_, "assertJSXExpressionContainer");
  function I_(e, t) {
    y("JSXSpreadChild", e, t);
  }
  s(I_, "assertJSXSpreadChild");
  function w_(e, t) {
    y("JSXIdentifier", e, t);
  }
  s(w_, "assertJSXIdentifier");
  function O_(e, t) {
    y("JSXMemberExpression", e, t);
  }
  s(O_, "assertJSXMemberExpression");
  function N_(e, t) {
    y("JSXNamespacedName", e, t);
  }
  s(N_, "assertJSXNamespacedName");
  function __(e, t) {
    y("JSXOpeningElement", e, t);
  }
  s(__, "assertJSXOpeningElement");
  function D_(e, t) {
    y("JSXSpreadAttribute", e, t);
  }
  s(D_, "assertJSXSpreadAttribute");
  function k_(e, t) {
    y("JSXText", e, t);
  }
  s(k_, "assertJSXText");
  function L_(e, t) {
    y("JSXFragment", e, t);
  }
  s(L_, "assertJSXFragment");
  function M_(e, t) {
    y("JSXOpeningFragment", e, t);
  }
  s(M_, "assertJSXOpeningFragment");
  function F_(e, t) {
    y("JSXClosingFragment", e, t);
  }
  s(F_, "assertJSXClosingFragment");
  function B_(e, t) {
    y("Noop", e, t);
  }
  s(B_, "assertNoop");
  function j_(e, t) {
    y("Placeholder", e, t);
  }
  s(j_, "assertPlaceholder");
  function R_(e, t) {
    y("V8IntrinsicIdentifier", e, t);
  }
  s(R_, "assertV8IntrinsicIdentifier");
  function q_(e, t) {
    y("ArgumentPlaceholder", e, t);
  }
  s(q_, "assertArgumentPlaceholder");
  function V_(e, t) {
    y("BindExpression", e, t);
  }
  s(V_, "assertBindExpression");
  function U_(e, t) {
    y("ImportAttribute", e, t);
  }
  s(U_, "assertImportAttribute");
  function K_(e, t) {
    y("Decorator", e, t);
  }
  s(K_, "assertDecorator");
  function W_(e, t) {
    y("DoExpression", e, t);
  }
  s(W_, "assertDoExpression");
  function Y_(e, t) {
    y("ExportDefaultSpecifier", e, t);
  }
  s(Y_, "assertExportDefaultSpecifier");
  function X_(e, t) {
    y("RecordExpression", e, t);
  }
  s(X_, "assertRecordExpression");
  function J_(e, t) {
    y("TupleExpression", e, t);
  }
  s(J_, "assertTupleExpression");
  function $_(e, t) {
    y("DecimalLiteral", e, t);
  }
  s($_, "assertDecimalLiteral");
  function H_(e, t) {
    y("ModuleExpression", e, t);
  }
  s(H_, "assertModuleExpression");
  function G_(e, t) {
    y("TopicReference", e, t);
  }
  s(G_, "assertTopicReference");
  function z_(e, t) {
    y("PipelineTopicExpression", e, t);
  }
  s(z_, "assertPipelineTopicExpression");
  function Q_(e, t) {
    y("PipelineBareFunction", e, t);
  }
  s(Q_, "assertPipelineBareFunction");
  function Z_(e, t) {
    y("PipelinePrimaryTopicReference", e, t);
  }
  s(Z_, "assertPipelinePrimaryTopicReference");
  function e2(e, t) {
    y("TSParameterProperty", e, t);
  }
  s(e2, "assertTSParameterProperty");
  function t2(e, t) {
    y("TSDeclareFunction", e, t);
  }
  s(t2, "assertTSDeclareFunction");
  function r2(e, t) {
    y("TSDeclareMethod", e, t);
  }
  s(r2, "assertTSDeclareMethod");
  function i2(e, t) {
    y("TSQualifiedName", e, t);
  }
  s(i2, "assertTSQualifiedName");
  function s2(e, t) {
    y("TSCallSignatureDeclaration", e, t);
  }
  s(s2, "assertTSCallSignatureDeclaration");
  function n2(e, t) {
    y("TSConstructSignatureDeclaration", e, t);
  }
  s(n2, "assertTSConstructSignatureDeclaration");
  function a2(e, t) {
    y("TSPropertySignature", e, t);
  }
  s(a2, "assertTSPropertySignature");
  function o2(e, t) {
    y("TSMethodSignature", e, t);
  }
  s(o2, "assertTSMethodSignature");
  function l2(e, t) {
    y("TSIndexSignature", e, t);
  }
  s(l2, "assertTSIndexSignature");
  function u2(e, t) {
    y("TSAnyKeyword", e, t);
  }
  s(u2, "assertTSAnyKeyword");
  function c2(e, t) {
    y("TSBooleanKeyword", e, t);
  }
  s(c2, "assertTSBooleanKeyword");
  function p2(e, t) {
    y("TSBigIntKeyword", e, t);
  }
  s(p2, "assertTSBigIntKeyword");
  function f2(e, t) {
    y("TSIntrinsicKeyword", e, t);
  }
  s(f2, "assertTSIntrinsicKeyword");
  function h2(e, t) {
    y("TSNeverKeyword", e, t);
  }
  s(h2, "assertTSNeverKeyword");
  function d2(e, t) {
    y("TSNullKeyword", e, t);
  }
  s(d2, "assertTSNullKeyword");
  function m2(e, t) {
    y("TSNumberKeyword", e, t);
  }
  s(m2, "assertTSNumberKeyword");
  function y2(e, t) {
    y("TSObjectKeyword", e, t);
  }
  s(y2, "assertTSObjectKeyword");
  function T2(e, t) {
    y("TSStringKeyword", e, t);
  }
  s(T2, "assertTSStringKeyword");
  function g2(e, t) {
    y("TSSymbolKeyword", e, t);
  }
  s(g2, "assertTSSymbolKeyword");
  function b2(e, t) {
    y("TSUndefinedKeyword", e, t);
  }
  s(b2, "assertTSUndefinedKeyword");
  function S2(e, t) {
    y("TSUnknownKeyword", e, t);
  }
  s(S2, "assertTSUnknownKeyword");
  function x2(e, t) {
    y("TSVoidKeyword", e, t);
  }
  s(x2, "assertTSVoidKeyword");
  function E2(e, t) {
    y("TSThisType", e, t);
  }
  s(E2, "assertTSThisType");
  function P2(e, t) {
    y("TSFunctionType", e, t);
  }
  s(P2, "assertTSFunctionType");
  function A2(e, t) {
    y("TSConstructorType", e, t);
  }
  s(A2, "assertTSConstructorType");
  function v2(e, t) {
    y("TSTypeReference", e, t);
  }
  s(v2, "assertTSTypeReference");
  function C2(e, t) {
    y("TSTypePredicate", e, t);
  }
  s(C2, "assertTSTypePredicate");
  function I2(e, t) {
    y("TSTypeQuery", e, t);
  }
  s(I2, "assertTSTypeQuery");
  function w2(e, t) {
    y("TSTypeLiteral", e, t);
  }
  s(w2, "assertTSTypeLiteral");
  function O2(e, t) {
    y("TSArrayType", e, t);
  }
  s(O2, "assertTSArrayType");
  function N2(e, t) {
    y("TSTupleType", e, t);
  }
  s(N2, "assertTSTupleType");
  function _2(e, t) {
    y("TSOptionalType", e, t);
  }
  s(_2, "assertTSOptionalType");
  function D2(e, t) {
    y("TSRestType", e, t);
  }
  s(D2, "assertTSRestType");
  function k2(e, t) {
    y("TSNamedTupleMember", e, t);
  }
  s(k2, "assertTSNamedTupleMember");
  function L2(e, t) {
    y("TSUnionType", e, t);
  }
  s(L2, "assertTSUnionType");
  function M2(e, t) {
    y("TSIntersectionType", e, t);
  }
  s(M2, "assertTSIntersectionType");
  function F2(e, t) {
    y("TSConditionalType", e, t);
  }
  s(F2, "assertTSConditionalType");
  function B2(e, t) {
    y("TSInferType", e, t);
  }
  s(B2, "assertTSInferType");
  function j2(e, t) {
    y("TSParenthesizedType", e, t);
  }
  s(j2, "assertTSParenthesizedType");
  function R2(e, t) {
    y("TSTypeOperator", e, t);
  }
  s(R2, "assertTSTypeOperator");
  function q2(e, t) {
    y("TSIndexedAccessType", e, t);
  }
  s(q2, "assertTSIndexedAccessType");
  function V2(e, t) {
    y("TSMappedType", e, t);
  }
  s(V2, "assertTSMappedType");
  function U2(e, t) {
    y("TSLiteralType", e, t);
  }
  s(U2, "assertTSLiteralType");
  function K2(e, t) {
    y("TSExpressionWithTypeArguments", e, t);
  }
  s(K2, "assertTSExpressionWithTypeArguments");
  function W2(e, t) {
    y("TSInterfaceDeclaration", e, t);
  }
  s(W2, "assertTSInterfaceDeclaration");
  function Y2(e, t) {
    y("TSInterfaceBody", e, t);
  }
  s(Y2, "assertTSInterfaceBody");
  function X2(e, t) {
    y("TSTypeAliasDeclaration", e, t);
  }
  s(X2, "assertTSTypeAliasDeclaration");
  function J2(e, t) {
    y("TSInstantiationExpression", e, t);
  }
  s(J2, "assertTSInstantiationExpression");
  function $2(e, t) {
    y("TSAsExpression", e, t);
  }
  s($2, "assertTSAsExpression");
  function H2(e, t) {
    y("TSSatisfiesExpression", e, t);
  }
  s(H2, "assertTSSatisfiesExpression");
  function G2(e, t) {
    y("TSTypeAssertion", e, t);
  }
  s(G2, "assertTSTypeAssertion");
  function z2(e, t) {
    y("TSEnumDeclaration", e, t);
  }
  s(z2, "assertTSEnumDeclaration");
  function Q2(e, t) {
    y("TSEnumMember", e, t);
  }
  s(Q2, "assertTSEnumMember");
  function Z2(e, t) {
    y("TSModuleDeclaration", e, t);
  }
  s(Z2, "assertTSModuleDeclaration");
  function eD(e, t) {
    y("TSModuleBlock", e, t);
  }
  s(eD, "assertTSModuleBlock");
  function tD(e, t) {
    y("TSImportType", e, t);
  }
  s(tD, "assertTSImportType");
  function rD(e, t) {
    y("TSImportEqualsDeclaration", e, t);
  }
  s(rD, "assertTSImportEqualsDeclaration");
  function iD(e, t) {
    y("TSExternalModuleReference", e, t);
  }
  s(iD, "assertTSExternalModuleReference");
  function sD(e, t) {
    y("TSNonNullExpression", e, t);
  }
  s(sD, "assertTSNonNullExpression");
  function nD(e, t) {
    y("TSExportAssignment", e, t);
  }
  s(nD, "assertTSExportAssignment");
  function aD(e, t) {
    y("TSNamespaceExportDeclaration", e, t);
  }
  s(aD, "assertTSNamespaceExportDeclaration");
  function oD(e, t) {
    y("TSTypeAnnotation", e, t);
  }
  s(oD, "assertTSTypeAnnotation");
  function lD(e, t) {
    y("TSTypeParameterInstantiation", e, t);
  }
  s(lD, "assertTSTypeParameterInstantiation");
  function uD(e, t) {
    y("TSTypeParameterDeclaration", e, t);
  }
  s(uD, "assertTSTypeParameterDeclaration");
  function cD(e, t) {
    y("TSTypeParameter", e, t);
  }
  s(cD, "assertTSTypeParameter");
  function pD(e, t) {
    y("Standardized", e, t);
  }
  s(pD, "assertStandardized");
  function fD(e, t) {
    y("Expression", e, t);
  }
  s(fD, "assertExpression");
  function hD(e, t) {
    y("Binary", e, t);
  }
  s(hD, "assertBinary");
  function dD(e, t) {
    y("Scopable", e, t);
  }
  s(dD, "assertScopable");
  function mD(e, t) {
    y("BlockParent", e, t);
  }
  s(mD, "assertBlockParent");
  function yD(e, t) {
    y("Block", e, t);
  }
  s(yD, "assertBlock");
  function TD(e, t) {
    y("Statement", e, t);
  }
  s(TD, "assertStatement");
  function gD(e, t) {
    y("Terminatorless", e, t);
  }
  s(gD, "assertTerminatorless");
  function bD(e, t) {
    y("CompletionStatement", e, t);
  }
  s(bD, "assertCompletionStatement");
  function SD(e, t) {
    y("Conditional", e, t);
  }
  s(SD, "assertConditional");
  function xD(e, t) {
    y("Loop", e, t);
  }
  s(xD, "assertLoop");
  function ED(e, t) {
    y("While", e, t);
  }
  s(ED, "assertWhile");
  function PD(e, t) {
    y("ExpressionWrapper", e, t);
  }
  s(PD, "assertExpressionWrapper");
  function AD(e, t) {
    y("For", e, t);
  }
  s(AD, "assertFor");
  function vD(e, t) {
    y("ForXStatement", e, t);
  }
  s(vD, "assertForXStatement");
  function CD(e, t) {
    y("Function", e, t);
  }
  s(CD, "assertFunction");
  function ID(e, t) {
    y("FunctionParent", e, t);
  }
  s(ID, "assertFunctionParent");
  function wD(e, t) {
    y("Pureish", e, t);
  }
  s(wD, "assertPureish");
  function OD(e, t) {
    y("Declaration", e, t);
  }
  s(OD, "assertDeclaration");
  function ND(e, t) {
    y("PatternLike", e, t);
  }
  s(ND, "assertPatternLike");
  function _D(e, t) {
    y("LVal", e, t);
  }
  s(_D, "assertLVal");
  function DD(e, t) {
    y("TSEntityName", e, t);
  }
  s(DD, "assertTSEntityName");
  function kD(e, t) {
    y("Literal", e, t);
  }
  s(kD, "assertLiteral");
  function LD(e, t) {
    y("Immutable", e, t);
  }
  s(LD, "assertImmutable");
  function MD(e, t) {
    y("UserWhitespacable", e, t);
  }
  s(MD, "assertUserWhitespacable");
  function FD(e, t) {
    y("Method", e, t);
  }
  s(FD, "assertMethod");
  function BD(e, t) {
    y("ObjectMember", e, t);
  }
  s(BD, "assertObjectMember");
  function jD(e, t) {
    y("Property", e, t);
  }
  s(jD, "assertProperty");
  function RD(e, t) {
    y("UnaryLike", e, t);
  }
  s(RD, "assertUnaryLike");
  function qD(e, t) {
    y("Pattern", e, t);
  }
  s(qD, "assertPattern");
  function VD(e, t) {
    y("Class", e, t);
  }
  s(VD, "assertClass");
  function UD(e, t) {
    y("ImportOrExportDeclaration", e, t);
  }
  s(UD, "assertImportOrExportDeclaration");
  function KD(e, t) {
    y("ExportDeclaration", e, t);
  }
  s(KD, "assertExportDeclaration");
  function WD(e, t) {
    y("ModuleSpecifier", e, t);
  }
  s(WD, "assertModuleSpecifier");
  function YD(e, t) {
    y("Accessor", e, t);
  }
  s(YD, "assertAccessor");
  function XD(e, t) {
    y("Private", e, t);
  }
  s(XD, "assertPrivate");
  function JD(e, t) {
    y("Flow", e, t);
  }
  s(JD, "assertFlow");
  function $D(e, t) {
    y("FlowType", e, t);
  }
  s($D, "assertFlowType");
  function HD(e, t) {
    y("FlowBaseAnnotation", e, t);
  }
  s(HD, "assertFlowBaseAnnotation");
  function GD(e, t) {
    y("FlowDeclaration", e, t);
  }
  s(GD, "assertFlowDeclaration");
  function zD(e, t) {
    y("FlowPredicate", e, t);
  }
  s(zD, "assertFlowPredicate");
  function QD(e, t) {
    y("EnumBody", e, t);
  }
  s(QD, "assertEnumBody");
  function ZD(e, t) {
    y("EnumMember", e, t);
  }
  s(ZD, "assertEnumMember");
  function ek(e, t) {
    y("JSX", e, t);
  }
  s(ek, "assertJSX");
  function tk(e, t) {
    y("Miscellaneous", e, t);
  }
  s(tk, "assertMiscellaneous");
  function rk(e, t) {
    y("TypeScript", e, t);
  }
  s(rk, "assertTypeScript");
  function ik(e, t) {
    y("TSTypeElement", e, t);
  }
  s(ik, "assertTSTypeElement");
  function sk(e, t) {
    y("TSType", e, t);
  }
  s(sk, "assertTSType");
  function nk(e, t) {
    y("TSBaseType", e, t);
  }
  s(nk, "assertTSBaseType");
  function ak(e, t) {
    (0, Ui.default)("assertNumberLiteral", "assertNumericLiteral"), y("NumberLiteral", e, t);
  }
  s(ak, "assertNumberLiteral");
  function ok(e, t) {
    (0, Ui.default)("assertRegexLiteral", "assertRegExpLiteral"), y("RegexLiteral", e, t);
  }
  s(ok, "assertRegexLiteral");
  function lk(e, t) {
    (0, Ui.default)("assertRestProperty", "assertRestElement"), y("RestProperty", e, t);
  }
  s(lk, "assertRestProperty");
  function uk(e, t) {
    (0, Ui.default)("assertSpreadProperty", "assertSpreadElement"), y("SpreadProperty", e, t);
  }
  s(uk, "assertSpreadProperty");
  function ck(e, t) {
    (0, Ui.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), y("ModuleDeclaration", e, t);
  }
  s(ck, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var Sf = v(($s) => {
  "use strict";
  Object.defineProperty($s, "__esModule", {
    value: !0
  });
  $s.default = void 0;
  var Ot = ut(), pH = $s.default = pk;
  function pk(e) {
    switch (e) {
      case "string":
        return (0, Ot.stringTypeAnnotation)();
      case "number":
        return (0, Ot.numberTypeAnnotation)();
      case "undefined":
        return (0, Ot.voidTypeAnnotation)();
      case "boolean":
        return (0, Ot.booleanTypeAnnotation)();
      case "function":
        return (0, Ot.genericTypeAnnotation)((0, Ot.identifier)("Function"));
      case "object":
        return (0, Ot.genericTypeAnnotation)((0, Ot.identifier)("Object"));
      case "symbol":
        return (0, Ot.genericTypeAnnotation)((0, Ot.identifier)("Symbol"));
      case "bigint":
        return (0, Ot.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e);
  }
  s(pk, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var io = v((ro) => {
  "use strict";
  Object.defineProperty(ro, "__esModule", {
    value: !0
  });
  ro.default = Ef;
  var Ki = We();
  function xf(e) {
    return (0, Ki.isIdentifier)(e) ? e.name : `${e.id.name}.${xf(e.qualification)}`;
  }
  s(xf, "getQualifiedName");
  function Ef(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Ki.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, Ki.isFlowBaseAnnotation)(l)) {
          i.set(l.type, l);
          continue;
        }
        if ((0, Ki.isUnionTypeAnnotation)(l)) {
          n.has(l.types) || (t.push(...l.types), n.add(l.types));
          continue;
        }
        if ((0, Ki.isGenericTypeAnnotation)(l)) {
          let u = xf(l.id);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = Ef(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(Ef, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var Pf = v((so) => {
  "use strict";
  Object.defineProperty(so, "__esModule", {
    value: !0
  });
  so.default = dk;
  var fk = ut(), hk = io();
  function dk(e) {
    let t = (0, hk.default)(e);
    return t.length === 1 ? t[0] : (0, fk.unionTypeAnnotation)(t);
  }
  s(dk, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var Cf = v((no) => {
  "use strict";
  Object.defineProperty(no, "__esModule", {
    value: !0
  });
  no.default = vf;
  var Wi = We();
  function Af(e) {
    return (0, Wi.isIdentifier)(e) ? e.name : `${e.right.name}.${Af(e.left)}`;
  }
  s(Af, "getQualifiedName");
  function vf(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Wi.isTSAnyKeyword)(l))
          return [l];
        if ((0, Wi.isTSBaseType)(l)) {
          i.set(l.type, l);
          continue;
        }
        if ((0, Wi.isTSUnionType)(l)) {
          n.has(l.types) || (t.push(...l.types), n.add(l.types));
          continue;
        }
        if ((0, Wi.isTSTypeReference)(l) && l.typeParameters) {
          let u = Af(l.typeName);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = vf(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(vf, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var If = v((ao) => {
  "use strict";
  Object.defineProperty(ao, "__esModule", {
    value: !0
  });
  ao.default = gk;
  var mk = ut(), yk = Cf(), Tk = We();
  function gk(e) {
    let t = e.map((i) => (0, Tk.isTSTypeAnnotation)(i) ? i.typeAnnotation : i), r = (0, yk.default)(t);
    return r.length === 1 ? r[0] : (0, mk.tsUnionType)(r);
  }
  s(gk, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var wf = v((b) => {
  "use strict";
  Object.defineProperty(b, "__esModule", {
    value: !0
  });
  Object.defineProperty(b, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(b, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.arrayExpression;
    }, "get")
  });
  Object.defineProperty(b, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.arrayPattern;
    }, "get")
  });
  Object.defineProperty(b, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(b, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(b, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(b, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.awaitExpression;
    }, "get")
  });
  Object.defineProperty(b, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(b, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.binaryExpression;
    }, "get")
  });
  Object.defineProperty(b, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.bindExpression;
    }, "get")
  });
  Object.defineProperty(b, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.blockStatement;
    }, "get")
  });
  Object.defineProperty(b, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(b, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.breakStatement;
    }, "get")
  });
  Object.defineProperty(b, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.callExpression;
    }, "get")
  });
  Object.defineProperty(b, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.catchClause;
    }, "get")
  });
  Object.defineProperty(b, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(b, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classBody;
    }, "get")
  });
  Object.defineProperty(b, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classExpression;
    }, "get")
  });
  Object.defineProperty(b, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classImplements;
    }, "get")
  });
  Object.defineProperty(b, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classMethod;
    }, "get")
  });
  Object.defineProperty(b, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(b, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(b, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classProperty;
    }, "get")
  });
  Object.defineProperty(b, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(b, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.continueStatement;
    }, "get")
  });
  Object.defineProperty(b, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(b, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(b, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareClass;
    }, "get")
  });
  Object.defineProperty(b, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareFunction;
    }, "get")
  });
  Object.defineProperty(b, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareInterface;
    }, "get")
  });
  Object.defineProperty(b, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareModule;
    }, "get")
  });
  Object.defineProperty(b, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(b, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(b, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(b, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareVariable;
    }, "get")
  });
  Object.defineProperty(b, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(b, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.decorator;
    }, "get")
  });
  Object.defineProperty(b, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.directive;
    }, "get")
  });
  Object.defineProperty(b, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(b, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.doExpression;
    }, "get")
  });
  Object.defineProperty(b, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(b, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.emptyStatement;
    }, "get")
  });
  Object.defineProperty(b, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumStringBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumStringMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(b, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.expressionStatement;
    }, "get")
  });
  Object.defineProperty(b, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.file;
    }, "get")
  });
  Object.defineProperty(b, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.forInStatement;
    }, "get")
  });
  Object.defineProperty(b, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.forOfStatement;
    }, "get")
  });
  Object.defineProperty(b, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.forStatement;
    }, "get")
  });
  Object.defineProperty(b, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.functionExpression;
    }, "get")
  });
  Object.defineProperty(b, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(b, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.identifier;
    }, "get")
  });
  Object.defineProperty(b, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.ifStatement;
    }, "get")
  });
  Object.defineProperty(b, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.import;
    }, "get")
  });
  Object.defineProperty(b, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importAttribute;
    }, "get")
  });
  Object.defineProperty(b, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importExpression;
    }, "get")
  });
  Object.defineProperty(b, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(b, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(b, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(b, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(b, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(b, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(b, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(b, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(b, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxText;
    }, "get")
  });
  Object.defineProperty(b, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.labeledStatement;
    }, "get")
  });
  Object.defineProperty(b, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.logicalExpression;
    }, "get")
  });
  Object.defineProperty(b, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.memberExpression;
    }, "get")
  });
  Object.defineProperty(b, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.metaProperty;
    }, "get")
  });
  Object.defineProperty(b, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.moduleExpression;
    }, "get")
  });
  Object.defineProperty(b, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.newExpression;
    }, "get")
  });
  Object.defineProperty(b, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.noop;
    }, "get")
  });
  Object.defineProperty(b, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.nullLiteral;
    }, "get")
  });
  Object.defineProperty(b, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.numberLiteral;
    }, "get")
  });
  Object.defineProperty(b, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.numericLiteral;
    }, "get")
  });
  Object.defineProperty(b, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectExpression;
    }, "get")
  });
  Object.defineProperty(b, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectMethod;
    }, "get")
  });
  Object.defineProperty(b, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectPattern;
    }, "get")
  });
  Object.defineProperty(b, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(b, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.opaqueType;
    }, "get")
  });
  Object.defineProperty(b, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(b, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(b, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(b, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(b, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(b, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(b, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.placeholder;
    }, "get")
  });
  Object.defineProperty(b, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.privateName;
    }, "get")
  });
  Object.defineProperty(b, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.program;
    }, "get")
  });
  Object.defineProperty(b, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.recordExpression;
    }, "get")
  });
  Object.defineProperty(b, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(b, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.regexLiteral;
    }, "get")
  });
  Object.defineProperty(b, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.restElement;
    }, "get")
  });
  Object.defineProperty(b, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.restProperty;
    }, "get")
  });
  Object.defineProperty(b, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.returnStatement;
    }, "get")
  });
  Object.defineProperty(b, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(b, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.spreadElement;
    }, "get")
  });
  Object.defineProperty(b, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.spreadProperty;
    }, "get")
  });
  Object.defineProperty(b, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.staticBlock;
    }, "get")
  });
  Object.defineProperty(b, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.stringLiteral;
    }, "get")
  });
  Object.defineProperty(b, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.super;
    }, "get")
  });
  Object.defineProperty(b, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.switchCase;
    }, "get")
  });
  Object.defineProperty(b, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.switchStatement;
    }, "get")
  });
  Object.defineProperty(b, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsArrayType;
    }, "get")
  });
  Object.defineProperty(b, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(b, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(b, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(b, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(b, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(b, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(b, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(b, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(b, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsImportType;
    }, "get")
  });
  Object.defineProperty(b, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(b, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsInferType;
    }, "get")
  });
  Object.defineProperty(b, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(b, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(b, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(b, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsMappedType;
    }, "get")
  });
  Object.defineProperty(b, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(b, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(b, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(b, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(b, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(b, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(b, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(b, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(b, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsRestType;
    }, "get")
  });
  Object.defineProperty(b, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsThisType;
    }, "get")
  });
  Object.defineProperty(b, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTupleType;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(b, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(b, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsUnionType;
    }, "get")
  });
  Object.defineProperty(b, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(b, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.templateElement;
    }, "get")
  });
  Object.defineProperty(b, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.templateLiteral;
    }, "get")
  });
  Object.defineProperty(b, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.thisExpression;
    }, "get")
  });
  Object.defineProperty(b, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.throwStatement;
    }, "get")
  });
  Object.defineProperty(b, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.topicReference;
    }, "get")
  });
  Object.defineProperty(b, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tryStatement;
    }, "get")
  });
  Object.defineProperty(b, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tupleExpression;
    }, "get")
  });
  Object.defineProperty(b, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeAlias;
    }, "get")
  });
  Object.defineProperty(b, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeParameter;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(b, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.unaryExpression;
    }, "get")
  });
  Object.defineProperty(b, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.updateExpression;
    }, "get")
  });
  Object.defineProperty(b, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(b, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.variance;
    }, "get")
  });
  Object.defineProperty(b, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.whileStatement;
    }, "get")
  });
  Object.defineProperty(b, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.withStatement;
    }, "get")
  });
  Object.defineProperty(b, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.yieldExpression;
    }, "get")
  });
  var S = ut();
});

// ../node_modules/@babel/types/lib/builders/productions.js
var Nf = v((oo) => {
  "use strict";
  Object.defineProperty(oo, "__esModule", {
    value: !0
  });
  oo.buildUndefinedNode = bk;
  var Of = ut();
  function bk() {
    return (0, Of.unaryExpression)("void", (0, Of.numericLiteral)(0), !0);
  }
  s(bk, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var ar = v((lo) => {
  "use strict";
  Object.defineProperty(lo, "__esModule", {
    value: !0
  });
  lo.default = Sk;
  var _f = Et(), Df = We(), {
    hasOwn: Kt
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function kf(e, t, r, i) {
    return e && typeof e.type == "string" ? Mf(e, t, r, i) : e;
  }
  s(kf, "cloneIfNode");
  function Lf(e, t, r, i) {
    return Array.isArray(e) ? e.map((n) => kf(n, t, r, i)) : kf(e, t, r, i);
  }
  s(Lf, "cloneIfNodeOrArray");
  function Sk(e, t = !0, r = !1) {
    return Mf(e, t, r, /* @__PURE__ */ new Map());
  }
  s(Sk, "cloneNode");
  function Mf(e, t = !0, r = !1, i) {
    if (!e) return e;
    let {
      type: n
    } = e, a = {
      type: e.type
    };
    if ((0, Df.isIdentifier)(e))
      a.name = e.name, Kt(e, "optional") && typeof e.optional == "boolean" && (a.optional = e.optional), Kt(e, "typeAnnotation") && (a.typeAnnotation =
      t ? Lf(e.typeAnnotation, !0, r, i) : e.typeAnnotation);
    else if (Kt(_f.NODE_FIELDS, n))
      for (let o of Object.keys(_f.NODE_FIELDS[n]))
        Kt(e, o) && (t ? a[o] = (0, Df.isFile)(e) && o === "comments" ? Hs(e.comments, t, r, i) : Lf(e[o], !0, r, i) : a[o] = e[o]);
    else
      throw new Error(`Unknown node type: "${n}"`);
    return Kt(e, "loc") && (r ? a.loc = null : a.loc = e.loc), Kt(e, "leadingComments") && (a.leadingComments = Hs(e.leadingComments, t, r, i)),
    Kt(e, "innerComments") && (a.innerComments = Hs(e.innerComments, t, r, i)), Kt(e, "trailingComments") && (a.trailingComments = Hs(e.trailingComments,
    t, r, i)), Kt(e, "extra") && (a.extra = Object.assign({}, e.extra)), a;
  }
  s(Mf, "cloneNodeInternal");
  function Hs(e, t, r, i) {
    return !e || !t ? e : e.map((n) => {
      let a = i.get(n);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = n, c = {
        type: o,
        value: l,
        loc: u
      };
      return r && (c.loc = null), i.set(n, c), c;
    });
  }
  s(Hs, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var Ff = v((uo) => {
  "use strict";
  Object.defineProperty(uo, "__esModule", {
    value: !0
  });
  uo.default = Ek;
  var xk = ar();
  function Ek(e) {
    return (0, xk.default)(e, !1);
  }
  s(Ek, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var Bf = v((co) => {
  "use strict";
  Object.defineProperty(co, "__esModule", {
    value: !0
  });
  co.default = Ak;
  var Pk = ar();
  function Ak(e) {
    return (0, Pk.default)(e);
  }
  s(Ak, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var jf = v((po) => {
  "use strict";
  Object.defineProperty(po, "__esModule", {
    value: !0
  });
  po.default = Ck;
  var vk = ar();
  function Ck(e) {
    return (0, vk.default)(e, !0, !0);
  }
  s(Ck, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var Rf = v((fo) => {
  "use strict";
  Object.defineProperty(fo, "__esModule", {
    value: !0
  });
  fo.default = wk;
  var Ik = ar();
  function wk(e) {
    return (0, Ik.default)(e, !1, !0);
  }
  s(wk, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var mo = v((ho) => {
  "use strict";
  Object.defineProperty(ho, "__esModule", {
    value: !0
  });
  ho.default = Ok;
  function Ok(e, t, r) {
    if (!r || !e) return e;
    let i = `${t}Comments`;
    return e[i] ? t === "leading" ? e[i] = r.concat(e[i]) : e[i].push(...r) : e[i] = r, e;
  }
  s(Ok, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var qf = v((yo) => {
  "use strict";
  Object.defineProperty(yo, "__esModule", {
    value: !0
  });
  yo.default = _k;
  var Nk = mo();
  function _k(e, t, r, i) {
    return (0, Nk.default)(e, t, [{
      type: i ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  s(_k, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var Gs = v((To) => {
  "use strict";
  Object.defineProperty(To, "__esModule", {
    value: !0
  });
  To.default = Dk;
  function Dk(e, t, r) {
    t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
  }
  s(Dk, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var bo = v((go) => {
  "use strict";
  Object.defineProperty(go, "__esModule", {
    value: !0
  });
  go.default = Lk;
  var kk = Gs();
  function Lk(e, t) {
    (0, kk.default)("innerComments", e, t);
  }
  s(Lk, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var xo = v((So) => {
  "use strict";
  Object.defineProperty(So, "__esModule", {
    value: !0
  });
  So.default = Fk;
  var Mk = Gs();
  function Fk(e, t) {
    (0, Mk.default)("leadingComments", e, t);
  }
  s(Fk, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var Po = v((Eo) => {
  "use strict";
  Object.defineProperty(Eo, "__esModule", {
    value: !0
  });
  Eo.default = jk;
  var Bk = Gs();
  function jk(e, t) {
    (0, Bk.default)("trailingComments", e, t);
  }
  s(jk, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var vo = v((Ao) => {
  "use strict";
  Object.defineProperty(Ao, "__esModule", {
    value: !0
  });
  Ao.default = Uk;
  var Rk = Po(), qk = xo(), Vk = bo();
  function Uk(e, t) {
    return (0, Rk.default)(e, t), (0, qk.default)(e, t), (0, Vk.default)(e, t), e;
  }
  s(Uk, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var Vf = v((Co) => {
  "use strict";
  Object.defineProperty(Co, "__esModule", {
    value: !0
  });
  Co.default = Wk;
  var Kk = ir();
  function Wk(e) {
    return Kk.COMMENT_KEYS.forEach((t) => {
      e[t] = null;
    }), e;
  }
  s(Wk, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var Uf = v((L) => {
  "use strict";
  Object.defineProperty(L, "__esModule", {
    value: !0
  });
  L.WHILE_TYPES = L.USERWHITESPACABLE_TYPES = L.UNARYLIKE_TYPES = L.TYPESCRIPT_TYPES = L.TSTYPE_TYPES = L.TSTYPEELEMENT_TYPES = L.TSENTITYNAME_TYPES =
  L.TSBASETYPE_TYPES = L.TERMINATORLESS_TYPES = L.STATEMENT_TYPES = L.STANDARDIZED_TYPES = L.SCOPABLE_TYPES = L.PUREISH_TYPES = L.PROPERTY_TYPES =
  L.PRIVATE_TYPES = L.PATTERN_TYPES = L.PATTERNLIKE_TYPES = L.OBJECTMEMBER_TYPES = L.MODULESPECIFIER_TYPES = L.MODULEDECLARATION_TYPES = L.MISCELLANEOUS_TYPES =
  L.METHOD_TYPES = L.LVAL_TYPES = L.LOOP_TYPES = L.LITERAL_TYPES = L.JSX_TYPES = L.IMPORTOREXPORTDECLARATION_TYPES = L.IMMUTABLE_TYPES = L.FUNCTION_TYPES =
  L.FUNCTIONPARENT_TYPES = L.FOR_TYPES = L.FORXSTATEMENT_TYPES = L.FLOW_TYPES = L.FLOWTYPE_TYPES = L.FLOWPREDICATE_TYPES = L.FLOWDECLARATION_TYPES =
  L.FLOWBASEANNOTATION_TYPES = L.EXPRESSION_TYPES = L.EXPRESSIONWRAPPER_TYPES = L.EXPORTDECLARATION_TYPES = L.ENUMMEMBER_TYPES = L.ENUMBODY_TYPES =
  L.DECLARATION_TYPES = L.CONDITIONAL_TYPES = L.COMPLETIONSTATEMENT_TYPES = L.CLASS_TYPES = L.BLOCK_TYPES = L.BLOCKPARENT_TYPES = L.BINARY_TYPES =
  L.ACCESSOR_TYPES = void 0;
  var ae = Et(), QH = L.STANDARDIZED_TYPES = ae.FLIPPED_ALIAS_KEYS.Standardized, ZH = L.EXPRESSION_TYPES = ae.FLIPPED_ALIAS_KEYS.Expression,
  eG = L.BINARY_TYPES = ae.FLIPPED_ALIAS_KEYS.Binary, tG = L.SCOPABLE_TYPES = ae.FLIPPED_ALIAS_KEYS.Scopable, rG = L.BLOCKPARENT_TYPES = ae.
  FLIPPED_ALIAS_KEYS.BlockParent, iG = L.BLOCK_TYPES = ae.FLIPPED_ALIAS_KEYS.Block, sG = L.STATEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.Statement,
  nG = L.TERMINATORLESS_TYPES = ae.FLIPPED_ALIAS_KEYS.Terminatorless, aG = L.COMPLETIONSTATEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.CompletionStatement,
  oG = L.CONDITIONAL_TYPES = ae.FLIPPED_ALIAS_KEYS.Conditional, lG = L.LOOP_TYPES = ae.FLIPPED_ALIAS_KEYS.Loop, uG = L.WHILE_TYPES = ae.FLIPPED_ALIAS_KEYS.
  While, cG = L.EXPRESSIONWRAPPER_TYPES = ae.FLIPPED_ALIAS_KEYS.ExpressionWrapper, pG = L.FOR_TYPES = ae.FLIPPED_ALIAS_KEYS.For, fG = L.FORXSTATEMENT_TYPES =
  ae.FLIPPED_ALIAS_KEYS.ForXStatement, hG = L.FUNCTION_TYPES = ae.FLIPPED_ALIAS_KEYS.Function, dG = L.FUNCTIONPARENT_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FunctionParent, mG = L.PUREISH_TYPES = ae.FLIPPED_ALIAS_KEYS.Pureish, yG = L.DECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.Declaration, TG = L.
  PATTERNLIKE_TYPES = ae.FLIPPED_ALIAS_KEYS.PatternLike, gG = L.LVAL_TYPES = ae.FLIPPED_ALIAS_KEYS.LVal, bG = L.TSENTITYNAME_TYPES = ae.FLIPPED_ALIAS_KEYS.
  TSEntityName, SG = L.LITERAL_TYPES = ae.FLIPPED_ALIAS_KEYS.Literal, xG = L.IMMUTABLE_TYPES = ae.FLIPPED_ALIAS_KEYS.Immutable, EG = L.USERWHITESPACABLE_TYPES =
  ae.FLIPPED_ALIAS_KEYS.UserWhitespacable, PG = L.METHOD_TYPES = ae.FLIPPED_ALIAS_KEYS.Method, AG = L.OBJECTMEMBER_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ObjectMember, vG = L.PROPERTY_TYPES = ae.FLIPPED_ALIAS_KEYS.Property, CG = L.UNARYLIKE_TYPES = ae.FLIPPED_ALIAS_KEYS.UnaryLike, IG = L.PATTERN_TYPES =
  ae.FLIPPED_ALIAS_KEYS.Pattern, wG = L.CLASS_TYPES = ae.FLIPPED_ALIAS_KEYS.Class, Yk = L.IMPORTOREXPORTDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ImportOrExportDeclaration, OG = L.EXPORTDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.ExportDeclaration, NG = L.MODULESPECIFIER_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ModuleSpecifier, _G = L.ACCESSOR_TYPES = ae.FLIPPED_ALIAS_KEYS.Accessor, DG = L.PRIVATE_TYPES = ae.FLIPPED_ALIAS_KEYS.Private, kG = L.FLOW_TYPES =
  ae.FLIPPED_ALIAS_KEYS.Flow, LG = L.FLOWTYPE_TYPES = ae.FLIPPED_ALIAS_KEYS.FlowType, MG = L.FLOWBASEANNOTATION_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FlowBaseAnnotation, FG = L.FLOWDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.FlowDeclaration, BG = L.FLOWPREDICATE_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FlowPredicate, jG = L.ENUMBODY_TYPES = ae.FLIPPED_ALIAS_KEYS.EnumBody, RG = L.ENUMMEMBER_TYPES = ae.FLIPPED_ALIAS_KEYS.EnumMember, qG = L.
  JSX_TYPES = ae.FLIPPED_ALIAS_KEYS.JSX, VG = L.MISCELLANEOUS_TYPES = ae.FLIPPED_ALIAS_KEYS.Miscellaneous, UG = L.TYPESCRIPT_TYPES = ae.FLIPPED_ALIAS_KEYS.
  TypeScript, KG = L.TSTYPEELEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.TSTypeElement, WG = L.TSTYPE_TYPES = ae.FLIPPED_ALIAS_KEYS.TSType, YG = L.TSBASETYPE_TYPES =
  ae.FLIPPED_ALIAS_KEYS.TSBaseType, XG = L.MODULEDECLARATION_TYPES = Yk;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var Oo = v((wo) => {
  "use strict";
  Object.defineProperty(wo, "__esModule", {
    value: !0
  });
  wo.default = Xk;
  var zs = We(), Io = ut();
  function Xk(e, t) {
    if ((0, zs.isBlockStatement)(e))
      return e;
    let r = [];
    return (0, zs.isEmptyStatement)(e) ? r = [] : ((0, zs.isStatement)(e) || ((0, zs.isFunction)(t) ? e = (0, Io.returnStatement)(e) : e = (0, Io.
    expressionStatement)(e)), r = [e]), (0, Io.blockStatement)(r);
  }
  s(Xk, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var Kf = v((No) => {
  "use strict";
  Object.defineProperty(No, "__esModule", {
    value: !0
  });
  No.default = $k;
  var Jk = Oo();
  function $k(e, t = "body") {
    let r = (0, Jk.default)(e[t], e);
    return e[t] = r, r;
  }
  s($k, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var Do = v((_o) => {
  "use strict";
  Object.defineProperty(_o, "__esModule", {
    value: !0
  });
  _o.default = zk;
  var Hk = Qr(), Gk = Bi();
  function zk(e) {
    e = e + "";
    let t = "";
    for (let r of e)
      t += (0, Gk.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, i) {
      return i ? i.toUpperCase() : "";
    }), (0, Hk.default)(t) || (t = `_${t}`), t || "_";
  }
  s(zk, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var Wf = v((ko) => {
  "use strict";
  Object.defineProperty(ko, "__esModule", {
    value: !0
  });
  ko.default = Zk;
  var Qk = Do();
  function Zk(e) {
    return e = (0, Qk.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
  }
  s(Zk, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var Yf = v((Lo) => {
  "use strict";
  Object.defineProperty(Lo, "__esModule", {
    value: !0
  });
  Lo.default = rL;
  var eL = We(), tL = ut();
  function rL(e, t = e.key || e.property) {
    return !e.computed && (0, eL.isIdentifier)(t) && (t = (0, tL.stringLiteral)(t.name)), t;
  }
  s(rL, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var Xf = v((Qs) => {
  "use strict";
  Object.defineProperty(Qs, "__esModule", {
    value: !0
  });
  Qs.default = void 0;
  var Yi = We(), sz = Qs.default = iL;
  function iL(e) {
    if ((0, Yi.isExpressionStatement)(e) && (e = e.expression), (0, Yi.isExpression)(e))
      return e;
    if ((0, Yi.isClass)(e) ? e.type = "ClassExpression" : (0, Yi.isFunction)(e) && (e.type = "FunctionExpression"), !(0, Yi.isExpression)(e))
      throw new Error(`cannot turn ${e.type} to an expression`);
    return e;
  }
  s(iL, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var Bo = v((Fo) => {
  "use strict";
  Object.defineProperty(Fo, "__esModule", {
    value: !0
  });
  Fo.default = Mo;
  var sL = Et();
  function Mo(e, t, r) {
    if (!e) return;
    let i = sL.VISITOR_KEYS[e.type];
    if (i) {
      r = r || {}, t(e, r);
      for (let n of i) {
        let a = e[n];
        if (Array.isArray(a))
          for (let o of a)
            Mo(o, t, r);
        else
          Mo(a, t, r);
      }
    }
  }
  s(Mo, "traverseFast");
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var Ro = v((jo) => {
  "use strict";
  Object.defineProperty(jo, "__esModule", {
    value: !0
  });
  jo.default = oL;
  var nL = ir(), Jf = ["tokens", "start", "end", "loc", "raw", "rawValue"], aL = [...nL.COMMENT_KEYS, "comments", ...Jf];
  function oL(e, t = {}) {
    let r = t.preserveComments ? Jf : aL;
    for (let n of r)
      e[n] != null && (e[n] = void 0);
    for (let n of Object.keys(e))
      n[0] === "_" && e[n] != null && (e[n] = void 0);
    let i = Object.getOwnPropertySymbols(e);
    for (let n of i)
      e[n] = null;
  }
  s(oL, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var Vo = v((qo) => {
  "use strict";
  Object.defineProperty(qo, "__esModule", {
    value: !0
  });
  qo.default = cL;
  var lL = Bo(), uL = Ro();
  function cL(e, t) {
    return (0, lL.default)(e, uL.default, t), e;
  }
  s(cL, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var Hf = v((Uo) => {
  "use strict";
  Object.defineProperty(Uo, "__esModule", {
    value: !0
  });
  Uo.default = _r;
  var $f = We(), pL = ar(), fL = Vo();
  function _r(e, t = e.key) {
    let r;
    return e.kind === "method" ? _r.increment() + "" : ((0, $f.isIdentifier)(t) ? r = t.name : (0, $f.isStringLiteral)(t) ? r = JSON.stringify(
    t.value) : r = JSON.stringify((0, fL.default)((0, pL.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
  }
  s(_r, "toKeyAlias");
  _r.uid = 0;
  _r.increment = function() {
    return _r.uid >= Number.MAX_SAFE_INTEGER ? _r.uid = 0 : _r.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var Gf = v((en) => {
  "use strict";
  Object.defineProperty(en, "__esModule", {
    value: !0
  });
  en.default = void 0;
  var Zs = We(), hL = ut(), mz = en.default = dL;
  function dL(e, t) {
    if ((0, Zs.isStatement)(e))
      return e;
    let r = !1, i;
    if ((0, Zs.isClass)(e))
      r = !0, i = "ClassDeclaration";
    else if ((0, Zs.isFunction)(e))
      r = !0, i = "FunctionDeclaration";
    else if ((0, Zs.isAssignmentExpression)(e))
      return (0, hL.expressionStatement)(e);
    if (r && !e.id && (i = !1), !i) {
      if (t)
        return !1;
      throw new Error(`cannot turn ${e.type} to a statement`);
    }
    return e.type = i, e;
  }
  s(dL, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var zf = v((tn) => {
  "use strict";
  Object.defineProperty(tn, "__esModule", {
    value: !0
  });
  tn.default = void 0;
  var mL = Qr(), rt = ut(), gz = tn.default = Ko, yL = Function.call.bind(Object.prototype.toString);
  function TL(e) {
    return yL(e) === "[object RegExp]";
  }
  s(TL, "isRegExp");
  function gL(e) {
    if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    let t = Object.getPrototypeOf(e);
    return t === null || Object.getPrototypeOf(t) === null;
  }
  s(gL, "isPlainObject");
  function Ko(e) {
    if (e === void 0)
      return (0, rt.identifier)("undefined");
    if (e === !0 || e === !1)
      return (0, rt.booleanLiteral)(e);
    if (e === null)
      return (0, rt.nullLiteral)();
    if (typeof e == "string")
      return (0, rt.stringLiteral)(e);
    if (typeof e == "number") {
      let t;
      if (Number.isFinite(e))
        t = (0, rt.numericLiteral)(Math.abs(e));
      else {
        let r;
        Number.isNaN(e) ? r = (0, rt.numericLiteral)(0) : r = (0, rt.numericLiteral)(1), t = (0, rt.binaryExpression)("/", r, (0, rt.numericLiteral)(
        0));
      }
      return (e < 0 || Object.is(e, -0)) && (t = (0, rt.unaryExpression)("-", t)), t;
    }
    if (TL(e)) {
      let t = e.source, r = e.toString().match(/\/([a-z]+|)$/)[1];
      return (0, rt.regExpLiteral)(t, r);
    }
    if (Array.isArray(e))
      return (0, rt.arrayExpression)(e.map(Ko));
    if (gL(e)) {
      let t = [];
      for (let r of Object.keys(e)) {
        let i;
        (0, mL.default)(r) ? i = (0, rt.identifier)(r) : i = (0, rt.stringLiteral)(r), t.push((0, rt.objectProperty)(i, Ko(e[r])));
      }
      return (0, rt.objectExpression)(t);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  s(Ko, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var Qf = v((Wo) => {
  "use strict";
  Object.defineProperty(Wo, "__esModule", {
    value: !0
  });
  Wo.default = SL;
  var bL = ut();
  function SL(e, t, r = !1) {
    return e.object = (0, bL.memberExpression)(e.object, e.property, e.computed), e.property = t, e.computed = !!r, e;
  }
  s(SL, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var eh = v((Yo) => {
  "use strict";
  Object.defineProperty(Yo, "__esModule", {
    value: !0
  });
  Yo.default = EL;
  var Zf = ir(), xL = vo();
  function EL(e, t) {
    if (!e || !t) return e;
    for (let r of Zf.INHERIT_KEYS.optional)
      e[r] == null && (e[r] = t[r]);
    for (let r of Object.keys(t))
      r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
    for (let r of Zf.INHERIT_KEYS.force)
      e[r] = t[r];
    return (0, xL.default)(e, t), e;
  }
  s(EL, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var th = v((Xo) => {
  "use strict";
  Object.defineProperty(Xo, "__esModule", {
    value: !0
  });
  Xo.default = vL;
  var PL = ut(), AL = le();
  function vL(e, t) {
    if ((0, AL.isSuper)(e.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e.object = (0, PL.memberExpression)(t, e.object), e;
  }
  s(vL, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var Xi = v(($o) => {
  "use strict";
  Object.defineProperty($o, "__esModule", {
    value: !0
  });
  $o.default = Jo;
  var or = We();
  function Jo(e, t, r, i) {
    let n = [].concat(e), a = /* @__PURE__ */ Object.create(null);
    for (; n.length; ) {
      let o = n.shift();
      if (!o || i && ((0, or.isAssignmentExpression)(o) || (0, or.isUnaryExpression)(o)))
        continue;
      let l = Jo.keys[o.type];
      if ((0, or.isIdentifier)(o)) {
        t ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, or.isExportDeclaration)(o) && !(0, or.isExportAllDeclaration)(o)) {
        (0, or.isDeclaration)(o.declaration) && n.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, or.isFunctionDeclaration)(o)) {
          n.push(o.id);
          continue;
        }
        if ((0, or.isFunctionExpression)(o))
          continue;
      }
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], p = o[c];
          p && (Array.isArray(p) ? n.push(...p) : n.push(p));
        }
    }
    return a;
  }
  s(Jo, "getBindingIdentifiers");
  Jo.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var rh = v((rn) => {
  "use strict";
  Object.defineProperty(rn, "__esModule", {
    value: !0
  });
  rn.default = void 0;
  var CL = Xi(), Oz = rn.default = IL;
  function IL(e, t) {
    return (0, CL.default)(e, t, !0);
  }
  s(IL, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var ih = v((Go) => {
  "use strict";
  Object.defineProperty(Go, "__esModule", {
    value: !0
  });
  Go.default = OL;
  var wL = Et();
  function OL(e, t, r) {
    typeof t == "function" && (t = {
      enter: t
    });
    let {
      enter: i,
      exit: n
    } = t;
    Ho(e, i, n, r, []);
  }
  s(OL, "traverse");
  function Ho(e, t, r, i, n) {
    let a = wL.VISITOR_KEYS[e.type];
    if (a) {
      t && t(e, n, i);
      for (let o of a) {
        let l = e[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (n.push({
              node: e,
              key: o,
              index: u
            }), Ho(c, t, r, i, n), n.pop());
          }
        else l && (n.push({
          node: e,
          key: o
        }), Ho(l, t, r, i, n), n.pop());
      }
      r && r(e, n, i);
    }
  }
  s(Ho, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var sh = v((zo) => {
  "use strict";
  Object.defineProperty(zo, "__esModule", {
    value: !0
  });
  zo.default = _L;
  var NL = Xi();
  function _L(e, t, r) {
    if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let i = NL.default.keys[t.type];
    if (i)
      for (let n = 0; n < i.length; n++) {
        let a = i[n], o = t[a];
        if (Array.isArray(o)) {
          if (o.indexOf(e) >= 0) return !0;
        } else if (o === e) return !0;
      }
    return !1;
  }
  s(_L, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var Zo = v((Qo) => {
  "use strict";
  Object.defineProperty(Qo, "__esModule", {
    value: !0
  });
  Qo.default = LL;
  var DL = We(), kL = ir();
  function LL(e) {
    return (0, DL.isVariableDeclaration)(e) && (e.kind !== "var" || e[kL.BLOCK_SCOPED_SYMBOL]);
  }
  s(LL, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var ah = v((el) => {
  "use strict";
  Object.defineProperty(el, "__esModule", {
    value: !0
  });
  el.default = FL;
  var nh = We(), ML = Zo();
  function FL(e) {
    return (0, nh.isFunctionDeclaration)(e) || (0, nh.isClassDeclaration)(e) || (0, ML.default)(e);
  }
  s(FL, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var oh = v((tl) => {
  "use strict";
  Object.defineProperty(tl, "__esModule", {
    value: !0
  });
  tl.default = RL;
  var BL = Bs(), jL = We();
  function RL(e) {
    return (0, BL.default)(e.type, "Immutable") ? !0 : (0, jL.isIdentifier)(e) ? e.name === "undefined" : !1;
  }
  s(RL, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var uh = v((il) => {
  "use strict";
  Object.defineProperty(il, "__esModule", {
    value: !0
  });
  il.default = rl;
  var lh = Et();
  function rl(e, t) {
    if (typeof e != "object" || typeof t != "object" || e == null || t == null)
      return e === t;
    if (e.type !== t.type)
      return !1;
    let r = Object.keys(lh.NODE_FIELDS[e.type] || e.type), i = lh.VISITOR_KEYS[e.type];
    for (let n of r) {
      let a = e[n], o = t[n];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!rl(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(i != null && i.includes(n))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!rl(a, o))
          return !1;
      }
    }
    return !0;
  }
  s(rl, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var ch = v((sl) => {
  "use strict";
  Object.defineProperty(sl, "__esModule", {
    value: !0
  });
  sl.default = qL;
  function qL(e, t, r) {
    switch (t.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t.property === e ? !!t.computed : t.object === e;
      case "JSXMemberExpression":
        return t.object === e;
      case "VariableDeclarator":
        return t.init === e;
      case "ArrowFunctionExpression":
        return t.body === e;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t.key === e ? !!t.computed : !1;
      case "ObjectProperty":
        return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return t.key === e ? !!t.computed : !0;
      case "ClassPrivateProperty":
        return t.key !== e;
      case "ClassDeclaration":
      case "ClassExpression":
        return t.superClass === e;
      case "AssignmentExpression":
        return t.right === e;
      case "AssignmentPattern":
        return t.right === e;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : t.local === e;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return t.key !== e;
      case "TSEnumMember":
        return t.id !== e;
      case "TSPropertySignature":
        return t.key === e ? !!t.computed : !0;
    }
    return !0;
  }
  s(qL, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var ph = v((nl) => {
  "use strict";
  Object.defineProperty(nl, "__esModule", {
    value: !0
  });
  nl.default = VL;
  var Dr = We();
  function VL(e, t) {
    return (0, Dr.isBlockStatement)(e) && ((0, Dr.isFunction)(t) || (0, Dr.isCatchClause)(t)) ? !1 : (0, Dr.isPattern)(e) && ((0, Dr.isFunction)(
    t) || (0, Dr.isCatchClause)(t)) ? !0 : (0, Dr.isScopable)(e);
  }
  s(VL, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var hh = v((al) => {
  "use strict";
  Object.defineProperty(al, "__esModule", {
    value: !0
  });
  al.default = UL;
  var fh = We();
  function UL(e) {
    return (0, fh.isImportDefaultSpecifier)(e) || (0, fh.isIdentifier)(e.imported || e.exported, {
      name: "default"
    });
  }
  s(UL, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var dh = v((ol) => {
  "use strict";
  Object.defineProperty(ol, "__esModule", {
    value: !0
  });
  ol.default = YL;
  var KL = Qr(), WL = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implement\
s", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transie\
nt", "volatile"]);
  function YL(e) {
    return (0, KL.default)(e) && !WL.has(e);
  }
  s(YL, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var mh = v((ll) => {
  "use strict";
  Object.defineProperty(ll, "__esModule", {
    value: !0
  });
  ll.default = $L;
  var XL = We(), JL = ir();
  function $L(e) {
    return (0, XL.isVariableDeclaration)(e, {
      kind: "var"
    }) && !e[JL.BLOCK_SCOPED_SYMBOL];
  }
  s($L, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var yh = v((cl) => {
  "use strict";
  Object.defineProperty(cl, "__esModule", {
    value: !0
  });
  cl.default = sn;
  var HL = Xi(), kr = We(), ul = ut(), GL = ar();
  function sn(e, t, r) {
    let i = [], n = !0;
    for (let a of e)
      if ((0, kr.isEmptyStatement)(a) || (n = !1), (0, kr.isExpression)(a))
        i.push(a);
      else if ((0, kr.isExpressionStatement)(a))
        i.push(a.expression);
      else if ((0, kr.isVariableDeclaration)(a)) {
        if (a.kind !== "var") return;
        for (let o of a.declarations) {
          let l = (0, HL.default)(o);
          for (let u of Object.keys(l))
            r.push({
              kind: a.kind,
              id: (0, GL.default)(l[u])
            });
          o.init && i.push((0, ul.assignmentExpression)("=", o.id, o.init));
        }
        n = !0;
      } else if ((0, kr.isIfStatement)(a)) {
        let o = a.consequent ? sn([a.consequent], t, r) : t.buildUndefinedNode(), l = a.alternate ? sn([a.alternate], t, r) : t.buildUndefinedNode();
        if (!o || !l) return;
        i.push((0, ul.conditionalExpression)(a.test, o, l));
      } else if ((0, kr.isBlockStatement)(a)) {
        let o = sn(a.body, t, r);
        if (!o) return;
        i.push(o);
      } else if ((0, kr.isEmptyStatement)(a))
        e.indexOf(a) === 0 && (n = !0);
      else
        return;
    return n && i.push(t.buildUndefinedNode()), i.length === 1 ? i[0] : (0, ul.sequenceExpression)(i);
  }
  s(sn, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var Th = v((pl) => {
  "use strict";
  Object.defineProperty(pl, "__esModule", {
    value: !0
  });
  pl.default = QL;
  var zL = yh();
  function QL(e, t) {
    if (!(e != null && e.length)) return;
    let r = [], i = (0, zL.default)(e, t, r);
    if (i) {
      for (let n of r)
        t.push(n);
      return i;
    }
  }
  s(QL, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var le = v((V) => {
  "use strict";
  Object.defineProperty(V, "__esModule", {
    value: !0
  });
  var Wt = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(V, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return e3.default;
    }, "get")
  });
  Object.defineProperty(V, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cM.default;
    }, "get")
  });
  Object.defineProperty(V, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return pM.default;
    }, "get")
  });
  Object.defineProperty(V, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return CM.default;
    }, "get")
  });
  Object.defineProperty(V, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rM.default;
    }, "get")
  });
  Object.defineProperty(V, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ZM.default;
    }, "get")
  });
  Object.defineProperty(V, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return aM.default;
    }, "get")
  });
  Object.defineProperty(V, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return oM.default;
    }, "get")
  });
  Object.defineProperty(V, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return lM.default;
    }, "get")
  });
  Object.defineProperty(V, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nM.default;
    }, "get")
  });
  Object.defineProperty(V, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return uM.default;
    }, "get")
  });
  Object.defineProperty(V, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return gh.default;
    }, "get")
  });
  Object.defineProperty(V, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return sM.default;
    }, "get")
  });
  Object.defineProperty(V, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return iM.default;
    }, "get")
  });
  Object.defineProperty(V, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return gh.default;
    }, "get")
  });
  Object.defineProperty(V, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return TM.default;
    }, "get")
  });
  Object.defineProperty(V, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return DM.default;
    }, "get")
  });
  Object.defineProperty(V, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return kM.default;
    }, "get")
  });
  Object.defineProperty(V, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return fM.default;
    }, "get")
  });
  Object.defineProperty(V, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return hM.default;
    }, "get")
  });
  Object.defineProperty(V, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return mM.default;
    }, "get")
  });
  Object.defineProperty(V, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return IM.default;
    }, "get")
  });
  Object.defineProperty(V, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return dM.default;
    }, "get")
  });
  Object.defineProperty(V, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return FM.default;
    }, "get")
  });
  Object.defineProperty(V, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return BM.default;
    }, "get")
  });
  Object.defineProperty(V, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return jM.default;
    }, "get")
  });
  Object.defineProperty(V, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return RM.default;
    }, "get")
  });
  Object.defineProperty(V, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qM.default;
    }, "get")
  });
  Object.defineProperty(V, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return VM.default;
    }, "get")
  });
  Object.defineProperty(V, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return UM.default;
    }, "get")
  });
  Object.defineProperty(V, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return KM.default;
    }, "get")
  });
  Object.defineProperty(V, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return WM.default;
    }, "get")
  });
  Object.defineProperty(V, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return YM.default;
    }, "get")
  });
  Object.defineProperty(V, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return XM.default;
    }, "get")
  });
  Object.defineProperty(V, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return JM.default;
    }, "get")
  });
  Object.defineProperty(V, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $M.default;
    }, "get")
  });
  Object.defineProperty(V, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return HM.default;
    }, "get")
  });
  Object.defineProperty(V, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return GM.default;
    }, "get")
  });
  Object.defineProperty(V, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zM.default;
    }, "get")
  });
  Object.defineProperty(V, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return wM.default;
    }, "get")
  });
  V.react = void 0;
  Object.defineProperty(V, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return yM.default;
    }, "get")
  });
  Object.defineProperty(V, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return OM.default;
    }, "get")
  });
  Object.defineProperty(V, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return NM.default;
    }, "get")
  });
  Object.defineProperty(V, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return _M.default;
    }, "get")
  });
  Object.defineProperty(V, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return MM.default;
    }, "get")
  });
  Object.defineProperty(V, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return gM.default;
    }, "get")
  });
  Object.defineProperty(V, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return bM.default;
    }, "get")
  });
  Object.defineProperty(V, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return SM.default;
    }, "get")
  });
  Object.defineProperty(V, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return xM.default;
    }, "get")
  });
  Object.defineProperty(V, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return EM.default;
    }, "get")
  });
  Object.defineProperty(V, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return PM.default;
    }, "get")
  });
  Object.defineProperty(V, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return AM.default;
    }, "get")
  });
  Object.defineProperty(V, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nn.default;
    }, "get")
  });
  Object.defineProperty(V, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return LM.default;
    }, "get")
  });
  Object.defineProperty(V, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return QM.default;
    }, "get")
  });
  Object.defineProperty(V, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vM.default;
    }, "get")
  });
  var ZL = xp(), eM = Ep(), tM = Tf(), rM = gf(), fl = bf();
  Object.keys(fl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === fl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return fl[e];
      }, "get")
    });
  });
  var iM = Sf(), gh = Pf(), sM = If(), hl = ut();
  Object.keys(hl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === hl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return hl[e];
      }, "get")
    });
  });
  var dl = wf();
  Object.keys(dl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === dl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return dl[e];
      }, "get")
    });
  });
  var ml = Nf();
  Object.keys(ml).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === ml[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ml[e];
      }, "get")
    });
  });
  var nM = ar(), aM = Ff(), oM = Bf(), lM = jf(), uM = Rf(), cM = qf(), pM = mo(), fM = bo(), hM = xo(), dM = vo(), mM = Po(), yM = Vf(), yl = Uf();
  Object.keys(yl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === yl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return yl[e];
      }, "get")
    });
  });
  var Tl = ir();
  Object.keys(Tl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === Tl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Tl[e];
      }, "get")
    });
  });
  var TM = Kf(), gM = Wf(), bM = Oo(), SM = Yf(), xM = Xf(), EM = Do(), PM = Hf(), AM = Gf(), vM = zf(), gl = Et();
  Object.keys(gl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === gl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return gl[e];
      }, "get")
    });
  });
  var CM = Qf(), IM = eh(), wM = th(), OM = Ro(), NM = Vo(), _M = io(), DM = Xi(), kM = rh(), nn = ih();
  Object.keys(nn).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === nn[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return nn[e];
      }, "get")
    });
  });
  var LM = Bo(), MM = Ms(), FM = zr(), BM = sh(), jM = ah(), RM = oh(), qM = Zo(), VM = eo(), UM = uh(), KM = Ia(), WM = ch(), YM = ph(), XM = hh(),
  JM = Bs(), $M = dh(), HM = Qr(), GM = mh(), zM = xa(), QM = Us(), ZM = Pa(), bl = We();
  Object.keys(bl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === bl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return bl[e];
      }, "get")
    });
  });
  var e3 = Ni(), sQ = V.react = {
    isReactComponent: ZL.default,
    isCompatTag: eM.default,
    buildChildren: tM.default
  };
  V.toSequenceExpression = Th().default;
});

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var Sh = v((an, bh) => {
  (function(e, t) {
    typeof an == "object" && typeof bh < "u" ? t(an) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.setArray = {}));
  })(an, function(e) {
    "use strict";
    class t {
      static {
        s(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function r(l) {
      return l;
    }
    s(r, "cast");
    function i(l, u) {
      return l._indexes[u];
    }
    s(i, "get");
    function n(l, u) {
      let c = i(l, u);
      if (c !== void 0)
        return c;
      let { array: p, _indexes: g } = l, P = p.push(u);
      return g[u] = P - 1;
    }
    s(n, "put");
    function a(l) {
      let { array: u, _indexes: c } = l;
      if (u.length === 0)
        return;
      let p = u.pop();
      c[p] = void 0;
    }
    s(a, "pop");
    function o(l, u) {
      let c = i(l, u);
      if (c === void 0)
        return;
      let { array: p, _indexes: g } = l;
      for (let P = c + 1; P < p.length; P++) {
        let A = p[P];
        p[P - 1] = A, g[A]--;
      }
      g[u] = void 0, p.pop();
    }
    s(o, "remove"), e.SetArray = t, e.get = i, e.pop = a, e.put = n, e.remove = o, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var Sl = v((on, xh) => {
  (function(e, t) {
    typeof on == "object" && typeof xh < "u" ? t(on) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.sourcemapCodec = {}));
  })(on, function(e) {
    "use strict";
    let i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(64), a = new Uint8Array(128);
    for (let _ = 0; _ < i.length; _++) {
      let k = i.charCodeAt(_);
      n[_] = k, a[k] = _;
    }
    let o = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(_) {
        return Buffer.from(_.buffer, _.byteOffset, _.byteLength).toString();
      }
    } : {
      decode(_) {
        let k = "";
        for (let O = 0; O < _.length; O++)
          k += String.fromCharCode(_[O]);
        return k;
      }
    };
    function l(_) {
      let k = new Int32Array(5), O = [], M = 0;
      do {
        let F = u(_, M), G = [], $ = !0, K = 0;
        k[0] = 0;
        for (let oe = M; oe < F; oe++) {
          let Oe;
          oe = c(_, oe, k, 0);
          let Ne = k[0];
          Ne < K && ($ = !1), K = Ne, p(_, oe, F) ? (oe = c(_, oe, k, 1), oe = c(_, oe, k, 2), oe = c(_, oe, k, 3), p(_, oe, F) ? (oe = c(_,
          oe, k, 4), Oe = [Ne, k[1], k[2], k[3], k[4]]) : Oe = [Ne, k[1], k[2], k[3]]) : Oe = [Ne], G.push(Oe);
        }
        $ || g(G), O.push(G), M = F + 1;
      } while (M <= _.length);
      return O;
    }
    s(l, "decode");
    function u(_, k) {
      let O = _.indexOf(";", k);
      return O === -1 ? _.length : O;
    }
    s(u, "indexOf");
    function c(_, k, O, M) {
      let F = 0, G = 0, $ = 0;
      do {
        let oe = _.charCodeAt(k++);
        $ = a[oe], F |= ($ & 31) << G, G += 5;
      } while ($ & 32);
      let K = F & 1;
      return F >>>= 1, K && (F = -2147483648 | -F), O[M] += F, k;
    }
    s(c, "decodeInteger");
    function p(_, k, O) {
      return k >= O ? !1 : _.charCodeAt(k) !== 44;
    }
    s(p, "hasMoreVlq");
    function g(_) {
      _.sort(P);
    }
    s(g, "sort");
    function P(_, k) {
      return _[0] - k[0];
    }
    s(P, "sortComparator");
    function A(_) {
      let k = new Int32Array(5), O = 1024 * 16, M = O - 36, F = new Uint8Array(O), G = F.subarray(0, M), $ = 0, K = "";
      for (let oe = 0; oe < _.length; oe++) {
        let Oe = _[oe];
        if (oe > 0 && ($ === O && (K += o.decode(F), $ = 0), F[$++] = 59), Oe.length !== 0) {
          k[0] = 0;
          for (let Ne = 0; Ne < Oe.length; Ne++) {
            let $e = Oe[Ne];
            $ > M && (K += o.decode(G), F.copyWithin(0, M, $), $ -= M), Ne > 0 && (F[$++] = 44), $ = C(F, $, k, $e, 0), $e.length !== 1 && ($ =
            C(F, $, k, $e, 1), $ = C(F, $, k, $e, 2), $ = C(F, $, k, $e, 3), $e.length !== 4 && ($ = C(F, $, k, $e, 4)));
          }
        }
      }
      return K + o.decode(F.subarray(0, $));
    }
    s(A, "encode");
    function C(_, k, O, M, F) {
      let G = M[F], $ = G - O[F];
      O[F] = G, $ = $ < 0 ? -$ << 1 | 1 : $ << 1;
      do {
        let K = $ & 31;
        $ >>>= 5, $ > 0 && (K |= 32), _[k++] = n[K];
      } while ($ > 0);
      return k;
    }
    s(C, "encodeInteger"), e.decode = l, e.encode = A, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var Eh = v((xl, El) => {
  (function(e, t) {
    typeof xl == "object" && typeof El < "u" ? El.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, e.resolveURI = t());
  })(xl, function() {
    "use strict";
    let e = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var i;
    (function(O) {
      O[O.Empty = 1] = "Empty", O[O.Hash = 2] = "Hash", O[O.Query = 3] = "Query", O[O.RelativePath = 4] = "RelativePath", O[O.AbsolutePath =
      5] = "AbsolutePath", O[O.SchemeRelative = 6] = "SchemeRelative", O[O.Absolute = 7] = "Absolute";
    })(i || (i = {}));
    function n(O) {
      return e.test(O);
    }
    s(n, "isAbsoluteUrl");
    function a(O) {
      return O.startsWith("//");
    }
    s(a, "isSchemeRelativeUrl");
    function o(O) {
      return O.startsWith("/");
    }
    s(o, "isAbsolutePath");
    function l(O) {
      return O.startsWith("file:");
    }
    s(l, "isFileUrl");
    function u(O) {
      return /^[.?#]/.test(O);
    }
    s(u, "isRelative");
    function c(O) {
      let M = t.exec(O);
      return g(M[1], M[2] || "", M[3], M[4] || "", M[5] || "/", M[6] || "", M[7] || "");
    }
    s(c, "parseAbsoluteUrl");
    function p(O) {
      let M = r.exec(O), F = M[2];
      return g("file:", "", M[1] || "", "", o(F) ? F : "/" + F, M[3] || "", M[4] || "");
    }
    s(p, "parseFileUrl");
    function g(O, M, F, G, $, K, oe) {
      return {
        scheme: O,
        user: M,
        host: F,
        port: G,
        path: $,
        query: K,
        hash: oe,
        type: i.Absolute
      };
    }
    s(g, "makeUrl");
    function P(O) {
      if (a(O)) {
        let F = c("http:" + O);
        return F.scheme = "", F.type = i.SchemeRelative, F;
      }
      if (o(O)) {
        let F = c("http://foo.com" + O);
        return F.scheme = "", F.host = "", F.type = i.AbsolutePath, F;
      }
      if (l(O))
        return p(O);
      if (n(O))
        return c(O);
      let M = c("http://foo.com/" + O);
      return M.scheme = "", M.host = "", M.type = O ? O.startsWith("?") ? i.Query : O.startsWith("#") ? i.Hash : i.RelativePath : i.Empty, M;
    }
    s(P, "parseUrl");
    function A(O) {
      if (O.endsWith("/.."))
        return O;
      let M = O.lastIndexOf("/");
      return O.slice(0, M + 1);
    }
    s(A, "stripPathFilename");
    function C(O, M) {
      _(M, M.type), O.path === "/" ? O.path = M.path : O.path = A(M.path) + O.path;
    }
    s(C, "mergePaths");
    function _(O, M) {
      let F = M <= i.RelativePath, G = O.path.split("/"), $ = 1, K = 0, oe = !1;
      for (let Ne = 1; Ne < G.length; Ne++) {
        let $e = G[Ne];
        if (!$e) {
          oe = !0;
          continue;
        }
        if (oe = !1, $e !== ".") {
          if ($e === "..") {
            K ? (oe = !0, K--, $--) : F && (G[$++] = $e);
            continue;
          }
          G[$++] = $e, K++;
        }
      }
      let Oe = "";
      for (let Ne = 1; Ne < $; Ne++)
        Oe += "/" + G[Ne];
      (!Oe || oe && !Oe.endsWith("/..")) && (Oe += "/"), O.path = Oe;
    }
    s(_, "normalizePath");
    function k(O, M) {
      if (!O && !M)
        return "";
      let F = P(O), G = F.type;
      if (M && G !== i.Absolute) {
        let K = P(M), oe = K.type;
        switch (G) {
          case i.Empty:
            F.hash = K.hash;
          case i.Hash:
            F.query = K.query;
          case i.Query:
          case i.RelativePath:
            C(F, K);
          case i.AbsolutePath:
            F.user = K.user, F.host = K.host, F.port = K.port;
          case i.SchemeRelative:
            F.scheme = K.scheme;
        }
        oe > G && (G = oe);
      }
      _(F, G);
      let $ = F.query + F.hash;
      switch (G) {
        case i.Hash:
        case i.Query:
          return $;
        case i.RelativePath: {
          let K = F.path.slice(1);
          return K ? u(M || O) && !u(K) ? "./" + K + $ : K + $ : $ || ".";
        }
        case i.AbsolutePath:
          return F.path + $;
        default:
          return F.scheme + "//" + F.user + F.host + F.port + F.path + $;
      }
    }
    return s(k, "resolve"), k;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var Pl = v((ln, Ph) => {
  (function(e, t) {
    typeof ln == "object" && typeof Ph < "u" ? t(ln, Sl(), Eh()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.traceMapping = {}, e.sourcemapCodec,
    e.resolveURI));
  })(ln, function(e, t, r) {
    "use strict";
    function i(N, B) {
      return B && !B.endsWith("/") && (B += "/"), r(N, B);
    }
    s(i, "resolve");
    function n(N) {
      if (!N)
        return "";
      let B = N.lastIndexOf("/");
      return N.slice(0, B + 1);
    }
    s(n, "stripFilename");
    let a = 0, o = 1, l = 2, u = 3, c = 4, p = 1, g = 2;
    function P(N, B) {
      let R = A(N, 0);
      if (R === N.length)
        return N;
      B || (N = N.slice());
      for (let W = R; W < N.length; W = A(N, W + 1))
        N[W] = _(N[W], B);
      return N;
    }
    s(P, "maybeSort");
    function A(N, B) {
      for (let R = B; R < N.length; R++)
        if (!C(N[R]))
          return R;
      return N.length;
    }
    s(A, "nextUnsortedSegmentLine");
    function C(N) {
      for (let B = 1; B < N.length; B++)
        if (N[B][a] < N[B - 1][a])
          return !1;
      return !0;
    }
    s(C, "isSorted");
    function _(N, B) {
      return B || (N = N.slice()), N.sort(k);
    }
    s(_, "sortSegments");
    function k(N, B) {
      return N[a] - B[a];
    }
    s(k, "sortComparator");
    let O = !1;
    function M(N, B, R, W) {
      for (; R <= W; ) {
        let ue = R + (W - R >> 1), te = N[ue][a] - B;
        if (te === 0)
          return O = !0, ue;
        te < 0 ? R = ue + 1 : W = ue - 1;
      }
      return O = !1, R - 1;
    }
    s(M, "binarySearch");
    function F(N, B, R) {
      for (let W = R + 1; W < N.length && N[W][a] === B; R = W++)
        ;
      return R;
    }
    s(F, "upperBound");
    function G(N, B, R) {
      for (let W = R - 1; W >= 0 && N[W][a] === B; R = W--)
        ;
      return R;
    }
    s(G, "lowerBound");
    function $() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    s($, "memoizedState");
    function K(N, B, R, W) {
      let { lastKey: ue, lastNeedle: te, lastIndex: Se } = R, De = 0, me = N.length - 1;
      if (W === ue) {
        if (B === te)
          return O = Se !== -1 && N[Se][a] === B, Se;
        B >= te ? De = Se === -1 ? 0 : Se : me = Se;
      }
      return R.lastKey = W, R.lastNeedle = B, R.lastIndex = M(N, B, De, me);
    }
    s(K, "memoizedBinarySearch");
    function oe(N, B) {
      let R = B.map(Ne);
      for (let W = 0; W < N.length; W++) {
        let ue = N[W];
        for (let te = 0; te < ue.length; te++) {
          let Se = ue[te];
          if (Se.length === 1)
            continue;
          let De = Se[o], me = Se[l], ke = Se[u], mt = R[De], Ke = mt[me] || (mt[me] = []), Ve = B[De], nt = F(Ke, ke, K(Ke, ke, Ve, me));
          Ve.lastIndex = ++nt, Oe(Ke, nt, [ke, W, Se[a]]);
        }
      }
      return R;
    }
    s(oe, "buildBySources");
    function Oe(N, B, R) {
      for (let W = N.length; W > B; W--)
        N[W] = N[W - 1];
      N[B] = R;
    }
    s(Oe, "insert");
    function Ne() {
      return { __proto__: null };
    }
    s(Ne, "buildNullArray");
    let $e = /* @__PURE__ */ s(function(N, B) {
      let R = Lt(N);
      if (!("sections" in R))
        return new Ie(R, B);
      let W = [], ue = [], te = [], Se = [], De = [];
      rr(R, B, W, ue, te, Se, De, 0, 0, 1 / 0, 1 / 0);
      let me = {
        version: 3,
        file: R.file,
        names: Se,
        sources: ue,
        sourcesContent: te,
        mappings: W,
        ignoreList: De
      };
      return cp(me);
    }, "AnyMap");
    function Lt(N) {
      return typeof N == "string" ? JSON.parse(N) : N;
    }
    s(Lt, "parse");
    function rr(N, B, R, W, ue, te, Se, De, me, ke, mt) {
      let { sections: Ke } = N;
      for (let Ve = 0; Ve < Ke.length; Ve++) {
        let { map: nt, offset: Ft } = Ke[Ve], Ir = ke, Hr = mt;
        if (Ve + 1 < Ke.length) {
          let Gr = Ke[Ve + 1].offset;
          Ir = Math.min(ke, De + Gr.line), Ir === ke ? Hr = Math.min(mt, me + Gr.column) : Ir < ke && (Hr = me + Gr.column);
        }
        Os(nt, B, R, W, ue, te, Se, De + Ft.line, me + Ft.column, Ir, Hr);
      }
    }
    s(rr, "recurse");
    function Os(N, B, R, W, ue, te, Se, De, me, ke, mt) {
      let Ke = Lt(N);
      if ("sections" in Ke)
        return rr(...arguments);
      let Ve = new Ie(Ke, B), nt = W.length, Ft = te.length, Ir = He(Ve), { resolvedSources: Hr, sourcesContent: Gr, ignoreList: ma } = Ve;
      if (Mt(W, Hr), Mt(te, Ve.names), Gr)
        Mt(ue, Gr);
      else
        for (let xt = 0; xt < Hr.length; xt++)
          ue.push(null);
      if (ma)
        for (let xt = 0; xt < ma.length; xt++)
          Se.push(ma[xt] + nt);
      for (let xt = 0; xt < Ir.length; xt++) {
        let ya = De + xt;
        if (ya > ke)
          return;
        let fp = ie(R, ya), V0 = xt === 0 ? me : 0, hp = Ir[xt];
        for (let Ta = 0; Ta < hp.length; Ta++) {
          let wr = hp[Ta], ks = V0 + wr[a];
          if (ya === ke && ks >= mt)
            return;
          if (wr.length === 1) {
            fp.push([ks]);
            continue;
          }
          let dp = nt + wr[o], mp = wr[l], yp = wr[u];
          fp.push(wr.length === 4 ? [ks, dp, mp, yp] : [ks, dp, mp, yp, Ft + wr[c]]);
        }
      }
    }
    s(Os, "addSection");
    function Mt(N, B) {
      for (let R = 0; R < B.length; R++)
        N.push(B[R]);
    }
    s(Mt, "append");
    function ie(N, B) {
      for (let R = N.length; R <= B; R++)
        N[R] = [];
      return N[B];
    }
    s(ie, "getLine");
    let Q = "`line` must be greater than 0 (lines start at line 1)", ne = "`column` must be greater than or equal to 0 (columns start at col\
umn 0)", ce = -1, _e = 1;
    class Ie {
      static {
        s(this, "TraceMap");
      }
      constructor(B, R) {
        let W = typeof B == "string";
        if (!W && B._decodedMemo)
          return B;
        let ue = W ? JSON.parse(B) : B, { version: te, file: Se, names: De, sourceRoot: me, sources: ke, sourcesContent: mt } = ue;
        this.version = te, this.file = Se, this.names = De || [], this.sourceRoot = me, this.sources = ke, this.sourcesContent = mt, this.ignoreList =
        ue.ignoreList || ue.x_google_ignoreList || void 0;
        let Ke = i(me || "", n(R));
        this.resolvedSources = ke.map((nt) => i(nt || "", Ke));
        let { mappings: Ve } = ue;
        typeof Ve == "string" ? (this._encoded = Ve, this._decoded = void 0) : (this._encoded = void 0, this._decoded = P(Ve, W)), this._decodedMemo =
        $(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function Me(N) {
      return N;
    }
    s(Me, "cast");
    function tt(N) {
      var B, R;
      return (B = (R = N)._encoded) !== null && B !== void 0 ? B : R._encoded = t.encode(N._decoded);
    }
    s(tt, "encodedMappings");
    function He(N) {
      var B;
      return (B = N)._decoded || (B._decoded = t.decode(N._encoded));
    }
    s(He, "decodedMappings");
    function Ci(N, B, R) {
      let W = He(N);
      if (B >= W.length)
        return null;
      let ue = W[B], te = Ds(ue, N._decodedMemo, B, R, _e);
      return te === -1 ? null : ue[te];
    }
    s(Ci, "traceSegment");
    function Jr(N, B) {
      let { line: R, column: W, bias: ue } = B;
      if (R--, R < 0)
        throw new Error(Q);
      if (W < 0)
        throw new Error(ne);
      let te = He(N);
      if (R >= te.length)
        return _s(null, null, null, null);
      let Se = te[R], De = Ds(Se, N._decodedMemo, R, W, ue || _e);
      if (De === -1)
        return _s(null, null, null, null);
      let me = Se[De];
      if (me.length === 1)
        return _s(null, null, null, null);
      let { names: ke, resolvedSources: mt } = N;
      return _s(mt[me[o]], me[l] + 1, me[u], me.length === 5 ? ke[me[c]] : null);
    }
    s(Jr, "originalPositionFor");
    function Pr(N, B) {
      let { source: R, line: W, column: ue, bias: te } = B;
      return pp(N, R, W, ue, te || _e, !1);
    }
    s(Pr, "generatedPositionFor");
    function $r(N, B) {
      let { source: R, line: W, column: ue, bias: te } = B;
      return pp(N, R, W, ue, te || ce, !0);
    }
    s($r, "allGeneratedPositionsFor");
    function Ar(N, B) {
      let R = He(N), { names: W, resolvedSources: ue } = N;
      for (let te = 0; te < R.length; te++) {
        let Se = R[te];
        for (let De = 0; De < Se.length; De++) {
          let me = Se[De], ke = te + 1, mt = me[0], Ke = null, Ve = null, nt = null, Ft = null;
          me.length !== 1 && (Ke = ue[me[1]], Ve = me[2] + 1, nt = me[3]), me.length === 5 && (Ft = W[me[4]]), B({
            generatedLine: ke,
            generatedColumn: mt,
            source: Ke,
            originalLine: Ve,
            originalColumn: nt,
            name: Ft
          });
        }
      }
    }
    s(Ar, "eachMapping");
    function vr(N, B) {
      let { sources: R, resolvedSources: W } = N, ue = R.indexOf(B);
      return ue === -1 && (ue = W.indexOf(B)), ue;
    }
    s(vr, "sourceIndex");
    function Cr(N, B) {
      let { sourcesContent: R } = N;
      if (R == null)
        return null;
      let W = vr(N, B);
      return W === -1 ? null : R[W];
    }
    s(Cr, "sourceContentFor");
    function Ns(N, B) {
      let { ignoreList: R } = N;
      if (R == null)
        return !1;
      let W = vr(N, B);
      return W === -1 ? !1 : R.includes(W);
    }
    s(Ns, "isIgnored");
    function cp(N, B) {
      let R = new Ie(da(N, []), B);
      return R._decoded = N.mappings, R;
    }
    s(cp, "presortedDecodedMap");
    function j0(N) {
      return da(N, He(N));
    }
    s(j0, "decodedMap");
    function R0(N) {
      return da(N, tt(N));
    }
    s(R0, "encodedMap");
    function da(N, B) {
      return {
        version: N.version,
        file: N.file,
        names: N.names,
        sourceRoot: N.sourceRoot,
        sources: N.sources,
        sourcesContent: N.sourcesContent,
        mappings: B,
        ignoreList: N.ignoreList || N.x_google_ignoreList
      };
    }
    s(da, "clone");
    function _s(N, B, R, W) {
      return { source: N, line: B, column: R, name: W };
    }
    s(_s, "OMapping");
    function Ii(N, B) {
      return { line: N, column: B };
    }
    s(Ii, "GMapping");
    function Ds(N, B, R, W, ue) {
      let te = K(N, W, B, R);
      return O ? te = (ue === ce ? F : G)(N, W, te) : ue === ce && te++, te === -1 || te === N.length ? -1 : te;
    }
    s(Ds, "traceSegmentInternal");
    function q0(N, B, R, W, ue) {
      let te = Ds(N, B, R, W, _e);
      if (!O && ue === ce && te++, te === -1 || te === N.length)
        return [];
      let Se = O ? W : N[te][a];
      O || (te = G(N, Se, te));
      let De = F(N, Se, te), me = [];
      for (; te <= De; te++) {
        let ke = N[te];
        me.push(Ii(ke[p] + 1, ke[g]));
      }
      return me;
    }
    s(q0, "sliceGeneratedPositions");
    function pp(N, B, R, W, ue, te) {
      var Se;
      if (R--, R < 0)
        throw new Error(Q);
      if (W < 0)
        throw new Error(ne);
      let { sources: De, resolvedSources: me } = N, ke = De.indexOf(B);
      if (ke === -1 && (ke = me.indexOf(B)), ke === -1)
        return te ? [] : Ii(null, null);
      let Ke = ((Se = N)._bySources || (Se._bySources = oe(He(N), N._bySourceMemos = De.map($))))[ke][R];
      if (Ke == null)
        return te ? [] : Ii(null, null);
      let Ve = N._bySourceMemos[ke];
      if (te)
        return q0(Ke, Ve, R, W, ue);
      let nt = Ds(Ke, Ve, R, W, ue);
      if (nt === -1)
        return Ii(null, null);
      let Ft = Ke[nt];
      return Ii(Ft[p] + 1, Ft[g]);
    }
    s(pp, "generatedPosition"), e.AnyMap = $e, e.GREATEST_LOWER_BOUND = _e, e.LEAST_UPPER_BOUND = ce, e.TraceMap = Ie, e.allGeneratedPositionsFor =
    $r, e.decodedMap = j0, e.decodedMappings = He, e.eachMapping = Ar, e.encodedMap = R0, e.encodedMappings = tt, e.generatedPositionFor = Pr,
    e.isIgnored = Ns, e.originalPositionFor = Jr, e.presortedDecodedMap = cp, e.sourceContentFor = Cr, e.traceSegment = Ci;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var vh = v((un, Ah) => {
  (function(e, t) {
    typeof un == "object" && typeof Ah < "u" ? t(un, Sh(), Sl(), Pl()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], t) : (e = typeof globalThis < "u" ? globalThis : e || self,
    t(e.genMapping = {}, e.setArray, e.sourcemapCodec, e.traceMapping));
  })(un, function(e, t, r, i) {
    "use strict";
    class p {
      static {
        s(this, "GenMapping");
      }
      constructor({ file: Q, sourceRoot: ne } = {}) {
        this._names = new t.SetArray(), this._sources = new t.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = Q, this.
        sourceRoot = ne, this._ignoreList = new t.SetArray();
      }
    }
    function g(ie) {
      return ie;
    }
    s(g, "cast");
    function P(ie, Q, ne, ce, _e, Ie, Me, tt) {
      return K(!1, ie, Q, ne, ce, _e, Ie, Me, tt);
    }
    s(P, "addSegment");
    function A(ie, Q) {
      return Mt(!1, ie, Q);
    }
    s(A, "addMapping");
    let C = /* @__PURE__ */ s((ie, Q, ne, ce, _e, Ie, Me, tt) => K(!0, ie, Q, ne, ce, _e, Ie, Me, tt), "maybeAddSegment"), _ = /* @__PURE__ */ s(
    (ie, Q) => Mt(!0, ie, Q), "maybeAddMapping");
    function k(ie, Q, ne) {
      let { _sources: ce, _sourcesContent: _e } = ie, Ie = t.put(ce, Q);
      _e[Ie] = ne;
    }
    s(k, "setSourceContent");
    function O(ie, Q, ne = !0) {
      let { _sources: ce, _sourcesContent: _e, _ignoreList: Ie } = ie, Me = t.put(ce, Q);
      Me === _e.length && (_e[Me] = null), ne ? t.put(Ie, Me) : t.remove(Ie, Me);
    }
    s(O, "setIgnore");
    function M(ie) {
      let { _mappings: Q, _sources: ne, _sourcesContent: ce, _names: _e, _ignoreList: Ie } = ie;
      return $e(Q), {
        version: 3,
        file: ie.file || void 0,
        names: _e.array,
        sourceRoot: ie.sourceRoot || void 0,
        sources: ne.array,
        sourcesContent: ce,
        mappings: Q,
        ignoreList: Ie.array
      };
    }
    s(M, "toDecodedMap");
    function F(ie) {
      let Q = M(ie);
      return Object.assign(Object.assign({}, Q), { mappings: r.encode(Q.mappings) });
    }
    s(F, "toEncodedMap");
    function G(ie) {
      let Q = new i.TraceMap(ie), ne = new p({ file: Q.file, sourceRoot: Q.sourceRoot });
      return Lt(ne._names, Q.names), Lt(ne._sources, Q.sources), ne._sourcesContent = Q.sourcesContent || Q.sources.map(() => null), ne._mappings =
      i.decodedMappings(Q), Q.ignoreList && Lt(ne._ignoreList, Q.ignoreList), ne;
    }
    s(G, "fromMap");
    function $(ie) {
      let Q = [], { _mappings: ne, _sources: ce, _names: _e } = ie;
      for (let Ie = 0; Ie < ne.length; Ie++) {
        let Me = ne[Ie];
        for (let tt = 0; tt < Me.length; tt++) {
          let He = Me[tt], Ci = { line: Ie + 1, column: He[0] }, Jr, Pr, $r;
          He.length !== 1 && (Jr = ce.array[He[1]], Pr = { line: He[2] + 1, column: He[3] }, He.length === 5 && ($r = _e.array[He[4]])), Q.push(
          { generated: Ci, source: Jr, original: Pr, name: $r });
        }
      }
      return Q;
    }
    s($, "allMappings");
    function K(ie, Q, ne, ce, _e, Ie, Me, tt, He) {
      let { _mappings: Ci, _sources: Jr, _sourcesContent: Pr, _names: $r } = Q, Ar = oe(Ci, ne), vr = Oe(Ar, ce);
      if (!_e)
        return ie && rr(Ar, vr) ? void 0 : Ne(Ar, vr, [ce]);
      let Cr = t.put(Jr, _e), Ns = tt ? t.put($r, tt) : -1;
      if (Cr === Pr.length && (Pr[Cr] = He ?? null), !(ie && Os(Ar, vr, Cr, Ie, Me, Ns)))
        return Ne(Ar, vr, tt ? [ce, Cr, Ie, Me, Ns] : [ce, Cr, Ie, Me]);
    }
    s(K, "addSegmentInternal");
    function oe(ie, Q) {
      for (let ne = ie.length; ne <= Q; ne++)
        ie[ne] = [];
      return ie[Q];
    }
    s(oe, "getLine");
    function Oe(ie, Q) {
      let ne = ie.length;
      for (let ce = ne - 1; ce >= 0; ne = ce--) {
        let _e = ie[ce];
        if (Q >= _e[0])
          break;
      }
      return ne;
    }
    s(Oe, "getColumnIndex");
    function Ne(ie, Q, ne) {
      for (let ce = ie.length; ce > Q; ce--)
        ie[ce] = ie[ce - 1];
      ie[Q] = ne;
    }
    s(Ne, "insert");
    function $e(ie) {
      let { length: Q } = ie, ne = Q;
      for (let ce = ne - 1; ce >= 0 && !(ie[ce].length > 0); ne = ce, ce--)
        ;
      ne < Q && (ie.length = ne);
    }
    s($e, "removeEmptyFinalLines");
    function Lt(ie, Q) {
      for (let ne = 0; ne < Q.length; ne++)
        t.put(ie, Q[ne]);
    }
    s(Lt, "putAll");
    function rr(ie, Q) {
      return Q === 0 ? !0 : ie[Q - 1].length === 1;
    }
    s(rr, "skipSourceless");
    function Os(ie, Q, ne, ce, _e, Ie) {
      if (Q === 0)
        return !1;
      let Me = ie[Q - 1];
      return Me.length === 1 ? !1 : ne === Me[1] && ce === Me[2] && _e === Me[3] && Ie === (Me.length === 5 ? Me[4] : -1);
    }
    s(Os, "skipSource");
    function Mt(ie, Q, ne) {
      let { generated: ce, source: _e, original: Ie, name: Me, content: tt } = ne;
      return _e ? K(ie, Q, ce.line - 1, ce.column, _e, Ie.line - 1, Ie.column, Me, tt) : K(ie, Q, ce.line - 1, ce.column, null, null, null, null,
      null);
    }
    s(Mt, "addMappingInternal"), e.GenMapping = p, e.addMapping = A, e.addSegment = P, e.allMappings = $, e.fromMap = G, e.maybeAddMapping =
    _, e.maybeAddSegment = C, e.setIgnore = O, e.setSourceContent = k, e.toDecodedMap = M, e.toEncodedMap = F, Object.defineProperty(e, "__e\
sModule", { value: !0 });
  });
});

// ../node_modules/@babel/generator/lib/source-map.js
var Ch = v((cn) => {
  "use strict";
  Object.defineProperty(cn, "__esModule", {
    value: !0
  });
  cn.default = void 0;
  var lr = vh(), Al = Pl(), vl = class {
    static {
      s(this, "SourceMap");
    }
    constructor(t, r) {
      var i;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let n = this._map = new lr.GenMapping({
        sourceRoot: t.sourceRoot
      });
      if (this._sourceFileName = (i = t.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
        this._inputMap = new Al.TraceMap(t.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, lr.setSourceContent)(n, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !t.inputSourceMap)
        (0, lr.setSourceContent)(n, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, lr.setSourceContent)(n, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, lr.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, lr.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, lr.allMappings)(this._map));
    }
    mark(t, r, i, n, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, Al.originalPositionFor)(this._inputMap, {
            line: r,
            column: i
          }), !u.name && a) {
            let c = (0, Al.originalPositionFor)(this._inputMap, a);
            c.name && (n = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: i
          };
      (0, lr.maybeAddMapping)(this._map, {
        name: n,
        generated: t,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  cn.default = vl;
});

// ../node_modules/@babel/generator/lib/buffer.js
var Ih = v((pn) => {
  "use strict";
  Object.defineProperty(pn, "__esModule", {
    value: !0
  });
  pn.default = void 0;
  var Cl = class {
    static {
      s(this, "Buffer");
    }
    constructor(t, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = t, this._indentChar = r;
      for (let i = 0; i < 64; i++)
        this._fastIndentations.push(r.repeat(i));
      this._allocQueue();
    }
    _allocQueue() {
      let t = this._queue;
      for (let r = 0; r < 16; r++)
        t.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(t, r, i, n, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = t, l.repeat = r, l.line = i, l.column = n, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let t = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: t?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let i = t ? t.get() : null;
          return r.map = i, i;
        },
        set map(i) {
          Object.defineProperty(r, "map", {
            value: i,
            writable: !0
          });
        },
        get rawMappings() {
          let i = t?.getRawMappings();
          return r.rawMappings = i, i;
        },
        set rawMappings(i) {
          Object.defineProperty(r, "rawMappings", {
            value: i,
            writable: !0
          });
        }
      };
      return r;
    }
    append(t, r) {
      this._flush(), this._append(t, this._sourcePosition, r);
    }
    appendChar(t) {
      this._flush(), this._appendChar(t, 1, this._sourcePosition);
    }
    queue(t) {
      if (t === 10)
        for (; this._queueCursor !== 0; ) {
          let i = this._queue[this._queueCursor - 1].char;
          if (i !== 32 && i !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(t, 1, r.line, r.column, r.filename);
    }
    queueIndentation(t) {
      t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
    }
    _flush() {
      let t = this._queueCursor, r = this._queue;
      for (let i = 0; i < t; i++) {
        let n = r[i];
        this._appendChar(n.char, n.repeat, n);
      }
      this._queueCursor = 0;
    }
    _appendChar(t, r, i) {
      if (this._last = t, t === -1) {
        let n = this._fastIndentations[r];
        n !== void 0 ? this._str += n : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
      t !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
    }
    _append(t, r, i) {
      let n = t.length, a = this._position;
      if (this._last = t.charCodeAt(n - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount =
      0) : this._str += t, !i && !this._map) {
        a.column += n;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = r, p = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let g = t.indexOf(`
`), P = 0;
      for (g !== 0 && this._mark(p, o, l, u, c); g !== -1; )
        a.line++, a.column = 0, P = g + 1, P < n && p !== void 0 && this._mark(++p, 0, null, null, c), g = t.indexOf(`
`, P);
      a.column += n - P;
    }
    _mark(t, r, i, n, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, t, r, i, n, a);
    }
    removeTrailingNewline() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let t = this._queueCursor;
      return t !== 0 ? this._queue[t - 1].char : this._last;
    }
    getNewlineCount() {
      let t = this._queueCursor, r = 0;
      if (t === 0) return this._last === 10 ? 1 : 0;
      for (let i = t - 1; i >= 0 && this._queue[i].char === 10; i--)
        r++;
      return r === t && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let t = this._queue, r = this._queueCursor;
      if (r !== 0)
        return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(t, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", t);
      let i = t.identifierName, n = this._sourcePosition;
      i && (this._canMarkIdName = !1, n.identifierName = i), r(), i && (this._canMarkIdName = !0, n.identifierName = void 0, n.identifierNamePos =
      void 0), this.source("end", t);
    }
    source(t, r) {
      this._map && this._normalizePosition(t, r, 0);
    }
    sourceWithOffset(t, r, i) {
      this._map && this._normalizePosition(t, r, i);
    }
    withSource(t, r, i) {
      this._map && this.source(t, r), i();
    }
    _normalizePosition(t, r, i) {
      let n = r[t], a = this._sourcePosition;
      n && (a.line = n.line, a.column = Math.max(n.column + i, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let t = this._queue, r = this._queueCursor, i = -1, n = 0;
      for (let a = 0; a < r; a++) {
        let o = t[a];
        o.char === 10 && (i = n), n += o.repeat;
      }
      return i === -1 ? this._position.column + n : n - 1 - i;
    }
    getCurrentLine() {
      let t = 0, r = this._queue;
      for (let i = 0; i < this._queueCursor; i++)
        r[i].char === 10 && t++;
      return this._position.line + t;
    }
  };
  pn.default = Cl;
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var Dh = v((hn) => {
  "use strict";
  Object.defineProperty(hn, "__esModule", {
    value: !0
  });
  hn.nodes = void 0;
  var t3 = le(), {
    FLIPPED_ALIAS_KEYS: r3,
    isArrayExpression: i3,
    isAssignmentExpression: Oh,
    isBinary: Nh,
    isBlockStatement: s3,
    isCallExpression: _h,
    isFunction: Ji,
    isIdentifier: fn,
    isLiteral: n3,
    isMemberExpression: Il,
    isObjectExpression: a3,
    isOptionalCallExpression: o3,
    isOptionalMemberExpression: l3,
    isStringLiteral: u3
  } = t3;
  function ti(e, t) {
    return e && (Il(e) || l3(e) ? (ti(e.object, t), e.computed && ti(e.property, t)) : Nh(e) || Oh(e) ? (ti(e.left, t), ti(e.right, t)) : _h(
    e) || o3(e) ? (t.hasCall = !0, ti(e.callee, t)) : Ji(e) ? t.hasFunction = !0 : fn(e) && (t.hasHelper = t.hasHelper || e.callee && Yt(e.callee))),
    t;
  }
  s(ti, "crawlInternal");
  function wh(e) {
    return ti(e, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  s(wh, "crawl");
  function Yt(e) {
    return e ? Il(e) ? Yt(e.object) || Yt(e.property) : fn(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : _h(e) ? Yt(e.callee) :
    Nh(e) || Oh(e) ? fn(e.left) && Yt(e.left) || Yt(e.right) : !1 : !1;
  }
  s(Yt, "isHelper");
  function c3(e) {
    return n3(e) || a3(e) || i3(e) || fn(e) || Il(e);
  }
  s(c3, "isType");
  var Lr = hn.nodes = {
    AssignmentExpression(e) {
      let t = wh(e.right);
      if (t.hasCall && t.hasHelper || t.hasFunction)
        return t.hasFunction ? 3 : 2;
    },
    SwitchCase(e, t) {
      return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
    },
    LogicalExpression(e) {
      if (Ji(e.left) || Ji(e.right))
        return 2;
    },
    Literal(e) {
      if (u3(e) && e.value === "use strict")
        return 2;
    },
    CallExpression(e) {
      if (Ji(e.callee) || Yt(e))
        return 3;
    },
    OptionalCallExpression(e) {
      if (Ji(e.callee))
        return 3;
    },
    VariableDeclaration(e) {
      for (let t = 0; t < e.declarations.length; t++) {
        let r = e.declarations[t], i = Yt(r.id) && !c3(r.init);
        if (!i && r.init) {
          let n = wh(r.init);
          i = Yt(r.init) && n.hasCall || n.hasFunction;
        }
        if (i)
          return 3;
      }
    },
    IfStatement(e) {
      if (s3(e.consequent))
        return 3;
    }
  };
  Lr.ObjectProperty = Lr.ObjectTypeProperty = Lr.ObjectMethod = function(e, t) {
    if (t.properties[0] === e)
      return 1;
  };
  Lr.ObjectTypeCallProperty = function(e, t) {
    var r;
    if (t.callProperties[0] === e && !((r = t.properties) != null && r.length))
      return 1;
  };
  Lr.ObjectTypeIndexer = function(e, t) {
    var r, i;
    if (t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length))
      return 1;
  };
  Lr.ObjectTypeInternalSlot = function(e, t) {
    var r, i, n;
    if (t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length) && !((n = t.indexers) !=
    null && n.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  e, t]) {
    [e].concat(r3[e] || []).forEach(function(r) {
      let i = t ? 3 : 0;
      Lr[r] = () => i;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var Bh = v((Pe) => {
  "use strict";
  Object.defineProperty(Pe, "__esModule", {
    value: !0
  });
  Pe.ArrowFunctionExpression = R3;
  Pe.AssignmentExpression = V3;
  Pe.Binary = I3;
  Pe.BinaryExpression = L3;
  Pe.ClassExpression = B3;
  Pe.ConditionalExpression = wl;
  Pe.DoExpression = C3;
  Pe.FunctionExpression = j3;
  Pe.FunctionTypeAnnotation = P3;
  Pe.Identifier = K3;
  Pe.LogicalExpression = U3;
  Pe.NullableTypeAnnotation = E3;
  Pe.ObjectExpression = v3;
  Pe.OptionalIndexedAccessType = O3;
  Pe.OptionalCallExpression = Pe.OptionalMemberExpression = q3;
  Pe.SequenceExpression = M3;
  Pe.TSTypeAssertion = Pe.TSSatisfiesExpression = Pe.TSAsExpression = N3;
  Pe.TSInferType = D3;
  Pe.TSInstantiationExpression = k3;
  Pe.TSIntersectionType = Pe.TSUnionType = _3;
  Pe.UnaryLike = Fh;
  Pe.IntersectionTypeAnnotation = Pe.UnionTypeAnnotation = w3;
  Pe.UpdateExpression = A3;
  Pe.AwaitExpression = Pe.YieldExpression = F3;
  var p3 = le(), {
    isArrayTypeAnnotation: f3,
    isArrowFunctionExpression: h3,
    isBinaryExpression: d3,
    isCallExpression: m3,
    isExportDeclaration: y3,
    isForOfStatement: T3,
    isIndexedAccessType: g3,
    isMemberExpression: Lh,
    isObjectPattern: b3,
    isOptionalMemberExpression: S3,
    isYieldExpression: x3
  } = p3, kh = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function Mh(e) {
    return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
  }
  s(Mh, "isTSTypeExpression");
  var dn = /* @__PURE__ */ s((e, t) => {
    let r = t.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
  }, "isClassExtendsClause"), $i = /* @__PURE__ */ s((e, t) => {
    let r = t.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function E3(e, t) {
    return f3(t);
  }
  s(E3, "NullableTypeAnnotation");
  function P3(e, t, r) {
    if (r.length < 3) return;
    let i = t.type;
    return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || i === "TypeAnnotation" && h3(
    r[r.length - 3]);
  }
  s(P3, "FunctionTypeAnnotation");
  function A3(e, t) {
    return $i(e, t) || dn(e, t);
  }
  s(A3, "UpdateExpression");
  function v3(e, t, r) {
    return Hi(r, 3);
  }
  s(v3, "ObjectExpression");
  function C3(e, t, r) {
    return !e.async && Hi(r, 1);
  }
  s(C3, "DoExpression");
  function I3(e, t) {
    let r = t.type;
    if (e.operator === "**" && r === "BinaryExpression" && t.operator === "**")
      return t.left === e;
    if (dn(e, t) || $i(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    if (r === "BinaryExpression" || r === "LogicalExpression") {
      let i = kh.get(t.operator), n = kh.get(e.operator);
      if (i === n && t.right === e && r !== "LogicalExpression" || i > n)
        return !0;
    }
  }
  s(I3, "Binary");
  function w3(e, t) {
    let r = t.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  s(w3, "UnionTypeAnnotation");
  function O3(e, t) {
    return g3(t) && t.objectType === e;
  }
  s(O3, "OptionalIndexedAccessType");
  function N3() {
    return !0;
  }
  s(N3, "TSAsExpression");
  function _3(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
  }
  s(_3, "TSUnionType");
  function D3(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSOptionalType";
  }
  s(D3, "TSInferType");
  function k3(e, t) {
    let r = t.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
  }
  s(k3, "TSInstantiationExpression");
  function L3(e, t) {
    if (e.operator === "in") {
      let r = t.type;
      return r === "VariableDeclarator" || r === "ForStatement" || r === "ForInStatement" || r === "ForOfStatement";
    }
    return !1;
  }
  s(L3, "BinaryExpression");
  function M3(e, t) {
    let r = t.type;
    return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && t.test === e || r === "Whil\
eStatement" && t.test === e || r === "ForInStatement" && t.right === e || r === "SwitchStatement" && t.discriminant === e || r === "Expressi\
onStatement" && t.expression === e);
  }
  s(M3, "SequenceExpression");
  function F3(e, t) {
    let r = t.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || $i(e, t) || r === "A\
waitExpression" && x3(e) || r === "ConditionalExpression" && e === t.test || dn(e, t);
  }
  s(F3, "YieldExpression");
  function B3(e, t, r) {
    return Hi(r, 5);
  }
  s(B3, "ClassExpression");
  function Fh(e, t) {
    return $i(e, t) || d3(t) && t.operator === "**" && t.left === e || dn(e, t);
  }
  s(Fh, "UnaryLike");
  function j3(e, t, r) {
    return Hi(r, 5);
  }
  s(j3, "FunctionExpression");
  function R3(e, t) {
    return y3(t) || wl(e, t);
  }
  s(R3, "ArrowFunctionExpression");
  function wl(e, t) {
    let r = t.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && t.test === e || r === "AwaitExpression" || Mh(r) ? !0 : Fh(e, t);
  }
  s(wl, "ConditionalExpression");
  function q3(e, t) {
    return m3(t) && t.callee === e || Lh(t) && t.object === e;
  }
  s(q3, "OptionalMemberExpression");
  function V3(e, t) {
    return b3(e.left) ? !0 : wl(e, t);
  }
  s(V3, "AssignmentExpression");
  function U3(e, t) {
    let r = t.type;
    if (Mh(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (e.operator) {
      case "||":
        return t.operator === "??" || t.operator === "&&";
      case "&&":
        return t.operator === "??";
      case "??":
        return t.operator !== "??";
    }
  }
  s(U3, "LogicalExpression");
  function K3(e, t, r) {
    var i;
    let n = t.type;
    if ((i = e.extra) != null && i.parenthesized && n === "AssignmentExpression" && t.left === e) {
      let a = t.right.type;
      if ((a === "FunctionExpression" || a === "ClassExpression") && t.right.id == null)
        return !0;
    }
    if (e.name === "let") {
      let a = Lh(t, {
        object: e,
        computed: !0
      }) || S3(t, {
        object: e,
        computed: !0,
        optional: !1
      });
      return Hi(r, a ? 57 : 32);
    }
    return e.name === "async" && T3(t) && e === t.left;
  }
  s(K3, "Identifier");
  function Hi(e, t) {
    let r = t & 1, i = t & 2, n = t & 4, a = t & 8, o = t & 16, l = t & 32, u = e.length - 1;
    if (u <= 0) return;
    let c = e[u];
    u--;
    let p = e[u];
    for (; u >= 0; ) {
      let g = p.type;
      if (r && g === "ExpressionStatement" && p.expression === c || n && g === "ExportDefaultDeclaration" && c === p.declaration || i && g ===
      "ArrowFunctionExpression" && p.body === c || a && g === "ForStatement" && p.init === c || o && g === "ForInStatement" && p.left === c ||
      l && g === "ForOfStatement" && p.left === c)
        return !0;
      if (u > 0 && ($i(c, p) && g !== "NewExpression" || g === "SequenceExpression" && p.expressions[0] === c || g === "UpdateExpression" &&
      !p.prefix || g === "ConditionalExpression" && p.test === c || (g === "BinaryExpression" || g === "LogicalExpression") && p.left === c ||
      g === "AssignmentExpression" && p.left === c))
        c = p, u--, p = e[u];
      else
        return !1;
    }
    return !1;
  }
  s(Hi, "isFirstInContext");
});

// ../node_modules/@babel/generator/lib/node/index.js
var Nl = v((ri) => {
  "use strict";
  Object.defineProperty(ri, "__esModule", {
    value: !0
  });
  ri.needsParens = rF;
  ri.needsWhitespace = Ol;
  ri.needsWhitespaceAfter = tF;
  ri.needsWhitespaceBefore = eF;
  var W3 = Dh(), Y3 = Bh(), X3 = le(), {
    FLIPPED_ALIAS_KEYS: J3,
    isCallExpression: $3,
    isExpressionStatement: H3,
    isMemberExpression: G3,
    isNewExpression: z3
  } = X3;
  function jh(e) {
    let t = /* @__PURE__ */ new Map();
    function r(i, n) {
      let a = t.get(i);
      t.set(i, a ? function(o, l, u) {
        var c;
        return (c = a(o, l, u)) != null ? c : n(o, l, u);
      } : n);
    }
    s(r, "add");
    for (let i of Object.keys(e)) {
      let n = J3[i];
      if (n)
        for (let a of n)
          r(a, e[i]);
      else
        r(i, e[i]);
    }
    return t;
  }
  s(jh, "expandAliases");
  var Q3 = jh(Y3), Z3 = jh(W3.nodes);
  function Rh(e) {
    return $3(e) ? !0 : G3(e) && Rh(e.object);
  }
  s(Rh, "isOrHasCallExpression");
  function Ol(e, t, r) {
    var i;
    if (!e) return !1;
    H3(e) && (e = e.expression);
    let n = (i = Z3.get(e.type)) == null ? void 0 : i(e, t);
    return typeof n == "number" ? (n & r) !== 0 : !1;
  }
  s(Ol, "needsWhitespace");
  function eF(e, t) {
    return Ol(e, t, 1);
  }
  s(eF, "needsWhitespaceBefore");
  function tF(e, t) {
    return Ol(e, t, 2);
  }
  s(tF, "needsWhitespaceAfter");
  function rF(e, t, r) {
    var i;
    return t ? z3(t) && t.callee === e && Rh(e) ? !0 : (i = Q3.get(e.type)) == null ? void 0 : i(e, t, r) : !1;
  }
  s(rF, "needsParens");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var qh = v((Gi) => {
  "use strict";
  Object.defineProperty(Gi, "__esModule", {
    value: !0
  });
  Gi.TaggedTemplateExpression = iF;
  Gi.TemplateElement = sF;
  Gi.TemplateLiteral = nF;
  function iF(e) {
    this.print(e.tag, e), this.print(e.typeParameters, e), this.print(e.quasi, e);
  }
  s(iF, "TaggedTemplateExpression");
  function sF(e, t) {
    let r = t.quasis[0] === e, i = t.quasis[t.quasis.length - 1] === e, n = (r ? "`" : "}") + e.value.raw + (i ? "`" : "${");
    this.token(n, !0);
  }
  s(sF, "TemplateElement");
  function nF(e) {
    let t = e.quasis;
    for (let r = 0; r < t.length; r++)
      this.print(t[r], e), r + 1 < t.length && this.print(e.expressions[r], e);
  }
  s(nF, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var Kh = v((Ce) => {
  "use strict";
  Object.defineProperty(Ce, "__esModule", {
    value: !0
  });
  Ce.LogicalExpression = Ce.BinaryExpression = Ce.AssignmentExpression = _F;
  Ce.AssignmentPattern = NF;
  Ce.AwaitExpression = CF;
  Ce.BindExpression = DF;
  Ce.CallExpression = AF;
  Ce.ConditionalExpression = dF;
  Ce.Decorator = xF;
  Ce.DoExpression = pF;
  Ce.EmptyStatement = wF;
  Ce.ExpressionStatement = OF;
  Ce.Import = vF;
  Ce.MemberExpression = kF;
  Ce.MetaProperty = LF;
  Ce.ModuleExpression = BF;
  Ce.NewExpression = mF;
  Ce.OptionalCallExpression = PF;
  Ce.OptionalMemberExpression = EF;
  Ce.ParenthesizedExpression = fF;
  Ce.PrivateName = MF;
  Ce.SequenceExpression = yF;
  Ce.Super = gF;
  Ce.ThisExpression = TF;
  Ce.UnaryExpression = cF;
  Ce.UpdateExpression = hF;
  Ce.V8IntrinsicIdentifier = FF;
  Ce.YieldExpression = IF;
  Ce._shouldPrintDecoratorsBeforeExport = SF;
  var aF = le(), oF = Nl(), {
    isCallExpression: lF,
    isLiteral: Vh,
    isMemberExpression: _l,
    isNewExpression: uF
  } = aF;
  function cF(e) {
    let {
      operator: t
    } = e;
    t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument,
    e);
  }
  s(cF, "UnaryExpression");
  function pF(e) {
    e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body, e);
  }
  s(pF, "DoExpression");
  function fF(e) {
    this.tokenChar(40), this.print(e.expression, e), this.rightParens(e);
  }
  s(fF, "ParenthesizedExpression");
  function hF(e) {
    e.prefix ? (this.token(e.operator), this.print(e.argument, e)) : (this.printTerminatorless(e.argument, e, !0), this.token(e.operator));
  }
  s(hF, "UpdateExpression");
  function dF(e) {
    this.print(e.test, e), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent, e), this.space(), this.tokenChar(58), this.
    space(), this.print(e.alternate, e);
  }
  s(dF, "ConditionalExpression");
  function mF(e, t) {
    this.word("new"), this.space(), this.print(e.callee, e), !(this.format.minified && e.arguments.length === 0 && !e.optional && !lF(t, {
      callee: e
    }) && !_l(t) && !uF(t)) && (this.print(e.typeArguments, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.tokenChar(
    40), this.printList(e.arguments, e), this.rightParens(e));
  }
  s(mF, "NewExpression");
  function yF(e) {
    this.printList(e.expressions, e);
  }
  s(yF, "SequenceExpression");
  function TF() {
    this.word("this");
  }
  s(TF, "ThisExpression");
  function gF() {
    this.word("super");
  }
  s(gF, "Super");
  function Uh(e) {
    switch (e.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !e.computed && e.property.type === "Identifier" && Uh(e.object);
      default:
        return !1;
    }
  }
  s(Uh, "isDecoratorMemberExpression");
  function bF(e) {
    return e.type === "ParenthesizedExpression" ? !1 : !Uh(e.type === "CallExpression" ? e.callee : e);
  }
  s(bF, "shouldParenthesizeDecoratorExpression");
  function SF(e) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start ===
    e.declaration.start;
  }
  s(SF, "_shouldPrintDecoratorsBeforeExport");
  function xF(e) {
    this.tokenChar(64);
    let {
      expression: t
    } = e;
    bF(t) ? (this.tokenChar(40), this.print(t, e), this.tokenChar(41)) : this.print(t, e), this.newline();
  }
  s(xF, "Decorator");
  function EF(e) {
    let {
      computed: t
    } = e, {
      optional: r,
      property: i
    } = e;
    if (this.print(e.object, e), !t && _l(i))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    Vh(i) && typeof i.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(i, e), this.tokenChar(93)) :
    (r || this.tokenChar(46), this.print(i, e));
  }
  s(EF, "OptionalMemberExpression");
  function PF(e) {
    this.print(e.callee, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.print(e.typeArguments, e), this.tokenChar(
    40), this.printList(e.arguments, e), this.rightParens(e);
  }
  s(PF, "OptionalCallExpression");
  function AF(e) {
    this.print(e.callee, e), this.print(e.typeArguments, e), this.print(e.typeParameters, e), this.tokenChar(40), this.printList(e.arguments,
    e), this.rightParens(e);
  }
  s(AF, "CallExpression");
  function vF() {
    this.word("import");
  }
  s(vF, "Import");
  function CF(e) {
    this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
  }
  s(CF, "AwaitExpression");
  function IF(e) {
    this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument, e))) : e.argument && (this.
    space(), this.printTerminatorless(e.argument, e, !1));
  }
  s(IF, "YieldExpression");
  function wF() {
    this.semicolon(!0);
  }
  s(wF, "EmptyStatement");
  function OF(e) {
    this.print(e.expression, e), this.semicolon();
  }
  s(OF, "ExpressionStatement");
  function NF(e) {
    this.print(e.left, e), e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation, e), this.space(), this.tokenChar(61), this.
    space(), this.print(e.right, e);
  }
  s(NF, "AssignmentPattern");
  function _F(e, t) {
    let r = this.inForStatementInitCounter && e.operator === "in" && !oF.needsParens(e, t);
    r && this.tokenChar(40), this.print(e.left, e), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) :
    this.token(e.operator), this.space(), this.print(e.right, e), r && this.tokenChar(41);
  }
  s(_F, "AssignmentExpression");
  function DF(e) {
    this.print(e.object, e), this.token("::"), this.print(e.callee, e);
  }
  s(DF, "BindExpression");
  function kF(e) {
    if (this.print(e.object, e), !e.computed && _l(e.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let t = e.computed;
    Vh(e.property) && typeof e.property.value == "number" && (t = !0), t ? (this.tokenChar(91), this.print(e.property, e), this.tokenChar(93)) :
    (this.tokenChar(46), this.print(e.property, e));
  }
  s(kF, "MemberExpression");
  function LF(e) {
    this.print(e.meta, e), this.tokenChar(46), this.print(e.property, e);
  }
  s(LF, "MetaProperty");
  function MF(e) {
    this.tokenChar(35), this.print(e.id, e);
  }
  s(MF, "PrivateName");
  function FF(e) {
    this.tokenChar(37), this.word(e.name);
  }
  s(FF, "V8IntrinsicIdentifier");
  function BF(e) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: t
    } = e;
    (t.body.length || t.directives.length) && this.newline(), this.print(t, e), this.dedent(), this.rightBrace(e);
  }
  s(BF, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var Jh = v((Re) => {
  "use strict";
  Object.defineProperty(Re, "__esModule", {
    value: !0
  });
  Re.BreakStatement = JF;
  Re.CatchClause = ZF;
  Re.ContinueStatement = $F;
  Re.DebuggerStatement = rB;
  Re.DoWhileStatement = XF;
  Re.ForOfStatement = Re.ForInStatement = void 0;
  Re.ForStatement = WF;
  Re.IfStatement = KF;
  Re.LabeledStatement = zF;
  Re.ReturnStatement = HF;
  Re.SwitchCase = tB;
  Re.SwitchStatement = eB;
  Re.ThrowStatement = GF;
  Re.TryStatement = QF;
  Re.VariableDeclaration = iB;
  Re.VariableDeclarator = sB;
  Re.WhileStatement = YF;
  Re.WithStatement = UF;
  var jF = le(), {
    isFor: Wh,
    isForStatement: RF,
    isIfStatement: qF,
    isStatement: VF
  } = jF;
  function UF(e) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(e.object, e), this.tokenChar(41), this.printBlock(e);
  }
  s(UF, "WithStatement");
  function KF(e) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.space();
    let t = e.alternate && qF(Yh(e.consequent));
    t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent, e), t && (this.dedent(), this.newline(),
    this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    e.alternate, e));
  }
  s(KF, "IfStatement");
  function Yh(e) {
    let {
      body: t
    } = e;
    return VF(t) === !1 ? e : Yh(t);
  }
  s(Yh, "getLastStatement");
  function WF(e) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(e.init, e), this.inForStatementInitCounter--,
    this.tokenChar(59), e.test && (this.space(), this.print(e.test, e)), this.tokenChar(59), e.update && (this.space(), this.print(e.update,
    e)), this.tokenChar(41), this.printBlock(e);
  }
  s(WF, "ForStatement");
  function YF(e) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.printBlock(e);
  }
  s(YF, "WhileStatement");
  function Xh(e) {
    this.word("for"), this.space();
    let t = e.type === "ForOfStatement";
    t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(e.left, e), this.space(),
    this.word(t ? "of" : "in"), this.space(), this.print(e.right, e), this.tokenChar(41), this.printBlock(e);
  }
  s(Xh, "ForXStatement");
  var CQ = Re.ForInStatement = Xh, IQ = Re.ForOfStatement = Xh;
  function XF(e) {
    this.word("do"), this.space(), this.print(e.body, e), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test,
    e), this.tokenChar(41), this.semicolon();
  }
  s(XF, "DoWhileStatement");
  function mn(e, t, r, i) {
    t && (e.space(), e.printTerminatorless(t, r, i)), e.semicolon();
  }
  s(mn, "printStatementAfterKeyword");
  function JF(e) {
    this.word("break"), mn(this, e.label, e, !0);
  }
  s(JF, "BreakStatement");
  function $F(e) {
    this.word("continue"), mn(this, e.label, e, !0);
  }
  s($F, "ContinueStatement");
  function HF(e) {
    this.word("return"), mn(this, e.argument, e, !1);
  }
  s(HF, "ReturnStatement");
  function GF(e) {
    this.word("throw"), mn(this, e.argument, e, !1);
  }
  s(GF, "ThrowStatement");
  function zF(e) {
    this.print(e.label, e), this.tokenChar(58), this.space(), this.print(e.body, e);
  }
  s(zF, "LabeledStatement");
  function QF(e) {
    this.word("try"), this.space(), this.print(e.block, e), this.space(), e.handlers ? this.print(e.handlers[0], e) : this.print(e.handler, e),
    e.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e.finalizer, e));
  }
  s(QF, "TryStatement");
  function ZF(e) {
    this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param, e), this.print(e.param.typeAnnotation, e), this.tokenChar(
    41), this.space()), this.print(e.body, e);
  }
  s(ZF, "CatchClause");
  function eB(e) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant, e), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(e.cases, e, {
      indent: !0,
      addNewlines(t, r) {
        if (!t && e.cases[e.cases.length - 1] === r) return -1;
      }
    }), this.rightBrace(e);
  }
  s(eB, "SwitchStatement");
  function tB(e) {
    e.test ? (this.word("case"), this.space(), this.print(e.test, e), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.
    length && (this.newline(), this.printSequence(e.consequent, e, {
      indent: !0
    }));
  }
  s(tB, "SwitchCase");
  function rB() {
    this.word("debugger"), this.semicolon();
  }
  s(rB, "DebuggerStatement");
  function iB(e, t) {
    e.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = e;
    this.word(r, r === "using" || r === "await using"), this.space();
    let i = !1;
    if (!Wh(t))
      for (let n of e.declarations)
        n.init && (i = !0);
    if (this.printList(e.declarations, e, {
      separator: i ? function() {
        this.tokenChar(44), this.newline();
      } : void 0,
      indent: e.declarations.length > 1
    }), Wh(t)) {
      if (RF(t)) {
        if (t.init === e) return;
      } else if (t.left === e) return;
    }
    this.semicolon();
  }
  s(iB, "VariableDeclaration");
  function sB(e) {
    this.print(e.id, e), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation, e), e.init && (this.space(), this.tokenChar(61), this.
    space(), this.print(e.init, e));
  }
  s(sB, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var $h = v((Pt) => {
  "use strict";
  Object.defineProperty(Pt, "__esModule", {
    value: !0
  });
  Pt.ClassAccessorProperty = pB;
  Pt.ClassBody = uB;
  Pt.ClassExpression = Pt.ClassDeclaration = lB;
  Pt.ClassMethod = hB;
  Pt.ClassPrivateMethod = dB;
  Pt.ClassPrivateProperty = fB;
  Pt.ClassProperty = cB;
  Pt.StaticBlock = yB;
  Pt._classMethodHead = mB;
  var nB = le(), {
    isExportDefaultDeclaration: aB,
    isExportNamedDeclaration: oB
  } = nB;
  function lB(e, t) {
    (!(aB(t) || oB(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators, e), e.declare && (this.word("declare"),
    this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id, e)), this.
    print(e.typeParameters, e), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass, e), this.print(e.
    superTypeParameters, e)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e)), this.space(),
    this.print(e.body, e);
  }
  s(lB, "ClassDeclaration");
  function uB(e) {
    this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, e, {
      indent: !0
    }), this.endsWith(10) || this.newline(), this.rightBrace(e));
  }
  s(uB, "ClassBody");
  function cB(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) :
    (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation,
    e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  s(cB, "ClassProperty");
  function pB(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.
    print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(
    33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  s(pB, "ClassAccessorProperty");
  function fB(e) {
    this.printJoin(e.decorators, e), e.static && (this.word("static"), this.space()), this.print(e.key, e), this.print(e.typeAnnotation, e),
    e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  s(fB, "ClassPrivateProperty");
  function hB(e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }
  s(hB, "ClassMethod");
  function dB(e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }
  s(dB, "ClassPrivateMethod");
  function mB(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this._methodHead(e);
  }
  s(mB, "_classMethodHead");
  function yB(e) {
    this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    e.body, e, {
      indent: !0
    }), this.rightBrace(e));
  }
  s(yB, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var Hh = v((Nt) => {
  "use strict";
  Object.defineProperty(Nt, "__esModule", {
    value: !0
  });
  Nt.ArrowFunctionExpression = CB;
  Nt.FunctionDeclaration = Nt.FunctionExpression = vB;
  Nt._functionHead = AB;
  Nt._methodHead = EB;
  Nt._param = xB;
  Nt._parameters = SB;
  Nt._params = bB;
  Nt._predicate = PB;
  var TB = le(), {
    isIdentifier: gB
  } = TB;
  function bB(e, t, r) {
    this.print(e.typeParameters, e);
    let i = wB.call(this, t, r);
    i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(e.params, e), this.tokenChar(41);
    let n = e.type === "ArrowFunctionExpression";
    this.print(e.returnType, e, n), this._noLineTerminator = n;
  }
  s(bB, "_params");
  function SB(e, t) {
    let r = e.length;
    for (let i = 0; i < r; i++)
      this._param(e[i], t), i < e.length - 1 && (this.tokenChar(44), this.space());
  }
  s(SB, "_parameters");
  function xB(e, t) {
    this.printJoin(e.decorators, e), this.print(e, t), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(xB, "_param");
  function EB(e) {
    let t = e.kind, r = e.key;
    (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t ===
    "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r, e), this.tokenChar(93)) : this.print(r, e),
    e.optional && this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
  }
  s(EB, "_methodHead");
  function PB(e, t) {
    e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, e, t));
  }
  s(PB, "_predicate");
  function AB(e, t) {
    e.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), e.generator && (this._endsWithInnerRaw =
    !1, this.tokenChar(42)), this.space(), e.id && this.print(e.id, e), this._params(e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(
    e);
  }
  s(AB, "_functionHead");
  function vB(e, t) {
    this._functionHead(e, t), this.space(), this.print(e.body, e);
  }
  s(vB, "FunctionExpression");
  function CB(e, t) {
    e.async && (this.word("async", !0), this.space());
    let r;
    !this.format.retainLines && e.params.length === 1 && gB(r = e.params[0]) && !IB(e, r) ? this.print(r, e, !0) : this._params(e, void 0, t),
    this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e.body, e);
  }
  s(CB, "ArrowFunctionExpression");
  function IB(e, t) {
    var r, i;
    return !!(e.typeParameters || e.returnType || e.predicate || t.typeAnnotation || t.optional || (r = t.leadingComments) != null && r.length ||
    (i = t.trailingComments) != null && i.length);
  }
  s(IB, "hasTypesOrComments");
  function wB(e, t) {
    let r = e;
    if (!r && t) {
      let u = t.type;
      u === "VariableDeclarator" ? r = t.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = t.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = t.key);
    }
    if (!r) return;
    let i;
    if (r.type === "Identifier") {
      var n, a;
      i = {
        pos: (n = r.loc) == null ? void 0 : n.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      i = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      i = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return i;
  }
  s(wB, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var Dl = v((ct) => {
  "use strict";
  Object.defineProperty(ct, "__esModule", {
    value: !0
  });
  ct.ExportAllDeclaration = VB;
  ct.ExportDefaultDeclaration = KB;
  ct.ExportDefaultSpecifier = BB;
  ct.ExportNamedDeclaration = UB;
  ct.ExportNamespaceSpecifier = RB;
  ct.ExportSpecifier = jB;
  ct.ImportAttribute = YB;
  ct.ImportDeclaration = WB;
  ct.ImportDefaultSpecifier = FB;
  ct.ImportExpression = JB;
  ct.ImportNamespaceSpecifier = XB;
  ct.ImportSpecifier = MB;
  ct._printAttributes = qB;
  var OB = le(), {
    isClassDeclaration: NB,
    isExportDefaultSpecifier: _B,
    isExportNamespaceSpecifier: DB,
    isImportDefaultSpecifier: kB,
    isImportNamespaceSpecifier: LB,
    isStatement: zh
  } = OB;
  function MB(e) {
    (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported, e), e.local &&
    e.local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local, e));
  }
  s(MB, "ImportSpecifier");
  function FB(e) {
    this.print(e.local, e);
  }
  s(FB, "ImportDefaultSpecifier");
  function BB(e) {
    this.print(e.exported, e);
  }
  s(BB, "ExportDefaultSpecifier");
  function jB(e) {
    e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local, e), e.exported && e.local.name !== e.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(e.exported, e));
  }
  s(jB, "ExportSpecifier");
  function RB(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported, e);
  }
  s(RB, "ExportNamespaceSpecifier");
  var Gh = !1;
  function qB(e) {
    let {
      importAttributesKeyword: t
    } = this.format, {
      attributes: r,
      assertions: i
    } = e;
    r && !t && !Gh && (Gh = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify \
the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\
\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let n = t === "assert" || !t && i;
    if (this.word(n ? "assert" : "with"), this.space(), !n && t !== "with") {
      this.printList(r || i, e);
      return;
    }
    this.tokenChar(123), this.space(), this.printList(r || i, e), this.space(), this.tokenChar(125);
  }
  s(qB, "_printAttributes");
  function VB(e) {
    var t, r;
    this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0),
    this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
  }
  s(VB, "ExportAllDeclaration");
  function Qh(e, t) {
    NB(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators, t);
  }
  s(Qh, "maybePrintDecoratorsBeforeExport");
  function UB(e) {
    if (Qh(this, e), this.word("export"), this.space(), e.declaration) {
      let i = e.declaration;
      this.print(i, e), zh(i) || this.semicolon();
    } else {
      e.exportKind === "type" && (this.word("type"), this.space());
      let i = e.specifiers.slice(0), n = !1;
      for (; ; ) {
        let a = i[0];
        if (_B(a) || DB(a))
          n = !0, this.print(i.shift(), e), i.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      if ((i.length || !i.length && !n) && (this.tokenChar(123), i.length && (this.space(), this.printList(i, e), this.space()), this.tokenChar(
      125)), e.source) {
        var t, r;
        this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.
        print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e);
      }
      this.semicolon();
    }
  }
  s(UB, "ExportNamedDeclaration");
  function KB(e) {
    Qh(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
    let t = e.declaration;
    this.print(t, e), zh(t) || this.semicolon();
  }
  s(KB, "ExportDefaultDeclaration");
  function WB(e) {
    var t, r;
    this.word("import"), this.space();
    let i = e.importKind === "type" || e.importKind === "typeof";
    i ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
    let n = e.specifiers.slice(0), a = !!n.length;
    for (; a; ) {
      let o = n[0];
      if (kB(o) || LB(o))
        this.print(n.shift(), e), n.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    n.length ? (this.tokenChar(123), this.space(), this.printList(n, e), this.space(), this.tokenChar(125)) : i && !a && (this.tokenChar(123),
    this.tokenChar(125)), (a || i) && (this.space(), this.word("from"), this.space()), (t = e.attributes) != null && t.length || (r = e.assertions) !=
    null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
  }
  s(WB, "ImportDeclaration");
  function YB(e) {
    this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
  }
  s(YB, "ImportAttribute");
  function XB(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local, e);
  }
  s(XB, "ImportNamespaceSpecifier");
  function JB(e) {
    this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40), this.print(e.source, e), e.options != null &&
    (this.tokenChar(44), this.space(), this.print(e.options, e)), this.tokenChar(41);
  }
  s(JB, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var rd = v((FQ, td) => {
  "use strict";
  var Zh = {}, $B = Zh.hasOwnProperty, ed = /* @__PURE__ */ s((e, t) => {
    for (let r in e)
      $B.call(e, r) && t(r, e[r]);
  }, "forOwn"), HB = /* @__PURE__ */ s((e, t) => (t && ed(t, (r, i) => {
    e[r] = i;
  }), e), "extend"), GB = /* @__PURE__ */ s((e, t) => {
    let r = e.length, i = -1;
    for (; ++i < r; )
      t(e[i]);
  }, "forEach"), zi = Zh.toString, zB = Array.isArray, QB = Buffer.isBuffer, ZB = /* @__PURE__ */ s((e) => zi.call(e) == "[object Object]", "\
isObject"), ej = /* @__PURE__ */ s((e) => typeof e == "string" || zi.call(e) == "[object String]", "isString"), tj = /* @__PURE__ */ s((e) => typeof e ==
  "number" || zi.call(e) == "[object Number]", "isNumber"), rj = /* @__PURE__ */ s((e) => typeof e == "function", "isFunction"), ij = /* @__PURE__ */ s(
  (e) => zi.call(e) == "[object Map]", "isMap"), sj = /* @__PURE__ */ s((e) => zi.call(e) == "[object Set]", "isSet"), nj = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, aj = /["'\\\b\f\n\r\t]/, oj = /[0-9]/, lj = /[ !#-&\(-\[\]-_a-~]/, ur = /* @__PURE__ */ s((e, t) => {
    let r = /* @__PURE__ */ s(() => {
      c = u, ++t.indentLevel, u = t.indent.repeat(t.indentLevel);
    }, "increaseIndentation"), i = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, n = t && t.json;
    n && (i.quotes = "double", i.wrap = !0), t = HB(i, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes =
    "single");
    let a = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", o = t.compact, l = t.lowercaseHex, u = t.indent.repeat(t.indentLevel),
    c = "", p = t.__inline1__, g = t.__inline2__, P = o ? "" : `
`, A, C = !0, _ = t.numbers == "binary", k = t.numbers == "octal", O = t.numbers == "decimal", M = t.numbers == "hexadecimal";
    if (n && e && rj(e.toJSON) && (e = e.toJSON()), !ej(e)) {
      if (ij(e))
        return e.size == 0 ? "new Map()" : (o || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + ur(Array.from(e), t) + ")");
      if (sj(e))
        return e.size == 0 ? "new Set()" : "new Set(" + ur(Array.from(e), t) + ")";
      if (QB(e))
        return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + ur(Array.from(e), t) + ")";
      if (zB(e))
        return A = [], t.wrap = !0, p && (t.__inline1__ = !1, t.__inline2__ = !0), g || r(), GB(e, (K) => {
          C = !1, g && (t.__inline2__ = !1), A.push(
            (o || g ? "" : u) + ur(K, t)
          );
        }), C ? "[]" : g ? "[" + A.join(", ") + "]" : "[" + P + A.join("," + P) + P + (o ? "" : c) + "]";
      if (tj(e)) {
        if (n)
          return JSON.stringify(e);
        if (O)
          return String(e);
        if (M) {
          let K = e.toString(16);
          return l || (K = K.toUpperCase()), "0x" + K;
        }
        if (_)
          return "0b" + e.toString(2);
        if (k)
          return "0o" + e.toString(8);
      } else return ZB(e) ? (A = [], t.wrap = !0, r(), ed(e, (K, oe) => {
        C = !1, A.push(
          (o ? "" : u) + ur(K, t) + ":" + (o ? "" : " ") + ur(oe, t)
        );
      }), C ? "{}" : "{" + P + A.join("," + P) + P + (o ? "" : c) + "}") : n ? JSON.stringify(e) || "null" : String(e);
    }
    let F = e, G = -1, $ = F.length;
    for (A = ""; ++G < $; ) {
      let K = F.charAt(G);
      if (t.es6) {
        let Lt = F.charCodeAt(G);
        if (
          // check if it’s the start of a surrogate pair
          Lt >= 55296 && Lt <= 56319 && // high surrogate
          $ > G + 1
        ) {
          let rr = F.charCodeAt(G + 1);
          if (rr >= 56320 && rr <= 57343) {
            let Mt = ((Lt - 55296) * 1024 + rr - 56320 + 65536).toString(16);
            l || (Mt = Mt.toUpperCase()), A += "\\u{" + Mt + "}", ++G;
            continue;
          }
        }
      }
      if (!t.escapeEverything) {
        if (lj.test(K)) {
          A += K;
          continue;
        }
        if (K == '"') {
          A += a == K ? '\\"' : K;
          continue;
        }
        if (K == "`") {
          A += a == K ? "\\`" : K;
          continue;
        }
        if (K == "'") {
          A += a == K ? "\\'" : K;
          continue;
        }
      }
      if (K == "\0" && !n && !oj.test(F.charAt(G + 1))) {
        A += "\\0";
        continue;
      }
      if (aj.test(K)) {
        A += nj[K];
        continue;
      }
      let oe = K.charCodeAt(0);
      if (t.minimal && oe != 8232 && oe != 8233) {
        A += K;
        continue;
      }
      let Oe = oe.toString(16);
      l || (Oe = Oe.toUpperCase());
      let Ne = Oe.length > 2 || n, $e = "\\" + (Ne ? "u" : "x") + ("0000" + Oe).slice(Ne ? -4 : -2);
      A += $e;
    }
    return t.wrap && (A = a + A + a), a == "`" && (A = A.replace(/\$\{/g, "\\${")), t.isScriptContext ? A.replace(/<\/(script|style)/gi, "<\\\
/$1").replace(/<!--/g, n ? "\\u003C!--" : "\\x3C!--") : A;
  }, "jsesc");
  ur.version = "2.5.2";
  td.exports = ur;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var Ll = v((Fe) => {
  "use strict";
  Object.defineProperty(Fe, "__esModule", {
    value: !0
  });
  Fe.ArgumentPlaceholder = fj;
  Fe.ArrayPattern = Fe.ArrayExpression = Tj;
  Fe.BigIntLiteral = vj;
  Fe.BooleanLiteral = xj;
  Fe.DecimalLiteral = Cj;
  Fe.Identifier = pj;
  Fe.NullLiteral = Ej;
  Fe.NumericLiteral = Pj;
  Fe.ObjectPattern = Fe.ObjectExpression = dj;
  Fe.ObjectMethod = mj;
  Fe.ObjectProperty = yj;
  Fe.PipelineBareFunction = Oj;
  Fe.PipelinePrimaryTopicReference = Nj;
  Fe.PipelineTopicExpression = wj;
  Fe.RecordExpression = gj;
  Fe.RegExpLiteral = Sj;
  Fe.SpreadElement = Fe.RestElement = hj;
  Fe.StringLiteral = Aj;
  Fe.TopicReference = Ij;
  Fe.TupleExpression = bj;
  var uj = le(), sd = rd(), {
    isAssignmentPattern: cj,
    isIdentifier: kl
  } = uj;
  function pj(e) {
    var t;
    this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(e.name);
  }
  s(pj, "Identifier");
  function fj() {
    this.tokenChar(63);
  }
  s(fj, "ArgumentPlaceholder");
  function hj(e) {
    this.token("..."), this.print(e.argument, e);
  }
  s(hj, "RestElement");
  function dj(e) {
    let t = e.properties;
    this.tokenChar(123), t.length && (this.space(), this.printList(t, e, {
      indent: !0,
      statement: !0
    }), this.space()), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
  }
  s(dj, "ObjectExpression");
  function mj(e) {
    this.printJoin(e.decorators, e), this._methodHead(e), this.space(), this.print(e.body, e);
  }
  s(mj, "ObjectMethod");
  function yj(e) {
    if (this.printJoin(e.decorators, e), e.computed)
      this.tokenChar(91), this.print(e.key, e), this.tokenChar(93);
    else {
      if (cj(e.value) && kl(e.key) && e.key.name === e.value.left.name) {
        this.print(e.value, e);
        return;
      }
      if (this.print(e.key, e), e.shorthand && kl(e.key) && kl(e.value) && e.key.name === e.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(e.value, e);
  }
  s(yj, "ObjectProperty");
  function Tj(e) {
    let t = e.elements, r = t.length;
    this.tokenChar(91);
    for (let i = 0; i < t.length; i++) {
      let n = t[i];
      n ? (i > 0 && this.space(), this.print(n, e), i < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }
  s(Tj, "ArrayExpression");
  function gj(e) {
    let t = e.properties, r, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", i = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", i = "}";
    }
    this.token(r), t.length && (this.space(), this.printList(t, e, {
      indent: !0,
      statement: !0
    }), this.space()), this.token(i);
  }
  s(gj, "RecordExpression");
  function bj(e) {
    let t = e.elements, r = t.length, i, n;
    if (this.format.recordAndTupleSyntaxType === "bar")
      i = "[|", n = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      i = "#[", n = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(i);
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      o && (a > 0 && this.space(), this.print(o, e), a < r - 1 && this.tokenChar(44));
    }
    this.token(n);
  }
  s(bj, "TupleExpression");
  function Sj(e) {
    this.word(`/${e.pattern}/${e.flags}`);
  }
  s(Sj, "RegExpLiteral");
  function xj(e) {
    this.word(e.value ? "true" : "false");
  }
  s(xj, "BooleanLiteral");
  function Ej() {
    this.word("null");
  }
  s(Ej, "NullLiteral");
  function Pj(e) {
    let t = this.getPossibleRaw(e), r = this.format.jsescOption, i = e.value, n = i + "";
    r.numbers ? this.number(sd(i, r), i) : t == null ? this.number(n, i) : this.format.minified ? this.number(t.length < n.length ? t : n, i) :
    this.number(t, i);
  }
  s(Pj, "NumericLiteral");
  function Aj(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let r = sd(e.value, this.format.jsescOption);
    this.token(r);
  }
  s(Aj, "StringLiteral");
  function vj(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "n");
  }
  s(vj, "BigIntLiteral");
  function Cj(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "m");
  }
  s(Cj, "DecimalLiteral");
  var id = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function Ij() {
    let {
      topicToken: e
    } = this.format;
    if (id.has(e))
      this.token(e);
    else {
      let t = JSON.stringify(e), r = Array.from(id, (i) => JSON.stringify(i));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
    }
  }
  s(Ij, "TopicReference");
  function wj(e) {
    this.print(e.expression, e);
  }
  s(wj, "PipelineTopicExpression");
  function Oj(e) {
    this.print(e.callee, e);
  }
  s(Oj, "PipelineBareFunction");
  function Nj() {
    this.tokenChar(35);
  }
  s(Nj, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var ad = v((X) => {
  "use strict";
  Object.defineProperty(X, "__esModule", {
    value: !0
  });
  X.AnyTypeAnnotation = Lj;
  X.ArrayTypeAnnotation = Mj;
  X.BooleanLiteralTypeAnnotation = Bj;
  X.BooleanTypeAnnotation = Fj;
  X.DeclareClass = Rj;
  X.DeclareExportAllDeclaration = Gj;
  X.DeclareExportDeclaration = Hj;
  X.DeclareFunction = qj;
  X.DeclareInterface = Kj;
  X.DeclareModule = Wj;
  X.DeclareModuleExports = Yj;
  X.DeclareOpaqueType = Jj;
  X.DeclareTypeAlias = Xj;
  X.DeclareVariable = $j;
  X.DeclaredPredicate = Uj;
  X.EmptyTypeAnnotation = gR;
  X.EnumBooleanBody = Qj;
  X.EnumBooleanMember = iR;
  X.EnumDeclaration = zj;
  X.EnumDefaultedMember = rR;
  X.EnumNumberBody = Zj;
  X.EnumNumberMember = sR;
  X.EnumStringBody = eR;
  X.EnumStringMember = nR;
  X.EnumSymbolBody = tR;
  X.ExistsTypeAnnotation = oR;
  X.FunctionTypeAnnotation = lR;
  X.FunctionTypeParam = uR;
  X.IndexedAccessType = KR;
  X.InferredPredicate = Vj;
  X.InterfaceDeclaration = hR;
  X.GenericTypeAnnotation = X.ClassImplements = X.InterfaceExtends = cR;
  X.InterfaceTypeAnnotation = mR;
  X.IntersectionTypeAnnotation = yR;
  X.MixedTypeAnnotation = TR;
  X.NullLiteralTypeAnnotation = jj;
  X.NullableTypeAnnotation = bR;
  Object.defineProperty(X, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nd.NumericLiteral;
    }, "get")
  });
  X.NumberTypeAnnotation = SR;
  X.ObjectTypeAnnotation = NR;
  X.ObjectTypeCallProperty = DR;
  X.ObjectTypeIndexer = kR;
  X.ObjectTypeInternalSlot = _R;
  X.ObjectTypeProperty = LR;
  X.ObjectTypeSpreadProperty = MR;
  X.OpaqueType = OR;
  X.OptionalIndexedAccessType = WR;
  X.QualifiedTypeIdentifier = FR;
  Object.defineProperty(X, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nd.StringLiteral;
    }, "get")
  });
  X.StringTypeAnnotation = xR;
  X.SymbolTypeAnnotation = BR;
  X.ThisTypeAnnotation = ER;
  X.TupleTypeAnnotation = PR;
  X.TypeAlias = vR;
  X.TypeAnnotation = CR;
  X.TypeCastExpression = qR;
  X.TypeParameter = wR;
  X.TypeParameterDeclaration = X.TypeParameterInstantiation = IR;
  X.TypeofTypeAnnotation = AR;
  X.UnionTypeAnnotation = RR;
  X.Variance = VR;
  X.VoidTypeAnnotation = UR;
  X._interfaceish = pR;
  X._variance = fR;
  var _j = le(), Dj = Dl(), nd = Ll(), {
    isDeclareExportDeclaration: yn,
    isStatement: kj
  } = _j;
  function Lj() {
    this.word("any");
  }
  s(Lj, "AnyTypeAnnotation");
  function Mj(e) {
    this.print(e.elementType, e, !0), this.tokenChar(91), this.tokenChar(93);
  }
  s(Mj, "ArrayTypeAnnotation");
  function Fj() {
    this.word("boolean");
  }
  s(Fj, "BooleanTypeAnnotation");
  function Bj(e) {
    this.word(e.value ? "true" : "false");
  }
  s(Bj, "BooleanLiteralTypeAnnotation");
  function jj() {
    this.word("null");
  }
  s(jj, "NullLiteralTypeAnnotation");
  function Rj(e, t) {
    yn(t) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e);
  }
  s(Rj, "DeclareClass");
  function qj(e, t) {
    yn(t) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e.id, e), this.print(e.id.typeAnnotation.
    typeAnnotation, e), e.predicate && (this.space(), this.print(e.predicate, e)), this.semicolon();
  }
  s(qj, "DeclareFunction");
  function Vj() {
    this.tokenChar(37), this.word("checks");
  }
  s(Vj, "InferredPredicate");
  function Uj(e) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e.value, e), this.tokenChar(41);
  }
  s(Uj, "DeclaredPredicate");
  function Kj(e) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(e);
  }
  s(Kj, "DeclareInterface");
  function Wj(e) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e.id, e), this.space(), this.print(e.body, e);
  }
  s(Wj, "DeclareModule");
  function Yj(e) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e.typeAnnotation, e);
  }
  s(Yj, "DeclareModuleExports");
  function Xj(e) {
    this.word("declare"), this.space(), this.TypeAlias(e);
  }
  s(Xj, "DeclareTypeAlias");
  function Jj(e, t) {
    yn(t) || (this.word("declare"), this.space()), this.OpaqueType(e);
  }
  s(Jj, "DeclareOpaqueType");
  function $j(e, t) {
    yn(t) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e.id, e), this.print(e.id.typeAnnotation, e), this.
    semicolon();
  }
  s($j, "DeclareVariable");
  function Hj(e) {
    this.word("declare"), this.space(), this.word("export"), this.space(), e.default && (this.word("default"), this.space()), aR.call(this, e);
  }
  s(Hj, "DeclareExportDeclaration");
  function Gj(e) {
    this.word("declare"), this.space(), Dj.ExportAllDeclaration.call(this, e);
  }
  s(Gj, "DeclareExportAllDeclaration");
  function zj(e) {
    let {
      id: t,
      body: r
    } = e;
    this.word("enum"), this.space(), this.print(t, e), this.print(r, e);
  }
  s(zj, "EnumDeclaration");
  function Tn(e, t, r) {
    r && (e.space(), e.word("of"), e.space(), e.word(t)), e.space();
  }
  s(Tn, "enumExplicitType");
  function gn(e, t) {
    let {
      members: r
    } = t;
    e.token("{"), e.indent(), e.newline();
    for (let i of r)
      e.print(i, t), e.newline();
    t.hasUnknownMembers && (e.token("..."), e.newline()), e.dedent(), e.token("}");
  }
  s(gn, "enumBody");
  function Qj(e) {
    let {
      explicitType: t
    } = e;
    Tn(this, "boolean", t), gn(this, e);
  }
  s(Qj, "EnumBooleanBody");
  function Zj(e) {
    let {
      explicitType: t
    } = e;
    Tn(this, "number", t), gn(this, e);
  }
  s(Zj, "EnumNumberBody");
  function eR(e) {
    let {
      explicitType: t
    } = e;
    Tn(this, "string", t), gn(this, e);
  }
  s(eR, "EnumStringBody");
  function tR(e) {
    Tn(this, "symbol", !0), gn(this, e);
  }
  s(tR, "EnumSymbolBody");
  function rR(e) {
    let {
      id: t
    } = e;
    this.print(t, e), this.tokenChar(44);
  }
  s(rR, "EnumDefaultedMember");
  function Ml(e, t) {
    let {
      id: r,
      init: i
    } = t;
    e.print(r, t), e.space(), e.token("="), e.space(), e.print(i, t), e.token(",");
  }
  s(Ml, "enumInitializedMember");
  function iR(e) {
    Ml(this, e);
  }
  s(iR, "EnumBooleanMember");
  function sR(e) {
    Ml(this, e);
  }
  s(sR, "EnumNumberMember");
  function nR(e) {
    Ml(this, e);
  }
  s(nR, "EnumStringMember");
  function aR(e) {
    if (e.declaration) {
      let t = e.declaration;
      this.print(t, e), kj(t) || this.semicolon();
    } else
      this.tokenChar(123), e.specifiers.length && (this.space(), this.printList(e.specifiers, e), this.space()), this.tokenChar(125), e.source &&
      (this.space(), this.word("from"), this.space(), this.print(e.source, e)), this.semicolon();
  }
  s(aR, "FlowExportDeclaration");
  function oR() {
    this.tokenChar(42);
  }
  s(oR, "ExistsTypeAnnotation");
  function lR(e, t) {
    this.print(e.typeParameters, e), this.tokenChar(40), e.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e.this.typeAnnotation,
    e), (e.params.length || e.rest) && (this.tokenChar(44), this.space())), this.printList(e.params, e), e.rest && (e.params.length && (this.
    tokenChar(44), this.space()), this.token("..."), this.print(e.rest, e)), this.tokenChar(41);
    let r = t?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    t.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e.returnType, e);
  }
  s(lR, "FunctionTypeAnnotation");
  function uR(e) {
    this.print(e.name, e), e.optional && this.tokenChar(63), e.name && (this.tokenChar(58), this.space()), this.print(e.typeAnnotation, e);
  }
  s(uR, "FunctionTypeParam");
  function cR(e) {
    this.print(e.id, e), this.print(e.typeParameters, e, !0);
  }
  s(cR, "InterfaceExtends");
  function pR(e) {
    var t;
    if (this.print(e.id, e), this.print(e.typeParameters, e), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.
    space(), this.printList(e.extends, e)), e.type === "DeclareClass") {
      var r, i;
      (r = e.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(e.mixins, e)), (i = e.implements) !=
      null && i.length && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e));
    }
    this.space(), this.print(e.body, e);
  }
  s(pR, "_interfaceish");
  function fR(e) {
    var t;
    let r = (t = e.variance) == null ? void 0 : t.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  s(fR, "_variance");
  function hR(e) {
    this.word("interface"), this.space(), this._interfaceish(e);
  }
  s(hR, "InterfaceDeclaration");
  function dR() {
    this.space(), this.tokenChar(38), this.space();
  }
  s(dR, "andSeparator");
  function mR(e) {
    var t;
    this.word("interface"), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e.extends,
    e)), this.space(), this.print(e.body, e);
  }
  s(mR, "InterfaceTypeAnnotation");
  function yR(e) {
    this.printJoin(e.types, e, {
      separator: dR
    });
  }
  s(yR, "IntersectionTypeAnnotation");
  function TR() {
    this.word("mixed");
  }
  s(TR, "MixedTypeAnnotation");
  function gR() {
    this.word("empty");
  }
  s(gR, "EmptyTypeAnnotation");
  function bR(e) {
    this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(bR, "NullableTypeAnnotation");
  function SR() {
    this.word("number");
  }
  s(SR, "NumberTypeAnnotation");
  function xR() {
    this.word("string");
  }
  s(xR, "StringTypeAnnotation");
  function ER() {
    this.word("this");
  }
  s(ER, "ThisTypeAnnotation");
  function PR(e) {
    this.tokenChar(91), this.printList(e.types, e), this.tokenChar(93);
  }
  s(PR, "TupleTypeAnnotation");
  function AR(e) {
    this.word("typeof"), this.space(), this.print(e.argument, e);
  }
  s(AR, "TypeofTypeAnnotation");
  function vR(e) {
    this.word("type"), this.space(), this.print(e.id, e), this.print(e.typeParameters, e), this.space(), this.tokenChar(61), this.space(), this.
    print(e.right, e), this.semicolon();
  }
  s(vR, "TypeAlias");
  function CR(e) {
    this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(CR, "TypeAnnotation");
  function IR(e) {
    this.tokenChar(60), this.printList(e.params, e, {}), this.tokenChar(62);
  }
  s(IR, "TypeParameterInstantiation");
  function wR(e) {
    this._variance(e), this.word(e.name), e.bound && this.print(e.bound, e), e.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(e.default, e));
  }
  s(wR, "TypeParameter");
  function OR(e) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e.id, e), this.print(e.typeParameters, e), e.supertype &&
    (this.tokenChar(58), this.space(), this.print(e.supertype, e)), e.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(
    e.impltype, e)), this.semicolon();
  }
  s(OR, "OpaqueType");
  function NR(e) {
    e.exact ? this.token("{|") : this.tokenChar(123);
    let t = [...e.properties, ...e.callProperties || [], ...e.indexers || [], ...e.internalSlots || []];
    t.length && (this.newline(), this.space(), this.printJoin(t, e, {
      addNewlines(r) {
        if (r && !t[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: /* @__PURE__ */ s(() => {
        (t.length !== 1 || e.inexact) && (this.tokenChar(44), this.space());
      }, "iterator")
    }), this.space()), e.inexact && (this.indent(), this.token("..."), t.length && this.newline(), this.dedent()), e.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  s(NR, "ObjectTypeAnnotation");
  function _R(e) {
    e.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e.id, e), this.tokenChar(93), this.tokenChar(
    93), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58), this.space()), this.print(e.value, e);
  }
  s(_R, "ObjectTypeInternalSlot");
  function DR(e) {
    e.static && (this.word("static"), this.space()), this.print(e.value, e);
  }
  s(DR, "ObjectTypeCallProperty");
  function kR(e) {
    e.static && (this.word("static"), this.space()), this._variance(e), this.tokenChar(91), e.id && (this.print(e.id, e), this.tokenChar(58),
    this.space()), this.print(e.key, e), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e.value, e);
  }
  s(kR, "ObjectTypeIndexer");
  function LR(e) {
    e.proto && (this.word("proto"), this.space()), e.static && (this.word("static"), this.space()), (e.kind === "get" || e.kind === "set") &&
    (this.word(e.kind), this.space()), this._variance(e), this.print(e.key, e), e.optional && this.tokenChar(63), e.method || (this.tokenChar(
    58), this.space()), this.print(e.value, e);
  }
  s(LR, "ObjectTypeProperty");
  function MR(e) {
    this.token("..."), this.print(e.argument, e);
  }
  s(MR, "ObjectTypeSpreadProperty");
  function FR(e) {
    this.print(e.qualification, e), this.tokenChar(46), this.print(e.id, e);
  }
  s(FR, "QualifiedTypeIdentifier");
  function BR() {
    this.word("symbol");
  }
  s(BR, "SymbolTypeAnnotation");
  function jR() {
    this.space(), this.tokenChar(124), this.space();
  }
  s(jR, "orSeparator");
  function RR(e) {
    this.printJoin(e.types, e, {
      separator: jR
    });
  }
  s(RR, "UnionTypeAnnotation");
  function qR(e) {
    this.tokenChar(40), this.print(e.expression, e), this.print(e.typeAnnotation, e), this.tokenChar(41);
  }
  s(qR, "TypeCastExpression");
  function VR(e) {
    e.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  s(VR, "Variance");
  function UR() {
    this.word("void");
  }
  s(UR, "VoidTypeAnnotation");
  function KR(e) {
    this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  s(KR, "IndexedAccessType");
  function WR(e) {
    this.print(e.objectType, e), e.optional && this.token("?."), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  s(WR, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var od = v((Xt) => {
  "use strict";
  Object.defineProperty(Xt, "__esModule", {
    value: !0
  });
  Xt.BlockStatement = JR;
  Xt.Directive = $R;
  Xt.DirectiveLiteral = zR;
  Xt.File = YR;
  Xt.InterpreterDirective = QR;
  Xt.Placeholder = ZR;
  Xt.Program = XR;
  function YR(e) {
    e.program && this.print(e.program.interpreter, e), this.print(e.program, e);
  }
  s(YR, "File");
  function XR(e) {
    var t;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var i;
      let n = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, {
        trailingCommentsLineOffset: n
      }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(n);
    }
    this.printSequence(e.body, e);
  }
  s(XR, "Program");
  function JR(e) {
    var t;
    this.tokenChar(123);
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var i;
      let n = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, {
        indent: !0,
        trailingCommentsLineOffset: n
      }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(n);
    }
    this.printSequence(e.body, e, {
      indent: !0
    }), this.rightBrace(e);
  }
  s(JR, "BlockStatement");
  function $R(e) {
    this.print(e.value, e), this.semicolon();
  }
  s($R, "Directive");
  var HR = /(?:^|[^\\])(?:\\\\)*'/, GR = /(?:^|[^\\])(?:\\\\)*"/;
  function zR(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let {
      value: r
    } = e;
    if (!GR.test(r))
      this.token(`"${r}"`);
    else if (!HR.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  s(zR, "DirectiveLiteral");
  function QR(e) {
    this.token(`#!${e.value}`), this.newline(1, !0);
  }
  s(QR, "InterpreterDirective");
  function ZR(e) {
    this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
  }
  s(ZR, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var ld = v((Ze) => {
  "use strict";
  Object.defineProperty(Ze, "__esModule", {
    value: !0
  });
  Ze.JSXAttribute = e5;
  Ze.JSXClosingElement = p5;
  Ze.JSXClosingFragment = m5;
  Ze.JSXElement = l5;
  Ze.JSXEmptyExpression = f5;
  Ze.JSXExpressionContainer = n5;
  Ze.JSXFragment = h5;
  Ze.JSXIdentifier = t5;
  Ze.JSXMemberExpression = i5;
  Ze.JSXNamespacedName = r5;
  Ze.JSXOpeningElement = c5;
  Ze.JSXOpeningFragment = d5;
  Ze.JSXSpreadAttribute = s5;
  Ze.JSXSpreadChild = a5;
  Ze.JSXText = o5;
  function e5(e) {
    this.print(e.name, e), e.value && (this.tokenChar(61), this.print(e.value, e));
  }
  s(e5, "JSXAttribute");
  function t5(e) {
    this.word(e.name);
  }
  s(t5, "JSXIdentifier");
  function r5(e) {
    this.print(e.namespace, e), this.tokenChar(58), this.print(e.name, e);
  }
  s(r5, "JSXNamespacedName");
  function i5(e) {
    this.print(e.object, e), this.tokenChar(46), this.print(e.property, e);
  }
  s(i5, "JSXMemberExpression");
  function s5(e) {
    this.tokenChar(123), this.token("..."), this.print(e.argument, e), this.tokenChar(125);
  }
  s(s5, "JSXSpreadAttribute");
  function n5(e) {
    this.tokenChar(123), this.print(e.expression, e), this.tokenChar(125);
  }
  s(n5, "JSXExpressionContainer");
  function a5(e) {
    this.tokenChar(123), this.token("..."), this.print(e.expression, e), this.tokenChar(125);
  }
  s(a5, "JSXSpreadChild");
  function o5(e) {
    let t = this.getPossibleRaw(e);
    t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
  }
  s(o5, "JSXText");
  function l5(e) {
    let t = e.openingElement;
    if (this.print(t, e), !t.selfClosing) {
      this.indent();
      for (let r of e.children)
        this.print(r, e);
      this.dedent(), this.print(e.closingElement, e);
    }
  }
  s(l5, "JSXElement");
  function u5() {
    this.space();
  }
  s(u5, "spaceSeparator");
  function c5(e) {
    this.tokenChar(60), this.print(e.name, e), this.print(e.typeParameters, e), e.attributes.length > 0 && (this.space(), this.printJoin(e.attributes,
    e, {
      separator: u5
    })), e.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }
  s(c5, "JSXOpeningElement");
  function p5(e) {
    this.token("</"), this.print(e.name, e), this.tokenChar(62);
  }
  s(p5, "JSXClosingElement");
  function f5() {
    this.printInnerComments();
  }
  s(f5, "JSXEmptyExpression");
  function h5(e) {
    this.print(e.openingFragment, e), this.indent();
    for (let t of e.children)
      this.print(t, e);
    this.dedent(), this.print(e.closingFragment, e);
  }
  s(h5, "JSXFragment");
  function d5() {
    this.tokenChar(60), this.tokenChar(62);
  }
  s(d5, "JSXOpeningFragment");
  function m5() {
    this.token("</"), this.tokenChar(62);
  }
  s(m5, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var pd = v((Y) => {
  "use strict";
  Object.defineProperty(Y, "__esModule", {
    value: !0
  });
  Y.TSAnyKeyword = O5;
  Y.TSArrayType = z5;
  Y.TSSatisfiesExpression = Y.TSAsExpression = m4;
  Y.TSBigIntKeyword = N5;
  Y.TSBooleanKeyword = L5;
  Y.TSCallSignatureDeclaration = P5;
  Y.TSConditionalType = s4;
  Y.TSConstructSignatureDeclaration = A5;
  Y.TSConstructorType = W5;
  Y.TSDeclareFunction = S5;
  Y.TSDeclareMethod = x5;
  Y.TSEnumDeclaration = g4;
  Y.TSEnumMember = b4;
  Y.TSExportAssignment = C4;
  Y.TSExpressionWithTypeArguments = p4;
  Y.TSExternalModuleReference = A4;
  Y.TSFunctionType = K5;
  Y.TSImportEqualsDeclaration = P4;
  Y.TSImportType = E4;
  Y.TSIndexSignature = w5;
  Y.TSIndexedAccessType = l4;
  Y.TSInferType = n4;
  Y.TSInstantiationExpression = T4;
  Y.TSInterfaceBody = h4;
  Y.TSInterfaceDeclaration = f4;
  Y.TSIntersectionType = i4;
  Y.TSIntrinsicKeyword = V5;
  Y.TSLiteralType = c4;
  Y.TSMappedType = u4;
  Y.TSMethodSignature = I5;
  Y.TSModuleBlock = x4;
  Y.TSModuleDeclaration = S4;
  Y.TSNamedTupleMember = t4;
  Y.TSNamespaceExportDeclaration = I4;
  Y.TSNeverKeyword = q5;
  Y.TSNonNullExpression = v4;
  Y.TSNullKeyword = R5;
  Y.TSNumberKeyword = D5;
  Y.TSObjectKeyword = k5;
  Y.TSOptionalType = Z5;
  Y.TSParameterProperty = b5;
  Y.TSParenthesizedType = a4;
  Y.TSPropertySignature = v5;
  Y.TSQualifiedName = E5;
  Y.TSRestType = e4;
  Y.TSStringKeyword = M5;
  Y.TSSymbolKeyword = F5;
  Y.TSThisType = U5;
  Y.TSTupleType = Q5;
  Y.TSTypeAliasDeclaration = d4;
  Y.TSTypeAnnotation = y5;
  Y.TSTypeAssertion = y4;
  Y.TSTypeLiteral = H5;
  Y.TSTypeOperator = o4;
  Y.TSTypeParameter = g5;
  Y.TSTypeParameterDeclaration = Y.TSTypeParameterInstantiation = T5;
  Y.TSTypePredicate = J5;
  Y.TSTypeQuery = $5;
  Y.TSTypeReference = X5;
  Y.TSUndefinedKeyword = j5;
  Y.TSUnionType = r4;
  Y.TSUnknownKeyword = _5;
  Y.TSVoidKeyword = B5;
  Y.tsPrintClassMemberModifiers = O4;
  Y.tsPrintFunctionOrConstructorType = Y5;
  Y.tsPrintPropertyOrMethodName = C5;
  Y.tsPrintSignatureDeclarationBase = w4;
  Y.tsPrintTypeLiteralOrInterfaceBody = G5;
  function y5(e) {
    this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(y5, "TSTypeAnnotation");
  function T5(e, t) {
    this.tokenChar(60), this.printList(e.params, e, {}), t.type === "ArrowFunctionExpression" && e.params.length === 1 && this.tokenChar(44),
    this.tokenChar(62);
  }
  s(T5, "TSTypeParameterInstantiation");
  function g5(e) {
    e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(e.constraint, e)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.
    default, e));
  }
  s(g5, "TSTypeParameter");
  function b5(e) {
    e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
  }
  s(b5, "TSParameterProperty");
  function S5(e, t) {
    e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.tokenChar(59);
  }
  s(S5, "TSDeclareFunction");
  function x5(e) {
    this._classMethodHead(e), this.tokenChar(59);
  }
  s(x5, "TSDeclareMethod");
  function E5(e) {
    this.print(e.left, e), this.tokenChar(46), this.print(e.right, e);
  }
  s(E5, "TSQualifiedName");
  function P5(e) {
    this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
  }
  s(P5, "TSCallSignatureDeclaration");
  function A5(e) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
  }
  s(A5, "TSConstructSignatureDeclaration");
  function v5(e) {
    let {
      readonly: t
    } = e;
    t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation, e), this.tokenChar(59);
  }
  s(v5, "TSPropertySignature");
  function C5(e) {
    e.computed && this.tokenChar(91), this.print(e.key, e), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
  }
  s(C5, "tsPrintPropertyOrMethodName");
  function I5(e) {
    let {
      kind: t
    } = e;
    (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(
    e), this.tokenChar(59);
  }
  s(I5, "TSMethodSignature");
  function w5(e) {
    let {
      readonly: t,
      static: r
    } = e;
    r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters,
    e), this.tokenChar(93), this.print(e.typeAnnotation, e), this.tokenChar(59);
  }
  s(w5, "TSIndexSignature");
  function O5() {
    this.word("any");
  }
  s(O5, "TSAnyKeyword");
  function N5() {
    this.word("bigint");
  }
  s(N5, "TSBigIntKeyword");
  function _5() {
    this.word("unknown");
  }
  s(_5, "TSUnknownKeyword");
  function D5() {
    this.word("number");
  }
  s(D5, "TSNumberKeyword");
  function k5() {
    this.word("object");
  }
  s(k5, "TSObjectKeyword");
  function L5() {
    this.word("boolean");
  }
  s(L5, "TSBooleanKeyword");
  function M5() {
    this.word("string");
  }
  s(M5, "TSStringKeyword");
  function F5() {
    this.word("symbol");
  }
  s(F5, "TSSymbolKeyword");
  function B5() {
    this.word("void");
  }
  s(B5, "TSVoidKeyword");
  function j5() {
    this.word("undefined");
  }
  s(j5, "TSUndefinedKeyword");
  function R5() {
    this.word("null");
  }
  s(R5, "TSNullKeyword");
  function q5() {
    this.word("never");
  }
  s(q5, "TSNeverKeyword");
  function V5() {
    this.word("intrinsic");
  }
  s(V5, "TSIntrinsicKeyword");
  function U5() {
    this.word("this");
  }
  s(U5, "TSThisType");
  function K5(e) {
    this.tsPrintFunctionOrConstructorType(e);
  }
  s(K5, "TSFunctionType");
  function W5(e) {
    e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
  }
  s(W5, "TSConstructorType");
  function Y5(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    let i = e.typeAnnotation;
    this.print(i.typeAnnotation, e);
  }
  s(Y5, "tsPrintFunctionOrConstructorType");
  function X5(e) {
    this.print(e.typeName, e, !0), this.print(e.typeParameters, e, !0);
  }
  s(X5, "TSTypeReference");
  function J5(e) {
    e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(e.typeAnnotation.typeAnnotation));
  }
  s(J5, "TSTypePredicate");
  function $5(e) {
    this.word("typeof"), this.space(), this.print(e.exprName), e.typeParameters && this.print(e.typeParameters, e);
  }
  s($5, "TSTypeQuery");
  function H5(e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
  }
  s(H5, "TSTypeLiteral");
  function G5(e, t) {
    Fl(this, e, t);
  }
  s(G5, "tsPrintTypeLiteralOrInterfaceBody");
  function Fl(e, t, r) {
    if (e.token("{"), t.length) {
      e.indent(), e.newline();
      for (let i of t)
        e.print(i, r), e.newline();
      e.dedent();
    }
    e.rightBrace(r);
  }
  s(Fl, "tsPrintBraced");
  function z5(e) {
    this.print(e.elementType, e, !0), this.token("[]");
  }
  s(z5, "TSArrayType");
  function Q5(e) {
    this.tokenChar(91), this.printList(e.elementTypes, e), this.tokenChar(93);
  }
  s(Q5, "TSTupleType");
  function Z5(e) {
    this.print(e.typeAnnotation, e), this.tokenChar(63);
  }
  s(Z5, "TSOptionalType");
  function e4(e) {
    this.token("..."), this.print(e.typeAnnotation, e);
  }
  s(e4, "TSRestType");
  function t4(e) {
    this.print(e.label, e), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType, e);
  }
  s(t4, "TSNamedTupleMember");
  function r4(e) {
    cd(this, e, "|");
  }
  s(r4, "TSUnionType");
  function i4(e) {
    cd(this, e, "&");
  }
  s(i4, "TSIntersectionType");
  function cd(e, t, r) {
    e.printJoin(t.types, t, {
      separator() {
        this.space(), this.token(r), this.space();
      }
    });
  }
  s(cd, "tsPrintUnionOrIntersectionType");
  function s4(e) {
    this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
  }
  s(s4, "TSConditionalType");
  function n4(e) {
    this.token("infer"), this.space(), this.print(e.typeParameter);
  }
  s(n4, "TSInferType");
  function a4(e) {
    this.tokenChar(40), this.print(e.typeAnnotation, e), this.tokenChar(41);
  }
  s(a4, "TSParenthesizedType");
  function o4(e) {
    this.word(e.operator), this.space(), this.print(e.typeAnnotation, e);
  }
  s(o4, "TSTypeOperator");
  function l4(e) {
    this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  s(l4, "TSIndexedAccessType");
  function u4(e) {
    let {
      nameType: t,
      optional: r,
      readonly: i,
      typeParameter: n,
      typeAnnotation: a
    } = e;
    this.tokenChar(123), this.space(), i && (ud(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(n.name), this.
    space(), this.word("in"), this.space(), this.print(n.constraint, n), t && (this.space(), this.word("as"), this.space(), this.print(t, e)),
    this.tokenChar(93), r && (ud(this, r), this.tokenChar(63)), a && (this.tokenChar(58), this.space(), this.print(a, e)), this.space(), this.
    tokenChar(125);
  }
  s(u4, "TSMappedType");
  function ud(e, t) {
    t !== !0 && e.token(t);
  }
  s(ud, "tokenIfPlusMinus");
  function c4(e) {
    this.print(e.literal, e);
  }
  s(c4, "TSLiteralType");
  function p4(e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }
  s(p4, "TSExpressionWithTypeArguments");
  function f4(e) {
    let {
      declare: t,
      id: r,
      typeParameters: i,
      extends: n,
      body: a
    } = e;
    t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, e), this.print(i, e), n != null && n.length &&
    (this.space(), this.word("extends"), this.space(), this.printList(n, e)), this.space(), this.print(a, e);
  }
  s(f4, "TSInterfaceDeclaration");
  function h4(e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
  }
  s(h4, "TSInterfaceBody");
  function d4(e) {
    let {
      declare: t,
      id: r,
      typeParameters: i,
      typeAnnotation: n
    } = e;
    t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, e), this.print(i, e), this.space(), this.tokenChar(
    61), this.space(), this.print(n, e), this.tokenChar(59);
  }
  s(d4, "TSTypeAliasDeclaration");
  function m4(e) {
    var t;
    let {
      type: r,
      expression: i,
      typeAnnotation: n
    } = e, a = !!((t = i.trailingComments) != null && t.length);
    this.print(i, e, !0, void 0, a), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(n, e);
  }
  s(m4, "TSTypeExpression");
  function y4(e) {
    let {
      typeAnnotation: t,
      expression: r
    } = e;
    this.tokenChar(60), this.print(t, e), this.tokenChar(62), this.space(), this.print(r, e);
  }
  s(y4, "TSTypeAssertion");
  function T4(e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }
  s(T4, "TSInstantiationExpression");
  function g4(e) {
    let {
      declare: t,
      const: r,
      id: i,
      members: n
    } = e;
    t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i, e), this.
    space(), Fl(this, n, e);
  }
  s(g4, "TSEnumDeclaration");
  function b4(e) {
    let {
      id: t,
      initializer: r
    } = e;
    this.print(t, e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e)), this.tokenChar(44);
  }
  s(b4, "TSEnumMember");
  function S4(e) {
    let {
      declare: t,
      id: r
    } = e;
    if (t && (this.word("declare"), this.space()), e.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.
    print(r, e), !e.body) {
      this.tokenChar(59);
      return;
    }
    let i = e.body;
    for (; i.type === "TSModuleDeclaration"; )
      this.tokenChar(46), this.print(i.id, i), i = i.body;
    this.space(), this.print(i, e);
  }
  s(S4, "TSModuleDeclaration");
  function x4(e) {
    Fl(this, e.body, e);
  }
  s(x4, "TSModuleBlock");
  function E4(e) {
    let {
      argument: t,
      qualifier: r,
      typeParameters: i
    } = e;
    this.word("import"), this.tokenChar(40), this.print(t, e), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, e)), i && this.print(
    i, e);
  }
  s(E4, "TSImportType");
  function P4(e) {
    let {
      isExport: t,
      id: r,
      moduleReference: i
    } = e;
    t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, e), this.space(), this.tokenChar(61), this.space(),
    this.print(i, e), this.tokenChar(59);
  }
  s(P4, "TSImportEqualsDeclaration");
  function A4(e) {
    this.token("require("), this.print(e.expression, e), this.tokenChar(41);
  }
  s(A4, "TSExternalModuleReference");
  function v4(e) {
    this.print(e.expression, e), this.tokenChar(33);
  }
  s(v4, "TSNonNullExpression");
  function C4(e) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression, e), this.tokenChar(59);
  }
  s(C4, "TSExportAssignment");
  function I4(e) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id, e);
  }
  s(I4, "TSNamespaceExportDeclaration");
  function w4(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41);
    let i = e.typeAnnotation;
    this.print(i, e);
  }
  s(w4, "tsPrintSignatureDeclarationBase");
  function O4(e) {
    let t = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
    t && e.declare && (this.word("declare"), this.space()), e.accessibility && (this.word(e.accessibility), this.space()), e.static && (this.
    word("static"), this.space()), e.override && (this.word("override"), this.space()), e.abstract && (this.word("abstract"), this.space()),
    t && e.readonly && (this.word("readonly"), this.space());
  }
  s(O4, "tsPrintClassMemberModifiers");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var fd = v((ye) => {
  "use strict";
  Object.defineProperty(ye, "__esModule", {
    value: !0
  });
  var Bl = qh();
  Object.keys(Bl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Bl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Bl[e];
      }, "get")
    });
  });
  var jl = Kh();
  Object.keys(jl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === jl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return jl[e];
      }, "get")
    });
  });
  var Rl = Jh();
  Object.keys(Rl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Rl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Rl[e];
      }, "get")
    });
  });
  var ql = $h();
  Object.keys(ql).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === ql[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ql[e];
      }, "get")
    });
  });
  var Vl = Hh();
  Object.keys(Vl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Vl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Vl[e];
      }, "get")
    });
  });
  var Ul = Dl();
  Object.keys(Ul).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Ul[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ul[e];
      }, "get")
    });
  });
  var Kl = Ll();
  Object.keys(Kl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Kl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Kl[e];
      }, "get")
    });
  });
  var Wl = ad();
  Object.keys(Wl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Wl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Wl[e];
      }, "get")
    });
  });
  var Yl = od();
  Object.keys(Yl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Yl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Yl[e];
      }, "get")
    });
  });
  var Xl = ld();
  Object.keys(Xl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Xl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Xl[e];
      }, "get")
    });
  });
  var Jl = pd();
  Object.keys(Jl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Jl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Jl[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/printer.js
var dd = v((bn) => {
  "use strict";
  Object.defineProperty(bn, "__esModule", {
    value: !0
  });
  bn.default = void 0;
  var N4 = Ih(), _4 = Nl(), D4 = le(), k4 = fd(), {
    isFunction: L4,
    isStatement: M4,
    isClassBody: F4,
    isTSInterfaceBody: B4,
    isTSEnumDeclaration: j4
  } = D4, R4 = /e/i, q4 = /\.0+$/, hd = /[\n\r\u2028\u2029]/, V4 = /[\n\r\u2028\u2029]|\*\//, {
    needsParens: U4
  } = _4, Qi = class {
    static {
      s(this, "Printer");
    }
    constructor(t, r) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState =
      null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger =
      !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = t, this.
      _indentRepeat = t.indent.style.length, this._inputMap = r?._inputMap, this._buf = new N4.default(r, t.indent.style[0]);
    }
    generate(t) {
      return this.print(t), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(t = !1) {
      this._maybeAddAuxComment(), t ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(t) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
    }
    rightParens(t) {
      this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
    }
    space(t = !1) {
      if (!this.format.compact) {
        if (t)
          this._space();
        else if (this._buf.hasContent()) {
          let r = this.getLastChar();
          r !== 32 && r !== 10 && this._space();
        }
      }
    }
    word(t, r = !1) {
      this._maybePrintInnerComments(), (this._endsWithWord || t.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(),
      this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(t, r) {
      function i(n) {
        if (n.length > 2 && n.charCodeAt(0) === 48) {
          let a = n.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      s(i, "isNonDecimalLiteral"), this.word(t), this._endsWithInteger = Number.isInteger(r) && !i(t) && !R4.test(t) && !q4.test(t) && t.charCodeAt(
      t.length - 1) !== 46;
    }
    token(t, r = !1) {
      this._maybePrintInnerComments();
      let i = this.getLastChar(), n = t.charCodeAt(0);
      (i === 33 && (t === "--" || n === 61) || n === 43 && i === 43 || n === 45 && i === 45 || n === 46 && this._endsWithInteger) && this._space(),
      this._maybeAddAuxComment(), this._append(t, r), this._noLineTerminator = !1;
    }
    tokenChar(t) {
      this._maybePrintInnerComments();
      let r = this.getLastChar();
      (t === 43 && r === 43 || t === 45 && r === 45 || t === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this.
      _appendChar(t), this._noLineTerminator = !1;
    }
    newline(t = 1, r) {
      if (!(t <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        t > 2 && (t = 2), t -= this._buf.getNewlineCount();
        for (let i = 0; i < t; i++)
          this._newline();
      }
    }
    endsWith(t) {
      return this.getLastChar() === t;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(t, r) {
      if (!t) {
        r();
        return;
      }
      this._catchUp("start", t), this._buf.exactSource(t, r);
    }
    source(t, r) {
      r && (this._catchUp(t, r), this._buf.source(t, r));
    }
    sourceWithOffset(t, r, i) {
      r && (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, i));
    }
    withSource(t, r, i) {
      if (!r) {
        i();
        return;
      }
      this._catchUp(t, r), this._buf.withSource(t, r, i);
    }
    sourceIdentifierName(t, r) {
      if (!this._buf._canMarkIdName) return;
      let i = this._buf._sourcePosition;
      i.identifierNamePos = r, i.identifierName = t;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(t, r) {
      this._maybeAddParen(t), this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _appendChar(t) {
      this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _queue(t) {
      this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(t) {
      this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(t) {
      if (this._indent && t !== 10 && this.endsWith(10))
        return !0;
    }
    _maybeAddParenChar(t) {
      let r = this._parenPushNewlineState;
      if (r && t !== 32) {
        if (t !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40), this.indent(), r.printed = !0;
      }
    }
    _maybeAddParen(t) {
      let r = this._parenPushNewlineState;
      if (!r) return;
      let i = t.length, n;
      for (n = 0; n < i && t.charCodeAt(n) === 32; n++) ;
      if (n === i)
        return;
      let a = t.charCodeAt(n);
      if (a !== 10) {
        if (a !== 47 || n + 1 === i) {
          this._parenPushNewlineState = null;
          return;
        }
        let o = t.charCodeAt(n + 1);
        if (o === 42)
          return;
        if (o !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
    catchUp(t) {
      if (!this.format.retainLines) return;
      let r = t - this._buf.getCurrentLine();
      for (let i = 0; i < r; i++)
        this._newline();
    }
    _catchUp(t, r) {
      var i;
      if (!this.format.retainLines) return;
      let n = r == null || (i = r[t]) == null ? void 0 : i.line;
      if (n != null) {
        let a = n - this._buf.getCurrentLine();
        for (let o = 0; o < a; o++)
          this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(t, r, i) {
      if (i)
        this._noLineTerminator = !0, this.print(t, r);
      else {
        let n = {
          printed: !1
        };
        this._parenPushNewlineState = n, this.print(t, r), n.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(t, r, i, n, a) {
      var o, l;
      if (!t) return;
      this._endsWithInnerRaw = !1;
      let u = t.type, c = this.format, p = c.concise;
      t._compact && (c.concise = !0);
      let g = this[u];
      if (g === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(t.constructor.name)}`);
      this._printStack.push(t);
      let P = this._insideAux;
      this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !P);
      let A = (o = t.extra) == null ? void 0 : o.parenthesized, C = a || A && c.retainFunctionParens && u === "FunctionExpression" || U4(t, r,
      this._printStack);
      if (!C && A && (l = t.leadingComments) != null && l.length && t.leadingComments[0].type === "CommentBlock")
        switch (r?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (r.callee !== t) break;
          default:
            C = !0;
        }
      C && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(t, r);
      let _ = u === "Program" || u === "File" ? null : t.loc;
      this.exactSource(_, g.bind(this, t, r)), C ? (this._printTrailingComments(t, r), this.tokenChar(41), this._noLineTerminator = i) : i &&
      !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(t, r)) : this._printTrailingComments(t, r, n), this.
      _printStack.pop(), c.concise = p, this._insideAux = P, this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(t) {
      t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let t = this.format.auxiliaryCommentBefore;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let t = this.format.auxiliaryCommentAfter;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    getPossibleRaw(t) {
      let r = t.extra;
      if (r?.raw != null && r.rawValue != null && t.value === r.rawValue)
        return r.raw;
    }
    printJoin(t, r, i = {}) {
      if (!(t != null && t.length)) return;
      let {
        indent: n
      } = i;
      if (n == null && this.format.retainLines) {
        var a;
        let g = (a = t[0].loc) == null ? void 0 : a.start.line;
        g != null && g !== this._buf.getCurrentLine() && (n = !0);
      }
      n && this.indent();
      let o = {
        addNewlines: i.addNewlines,
        nextNodeStartLine: 0
      }, l = i.separator ? i.separator.bind(this) : null, u = t.length;
      for (let g = 0; g < u; g++) {
        let P = t[g];
        if (P && (i.statement && this._printNewline(g === 0, o), this.print(P, r, void 0, i.trailingCommentsLineOffset || 0), i.iterator == null ||
        i.iterator(P, g), g < u - 1 && l?.(), i.statement)) {
          var c;
          if ((c = P.trailingComments) != null && c.length || (this._lastCommentLine = 0), g + 1 === u)
            this.newline(1);
          else {
            var p;
            let A = t[g + 1];
            o.nextNodeStartLine = ((p = A.loc) == null ? void 0 : p.start.line) || 0, this._printNewline(!0, o);
          }
        }
      }
      n && this.dedent();
    }
    printAndIndentOnComments(t, r) {
      let i = t.leadingComments && t.leadingComments.length > 0;
      i && this.indent(), this.print(t, r), i && this.dedent();
    }
    printBlock(t) {
      let r = t.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r, t);
    }
    _printTrailingComments(t, r, i) {
      let {
        innerComments: n,
        trailingComments: a
      } = t;
      n != null && n.length && this._printComments(2, n, t, r, i), a != null && a.length && this._printComments(2, a, t, r, i);
    }
    _printLeadingComments(t, r) {
      let i = t.leadingComments;
      i != null && i.length && this._printComments(0, i, t, r);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments() {
      let t = this._printStack[this._printStack.length - 1], r = t.innerComments;
      if (!(r != null && r.length)) return;
      let i = this.endsWith(32), n = this._indentInnerComments, a = this._printedComments.size;
      n && this.indent(), this._printComments(1, r, t), i && a !== this._printedComments.size && this.space(), n && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(t, r, i = {}) {
      var n;
      i.statement = !0, (n = i.indent) != null || (i.indent = !1), this.printJoin(t, r, i);
    }
    printList(t, r, i = {}) {
      i.separator == null && (i.separator = K4), this.printJoin(t, r, i);
    }
    _printNewline(t, r) {
      let i = this.format;
      if (i.retainLines || i.compact) return;
      if (i.concise) {
        this.space();
        return;
      }
      if (!t)
        return;
      let n = r.nextNodeStartLine, a = this._lastCommentLine;
      if (n > 0 && a > 0) {
        let o = n - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(t) {
      return t.ignore || this._printedComments.has(t) ? 0 : this._noLineTerminator && V4.test(t.value) ? 2 : (this._printedComments.add(t), this.
      format.shouldPrintComment(t.value) ? 1 : 0);
    }
    _printComment(t, r) {
      let i = this._noLineTerminator, n = t.type === "CommentBlock", a = n && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && this.space();
      let l;
      if (n) {
        let {
          _parenPushNewlineState: c
        } = this;
        if (c?.printed === !1 && hd.test(t.value) && (this.tokenChar(40), this.indent(), c.printed = !0), l = `/*${t.value}*/`, this.format.
        indent.adjustMultilineComment) {
          var u;
          let p = (u = t.loc) == null ? void 0 : u.start.column;
          if (p) {
            let g = new RegExp("\\n\\s{1," + p + "}", "g");
            l = l.replace(g, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let g = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (g += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(g)}`);
          }
        }
      } else i ? l = `/*${t.value}*/` : l = `//${t.value}`;
      this.endsWith(47) && this._space(), this.source("start", t.loc), this._append(l, n), !n && !i && this.newline(1, !0), a && r !== 3 && this.
      newline(1);
    }
    _printComments(t, r, i, n, a = 0) {
      let o = i.loc, l = r.length, u = !!o, c = u ? o.start.line : 0, p = u ? o.end.line : 0, g = 0, P = 0, A = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let C = 0; C < l; C++) {
        let _ = r[C], k = this._shouldPrintComment(_);
        if (k === 2) {
          u = !1;
          break;
        }
        if (u && _.loc && k === 1) {
          let O = _.loc.start.line, M = _.loc.end.line;
          if (t === 0) {
            let F = 0;
            C === 0 ? this._buf.hasContent() && (_.type === "CommentLine" || O != M) && (F = P = 1) : F = O - g, g = M, A(F), this._printComment(
            _, 1), C + 1 === l && (A(Math.max(c - g, P)), g = c);
          } else if (t === 1) {
            let F = O - (C === 0 ? c : g);
            g = M, A(F), this._printComment(_, 1), C + 1 === l && (A(Math.min(1, p - g)), g = p);
          } else {
            let F = O - (C === 0 ? p - a : g);
            g = M, A(F), this._printComment(_, 1);
          }
        } else {
          if (u = !1, k !== 1)
            continue;
          if (l === 1) {
            let O = _.loc ? _.loc.start.line === _.loc.end.line : !hd.test(_.value), M = O && !M4(i) && !F4(n) && !B4(n) && !j4(n);
            t === 0 ? this._printComment(_, M && i.type !== "ObjectExpression" || O && L4(n, {
              body: i
            }) ? 1 : 0) : M && t === 2 ? this._printComment(_, 1) : this._printComment(_, 0);
          } else t === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterface\
Body" ? this._printComment(_, C === 0 ? 2 : C === l - 1 ? 3 : 0) : this._printComment(_, 0);
        }
      }
      t === 2 && u && g && (this._lastCommentLine = g);
    }
  };
  Object.assign(Qi.prototype, k4);
  Qi.prototype.Noop = /* @__PURE__ */ s(function() {
  }, "Noop");
  var GQ = bn.default = Qi;
  function K4() {
    this.tokenChar(44), this.space();
  }
  s(K4, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var ii = v((Sn) => {
  "use strict";
  Object.defineProperty(Sn, "__esModule", {
    value: !0
  });
  Sn.default = W4;
  var md = Ch(), yd = dd();
  function Td(e, t) {
    var r;
    let i = {
      auxiliaryCommentBefore: t.auxiliaryCommentBefore,
      auxiliaryCommentAfter: t.auxiliaryCommentAfter,
      shouldPrintComment: t.shouldPrintComment,
      retainLines: t.retainLines,
      retainFunctionParens: t.retainFunctionParens,
      comments: t.comments == null || t.comments,
      compact: t.compact,
      minified: t.minified,
      concise: t.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, t.jsescOption),
      recordAndTupleSyntaxType: (r = t.recordAndTupleSyntaxType) != null ? r : "hash",
      topicToken: t.topicToken,
      importAttributesKeyword: t.importAttributesKeyword
    };
    i.decoratorsBeforeExport = t.decoratorsBeforeExport, i.jsescOption.json = t.jsonCompatibleStrings, i.minified ? (i.compact = !0, i.shouldPrintComment =
    i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment || ((l) => i.comments || l.includes("@license") ||
    l.includes("@preserve")), i.compact === "auto" && (i.compact = typeof e == "string" && e.length > 5e5, i.compact && console.error(`[BABE\
L] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)), i.compact && (i.indent.adjustMultilineComment =
    !1);
    let {
      auxiliaryCommentBefore: n,
      auxiliaryCommentAfter: a,
      shouldPrintComment: o
    } = i;
    return n && !o(n) && (i.auxiliaryCommentBefore = void 0), a && !o(a) && (i.auxiliaryCommentAfter = void 0), i;
  }
  s(Td, "normalizeOptions");
  Sn.CodeGenerator = class {
    static {
      s(this, "CodeGenerator");
    }
    constructor(t, r = {}, i) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = Td(i, r), this._map = r.sourceMaps ? new md.
      default(r, i) : null;
    }
    generate() {
      return new yd.default(this._format, this._map).generate(this._ast);
    }
  };
  function W4(e, t = {}, r) {
    let i = Td(r, t), n = t.sourceMaps ? new md.default(t, r) : null;
    return new yd.default(i, n).generate(e);
  }
  s(W4, "generate");
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var $l = v((de) => {
  "use strict";
  Object.defineProperty(de, "__esModule", {
    value: !0
  });
  de.Var = de.User = de.Statement = de.SpreadProperty = de.Scope = de.RestProperty = de.ReferencedMemberExpression = de.ReferencedIdentifier =
  de.Referenced = de.Pure = de.NumericLiteralTypeAnnotation = de.Generated = de.ForAwaitStatement = de.Flow = de.Expression = de.ExistentialTypeParam =
  de.BlockScoped = de.BindingIdentifier = void 0;
  var rZ = de.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], iZ = de.ReferencedMemberExpression = ["MemberExpression"], sZ = de.BindingIdentifier =
  ["Identifier"], nZ = de.Statement = ["Statement"], aZ = de.Expression = ["Expression"], oZ = de.Scope = ["Scopable", "Pattern"], lZ = de.Referenced =
  null, uZ = de.BlockScoped = null, cZ = de.Var = ["VariableDeclaration"], pZ = de.User = null, fZ = de.Generated = null, hZ = de.Pure = null,
  dZ = de.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], mZ = de.RestProperty = ["RestElement"], yZ = de.SpreadProperty =
  ["RestElement"], TZ = de.ExistentialTypeParam = ["ExistsTypeAnnotation"], gZ = de.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnota\
tion"], bZ = de.ForAwaitStatement = ["ForOfStatement"];
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var Gl = v((Ye) => {
  "use strict";
  Object.defineProperty(Ye, "__esModule", {
    value: !0
  });
  Ye.isBindingIdentifier = h6;
  Ye.isBlockScoped = g6;
  Ye.isExpression = m6;
  Ye.isFlow = P6;
  Ye.isForAwaitStatement = C6;
  Ye.isGenerated = x6;
  Ye.isPure = E6;
  Ye.isReferenced = T6;
  Ye.isReferencedIdentifier = p6;
  Ye.isReferencedMemberExpression = f6;
  Ye.isRestProperty = A6;
  Ye.isScope = y6;
  Ye.isSpreadProperty = v6;
  Ye.isStatement = d6;
  Ye.isUser = S6;
  Ye.isVar = b6;
  var Y4 = le(), {
    isBinding: X4,
    isBlockScoped: J4,
    isExportDeclaration: $4,
    isExpression: H4,
    isFlow: G4,
    isForStatement: z4,
    isForXStatement: Q4,
    isIdentifier: gd,
    isImportDeclaration: Z4,
    isImportSpecifier: e6,
    isJSXIdentifier: t6,
    isJSXMemberExpression: r6,
    isMemberExpression: i6,
    isRestElement: bd,
    isReferenced: Hl,
    isScope: s6,
    isStatement: n6,
    isVar: a6,
    isVariableDeclaration: o6,
    react: l6,
    isForOfStatement: u6
  } = Y4, {
    isCompatTag: c6
  } = l6;
  function p6(e) {
    let {
      node: t,
      parent: r
    } = this;
    if (!gd(t, e) && !r6(r, e))
      if (t6(t, e)) {
        if (c6(t.name)) return !1;
      } else
        return !1;
    return Hl(t, r, this.parentPath.parent);
  }
  s(p6, "isReferencedIdentifier");
  function f6() {
    let {
      node: e,
      parent: t
    } = this;
    return i6(e) && Hl(e, t);
  }
  s(f6, "isReferencedMemberExpression");
  function h6() {
    let {
      node: e,
      parent: t
    } = this, r = this.parentPath.parent;
    return gd(e) && X4(e, t, r);
  }
  s(h6, "isBindingIdentifier");
  function d6() {
    let {
      node: e,
      parent: t
    } = this;
    return n6(e) ? !(o6(e) && (Q4(t, {
      left: e
    }) || z4(t, {
      init: e
    }))) : !1;
  }
  s(d6, "isStatement");
  function m6() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : H4(this.node);
  }
  s(m6, "isExpression");
  function y6() {
    return s6(this.node, this.parent);
  }
  s(y6, "isScope");
  function T6() {
    return Hl(this.node, this.parent);
  }
  s(T6, "isReferenced");
  function g6() {
    return J4(this.node);
  }
  s(g6, "isBlockScoped");
  function b6() {
    return a6(this.node);
  }
  s(b6, "isVar");
  function S6() {
    return this.node && !!this.node.loc;
  }
  s(S6, "isUser");
  function x6() {
    return !this.isUser();
  }
  s(x6, "isGenerated");
  function E6(e) {
    return this.scope.isPure(this.node, e);
  }
  s(E6, "isPure");
  function P6() {
    let {
      node: e
    } = this;
    return G4(e) ? !0 : Z4(e) ? e.importKind === "type" || e.importKind === "typeof" : $4(e) ? e.exportKind === "type" : e6(e) ? e.importKind ===
    "type" || e.importKind === "typeof" : !1;
  }
  s(P6, "isFlow");
  function A6() {
    return bd(this.node) && this.parentPath && this.parentPath.isObjectPattern();
  }
  s(A6, "isRestProperty");
  function v6() {
    return bd(this.node) && this.parentPath && this.parentPath.isObjectExpression();
  }
  s(v6, "isSpreadProperty");
  function C6() {
    return u6(this.node, {
      await: !0
    });
  }
  s(C6, "isForAwaitStatement");
  Ye.isExistentialTypeParam = /* @__PURE__ */ s(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), Ye.isNumericLiteralTypeAnnotation = /* @__PURE__ */ s(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/traverse/lib/visitors.js
var es = v((si) => {
  "use strict";
  Object.defineProperty(si, "__esModule", {
    value: !0
  });
  si.explode = Od;
  si.isExplodedVisitor = wd;
  si.merge = _6;
  si.verify = Nd;
  var Id = $l(), I6 = Gl(), w6 = le(), {
    DEPRECATED_KEYS: Sd,
    DEPRECATED_ALIASES: xd,
    FLIPPED_ALIAS_KEYS: Ed,
    TYPES: O6,
    __internal__deprecationWarning: Pd
  } = w6;
  function N6(e) {
    return e in Id;
  }
  s(N6, "isVirtualType");
  function wd(e) {
    return e?._exploded;
  }
  s(wd, "isExplodedVisitor");
  function Od(e) {
    if (wd(e)) return e;
    e._exploded = !0;
    for (let t of Object.keys(e)) {
      if (Mr(t)) continue;
      let r = t.split("|");
      if (r.length === 1) continue;
      let i = e[t];
      delete e[t];
      for (let n of r)
        e[n] = i;
    }
    Nd(e), delete e.__esModule, D6(e), Cd(e);
    for (let t of Object.keys(e)) {
      if (Mr(t) || !N6(t)) continue;
      let r = e[t];
      for (let n of Object.keys(r))
        r[n] = k6(t, r[n]);
      delete e[t];
      let i = Id[t];
      if (i !== null)
        for (let n of i)
          e[n] ? Zi(e[n], r) : e[n] = r;
      else
        Zi(e, r);
    }
    for (let t of Object.keys(e)) {
      if (Mr(t)) continue;
      let r = Ed[t];
      if (t in Sd) {
        let n = Sd[t];
        Pd(t, n, "Visitor "), r = [n];
      } else if (t in xd) {
        let n = xd[t];
        Pd(t, n, "Visitor "), r = Ed[n];
      }
      if (!r) continue;
      let i = e[t];
      delete e[t];
      for (let n of r) {
        let a = e[n];
        a ? Zi(a, i) : e[n] = Object.assign({}, i);
      }
    }
    for (let t of Object.keys(e))
      Mr(t) || Cd(e[t]);
    return e;
  }
  s(Od, "explode");
  function Nd(e) {
    if (!e._verified) {
      if (typeof e == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let t of Object.keys(e)) {
        if ((t === "enter" || t === "exit") && Ad(t, e[t]), Mr(t)) continue;
        if (O6.indexOf(t) < 0)
          throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);
        let r = e[t];
        if (typeof r == "object")
          for (let i of Object.keys(r))
            if (i === "enter" || i === "exit")
              Ad(`${t}.${i}`, r[i]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${i}`);
      }
      e._verified = !0;
    }
  }
  s(Nd, "verify");
  function Ad(e, t) {
    let r = [].concat(t);
    for (let i of r)
      if (typeof i != "function")
        throw new TypeError(`Non-function found defined in ${e} with type ${typeof i}`);
  }
  s(Ad, "validateVisitorMethods");
  function _6(e, t = [], r) {
    let i = {};
    for (let n = 0; n < e.length; n++) {
      let a = Od(e[n]), o = t[n], l = a;
      (o || r) && (l = vd(l, o, r)), Zi(i, l);
      for (let u of Object.keys(a)) {
        if (Mr(u)) continue;
        let c = a[u];
        (o || r) && (c = vd(c, o, r));
        let p = i[u] || (i[u] = {});
        Zi(p, c);
      }
    }
    return i;
  }
  s(_6, "merge");
  function vd(e, t, r) {
    let i = {};
    for (let n of ["enter", "exit"]) {
      let a = e[n];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return t && (l = /* @__PURE__ */ s(function(u) {
          o.call(t, u, t);
        }, "newFn")), r && (l = r(t?.key, n, l)), l !== o && (l.toString = () => o.toString()), l;
      }), i[n] = a);
    }
    return i;
  }
  s(vd, "wrapWithStateOrWrapper");
  function D6(e) {
    for (let t of Object.keys(e)) {
      if (Mr(t)) continue;
      let r = e[t];
      typeof r == "function" && (e[t] = {
        enter: r
      });
    }
  }
  s(D6, "ensureEntranceObjects");
  function Cd(e) {
    e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
  }
  s(Cd, "ensureCallbackArrays");
  function k6(e, t) {
    let r = `is${e}`, i = I6[r], n = /* @__PURE__ */ s(function(a) {
      if (i.call(a))
        return t.apply(this, arguments);
    }, "newFn");
    return n.toString = () => t.toString(), n;
  }
  s(k6, "wrapCheck");
  function Mr(e) {
    return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" ||
    e === "blacklist";
  }
  s(Mr, "shouldIgnoreKey");
  function Zi(e, t) {
    for (let r of ["enter", "exit"])
      t[r] && (e[r] = [].concat(e[r] || [], t[r]));
  }
  s(Zi, "mergePair");
});

// ../node_modules/@babel/traverse/lib/cache.js
var Fr = v((bt) => {
  "use strict";
  Object.defineProperty(bt, "__esModule", {
    value: !0
  });
  bt.clear = M6;
  bt.clearPath = _d;
  bt.clearScope = Dd;
  bt.getCachedPaths = F6;
  bt.getOrCreateCachedPaths = B6;
  bt.scope = bt.path = void 0;
  var xn = bt.path = /* @__PURE__ */ new WeakMap(), L6 = bt.scope = /* @__PURE__ */ new WeakMap();
  function M6() {
    _d(), Dd();
  }
  s(M6, "clear");
  function _d() {
    bt.path = xn = /* @__PURE__ */ new WeakMap();
  }
  s(_d, "clearPath");
  function Dd() {
    bt.scope = L6 = /* @__PURE__ */ new WeakMap();
  }
  s(Dd, "clearScope");
  var zl = Object.freeze({});
  function F6(e, t) {
    var r, i;
    return e = null, (r = xn.get((i = e) != null ? i : zl)) == null ? void 0 : r.get(t);
  }
  s(F6, "getCachedPaths");
  function B6(e, t) {
    var r, i;
    e = null;
    let n = xn.get((r = e) != null ? r : zl);
    n || xn.set((i = e) != null ? i : zl, n = /* @__PURE__ */ new WeakMap());
    let a = n.get(t);
    return a || n.set(t, a = /* @__PURE__ */ new Map()), a;
  }
  s(B6, "getOrCreateCachedPaths");
});

// ../node_modules/debug/node_modules/ms/index.js
var Ld = v((IZ, kd) => {
  var ni = 1e3, ai = ni * 60, oi = ai * 60, Br = oi * 24, j6 = Br * 7, R6 = Br * 365.25;
  kd.exports = function(e, t) {
    t = t || {};
    var r = typeof e;
    if (r === "string" && e.length > 0)
      return q6(e);
    if (r === "number" && isFinite(e))
      return t.long ? U6(e) : V6(e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(e)
    );
  };
  function q6(e) {
    if (e = String(e), !(e.length > 100)) {
      var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        e
      );
      if (t) {
        var r = parseFloat(t[1]), i = (t[2] || "ms").toLowerCase();
        switch (i) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * R6;
          case "weeks":
          case "week":
          case "w":
            return r * j6;
          case "days":
          case "day":
          case "d":
            return r * Br;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * oi;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * ai;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * ni;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  s(q6, "parse");
  function V6(e) {
    var t = Math.abs(e);
    return t >= Br ? Math.round(e / Br) + "d" : t >= oi ? Math.round(e / oi) + "h" : t >= ai ? Math.round(e / ai) + "m" : t >= ni ? Math.round(
    e / ni) + "s" : e + "ms";
  }
  s(V6, "fmtShort");
  function U6(e) {
    var t = Math.abs(e);
    return t >= Br ? En(e, t, Br, "day") : t >= oi ? En(e, t, oi, "hour") : t >= ai ? En(e, t, ai, "minute") : t >= ni ? En(e, t, ni, "secon\
d") : e + " ms";
  }
  s(U6, "fmtLong");
  function En(e, t, r, i) {
    var n = t >= r * 1.5;
    return Math.round(e / r) + " " + i + (n ? "s" : "");
  }
  s(En, "plural");
});

// ../node_modules/debug/src/common.js
var Ql = v((OZ, Md) => {
  function K6(e) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = a, r.enable = n, r.enabled = o, r.humanize = Ld(), r.destroy = c, Object.keys(e).forEach(
    (p) => {
      r[p] = e[p];
    }), r.names = [], r.skips = [], r.formatters = {};
    function t(p) {
      let g = 0;
      for (let P = 0; P < p.length; P++)
        g = (g << 5) - g + p.charCodeAt(P), g |= 0;
      return r.colors[Math.abs(g) % r.colors.length];
    }
    s(t, "selectColor"), r.selectColor = t;
    function r(p) {
      let g, P = null, A, C;
      function _(...k) {
        if (!_.enabled)
          return;
        let O = _, M = Number(/* @__PURE__ */ new Date()), F = M - (g || M);
        O.diff = F, O.prev = g, O.curr = M, g = M, k[0] = r.coerce(k[0]), typeof k[0] != "string" && k.unshift("%O");
        let G = 0;
        k[0] = k[0].replace(/%([a-zA-Z%])/g, (K, oe) => {
          if (K === "%%")
            return "%";
          G++;
          let Oe = r.formatters[oe];
          if (typeof Oe == "function") {
            let Ne = k[G];
            K = Oe.call(O, Ne), k.splice(G, 1), G--;
          }
          return K;
        }), r.formatArgs.call(O, k), (O.log || r.log).apply(O, k);
      }
      return s(_, "debug"), _.namespace = p, _.useColors = r.useColors(), _.color = r.selectColor(p), _.extend = i, _.destroy = r.destroy, Object.
      defineProperty(_, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ s(() => P !== null ? P : (A !== r.namespaces && (A = r.namespaces, C = r.enabled(p)), C), "get"),
        set: /* @__PURE__ */ s((k) => {
          P = k;
        }, "set")
      }), typeof r.init == "function" && r.init(_), _;
    }
    s(r, "createDebug");
    function i(p, g) {
      let P = r(this.namespace + (typeof g > "u" ? ":" : g) + p);
      return P.log = this.log, P;
    }
    s(i, "extend");
    function n(p) {
      r.save(p), r.namespaces = p, r.names = [], r.skips = [];
      let g, P = (typeof p == "string" ? p : "").split(/[\s,]+/), A = P.length;
      for (g = 0; g < A; g++)
        P[g] && (p = P[g].replace(/\*/g, ".*?"), p[0] === "-" ? r.skips.push(new RegExp("^" + p.slice(1) + "$")) : r.names.push(new RegExp("\
^" + p + "$")));
    }
    s(n, "enable");
    function a() {
      let p = [
        ...r.names.map(l),
        ...r.skips.map(l).map((g) => "-" + g)
      ].join(",");
      return r.enable(""), p;
    }
    s(a, "disable");
    function o(p) {
      if (p[p.length - 1] === "*")
        return !0;
      let g, P;
      for (g = 0, P = r.skips.length; g < P; g++)
        if (r.skips[g].test(p))
          return !1;
      for (g = 0, P = r.names.length; g < P; g++)
        if (r.names[g].test(p))
          return !0;
      return !1;
    }
    s(o, "enabled");
    function l(p) {
      return p.toString().substring(2, p.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    s(l, "toNamespace");
    function u(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    s(u, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return s(c, "destroy"), r.enable(r.load()), r;
  }
  s(K6, "setup");
  Md.exports = K6;
});

// ../node_modules/debug/src/browser.js
var Fd = v((St, Pn) => {
  St.formatArgs = Y6;
  St.save = X6;
  St.load = J6;
  St.useColors = W6;
  St.storage = $6();
  St.destroy = /* @__PURE__ */ (() => {
    let e = !1;
    return () => {
      e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  St.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function W6() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "\
u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement &&
    document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  s(W6, "useColors");
  function Y6(e) {
    if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" +
    Pn.exports.humanize(this.diff), !this.useColors)
      return;
    let t = "color: " + this.color;
    e.splice(1, 0, t, "color: inherit");
    let r = 0, i = 0;
    e[0].replace(/%[a-zA-Z%]/g, (n) => {
      n !== "%%" && (r++, n === "%c" && (i = r));
    }), e.splice(i, 0, t);
  }
  s(Y6, "formatArgs");
  St.log = console.debug || console.log || (() => {
  });
  function X6(e) {
    try {
      e ? St.storage.setItem("debug", e) : St.storage.removeItem("debug");
    } catch {
    }
  }
  s(X6, "save");
  function J6() {
    let e;
    try {
      e = St.storage.getItem("debug");
    } catch {
    }
    return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
  }
  s(J6, "load");
  function $6() {
    try {
      return localStorage;
    } catch {
    }
  }
  s($6, "localstorage");
  Pn.exports = Ql()(St);
  var { formatters: H6 } = Pn.exports;
  H6.j = function(e) {
    try {
      return JSON.stringify(e);
    } catch (t) {
      return "[UnexpectedJSONParseError]: " + t.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var jd = v((DZ, Bd) => {
  "use strict";
  Bd.exports = (e, t = process.argv) => {
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", i = t.indexOf(r + e), n = t.indexOf("--");
    return i !== -1 && (n === -1 || i < n);
  };
});

// ../node_modules/supports-color/index.js
var Vd = v((kZ, qd) => {
  "use strict";
  var G6 = require("os"), Rd = require("tty"), At = jd(), { env: Qe } = process, cr;
  At("no-color") || At("no-colors") || At("color=false") || At("color=never") ? cr = 0 : (At("color") || At("colors") || At("color=true") ||
  At("color=always")) && (cr = 1);
  "FORCE_COLOR" in Qe && (Qe.FORCE_COLOR === "true" ? cr = 1 : Qe.FORCE_COLOR === "false" ? cr = 0 : cr = Qe.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(Qe.FORCE_COLOR, 10), 3));
  function Zl(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  s(Zl, "translateLevel");
  function eu(e, t) {
    if (cr === 0)
      return 0;
    if (At("color=16m") || At("color=full") || At("color=truecolor"))
      return 3;
    if (At("color=256"))
      return 2;
    if (e && !t && cr === void 0)
      return 0;
    let r = cr || 0;
    if (Qe.TERM === "dumb")
      return r;
    if (process.platform === "win32") {
      let i = G6.release().split(".");
      return Number(i[0]) >= 10 && Number(i[2]) >= 10586 ? Number(i[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in Qe)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((i) => i in Qe) || Qe.CI_NAME === "codeship" ?
      1 : r;
    if ("TEAMCITY_VERSION" in Qe)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Qe.TEAMCITY_VERSION) ? 1 : 0;
    if (Qe.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in Qe) {
      let i = parseInt((Qe.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Qe.TERM_PROGRAM) {
        case "iTerm.app":
          return i >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Qe.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Qe.TERM) || "COLORTERM" in
    Qe ? 1 : r;
  }
  s(eu, "supportsColor");
  function z6(e) {
    let t = eu(e, e && e.isTTY);
    return Zl(t);
  }
  s(z6, "getSupportLevel");
  qd.exports = {
    supportsColor: z6,
    stdout: Zl(eu(!0, Rd.isatty(1))),
    stderr: Zl(eu(!0, Rd.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var Kd = v((et, vn) => {
  var Q6 = require("tty"), An = require("util");
  et.init = n8;
  et.log = r8;
  et.formatArgs = e8;
  et.save = i8;
  et.load = s8;
  et.useColors = Z6;
  et.destroy = An.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  et.colors = [6, 2, 3, 4, 5, 1];
  try {
    let e = Vd();
    e && (e.stderr || e).level >= 2 && (et.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  et.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
    let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (n, a) => a.toUpperCase()), i = process.env[t];
    return /^(yes|on|true|enabled)$/i.test(i) ? i = !0 : /^(no|off|false|disabled)$/i.test(i) ? i = !1 : i === "null" ? i = null : i = Number(
    i), e[r] = i, e;
  }, {});
  function Z6() {
    return "colors" in et.inspectOpts ? !!et.inspectOpts.colors : Q6.isatty(process.stderr.fd);
  }
  s(Z6, "useColors");
  function e8(e) {
    let { namespace: t, useColors: r } = this;
    if (r) {
      let i = this.color, n = "\x1B[3" + (i < 8 ? i : "8;5;" + i), a = `  ${n};1m${t} \x1B[0m`;
      e[0] = a + e[0].split(`
`).join(`
` + a), e.push(n + "m+" + vn.exports.humanize(this.diff) + "\x1B[0m");
    } else
      e[0] = t8() + t + " " + e[0];
  }
  s(e8, "formatArgs");
  function t8() {
    return et.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  s(t8, "getDate");
  function r8(...e) {
    return process.stderr.write(An.format(...e) + `
`);
  }
  s(r8, "log");
  function i8(e) {
    e ? process.env.DEBUG = e : delete process.env.DEBUG;
  }
  s(i8, "save");
  function s8() {
    return process.env.DEBUG;
  }
  s(s8, "load");
  function n8(e) {
    e.inspectOpts = {};
    let t = Object.keys(et.inspectOpts);
    for (let r = 0; r < t.length; r++)
      e.inspectOpts[t[r]] = et.inspectOpts[t[r]];
  }
  s(n8, "init");
  vn.exports = Ql()(et);
  var { formatters: Ud } = vn.exports;
  Ud.o = function(e) {
    return this.inspectOpts.colors = this.useColors, An.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
  };
  Ud.O = function(e) {
    return this.inspectOpts.colors = this.useColors, An.inspect(e, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var Wd = v((FZ, tu) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? tu.exports = Fd() : tu.exports = Kd();
});

// ../node_modules/@babel/helper-split-export-declaration/lib/index.js
var Jd = v((su) => {
  "use strict";
  Object.defineProperty(su, "__esModule", {
    value: !0
  });
  su.default = u8;
  var a8 = le(), {
    cloneNode: ru,
    exportNamedDeclaration: Yd,
    exportSpecifier: Xd,
    identifier: iu,
    variableDeclaration: o8,
    variableDeclarator: l8
  } = a8;
  function u8(e) {
    if (!e.isExportDeclaration() || e.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (e.isExportDefaultDeclaration()) {
      let a = e.get("declaration"), o = a.isFunctionDeclaration() || a.isClassDeclaration(), l = a.isFunctionExpression() || a.isClassExpression(),
      u = a.isScope() ? a.scope.parent : a.scope, c = a.node.id, p = !1;
      c ? l && u.hasBinding(c.name) && (p = !0, c = u.generateUidIdentifier(c.name)) : (p = !0, c = u.generateUidIdentifier("default"), (o ||
      l) && (a.node.id = ru(c)));
      let g = o ? a.node : o8("var", [l8(ru(c), a.node)]), P = Yd(null, [Xd(ru(c), iu("default"))]);
      return e.insertAfter(P), e.replaceWith(g), p && u.registerDeclaration(e), e;
    } else if (e.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let t = e.get("declaration"), r = t.getOuterBindingIdentifiers(), i = Object.keys(r).map((a) => Xd(iu(a), iu(a))), n = Yd(null, i);
    return e.insertAfter(n), e.replaceWith(t.node), e;
  }
  s(u8, "splitExportDeclaration");
});

// ../node_modules/@babel/helper-environment-visitor/lib/index.js
var au = v((li) => {
  "use strict";
  Object.defineProperty(li, "__esModule", {
    value: !0
  });
  li.default = void 0;
  li.requeueComputedKeyAndDecorators = nu;
  li.skipAllButComputedKey = /* @__PURE__ */ s(function(t) {
    t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
  }, "skipAllButComputedKey");
  function nu(e) {
    let {
      context: t,
      node: r
    } = e;
    if (r.computed && t.maybeQueue(e.get("key")), r.decorators)
      for (let i of e.get("decorators"))
        t.maybeQueue(i);
  }
  s(nu, "requeueComputedKeyAndDecorators");
  var c8 = {
    FunctionParent(e) {
      e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && nu(e));
    },
    Property(e) {
      e.isObjectProperty() || (e.skip(), nu(e));
    }
  }, p8 = c8;
  li.default = p8;
});

// ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var $d = v((Cn) => {
  "use strict";
  Object.defineProperty(Cn, "__esModule", {
    value: !0
  });
  Cn.default = void 0;
  var f8 = Jd(), h8 = le(), d8 = au(), m8 = In(), y8 = es(), T8 = {
    ReferencedIdentifier({
      node: e
    }, t) {
      e.name === t.oldName && (e.name = t.newName);
    },
    Scope(e, t) {
      e.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier) || (e.skip(), e.isMethod() && (0, d8.requeueComputedKeyAndDecorators)(
      e));
    },
    ObjectProperty({
      node: e,
      scope: t
    }, r) {
      let {
        name: i
      } = e.key;
      if (e.shorthand && (i === r.oldName || i === r.newName) && t.getBindingIdentifier(i) === r.binding.identifier) {
        var n;
        e.shorthand = !1, (n = e.extra) != null && n.shorthand && (e.extra.shorthand = !1);
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(e, t) {
      if (e.isVariableDeclaration()) return;
      let r = e.getOuterBindingIdentifiers();
      for (let i in r)
        i === t.oldName && (r[i].name = t.newName);
    }
  }, ou = class {
    static {
      s(this, "Renamer");
    }
    constructor(t, r, i) {
      this.newName = i, this.oldName = r, this.binding = t;
    }
    maybeConvertFromExportDeclaration(t) {
      let r = t.parentPath;
      if (r.isExportDeclaration()) {
        if (r.isExportDefaultDeclaration()) {
          let {
            declaration: i
          } = r.node;
          if (h8.isDeclaration(i) && !i.id)
            return;
        }
        r.isExportAllDeclaration() || (0, f8.default)(r);
      }
    }
    maybeConvertFromClassFunctionDeclaration(t) {
      return t;
    }
    maybeConvertFromClassFunctionExpression(t) {
      return t;
    }
    rename() {
      let {
        binding: t,
        oldName: r,
        newName: i
      } = this, {
        scope: n,
        path: a
      } = t, o = a.find((u) => u.isDeclaration() || u.isFunctionExpression() || u.isClassExpression());
      o && o.getOuterBindingIdentifiers()[r] === t.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || n.block;
      (0, m8.traverseNode)(l, (0, y8.explode)(T8), n, this, n.path, {
        discriminant: !0
      }), arguments[0] || (n.removeOwnBinding(r), n.bindings[i] = t, this.binding.identifier.name = i), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  Cn.default = ou;
});

// ../node_modules/@babel/traverse/lib/scope/binding.js
var Hd = v((wn) => {
  "use strict";
  Object.defineProperty(wn, "__esModule", {
    value: !0
  });
  wn.default = void 0;
  var lu = class {
    static {
      s(this, "Binding");
    }
    constructor({
      identifier: t,
      scope: r,
      path: i,
      kind: n
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = i, this.kind = n,
      (n === "var" || n === "hoisted") && g8(i) && this.reassign(i), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(t) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(t) {
      this.constant = !1, this.constantViolations.indexOf(t) === -1 && this.constantViolations.push(t);
    }
    reference(t) {
      this.referencePaths.indexOf(t) === -1 && (this.referenced = !0, this.references++, this.referencePaths.push(t));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  wn.default = lu;
  function g8(e) {
    for (let {
      parentPath: t,
      key: r
    } = e; t; {
      parentPath: t,
      key: r
    } = t) {
      if (t.isFunctionParent()) return !1;
      if (t.isWhile() || t.isForXStatement() || t.isForStatement() && r === "body")
        return !0;
    }
    return !1;
  }
  s(g8, "isDeclaredInLoop");
});

// ../node_modules/@babel/traverse/node_modules/globals/globals.json
var Gd = v((YZ, b8) => {
  b8.exports = {
    builtin: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      BigInt: !1,
      BigInt64Array: !1,
      BigUint64Array: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      globalThis: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es5: {
      Array: !1,
      Boolean: !1,
      constructor: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      propertyIsEnumerable: !1,
      RangeError: !1,
      ReferenceError: !1,
      RegExp: !1,
      String: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1
    },
    es2015: {
      Array: !1,
      ArrayBuffer: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es2017: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    browser: {
      AbortController: !1,
      AbortSignal: !1,
      addEventListener: !1,
      alert: !1,
      AnalyserNode: !1,
      Animation: !1,
      AnimationEffectReadOnly: !1,
      AnimationEffectTiming: !1,
      AnimationEffectTimingReadOnly: !1,
      AnimationEvent: !1,
      AnimationPlaybackEvent: !1,
      AnimationTimeline: !1,
      applicationCache: !1,
      ApplicationCache: !1,
      ApplicationCacheErrorEvent: !1,
      atob: !1,
      Attr: !1,
      Audio: !1,
      AudioBuffer: !1,
      AudioBufferSourceNode: !1,
      AudioContext: !1,
      AudioDestinationNode: !1,
      AudioListener: !1,
      AudioNode: !1,
      AudioParam: !1,
      AudioProcessingEvent: !1,
      AudioScheduledSourceNode: !1,
      "AudioWorkletGlobalScope ": !1,
      AudioWorkletNode: !1,
      AudioWorkletProcessor: !1,
      BarProp: !1,
      BaseAudioContext: !1,
      BatteryManager: !1,
      BeforeUnloadEvent: !1,
      BiquadFilterNode: !1,
      Blob: !1,
      BlobEvent: !1,
      blur: !1,
      BroadcastChannel: !1,
      btoa: !1,
      BudgetService: !1,
      ByteLengthQueuingStrategy: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      cancelAnimationFrame: !1,
      cancelIdleCallback: !1,
      CanvasCaptureMediaStreamTrack: !1,
      CanvasGradient: !1,
      CanvasPattern: !1,
      CanvasRenderingContext2D: !1,
      ChannelMergerNode: !1,
      ChannelSplitterNode: !1,
      CharacterData: !1,
      clearInterval: !1,
      clearTimeout: !1,
      clientInformation: !1,
      ClipboardEvent: !1,
      close: !1,
      closed: !1,
      CloseEvent: !1,
      Comment: !1,
      CompositionEvent: !1,
      confirm: !1,
      console: !1,
      ConstantSourceNode: !1,
      ConvolverNode: !1,
      CountQueuingStrategy: !1,
      createImageBitmap: !1,
      Credential: !1,
      CredentialsContainer: !1,
      crypto: !1,
      Crypto: !1,
      CryptoKey: !1,
      CSS: !1,
      CSSConditionRule: !1,
      CSSFontFaceRule: !1,
      CSSGroupingRule: !1,
      CSSImportRule: !1,
      CSSKeyframeRule: !1,
      CSSKeyframesRule: !1,
      CSSMediaRule: !1,
      CSSNamespaceRule: !1,
      CSSPageRule: !1,
      CSSRule: !1,
      CSSRuleList: !1,
      CSSStyleDeclaration: !1,
      CSSStyleRule: !1,
      CSSStyleSheet: !1,
      CSSSupportsRule: !1,
      CustomElementRegistry: !1,
      customElements: !1,
      CustomEvent: !1,
      DataTransfer: !1,
      DataTransferItem: !1,
      DataTransferItemList: !1,
      defaultstatus: !1,
      defaultStatus: !1,
      DelayNode: !1,
      DeviceMotionEvent: !1,
      DeviceOrientationEvent: !1,
      devicePixelRatio: !1,
      dispatchEvent: !1,
      document: !1,
      Document: !1,
      DocumentFragment: !1,
      DocumentType: !1,
      DOMError: !1,
      DOMException: !1,
      DOMImplementation: !1,
      DOMMatrix: !1,
      DOMMatrixReadOnly: !1,
      DOMParser: !1,
      DOMPoint: !1,
      DOMPointReadOnly: !1,
      DOMQuad: !1,
      DOMRect: !1,
      DOMRectReadOnly: !1,
      DOMStringList: !1,
      DOMStringMap: !1,
      DOMTokenList: !1,
      DragEvent: !1,
      DynamicsCompressorNode: !1,
      Element: !1,
      ErrorEvent: !1,
      event: !1,
      Event: !1,
      EventSource: !1,
      EventTarget: !1,
      external: !1,
      fetch: !1,
      File: !1,
      FileList: !1,
      FileReader: !1,
      find: !1,
      focus: !1,
      FocusEvent: !1,
      FontFace: !1,
      FontFaceSetLoadEvent: !1,
      FormData: !1,
      frameElement: !1,
      frames: !1,
      GainNode: !1,
      Gamepad: !1,
      GamepadButton: !1,
      GamepadEvent: !1,
      getComputedStyle: !1,
      getSelection: !1,
      HashChangeEvent: !1,
      Headers: !1,
      history: !1,
      History: !1,
      HTMLAllCollection: !1,
      HTMLAnchorElement: !1,
      HTMLAreaElement: !1,
      HTMLAudioElement: !1,
      HTMLBaseElement: !1,
      HTMLBodyElement: !1,
      HTMLBRElement: !1,
      HTMLButtonElement: !1,
      HTMLCanvasElement: !1,
      HTMLCollection: !1,
      HTMLContentElement: !1,
      HTMLDataElement: !1,
      HTMLDataListElement: !1,
      HTMLDetailsElement: !1,
      HTMLDialogElement: !1,
      HTMLDirectoryElement: !1,
      HTMLDivElement: !1,
      HTMLDListElement: !1,
      HTMLDocument: !1,
      HTMLElement: !1,
      HTMLEmbedElement: !1,
      HTMLFieldSetElement: !1,
      HTMLFontElement: !1,
      HTMLFormControlsCollection: !1,
      HTMLFormElement: !1,
      HTMLFrameElement: !1,
      HTMLFrameSetElement: !1,
      HTMLHeadElement: !1,
      HTMLHeadingElement: !1,
      HTMLHRElement: !1,
      HTMLHtmlElement: !1,
      HTMLIFrameElement: !1,
      HTMLImageElement: !1,
      HTMLInputElement: !1,
      HTMLLabelElement: !1,
      HTMLLegendElement: !1,
      HTMLLIElement: !1,
      HTMLLinkElement: !1,
      HTMLMapElement: !1,
      HTMLMarqueeElement: !1,
      HTMLMediaElement: !1,
      HTMLMenuElement: !1,
      HTMLMetaElement: !1,
      HTMLMeterElement: !1,
      HTMLModElement: !1,
      HTMLObjectElement: !1,
      HTMLOListElement: !1,
      HTMLOptGroupElement: !1,
      HTMLOptionElement: !1,
      HTMLOptionsCollection: !1,
      HTMLOutputElement: !1,
      HTMLParagraphElement: !1,
      HTMLParamElement: !1,
      HTMLPictureElement: !1,
      HTMLPreElement: !1,
      HTMLProgressElement: !1,
      HTMLQuoteElement: !1,
      HTMLScriptElement: !1,
      HTMLSelectElement: !1,
      HTMLShadowElement: !1,
      HTMLSlotElement: !1,
      HTMLSourceElement: !1,
      HTMLSpanElement: !1,
      HTMLStyleElement: !1,
      HTMLTableCaptionElement: !1,
      HTMLTableCellElement: !1,
      HTMLTableColElement: !1,
      HTMLTableElement: !1,
      HTMLTableRowElement: !1,
      HTMLTableSectionElement: !1,
      HTMLTemplateElement: !1,
      HTMLTextAreaElement: !1,
      HTMLTimeElement: !1,
      HTMLTitleElement: !1,
      HTMLTrackElement: !1,
      HTMLUListElement: !1,
      HTMLUnknownElement: !1,
      HTMLVideoElement: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      IdleDeadline: !1,
      IIRFilterNode: !1,
      Image: !1,
      ImageBitmap: !1,
      ImageBitmapRenderingContext: !1,
      ImageCapture: !1,
      ImageData: !1,
      indexedDB: !1,
      innerHeight: !1,
      innerWidth: !1,
      InputEvent: !1,
      IntersectionObserver: !1,
      IntersectionObserverEntry: !1,
      Intl: !1,
      isSecureContext: !1,
      KeyboardEvent: !1,
      KeyframeEffect: !1,
      KeyframeEffectReadOnly: !1,
      length: !1,
      localStorage: !1,
      location: !0,
      Location: !1,
      locationbar: !1,
      matchMedia: !1,
      MediaDeviceInfo: !1,
      MediaDevices: !1,
      MediaElementAudioSourceNode: !1,
      MediaEncryptedEvent: !1,
      MediaError: !1,
      MediaKeyMessageEvent: !1,
      MediaKeySession: !1,
      MediaKeyStatusMap: !1,
      MediaKeySystemAccess: !1,
      MediaList: !1,
      MediaQueryList: !1,
      MediaQueryListEvent: !1,
      MediaRecorder: !1,
      MediaSettingsRange: !1,
      MediaSource: !1,
      MediaStream: !1,
      MediaStreamAudioDestinationNode: !1,
      MediaStreamAudioSourceNode: !1,
      MediaStreamEvent: !1,
      MediaStreamTrack: !1,
      MediaStreamTrackEvent: !1,
      menubar: !1,
      MessageChannel: !1,
      MessageEvent: !1,
      MessagePort: !1,
      MIDIAccess: !1,
      MIDIConnectionEvent: !1,
      MIDIInput: !1,
      MIDIInputMap: !1,
      MIDIMessageEvent: !1,
      MIDIOutput: !1,
      MIDIOutputMap: !1,
      MIDIPort: !1,
      MimeType: !1,
      MimeTypeArray: !1,
      MouseEvent: !1,
      moveBy: !1,
      moveTo: !1,
      MutationEvent: !1,
      MutationObserver: !1,
      MutationRecord: !1,
      name: !1,
      NamedNodeMap: !1,
      NavigationPreloadManager: !1,
      navigator: !1,
      Navigator: !1,
      NetworkInformation: !1,
      Node: !1,
      NodeFilter: !1,
      NodeIterator: !1,
      NodeList: !1,
      Notification: !1,
      OfflineAudioCompletionEvent: !1,
      OfflineAudioContext: !1,
      offscreenBuffering: !1,
      OffscreenCanvas: !0,
      onabort: !0,
      onafterprint: !0,
      onanimationend: !0,
      onanimationiteration: !0,
      onanimationstart: !0,
      onappinstalled: !0,
      onauxclick: !0,
      onbeforeinstallprompt: !0,
      onbeforeprint: !0,
      onbeforeunload: !0,
      onblur: !0,
      oncancel: !0,
      oncanplay: !0,
      oncanplaythrough: !0,
      onchange: !0,
      onclick: !0,
      onclose: !0,
      oncontextmenu: !0,
      oncuechange: !0,
      ondblclick: !0,
      ondevicemotion: !0,
      ondeviceorientation: !0,
      ondeviceorientationabsolute: !0,
      ondrag: !0,
      ondragend: !0,
      ondragenter: !0,
      ondragleave: !0,
      ondragover: !0,
      ondragstart: !0,
      ondrop: !0,
      ondurationchange: !0,
      onemptied: !0,
      onended: !0,
      onerror: !0,
      onfocus: !0,
      ongotpointercapture: !0,
      onhashchange: !0,
      oninput: !0,
      oninvalid: !0,
      onkeydown: !0,
      onkeypress: !0,
      onkeyup: !0,
      onlanguagechange: !0,
      onload: !0,
      onloadeddata: !0,
      onloadedmetadata: !0,
      onloadstart: !0,
      onlostpointercapture: !0,
      onmessage: !0,
      onmessageerror: !0,
      onmousedown: !0,
      onmouseenter: !0,
      onmouseleave: !0,
      onmousemove: !0,
      onmouseout: !0,
      onmouseover: !0,
      onmouseup: !0,
      onmousewheel: !0,
      onoffline: !0,
      ononline: !0,
      onpagehide: !0,
      onpageshow: !0,
      onpause: !0,
      onplay: !0,
      onplaying: !0,
      onpointercancel: !0,
      onpointerdown: !0,
      onpointerenter: !0,
      onpointerleave: !0,
      onpointermove: !0,
      onpointerout: !0,
      onpointerover: !0,
      onpointerup: !0,
      onpopstate: !0,
      onprogress: !0,
      onratechange: !0,
      onrejectionhandled: !0,
      onreset: !0,
      onresize: !0,
      onscroll: !0,
      onsearch: !0,
      onseeked: !0,
      onseeking: !0,
      onselect: !0,
      onstalled: !0,
      onstorage: !0,
      onsubmit: !0,
      onsuspend: !0,
      ontimeupdate: !0,
      ontoggle: !0,
      ontransitionend: !0,
      onunhandledrejection: !0,
      onunload: !0,
      onvolumechange: !0,
      onwaiting: !0,
      onwheel: !0,
      open: !1,
      openDatabase: !1,
      opener: !1,
      Option: !1,
      origin: !1,
      OscillatorNode: !1,
      outerHeight: !1,
      outerWidth: !1,
      PageTransitionEvent: !1,
      pageXOffset: !1,
      pageYOffset: !1,
      PannerNode: !1,
      parent: !1,
      Path2D: !1,
      PaymentAddress: !1,
      PaymentRequest: !1,
      PaymentRequestUpdateEvent: !1,
      PaymentResponse: !1,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceLongTaskTiming: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceNavigationTiming: !1,
      PerformanceObserver: !1,
      PerformanceObserverEntryList: !1,
      PerformancePaintTiming: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      PeriodicWave: !1,
      Permissions: !1,
      PermissionStatus: !1,
      personalbar: !1,
      PhotoCapabilities: !1,
      Plugin: !1,
      PluginArray: !1,
      PointerEvent: !1,
      PopStateEvent: !1,
      postMessage: !1,
      Presentation: !1,
      PresentationAvailability: !1,
      PresentationConnection: !1,
      PresentationConnectionAvailableEvent: !1,
      PresentationConnectionCloseEvent: !1,
      PresentationConnectionList: !1,
      PresentationReceiver: !1,
      PresentationRequest: !1,
      print: !1,
      ProcessingInstruction: !1,
      ProgressEvent: !1,
      PromiseRejectionEvent: !1,
      prompt: !1,
      PushManager: !1,
      PushSubscription: !1,
      PushSubscriptionOptions: !1,
      queueMicrotask: !1,
      RadioNodeList: !1,
      Range: !1,
      ReadableStream: !1,
      registerProcessor: !1,
      RemotePlayback: !1,
      removeEventListener: !1,
      Request: !1,
      requestAnimationFrame: !1,
      requestIdleCallback: !1,
      resizeBy: !1,
      ResizeObserver: !1,
      ResizeObserverEntry: !1,
      resizeTo: !1,
      Response: !1,
      RTCCertificate: !1,
      RTCDataChannel: !1,
      RTCDataChannelEvent: !1,
      RTCDtlsTransport: !1,
      RTCIceCandidate: !1,
      RTCIceGatherer: !1,
      RTCIceTransport: !1,
      RTCPeerConnection: !1,
      RTCPeerConnectionIceEvent: !1,
      RTCRtpContributingSource: !1,
      RTCRtpReceiver: !1,
      RTCRtpSender: !1,
      RTCSctpTransport: !1,
      RTCSessionDescription: !1,
      RTCStatsReport: !1,
      RTCTrackEvent: !1,
      screen: !1,
      Screen: !1,
      screenLeft: !1,
      ScreenOrientation: !1,
      screenTop: !1,
      screenX: !1,
      screenY: !1,
      ScriptProcessorNode: !1,
      scroll: !1,
      scrollbars: !1,
      scrollBy: !1,
      scrollTo: !1,
      scrollX: !1,
      scrollY: !1,
      SecurityPolicyViolationEvent: !1,
      Selection: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerRegistration: !1,
      sessionStorage: !1,
      setInterval: !1,
      setTimeout: !1,
      ShadowRoot: !1,
      SharedWorker: !1,
      SourceBuffer: !1,
      SourceBufferList: !1,
      speechSynthesis: !1,
      SpeechSynthesisEvent: !1,
      SpeechSynthesisUtterance: !1,
      StaticRange: !1,
      status: !1,
      statusbar: !1,
      StereoPannerNode: !1,
      stop: !1,
      Storage: !1,
      StorageEvent: !1,
      StorageManager: !1,
      styleMedia: !1,
      StyleSheet: !1,
      StyleSheetList: !1,
      SubtleCrypto: !1,
      SVGAElement: !1,
      SVGAngle: !1,
      SVGAnimatedAngle: !1,
      SVGAnimatedBoolean: !1,
      SVGAnimatedEnumeration: !1,
      SVGAnimatedInteger: !1,
      SVGAnimatedLength: !1,
      SVGAnimatedLengthList: !1,
      SVGAnimatedNumber: !1,
      SVGAnimatedNumberList: !1,
      SVGAnimatedPreserveAspectRatio: !1,
      SVGAnimatedRect: !1,
      SVGAnimatedString: !1,
      SVGAnimatedTransformList: !1,
      SVGAnimateElement: !1,
      SVGAnimateMotionElement: !1,
      SVGAnimateTransformElement: !1,
      SVGAnimationElement: !1,
      SVGCircleElement: !1,
      SVGClipPathElement: !1,
      SVGComponentTransferFunctionElement: !1,
      SVGDefsElement: !1,
      SVGDescElement: !1,
      SVGDiscardElement: !1,
      SVGElement: !1,
      SVGEllipseElement: !1,
      SVGFEBlendElement: !1,
      SVGFEColorMatrixElement: !1,
      SVGFEComponentTransferElement: !1,
      SVGFECompositeElement: !1,
      SVGFEConvolveMatrixElement: !1,
      SVGFEDiffuseLightingElement: !1,
      SVGFEDisplacementMapElement: !1,
      SVGFEDistantLightElement: !1,
      SVGFEDropShadowElement: !1,
      SVGFEFloodElement: !1,
      SVGFEFuncAElement: !1,
      SVGFEFuncBElement: !1,
      SVGFEFuncGElement: !1,
      SVGFEFuncRElement: !1,
      SVGFEGaussianBlurElement: !1,
      SVGFEImageElement: !1,
      SVGFEMergeElement: !1,
      SVGFEMergeNodeElement: !1,
      SVGFEMorphologyElement: !1,
      SVGFEOffsetElement: !1,
      SVGFEPointLightElement: !1,
      SVGFESpecularLightingElement: !1,
      SVGFESpotLightElement: !1,
      SVGFETileElement: !1,
      SVGFETurbulenceElement: !1,
      SVGFilterElement: !1,
      SVGForeignObjectElement: !1,
      SVGGElement: !1,
      SVGGeometryElement: !1,
      SVGGradientElement: !1,
      SVGGraphicsElement: !1,
      SVGImageElement: !1,
      SVGLength: !1,
      SVGLengthList: !1,
      SVGLinearGradientElement: !1,
      SVGLineElement: !1,
      SVGMarkerElement: !1,
      SVGMaskElement: !1,
      SVGMatrix: !1,
      SVGMetadataElement: !1,
      SVGMPathElement: !1,
      SVGNumber: !1,
      SVGNumberList: !1,
      SVGPathElement: !1,
      SVGPatternElement: !1,
      SVGPoint: !1,
      SVGPointList: !1,
      SVGPolygonElement: !1,
      SVGPolylineElement: !1,
      SVGPreserveAspectRatio: !1,
      SVGRadialGradientElement: !1,
      SVGRect: !1,
      SVGRectElement: !1,
      SVGScriptElement: !1,
      SVGSetElement: !1,
      SVGStopElement: !1,
      SVGStringList: !1,
      SVGStyleElement: !1,
      SVGSVGElement: !1,
      SVGSwitchElement: !1,
      SVGSymbolElement: !1,
      SVGTextContentElement: !1,
      SVGTextElement: !1,
      SVGTextPathElement: !1,
      SVGTextPositioningElement: !1,
      SVGTitleElement: !1,
      SVGTransform: !1,
      SVGTransformList: !1,
      SVGTSpanElement: !1,
      SVGUnitTypes: !1,
      SVGUseElement: !1,
      SVGViewElement: !1,
      TaskAttributionTiming: !1,
      Text: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      TextEvent: !1,
      TextMetrics: !1,
      TextTrack: !1,
      TextTrackCue: !1,
      TextTrackCueList: !1,
      TextTrackList: !1,
      TimeRanges: !1,
      toolbar: !1,
      top: !1,
      Touch: !1,
      TouchEvent: !1,
      TouchList: !1,
      TrackEvent: !1,
      TransitionEvent: !1,
      TreeWalker: !1,
      UIEvent: !1,
      URL: !1,
      URLSearchParams: !1,
      ValidityState: !1,
      visualViewport: !1,
      VisualViewport: !1,
      VTTCue: !1,
      WaveShaperNode: !1,
      WebAssembly: !1,
      WebGL2RenderingContext: !1,
      WebGLActiveInfo: !1,
      WebGLBuffer: !1,
      WebGLContextEvent: !1,
      WebGLFramebuffer: !1,
      WebGLProgram: !1,
      WebGLQuery: !1,
      WebGLRenderbuffer: !1,
      WebGLRenderingContext: !1,
      WebGLSampler: !1,
      WebGLShader: !1,
      WebGLShaderPrecisionFormat: !1,
      WebGLSync: !1,
      WebGLTexture: !1,
      WebGLTransformFeedback: !1,
      WebGLUniformLocation: !1,
      WebGLVertexArrayObject: !1,
      WebSocket: !1,
      WheelEvent: !1,
      window: !1,
      Window: !1,
      Worker: !1,
      WritableStream: !1,
      XMLDocument: !1,
      XMLHttpRequest: !1,
      XMLHttpRequestEventTarget: !1,
      XMLHttpRequestUpload: !1,
      XMLSerializer: !1,
      XPathEvaluator: !1,
      XPathExpression: !1,
      XPathResult: !1,
      XSLTProcessor: !1
    },
    worker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      clearInterval: !1,
      clearTimeout: !1,
      close: !0,
      console: !1,
      fetch: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !0,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onoffline: !0,
      ononline: !0,
      onrejectionhandled: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !0,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    node: {
      __dirname: !1,
      __filename: !1,
      Buffer: !1,
      clearImmediate: !1,
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      exports: !0,
      global: !1,
      Intl: !1,
      module: !1,
      process: !1,
      queueMicrotask: !1,
      require: !1,
      setImmediate: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1
    },
    commonjs: {
      exports: !0,
      global: !1,
      module: !1,
      require: !1
    },
    amd: {
      define: !1,
      require: !1
    },
    mocha: {
      after: !1,
      afterEach: !1,
      before: !1,
      beforeEach: !1,
      context: !1,
      describe: !1,
      it: !1,
      mocha: !1,
      run: !1,
      setup: !1,
      specify: !1,
      suite: !1,
      suiteSetup: !1,
      suiteTeardown: !1,
      teardown: !1,
      test: !1,
      xcontext: !1,
      xdescribe: !1,
      xit: !1,
      xspecify: !1
    },
    jasmine: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fail: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jasmine: !1,
      pending: !1,
      runs: !1,
      spyOn: !1,
      spyOnProperty: !1,
      waits: !1,
      waitsFor: !1,
      xdescribe: !1,
      xit: !1
    },
    jest: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jest: !1,
      pit: !1,
      require: !1,
      test: !1,
      xdescribe: !1,
      xit: !1,
      xtest: !1
    },
    qunit: {
      asyncTest: !1,
      deepEqual: !1,
      equal: !1,
      expect: !1,
      module: !1,
      notDeepEqual: !1,
      notEqual: !1,
      notOk: !1,
      notPropEqual: !1,
      notStrictEqual: !1,
      ok: !1,
      propEqual: !1,
      QUnit: !1,
      raises: !1,
      start: !1,
      stop: !1,
      strictEqual: !1,
      test: !1,
      throws: !1
    },
    phantomjs: {
      console: !0,
      exports: !0,
      phantom: !0,
      require: !0,
      WebPage: !0
    },
    couch: {
      emit: !1,
      exports: !1,
      getRow: !1,
      log: !1,
      module: !1,
      provides: !1,
      require: !1,
      respond: !1,
      send: !1,
      start: !1,
      sum: !1
    },
    rhino: {
      defineClass: !1,
      deserialize: !1,
      gc: !1,
      help: !1,
      importClass: !1,
      importPackage: !1,
      java: !1,
      load: !1,
      loadClass: !1,
      Packages: !1,
      print: !1,
      quit: !1,
      readFile: !1,
      readUrl: !1,
      runCommand: !1,
      seal: !1,
      serialize: !1,
      spawn: !1,
      sync: !1,
      toint32: !1,
      version: !1
    },
    nashorn: {
      __DIR__: !1,
      __FILE__: !1,
      __LINE__: !1,
      com: !1,
      edu: !1,
      exit: !1,
      java: !1,
      Java: !1,
      javafx: !1,
      JavaImporter: !1,
      javax: !1,
      JSAdapter: !1,
      load: !1,
      loadWithNewGlobal: !1,
      org: !1,
      Packages: !1,
      print: !1,
      quit: !1
    },
    wsh: {
      ActiveXObject: !0,
      Enumerator: !0,
      GetObject: !0,
      ScriptEngine: !0,
      ScriptEngineBuildVersion: !0,
      ScriptEngineMajorVersion: !0,
      ScriptEngineMinorVersion: !0,
      VBArray: !0,
      WScript: !0,
      WSH: !0,
      XDomainRequest: !0
    },
    jquery: {
      $: !1,
      jQuery: !1
    },
    yui: {
      YAHOO: !1,
      YAHOO_config: !1,
      YUI: !1,
      YUI_config: !1
    },
    shelljs: {
      cat: !1,
      cd: !1,
      chmod: !1,
      config: !1,
      cp: !1,
      dirs: !1,
      echo: !1,
      env: !1,
      error: !1,
      exec: !1,
      exit: !1,
      find: !1,
      grep: !1,
      ln: !1,
      ls: !1,
      mkdir: !1,
      mv: !1,
      popd: !1,
      pushd: !1,
      pwd: !1,
      rm: !1,
      sed: !1,
      set: !1,
      target: !1,
      tempdir: !1,
      test: !1,
      touch: !1,
      which: !1
    },
    prototypejs: {
      $: !1,
      $$: !1,
      $A: !1,
      $break: !1,
      $continue: !1,
      $F: !1,
      $H: !1,
      $R: !1,
      $w: !1,
      Abstract: !1,
      Ajax: !1,
      Autocompleter: !1,
      Builder: !1,
      Class: !1,
      Control: !1,
      Draggable: !1,
      Draggables: !1,
      Droppables: !1,
      Effect: !1,
      Element: !1,
      Enumerable: !1,
      Event: !1,
      Field: !1,
      Form: !1,
      Hash: !1,
      Insertion: !1,
      ObjectRange: !1,
      PeriodicalExecuter: !1,
      Position: !1,
      Prototype: !1,
      Scriptaculous: !1,
      Selector: !1,
      Sortable: !1,
      SortableObserver: !1,
      Sound: !1,
      Template: !1,
      Toggle: !1,
      Try: !1
    },
    meteor: {
      _: !1,
      $: !1,
      Accounts: !1,
      AccountsClient: !1,
      AccountsCommon: !1,
      AccountsServer: !1,
      App: !1,
      Assets: !1,
      Blaze: !1,
      check: !1,
      Cordova: !1,
      DDP: !1,
      DDPRateLimiter: !1,
      DDPServer: !1,
      Deps: !1,
      EJSON: !1,
      Email: !1,
      HTTP: !1,
      Log: !1,
      Match: !1,
      Meteor: !1,
      Mongo: !1,
      MongoInternals: !1,
      Npm: !1,
      Package: !1,
      Plugin: !1,
      process: !1,
      Random: !1,
      ReactiveDict: !1,
      ReactiveVar: !1,
      Router: !1,
      ServiceConfiguration: !1,
      Session: !1,
      share: !1,
      Spacebars: !1,
      Template: !1,
      Tinytest: !1,
      Tracker: !1,
      UI: !1,
      Utils: !1,
      WebApp: !1,
      WebAppInternals: !1
    },
    mongo: {
      _isWindows: !1,
      _rand: !1,
      BulkWriteResult: !1,
      cat: !1,
      cd: !1,
      connect: !1,
      db: !1,
      getHostName: !1,
      getMemInfo: !1,
      hostname: !1,
      ISODate: !1,
      listFiles: !1,
      load: !1,
      ls: !1,
      md5sumFile: !1,
      mkdir: !1,
      Mongo: !1,
      NumberInt: !1,
      NumberLong: !1,
      ObjectId: !1,
      PlanCache: !1,
      print: !1,
      printjson: !1,
      pwd: !1,
      quit: !1,
      removeFile: !1,
      rs: !1,
      sh: !1,
      UUID: !1,
      version: !1,
      WriteResult: !1
    },
    applescript: {
      $: !1,
      Application: !1,
      Automation: !1,
      console: !1,
      delay: !1,
      Library: !1,
      ObjC: !1,
      ObjectSpecifier: !1,
      Path: !1,
      Progress: !1,
      Ref: !1
    },
    serviceworker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      clearInterval: !1,
      clearTimeout: !1,
      Client: !1,
      clients: !1,
      Clients: !1,
      close: !0,
      console: !1,
      ExtendableEvent: !1,
      ExtendableMessageEvent: !1,
      fetch: !1,
      FetchEvent: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !1,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onfetch: !0,
      oninstall: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onmessageerror: !0,
      onnotificationclick: !0,
      onnotificationclose: !0,
      onoffline: !0,
      ononline: !0,
      onpush: !0,
      onpushsubscriptionchange: !0,
      onrejectionhandled: !0,
      onsync: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      registration: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerGlobalScope: !1,
      ServiceWorkerMessageEvent: !1,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      skipWaiting: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      WindowClient: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    atomtest: {
      advanceClock: !1,
      fakeClearInterval: !1,
      fakeClearTimeout: !1,
      fakeSetInterval: !1,
      fakeSetTimeout: !1,
      resetTimeouts: !1,
      waitsForPromise: !1
    },
    embertest: {
      andThen: !1,
      click: !1,
      currentPath: !1,
      currentRouteName: !1,
      currentURL: !1,
      fillIn: !1,
      find: !1,
      findAll: !1,
      findWithAssert: !1,
      keyEvent: !1,
      pauseTest: !1,
      resumeTest: !1,
      triggerEvent: !1,
      visit: !1,
      wait: !1
    },
    protractor: {
      $: !1,
      $$: !1,
      browser: !1,
      by: !1,
      By: !1,
      DartObject: !1,
      element: !1,
      protractor: !1
    },
    "shared-node-browser": {
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      setInterval: !1,
      setTimeout: !1,
      URL: !1,
      URLSearchParams: !1
    },
    webextensions: {
      browser: !1,
      chrome: !1,
      opr: !1
    },
    greasemonkey: {
      cloneInto: !1,
      createObjectIn: !1,
      exportFunction: !1,
      GM: !1,
      GM_addStyle: !1,
      GM_deleteValue: !1,
      GM_getResourceText: !1,
      GM_getResourceURL: !1,
      GM_getValue: !1,
      GM_info: !1,
      GM_listValues: !1,
      GM_log: !1,
      GM_openInTab: !1,
      GM_registerMenuCommand: !1,
      GM_setClipboard: !1,
      GM_setValue: !1,
      GM_xmlhttpRequest: !1,
      unsafeWindow: !1
    },
    devtools: {
      $: !1,
      $_: !1,
      $$: !1,
      $0: !1,
      $1: !1,
      $2: !1,
      $3: !1,
      $4: !1,
      $x: !1,
      chrome: !1,
      clear: !1,
      copy: !1,
      debug: !1,
      dir: !1,
      dirxml: !1,
      getEventListeners: !1,
      inspect: !1,
      keys: !1,
      monitor: !1,
      monitorEvents: !1,
      profile: !1,
      profileEnd: !1,
      queryObjects: !1,
      table: !1,
      undebug: !1,
      unmonitor: !1,
      unmonitorEvents: !1,
      values: !1
    }
  };
});

// ../node_modules/@babel/traverse/node_modules/globals/index.js
var Qd = v((XZ, zd) => {
  "use strict";
  zd.exports = Gd();
});

// ../node_modules/@babel/traverse/lib/scope/index.js
var fu = v((Nn) => {
  "use strict";
  Object.defineProperty(Nn, "__esModule", {
    value: !0
  });
  Nn.default = void 0;
  var S8 = $d(), x8 = Rr(), E8 = Hd(), P8 = Qd(), lm = le(), A8 = lm, Zd = Fr(), v8 = es(), {
    NOT_LOCAL_BINDING: em,
    callExpression: tm,
    cloneNode: rm,
    getBindingIdentifiers: C8,
    identifier: ui,
    isArrayExpression: im,
    isBinary: I8,
    isCallExpression: sm,
    isClass: w8,
    isClassBody: O8,
    isClassDeclaration: N8,
    isExportAllDeclaration: um,
    isExportDefaultDeclaration: _8,
    isExportNamedDeclaration: uu,
    isFunctionDeclaration: D8,
    isIdentifier: jr,
    isImportDeclaration: cu,
    isLiteral: k8,
    isMemberExpression: L8,
    isMethod: M8,
    isModuleSpecifier: F8,
    isNullLiteral: B8,
    isObjectExpression: j8,
    isProperty: R8,
    isPureish: q8,
    isRegExpLiteral: V8,
    isSuper: U8,
    isTaggedTemplateExpression: K8,
    isTemplateLiteral: cm,
    isThisExpression: nm,
    isUnaryExpression: W8,
    isVariableDeclaration: Y8,
    matchesPattern: am,
    memberExpression: pu,
    numericLiteral: X8,
    toIdentifier: J8,
    variableDeclaration: $8,
    variableDeclarator: H8,
    isRecordExpression: G8,
    isTupleExpression: z8,
    isObjectProperty: Q8,
    isTopicReference: om,
    isMetaProperty: Z8,
    isPrivateName: e9,
    isExportDeclaration: t9,
    buildUndefinedNode: r9
  } = lm;
  function Le(e, t) {
    switch (e?.type) {
      default:
        if (cu(e) || t9(e)) {
          var r;
          if ((um(e) || uu(e) || cu(e)) && e.source)
            Le(e.source, t);
          else if ((uu(e) || cu(e)) && (r = e.specifiers) != null && r.length)
            for (let i of e.specifiers) Le(i, t);
          else (_8(e) || uu(e)) && e.declaration && Le(e.declaration, t);
        } else F8(e) ? Le(e.local, t) : k8(e) && !B8(e) && !V8(e) && !cm(e) && t.push(e.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        Le(e.object, t), Le(e.property, t);
        break;
      case "Identifier":
      case "JSXIdentifier":
        t.push(e.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        Le(e.callee, t);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let i of e.properties)
          Le(i, t);
        break;
      case "SpreadElement":
      case "RestElement":
        Le(e.argument, t);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        Le(e.key, t);
        break;
      case "ThisExpression":
        t.push("this");
        break;
      case "Super":
        t.push("super");
        break;
      case "Import":
        t.push("import");
        break;
      case "DoExpression":
        t.push("do");
        break;
      case "YieldExpression":
        t.push("yield"), Le(e.argument, t);
        break;
      case "AwaitExpression":
        t.push("await"), Le(e.argument, t);
        break;
      case "AssignmentExpression":
        Le(e.left, t);
        break;
      case "VariableDeclarator":
        Le(e.id, t);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        Le(e.id, t);
        break;
      case "PrivateName":
        Le(e.id, t);
        break;
      case "ParenthesizedExpression":
        Le(e.expression, t);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        Le(e.argument, t);
        break;
      case "MetaProperty":
        Le(e.meta, t), Le(e.property, t);
        break;
      case "JSXElement":
        Le(e.openingElement, t);
        break;
      case "JSXOpeningElement":
        Le(e.name, t);
        break;
      case "JSXFragment":
        Le(e.openingFragment, t);
        break;
      case "JSXOpeningFragment":
        t.push("Fragment");
        break;
      case "JSXNamespacedName":
        Le(e.namespace, t), Le(e.name, t);
        break;
    }
  }
  s(Le, "gatherNodeParts");
  var On = {
    ForStatement(e) {
      let t = e.get("init");
      if (t.isVar()) {
        let {
          scope: r
        } = e;
        (r.getFunctionParent() || r.getProgramParent()).registerBinding("var", t);
      }
    },
    Declaration(e) {
      if (e.isBlockScoped() || e.isImportDeclaration() || e.isExportDeclaration()) return;
      (e.scope.getFunctionParent() || e.scope.getProgramParent()).registerDeclaration(e);
    },
    ImportDeclaration(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    ReferencedIdentifier(e, t) {
      t.references.push(e);
    },
    ForXStatement(e, t) {
      let r = e.get("left");
      if (r.isPattern() || r.isIdentifier())
        t.constantViolations.push(e);
      else if (r.isVar()) {
        let {
          scope: i
        } = e;
        (i.getFunctionParent() || i.getProgramParent()).registerBinding("var", r);
      }
    },
    ExportDeclaration: {
      exit(e) {
        let {
          node: t,
          scope: r
        } = e;
        if (um(t)) return;
        let i = t.declaration;
        if (N8(i) || D8(i)) {
          let n = i.id;
          if (!n) return;
          let a = r.getBinding(n.name);
          a?.reference(e);
        } else if (Y8(i))
          for (let n of i.declarations)
            for (let a of Object.keys(C8(n))) {
              let o = r.getBinding(a);
              o?.reference(e);
            }
      }
    },
    LabeledStatement(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    AssignmentExpression(e, t) {
      t.assignments.push(e);
    },
    UpdateExpression(e, t) {
      t.constantViolations.push(e);
    },
    UnaryExpression(e, t) {
      e.node.operator === "delete" && t.constantViolations.push(e);
    },
    BlockScoped(e) {
      let t = e.scope;
      if (t.path === e && (t = t.parent), t.getBlockParent().registerDeclaration(e), e.isClassDeclaration() && e.node.id) {
        let n = e.node.id.name;
        e.scope.bindings[n] = e.scope.parent.getBinding(n);
      }
    },
    CatchClause(e) {
      e.scope.registerBinding("let", e);
    },
    Function(e) {
      let t = e.get("params");
      for (let r of t)
        e.scope.registerBinding("param", r);
      e.isFunctionExpression() && e.has("id") && !e.get("id").node[em] && e.scope.registerBinding("local", e.get("id"), e);
    },
    ClassExpression(e) {
      e.has("id") && !e.get("id").node[em] && e.scope.registerBinding("local", e);
    }
  }, i9 = 0, ts = class e {
    static {
      s(this, "Scope");
    }
    constructor(t) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references =
      void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: r
      } = t, i = Zd.scope.get(r);
      if (i?.path === t)
        return i;
      Zd.scope.set(r, this), this.uid = i9++, this.block = r, this.path = t, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var t;
      let r, i = this.path;
      do {
        let n = i.key === "key" || i.listKey === "decorators";
        i = i.parentPath, n && i.isMethod() && (i = i.parentPath), i && i.isScope() && (r = i);
      } while (i && !r);
      return (t = r) == null ? void 0 : t.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(t, r, i) {
      (0, x8.default)(t, r, this, i, this.path);
    }
    generateDeclaredUidIdentifier(t) {
      let r = this.generateUidIdentifier(t);
      return this.push({
        id: r
      }), rm(r);
    }
    generateUidIdentifier(t) {
      return ui(this.generateUid(t));
    }
    generateUid(t = "temp") {
      t = J8(t).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let r, i = 1;
      do
        r = this._generateUid(t, i), i++;
      while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r));
      let n = this.getProgramParent();
      return n.references[r] = !0, n.uids[r] = !0, r;
    }
    _generateUid(t, r) {
      let i = t;
      return r > 1 && (i += r), `_${i}`;
    }
    generateUidBasedOnNode(t, r) {
      let i = [];
      Le(t, i);
      let n = i.join("$");
      return n = n.replace(/^_/, "") || r || "ref", this.generateUid(n.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(t, r) {
      return ui(this.generateUidBasedOnNode(t, r));
    }
    isStatic(t) {
      if (nm(t) || U8(t) || om(t))
        return !0;
      if (jr(t)) {
        let r = this.getBinding(t.name);
        return r ? r.constant : this.hasBinding(t.name);
      }
      return !1;
    }
    maybeGenerateMemoised(t, r) {
      if (this.isStatic(t))
        return null;
      {
        let i = this.generateUidIdentifierBasedOnNode(t);
        return r ? i : (this.push({
          id: i
        }), rm(i));
      }
    }
    checkBlockScopedCollisions(t, r, i, n) {
      if (r === "param" || t.kind === "local") return;
      if (r === "let" || t.kind === "let" || t.kind === "const" || t.kind === "module" || t.kind === "param" && r === "const")
        throw this.hub.buildError(n, `Duplicate declaration "${i}"`, TypeError);
    }
    rename(t, r) {
      let i = this.getBinding(t);
      i && (r || (r = this.generateUidIdentifier(t).name), new S8.default(i, t, r).rename(arguments[2]));
    }
    _renameFromMap(t, r, i, n) {
      t[r] && (t[i] = n, t[r] = null);
    }
    dump() {
      let t = "-".repeat(60);
      console.log(t);
      let r = this;
      do {
        console.log("#", r.block.type);
        for (let i of Object.keys(r.bindings)) {
          let n = r.bindings[i];
          console.log(" -", i, {
            constant: n.constant,
            references: n.references,
            violations: n.constantViolations.length,
            kind: n.kind
          });
        }
      } while (r = r.parent);
      console.log(t);
    }
    toArray(t, r, i) {
      if (jr(t)) {
        let o = this.getBinding(t.name);
        if (o != null && o.constant && o.path.isGenericType("Array"))
          return t;
      }
      if (im(t))
        return t;
      if (jr(t, {
        name: "arguments"
      }))
        return tm(pu(pu(pu(ui("Array"), ui("prototype")), ui("slice")), ui("call")), [t]);
      let n, a = [t];
      return r === !0 ? n = "toConsumableArray" : typeof r == "number" ? (a.push(X8(r)), n = "slicedToArray") : n = "toArray", i && (a.unshift(
      this.hub.addHelper(n)), n = "maybeArrayLike"), tm(this.hub.addHelper(n), a);
    }
    hasLabel(t) {
      return !!this.getLabel(t);
    }
    getLabel(t) {
      return this.labels.get(t);
    }
    registerLabel(t) {
      this.labels.set(t.node.label.name, t);
    }
    registerDeclaration(t) {
      if (t.isLabeledStatement())
        this.registerLabel(t);
      else if (t.isFunctionDeclaration())
        this.registerBinding("hoisted", t.get("id"), t);
      else if (t.isVariableDeclaration()) {
        let r = t.get("declarations"), {
          kind: i
        } = t.node;
        for (let n of r)
          this.registerBinding(i === "using" || i === "await using" ? "const" : i, n);
      } else if (t.isClassDeclaration()) {
        if (t.node.declare) return;
        this.registerBinding("let", t);
      } else if (t.isImportDeclaration()) {
        let r = t.node.importKind === "type" || t.node.importKind === "typeof", i = t.get("specifiers");
        for (let n of i) {
          let a = r || n.isImportSpecifier() && (n.node.importKind === "type" || n.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", n);
        }
      } else if (t.isExportDeclaration()) {
        let r = t.get("declaration");
        (r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) && this.registerDeclaration(r);
      } else
        this.registerBinding("unknown", t);
    }
    buildUndefinedNode() {
      return r9();
    }
    registerConstantViolation(t) {
      let r = t.getBindingIdentifiers();
      for (let n of Object.keys(r)) {
        var i;
        (i = this.getBinding(n)) == null || i.reassign(t);
      }
    }
    registerBinding(t, r, i = r) {
      if (!t) throw new ReferenceError("no `kind`");
      if (r.isVariableDeclaration()) {
        let o = r.get("declarations");
        for (let l of o)
          this.registerBinding(t, l);
        return;
      }
      let n = this.getProgramParent(), a = r.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        n.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, t, o, l);
          }
          u ? this.registerConstantViolation(i) : this.bindings[o] = new E8.default({
            identifier: l,
            scope: this,
            path: i,
            kind: t
          });
        }
      }
    }
    addGlobal(t) {
      this.globals[t.name] = t;
    }
    hasUid(t) {
      let r = this;
      do
        if (r.uids[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasGlobal(t) {
      let r = this;
      do
        if (r.globals[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasReference(t) {
      return !!this.getProgramParent().references[t];
    }
    isPure(t, r) {
      if (jr(t)) {
        let o = this.getBinding(t.name);
        return o ? r ? o.constant : !0 : !1;
      } else {
        if (nm(t) || Z8(t) || om(t) || e9(t))
          return !0;
        if (w8(t)) {
          var i;
          return t.superClass && !this.isPure(t.superClass, r) || ((i = t.decorators) == null ? void 0 : i.length) > 0 ? !1 : this.isPure(t.
          body, r);
        } else if (O8(t)) {
          for (let o of t.body)
            if (!this.isPure(o, r)) return !1;
          return !0;
        } else {
          if (I8(t))
            return this.isPure(t.left, r) && this.isPure(t.right, r);
          if (im(t) || z8(t)) {
            for (let o of t.elements)
              if (o !== null && !this.isPure(o, r)) return !1;
            return !0;
          } else if (j8(t) || G8(t)) {
            for (let o of t.properties)
              if (!this.isPure(o, r)) return !1;
            return !0;
          } else if (M8(t)) {
            var n;
            return !(t.computed && !this.isPure(t.key, r) || ((n = t.decorators) == null ? void 0 : n.length) > 0);
          } else if (R8(t)) {
            var a;
            return !(t.computed && !this.isPure(t.key, r) || ((a = t.decorators) == null ? void 0 : a.length) > 0 || (Q8(t) || t.static) && t.
            value !== null && !this.isPure(t.value, r));
          } else {
            if (W8(t))
              return this.isPure(t.argument, r);
            if (cm(t)) {
              for (let o of t.expressions)
                if (!this.isPure(o, r)) return !1;
              return !0;
            } else return K8(t) ? am(t.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(t.quasi, r) : L8(t) ? !t.computed && jr(t.object) && t.object.name === "Symbol" && jr(t.property) && t.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : sm(t) ? am(t.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && t.arguments.length === 1 && A8.isStringLiteral(t.arguments[0]) : q8(t);
          }
        }
      }
    }
    setData(t, r) {
      return this.data[t] = r;
    }
    getData(t) {
      let r = this;
      do {
        let i = r.data[t];
        if (i != null) return i;
      } while (r = r.parent);
    }
    removeData(t) {
      let r = this;
      do
        r.data[t] != null && (r.data[t] = null);
      while (r = r.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let t = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.
      create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      let r = this.getProgramParent();
      if (r.crawling) return;
      let i = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, t.type !== "Program" && (0, v8.isExplodedVisitor)(On)) {
        for (let a of On.enter)
          a.call(i, t, i);
        let n = On[t.type];
        if (n)
          for (let a of n.enter)
            a.call(i, t, i);
      }
      t.traverse(On, i), this.crawling = !1;
      for (let n of i.assignments) {
        let a = n.getBindingIdentifiers();
        for (let o of Object.keys(a))
          n.scope.getBinding(o) || r.addGlobal(a[o]);
        n.scope.registerConstantViolation(n);
      }
      for (let n of i.references) {
        let a = n.scope.getBinding(n.node.name);
        a ? a.reference(n) : r.addGlobal(n.node);
      }
      for (let n of i.constantViolations)
        n.scope.registerConstantViolation(n);
    }
    push(t) {
      let r = this.path;
      r.isPattern() ? r = this.getPatternParent().path : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path), r.isSwitchStatement() &&
      (r = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: i,
        unique: n,
        kind: a = "var",
        id: o
      } = t;
      if (!i && !n && (a === "var" || a === "let") && r.isFunction() && !r.node.name && sm(r.parent, {
        callee: r.node
      }) && r.parent.arguments.length <= r.node.params.length && jr(o)) {
        r.pushContainer("params", o), r.scope.registerBinding("param", r.get("params")[r.node.params.length - 1]);
        return;
      }
      (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), r = r.get("body"));
      let l = t._blockHoist == null ? 2 : t._blockHoist, u = `declaration:${a}:${l}`, c = !n && r.getData(u);
      if (!c) {
        let P = $8(a, []);
        P._blockHoist = l, [c] = r.unshiftContainer("body", [P]), n || r.setData(u, c);
      }
      let p = H8(o, i), g = c.node.declarations.push(p);
      r.scope.registerBinding(a, c.get("declarations")[g - 1]);
    }
    getProgramParent() {
      let t = this;
      do
        if (t.path.isProgram())
          return t;
      while (t = t.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let t = this;
      do
        if (t.path.isFunctionParent())
          return t;
      while (t = t.parent);
      return null;
    }
    getBlockParent() {
      let t = this;
      do
        if (t.path.isBlockParent())
          return t;
      while (t = t.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let t = this;
      do
        if (!t.path.isPattern())
          return t.getBlockParent();
      while (t = t.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let t = /* @__PURE__ */ Object.create(null), r = this;
      do {
        for (let i of Object.keys(r.bindings))
          i in t || (t[i] = r.bindings[i]);
        r = r.parent;
      } while (r);
      return t;
    }
    getAllBindingsOfKind(...t) {
      let r = /* @__PURE__ */ Object.create(null);
      for (let i of t) {
        let n = this;
        do {
          for (let a of Object.keys(n.bindings)) {
            let o = n.bindings[a];
            o.kind === i && (r[a] = o);
          }
          n = n.parent;
        } while (n);
      }
      return r;
    }
    bindingIdentifierEquals(t, r) {
      return this.getBindingIdentifier(t) === r;
    }
    getBinding(t) {
      let r = this, i;
      do {
        let a = r.getOwnBinding(t);
        if (a) {
          var n;
          if (!((n = i) != null && n.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && t === "arguments" && r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
        i = r.path;
      } while (r = r.parent);
    }
    getOwnBinding(t) {
      return this.bindings[t];
    }
    getBindingIdentifier(t) {
      var r;
      return (r = this.getBinding(t)) == null ? void 0 : r.identifier;
    }
    getOwnBindingIdentifier(t) {
      let r = this.bindings[t];
      return r?.identifier;
    }
    hasOwnBinding(t) {
      return !!this.getOwnBinding(t);
    }
    hasBinding(t, r) {
      var i, n, a;
      return t ? !!(this.hasOwnBinding(t) || (typeof r == "boolean" && (r = {
        noGlobals: r
      }), this.parentHasBinding(t, r)) || !((i = r) != null && i.noUids) && this.hasUid(t) || !((n = r) != null && n.noGlobals) && e.globals.
      includes(t) || !((a = r) != null && a.noGlobals) && e.contextVariables.includes(t)) : !1;
    }
    parentHasBinding(t, r) {
      var i;
      return (i = this.parent) == null ? void 0 : i.hasBinding(t, r);
    }
    moveBindingTo(t, r) {
      let i = this.getBinding(t);
      i && (i.scope.removeOwnBinding(t), i.scope = r, r.bindings[t] = i);
    }
    removeOwnBinding(t) {
      delete this.bindings[t];
    }
    removeBinding(t) {
      var r;
      (r = this.getBinding(t)) == null || r.scope.removeOwnBinding(t);
      let i = this;
      do
        i.uids[t] && (i.uids[t] = !1);
      while (i = i.parent);
    }
  };
  Nn.default = ts;
  ts.globals = Object.keys(P8.builtin);
  ts.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
});

// ../node_modules/@babel/traverse/lib/path/ancestry.js
var pm = v((vt) => {
  "use strict";
  Object.defineProperty(vt, "__esModule", {
    value: !0
  });
  vt.find = o9;
  vt.findParent = a9;
  vt.getAncestry = f9;
  vt.getDeepestCommonAncestorFrom = p9;
  vt.getEarliestCommonAncestorFrom = c9;
  vt.getFunctionParent = l9;
  vt.getStatementParent = u9;
  vt.inType = m9;
  vt.isAncestor = h9;
  vt.isDescendant = d9;
  var s9 = le(), {
    VISITOR_KEYS: n9
  } = s9;
  function a9(e) {
    let t = this;
    for (; t = t.parentPath; )
      if (e(t)) return t;
    return null;
  }
  s(a9, "findParent");
  function o9(e) {
    let t = this;
    do
      if (e(t)) return t;
    while (t = t.parentPath);
    return null;
  }
  s(o9, "find");
  function l9() {
    return this.findParent((e) => e.isFunction());
  }
  s(l9, "getFunctionParent");
  function u9() {
    let e = this;
    do {
      if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
        break;
      e = e.parentPath;
    } while (e);
    if (e && (e.isProgram() || e.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return e;
  }
  s(u9, "getStatementParent");
  function c9(e) {
    return this.getDeepestCommonAncestorFrom(e, function(t, r, i) {
      let n, a = n9[t.type];
      for (let o of i) {
        let l = o[r + 1];
        if (!n) {
          n = l;
          continue;
        }
        if (l.listKey && n.listKey === l.listKey && l.key < n.key) {
          n = l;
          continue;
        }
        let u = a.indexOf(n.parentKey), c = a.indexOf(l.parentKey);
        u > c && (n = l);
      }
      return n;
    });
  }
  s(c9, "getEarliestCommonAncestorFrom");
  function p9(e, t) {
    if (!e.length)
      return this;
    if (e.length === 1)
      return e[0];
    let r = 1 / 0, i, n, a = e.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < r && (r = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < r; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      i = l, n = u;
    }
    if (n)
      return t ? t(n, i, a) : n;
    throw new Error("Couldn't find intersection");
  }
  s(p9, "getDeepestCommonAncestorFrom");
  function f9() {
    let e = this, t = [];
    do
      t.push(e);
    while (e = e.parentPath);
    return t;
  }
  s(f9, "getAncestry");
  function h9(e) {
    return e.isDescendant(this);
  }
  s(h9, "isAncestor");
  function d9(e) {
    return !!this.findParent((t) => t === e);
  }
  s(d9, "isDescendant");
  function m9(...e) {
    let t = this;
    for (; t; ) {
      for (let r of e)
        if (t.node.type === r) return !0;
      t = t.parentPath;
    }
    return !1;
  }
  s(m9, "inType");
});

// ../node_modules/@babel/traverse/lib/path/inference/util.js
var du = v((hu) => {
  "use strict";
  Object.defineProperty(hu, "__esModule", {
    value: !0
  });
  hu.createUnionType = S9;
  var y9 = le(), {
    createFlowUnionType: fm,
    createTSUnionType: hm,
    createUnionTypeAnnotation: T9,
    isFlowType: g9,
    isTSType: b9
  } = y9;
  function S9(e) {
    {
      if (e.every((t) => g9(t)))
        return fm ? fm(e) : T9(e);
      if (e.every((t) => b9(t)) && hm)
        return hm(e);
    }
  }
  s(S9, "createUnionType");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var gm = v((mu) => {
  "use strict";
  Object.defineProperty(mu, "__esModule", {
    value: !0
  });
  mu.default = v9;
  var x9 = le(), mm = du(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: E9,
    createTypeAnnotationBasedOnTypeof: P9,
    numberTypeAnnotation: ym,
    voidTypeAnnotation: A9
  } = x9;
  function v9(e) {
    if (!this.isReferenced()) return;
    let t = this.scope.getBinding(e.name);
    if (t)
      return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : C9(t, this, e.name);
    if (e.name === "undefined")
      return A9();
    if (e.name === "NaN" || e.name === "Infinity")
      return ym();
    e.name;
  }
  s(v9, "_default");
  function C9(e, t, r) {
    let i = [], n = [], a = dm(e, t, n), o = Tm(e, t, r);
    if (o) {
      let l = dm(e, o.ifStatement);
      a = a.filter((u) => l.indexOf(u) < 0), i.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...n);
      for (let l of a)
        i.push(l.getTypeAnnotation());
    }
    if (i.length)
      return (0, mm.createUnionType)(i);
  }
  s(C9, "getTypeAnnotationBindingConstantViolations");
  function dm(e, t, r) {
    let i = e.constantViolations.slice();
    return i.unshift(e.path), i.filter((n) => {
      n = n.resolve();
      let a = n._guessExecutionStatusRelativeTo(t);
      return r && a === "unknown" && r.push(n), a === "before";
    });
  }
  s(dm, "getConstantViolationsBefore");
  function I9(e, t) {
    let r = t.node.operator, i = t.get("right").resolve(), n = t.get("left").resolve(), a;
    if (n.isIdentifier({
      name: e
    }) ? a = i : i.isIdentifier({
      name: e
    }) && (a = n), a)
      return r === "===" ? a.getTypeAnnotation() : E9.indexOf(r) >= 0 ? ym() : void 0;
    if (r !== "===" && r !== "==") return;
    let o, l;
    if (n.isUnaryExpression({
      operator: "typeof"
    }) ? (o = n, l = i) : i.isUnaryExpression({
      operator: "typeof"
    }) && (o = i, l = n), !o || !o.get("argument").isIdentifier({
      name: e
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return P9(u);
  }
  s(I9, "inferAnnotationFromBinaryExpression");
  function w9(e, t, r) {
    let i;
    for (; i = t.parentPath; ) {
      if (i.isIfStatement() || i.isConditionalExpression())
        return t.key === "test" ? void 0 : i;
      if (i.isFunction() && i.parentPath.scope.getBinding(r) !== e)
        return;
      t = i;
    }
  }
  s(w9, "getParentConditionalPath");
  function Tm(e, t, r) {
    let i = w9(e, t, r);
    if (!i) return;
    let a = [i.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = I9(r, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, mm.createUnionType)(o),
      ifStatement: i
    } : Tm(e, i, r);
  }
  s(Tm, "getConditionalAnnotation");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferers.js
var Cm = v((Ae) => {
  "use strict";
  Object.defineProperty(Ae, "__esModule", {
    value: !0
  });
  Ae.ArrayExpression = Pm;
  Ae.AssignmentExpression = z9;
  Ae.BinaryExpression = X9;
  Ae.BooleanLiteral = t7;
  Ae.CallExpression = c7;
  Ae.ConditionalExpression = $9;
  Ae.ClassDeclaration = Ae.ClassExpression = Ae.FunctionDeclaration = Ae.ArrowFunctionExpression = Ae.FunctionExpression = n7;
  Object.defineProperty(Ae, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return N9.default;
    }, "get")
  });
  Ae.LogicalExpression = J9;
  Ae.NewExpression = K9;
  Ae.NullLiteral = r7;
  Ae.NumericLiteral = e7;
  Ae.ObjectExpression = s7;
  Ae.ParenthesizedExpression = G9;
  Ae.RegExpLiteral = i7;
  Ae.RestElement = Am;
  Ae.SequenceExpression = H9;
  Ae.StringLiteral = Z9;
  Ae.TSAsExpression = Em;
  Ae.TSNonNullExpression = U9;
  Ae.TaggedTemplateExpression = p7;
  Ae.TemplateLiteral = W9;
  Ae.TypeCastExpression = xm;
  Ae.UnaryExpression = Y9;
  Ae.UpdateExpression = Q9;
  Ae.VariableDeclarator = V9;
  var O9 = le(), N9 = gm(), Sm = du(), {
    BOOLEAN_BINARY_OPERATORS: _9,
    BOOLEAN_UNARY_OPERATORS: D9,
    NUMBER_BINARY_OPERATORS: k9,
    NUMBER_UNARY_OPERATORS: L9,
    STRING_UNARY_OPERATORS: M9,
    anyTypeAnnotation: bm,
    arrayTypeAnnotation: yu,
    booleanTypeAnnotation: Tu,
    buildMatchMemberExpression: _n,
    genericTypeAnnotation: pr,
    identifier: qr,
    nullLiteralTypeAnnotation: F9,
    numberTypeAnnotation: ci,
    stringTypeAnnotation: Vr,
    tupleTypeAnnotation: B9,
    unionTypeAnnotation: j9,
    voidTypeAnnotation: R9,
    isIdentifier: q9
  } = O9;
  function V9() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  s(V9, "VariableDeclarator");
  function xm(e) {
    return e.typeAnnotation;
  }
  s(xm, "TypeCastExpression");
  xm.validParent = !0;
  function Em(e) {
    return e.typeAnnotation;
  }
  s(Em, "TSAsExpression");
  Em.validParent = !0;
  function U9() {
    return this.get("expression").getTypeAnnotation();
  }
  s(U9, "TSNonNullExpression");
  function K9(e) {
    if (e.callee.type === "Identifier")
      return pr(e.callee);
  }
  s(K9, "NewExpression");
  function W9() {
    return Vr();
  }
  s(W9, "TemplateLiteral");
  function Y9(e) {
    let t = e.operator;
    if (t === "void")
      return R9();
    if (L9.indexOf(t) >= 0)
      return ci();
    if (M9.indexOf(t) >= 0)
      return Vr();
    if (D9.indexOf(t) >= 0)
      return Tu();
  }
  s(Y9, "UnaryExpression");
  function X9(e) {
    let t = e.operator;
    if (k9.indexOf(t) >= 0)
      return ci();
    if (_9.indexOf(t) >= 0)
      return Tu();
    if (t === "+") {
      let r = this.get("right"), i = this.get("left");
      return i.isBaseType("number") && r.isBaseType("number") ? ci() : i.isBaseType("string") || r.isBaseType("string") ? Vr() : j9([Vr(), ci()]);
    }
  }
  s(X9, "BinaryExpression");
  function J9() {
    let e = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, Sm.createUnionType)(e);
  }
  s(J9, "LogicalExpression");
  function $9() {
    let e = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, Sm.createUnionType)(e);
  }
  s($9, "ConditionalExpression");
  function H9() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  s(H9, "SequenceExpression");
  function G9() {
    return this.get("expression").getTypeAnnotation();
  }
  s(G9, "ParenthesizedExpression");
  function z9() {
    return this.get("right").getTypeAnnotation();
  }
  s(z9, "AssignmentExpression");
  function Q9(e) {
    let t = e.operator;
    if (t === "++" || t === "--")
      return ci();
  }
  s(Q9, "UpdateExpression");
  function Z9() {
    return Vr();
  }
  s(Z9, "StringLiteral");
  function e7() {
    return ci();
  }
  s(e7, "NumericLiteral");
  function t7() {
    return Tu();
  }
  s(t7, "BooleanLiteral");
  function r7() {
    return F9();
  }
  s(r7, "NullLiteral");
  function i7() {
    return pr(qr("RegExp"));
  }
  s(i7, "RegExpLiteral");
  function s7() {
    return pr(qr("Object"));
  }
  s(s7, "ObjectExpression");
  function Pm() {
    return pr(qr("Array"));
  }
  s(Pm, "ArrayExpression");
  function Am() {
    return Pm();
  }
  s(Am, "RestElement");
  Am.validParent = !0;
  function n7() {
    return pr(qr("Function"));
  }
  s(n7, "Func");
  var a7 = _n("Array.from"), o7 = _n("Object.keys"), l7 = _n("Object.values"), u7 = _n("Object.entries");
  function c7() {
    let {
      callee: e
    } = this.node;
    return o7(e) ? yu(Vr()) : a7(e) || l7(e) || q9(e, {
      name: "Array"
    }) ? yu(bm()) : u7(e) ? yu(B9([Vr(), bm()])) : vm(this.get("callee"));
  }
  s(c7, "CallExpression");
  function p7() {
    return vm(this.get("tag"));
  }
  s(p7, "TaggedTemplateExpression");
  function vm(e) {
    if (e = e.resolve(), e.isFunction()) {
      let {
        node: t
      } = e;
      if (t.async)
        return t.generator ? pr(qr("AsyncIterator")) : pr(qr("Promise"));
      if (t.generator)
        return pr(qr("Iterator"));
      if (e.node.returnType)
        return e.node.returnType;
    }
  }
  s(vm, "resolveCall");
});

// ../node_modules/@babel/traverse/lib/path/inference/index.js
var Nm = v((fr) => {
  "use strict";
  Object.defineProperty(fr, "__esModule", {
    value: !0
  });
  fr._getTypeAnnotation = _7;
  fr.baseTypeStrictlyMatches = L7;
  fr.couldBeBaseType = k7;
  fr.getTypeAnnotation = N7;
  fr.isBaseType = D7;
  fr.isGenericType = M7;
  var Im = Cm(), f7 = le(), {
    anyTypeAnnotation: Om,
    isAnyTypeAnnotation: Dn,
    isArrayTypeAnnotation: h7,
    isBooleanTypeAnnotation: d7,
    isEmptyTypeAnnotation: m7,
    isFlowBaseAnnotation: y7,
    isGenericTypeAnnotation: T7,
    isIdentifier: wm,
    isMixedTypeAnnotation: g7,
    isNumberTypeAnnotation: b7,
    isStringTypeAnnotation: S7,
    isTSArrayType: x7,
    isTSTypeAnnotation: E7,
    isTSTypeReference: P7,
    isTupleTypeAnnotation: A7,
    isTypeAnnotation: v7,
    isUnionTypeAnnotation: C7,
    isVoidTypeAnnotation: I7,
    stringTypeAnnotation: w7,
    voidTypeAnnotation: O7
  } = f7;
  function N7() {
    let e = this.getData("typeAnnotation");
    return e != null || (e = this._getTypeAnnotation() || Om(), (v7(e) || E7(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)),
    e;
  }
  s(N7, "getTypeAnnotation");
  var gu = /* @__PURE__ */ new WeakSet();
  function _7() {
    let e = this.node;
    if (!e)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let r = this.parentPath.parentPath, i = r.parentPath;
        return r.key === "left" && i.isForInStatement() ? w7() : r.key === "left" && i.isForOfStatement() ? Om() : O7();
      } else
        return;
    if (e.typeAnnotation)
      return e.typeAnnotation;
    if (!gu.has(e)) {
      gu.add(e);
      try {
        var t;
        let r = Im[e.type];
        if (r)
          return r.call(this, e);
        if (r = Im[this.parentPath.type], (t = r) != null && t.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        gu.delete(e);
      }
    }
  }
  s(_7, "_getTypeAnnotation");
  function D7(e, t) {
    return bu(e, this.getTypeAnnotation(), t);
  }
  s(D7, "isBaseType");
  function bu(e, t, r) {
    if (e === "string")
      return S7(t);
    if (e === "number")
      return b7(t);
    if (e === "boolean")
      return d7(t);
    if (e === "any")
      return Dn(t);
    if (e === "mixed")
      return g7(t);
    if (e === "empty")
      return m7(t);
    if (e === "void")
      return I7(t);
    if (r)
      return !1;
    throw new Error(`Unknown base type ${e}`);
  }
  s(bu, "_isBaseType");
  function k7(e) {
    let t = this.getTypeAnnotation();
    if (Dn(t)) return !0;
    if (C7(t)) {
      for (let r of t.types)
        if (Dn(r) || bu(e, r, !0))
          return !0;
      return !1;
    } else
      return bu(e, t, !0);
  }
  s(k7, "couldBeBaseType");
  function L7(e) {
    let t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
    return !Dn(t) && y7(t) ? r.type === t.type : !1;
  }
  s(L7, "baseTypeStrictlyMatches");
  function M7(e) {
    let t = this.getTypeAnnotation();
    return e === "Array" && (x7(t) || h7(t) || A7(t)) ? !0 : T7(t) && wm(t.id, {
      name: e
    }) || P7(t) && wm(t.typeName, {
      name: e
    });
  }
  s(M7, "isGenericType");
});

// ../node_modules/js-tokens/index.js
var _m = v((kn) => {
  Object.defineProperty(kn, "__esModule", {
    value: !0
  });
  kn.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  kn.matchToToken = function(e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) :
    e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "white\
space"), t;
  };
});

// ../node_modules/picocolors/picocolors.js
var xu = v((aee, Su) => {
  var F7 = require("tty"), B7 = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.
  argv.includes("--color") || process.platform === "win32" || F7.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env), je = /* @__PURE__ */ s(
  (e, t, r = e) => (i) => {
    let n = "" + i, a = n.indexOf(t, e.length);
    return ~a ? e + Dm(n, t, r, a) + t : e + n + t;
  }, "formatter"), Dm = /* @__PURE__ */ s((e, t, r, i) => {
    let n = e.substring(0, i) + r, a = e.substring(i + t.length), o = a.indexOf(t);
    return ~o ? n + Dm(a, t, r, o) : n + a;
  }, "replaceClose"), km = /* @__PURE__ */ s((e = B7) => ({
    isColorSupported: e,
    reset: e ? (t) => `\x1B[0m${t}\x1B[0m` : String,
    bold: e ? je("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
    dim: e ? je("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
    italic: e ? je("\x1B[3m", "\x1B[23m") : String,
    underline: e ? je("\x1B[4m", "\x1B[24m") : String,
    inverse: e ? je("\x1B[7m", "\x1B[27m") : String,
    hidden: e ? je("\x1B[8m", "\x1B[28m") : String,
    strikethrough: e ? je("\x1B[9m", "\x1B[29m") : String,
    black: e ? je("\x1B[30m", "\x1B[39m") : String,
    red: e ? je("\x1B[31m", "\x1B[39m") : String,
    green: e ? je("\x1B[32m", "\x1B[39m") : String,
    yellow: e ? je("\x1B[33m", "\x1B[39m") : String,
    blue: e ? je("\x1B[34m", "\x1B[39m") : String,
    magenta: e ? je("\x1B[35m", "\x1B[39m") : String,
    cyan: e ? je("\x1B[36m", "\x1B[39m") : String,
    white: e ? je("\x1B[37m", "\x1B[39m") : String,
    gray: e ? je("\x1B[90m", "\x1B[39m") : String,
    bgBlack: e ? je("\x1B[40m", "\x1B[49m") : String,
    bgRed: e ? je("\x1B[41m", "\x1B[49m") : String,
    bgGreen: e ? je("\x1B[42m", "\x1B[49m") : String,
    bgYellow: e ? je("\x1B[43m", "\x1B[49m") : String,
    bgBlue: e ? je("\x1B[44m", "\x1B[49m") : String,
    bgMagenta: e ? je("\x1B[45m", "\x1B[49m") : String,
    bgCyan: e ? je("\x1B[46m", "\x1B[49m") : String,
    bgWhite: e ? je("\x1B[47m", "\x1B[49m") : String
  }), "createColors");
  Su.exports = km();
  Su.exports.createColors = km;
});

// ../node_modules/escape-string-regexp/index.js
var Mm = v((lee, Lm) => {
  "use strict";
  var j7 = /[|\\{}()[\]^$+*?.]/g;
  Lm.exports = function(e) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return e.replace(j7, "\\$&");
  };
});

// ../node_modules/@babel/highlight/node_modules/color-name/index.js
var Bm = v((uee, Fm) => {
  "use strict";
  Fm.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var Eu = v((cee, Vm) => {
  var Ur = Bm(), qm = {};
  for (Ln in Ur)
    Ur.hasOwnProperty(Ln) && (qm[Ur[Ln]] = Ln);
  var Ln, z = Vm.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (pt in z)
    if (z.hasOwnProperty(pt)) {
      if (!("channels" in z[pt]))
        throw new Error("missing channels property: " + pt);
      if (!("labels" in z[pt]))
        throw new Error("missing channel labels property: " + pt);
      if (z[pt].labels.length !== z[pt].channels)
        throw new Error("channel and label counts mismatch: " + pt);
      jm = z[pt].channels, Rm = z[pt].labels, delete z[pt].channels, delete z[pt].labels, Object.defineProperty(z[pt], "channels", { value: jm }),
      Object.defineProperty(z[pt], "labels", { value: Rm });
    }
  var jm, Rm, pt;
  z.rgb.hsl = function(e) {
    var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255, n = Math.min(t, r, i), a = Math.max(t, r, i), o = a - n, l, u, c;
    return a === n ? l = 0 : t === a ? l = (r - i) / o : r === a ? l = 2 + (i - t) / o : i === a && (l = 4 + (t - r) / o), l = Math.min(l * 60,
    360), l < 0 && (l += 360), c = (n + a) / 2, a === n ? u = 0 : c <= 0.5 ? u = o / (a + n) : u = o / (2 - a - n), [l, u * 100, c * 100];
  };
  z.rgb.hsv = function(e) {
    var t, r, i, n, a, o = e[0] / 255, l = e[1] / 255, u = e[2] / 255, c = Math.max(o, l, u), p = c - Math.min(o, l, u), g = /* @__PURE__ */ s(
    function(P) {
      return (c - P) / 6 / p + 1 / 2;
    }, "diffc");
    return p === 0 ? n = a = 0 : (a = p / c, t = g(o), r = g(l), i = g(u), o === c ? n = i - r : l === c ? n = 1 / 3 + t - i : u === c && (n =
    2 / 3 + r - t), n < 0 ? n += 1 : n > 1 && (n -= 1)), [
      n * 360,
      a * 100,
      c * 100
    ];
  };
  z.rgb.hwb = function(e) {
    var t = e[0], r = e[1], i = e[2], n = z.rgb.hsl(e)[0], a = 1 / 255 * Math.min(t, Math.min(r, i));
    return i = 1 - 1 / 255 * Math.max(t, Math.max(r, i)), [n, a * 100, i * 100];
  };
  z.rgb.cmyk = function(e) {
    var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255, n, a, o, l;
    return l = Math.min(1 - t, 1 - r, 1 - i), n = (1 - t - l) / (1 - l) || 0, a = (1 - r - l) / (1 - l) || 0, o = (1 - i - l) / (1 - l) || 0,
    [n * 100, a * 100, o * 100, l * 100];
  };
  function R7(e, t) {
    return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2);
  }
  s(R7, "comparativeDistance");
  z.rgb.keyword = function(e) {
    var t = qm[e];
    if (t)
      return t;
    var r = 1 / 0, i;
    for (var n in Ur)
      if (Ur.hasOwnProperty(n)) {
        var a = Ur[n], o = R7(e, a);
        o < r && (r = o, i = n);
      }
    return i;
  };
  z.keyword.rgb = function(e) {
    return Ur[e];
  };
  z.rgb.xyz = function(e) {
    var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255;
    t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, i = i >
    0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92;
    var n = t * 0.4124 + r * 0.3576 + i * 0.1805, a = t * 0.2126 + r * 0.7152 + i * 0.0722, o = t * 0.0193 + r * 0.1192 + i * 0.9505;
    return [n * 100, a * 100, o * 100];
  };
  z.rgb.lab = function(e) {
    var t = z.rgb.xyz(e), r = t[0], i = t[1], n = t[2], a, o, l;
    return r /= 95.047, i /= 100, n /= 108.883, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 /
    3) : 7.787 * i + 16 / 116, n = n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, a = 116 * i - 16, o = 500 * (r - i), l = 200 * (i -
    n), [a, o, l];
  };
  z.hsl.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, i = e[2] / 100, n, a, o, l, u;
    if (r === 0)
      return u = i * 255, [u, u, u];
    i < 0.5 ? a = i * (1 + r) : a = i + r - i * r, n = 2 * i - a, l = [0, 0, 0];
    for (var c = 0; c < 3; c++)
      o = t + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? u = n + (a - n) * 6 * o : 2 * o < 1 ? u = a : 3 * o < 2 ? u = n + (a -
      n) * (2 / 3 - o) * 6 : u = n, l[c] = u * 255;
    return l;
  };
  z.hsl.hsv = function(e) {
    var t = e[0], r = e[1] / 100, i = e[2] / 100, n = r, a = Math.max(i, 0.01), o, l;
    return i *= 2, r *= i <= 1 ? i : 2 - i, n *= a <= 1 ? a : 2 - a, l = (i + r) / 2, o = i === 0 ? 2 * n / (a + n) : 2 * r / (i + r), [t, o *
    100, l * 100];
  };
  z.hsv.rgb = function(e) {
    var t = e[0] / 60, r = e[1] / 100, i = e[2] / 100, n = Math.floor(t) % 6, a = t - Math.floor(t), o = 255 * i * (1 - r), l = 255 * i * (1 -
    r * a), u = 255 * i * (1 - r * (1 - a));
    switch (i *= 255, n) {
      case 0:
        return [i, u, o];
      case 1:
        return [l, i, o];
      case 2:
        return [o, i, u];
      case 3:
        return [o, l, i];
      case 4:
        return [u, o, i];
      case 5:
        return [i, o, l];
    }
  };
  z.hsv.hsl = function(e) {
    var t = e[0], r = e[1] / 100, i = e[2] / 100, n = Math.max(i, 0.01), a, o, l;
    return l = (2 - r) * i, a = (2 - r) * n, o = r * n, o /= a <= 1 ? a : 2 - a, o = o || 0, l /= 2, [t, o * 100, l * 100];
  };
  z.hwb.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, i = e[2] / 100, n = r + i, a, o, l, u;
    n > 1 && (r /= n, i /= n), a = Math.floor(6 * t), o = 1 - i, l = 6 * t - a, a & 1 && (l = 1 - l), u = r + l * (o - r);
    var c, p, g;
    switch (a) {
      default:
      case 6:
      case 0:
        c = o, p = u, g = r;
        break;
      case 1:
        c = u, p = o, g = r;
        break;
      case 2:
        c = r, p = o, g = u;
        break;
      case 3:
        c = r, p = u, g = o;
        break;
      case 4:
        c = u, p = r, g = o;
        break;
      case 5:
        c = o, p = r, g = u;
        break;
    }
    return [c * 255, p * 255, g * 255];
  };
  z.cmyk.rgb = function(e) {
    var t = e[0] / 100, r = e[1] / 100, i = e[2] / 100, n = e[3] / 100, a, o, l;
    return a = 1 - Math.min(1, t * (1 - n) + n), o = 1 - Math.min(1, r * (1 - n) + n), l = 1 - Math.min(1, i * (1 - n) + n), [a * 255, o * 255,
    l * 255];
  };
  z.xyz.rgb = function(e) {
    var t = e[0] / 100, r = e[1] / 100, i = e[2] / 100, n, a, o;
    return n = t * 3.2406 + r * -1.5372 + i * -0.4986, a = t * -0.9689 + r * 1.8758 + i * 0.0415, o = t * 0.0557 + r * -0.204 + i * 1.057, n =
    n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92, o =
    o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, n = Math.min(Math.max(0, n), 1), a = Math.min(Math.max(0, a), 1), o = Math.
    min(Math.max(0, o), 1), [n * 255, a * 255, o * 255];
  };
  z.xyz.lab = function(e) {
    var t = e[0], r = e[1], i = e[2], n, a, o;
    return t /= 95.047, r /= 100, i /= 108.883, t = t > 8856e-6 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 /
    3) : 7.787 * r + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, n = 116 * r - 16, a = 500 * (t - r), o = 200 * (r -
    i), [n, a, o];
  };
  z.lab.xyz = function(e) {
    var t = e[0], r = e[1], i = e[2], n, a, o;
    a = (t + 16) / 116, n = r / 500 + a, o = a - i / 200;
    var l = Math.pow(a, 3), u = Math.pow(n, 3), c = Math.pow(o, 3);
    return a = l > 8856e-6 ? l : (a - 16 / 116) / 7.787, n = u > 8856e-6 ? u : (n - 16 / 116) / 7.787, o = c > 8856e-6 ? c : (o - 16 / 116) /
    7.787, n *= 95.047, a *= 100, o *= 108.883, [n, a, o];
  };
  z.lab.lch = function(e) {
    var t = e[0], r = e[1], i = e[2], n, a, o;
    return n = Math.atan2(i, r), a = n * 360 / 2 / Math.PI, a < 0 && (a += 360), o = Math.sqrt(r * r + i * i), [t, o, a];
  };
  z.lch.lab = function(e) {
    var t = e[0], r = e[1], i = e[2], n, a, o;
    return o = i / 360 * 2 * Math.PI, n = r * Math.cos(o), a = r * Math.sin(o), [t, n, a];
  };
  z.rgb.ansi16 = function(e) {
    var t = e[0], r = e[1], i = e[2], n = 1 in arguments ? arguments[1] : z.rgb.hsv(e)[2];
    if (n = Math.round(n / 50), n === 0)
      return 30;
    var a = 30 + (Math.round(i / 255) << 2 | Math.round(r / 255) << 1 | Math.round(t / 255));
    return n === 2 && (a += 60), a;
  };
  z.hsv.ansi16 = function(e) {
    return z.rgb.ansi16(z.hsv.rgb(e), e[2]);
  };
  z.rgb.ansi256 = function(e) {
    var t = e[0], r = e[1], i = e[2];
    if (t === r && r === i)
      return t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232;
    var n = 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(i / 255 * 5);
    return n;
  };
  z.ansi16.rgb = function(e) {
    var t = e % 10;
    if (t === 0 || t === 7)
      return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
    var r = (~~(e > 50) + 1) * 0.5, i = (t & 1) * r * 255, n = (t >> 1 & 1) * r * 255, a = (t >> 2 & 1) * r * 255;
    return [i, n, a];
  };
  z.ansi256.rgb = function(e) {
    if (e >= 232) {
      var t = (e - 232) * 10 + 8;
      return [t, t, t];
    }
    e -= 16;
    var r, i = Math.floor(e / 36) / 5 * 255, n = Math.floor((r = e % 36) / 6) / 5 * 255, a = r % 6 / 5 * 255;
    return [i, n, a];
  };
  z.rgb.hex = function(e) {
    var t = ((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255), r = t.toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  };
  z.hex.rgb = function(e) {
    var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t)
      return [0, 0, 0];
    var r = t[0];
    t[0].length === 3 && (r = r.split("").map(function(l) {
      return l + l;
    }).join(""));
    var i = parseInt(r, 16), n = i >> 16 & 255, a = i >> 8 & 255, o = i & 255;
    return [n, a, o];
  };
  z.rgb.hcg = function(e) {
    var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255, n = Math.max(Math.max(t, r), i), a = Math.min(Math.min(t, r), i), o = n - a, l, u;
    return o < 1 ? l = a / (1 - o) : l = 0, o <= 0 ? u = 0 : n === t ? u = (r - i) / o % 6 : n === r ? u = 2 + (i - t) / o : u = 4 + (t - r) /
    o + 4, u /= 6, u %= 1, [u * 360, o * 100, l * 100];
  };
  z.hsl.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = 1, n = 0;
    return r < 0.5 ? i = 2 * t * r : i = 2 * t * (1 - r), i < 1 && (n = (r - 0.5 * i) / (1 - i)), [e[0], i * 100, n * 100];
  };
  z.hsv.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = t * r, n = 0;
    return i < 1 && (n = (r - i) / (1 - i)), [e[0], i * 100, n * 100];
  };
  z.hcg.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, i = e[2] / 100;
    if (r === 0)
      return [i * 255, i * 255, i * 255];
    var n = [0, 0, 0], a = t % 1 * 6, o = a % 1, l = 1 - o, u = 0;
    switch (Math.floor(a)) {
      case 0:
        n[0] = 1, n[1] = o, n[2] = 0;
        break;
      case 1:
        n[0] = l, n[1] = 1, n[2] = 0;
        break;
      case 2:
        n[0] = 0, n[1] = 1, n[2] = o;
        break;
      case 3:
        n[0] = 0, n[1] = l, n[2] = 1;
        break;
      case 4:
        n[0] = o, n[1] = 0, n[2] = 1;
        break;
      default:
        n[0] = 1, n[1] = 0, n[2] = l;
    }
    return u = (1 - r) * i, [
      (r * n[0] + u) * 255,
      (r * n[1] + u) * 255,
      (r * n[2] + u) * 255
    ];
  };
  z.hcg.hsv = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = t + r * (1 - t), n = 0;
    return i > 0 && (n = t / i), [e[0], n * 100, i * 100];
  };
  z.hcg.hsl = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = r * (1 - t) + 0.5 * t, n = 0;
    return i > 0 && i < 0.5 ? n = t / (2 * i) : i >= 0.5 && i < 1 && (n = t / (2 * (1 - i))), [e[0], n * 100, i * 100];
  };
  z.hcg.hwb = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = t + r * (1 - t);
    return [e[0], (i - t) * 100, (1 - i) * 100];
  };
  z.hwb.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = 1 - r, n = i - t, a = 0;
    return n < 1 && (a = (i - n) / (1 - n)), [e[0], n * 100, a * 100];
  };
  z.apple.rgb = function(e) {
    return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
  };
  z.rgb.apple = function(e) {
    return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
  };
  z.gray.rgb = function(e) {
    return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
  };
  z.gray.hsl = z.gray.hsv = function(e) {
    return [0, 0, e[0]];
  };
  z.gray.hwb = function(e) {
    return [0, 100, e[0]];
  };
  z.gray.cmyk = function(e) {
    return [0, 0, 0, e[0]];
  };
  z.gray.lab = function(e) {
    return [e[0], 0, 0];
  };
  z.gray.hex = function(e) {
    var t = Math.round(e[0] / 100 * 255) & 255, r = (t << 16) + (t << 8) + t, i = r.toString(16).toUpperCase();
    return "000000".substring(i.length) + i;
  };
  z.rgb.gray = function(e) {
    var t = (e[0] + e[1] + e[2]) / 3;
    return [t / 255 * 100];
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/route.js
var Km = v((fee, Um) => {
  var Mn = Eu();
  function q7() {
    for (var e = {}, t = Object.keys(Mn), r = t.length, i = 0; i < r; i++)
      e[t[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return e;
  }
  s(q7, "buildGraph");
  function V7(e) {
    var t = q7(), r = [e];
    for (t[e].distance = 0; r.length; )
      for (var i = r.pop(), n = Object.keys(Mn[i]), a = n.length, o = 0; o < a; o++) {
        var l = n[o], u = t[l];
        u.distance === -1 && (u.distance = t[i].distance + 1, u.parent = i, r.unshift(l));
      }
    return t;
  }
  s(V7, "deriveBFS");
  function U7(e, t) {
    return function(r) {
      return t(e(r));
    };
  }
  s(U7, "link");
  function K7(e, t) {
    for (var r = [t[e].parent, e], i = Mn[t[e].parent][e], n = t[e].parent; t[n].parent; )
      r.unshift(t[n].parent), i = U7(Mn[t[n].parent][n], i), n = t[n].parent;
    return i.conversion = r, i;
  }
  s(K7, "wrapConversion");
  Um.exports = function(e) {
    for (var t = V7(e), r = {}, i = Object.keys(t), n = i.length, a = 0; a < n; a++) {
      var o = i[a], l = t[o];
      l.parent !== null && (r[o] = K7(o, t));
    }
    return r;
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/index.js
var Ym = v((dee, Wm) => {
  var Pu = Eu(), W7 = Km(), pi = {}, Y7 = Object.keys(Pu);
  function X7(e) {
    var t = /* @__PURE__ */ s(function(r) {
      return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), e(r));
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  s(X7, "wrapRaw");
  function J7(e) {
    var t = /* @__PURE__ */ s(function(r) {
      if (r == null)
        return r;
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
      var i = e(r);
      if (typeof i == "object")
        for (var n = i.length, a = 0; a < n; a++)
          i[a] = Math.round(i[a]);
      return i;
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  s(J7, "wrapRounded");
  Y7.forEach(function(e) {
    pi[e] = {}, Object.defineProperty(pi[e], "channels", { value: Pu[e].channels }), Object.defineProperty(pi[e], "labels", { value: Pu[e].labels });
    var t = W7(e), r = Object.keys(t);
    r.forEach(function(i) {
      var n = t[i];
      pi[e][i] = J7(n), pi[e][i].raw = X7(n);
    });
  });
  Wm.exports = pi;
});

// ../node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var Jm = v((yee, Xm) => {
  "use strict";
  var fi = Ym(), Fn = /* @__PURE__ */ s((e, t) => function() {
    return `\x1B[${e.apply(fi, arguments) + t}m`;
  }, "wrapAnsi16"), Bn = /* @__PURE__ */ s((e, t) => function() {
    let r = e.apply(fi, arguments);
    return `\x1B[${38 + t};5;${r}m`;
  }, "wrapAnsi256"), jn = /* @__PURE__ */ s((e, t) => function() {
    let r = e.apply(fi, arguments);
    return `\x1B[${38 + t};2;${r[0]};${r[1]};${r[2]}m`;
  }, "wrapAnsi16m");
  function $7() {
    let e = /* @__PURE__ */ new Map(), t = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    t.color.grey = t.color.gray;
    for (let n of Object.keys(t)) {
      let a = t[n];
      for (let o of Object.keys(a)) {
        let l = a[o];
        t[o] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, a[o] = t[o], e.set(l[0], l[1]);
      }
      Object.defineProperty(t, n, {
        value: a,
        enumerable: !1
      }), Object.defineProperty(t, "codes", {
        value: e,
        enumerable: !1
      });
    }
    let r = /* @__PURE__ */ s((n) => n, "ansi2ansi"), i = /* @__PURE__ */ s((n, a, o) => [n, a, o], "rgb2rgb");
    t.color.close = "\x1B[39m", t.bgColor.close = "\x1B[49m", t.color.ansi = {
      ansi: Fn(r, 0)
    }, t.color.ansi256 = {
      ansi256: Bn(r, 0)
    }, t.color.ansi16m = {
      rgb: jn(i, 0)
    }, t.bgColor.ansi = {
      ansi: Fn(r, 10)
    }, t.bgColor.ansi256 = {
      ansi256: Bn(r, 10)
    }, t.bgColor.ansi16m = {
      rgb: jn(i, 10)
    };
    for (let n of Object.keys(fi)) {
      if (typeof fi[n] != "object")
        continue;
      let a = fi[n];
      n === "ansi16" && (n = "ansi"), "ansi16" in a && (t.color.ansi[n] = Fn(a.ansi16, 0), t.bgColor.ansi[n] = Fn(a.ansi16, 10)), "ansi256" in
      a && (t.color.ansi256[n] = Bn(a.ansi256, 0), t.bgColor.ansi256[n] = Bn(a.ansi256, 10)), "rgb" in a && (t.color.ansi16m[n] = jn(a.rgb, 0),
      t.bgColor.ansi16m[n] = jn(a.rgb, 10));
    }
    return t;
  }
  s($7, "assembleStyles");
  Object.defineProperty(Xm, "exports", {
    enumerable: !0,
    get: $7
  });
});

// ../node_modules/@babel/highlight/node_modules/has-flag/index.js
var Hm = v((gee, $m) => {
  "use strict";
  $m.exports = (e, t) => {
    t = t || process.argv;
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", i = t.indexOf(r + e), n = t.indexOf("--");
    return i !== -1 && (n === -1 ? !0 : i < n);
  };
});

// ../node_modules/@babel/highlight/node_modules/supports-color/index.js
var zm = v((bee, Gm) => {
  "use strict";
  var H7 = require("os"), _t = Hm(), it = process.env, hi;
  _t("no-color") || _t("no-colors") || _t("color=false") ? hi = !1 : (_t("color") || _t("colors") || _t("color=true") || _t("color=always")) &&
  (hi = !0);
  "FORCE_COLOR" in it && (hi = it.FORCE_COLOR.length === 0 || parseInt(it.FORCE_COLOR, 10) !== 0);
  function G7(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  s(G7, "translateLevel");
  function z7(e) {
    if (hi === !1)
      return 0;
    if (_t("color=16m") || _t("color=full") || _t("color=truecolor"))
      return 3;
    if (_t("color=256"))
      return 2;
    if (e && !e.isTTY && hi !== !0)
      return 0;
    let t = hi ? 1 : 0;
    if (process.platform === "win32") {
      let r = H7.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 :
      1;
    }
    if ("CI" in it)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((r) => r in it) || it.CI_NAME === "codeship" ? 1 : t;
    if ("TEAMCITY_VERSION" in it)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(it.TEAMCITY_VERSION) ? 1 : 0;
    if (it.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in it) {
      let r = parseInt((it.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (it.TERM_PROGRAM) {
        case "iTerm.app":
          return r >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(it.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(it.TERM) || "COLORTERM" in
    it ? 1 : (it.TERM === "dumb", t);
  }
  s(z7, "supportsColor");
  function Au(e) {
    let t = z7(e);
    return G7(t);
  }
  s(Au, "getSupportLevel");
  Gm.exports = {
    supportsColor: Au,
    stdout: Au(process.stdout),
    stderr: Au(process.stderr)
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/templates.js
var ry = v((xee, ty) => {
  "use strict";
  var Q7 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
  Qm = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Z7 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, eq = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, tq = /* @__PURE__ */ new Map(
  [
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function ey(e) {
    return e[0] === "u" && e.length === 5 || e[0] === "x" && e.length === 3 ? String.fromCharCode(parseInt(e.slice(1), 16)) : tq.get(e) || e;
  }
  s(ey, "unescape");
  function rq(e, t) {
    let r = [], i = t.trim().split(/\s*,\s*/g), n;
    for (let a of i)
      if (!isNaN(a))
        r.push(Number(a));
      else if (n = a.match(Z7))
        r.push(n[2].replace(eq, (o, l, u) => l ? ey(l) : u));
      else
        throw new Error(`Invalid Chalk template style argument: ${a} (in style '${e}')`);
    return r;
  }
  s(rq, "parseArguments");
  function iq(e) {
    Qm.lastIndex = 0;
    let t = [], r;
    for (; (r = Qm.exec(e)) !== null; ) {
      let i = r[1];
      if (r[2]) {
        let n = rq(i, r[2]);
        t.push([i].concat(n));
      } else
        t.push([i]);
    }
    return t;
  }
  s(iq, "parseStyle");
  function Zm(e, t) {
    let r = {};
    for (let n of t)
      for (let a of n.styles)
        r[a[0]] = n.inverse ? null : a.slice(1);
    let i = e;
    for (let n of Object.keys(r))
      if (Array.isArray(r[n])) {
        if (!(n in i))
          throw new Error(`Unknown Chalk style: ${n}`);
        r[n].length > 0 ? i = i[n].apply(i, r[n]) : i = i[n];
      }
    return i;
  }
  s(Zm, "buildStyle");
  ty.exports = (e, t) => {
    let r = [], i = [], n = [];
    if (t.replace(Q7, (a, o, l, u, c, p) => {
      if (o)
        n.push(ey(o));
      else if (u) {
        let g = n.join("");
        n = [], i.push(r.length === 0 ? g : Zm(e, r)(g)), r.push({ inverse: l, styles: iq(u) });
      } else if (c) {
        if (r.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        i.push(Zm(e, r)(n.join(""))), n = [], r.pop();
      } else
        n.push(p);
    }), i.push(n.join("")), r.length > 0) {
      let a = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(a);
    }
    return i.join("");
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/index.js
var oy = v((Pee, is) => {
  "use strict";
  var Cu = Mm(), Xe = Jm(), vu = zm().stdout, sq = ry(), sy = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith(
  "xterm"), ny = ["ansi", "ansi", "ansi256", "ansi16m"], ay = /* @__PURE__ */ new Set(["gray"]), di = /* @__PURE__ */ Object.create(null);
  function iy(e, t) {
    t = t || {};
    let r = vu ? vu.level : 0;
    e.level = t.level === void 0 ? r : t.level, e.enabled = "enabled" in t ? t.enabled : e.level > 0;
  }
  s(iy, "applyOptions");
  function rs(e) {
    if (!this || !(this instanceof rs) || this.template) {
      let t = {};
      return iy(t, e), t.template = function() {
        let r = [].slice.call(arguments);
        return oq.apply(null, [t.template].concat(r));
      }, Object.setPrototypeOf(t, rs.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = rs, t.template;
    }
    iy(this, e);
  }
  s(rs, "Chalk");
  sy && (Xe.blue.open = "\x1B[94m");
  for (let e of Object.keys(Xe))
    Xe[e].closeRe = new RegExp(Cu(Xe[e].close), "g"), di[e] = {
      get() {
        let t = Xe[e];
        return Rn.call(this, this._styles ? this._styles.concat(t) : [t], this._empty, e);
      }
    };
  di.visible = {
    get() {
      return Rn.call(this, this._styles || [], !0, "visible");
    }
  };
  Xe.color.closeRe = new RegExp(Cu(Xe.color.close), "g");
  for (let e of Object.keys(Xe.color.ansi))
    ay.has(e) || (di[e] = {
      get() {
        let t = this.level;
        return function() {
          let i = {
            open: Xe.color[ny[t]][e].apply(null, arguments),
            close: Xe.color.close,
            closeRe: Xe.color.closeRe
          };
          return Rn.call(this, this._styles ? this._styles.concat(i) : [i], this._empty, e);
        };
      }
    });
  Xe.bgColor.closeRe = new RegExp(Cu(Xe.bgColor.close), "g");
  for (let e of Object.keys(Xe.bgColor.ansi)) {
    if (ay.has(e))
      continue;
    let t = "bg" + e[0].toUpperCase() + e.slice(1);
    di[t] = {
      get() {
        let r = this.level;
        return function() {
          let n = {
            open: Xe.bgColor[ny[r]][e].apply(null, arguments),
            close: Xe.bgColor.close,
            closeRe: Xe.bgColor.closeRe
          };
          return Rn.call(this, this._styles ? this._styles.concat(n) : [n], this._empty, e);
        };
      }
    };
  }
  var nq = Object.defineProperties(() => {
  }, di);
  function Rn(e, t, r) {
    let i = /* @__PURE__ */ s(function() {
      return aq.apply(i, arguments);
    }, "builder");
    i._styles = e, i._empty = t;
    let n = this;
    return Object.defineProperty(i, "level", {
      enumerable: !0,
      get() {
        return n.level;
      },
      set(a) {
        n.level = a;
      }
    }), Object.defineProperty(i, "enabled", {
      enumerable: !0,
      get() {
        return n.enabled;
      },
      set(a) {
        n.enabled = a;
      }
    }), i.hasGrey = this.hasGrey || r === "gray" || r === "grey", i.__proto__ = nq, i;
  }
  s(Rn, "build");
  function aq() {
    let e = arguments, t = e.length, r = String(arguments[0]);
    if (t === 0)
      return "";
    if (t > 1)
      for (let n = 1; n < t; n++)
        r += " " + e[n];
    if (!this.enabled || this.level <= 0 || !r)
      return this._empty ? "" : r;
    let i = Xe.dim.open;
    sy && this.hasGrey && (Xe.dim.open = "");
    for (let n of this._styles.slice().reverse())
      r = n.open + r.replace(n.closeRe, n.open) + n.close, r = r.replace(/\r?\n/g, `${n.close}$&${n.open}`);
    return Xe.dim.open = i, r;
  }
  s(aq, "applyStyle");
  function oq(e, t) {
    if (!Array.isArray(t))
      return [].slice.call(arguments, 1).join(" ");
    let r = [].slice.call(arguments, 2), i = [t.raw[0]];
    for (let n = 1; n < t.length; n++)
      i.push(String(r[n - 1]).replace(/[{}\\]/g, "\\$&")), i.push(String(t.raw[n]));
    return sq(e, i.join(""));
  }
  s(oq, "chalkTag");
  Object.defineProperties(rs.prototype, di);
  is.exports = rs();
  is.exports.supportsColor = vu;
  is.exports.default = is.exports;
});

// ../node_modules/@babel/highlight/lib/index.js
var my = v((ss) => {
  "use strict";
  Object.defineProperty(ss, "__esModule", {
    value: !0
  });
  ss.default = mq;
  ss.shouldHighlight = dy;
  var ly = _m(), uy = Bi(), wu = lq(xu(), !0);
  function py(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (py = /* @__PURE__ */ s(function(i) {
      return i ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  s(py, "_getRequireWildcardCache");
  function lq(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = py(t);
    if (r && r.has(e)) return r.get(e);
    var i = { __proto__: null }, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var o = n ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(i, a, o) : i[a] = e[a];
    }
    return i.default = e, r && r.set(e, i), i;
  }
  s(lq, "_interopRequireWildcard");
  var fy = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, wu.createColors)(!1) :
  wu.default, cy = /* @__PURE__ */ s((e, t) => (r) => e(t(r)), "compose"), uq = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of",
  "set"]);
  function cq(e) {
    return {
      keyword: e.cyan,
      capitalized: e.yellow,
      jsxIdentifier: e.yellow,
      punctuator: e.yellow,
      number: e.magenta,
      string: e.green,
      regex: e.magenta,
      comment: e.gray,
      invalid: cy(cy(e.white, e.bgRed), e.bold)
    };
  }
  s(cq, "getDefs");
  var pq = /\r\n|[\n\r\u2028\u2029]/, fq = /^[()[\]{}]$/, hy;
  {
    let e = /^[a-z][\w-]*$/i, t = /* @__PURE__ */ s(function(r, i, n) {
      if (r.type === "name") {
        if ((0, uy.isKeyword)(r.value) || (0, uy.isStrictReservedWord)(r.value, !0) || uq.has(r.value))
          return "keyword";
        if (e.test(r.value) && (n[i - 1] === "<" || n.slice(i - 2, i) == "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && fq.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punct\
uator" : r.type;
    }, "getTokenType");
    hy = /* @__PURE__ */ s(function* (r) {
      let i;
      for (; i = ly.default.exec(r); ) {
        let n = ly.matchToToken(i);
        yield {
          type: t(n, i.index, r),
          value: n.value
        };
      }
    }, "tokenize");
  }
  function hq(e, t) {
    let r = "";
    for (let {
      type: i,
      value: n
    } of hy(t)) {
      let a = e[i];
      a ? r += n.split(pq).map((o) => a(o)).join(`
`) : r += n;
    }
    return r;
  }
  s(hq, "highlightTokens");
  function dy(e) {
    return fy.isColorSupported || e.forceColor;
  }
  s(dy, "shouldHighlight");
  var Iu;
  function dq(e) {
    if (e) {
      var t;
      return (t = Iu) != null || (Iu = (0, wu.createColors)(!0)), Iu;
    }
    return fy;
  }
  s(dq, "getColors");
  function mq(e, t = {}) {
    if (e !== "" && dy(t)) {
      let r = cq(dq(t.forceColor));
      return hq(r, e);
    } else
      return e;
  }
  s(mq, "highlight");
  {
    let e, t;
    ss.getChalk = ({
      forceColor: r
    }) => {
      var i;
      if ((i = e) != null || (e = oy()), r) {
        var n;
        return (n = t) != null || (t = new e.constructor({
          enabled: !0,
          level: 1
        })), t;
      }
      return e;
    };
  }
});

// ../node_modules/@babel/code-frame/lib/index.js
var _u = v((qn) => {
  "use strict";
  Object.defineProperty(qn, "__esModule", {
    value: !0
  });
  qn.codeFrameColumns = xy;
  qn.default = xq;
  var yy = my(), Nu = yq(xu(), !0);
  function Sy(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (Sy = /* @__PURE__ */ s(function(i) {
      return i ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  s(Sy, "_getRequireWildcardCache");
  function yq(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = Sy(t);
    if (r && r.has(e)) return r.get(e);
    var i = { __proto__: null }, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var o = n ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(i, a, o) : i[a] = e[a];
    }
    return i.default = e, r && r.set(e, i), i;
  }
  s(yq, "_interopRequireWildcard");
  var Tq = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Nu.createColors)(!1) :
  Nu.default, Ty = /* @__PURE__ */ s((e, t) => (r) => e(t(r)), "compose"), Ou;
  function gq(e) {
    if (e) {
      var t;
      return (t = Ou) != null || (Ou = (0, Nu.createColors)(!0)), Ou;
    }
    return Tq;
  }
  s(gq, "getColors");
  var gy = !1;
  function bq(e) {
    return {
      gutter: e.gray,
      marker: Ty(e.red, e.bold),
      message: Ty(e.red, e.bold)
    };
  }
  s(bq, "getDefs");
  var by = /\r\n|[\n\r\u2028\u2029]/;
  function Sq(e, t, r) {
    let i = Object.assign({
      column: 0,
      line: -1
    }, e.start), n = Object.assign({}, i, e.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, l = i.line, u = i.column, c = n.line, p = n.column, g = Math.max(l - (a + 1), 0), P = Math.min(t.length, c + o);
    l === -1 && (g = 0), c === -1 && (P = t.length);
    let A = c - l, C = {};
    if (A)
      for (let _ = 0; _ <= A; _++) {
        let k = _ + l;
        if (!u)
          C[k] = !0;
        else if (_ === 0) {
          let O = t[k - 1].length;
          C[k] = [u, O - u + 1];
        } else if (_ === A)
          C[k] = [0, p];
        else {
          let O = t[k - _].length;
          C[k] = [0, O];
        }
      }
    else
      u === p ? u ? C[l] = [u, 0] : C[l] = !0 : C[l] = [u, p - u];
    return {
      start: g,
      end: P,
      markerLines: C
    };
  }
  s(Sq, "getMarkerLines");
  function xy(e, t, r = {}) {
    let i = (r.highlightCode || r.forceColor) && (0, yy.shouldHighlight)(r), n = gq(r.forceColor), a = bq(n), o = /* @__PURE__ */ s((_, k) => i ?
    _(k) : k, "maybeHighlight"), l = e.split(by), {
      start: u,
      end: c,
      markerLines: p
    } = Sq(t, l, r), g = t.start && typeof t.start.column == "number", P = String(c).length, C = (i ? (0, yy.default)(e, r) : e).split(by, c).
    slice(u, c).map((_, k) => {
      let O = u + 1 + k, F = ` ${` ${O}`.slice(-P)} |`, G = p[O], $ = !p[O + 1];
      if (G) {
        let K = "";
        if (Array.isArray(G)) {
          let oe = _.slice(0, Math.max(G[0] - 1, 0)).replace(/[^\t]/g, " "), Oe = G[1] || 1;
          K = [`
 `, o(a.gutter, F.replace(/\d/g, " ")), " ", oe, o(a.marker, "^").repeat(Oe)].join(""), $ && r.message && (K += " " + o(a.message, r.message));
        }
        return [o(a.marker, ">"), o(a.gutter, F), _.length > 0 ? ` ${_}` : "", K].join("");
      } else
        return ` ${o(a.gutter, F)}${_.length > 0 ? ` ${_}` : ""}`;
    }).join(`
`);
    return r.message && !g && (C = `${" ".repeat(P + 1)}${r.message}
${C}`), i ? n.reset(C) : C;
  }
  s(xy, "codeFrameColumns");
  function xq(e, t, r, i = {}) {
    if (!gy) {
      gy = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), xy(e, {
      start: {
        column: r,
        line: t
      }
    }, i);
  }
  s(xq, "_default");
});

// ../node_modules/@babel/parser/lib/index.js
var zn = v((ms) => {
  "use strict";
  Object.defineProperty(ms, "__esModule", {
    value: !0
  });
  function jy(e, t) {
    if (e == null) return {};
    var r = {}, i = Object.keys(e), n, a;
    for (a = 0; a < i.length; a++)
      n = i[a], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
    return r;
  }
  s(jy, "_objectWithoutPropertiesLoose");
  var Rt = class {
    static {
      s(this, "Position");
    }
    constructor(t, r, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = i;
    }
  }, gi = class {
    static {
      s(this, "SourceLocation");
    }
    constructor(t, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
    }
  };
  function ht(e, t) {
    let {
      line: r,
      column: i,
      index: n
    } = e;
    return new Rt(r, i + t, n + t);
  }
  s(ht, "createPositionWithColumnOffset");
  var Ey = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Eq = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: Ey
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: Ey
    }
  }, Py = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Kn = /* @__PURE__ */ s(({
    type: e,
    prefix: t
  }) => e === "UpdateExpression" ? Py.UpdateExpression[String(t)] : Py[e], "toNodeDescription"), Pq = {
    AccessorIsGenerator: /* @__PURE__ */ s(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ s(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ s(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ s(({
      phase: e
    }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ s(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ s(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ s(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ s(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ s(({
      maxArgumentCount: e
    }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ s(({
      radix: e
    }) => `Expected number in radix ${e}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ s(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Invalid identifier ${e}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Invalid left-hand side in ${Kn(e)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${Kn(e)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Invalid optional chaining in the left-hand side of ${Kn(e)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ s(({
      unexpected: e
    }) => `Unexpected character '${e}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Private name #${e} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ s(({
      labelName: e
    }) => `Label '${e}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ s(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ s(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ s(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ s(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ s(({
      localName: e
    }) => `Export '${e}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Duplicate private name #${e}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ s(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ s(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ s(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ s(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, Aq = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ s(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ s(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, vq = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Cq = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ s(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${e}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ s(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${Kn({
      type: e
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, Iq = ["toMessage"], wq = ["message"];
  function Ay(e, t, r) {
    Object.defineProperty(e, t, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  s(Ay, "defineHidden");
  function Oq(e) {
    let {
      toMessage: t
    } = e, r = jy(e, Iq);
    return /* @__PURE__ */ s(function i(n, a) {
      let o = new SyntaxError();
      return Object.assign(o, r, {
        loc: n,
        pos: n.index
      }), "missingPlugin" in a && Object.assign(o, {
        missingPlugin: a.missingPlugin
      }), Ay(o, "clone", /* @__PURE__ */ s(function(u = {}) {
        var c;
        let {
          line: p,
          column: g,
          index: P
        } = (c = u.loc) != null ? c : n;
        return i(new Rt(p, g, P), Object.assign({}, a, u.details));
      }, "clone")), Ay(o, "details", a), Object.defineProperty(o, "message", {
        configurable: !0,
        get() {
          let l = `${t(a)} (${n.line}:${n.column})`;
          return this.message = l, l;
        },
        set(l) {
          Object.defineProperty(this, "message", {
            value: l,
            writable: !0
          });
        }
      }), o;
    }, "constructor");
  }
  s(Oq, "toParseErrorConstructor");
  function Gt(e, t) {
    if (Array.isArray(e))
      return (i) => Gt(i, e[0]);
    let r = {};
    for (let i of Object.keys(e)) {
      let n = e[i], a = typeof n == "string" ? {
        message: /* @__PURE__ */ s(() => n, "message")
      } : typeof n == "function" ? {
        message: n
      } : n, {
        message: o
      } = a, l = jy(a, wq), u = typeof o == "string" ? () => o : o;
      r[i] = Oq(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: u
      }, t ? {
        syntaxPlugin: t
      } : {}, l));
    }
    return r;
  }
  s(Gt, "ParseErrorEnum");
  var x = Object.assign({}, Gt(Eq), Gt(Pq), Gt(Aq), Gt`pipelineOperator`(Cq)), {
    defineProperty: Nq
  } = Object, vy = /* @__PURE__ */ s((e, t) => Nq(e, t, {
    enumerable: !1,
    value: e[t]
  }), "toUnenumerable");
  function ns(e) {
    return e.loc.start && vy(e.loc.start, "index"), e.loc.end && vy(e.loc.end, "index"), e;
  }
  s(ns, "toESTreeLocation");
  var _q = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "ESTreeParserMixin");
    }
    parse() {
      let r = ns(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map(ns)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: i
    }) {
      let n = null;
      try {
        n = new RegExp(r, i);
      } catch {
      }
      let a = this.estreeParseLiteral(n);
      return a.regex = {
        pattern: r,
        flags: i
      }, a;
    }
    parseBigIntLiteral(r) {
      let i;
      try {
        i = BigInt(r);
      } catch {
        i = null;
      }
      let n = this.estreeParseLiteral(i);
      return n.bigint = String(n.value || r), n;
    }
    parseDecimalLiteral(r) {
      let n = this.estreeParseLiteral(null);
      return n.decimal = String(n.value || r), n;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let i = r.value;
      delete r.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let n = r;
      return n.type = "ExpressionStatement", n.expression = i, n.directive = i.extra.rawValue, delete i.extra, n;
    }
    initFunction(r, i) {
      super.initFunction(r, i), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var i;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((i = r.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(r, i, n, a, o) {
      super.parseBlockBody(r, i, n, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, i, n, a, o, l) {
      this.parseMethod(i, n, a, o, l, "ClassMethod", !0), i.typeParameters && (i.value.typeParameters = i.typeParameters, delete i.typeParameters),
      r.body.push(i);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let i = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = i, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, i) {
      let n = super.parseLiteral(r, i);
      return n.raw = n.extra.raw, delete n.extra, n;
    }
    parseFunctionBody(r, i, n = !1) {
      super.parseFunctionBody(r, i, n), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, i, n, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, i, n, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    parseClassProperty(...r) {
      let i = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...r) {
      let i = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
    }
    parseObjectMethod(r, i, n, a, o) {
      let l = super.parseObjectMethod(r, i, n, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, i, n, a) {
      let o = super.parseObjectProperty(r, i, n, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, i, n) {
      return r === "Property" ? "value" : super.isValidLVal(r, i, n);
    }
    isAssignable(r, i) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: n,
          value: a
        } = r;
        this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(r, i);
    }
    toAssignableObjectExpressionProp(r, i, n) {
      r.kind === "get" || r.kind === "set" ? this.raise(x.PatternHasAccessor, r.key) : r.method ? this.raise(x.PatternHasMethod, r.key) : super.
      toAssignableObjectExpressionProp(r, i, n);
    }
    finishCallExpression(r, i) {
      let n = super.finishCallExpression(r, i);
      if (n.callee.type === "Import") {
        if (n.type = "ImportExpression", n.source = n.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          n.options = (a = n.arguments[1]) != null ? a : null, n.attributes = (o = n.arguments[1]) != null ? o : null;
        }
        delete n.arguments, delete n.callee;
      }
      return n;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, i) {
      let n = this.state.lastTokStartLoc, a = super.parseExport(r, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, n);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, i, n, a) {
      let o = super.parseSubscript(r, i, n, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.method || r.kind === "get" || r.kind === "set";
    }
    finishNodeAt(r, i, n) {
      return ns(super.finishNodeAt(r, i, n));
    }
    resetStartLocation(r, i) {
      super.resetStartLocation(r, i), ns(r);
    }
    resetEndLocation(r, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, i), ns(r);
    }
  }, "estree"), Wr = class {
    static {
      s(this, "TokContext");
    }
    constructor(t, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
    }
  }, we = {
    brace: new Wr("{"),
    j_oTag: new Wr("<tag"),
    j_cTag: new Wr("</tag"),
    j_expr: new Wr("<tag>...</tag>", !0)
  };
  we.template = new Wr("`", !0);
  var he = !0, U = !0, Du = !0, as = !0, hr = !0, Dq = !0, Jn = class {
    static {
      s(this, "ExportedTokenType");
    }
    constructor(t, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, ic = /* @__PURE__ */ new Map();
  function Te(e, t = {}) {
    t.keyword = e;
    let r = Z(e, t);
    return ic.set(e, r), r;
  }
  s(Te, "createKeyword");
  function ft(e, t) {
    return Z(e, {
      beforeExpr: he,
      binop: t
    });
  }
  s(ft, "createBinop");
  var cs = -1, $t = [], sc = [], nc = [], ac = [], oc = [], lc = [];
  function Z(e, t = {}) {
    var r, i, n, a;
    return ++cs, sc.push(e), nc.push((r = t.binop) != null ? r : -1), ac.push((i = t.beforeExpr) != null ? i : !1), oc.push((n = t.startsExpr) !=
    null ? n : !1), lc.push((a = t.prefix) != null ? a : !1), $t.push(new Jn(e, t)), cs;
  }
  s(Z, "createToken");
  function fe(e, t = {}) {
    var r, i, n, a;
    return ++cs, ic.set(e, cs), sc.push(e), nc.push((r = t.binop) != null ? r : -1), ac.push((i = t.beforeExpr) != null ? i : !1), oc.push((n =
    t.startsExpr) != null ? n : !1), lc.push((a = t.prefix) != null ? a : !1), $t.push(new Jn("name", t)), cs;
  }
  s(fe, "createKeywordLike");
  var kq = {
    bracketL: Z("[", {
      beforeExpr: he,
      startsExpr: U
    }),
    bracketHashL: Z("#[", {
      beforeExpr: he,
      startsExpr: U
    }),
    bracketBarL: Z("[|", {
      beforeExpr: he,
      startsExpr: U
    }),
    bracketR: Z("]"),
    bracketBarR: Z("|]"),
    braceL: Z("{", {
      beforeExpr: he,
      startsExpr: U
    }),
    braceBarL: Z("{|", {
      beforeExpr: he,
      startsExpr: U
    }),
    braceHashL: Z("#{", {
      beforeExpr: he,
      startsExpr: U
    }),
    braceR: Z("}"),
    braceBarR: Z("|}"),
    parenL: Z("(", {
      beforeExpr: he,
      startsExpr: U
    }),
    parenR: Z(")"),
    comma: Z(",", {
      beforeExpr: he
    }),
    semi: Z(";", {
      beforeExpr: he
    }),
    colon: Z(":", {
      beforeExpr: he
    }),
    doubleColon: Z("::", {
      beforeExpr: he
    }),
    dot: Z("."),
    question: Z("?", {
      beforeExpr: he
    }),
    questionDot: Z("?."),
    arrow: Z("=>", {
      beforeExpr: he
    }),
    template: Z("template"),
    ellipsis: Z("...", {
      beforeExpr: he
    }),
    backQuote: Z("`", {
      startsExpr: U
    }),
    dollarBraceL: Z("${", {
      beforeExpr: he,
      startsExpr: U
    }),
    templateTail: Z("...`", {
      startsExpr: U
    }),
    templateNonTail: Z("...${", {
      beforeExpr: he,
      startsExpr: U
    }),
    at: Z("@"),
    hash: Z("#", {
      startsExpr: U
    }),
    interpreterDirective: Z("#!..."),
    eq: Z("=", {
      beforeExpr: he,
      isAssign: as
    }),
    assign: Z("_=", {
      beforeExpr: he,
      isAssign: as
    }),
    slashAssign: Z("_=", {
      beforeExpr: he,
      isAssign: as
    }),
    xorAssign: Z("_=", {
      beforeExpr: he,
      isAssign: as
    }),
    moduloAssign: Z("_=", {
      beforeExpr: he,
      isAssign: as
    }),
    incDec: Z("++/--", {
      prefix: hr,
      postfix: Dq,
      startsExpr: U
    }),
    bang: Z("!", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    tilde: Z("~", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    doubleCaret: Z("^^", {
      startsExpr: U
    }),
    doubleAt: Z("@@", {
      startsExpr: U
    }),
    pipeline: ft("|>", 0),
    nullishCoalescing: ft("??", 1),
    logicalOR: ft("||", 1),
    logicalAND: ft("&&", 2),
    bitwiseOR: ft("|", 3),
    bitwiseXOR: ft("^", 4),
    bitwiseAND: ft("&", 5),
    equality: ft("==/!=/===/!==", 6),
    lt: ft("</>/<=/>=", 7),
    gt: ft("</>/<=/>=", 7),
    relational: ft("</>/<=/>=", 7),
    bitShift: ft("<</>>/>>>", 8),
    bitShiftL: ft("<</>>/>>>", 8),
    bitShiftR: ft("<</>>/>>>", 8),
    plusMin: Z("+/-", {
      beforeExpr: he,
      binop: 9,
      prefix: hr,
      startsExpr: U
    }),
    modulo: Z("%", {
      binop: 10,
      startsExpr: U
    }),
    star: Z("*", {
      binop: 10
    }),
    slash: ft("/", 10),
    exponent: Z("**", {
      beforeExpr: he,
      binop: 11,
      rightAssociative: !0
    }),
    _in: Te("in", {
      beforeExpr: he,
      binop: 7
    }),
    _instanceof: Te("instanceof", {
      beforeExpr: he,
      binop: 7
    }),
    _break: Te("break"),
    _case: Te("case", {
      beforeExpr: he
    }),
    _catch: Te("catch"),
    _continue: Te("continue"),
    _debugger: Te("debugger"),
    _default: Te("default", {
      beforeExpr: he
    }),
    _else: Te("else", {
      beforeExpr: he
    }),
    _finally: Te("finally"),
    _function: Te("function", {
      startsExpr: U
    }),
    _if: Te("if"),
    _return: Te("return", {
      beforeExpr: he
    }),
    _switch: Te("switch"),
    _throw: Te("throw", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    _try: Te("try"),
    _var: Te("var"),
    _const: Te("const"),
    _with: Te("with"),
    _new: Te("new", {
      beforeExpr: he,
      startsExpr: U
    }),
    _this: Te("this", {
      startsExpr: U
    }),
    _super: Te("super", {
      startsExpr: U
    }),
    _class: Te("class", {
      startsExpr: U
    }),
    _extends: Te("extends", {
      beforeExpr: he
    }),
    _export: Te("export"),
    _import: Te("import", {
      startsExpr: U
    }),
    _null: Te("null", {
      startsExpr: U
    }),
    _true: Te("true", {
      startsExpr: U
    }),
    _false: Te("false", {
      startsExpr: U
    }),
    _typeof: Te("typeof", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    _void: Te("void", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    _delete: Te("delete", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    _do: Te("do", {
      isLoop: Du,
      beforeExpr: he
    }),
    _for: Te("for", {
      isLoop: Du
    }),
    _while: Te("while", {
      isLoop: Du
    }),
    _as: fe("as", {
      startsExpr: U
    }),
    _assert: fe("assert", {
      startsExpr: U
    }),
    _async: fe("async", {
      startsExpr: U
    }),
    _await: fe("await", {
      startsExpr: U
    }),
    _defer: fe("defer", {
      startsExpr: U
    }),
    _from: fe("from", {
      startsExpr: U
    }),
    _get: fe("get", {
      startsExpr: U
    }),
    _let: fe("let", {
      startsExpr: U
    }),
    _meta: fe("meta", {
      startsExpr: U
    }),
    _of: fe("of", {
      startsExpr: U
    }),
    _sent: fe("sent", {
      startsExpr: U
    }),
    _set: fe("set", {
      startsExpr: U
    }),
    _source: fe("source", {
      startsExpr: U
    }),
    _static: fe("static", {
      startsExpr: U
    }),
    _using: fe("using", {
      startsExpr: U
    }),
    _yield: fe("yield", {
      startsExpr: U
    }),
    _asserts: fe("asserts", {
      startsExpr: U
    }),
    _checks: fe("checks", {
      startsExpr: U
    }),
    _exports: fe("exports", {
      startsExpr: U
    }),
    _global: fe("global", {
      startsExpr: U
    }),
    _implements: fe("implements", {
      startsExpr: U
    }),
    _intrinsic: fe("intrinsic", {
      startsExpr: U
    }),
    _infer: fe("infer", {
      startsExpr: U
    }),
    _is: fe("is", {
      startsExpr: U
    }),
    _mixins: fe("mixins", {
      startsExpr: U
    }),
    _proto: fe("proto", {
      startsExpr: U
    }),
    _require: fe("require", {
      startsExpr: U
    }),
    _satisfies: fe("satisfies", {
      startsExpr: U
    }),
    _keyof: fe("keyof", {
      startsExpr: U
    }),
    _readonly: fe("readonly", {
      startsExpr: U
    }),
    _unique: fe("unique", {
      startsExpr: U
    }),
    _abstract: fe("abstract", {
      startsExpr: U
    }),
    _declare: fe("declare", {
      startsExpr: U
    }),
    _enum: fe("enum", {
      startsExpr: U
    }),
    _module: fe("module", {
      startsExpr: U
    }),
    _namespace: fe("namespace", {
      startsExpr: U
    }),
    _interface: fe("interface", {
      startsExpr: U
    }),
    _type: fe("type", {
      startsExpr: U
    }),
    _opaque: fe("opaque", {
      startsExpr: U
    }),
    name: Z("name", {
      startsExpr: U
    }),
    string: Z("string", {
      startsExpr: U
    }),
    num: Z("num", {
      startsExpr: U
    }),
    bigint: Z("bigint", {
      startsExpr: U
    }),
    decimal: Z("decimal", {
      startsExpr: U
    }),
    regexp: Z("regexp", {
      startsExpr: U
    }),
    privateName: Z("#name", {
      startsExpr: U
    }),
    eof: Z("eof"),
    jsxName: Z("jsxName"),
    jsxText: Z("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: Z("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: Z("jsxTagEnd"),
    placeholder: Z("%%", {
      startsExpr: !0
    })
  };
  function ve(e) {
    return e >= 93 && e <= 132;
  }
  s(ve, "tokenIsIdentifier");
  function Lq(e) {
    return e <= 92;
  }
  s(Lq, "tokenKeywordOrIdentifierIsKeyword");
  function Dt(e) {
    return e >= 58 && e <= 132;
  }
  s(Dt, "tokenIsKeywordOrIdentifier");
  function Ry(e) {
    return e >= 58 && e <= 136;
  }
  s(Ry, "tokenIsLiteralPropertyName");
  function Mq(e) {
    return ac[e];
  }
  s(Mq, "tokenComesBeforeExpression");
  function Bu(e) {
    return oc[e];
  }
  s(Bu, "tokenCanStartExpression");
  function Fq(e) {
    return e >= 29 && e <= 33;
  }
  s(Fq, "tokenIsAssignment");
  function Cy(e) {
    return e >= 129 && e <= 131;
  }
  s(Cy, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function Bq(e) {
    return e >= 90 && e <= 92;
  }
  s(Bq, "tokenIsLoop");
  function uc(e) {
    return e >= 58 && e <= 92;
  }
  s(uc, "tokenIsKeyword");
  function jq(e) {
    return e >= 39 && e <= 59;
  }
  s(jq, "tokenIsOperator");
  function Rq(e) {
    return e === 34;
  }
  s(Rq, "tokenIsPostfix");
  function qq(e) {
    return lc[e];
  }
  s(qq, "tokenIsPrefix");
  function Vq(e) {
    return e >= 121 && e <= 123;
  }
  s(Vq, "tokenIsTSTypeOperator");
  function Uq(e) {
    return e >= 124 && e <= 130;
  }
  s(Uq, "tokenIsTSDeclarationStart");
  function yr(e) {
    return sc[e];
  }
  s(yr, "tokenLabelName");
  function Wn(e) {
    return nc[e];
  }
  s(Wn, "tokenOperatorPrecedence");
  function Kq(e) {
    return e === 57;
  }
  s(Kq, "tokenIsRightAssociative");
  function $n(e) {
    return e >= 24 && e <= 25;
  }
  s($n, "tokenIsTemplate");
  function Jt(e) {
    return $t[e];
  }
  s(Jt, "getExportedToken");
  $t[8].updateContext = (e) => {
    e.pop();
  }, $t[5].updateContext = $t[7].updateContext = $t[23].updateContext = (e) => {
    e.push(we.brace);
  }, $t[22].updateContext = (e) => {
    e[e.length - 1] === we.template ? e.pop() : e.push(we.template);
  }, $t[142].updateContext = (e) => {
    e.push(we.j_expr, we.j_oTag);
  };
  var cc = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  qy = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", Wq = new RegExp("[" + cc + "]"), Yq = new RegExp("[" + cc + qy + "]");
  cc = qy = null;
  var Vy = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Xq = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2,
  5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6,
  1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function ju(e, t) {
    let r = 65536;
    for (let i = 0, n = t.length; i < n; i += 2) {
      if (r += t[i], r > e) return !1;
      if (r += t[i + 1], r >= e) return !0;
    }
    return !1;
  }
  s(ju, "isInAstralSet");
  function Ht(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && Wq.test(String.fromCharCode(e)) :
    ju(e, Vy);
  }
  s(Ht, "isIdentifierStart");
  function yi(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && Yq.test(
    String.fromCharCode(e)) : ju(e, Vy) || ju(e, Xq);
  }
  s(yi, "isIdentifierChar");
  var pc = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, Jq = new Set(pc.keyword), $q = new Set(pc.strict), Hq = new Set(pc.strictBind);
  function Uy(e, t) {
    return t && e === "await" || e === "enum";
  }
  s(Uy, "isReservedWord");
  function Ky(e, t) {
    return Uy(e, t) || $q.has(e);
  }
  s(Ky, "isStrictReservedWord");
  function Wy(e) {
    return Hq.has(e);
  }
  s(Wy, "isStrictBindOnlyReservedWord");
  function Yy(e, t) {
    return Ky(e, t) || Wy(e);
  }
  s(Yy, "isStrictBindReservedWord");
  function Gq(e) {
    return Jq.has(e);
  }
  s(Gq, "isKeyword");
  function zq(e, t, r) {
    return e === 64 && t === 64 && Ht(r);
  }
  s(zq, "isIteratorStart");
  var Qq = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Zq(e) {
    return Qq.has(e);
  }
  s(Zq, "canBeReservedWord");
  var fs = class {
    static {
      s(this, "Scope");
    }
    constructor(t) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
    }
  }, hs = class {
    static {
      s(this, "ScopeHandler");
    }
    constructor(t, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let t = this.currentThisScopeFlags();
      return (t & 64) > 0 && (t & 2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new fs(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
    }
    declareName(t, r, i) {
      let n = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(n, t, r, i);
        let a = n.names.get(t) || 0;
        r & 16 ? a = a | 4 : (n.firstLexicalName || (n.firstLexicalName = t), a = a | 2), n.names.set(t, a), r & 8 && this.maybeExportDefined(
        n, t);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (n = this.scopeStack[a], this.checkRedeclarationInScope(n, t, r, i), n.names.set(
        t, (n.names.get(t) || 0) | 1), this.maybeExportDefined(n, t), !(n.flags & 387)); --a)
          ;
      this.parser.inModule && n.flags & 1 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, r) {
      this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(t, r, i, n) {
      this.isRedeclaredInScope(t, r, i) && this.parser.raise(x.VarRedeclaration, n, {
        identifierName: r
      });
    }
    isRedeclaredInScope(t, r, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return t.names.has(r);
      let n = t.names.get(r);
      return i & 16 ? (n & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (n & 1) > 0 : (n & 2) > 0 && !(t.flags & 8 && t.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(t) && (n & 4) > 0;
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, Ru = class extends fs {
    static {
      s(this, "FlowScope");
    }
    constructor(...t) {
      super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, qu = class extends hs {
    static {
      s(this, "FlowScopeHandler");
    }
    createScope(t) {
      return new Ru(t);
    }
    declareName(t, r, i) {
      let n = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(n, t, r, i), this.maybeExportDefined(n, t), n.declareFunctions.add(t);
        return;
      }
      super.declareName(t, r, i);
    }
    isRedeclaredInScope(t, r, i) {
      if (super.isRedeclaredInScope(t, r, i)) return !0;
      if (i & 2048 && !t.declareFunctions.has(r)) {
        let n = t.names.get(r);
        return (n & 4) > 0 || (n & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }, Vu = class {
    static {
      s(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        let [r, i] = t;
        if (!this.hasPlugin(r))
          return !1;
        let n = this.plugins.get(r);
        for (let a of Object.keys(i))
          if (n?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(t, r) {
      var i;
      return (i = this.plugins.get(t)) == null ? void 0 : i[r];
    }
  };
  function Xy(e, t) {
    e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
  }
  s(Xy, "setTrailingComments");
  function eV(e, t) {
    e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
  }
  s(eV, "setLeadingComments");
  function ds(e, t) {
    e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
  }
  s(ds, "setInnerComments");
  function os(e, t, r) {
    let i = null, n = t.length;
    for (; i === null && n > 0; )
      i = t[--n];
    i === null || i.start > r.start ? ds(e, r.comments) : Xy(i, r.comments);
  }
  s(os, "adjustInnerComments");
  var Uu = class extends Vu {
    static {
      s(this, "CommentsParser");
    }
    addComment(t) {
      this.filename && (t.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length != r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
    }
    processComment(t) {
      let {
        commentStack: r
      } = this.state, i = r.length;
      if (i === 0) return;
      let n = i - 1, a = r[n];
      a.start === t.end && (a.leadingNode = t, n--);
      let {
        start: o
      } = t;
      for (; n >= 0; n--) {
        let l = r[n], u = l.end;
        if (u > o)
          l.containingNode = t, this.finalizeComment(l), r.splice(n, 1);
        else {
          u === o && (l.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      let {
        comments: r
      } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && Xy(t.leadingNode, r), t.trailingNode !== null && eV(t.trailingNode, r);
      else {
        let {
          containingNode: i,
          start: n
        } = t;
        if (this.input.charCodeAt(n - 1) === 44)
          switch (i.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              os(i, i.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              os(i, i.arguments, t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              os(i, i.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              os(i, i.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              os(i, i.specifiers, t);
              break;
            default:
              ds(i, r);
          }
        else
          ds(i, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: t
      } = this.state;
      for (let r = t.length - 1; r >= 0; r--)
        this.finalizeComment(t[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      if (i === 0) return;
      let n = r[i - 1];
      n.leadingNode === t && (n.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      i !== 0 && (r[i - 1].trailingNode === t ? r[i - 1].trailingNode = null : i >= 2 && r[i - 2].trailingNode === t && (r[i - 2].trailingNode =
      null));
    }
    takeSurroundingComments(t, r, i) {
      let {
        commentStack: n
      } = this.state, a = n.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = n[o], u = l.end;
        if (l.start === i)
          l.leadingNode = t;
        else if (u === r)
          l.trailingNode = t;
        else if (u < r)
          break;
      }
    }
  }, Jy = /\r\n?|[\n\u2028\u2029]/, Vn = new RegExp(Jy.source, "g");
  function ps(e) {
    switch (e) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  s(ps, "isNewLine");
  var ku = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Yn = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Iy = new RegExp("(?=(" + Yn.source + "))\\\
1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function tV(e) {
    switch (e) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  s(tV, "isWhitespace");
  var Ku = class e {
    static {
      s(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [we.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(t) {
      t ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: t,
      sourceType: r,
      startLine: i,
      startColumn: n
    }) {
      this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.curLine = i, this.lineStart = -n, this.startLoc = this.endLoc = new Rt(
      i, n, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(t) {
      t ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(t) {
      t ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(t) {
      t ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(t) {
      t ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(t) {
      t ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(t) {
      t ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(t) {
      t ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(t) {
      t ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(t) {
      t ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(t) {
      t ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(t) {
      t ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new Rt(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let t = new e();
      return t.flags = this.flags, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc,
      t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen,
      t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.
      end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
    }
  }, rV = /* @__PURE__ */ s(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), wy = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Un = {
    bin: /* @__PURE__ */ s((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ s((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ s((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ s((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function Oy(e, t, r, i, n, a) {
    let o = r, l = i, u = n, c = "", p = null, g = r, {
      length: P
    } = t;
    for (; ; ) {
      if (r >= P) {
        a.unterminated(o, l, u), c += t.slice(g, r);
        break;
      }
      let A = t.charCodeAt(r);
      if (iV(e, A, t, r)) {
        c += t.slice(g, r);
        break;
      }
      if (A === 92) {
        c += t.slice(g, r);
        let C = sV(t, r, i, n, e === "template", a);
        C.ch === null && !p ? p = {
          pos: r,
          lineStart: i,
          curLine: n
        } : c += C.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = C, g = r;
      } else A === 8232 || A === 8233 ? (++r, ++n, i = r) : A === 10 || A === 13 ? e === "template" ? (c += t.slice(g, r) + `
`, ++r, A === 13 && t.charCodeAt(r) === 10 && ++r, ++n, g = i = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: n,
      containsInvalid: !!p
    };
  }
  s(Oy, "readStringContents");
  function iV(e, t, r, i) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  s(iV, "isStringEnd");
  function sV(e, t, r, i, n, a) {
    let o = !n;
    t++;
    let l = /* @__PURE__ */ s((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: i
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = Wu(e, t, r, i, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = Hy(e, t, r, i, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(t - 1, r, i);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, g = e.slice(c, t + 2).match(/^[0-7]+/)[0], P = parseInt(g, 8);
          P > 255 && (g = g.slice(0, -1), P = parseInt(g, 8)), t += g.length - 1;
          let A = e.charCodeAt(t);
          if (g !== "0" || A === 56 || A === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(c, r, i);
          }
          return l(String.fromCharCode(P));
        }
        return l(String.fromCharCode(u));
    }
  }
  s(sV, "readEscapedChar");
  function Wu(e, t, r, i, n, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = $y(e, t, r, i, 16, n, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, i) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  s(Wu, "readHexChar");
  function $y(e, t, r, i, n, a, o, l, u, c) {
    let p = t, g = n === 16 ? wy.hex : wy.decBinOct, P = n === 16 ? Un.hex : n === 10 ? Un.dec : n === 8 ? Un.oct : Un.bin, A = !1, C = 0;
    for (let _ = 0, k = a ?? 1 / 0; _ < k; ++_) {
      let O = e.charCodeAt(t), M;
      if (O === 95 && l !== "bail") {
        let F = e.charCodeAt(t - 1), G = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(G) || !P(G) || g.has(F) || g.has(G)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, i);
        }
        ++t;
        continue;
      }
      if (O >= 97 ? M = O - 97 + 10 : O >= 65 ? M = O - 65 + 10 : rV(O) ? M = O - 48 : M = 1 / 0, M >= n) {
        if (M <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (M <= 9 && u.invalidDigit(t, r, i, n))
          M = 0;
        else if (o)
          M = 0, A = !0;
        else
          break;
      }
      ++t, C = C * n + M;
    }
    return t === p || a != null && t - p !== a || A ? {
      n: null,
      pos: t
    } : {
      n: C,
      pos: t
    };
  }
  s($y, "readInt");
  function Hy(e, t, r, i, n, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = Wu(e, t, r, i, e.indexOf("}", t) - t, !0, n, a), ++t, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(t, r, i);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = Wu(e, t, r, i, 4, !1, n, a));
    return {
      code: l,
      pos: t
    };
  }
  s(Hy, "readCodePoint");
  function ls(e, t, r) {
    return new Rt(r, e - t, e);
  }
  s(ls, "buildPosition");
  var nV = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), jt = class {
    static {
      s(this, "Token");
    }
    constructor(t) {
      this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new gi(t.startLoc, t.endLoc);
    }
  }, Yu = class extends Uu {
    static {
      s(this, "Tokenizer");
    }
    constructor(t, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ s((i, n, a, o) => this.options.errorRecovery ? (this.raise(x.InvalidDigit, ls(i, n, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(x.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(x.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(x.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(x.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ s((i, n, a) => {
          this.recordStrictModeErrors(x.StrictNumericEscape, ls(i, n, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(x.UnterminatedString, ls(i - 1, n, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(x.StrictNumericEscape),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(x.UnterminatedTemplate, ls(i, n, a));
        }, "unterminated")
      }), this.state = new Ku(), this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new jt(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), !0) : !1;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return {
        pos: t.pos,
        value: null,
        type: t.type,
        start: t.start,
        end: t.end,
        context: [this.curContext()],
        inType: t.inType,
        startLoc: t.startLoc,
        lastTokEndLoc: t.lastTokEndLoc,
        curLine: t.curLine,
        lineStart: t.lineStart,
        curPosition: t.curPosition
      };
    }
    lookahead() {
      let t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = t, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return ku.lastIndex = t, ku.test(this.input) ? ku.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(t) {
      return Yn.lastIndex = t, Yn.test(this.input) ? Yn.lastIndex : t;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(t) {
      let r = this.input.charCodeAt(t);
      if ((r & 64512) === 55296 && ++t < this.input.length) {
        let i = this.input.charCodeAt(t);
        (i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023));
      }
      return r;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(t) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let i = this.state.pos, n = this.input.indexOf(t, i + 2);
      if (n === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = n + t.length, Vn.lastIndex = i + 2; Vn.test(this.input) && Vn.lastIndex <= n; )
        ++this.state.curLine, this.state.lineStart = Vn.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, n),
        start: i,
        end: n + t.length,
        loc: new gi(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(t) {
      let r = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let n = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !ps(n) && ++this.state.pos < this.length; )
          n = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + t, a),
        start: r,
        end: a,
        loc: new gi(i, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let t = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let n = this.skipBlockComment("*/");
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
                break;
              }
              case 47: {
                let n = this.skipLineComment(2);
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (tV(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.options.annexB) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 45 && this.input.charCodeAt(n + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.options.annexB) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 33 && this.input.charCodeAt(n + 2) === 45 && this.input.charCodeAt(n + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let i = this.state.pos, n = {
          start: t,
          end: i,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(n);
      }
    }
    finishToken(t, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(i);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let t = this.state.pos + 1, r = this.codePointAtPos(t);
      if (r >= 48 && r <= 57)
        throw this.raise(x.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? x.RecordExpressionHashIncorrectStartSyntaxType : x.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else Ht(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(!0);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !ps(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(t) {
      let r = t === 42 ? 55 : 54, i = 1, n = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && n === 42 && (i++, n = this.input.charCodeAt(this.state.pos + 2), r = 57), n === 61 && !this.state.inType && (i++, r = t ===
      37 ? 33 : 30), this.finishOp(r, i);
    }
    readToken_pipe_amp(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 62) {
        let i = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Ht(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(x.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(t)
      });
    }
    finishOp(t, r) {
      let i = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(t, i);
    }
    readRegexp() {
      let t = this.state.startLoc, r = this.state.start + 1, i, n, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(x.UnterminatedRegExp, ht(t, 1));
        let c = this.input.charCodeAt(a);
        if (ps(c))
          throw this.raise(x.UnterminatedRegExp, ht(t, 1));
        if (i)
          i = !1;
        else {
          if (c === 91)
            n = !0;
          else if (c === 93 && n)
            n = !1;
          else if (c === 47 && !n)
            break;
          i = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ s(() => ht(t, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (nV.has(c))
          c === 118 ? l.includes("u") && this.raise(x.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(x.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(x.DuplicateRegExpFlags, u());
        else if (yi(c) || c === 92)
          this.raise(x.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(t, r, i = !1, n = !0) {
      let {
        n: a,
        pos: o
      } = $y(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, i, n, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(t) {
      let r = this.state.curPosition(), i = !1;
      this.state.pos += 2;
      let n = this.readInt(t);
      n == null && this.raise(x.InvalidDigit, ht(r, 2), {
        radix: t
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, i = !0;
      else if (a === 109)
        throw this.raise(x.InvalidDecimal, r);
      if (Ht(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      if (i) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, n);
    }
    readNumber(t) {
      let r = this.state.pos, i = this.state.curPosition(), n = !1, a = !1, o = !1, l = !1, u = !1;
      !t && this.readInt(10) === null && this.raise(x.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let A = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(x.StrictOctalLiteral, i), !this.state.strict) {
          let C = A.indexOf("_");
          C > 0 && this.raise(x.ZeroDigitNumericSeparator, ht(i, C));
        }
        u = c && !/[89]/.test(A);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !u && (++this.state.pos, this.readInt(10), n = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !u && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      x.InvalidOrMissingExponent, i), n = !0, l = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((n || c) && this.raise(x.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), p === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(x.InvalidDecimal,
      i), ++this.state.pos, o = !0), Ht(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      let g = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, g);
        return;
      }
      if (o) {
        this.finishToken(136, g);
        return;
      }
      let P = u ? parseInt(g, 8) : parseFloat(g);
      this.finishToken(134, P);
    }
    readCodePoint(t) {
      let {
        code: r,
        pos: i
      } = Hy(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
      return this.state.pos = i, r;
    }
    readString(t) {
      let {
        str: r,
        pos: i,
        curLine: n,
        lineStart: a
      } = Oy(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = n, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let t = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: i,
        pos: n,
        curLine: a,
        lineStart: o
      } = Oy("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = n + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new Rt(i.curLine,
      i.pos - i.lineStart, i.pos)), this.input.codePointAt(n) === 96 ? this.finishToken(24, i ? null : t + r + "`") : (this.state.pos++, this.
      finishToken(25, i ? null : t + r + "${"));
    }
    recordStrictModeErrors(t, r) {
      let i = r.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(t, r) : this.state.strictErrors.set(i, [t, r]);
    }
    readWord1(t) {
      this.state.containsEsc = !1;
      let r = "", i = this.state.pos, n = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (yi(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(n, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === i ? Ht : yi;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(x.MissingUnicodeEscape, this.state.curPosition()), n = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(x.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), n = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(n, this.state.pos);
    }
    readWord(t) {
      let r = this.readWord1(t), i = ic.get(r);
      i !== void 0 ? this.finishToken(i, yr(i)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: t
      } = this.state;
      uc(t) && this.state.containsEsc && this.raise(x.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: yr(t)
      });
    }
    raise(t, r, i = {}) {
      let n = r instanceof Rt ? r : r.loc.start, a = t(n, i);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(t, r, i = {}) {
      let n = r instanceof Rt ? r : r.loc.start, a = n.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = t(n, i);
        if (u.loc.index < a) break;
      }
      return this.raise(t, r, i);
    }
    updateContext(t) {
    }
    unexpected(t, r) {
      throw this.raise(x.UnexpectedToken, t ?? this.state.startLoc, {
        expected: r ? yr(r) : null
      });
    }
    expectPlugin(t, r) {
      if (this.hasPlugin(t))
        return !0;
      throw this.raise(x.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [t]
      });
    }
    expectOnePlugin(t) {
      if (!t.some((r) => this.hasPlugin(r)))
        throw this.raise(x.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: t
        });
    }
    errorBuilder(t) {
      return (r, i, n) => {
        this.raise(t, ls(r, i, n));
      };
    }
  }, Xu = class {
    static {
      s(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, Ju = class {
    static {
      s(this, "ClassScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Xu());
    }
    exit() {
      let t = this.stack.pop(), r = this.current();
      for (let [i, n] of Array.from(t.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, n) : this.parser.raise(x.InvalidPrivateFieldResolution, n, {
          identifierName: i
        });
    }
    declarePrivateName(t, r, i) {
      let {
        privateNames: n,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = n.has(t);
      if (r & 3) {
        let u = l && a.get(t);
        if (u) {
          let c = u & 4, p = r & 4, g = u & 3, P = r & 3;
          l = g === P || c !== p, l || a.delete(t);
        } else l || a.set(t, r);
      }
      l && this.parser.raise(x.PrivateNameRedeclaration, i, {
        identifierName: t
      }), n.add(t), o.delete(t);
    }
    usePrivateName(t, r) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(t)) return;
      i ? i.undefinedPrivateNames.set(t, r) : this.parser.raise(x.InvalidPrivateFieldResolution, r, {
        identifierName: t
      });
    }
  }, bi = class {
    static {
      s(this, "ExpressionScope");
    }
    constructor(t = 0) {
      this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Hn = class extends bi {
    static {
      s(this, "ArrowHeadParsingScope");
    }
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, r) {
      let i = r.index;
      this.declarationErrors.set(i, [t, r]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }, $u = class {
    static {
      s(this, "ExpressionScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [new bi()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, r) {
      let i = r.loc.start, {
        stack: n
      } = this, a = n.length - 1, o = n[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(t, i);
        else
          return;
        o = n[--a];
      }
      this.parser.raise(t, i);
    }
    recordArrowParameterBindingError(t, r) {
      let {
        stack: i
      } = this, n = i[i.length - 1], a = r.loc.start;
      if (n.isCertainlyParameterDeclaration())
        this.parser.raise(t, a);
      else if (n.canBeArrowParameterDeclaration())
        n.recordDeclarationError(t, a);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      let {
        stack: r
      } = this, i = r.length - 1, n = r[i];
      for (; n.canBeArrowParameterDeclaration(); )
        n.type === 2 && n.recordDeclarationError(x.AwaitBindingIdentifier, t), n = r[--i];
    }
    validateAsPattern() {
      let {
        stack: t
      } = this, r = t[t.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([i, n]) => {
        this.parser.raise(i, n);
        let a = t.length - 2, o = t[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(n.index), o = t[--a];
      });
    }
  };
  function aV() {
    return new bi(3);
  }
  s(aV, "newParameterDeclarationScope");
  function oV() {
    return new Hn(1);
  }
  s(oV, "newArrowHeadScope");
  function lV() {
    return new Hn(2);
  }
  s(lV, "newAsyncArrowScope");
  function Gy() {
    return new bi();
  }
  s(Gy, "newExpressionScope");
  var Hu = class {
    static {
      s(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Xn(e, t) {
    return (e ? 2 : 0) | (t ? 1 : 0);
  }
  s(Xn, "functionFlags");
  var Gu = class extends Yu {
    static {
      s(this, "UtilParser");
    }
    addExtra(t, r, i, n = !0) {
      if (!t) return;
      let a = t.extra = t.extra || {};
      n ? a[r] = i : Object.defineProperty(a, r, {
        enumerable: n,
        value: i
      });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, r) {
      let i = t + r.length;
      if (this.input.slice(t, i) === r) {
        let n = this.input.charCodeAt(i);
        return !(yi(n) || (n & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(t) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), !0) : !1;
    }
    expectContextual(t, r) {
      if (!this.eatContextual(t)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, t);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Jy.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return Iy.lastIndex = this.state.end, Iy.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(t = !0) {
      (t ? this.isLineTerminator() : this.eat(13)) || this.raise(x.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(t, r) {
      this.eat(t) || this.unexpected(r, t);
    }
    tryParse(t, r = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let n = t((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: n,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: n,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (n) {
        let a = this.state;
        if (this.state = r, n instanceof SyntaxError)
          return {
            node: null,
            error: n,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (n === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw n;
      }
    }
    checkExpressionErrors(t, r) {
      if (!t) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: n,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = t, l = !!i || !!n || !!o || !!a;
      if (!r)
        return l;
      i != null && this.raise(x.InvalidCoverInitializedName, i), n != null && this.raise(x.DuplicateProto, n), a != null && this.raise(x.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return Ry(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes(t = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let n = this.inModule;
      this.inModule = t;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, t);
      let l = this.prodParam;
      this.prodParam = new Hu();
      let u = this.classScope;
      this.classScope = new Ju(this);
      let c = this.expressionScope;
      return this.expressionScope = new $u(this), () => {
        this.state.labels = r, this.exportedIdentifiers = i, this.inModule = n, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let t = 0;
      this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
    }
    checkDestructuringPrivate(t) {
      let {
        privateKeyLoc: r
      } = t;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, Ti = class {
    static {
      s(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Si = class {
    static {
      s(this, "Node");
    }
    constructor(t, r, i) {
      this.type = "", this.start = r, this.end = 0, this.loc = new gi(i), t != null && t.options.ranges && (this.range = [r, 0]), t != null &&
      t.filename && (this.loc.filename = t.filename);
    }
  }, fc = Si.prototype;
  fc.__clone = function() {
    let e = new Si(void 0, this.start, this.loc.start), t = Object.keys(this);
    for (let r = 0, i = t.length; r < i; r++) {
      let n = t[r];
      n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments" && (e[n] = this[n]);
    }
    return e;
  };
  function uV(e) {
    return zt(e);
  }
  s(uV, "clonePlaceholder");
  function zt(e) {
    let {
      type: t,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o,
      name: l
    } = e, u = Object.create(fc);
    return u.type = t, u.start = r, u.end = i, u.loc = n, u.range = a, u.extra = o, u.name = l, t === "Placeholder" && (u.expectedNode = e.expectedNode),
    u;
  }
  s(zt, "cloneIdentifier");
  function cV(e) {
    let {
      type: t,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o
    } = e;
    if (t === "Placeholder")
      return uV(e);
    let l = Object.create(fc);
    return l.type = t, l.start = r, l.end = i, l.loc = n, l.range = a, e.raw !== void 0 ? l.raw = e.raw : l.extra = o, l.value = e.value, l;
  }
  s(cV, "cloneStringLiteral");
  var zu = class extends Gu {
    static {
      s(this, "NodeUtils");
    }
    startNode() {
      let t = this.state.startLoc;
      return new Si(this, t.index, t);
    }
    startNodeAt(t) {
      return new Si(this, t.index, t);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.loc.start);
    }
    finishNode(t, r) {
      return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, r, i) {
      return t.type = r, t.end = i.index, t.loc.end = i, this.options.ranges && (t.range[1] = i.index), this.options.attachComment && this.processComment(
      t), t;
    }
    resetStartLocation(t, r) {
      t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
    }
    resetEndLocation(t, r = this.state.lastTokEndLoc) {
      t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
    }
    resetStartLocationFromNode(t, r) {
      this.resetStartLocation(t, r.loc.start);
    }
  }, pV = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "stat\
ic", "string", "true", "typeof", "void"]), re = Gt`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ s(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ s(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ s(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ s(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ s(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ s(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ s(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ s(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ s(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function fV(e) {
    return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "T\
ypeAlias" && e.declaration.type !== "InterfaceDeclaration");
  }
  s(fV, "isEsModuleType");
  function Ny(e) {
    return e.importKind === "type" || e.importKind === "typeof";
  }
  s(Ny, "hasTypeImportKind");
  var hV = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function dV(e, t) {
    let r = [], i = [];
    for (let n = 0; n < e.length; n++)
      (t(e[n], n, e) ? r : i).push(e[n]);
    return [r, i];
  }
  s(dV, "partition");
  var mV = /\*?\s*@((?:no)?flow)\b/, yV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return qu;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, i) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, i);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let i = mV.exec(r.value);
        if (i) if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let i = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let n = this.flowParseType();
      return this.state.inType = i, n;
    }
    flowParsePredicate() {
      let r = this.startNode(), i = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(re.UnexpectedSpaceBetweenModuloChecks,
      i), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let i = null, n = null;
      return this.match(54) ? (this.state.inType = r, n = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = r, this.
      match(54) && (n = this.flowParsePredicate())), [i, n];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let i = r.id = this.parseIdentifier(), n = this.startNode(), a = this.startNode();
      this.match(47) ? n.typeParameters = this.flowParseTypeParameterDeclaration() : n.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return n.params = o.params, n.rest = o.rest, n.this = o._this, this.expect(11), [n.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(n, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      i), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, i) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (i && this.raise(re.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, i);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let i = r.body = this.startNode(), n = i.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(re.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, re.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), n.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
      let a = null, o = !1;
      return n.forEach((l) => {
        fV(l) ? (a === "CommonJS" && this.raise(re.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(re.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(re.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, i) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
        let n = this.state.value;
        throw this.raise(re.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: n,
          suggestion: hV[n]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let i = this.flowParseTypeAlias(r);
      return i.type = "DeclareTypeAlias", i;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let i = this.flowParseOpaqueType(r, !0);
      return i.type = "DeclareOpaqueType", i;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, i) {
      if (r.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(r.id.name, i ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!i && this.eat(12));
      if (i) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: i,
        allowExact: !1,
        allowSpread: !1,
        allowProto: i,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(re.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, i, n) {
      pV.has(r) && this.raise(n ? re.AssignReservedType : re.UnexpectedReservedType, i, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, i) {
      return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, i) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, i || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let i = this.state.startLoc, n = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return n.name = o.name, n.variance = a, n.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), n.default = this.flowParseType()) :
      r && this.raise(re.MissingTypeParamDefault, i), this.finishNode(n, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, i = this.startNode();
      i.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let n = !1;
      do {
        let a = this.flowParseTypeParameter(n);
        i.params.push(a), a.default && (n = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(i, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), i = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let n = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = n, this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), i = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, i, n) {
      return r.static = i, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = n, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, i) {
      return r.static = i, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, i) {
      let n = this.startNode();
      return r.static = i, r.value = this.flowParseObjectTypeMethodish(n), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: i,
      allowSpread: n,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, g = !1;
      for (i && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let A = !1, C = null, _ = null, k = this.startNode();
        if (a && this.isContextual(118)) {
          let M = this.lookahead();
          M.type !== 14 && M.type !== 17 && (this.next(), C = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let M = this.lookahead();
          M.type !== 14 && M.type !== 17 && (this.next(), A = !0);
        }
        let O = this.flowParseVariance();
        if (this.eat(0))
          C != null && this.unexpected(C), this.eat(0) ? (O && this.unexpected(O.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          k, A))) : u.indexers.push(this.flowParseObjectTypeIndexer(k, A, O));
        else if (this.match(10) || this.match(47))
          C != null && this.unexpected(C), O && this.unexpected(O.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(k, A));
        else {
          let M = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let G = this.lookahead();
            Ry(G.type) && (M = this.state.value, this.next());
          }
          let F = this.flowParseObjectTypeProperty(k, A, C, O, M, n, o ?? !p);
          F === null ? (g = !0, _ = this.state.lastTokStartLoc) : u.properties.push(F);
        }
        this.flowObjectTypeSemicolon(), _ && !this.match(8) && !this.match(9) && this.raise(re.UnexpectedExplicitInexactInObject, _);
      }
      this.expect(c), n && (u.inexact = g);
      let P = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, P;
    }
    flowParseObjectTypeProperty(r, i, n, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(re.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(re.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(re.InexactVariance, a), null) : (l || this.raise(
        re.UnexpectedSpreadType, this.state.lastTokStartLoc), n != null && this.unexpected(n), a && this.raise(re.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = i, r.proto = n != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, n != null && this.unexpected(n), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(re.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let i = r.kind === "get" ? 0 : 1, n = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? re.GetterMayNotHaveThisParam : re.SetterMayNotHaveThisParam, r.value.this), n !== i && this.
      raise(r.kind === "get" ? x.BadGetterArity : x.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(x.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, i) {
      var n;
      (n = r) != null || (r = this.state.startLoc);
      let a = i || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, i) {
      let n = this.startNodeAt(r);
      return n.typeParameters = null, n.id = this.flowParseQualifiedTypeIdentifier(r, i), this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(n, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let i = null, n = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(re.ThisParamMustBeFirst, o), i = this.parseIdentifier(u), this.eat(17) &&
      (n = !0, u && this.raise(re.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = i,
      o.optional = n, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let i = this.startNodeAt(r.loc.start);
      return i.name = null, i.optional = !1, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let i = null, n = null;
      for (this.match(78) && (n = this.flowParseFunctionTypeParam(!0), n.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: i,
        _this: n
      };
    }
    flowIdentToTypeAnnotation(r, i, n) {
      switch (n.name) {
        case "any":
          return this.finishNode(i, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(i, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(i, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(i, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(i, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(i, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(i, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(n.name), this.flowParseGenericType(r, n);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, i = this.startNode(), n, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47:
          return i.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), n = this.flowParseFunctionTypeParams(), i.params =
          n.params, i.rest = n.rest, i.this = n._this, this.expect(11), this.expect(19), i.returnType = this.flowParseType(), this.finishNode(
          i, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (ve(this.state.type) || this.match(78)) {
              let u = this.lookahead().type;
              o = u !== 17 && u !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? n = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : n = this.flowParseFunctionTypeParams(),
          i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), this.expect(19), i.returnType = this.flowParseType(), i.typeParameters =
          null, this.finishNode(i, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
            throw this.raise(re.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(i, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(i, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (uc(this.state.type)) {
            let u = yr(this.state.type);
            return this.next(), super.createIdentifier(i, u);
          } else if (ve(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, i, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, i = this.flowParsePrimaryType(), n = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        n = n || o, this.expect(0), !o && this.match(3) ? (a.elementType = i, this.next(), i = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = i, a.indexType = this.flowParseType(), this.expect(3), n ? (a.optional = o, i = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : i = this.finishNode(a, "IndexedAccessType"));
      }
      return i;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let i = this.startNodeAt(r.loc.start);
        return i.params = [this.reinterpretTypeAsFunctionTypeParam(r)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.
        typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let i = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [i]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? i : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let i = this.flowParseIntersectionType();
      for (r.types = [i]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? i : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let i = this.flowParseUnionType();
      return this.state.inType = r, i;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, i = this.parseIdentifier();
        return this.flowParseGenericType(r, i);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let i = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, i, n = !1) {
      if (i) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, n));
        return;
      }
      super.parseFunctionBody(r, !1, n);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, i, n);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let n = this.lookahead();
        if (Dt(n.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let n = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(n);
      }
      let i = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
    }
    parseExpressionStatement(r, i, n) {
      if (i.type === "Identifier") {
        if (i.name === "declare") {
          if (this.match(80) || ve(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (ve(this.state.type)) {
          if (i.name === "interface")
            return this.flowParseInterface(r);
          if (i.name === "type")
            return this.flowParseTypeAlias(r);
          if (i.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return Cy(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return Cy(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, i, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let P = this.lookaheadCharCode();
        if (P === 44 || P === 61 || P === 58 || P === 41)
          return this.setOptionalParametersError(n), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(i), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, g] = this.getArrowLikeExpressions(u);
      if (c || g.length > 0) {
        let P = [...o];
        if (g.length > 0) {
          this.state = a, this.state.noArrowAt = P;
          for (let A = 0; A < g.length; A++)
            P.push(g[A].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, g] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(re.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, P.push(p[0].start),
        this.state.noArrowAt = P, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), i = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: i
      };
    }
    getArrowLikeExpressions(r, i) {
      let n = [r], a = [];
      for (; n.length !== 0; ) {
        let o = n.pop();
        o.type === "ArrowFunctionExpression" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(o) : a.push(o), n.push(o.body)) :
        o.type === "ConditionalExpression" && (n.push(o.consequent), n.push(o.alternate));
      }
      return i ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : dV(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var i;
      this.toAssignableList(r.params, (i = r.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, i) {
      let n;
      return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), n =
      i(), this.state.noArrowParamsConversionAt.pop()) : n = i(), n;
    }
    parseParenItem(r, i) {
      if (r = super.parseParenItem(r, i), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let n = this.startNodeAt(i);
        return n.expression = r, n.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n, "TypeCastExpression");
      }
      return r;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        i);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseOpaqueType(i, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseInterface(i);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: i
      } = this.state, n = super.maybeParseExportNamespaceSpecifier(r);
      return n && r.exportKind === "type" && this.unexpected(i), n;
    }
    parseClassId(r, i, n) {
      super.parseClassId(r, i, n), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, i, n) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, i))
          return;
        i.declare = !0;
      }
      super.parseClassMember(r, i, n), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "Property\
Definition" ? this.raise(re.DeclareClassElement, a) : i.value && this.raise(re.DeclareClassFieldInitializer, i.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), i = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(x.InvalidIdentifier, this.state.curPosition(), {
        identifierName: i
      }), this.finishToken(132, i);
    }
    getTokenFromCode(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : zq(r, i, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, i) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      !i && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, i);
    }
    toAssignableList(r, i, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, i, n);
    }
    toReferencedList(r, i) {
      for (let a = 0; a < r.length; a++) {
        var n;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((n = o.extra) != null && n.parenthesized) && (r.length > 1 || !i) && this.raise(re.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return i && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, i, n) {
      return r === "TypeCastExpression" || super.isValidLVal(r, i, n);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, i, n, a, o, l) {
      if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, i, n, a, o, l), i.params && o) {
        let u = i.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(re.ThisParamBannedInConstructor, i);
      } else if (i.type === "MethodDefinition" && o && i.value.params) {
        let u = i.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(re.ThisParamBannedInConstructor, i);
      }
    }
    pushClassPrivateMethod(r, i, n, a) {
      i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, i, n, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let i = r.implements = [];
        do {
          let n = this.startNode();
          n.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? n.typeParameters = this.flowParseTypeParameterInstantiation() : n.
          typeParameters = null, i.push(this.finishNode(n, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let i = this.getObjectOrClassMethodParams(r);
      if (i.length > 0) {
        let n = i[0];
        this.isThisParam(n) && r.kind === "get" ? this.raise(re.GetterMayNotHaveThisParam, n) : this.isThisParam(n) && this.raise(re.SetterMayNotHaveThisParam,
        n);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, i, n, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, i, n, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(re.PatternIsOptional, r), this.isThisParam(r) && this.raise(re.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(re.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(re.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(re.TypeBeforeInitializer,
      n.typeAnnotation), n;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(re.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, i, n) {
      i.local = Ny(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(i,
      n));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let i = this.lookaheadCharCode();
        return i === 123 || i === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      if (super.applyImportPhase(r, i, n, a), i) {
        if (!n && this.match(65))
          return;
        r.exportKind = n === "type" ? n : "value";
      } else
        n === "type" && this.match(55) && this.unexpected(), r.importKind = n === "type" || n === "typeof" ? n : "value";
    }
    parseImportSpecifier(r, i, n, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let g = this.parseIdentifier(!0);
        u !== null && !Dt(this.state.type) ? (r.imported = g, r.importKind = u, r.local = zt(g)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && Dt(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (i)
            throw this.raise(x.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = zt(r.imported));
      }
      let p = Ny(r);
      return n && p && this.raise(re.ImportTypeShorthandOnlyInPureImport, r), (n || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !n && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, i) {
      let n = r.kind;
      n !== "get" && n !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      if (this.match(14)) {
        let n = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = n;
      }
      return super.parseAsyncArrowFromCallExpression(r, i);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, i) {
      var n;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, i), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === we.j_oTag || p === we.j_expr) && c.pop();
      }
      if ((n = o) != null && n.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((P) => {
          var A;
          c = this.flowParseTypeParameterDeclaration();
          let C = this.forwardNoArrowParamsConversionAt(c, () => {
            let k = super.parseMaybeAssign(r, i);
            return this.resetStartLocationFromNode(k, c), k;
          });
          (A = C.extra) != null && A.parenthesized && P();
          let _ = this.maybeUnwrapTypeCastExpression(C);
          return _.type !== "ArrowFunctionExpression" && P(), _.typeParameters = c, this.resetStartLocationFromNode(_, c), C;
        }, a), g = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(re.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          g = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (g)
          return this.state = p.failState, g;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(re.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse(() => {
          let n = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = n, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (i.thrown) return null;
        i.error && (this.state = i.failState), r.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, i) {
      this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = i : super.setArrowFunctionParameters(r, i);
    }
    checkParams(r, i, n, a = !0) {
      if (!(n && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(re.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, i, n, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(r, i, n) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(i.index) !== -1) {
        this.next();
        let a = this.startNodeAt(i);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(i) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, i, n), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, i, n);
    }
    parseSubscript(r, i, n, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, n)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(i);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!n && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(i);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let i = null;
      this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      i;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let i = this.startNodeAt(r);
      if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
        return super.parseArrowExpression(i, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && i === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && i === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, i) {
      let n = super.parseTopLevel(r, i);
      return this.state.hasFlowComment && this.raise(re.UnterminatedFlowComment, this.state.curPosition()), n;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(re.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, i = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + i)); )
        i++;
      let n = this.input.charCodeAt(i + r), a = this.input.charCodeAt(i + r + 1);
      return n === 58 && a === 58 ? i + 2 : this.input.slice(i + r, i + r + 12) === "flow-include" ? i + 12 : n === 58 && a !== 58 ? i : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: i,
      memberName: n
    }) {
      this.raise(re.EnumBooleanMemberNotInitialized, r, {
        memberName: n,
        enumName: i
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, i) {
      return this.raise(i.explicitType ? i.explicitType === "symbol" ? re.EnumInvalidMemberInitializerSymbolType : re.EnumInvalidMemberInitializerPrimaryType :
      re.EnumInvalidMemberInitializerUnknownType, r, i);
    }
    flowEnumErrorNumberMemberNotInitialized(r, i) {
      this.raise(re.EnumNumberMemberNotInitialized, r, i);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, i) {
      this.raise(re.EnumStringMemberInconsistentlyInitialized, r, i);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, i = /* @__PURE__ */ s(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let n = this.parseNumericLiteral(this.state.value);
          return i() ? {
            type: "number",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let n = this.parseStringLiteral(this.state.value);
          return i() ? {
            type: "string",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let n = this.parseBooleanLiteral(this.match(85));
          return i() ? {
            type: "boolean",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, i = this.parseIdentifier(!0), n = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: i,
        init: n
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, i, n) {
      let {
        explicitType: a
      } = i;
      a !== null && a !== n && this.flowEnumErrorInvalidMemberInitializer(r, i);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: i
    }) {
      let n = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(re.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), n.has(p) && this.raise(re.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: r
        }), n.add(p);
        let g = {
          enumName: r,
          explicitType: i,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, g, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, g, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, g, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, g);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, g);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, g);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, i, {
      enumName: n
    }) {
      if (r.length === 0)
        return i;
      if (i.length === 0)
        return r;
      if (i.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return i;
      } else {
        for (let a of i)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!ve(this.state.type))
        throw this.raise(re.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: i
      } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(re.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: i
      }), i;
    }
    flowEnumBody(r, i) {
      let n = i.name, a = i.loc.start, o = this.flowEnumParseExplicitType({
        enumName: n
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: n,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: n
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ s(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = l.booleanMembers.length, g = l.numberMembers.length, P = l.stringMembers.length, A = l.defaultedMembers.length;
          if (!p && !g && !P && !A)
            return c();
          if (!p && !g)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: n
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!g && !P && p >= A) {
            for (let C of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(C.loc.start, {
                enumName: n,
                memberName: C.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !P && g >= A) {
            for (let C of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(C.loc.start, {
                enumName: n,
                memberName: C.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(re.EnumInconsistentMemberValues, a, {
              enumName: n
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let i = this.parseIdentifier();
      return r.id = i, r.body = this.flowEnumBody(this.startNode(), i), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let i = this.input.charCodeAt(r + 1);
        return i !== 60 && i !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), TV = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Kr = Gt`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ s(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ s(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function dr(e) {
    return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
  }
  s(dr, "isFragment");
  function mi(e) {
    if (e.type === "JSXIdentifier")
      return e.name;
    if (e.type === "JSXNamespacedName")
      return e.namespace.name + ":" + e.name.name;
    if (e.type === "JSXMemberExpression")
      return mi(e.object) + "." + mi(e.property);
    throw new Error("Node had unexpected type: " + e.type);
  }
  s(mi, "getQualifiedJSXName");
  var gV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", i = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Kr.UnterminatedJsxContent, this.state.startLoc);
        let n = this.input.charCodeAt(this.state.pos);
        switch (n) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              n === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(n);
              return;
            }
            r += this.input.slice(i, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(i, this.state.pos), r += this.jsxReadEntity(), i = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            ps(n) ? (r += this.input.slice(i, this.state.pos), r += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let i = this.input.charCodeAt(this.state.pos), n;
      return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, n = r ? `
` : `\r
`) : n = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, n;
    }
    jsxReadString(r) {
      let i = "", n = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(x.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (i += this.input.slice(n, this.state.pos), i += this.jsxReadEntity(), n = this.state.pos) : ps(a) ? (i += this.input.slice(
        n, this.state.pos), i += this.jsxReadNewLine(!1), n = this.state.pos) : ++this.state.pos;
      }
      i += this.input.slice(n, this.state.pos++), this.finishToken(133, i);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let i = 10;
        this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
        let n = this.readInt(i, void 0, !1, "bail");
        if (n !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(n);
      } else {
        let i = 0, n = !1;
        for (; i++ < 10 && this.state.pos < this.length && !(n = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (n) {
          let a = this.input.slice(r, this.state.pos), o = TV[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, i = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (yi(r) || r === 45);
      this.finishToken(140, this.input.slice(i, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : uc(this.state.type) ? r.name = yr(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, i = this.jsxParseIdentifier();
      if (!this.eat(14)) return i;
      let n = this.startNodeAt(r);
      return n.namespace = i, n.name = this.jsxParseIdentifier(), this.finishNode(n, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, i = this.jsxParseNamespacedName();
      if (i.type === "JSXNamespacedName")
        return i;
      for (; this.eat(16); ) {
        let n = this.startNodeAt(r);
        n.object = i, n.property = this.jsxParseIdentifier(), i = this.finishNode(n, "JSXMemberExpression");
      }
      return i;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(we.brace), this.next(), r = this.jsxParseExpressionContainer(r, we.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(Kr.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(Kr.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(we.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, i) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let n = this.parseExpression();
        r.expression = n;
      }
      return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(we.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      we.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      i));
    }
    jsxParseOpeningElementAfterName(r) {
      let i = [];
      for (; !this.match(56) && !this.match(143); )
        i.push(this.jsxParseAttribute());
      return r.attributes = i, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      i, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let i = this.startNodeAt(r), n = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              n.push(this.jsxParseElementAt(r));
              break;
            case 141:
              n.push(this.parseExprAtom());
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(we.brace), this.next(), this.match(21) ? n.push(this.jsxParseSpreadChild(l)) : n.push(this.jsxParseExpressionContainer(
              l, we.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        dr(a) && !dr(o) && o !== null ? this.raise(Kr.MissingClosingTagFragment, o) : !dr(a) && dr(o) ? this.raise(Kr.MissingClosingTagElement,
        o, {
          openingTagName: mi(a.name)
        }) : !dr(a) && !dr(o) && mi(o.name) !== mi(a.name) && this.raise(Kr.MissingClosingTagElement, o, {
          openingTagName: mi(a.name)
        });
      }
      if (dr(a) ? (i.openingFragment = a, i.closingFragment = o) : (i.openingElement = a, i.closingElement = o), i.children = n, this.match(
      47))
        throw this.raise(Kr.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return dr(a) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: i
      } = this.state;
      i[i.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) &&
      this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let i = this.curContext();
      if (i === we.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (i === we.j_oTag || i === we.j_cTag) {
        if (Ht(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && i === we.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: i,
        type: n
      } = this.state;
      if (n === 56 && r === 142)
        i.splice(-2, 2, we.j_cTag), this.state.canStartJSXElement = !1;
      else if (n === 142)
        i.push(we.j_oTag);
      else if (n === 143) {
        let a = i[i.length - 1];
        a === we.j_oTag && r === 56 || a === we.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === we.j_expr) : (this.setContext(
        we.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = Mq(n);
    }
  }, "jsx"), Qu = class extends fs {
    static {
      s(this, "TypeScriptScope");
    }
    constructor(...t) {
      super(...t), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, Zu = class extends hs {
    static {
      s(this, "TypeScriptScopeHandler");
    }
    constructor(...t) {
      super(...t), this.importsStack = [];
    }
    createScope(t) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new Qu(t);
    }
    enter(t) {
      t == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
    }
    exit() {
      let t = super.exit();
      return t == 256 && this.importsStack.pop(), t;
    }
    hasImport(t, r) {
      let i = this.importsStack.length;
      if (this.importsStack[i - 1].has(t))
        return !0;
      if (!r && i > 1) {
        for (let n = 0; n < i - 1; n++)
          if (this.importsStack[n].has(t)) return !0;
      }
      return !1;
    }
    declareName(t, r, i) {
      if (r & 4096) {
        this.hasImport(t, !0) && this.parser.raise(x.VarRedeclaration, i, {
          identifierName: t
        }), this.importsStack[this.importsStack.length - 1].add(t);
        return;
      }
      let n = this.currentScope(), a = n.tsNames.get(t) || 0;
      if (r & 1024) {
        this.maybeExportDefined(n, t), n.tsNames.set(t, a | 16);
        return;
      }
      super.declareName(t, r, i), r & 2 && (r & 1 || (this.checkRedeclarationInScope(n, t, r, i), this.maybeExportDefined(n, t)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && n.tsNames.set(t, a);
    }
    isRedeclaredInScope(t, r, i) {
      let n = t.tsNames.get(r);
      if ((n & 2) > 0) {
        if (i & 256) {
          let a = !!(i & 512), o = (n & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return i & 128 && (n & 8) > 0 ? t.names.get(r) & 2 ? !!(i & 1) : !1 : i & 2 && (n & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, i);
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      if (this.hasImport(r)) return;
      let i = this.scopeStack.length;
      for (let n = i - 1; n >= 0; n--) {
        let o = this.scopeStack[n].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(t);
    }
  }, bV = /* @__PURE__ */ s((e, t) => hasOwnProperty.call(e, t) && e[t], "getOwn$1"), zy = /* @__PURE__ */ s((e) => e.type === "Parenthesize\
dExpression" ? zy(e.expression) : e, "unwrapParenthesizedExpression"), ec = class extends zu {
    static {
      s(this, "LValParser");
    }
    toAssignable(t, r = !1) {
      var i, n;
      let a;
      switch ((t.type === "ParenthesizedExpression" || (i = t.extra) != null && i.parenthesized) && (a = zy(t), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(x.InvalidParenthesizedAssignment, t) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(x.InvalidParenthesizedAssignment, t) : this.raise(x.InvalidParenthesizedAssignment, t)), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          t.type = "ObjectPattern";
          for (let l = 0, u = t.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = t.properties[l], g = l === c;
            this.toAssignableObjectExpressionProp(p, g, r), g && p.type === "RestElement" && (o = t.extra) != null && o.trailingCommaLoc && this.
            raise(x.RestTrailingComma, t.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = t;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          t.type = "ArrayPattern", this.toAssignableList(t.elements, (n = t.extra) == null ? void 0 : n.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(x.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(
          t.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, r, i) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? x.PatternHasAccessor : x.PatternHasMethod, t.key);
      else if (t.type === "SpreadElement") {
        t.type = "RestElement";
        let n = t.argument;
        this.checkToRestConversion(n, !1), this.toAssignable(n, i), r || this.raise(x.RestTrailingComma, t);
      } else
        this.toAssignable(t, i);
    }
    toAssignableList(t, r, i) {
      let n = t.length - 1;
      for (let a = 0; a <= n; a++) {
        let o = t[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, i);
          } else
            this.toAssignable(o, i);
          o.type === "RestElement" && (a < n ? this.raise(x.RestTrailingComma, o) : r && this.raise(x.RestTrailingComma, r));
        }
      }
    }
    isAssignable(t, r) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let i = t.properties.length - 1;
          return t.properties.every((n, a) => n.type !== "ObjectMethod" && (a === i || n.type !== "SpreadElement") && this.isAssignable(n));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((i) => i === null || this.isAssignable(i));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(t, r) {
      return t;
    }
    toReferencedListDeep(t, r) {
      this.toReferencedList(t, r);
      for (let i of t)
        i?.type === "ArrayExpression" && this.toReferencedListDeep(i.elements);
    }
    parseSpread(t) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let t = this.startNode();
      return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, r, i) {
      let n = i & 1, a = [], o = !0;
      for (; !this.eat(t); )
        if (o ? o = !1 : this.expect(12), n && this.match(12))
          a.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), i)), !this.checkCommaAfterRest(r)) {
              this.expect(t);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(x.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(i, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(t) {
      return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      let t = this.startNode(), {
        type: r,
        startLoc: i
      } = this.state;
      return r === 21 ? this.parseBindingRestProperty(t) : (r === 138 ? (this.expectPlugin("destructuringPrivate", i), this.classScope.usePrivateName(
      this.state.value, i), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = !1, this.parseObjPropValue(t, i, !1, !1,
      !0, !1));
    }
    parseAssignableListItem(t, r) {
      let i = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(i, t);
      let n = this.parseMaybeDefault(i.loc.start, i);
      return r.length && (i.decorators = r), n;
    }
    parseAssignableListItemTypes(t, r) {
      return t;
    }
    parseMaybeDefault(t, r) {
      var i, n;
      if ((i = t) != null || (t = this.state.startLoc), r = (n = r) != null ? n : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(t);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(t, r, i) {
      return bV({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, t);
    }
    isOptionalMemberExpression(t) {
      return t.type === "OptionalMemberExpression";
    }
    checkLVal(t, {
      in: r,
      binding: i = 64,
      checkClashes: n = !1,
      strictModeChanged: a = !1,
      hasParenthesizedAncestor: o = !1
    }) {
      var l;
      let u = t.type;
      if (this.isObjectMethod(t)) return;
      let c = this.isOptionalMemberExpression(t);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(x.InvalidLhsOptionalChaining,
        t, {
          ancestor: r
        })), i !== 64 && this.raise(x.InvalidPropertyBindingPattern, t);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(t, i, a);
        let {
          name: C
        } = t;
        n && (n.has(C) ? this.raise(x.ParamDupe, t) : n.add(C));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = t.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", i);
      if (p === !0) return;
      if (p === !1) {
        let C = i === 64 ? x.InvalidLhs : x.InvalidLhsBinding;
        this.raise(C, t, {
          ancestor: r
        });
        return;
      }
      let [g, P] = Array.isArray(p) ? p : [p, u === "ParenthesizedExpression"], A = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r;
      for (let C of [].concat(t[g]))
        C && this.checkLVal(C, {
          in: A,
          binding: i,
          checkClashes: n,
          strictModeChanged: a,
          hasParenthesizedAncestor: P
        });
    }
    checkIdentifier(t, r, i = !1) {
      this.state.strict && (i ? Yy(t.name, this.inModule) : Wy(t.name)) && (r === 64 ? this.raise(x.StrictEvalArguments, t, {
        referenceName: t.name
      }) : this.raise(x.StrictEvalArgumentsBinding, t, {
        bindingName: t.name
      })), r & 8192 && t.name === "let" && this.raise(x.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
    }
    declareNameFromIdentifier(t, r) {
      this.scope.declareName(t.name, r, t.loc.start);
    }
    checkToRestConversion(t, r) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(x.InvalidRestAssignmentPattern, t);
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? x.RestTrailingComma : x.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, SV = /* @__PURE__ */ s((e, t) => hasOwnProperty.call(e, t) && e[t], "getOwn");
  function xV(e) {
    if (e == null)
      throw new Error(`Unexpected ${e} value.`);
    return e;
  }
  s(xV, "nonNull");
  function _y(e) {
    if (!e)
      throw new Error("Assert fail");
  }
  s(_y, "assert");
  var J = Gt`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ s(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ s(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ s(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ s(({
      modifier: e
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ s(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ s(({
      token: e
    }) => `'${e}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ s(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ s(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ s(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ s(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ s(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ s(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`, "UnsupportedSignatureParameterKind")
  });
  function EV(e) {
    switch (e) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  s(EV, "keywordTypeFromName");
  function Dy(e) {
    return e === "private" || e === "public" || e === "protected";
  }
  s(Dy, "tsIsAccessModifier");
  function PV(e) {
    return e === "in" || e === "out";
  }
  s(PV, "tsIsVarianceAnnotations");
  var AV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: J.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: J.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: J.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return Zu;
    }
    tsIsIdentifier() {
      return ve(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, i) {
      if (!ve(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let n = this.state.value;
      if (r.indexOf(n) !== -1) {
        if (i && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return n;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: i,
      stopOnStartOfClassStaticBlock: n,
      errorTemplate: a = J.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ s((c, p, g, P) => {
        p === g && o[P] && this.raise(J.InvalidModifiersOrder, c, {
          orderedModifiers: [g, P]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ s((c, p, g, P) => {
        (o[g] && p === P || o[P] && p === g) && this.raise(J.IncompatibleModifiers, c, {
          modifiers: [g, P]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(i ?? []), n);
        if (!p) break;
        Dy(p) ? o.accessibility ? this.raise(J.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : PV(p) ? (o[p] && this.raise(J.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(J.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), i != null && i.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, i) {
      let n = [];
      for (; !this.tsIsListTerminator(r); )
        n.push(i());
      return n;
    }
    tsParseDelimitedList(r, i, n) {
      return xV(this.tsParseDelimitedListWorker(r, i, !0, n));
    }
    tsParseDelimitedListWorker(r, i, n, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = i();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        n && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, i, n, a, o) {
      a || (n ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, i, o);
      return n ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(J.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let i = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let n = this.startNodeAtNode(i);
        n.left = i, n.right = this.parseIdentifier(r), i = this.finishNode(n, "TSQualifiedName");
      }
      return i;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let i = this.startNodeAtNode(r);
      return i.parameterName = r, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let i = this.startNode();
      return r(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(
      29), this.finishNode(i, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let i = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let n = {
        value: -1
      };
      return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, n), i.params.
      length === 0 && this.raise(J.EmptyTypeParameters, i), n.value !== -1 && this.addExtra(i, "trailingComma", n.value), this.finishNode(i,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, i) {
      let n = r === 19, a = "parameters", o = "typeAnnotation";
      i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[a] = this.tsParseBindingListForSignature(),
      n ? i[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (i[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let i of r) {
        let {
          type: n
        } = i;
        (n === "AssignmentPattern" || n === "TSParameterProperty") && this.raise(J.UnsupportedSignatureParameterKind, i, {
          type: n
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, i) {
      return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), ve(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let i = this.parseIdentifier();
      i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), r.parameters = [i];
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, i) {
      this.eat(17) && (r.optional = !0);
      let n = r;
      if (this.match(10) || this.match(47)) {
        i && this.raise(J.ReadonlyForMethodSignature, r);
        let a = n;
        a.kind && this.match(47) && this.raise(J.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(x.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(J.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(x.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(J.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.optional &&
            this.raise(J.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(J.SetAccesorCannotHaveRestParameter,
            this.state.curPosition());
          }
          a[l] && this.raise(J.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = n;
        i && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let n = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(n, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let i = this.tsTryParseIndexSignature(r);
      return i || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let i = !1;
      return r.elementTypes.forEach((n) => {
        let {
          type: a
        } = n;
        i && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && n.optional) && this.raise(J.OptionalTypeBeforeRequired,
        n), i || (i = a === "TSNamedTupleMember" && n.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, i = this.eat(21), n, a, o, l, c = Dt(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        n = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let p = this.state.startLoc, g = this.state.value, P = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (n = !0, a = this.createIdentifier(this.startNodeAt(p), g), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (n = !1, l = P, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), n = this.eat(14);
      if (n) {
        let p;
        a ? (p = this.startNodeAtNode(a), p.optional = o, p.label = a, p.elementType = l, this.eat(17) && (p.optional = !0, this.raise(J.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (p = this.startNodeAtNode(l), p.optional = o, this.raise(J.InvalidTupleMemberLabel, l), p.label = l,
        p.elementType = this.tsParseType()), l = this.finishNode(p, "TSNamedTupleMember");
      } else if (o) {
        let p = this.startNodeAtNode(l);
        p.typeAnnotation = l, l = this.finishNode(p, "TSOptionalType");
      }
      if (i) {
        let p = this.startNodeAt(r);
        p.typeAnnotation = l, l = this.finishNode(p, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, i) {
      let n = this.startNode();
      return r === "TSConstructorType" && (n.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, n)), this.finishNode(n, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), i = this.lookahead();
            return i.type !== 134 && i.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (ve(r) || r === 88 || r === 84) {
            let i = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : EV(this.state.value);
            if (i !== void 0 && this.lookaheadCharCode() !== 46) {
              let n = this.startNode();
              return this.next(), this.finishNode(n, i);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let i = this.startNodeAtNode(r);
          i.elementType = r, this.expect(3), r = this.finishNode(i, "TSArrayType");
        } else {
          let i = this.startNodeAtNode(r);
          i.objectType = r, i.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(i, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), i = this.state.value;
      return this.next(), r.operator = i, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(J.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let i = this.startNode();
      return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(i, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return Vq(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, i, n) {
      let a = this.startNode(), o = this.eat(n), l = [];
      do
        l.push(i());
      while (this.eat(n));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (ve(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === i;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === i;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let i = this.startNode();
        this.expect(r);
        let n = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (n.parameterName = u, n.asserts = !0, n.typeAnnotation = null, u = this.finishNode(n, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, n), u.asserts = !0), i.typeAnnotation = u, this.finishNode(i, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (n.parameterName = this.parseIdentifier(), n.asserts = a, n.typeAnnotation = null, i.typeAnnotation = this.finishNode(n,
          "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
        let l = this.tsParseTypeAnnotation(!1);
        return n.parameterName = o, n.typeAnnotation = l, n.asserts = a, i.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(
        i, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !ve(this.state.type) && !this.match(78) ? !1 : (r && this.raise(x.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, i = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), i.typeAnnotation = this.tsParseType();
      }), this.finishNode(i, "TSTypeAnnotation");
    }
    tsParseType() {
      _y(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let i = this.startNodeAtNode(r);
      return i.checkType = r, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(i, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(J.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let i = this.state.startLoc, n = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return n.length || this.raise(J.EmptyHeritageClauseType, i, {
        token: r
      }), n;
    }
    tsParseInterfaceDeclaration(r, i = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), i.declare && (r.declare = !0), ve(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(J.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let n = this.startNode();
      return n.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(n, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let i = this.startNode();
          return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let i = this.state.context;
      this.state.context = [i[0]];
      try {
        return r();
      } finally {
        this.state.context = i;
      }
    }
    tsInType(r) {
      let i = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = i;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, i = {}) {
      return i.const && (r.const = !0), i.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, i = !1) {
      if (r.id = this.parseIdentifier(), i || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let n = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(n, !0), r.body = n;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, i, n) {
      r.isExport = n || !1, r.id = i || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(J.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let i = this.state.clone(), n = r();
      return this.state = i, n;
    }
    tsTryParseAndCatch(r) {
      let i = this.tryParse((n) => r() || n());
      if (!(i.aborted || !i.node))
        return i.error && (this.state = i.failState), i.node;
    }
    tsTryParse(r) {
      let i = this.state.clone(), n = r();
      if (n !== void 0 && n !== !1)
        return n;
      this.state = i;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let i = this.state.type, n;
      return this.isContextual(100) && (i = 74, n = "let"), this.tsInAmbientContext(() => {
        switch (i) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, n || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (ve(i))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, i, n) {
      switch (i.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = i, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, i.name, !1, n);
      }
    }
    tsParseDeclaration(r, i, n, a) {
      switch (i) {
        case "abstract":
          if (this.tsCheckLineTerminator(n) && (this.match(80) || ve(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(n)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (ve(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(n) && ve(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(n) && ve(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let i = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let n = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = i, !!n)
        return super.parseArrowExpression(n, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(J.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      we.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Uq(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, i) {
      let n = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(J.UnexpectedParameterModifier, n);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let g = this.startNodeAt(n);
        return i.length && (g.decorators = i), o && (g.accessibility = o), u && (g.readonly = u), l && (g.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(J.UnsupportedParameterPropertyKind, g), g.parameter = p, this.finishNode(g, "TSParamete\
rProperty");
      }
      return i.length && (c.decorators = i), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let i of r.params)
        i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(J.PatternIsOptional, i);
    }
    setArrowFunctionParameters(r, i, n) {
      super.setArrowFunctionParameters(r, i, n), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(J.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, n) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, i, n));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((i) => {
        i?.type === "TSTypeCastExpression" && this.raise(J.UnexpectedTypeAnnotation, i.typeAnnotation);
      });
    }
    toReferencedList(r, i) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, i, n, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(i);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (n)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!n && this.atPossibleAsyncArrow(r)) {
            let P = this.tsTryParseGenericAsyncArrowFunction(i);
            if (P)
              return P;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if ($n(this.state.type)) {
            let P = super.parseTaggedTemplateExpression(r, i, a);
            return P.typeParameters = c, P;
          }
          if (!n && this.eat(10)) {
            let P = this.startNodeAt(i);
            return P.callee = r, P.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(P.arguments), P.typeParameters =
            c, a.optionalChainMember && (P.optional = o), this.finishCallExpression(P, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && Bu(p) && !this.hasPrecedingLineBreak())
            return;
          let g = this.startNodeAt(i);
          return g.expression = r, g.typeParameters = c, this.finishNode(g, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          J.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      var i;
      super.parseNewCallee(r);
      let {
        callee: n
      } = r;
      n.type === "TSInstantiationExpression" && !((i = n.extra) != null && i.parenthesized) && (r.typeParameters = n.typeParameters, r.callee =
      n.expression);
    }
    parseExprOp(r, i, n) {
      let a;
      if (Wn(58) > n && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(i);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(x.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, i, n);
      }
      return super.parseExprOp(r, i, n);
    }
    checkReservedWord(r, i, n, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, i, n, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(J.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let i = this.lookaheadCharCode();
        return r ? i === 123 || i === 42 : i !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      super.applyImportPhase(r, i, n, a), i ? r.exportKind = n === "type" ? "type" : "value" : r.importKind = n === "type" || n === "typeof" ?
      n : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let i;
      if (ve(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let n = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, n);
        i = super.parseImportSpecifiersAndAfter(r, n);
      } else
        i = super.parseImport(r);
      return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(J.TypeImportCannotSpecifyDefaultAndNamed,
      i), i;
    }
    parseExport(r, i) {
      if (this.match(83)) {
        this.next();
        let n = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? n = this.parseMaybeImportPhase(r, !1) : r.importKind = "value", this.
        tsParseImportEqualsDeclaration(r, n, !0);
      } else if (this.eat(29)) {
        let n = r;
        return n.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(n, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let n = r;
        return this.expectContextual(128), n.id = this.parseIdentifier(), this.semicolon(), this.finishNode(n, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, i);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, i, n = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, i, n || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (i !== "const" || l.typeAnnotation ? this.raise(J.InitializerNotAllowedInAmbientContext, u) : CV(u, this.hasPlugin("estree")) ||
        this.raise(J.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, i) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let n = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(n, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let n = this.tsParseInterfaceDeclaration(this.startNode());
        if (n) return n;
      }
      return super.parseStatementContent(r, i);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, i) {
      return i.some((n) => Dy(n) ? r.accessibility === n : !!r[n]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, i, n) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: J.InvalidModifierOnTypeParameterPositions
      }, i);
      let o = /* @__PURE__ */ s(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, a) && this.raise(J.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, i)) : this.parseClassMemberWithIsStatic(r, i, n, !!i.static);
      }, "callParseClassMemberWithIsStatic");
      i.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, i, n, a) {
      let o = this.tsTryParseIndexSignature(i);
      if (o) {
        r.body.push(o), i.abstract && this.raise(J.IndexSignatureHasAbstract, i), i.accessibility && this.raise(J.IndexSignatureHasAccessibility,
        i, {
          modifier: i.accessibility
        }), i.declare && this.raise(J.IndexSignatureHasDeclare, i), i.override && this.raise(J.IndexSignatureHasOverride, i);
        return;
      }
      !this.state.inAbstractClass && i.abstract && this.raise(J.NonAbstractClassHasAbstractMethod, i), i.override && (n.hadSuperClass || this.
      raise(J.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(r, i, n, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(J.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(J.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, i, n) {
      return (i.type === "Identifier" ? this.tsParseExpressionStatement(r, i, n) : void 0) || super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, i, n) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, i, n);
      let a = this.tryParse(() => super.parseConditional(r, i));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(n, a.error), r);
    }
    parseParenItem(r, i) {
      if (r = super.parseParenItem(r, i), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let n = this.startNodeAt(i);
        return n.expression = r, n.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let i = this.state.startLoc, n = this.eatContextual(125);
      if (n && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(J.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = ve(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || n) && (r.exportKind = "type"), n && (this.resetStartLocation(
      o, i), o.declare = !0), o) : null;
    }
    parseClassId(r, i, n, a) {
      if ((!i || n) && this.isContextual(113))
        return;
      super.parseClassId(r, i, n, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let i = this.tsTryParseTypeAnnotation();
      i && (r.typeAnnotation = i);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(J.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: i
        } = r;
        this.raise(J.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: i.type === "Identifier" && !r.computed ? i.name : `[${this.input.slice(i.start, i.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(J.PrivateElementHasAbstract, r), r.accessibility && this.raise(J.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(J.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, i, n, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(J.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = i;
      c && (p === "get" || p === "set") && this.raise(J.DeclareAccessor, i, {
        kind: p
      }), u && (i.typeParameters = u), super.pushClassMethod(r, i, n, a, o, l);
    }
    pushClassPrivateMethod(r, i, n, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (i.typeParameters = o), super.pushClassPrivateMethod(r, i, n, a);
    }
    declareClassPrivateMethodInScope(r, i) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !r.value.body || super.declareClassPrivateMethodInScope(r, i));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, i, n, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, i, n, a, o, l, u);
    }
    parseFunctionParams(r, i) {
      let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      n && (r.typeParameters = n), super.parseFunctionParams(r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let n = this.tsTryParseTypeAnnotation();
      n && (r.id.typeAnnotation = n, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, i);
    }
    parseMaybeAssign(r, i) {
      var n, a, o, l, u;
      let c, p, g;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, i), c), !p.error) return p.node;
        let {
          context: C
        } = this.state, _ = C[C.length - 1];
        (_ === we.j_oTag || _ === we.j_expr) && C.pop();
      }
      if (!((n = p) != null && n.error) && !this.match(47))
        return super.parseMaybeAssign(r, i);
      (!c || c === this.state) && (c = this.state.clone());
      let P, A = this.tryParse((C) => {
        var _, k;
        P = this.tsParseTypeParameters(this.tsParseConstModifier);
        let O = super.parseMaybeAssign(r, i);
        return (O.type !== "ArrowFunctionExpression" || (_ = O.extra) != null && _.parenthesized) && C(), ((k = P) == null ? void 0 : k.params.
        length) !== 0 && this.resetStartLocationFromNode(O, P), O.typeParameters = P, O;
      }, c);
      if (!A.error && !A.aborted)
        return P && this.reportReservedArrowTypeParam(P), A.node;
      if (!p && (_y(!this.hasPlugin("jsx")), g = this.tryParse(() => super.parseMaybeAssign(r, i), c), !g.error))
        return g.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (A.node)
        return this.state = A.failState, P && this.reportReservedArrowTypeParam(P), A.node;
      if ((o = g) != null && o.node)
        return this.state = g.failState, g.node;
      throw ((l = p) == null ? void 0 : l.error) || A.error || ((u = g) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var i;
      r.params.length === 1 && !r.params[0].constraint && !((i = r.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(J.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, i) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse((n) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && n(), a;
        });
        if (i.aborted) return;
        i.thrown || (i.error && (this.state = i.failState), r.returnType = i.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, i) {
      if (!(i & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.resetEndLocation(r), r;
    }
    isAssignable(r, i) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, i);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, i);
      }
    }
    toAssignable(r, i = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, i);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          i ? this.expressionScope.recordArrowParameterBindingError(J.UnexpectedTypeCastInParameter, r) : this.raise(J.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, i);
          break;
        case "AssignmentExpression":
          !i && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, i);
      }
    }
    toAssignableParenthesizedExpression(r, i) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, i);
          break;
        default:
          super.toAssignable(r, i);
      }
    }
    checkToRestConversion(r, i) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, i);
      }
    }
    isValidLVal(r, i, n) {
      return SV({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (n !== 64 || !i) && ["expression", !0],
        TSSatisfiesExpression: (n !== 64 || !i) && ["expression", !0],
        TSTypeAssertion: (n !== 64 || !i) && ["expression", !0]
      }, r) || super.isValidLVal(r, i, n);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let n = super.parseMaybeDecoratorArguments(r);
          return n.typeParameters = i, n;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(J.TypeAnnotationAfterAssign,
      n.typeAnnotation), n;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, i, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, i, n);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        i && (r.typeParameters = i);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let i = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? i + 1 : i;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let i = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = i;
      }
    }
    parseClass(r, i, n) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, i, n);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, i) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(J.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, i, n, a, o, l, u) {
      let c = super.parseMethod(r, i, n, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: g
        } = c;
        this.raise(J.AbstractMethodHasImplementation, c, {
          methodName: g.type === "Identifier" && !c.computed ? g.name : `[${this.input.slice(g.start, g.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, i, n, a) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, n), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, i, n, a));
    }
    parseImportSpecifier(r, i, n, a, o) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, n), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, i, n, a, n ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, i, n) {
      let a = i ? "imported" : "local", o = i ? "local" : "exported", l = r[a], u, c = !1, p = !0, g = l.loc.start;
      if (this.isContextual(93)) {
        let A = this.parseIdentifier();
        if (this.isContextual(93)) {
          let C = this.parseIdentifier();
          Dt(this.state.type) ? (c = !0, l = A, u = i ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = C, p = !1);
        } else Dt(this.state.type) ? (p = !1, u = i ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = A);
      } else Dt(this.state.type) && (c = !0, i ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && n && this.raise(i ? J.TypeModifierIsUsedInTypeImports : J.TypeModifierIsUsedInTypeExports, g), r[a] = l, r[o] = u;
      let P = i ? "importKind" : "exportKind";
      r[P] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = i ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = zt(r[a])), i && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function vV(e) {
    if (e.type !== "MemberExpression") return !1;
    let {
      computed: t,
      property: r
    } = e;
    return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : Zy(e.object);
  }
  s(vV, "isPossiblyLiteralEnum");
  function CV(e, t) {
    var r;
    let {
      type: i
    } = e;
    if ((r = e.extra) != null && r.parenthesized)
      return !1;
    if (t) {
      if (i === "Literal") {
        let {
          value: n
        } = e;
        if (typeof n == "string" || typeof n == "boolean")
          return !0;
      }
    } else if (i === "StringLiteral" || i === "BooleanLiteral")
      return !0;
    return !!(Qy(e, t) || IV(e, t) || i === "TemplateLiteral" && e.expressions.length === 0 || vV(e));
  }
  s(CV, "isValidAmbientConstInitializer");
  function Qy(e, t) {
    return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLite\
ral";
  }
  s(Qy, "isNumber");
  function IV(e, t) {
    if (e.type === "UnaryExpression") {
      let {
        operator: r,
        argument: i
      } = e;
      if (r === "-" && Qy(i, t))
        return !0;
    }
    return !1;
  }
  s(IV, "isNegativeNumber");
  function Zy(e) {
    return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : Zy(e.object);
  }
  s(Zy, "isUncomputedMemberExpressionChain");
  var ky = Gt`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), wV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let i = this.startNode();
        return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        i, r);
      }
    }
    finishPlaceholder(r, i) {
      let n = !!(r.expectedNode && r.type === "Placeholder");
      return r.expectedNode = i, n ? r : this.finishNode(r, "Placeholder");
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, i, n, a) {
      r !== void 0 && super.checkReservedWord(r, i, n, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, i, n) {
      return r === "Placeholder" || super.isValidLVal(r, i, n);
    }
    toAssignable(r, i) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, i);
    }
    chStartsBindingIdentifier(r, i) {
      return !!(super.chStartsBindingIdentifier(r, i) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, i) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, i);
    }
    parseExpressionStatement(r, i) {
      var n;
      if (i.type !== "Placeholder" || (n = i.extra) != null && n.parenthesized)
        return super.parseExpressionStatement(r, i);
      if (this.match(14)) {
        let a = r;
        return a.label = this.finishPlaceholder(i, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(a, "LabeledStatement");
      }
      return this.semicolon(), r.name = i.name, this.finishPlaceholder(r, "Statement");
    }
    parseBlock(r, i, n) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, i, n);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, i, n) {
      let a = i ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (n || !i)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(ky.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, i, n);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, i) {
      let n = this.parsePlaceholder("Identifier");
      if (!n) return super.parseExport(r, i);
      if (!this.isContextual(98) && !this.match(12))
        return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(n, "Declaration"), this.finishNode(r, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let a = this.startNode();
      return a.exported = n, r.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(r, i);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(yr(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, i) {
      var n;
      return (n = r.specifiers) != null && n.length ? !0 : super.maybeParseExportDefaultSpecifier(r, i);
    }
    checkExport(r) {
      let {
        specifiers: i
      } = r;
      i != null && i.length && (r.specifiers = i.filter((n) => n.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = i;
    }
    parseImport(r) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let n = this.startNodeAtNode(i);
      return n.local = i, r.specifiers.push(this.finishNode(n, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(ky.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), OV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, i = this.startNode();
        if (this.next(), ve(this.state.type)) {
          let n = this.parseIdentifierName(), a = this.createIdentifier(i, n);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic");
  function Je(e, t) {
    let [r, i] = typeof t == "string" ? [t, {}] : t, n = Object.keys(i), a = n.length === 0;
    return e.some((o) => {
      if (typeof o == "string")
        return a && o === r;
      {
        let [l, u] = o;
        if (l !== r)
          return !1;
        for (let c of n)
          if (u[c] !== i[c])
            return !1;
        return !0;
      }
    });
  }
  s(Je, "hasPlugin");
  function mr(e, t, r) {
    let i = e.find((n) => Array.isArray(n) ? n[0] === t : n === t);
    return i && Array.isArray(i) && i.length > 1 ? i[1][r] : null;
  }
  s(mr, "getPluginOption");
  var Ly = ["minimal", "fsharp", "hack", "smart"], My = ["^^", "@@", "^", "%", "#"], Fy = ["hash", "bar"];
  function NV(e) {
    if (Je(e, "decorators")) {
      if (Je(e, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let t = mr(e, "decorators", "decoratorsBeforeExport");
      if (t != null && typeof t != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let r = mr(e, "decorators", "allowCallParenthesized");
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Je(e, "flow") && Je(e, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Je(e, "placeholders") && Je(e, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Je(e, "pipelineOperator")) {
      let t = mr(e, "pipelineOperator", "proposal");
      if (!Ly.includes(t)) {
        let i = Ly.map((n) => `"${n}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
      }
      let r = Je(e, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (t === "hack") {
        if (Je(e, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Je(e, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let i = mr(e, "pipelineOperator", "topicToken");
        if (!My.includes(i)) {
          let n = My.map((a) => `"${a}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}\
.`);
        }
        if (i === "#" && r)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { s\
yntaxType: "hash"}]`.');
      } else if (t === "smart" && r)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}\
]`.');
    }
    if (Je(e, "moduleAttributes")) {
      if (Je(e, "importAssertions") || Je(e, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (mr(e, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (Je(e, "importAssertions") && Je(e, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Je(e, "recordAndTuple") && mr(e, "recordAndTuple", "syntaxType") != null && !Fy.includes(mr(e, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Fy.map((t) => `'${t}'`).join(", "));
    if (Je(e, "asyncDoExpressions") && !Je(e, "doExpressions")) {
      let t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw t.missingPlugins = "doExpressions", t;
    }
    if (Je(e, "optionalChainingAssign") && mr(e, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  s(NV, "validatePlugins");
  var eT = {
    estree: _q,
    jsx: gV,
    flow: yV,
    typescript: AV,
    v8intrinsic: OV,
    placeholders: wV
  }, _V = Object.keys(eT), Lu = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function DV(e) {
    if (e == null)
      return Object.assign({}, Lu);
    if (e.annexB != null && e.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let t = {};
    for (let i of Object.keys(Lu)) {
      var r;
      t[i] = (r = e[i]) != null ? r : Lu[i];
    }
    return t;
  }
  s(DV, "getOptions");
  var tc = class extends ec {
    static {
      s(this, "ExpressionParser");
    }
    checkProto(t, r, i, n) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return;
      let a = t.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(x.RecordNoProto, a);
          return;
        }
        i.used && (n ? n.doubleProtoLoc === null && (n.doubleProtoLoc = a.loc.start) : this.raise(x.DuplicateProto, a)), i.used = !0;
      }
    }
    shouldExitDescending(t, r) {
      return t.type === "ArrowFunctionExpression" && t.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let t = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors,
      this.options.tokens && (t.tokens = this.tokens), t;
    }
    parseExpression(t, r) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(t) {
      let r = this.state.startLoc, i = this.parseMaybeAssign(t);
      if (this.match(12)) {
        let n = this.startNodeAt(r);
        for (n.expressions = [i]; this.eat(12); )
          n.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(n.expressions), this.finishNode(n, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(t, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
    }
    parseMaybeAssignAllowIn(t, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, r));
    }
    setOptionalParametersError(t, r) {
      var i;
      t.optionalParametersLoc = (i = r?.loc) != null ? i : this.state.startLoc;
    }
    parseMaybeAssign(t, r) {
      let i = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, i)), l;
      }
      let n;
      t ? n = !1 : (t = new Ti(), n = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || ve(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(t);
      if (r && (o = r.call(this, o, i)), Fq(this.state.type)) {
        let l = this.startNodeAt(i), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = i.index;
          t.doubleProtoLoc != null && t.doubleProtoLoc.index >= c && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.
          index >= c && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          t), t.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, {
          in: this.finishNode(l, "AssignmentExpression")
        }), l;
      } else n && this.checkExpressionErrors(t, !0);
      return o;
    }
    parseMaybeConditional(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprOps(t);
      return this.shouldExitDescending(n, i) ? n : this.parseConditional(n, r, t);
    }
    parseConditional(t, r, i) {
      if (this.eat(17)) {
        let n = this.startNodeAt(r);
        return n.test = t, n.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), n.alternate = this.parseMaybeAssign(), this.finishNode(
        n, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(n, i) ? n : this.parseExprOp(n, r, -1);
    }
    parseExprOp(t, r, i) {
      if (this.isPrivateName(t)) {
        let a = this.getPrivateNameSV(t);
        (i >= Wn(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(x.PrivateInExpectedIn, t, {
          identifierName: a
        }), this.classScope.usePrivateName(a, t.loc.start);
      }
      let n = this.state.type;
      if (jq(n) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Wn(n);
        if (a > i) {
          if (n === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, r);
          }
          let o = this.startNodeAt(r);
          o.left = t, o.operator = this.state.value;
          let l = n === 41 || n === 42, u = n === 40;
          if (u && (a = Wn(42)), this.next(), n === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(x.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(n, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(x.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, i);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, r) {
      let i = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(x.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), i);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(t, r);
      }
    }
    parseExprOpBaseRightExpr(t, r) {
      let i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, Kq(t) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var t;
      let {
        startLoc: r
      } = this.state, i = this.parseMaybeAssign();
      return vq.has(i.type) && !((t = i.extra) != null && t.parenthesized) && this.raise(x.PipeUnparenthesizedBody, r, {
        type: i.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipeTopicUnused, r), i;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(x.UnexpectedTokenUnaryExponentiation, t.argument);
    }
    parseMaybeUnary(t, r) {
      let i = this.state.startLoc, n = this.isContextual(96);
      if (n && this.isAwaitAllowed()) {
        this.next();
        let u = this.parseAwait(i);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (qq(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(x.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(x.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, t);
      if (n) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Bu(u) : Bu(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(x.AwaitNotInAsyncContext, i), this.parseAwait(i);
      }
      return l;
    }
    parseUpdate(t, r, i) {
      if (r) {
        let o = t;
        return this.checkLVal(o.argument, {
          in: this.finishNode(o, "UpdateExpression")
        }), t;
      }
      let n = this.state.startLoc, a = this.parseExprSubscripts(i);
      if (this.checkExpressionErrors(i, !1)) return a;
      for (; Rq(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(n);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, {
          in: a = this.finishNode(o, "UpdateExpression")
        });
      }
      return a;
    }
    parseExprSubscripts(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprAtom(t);
      return this.shouldExitDescending(n, i) ? n : this.parseSubscripts(n, r);
    }
    parseSubscripts(t, r, i) {
      let n = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(t),
        stop: !1
      };
      do
        t = this.parseSubscript(t, r, i, n), n.maybeAsyncArrow = !1;
      while (!n.stop);
      return t;
    }
    parseSubscript(t, r, i, n) {
      let {
        type: a
      } = this.state;
      if (!i && a === 15)
        return this.parseBind(t, r, i, n);
      if ($n(a))
        return this.parseTaggedTemplateExpression(t, r, n);
      let o = !1;
      if (a === 18) {
        if (i && (this.raise(x.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return n.stop = !0, t;
        n.optionalChainMember = o = !0, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, r, n, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(t, r, n, l, o) : (n.stop = !0, t);
      }
    }
    parseMember(t, r, i, n, a) {
      let o = this.startNodeAt(r);
      return o.object = t, o.computed = n, n ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t.type === "Super" &&
      this.raise(x.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), i.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(t, r, i, n) {
      let a = this.startNodeAt(r);
      return a.object = t, this.next(), a.callee = this.parseNoCallExpr(), n.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, i);
    }
    parseCoverCallAndAsyncArrowHead(t, r, i, n) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = t;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = i;
      u && (this.expressionScope.enter(lV()), o = new Ti()), c && (l.optional = n), n ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !n ? (i.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(t, r) {
      this.toReferencedListDeep(t.arguments, r);
    }
    parseTaggedTemplateExpression(t, r, i) {
      let n = this.startNodeAt(r);
      return n.tag = t, n.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(x.OptionalChainingNoTemplate, r), this.finishNode(
      n, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end -
      t.start === 5 && t.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(t, r) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 ||
        t.arguments.length > 2)
          this.raise(x.ImportCallArity, t, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let i of t.arguments)
            i.type === "SpreadElement" && this.raise(x.ImportCallSpreadArgument, i);
      return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, r, i, n, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(t)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          x.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, i));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, r) {
      var i;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (i = r.extra) == null ?
      void 0 : i.trailingCommaLoc), r.innerComments && ds(t, r.innerComments), r.callee.trailingComments && ds(t, r.callee.trailingComments),
      t;
    }
    parseNoCallExpr() {
      let t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, !0);
    }
    parseExprAtom(t) {
      let r, i = null, {
        type: n
      } = this.state;
      switch (n) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(x.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, t);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          i = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(x.UnsupportedBind, a);
        }
        case 138:
          return this.raise(x.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          Ht(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (ve(n)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (ve(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, r) {
      let i = this.getPluginOption("pipelineOperator", "proposal");
      if (i)
        return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = ht(this.state.endLoc, -1),
        this.parseTopicReference(i);
      this.unexpected();
    }
    parseTopicReference(t) {
      let r = this.startNode(), i = this.state.startLoc, n = this.state.type;
      return this.next(), this.finishTopicReference(r, i, t, n);
    }
    finishTopicReference(t, r, i, n) {
      if (this.testTopicReferenceConfiguration(i, r, n)) {
        let a = i === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(i === "smart" ? x.PrimaryTopicNotAllowed : x.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(t, a);
      } else
        throw this.raise(x.PipeTopicUnconfiguredToken, r, {
          token: yr(n)
        });
    }
    testTopicReferenceConfiguration(t, r, i) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: yr(i)
          }]);
        case "smart":
          return i === 27;
        default:
          throw this.raise(x.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(Xn(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(x.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(t, r, !0);
    }
    parseDo(t, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
      let i = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(),
      this.state.labels = i, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      let t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(x.SuperNotAllowed,
      t) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(x.UnexpectedSuper, t), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(x.UnsupportedSuper, t), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      let t = this.startNode(), r = this.startNodeAt(ht(this.state.startLoc, 1)), i = this.state.value;
      return this.next(), t.id = this.createIdentifier(r, i), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(t, r, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, r, i) {
      t.meta = r;
      let n = this.state.containsEsc;
      return t.property = this.parseIdentifier(!0), (t.property.name !== i || n) && this.raise(x.UnsupportedMetaProperty, t.property, {
        target: r.name,
        onlyValidPropertyName: i
      }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaProperty(t) {
      let r = this.createIdentifier(this.startNodeAtNode(t), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(x.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let i = this.isContextual(105);
        if (i || this.unexpected(), this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(x.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), t.phase = i ? "source" : "defer", this.parseImportCall(t);
      }
      return this.parseMetaProperty(t, r, "meta");
    }
    parseLiteralAtNode(t, r, i) {
      return this.addExtra(i, "rawValue", t), this.addExtra(i, "raw", this.input.slice(i.start, this.state.end)), i.value = t, this.next(), this.
      finishNode(i, r);
    }
    parseLiteral(t, r) {
      let i = this.startNode();
      return this.parseLiteralAtNode(t, r, i);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      let r = this.parseLiteral(t.value, "RegExpLiteral");
      return r.pattern = t.pattern, r.flags = t.flags, r;
    }
    parseBooleanLiteral(t) {
      let r = this.startNode();
      return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      let r = this.state.startLoc, i;
      this.next(), this.expressionScope.enter(oV());
      let n = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new Ti(), c = !0, p, g;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          g = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let C = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), C)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let P = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = n, this.state.inFSharpPipelineDirectBody = a;
      let A = this.startNodeAt(r);
      return t && this.shouldParseArrow(l) && (A = this.parseArrow(A)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(A, l, !1), A) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), g && this.unexpected(g), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (i = this.startNodeAt(o), i.expressions = l, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i,
      P)) : i = l[0], this.wrapParenthesis(r, i));
    }
    wrapParenthesis(t, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.
        state.lastTokEndLoc.index), r;
      let i = this.startNodeAt(t);
      return i.expression = r, this.finishNode(i, "ParenthesizedExpression");
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, r) {
      return t;
    }
    parseNewOrNewTarget() {
      let t = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        let i = this.parseMetaProperty(t, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(x.UnexpectedNewTarget,
        i), i;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), t.arguments = r;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      let r = this.match(83), i = this.parseNoCallExpr();
      t.callee = i, r && (i.type === "Import" || i.type === "ImportExpression") && this.raise(x.ImportCallNotNewExpression, i);
    }
    parseTemplateElement(t) {
      let {
        start: r,
        startLoc: i,
        end: n,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(ht(i, 1));
      a === null && (t || this.raise(x.InvalidEscapeSequenceTemplate, ht(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = n + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let g = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(g, ht(this.state.lastTokEndLoc, c)), g;
    }
    parseTemplate(t) {
      let r = this.startNode();
      r.expressions = [];
      let i = this.parseTemplateElement(t);
      for (r.quasis = [i]; !i.tail; )
        r.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.quasis.push(i = this.parseTemplateElement(t));
      return this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(t); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(n), this.checkProto(p, i, o, n)), i && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(x.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : i && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(x.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let i = this.startNode(), n = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (i.decorators = r, r = []), i.method = !1, t && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(i);
      let u = this.state.containsEsc, c = this.parsePropertyName(i, t);
      if (!l && !u && this.maybeAsyncOrAccessorProp(i)) {
        let p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (n = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        i)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), i.kind = p, this.match(55) && (l = !0, this.
        raise(x.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(i));
      }
      return this.parseObjPropValue(i, o, l, n, !1, a, t);
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var r;
      let i = this.getGetterSetterExpectedParamCount(t), n = this.getObjectOrClassMethodParams(t);
      n.length !== i && this.raise(t.kind === "get" ? x.BadGetterArity : x.BadSetterArity, t), t.kind === "set" && ((r = n[n.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(x.BadSetterRestParameter, t);
    }
    parseObjectMethod(t, r, i, n, a) {
      if (a) {
        let o = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (i || r || this.match(10))
        return n && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, i, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(t, r, i, n) {
      if (t.shorthand = !1, this.eat(14))
        return t.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n), this.finishNode(t, "ObjectProper\
ty");
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), i)
          t.value = this.parseMaybeDefault(r, zt(t.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          n != null ? n.shorthandAssignLoc === null && (n.shorthandAssignLoc = a) : this.raise(x.InvalidCoverInitializedName, a), t.value = this.
          parseMaybeDefault(r, zt(t.key));
        } else
          t.value = zt(t.key);
        return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
      }
    }
    parseObjPropValue(t, r, i, n, a, o, l) {
      let u = this.parseObjectMethod(t, i, n, a, o) || this.parseObjectProperty(t, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(t, r) {
      if (this.eat(0))
        t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: i,
          value: n
        } = this.state, a;
        if (Dt(i))
          a = this.parseIdentifier(!0);
        else
          switch (i) {
            case 134:
              a = this.parseNumericLiteral(n);
              break;
            case 133:
              a = this.parseStringLiteral(n);
              break;
            case 135:
              a = this.parseBigIntLiteral(n);
              break;
            case 136:
              a = this.parseDecimalLiteral(n);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(x.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        t.key = a, i !== 138 && (t.computed = !1);
      }
      return t.key;
    }
    initFunction(t, r) {
      t.id = null, t.generator = !1, t.async = r;
    }
    parseMethod(t, r, i, n, a, o, l = !1) {
      this.initFunction(t, i), t.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(Xn(i, t.generator)),
      this.parseFunctionParams(t, n);
      let u = this.parseFunctionBodyAndFinish(t, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(t, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(t, !i, n, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, i ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, r, i, n) {
      this.scope.enter(6);
      let a = Xn(i, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(t, i);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, n)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(t, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(t, r, i) {
      this.toAssignableList(r, i, !1), t.params = r;
    }
    parseFunctionBodyAndFinish(t, r, i = !1) {
      return this.parseFunctionBody(t, !1, i), this.finishNode(t, r);
    }
    parseFunctionBody(t, r, i = !1) {
      let n = r && !this.match(5);
      if (this.expressionScope.enter(Gy()), n)
        t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(t.params);
          l && u && this.raise(x.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
          let c = !a && this.state.strict;
          this.checkParams(t, !this.state.strict && !r && !i && !u, r, c), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let r = 0, i = t.length; r < i; r++)
        if (!this.isSimpleParameter(t[r])) return !1;
      return !0;
    }
    checkParams(t, r, i, n = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of t.params)
        this.checkLVal(l, {
          in: o,
          binding: 5,
          checkClashes: a,
          strictModeChanged: n
        });
    }
    parseExprList(t, r, i, n) {
      let a = [], o = !0;
      for (; !this.eat(t); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(t)) {
          n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, i));
      }
      return a;
    }
    parseExprListItem(t, r, i) {
      let n;
      if (this.match(12))
        t || this.raise(x.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), n = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        n = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), i || this.raise(x.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), n = this.finishNode(a, "ArgumentPlaceholder");
      } else
        n = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return n;
    }
    parseIdentifier(t) {
      let r = this.startNode(), i = this.parseIdentifierName(t);
      return this.createIdentifier(r, i);
    }
    createIdentifier(t, r) {
      return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
    }
    parseIdentifierName(t) {
      let r, {
        startLoc: i,
        type: n
      } = this.state;
      Dt(n) ? r = this.state.value : this.unexpected();
      let a = Lq(n);
      return t ? a && this.replaceToken(132) : this.checkReservedWord(r, i, a, !1), this.next(), r;
    }
    checkReservedWord(t, r, i, n) {
      if (t.length > 10 || !Zq(t))
        return;
      if (i && Gq(t)) {
        this.raise(x.UnexpectedKeyword, r, {
          keyword: t
        });
        return;
      }
      if ((this.state.strict ? n ? Yy : Ky : Uy)(t, this.inModule)) {
        this.raise(x.UnexpectedReservedWord, r, {
          reservedWord: t
        });
        return;
      } else if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(x.YieldBindingIdentifier, r);
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(x.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(x.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(x.ArgumentsInClass, r);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(t) {
      let r = this.startNodeAt(t);
      return this.expressionScope.recordParameterInitializerError(x.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(x.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: t
      } = this.state;
      return t === 53 || t === 10 || t === 0 || $n(t) || t === 102 && !this.state.containsEsc || t === 137 || t === 56 || this.hasPlugin("v8\
intrinsic") && t === 54;
    }
    parseYield() {
      let t = this.startNode();
      this.expressionScope.recordParameterInitializerError(x.YieldInParameter, t), this.next();
      let r = !1, i = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            i = this.parseMaybeAssign();
        }
      return t.delegate = r, t.argument = i, this.finishNode(t, "YieldExpression");
    }
    parseImportCall(t) {
      return this.next(), t.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(t, "ImportExpression");
    }
    checkPipelineAtInfixOperator(t, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && t.type === "SequenceExpression" && this.raise(x.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(t, r) {
      if (this.isSimpleReference(t)) {
        let i = this.startNodeAt(r);
        return i.callee = t, this.finishNode(i, "PipelineBareFunction");
      } else {
        let i = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = t, this.finishNode(i, "PipelineTopicExpression");
      }
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(x.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipelineTopicUnused, t);
    }
    withTopicBindingContext(t) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return t();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return t();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
      return this.state.inFSharpPipelineDirectBody = i, n;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let t = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let i = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        t.body = this.parseProgram(r, 8, "module");
      } finally {
        i();
      }
      return this.finishNode(t, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }, Mu = {
    kind: 1
  }, kV = {
    kind: 2
  }, LV = /[\uD800-\uDFFF]/u, Fu = /in(?:stanceof)?/y;
  function MV(e, t) {
    for (let r = 0; r < e.length; r++) {
      let i = e[r], {
        type: n
      } = i;
      if (typeof n == "number") {
        {
          if (n === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = i, c = o + 1, p = ht(a.start, 1);
            e.splice(r, 1, new jt({
              type: Jt(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }), new jt({
              type: Jt(132),
              value: l,
              start: c,
              end: u,
              startLoc: p,
              endLoc: a.end
            })), r++;
            continue;
          }
          if ($n(n)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = i, c = o + 1, p = ht(a.start, 1), g;
            t.charCodeAt(o) === 96 ? g = new jt({
              type: Jt(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }) : g = new jt({
              type: Jt(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            });
            let P, A, C, _;
            n === 24 ? (A = u - 1, C = ht(a.end, -1), P = l === null ? null : l.slice(1, -1), _ = new jt({
              type: Jt(22),
              value: "`",
              start: A,
              end: u,
              startLoc: C,
              endLoc: a.end
            })) : (A = u - 2, C = ht(a.end, -2), P = l === null ? null : l.slice(1, -2), _ = new jt({
              type: Jt(23),
              value: "${",
              start: A,
              end: u,
              startLoc: C,
              endLoc: a.end
            })), e.splice(r, 1, g, new jt({
              type: Jt(20),
              value: P,
              start: c,
              end: A,
              startLoc: p,
              endLoc: C
            }), _), r += 2;
            continue;
          }
        }
        i.type = Jt(n);
      }
    }
    return e;
  }
  s(MV, "babel7CompatTokens");
  var rc = class extends tc {
    static {
      s(this, "StatementParser");
    }
    parseTopLevel(t, r) {
      return t.program = this.parseProgram(r), t.comments = this.comments, this.options.tokens && (t.tokens = MV(this.tokens, this.input)), this.
      finishNode(t, "File");
    }
    parseProgram(t, r = 139, i = this.options.sourceType) {
      if (t.sourceType = i, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule && !this.options.
      allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [a, o] of Array.from(this.scope.undefinedExports))
          this.raise(x.ModuleExportUndefined, o, {
            localName: a
          });
      let n;
      return r === 139 ? n = this.finishNode(t, "Program") : n = this.finishNodeAt(t, "Program", ht(this.state.startLoc, -1)), n;
    }
    stmtToDirective(t) {
      let r = t;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let i = r.value, n = i.value, a = this.input.slice(i.start, i.end), o = i.value = a.slice(1, -1);
      return this.addExtra(i, "raw", a), this.addExtra(i, "rawValue", o), this.addExtra(i, "expressionValue", n), i.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(t, r) {
      if (Ht(t)) {
        if (Fu.lastIndex = r, Fu.test(this.input)) {
          let i = this.codePointAtPos(Fu.lastIndex);
          if (!yi(i) && i !== 92)
            return !1;
        }
        return !0;
      } else return t === 92;
    }
    chStartsBindingPattern(t) {
      return t === 91 || t === 123;
    }
    hasFollowingBindingAtom() {
      let t = this.nextTokenStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
    }
    hasInLineFollowingBindingIdentifier() {
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingIdentifier(r, t);
    }
    startsUsingForOf() {
      let {
        type: t,
        containsEsc: r
      } = this.lookahead();
      if (t === 102 && !r)
        return !1;
      if (ve(t) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let t = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(t, "using")) {
        t = this.nextTokenInLineStartSince(t + 5);
        let r = this.codePointAtPos(t);
        if (this.chStartsBindingIdentifier(r, t))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(t) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
    }
    parseStatementContent(t, r) {
      let i = this.state.type, n = this.startNode(), a = !!(t & 2), o = !!(t & 4), l = t & 1;
      switch (i) {
        case 60:
          return this.parseBreakContinueStatement(n, !0);
        case 63:
          return this.parseBreakContinueStatement(n, !1);
        case 64:
          return this.parseDebuggerStatement(n);
        case 90:
          return this.parseDoWhileStatement(n);
        case 91:
          return this.parseForStatement(n);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? x.StrictFunction : this.options.annexB ? x.SloppyFunctionAnnexB : x.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(n, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, n), !0);
        case 69:
          return this.parseIfStatement(n);
        case 70:
          return this.parseReturnStatement(n);
        case 71:
          return this.parseSwitchStatement(n);
        case 72:
          return this.parseThrowStatement(n);
        case 73:
          return this.parseTryStatement(n);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? a || this.raise(x.UnexpectedLexicalDeclaration, n) : this.raise(x.AwaitUsingNotInAsyncContext, n),
            this.next(), this.parseVarStatement(n, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(x.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), g = this.codePointAtPos(p);
          if (g !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(g, p) && g !== 123))
            break;
        }
        case 75:
          a || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(n, p);
        }
        case 92:
          return this.parseWhileStatement(n);
        case 76:
          return this.parseWithStatement(n);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(n);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(x.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return i === 83 ? (p = this.parseImport(n), p.type === "ImportDeclaration" && (!p.importKind || p.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (p = this.parseExport(n, r), (p.type === "ExportNamedDeclaration" && (!p.exportKind || p.exportKind ===
          "value") || p.type === "ExportAllDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(x.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return ve(i) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(n, u, c, t) : this.parseExpressionStatement(n, c,
      r);
    }
    assertModuleNodeAllowed(t) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(x.ImportOutsideModule, t);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(t, r, i) {
      return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(x.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(
      r, t[0]), i && this.resetStartLocationFromNode(i, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(x.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(x.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, i;
        if (this.match(10)) {
          let n = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(n, i);
          let a = this.state.startLoc;
          t.expression = this.parseMaybeDecoratorArguments(i), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !==
          i && this.raise(x.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (i = this.parseIdentifier(!1); this.eat(16); ) {
            let n = this.startNodeAt(r);
            n.object = i, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) :
            n.property = this.parseIdentifier(!0), n.computed = !1, i = this.finishNode(n, "MemberExpression");
          }
          t.expression = this.parseMaybeDecoratorArguments(i);
        }
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(t);
        return r.callee = t, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return t;
    }
    parseBreakContinueStatement(t, r) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, r) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        let n = this.state.labels[i];
        if ((t.label == null || n.name === t.label.name) && (n.kind != null && (r || n.kind === 1) || t.label && r))
          break;
      }
      if (i === this.state.labels.length) {
        let n = r ? "BreakStatement" : "ContinueStatement";
        this.raise(x.IllegalBreakContinue, t, {
          type: n
        });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoWhileStatement(t) {
      return this.next(), this.state.labels.push(Mu), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(Mu);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(
      13))
        return r !== null && this.unexpected(r), this.parseFor(t, null);
      let i = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = i && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let g = this.startNode(), P;
          u ? (P = "await using", this.isAwaitAllowed() || this.raise(x.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : P =
          this.state.value, this.next(), this.parseVar(g, !0, P);
          let A = this.finishNode(g, "VariableDeclaration"), C = this.match(58);
          return C && c && this.raise(x.ForInUsing, A), (C || this.isContextual(102)) && A.declarations.length === 1 ? this.parseForIn(t, A,
          r) : (r !== null && this.unexpected(r), this.parseFor(t, A));
        }
      }
      let n = this.isContextual(95), a = new Ti(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (i && this.raise(x.ForOfLet, o), r === null && n && o.type === "Identifier" && this.raise(x.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          in: {
            type: u
          }
        }), this.parseForIn(t, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(t, o);
    }
    parseFunctionStatement(t, r, i) {
      return this.next(), this.parseFunction(t, 1 | (i ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(x.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "Ret\
urnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      let r = t.cases = [];
      this.expect(5), this.state.labels.push(kV), this.scope.enter(0);
      let i;
      for (let n; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          i && this.finishNode(i, "SwitchCase"), r.push(i = this.startNode()), i.consequent = [], this.next(), a ? i.test = this.parseExpression() :
          (n && this.raise(x.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), n = !0, i.test = null), this.expect(14);
        } else
          i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchState\
ment");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(x.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let t = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(
        r, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(x.NoCatchOrFinally, t), this.finishNode(
      t, "TryStatement");
    }
    parseVarStatement(t, r, i = !1) {
      return this.next(), this.parseVar(t, !1, r, i), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(Mu), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(x.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, r, i, n) {
      for (let o of this.state.labels)
        o.name === r && this.raise(x.LabelRedeclaration, i, {
          labelName: r
        });
      let a = Bq(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === t.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), t.body = n & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label =
      i, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, r, i) {
      return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock(t = !1, r = !0, i) {
      let n = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(n, t, !1, 8, i), r && this.
      scope.exit(), this.finishNode(n, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, r, i, n, a) {
      let o = t.body = [], l = t.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, i, n, a);
    }
    parseBlockOrModuleBlockBody(t, r, i, n, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(n); ) {
        let c = i ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        t.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(t, r) {
      return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, r, i) {
      let n = this.match(58);
      return this.next(), n ? i !== null && this.unexpected(i) : t.await = i !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!n || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(x.ForInOfLoopInitializer, r, {
        type: n ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(x.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), t.left = r, t.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, n ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, r, i, n = !1) {
      let a = t.declarations = [];
      for (t.kind = i; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, i), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !n && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(x.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(x.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: i
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return t;
    }
    parseVarId(t, r) {
      let i = this.parseBindingAtom();
      this.checkLVal(i, {
        in: {
          type: "VariableDeclarator"
        },
        binding: r === "var" ? 5 : 8201
      }), t.id = i;
    }
    parseAsyncFunctionExpression(t) {
      return this.parseFunction(t, 8);
    }
    parseFunction(t, r = 0) {
      let i = r & 2, n = !!(r & 1), a = n && !(r & 4), o = !!(r & 8);
      this.initFunction(t, o), this.match(55) && (i && this.raise(x.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.
      generator = !0), n && (t.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Xn(o, t.generator)), n || (t.id = this.parseFunctionId()),
      this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, n ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), n && !i && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = l, t;
    }
    parseFunctionId(t) {
      return t || ve(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, r) {
      this.expect(10), this.expressionScope.enter(aV()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, t.id.loc.start);
    }
    parseClass(t, r, i) {
      this.next();
      let n = this.state.strict;
      return this.state.strict = !0, this.parseClassId(t, r, i), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, n), this.
      finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
    }
    parseClassBody(t, r) {
      this.classScope.enter();
      let i = {
        hadConstructor: !1,
        hadSuperClass: t
      }, n = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (n.length > 0)
              throw this.raise(x.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            n.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          n.length && (o.decorators = n, this.resetStartLocationFromNode(o, n[0]), n = []), this.parseClassMember(a, o, i), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(x.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), n.length)
        throw this.raise(x.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(t, r) {
      let i = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let n = r;
        return n.kind = "method", n.computed = !1, n.key = i, n.static = !1, this.pushClassMethod(t, n, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let n = r;
        return n.computed = !1, n.key = i, n.static = !1, t.body.push(this.parseClassProperty(n)), !0;
      }
      return this.resetPreviousNodeTrailingComments(i), !1;
    }
    parseClassMember(t, r, i) {
      let n = this.isContextual(106);
      if (n) {
        if (this.parseClassMemberFromModifier(t, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, r, i, n);
    }
    parseClassMemberWithIsStatic(t, r, i, n) {
      let a = r, o = r, l = r, u = r, c = r, p = a, g = a;
      if (r.static = n, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let k = this.match(138);
        if (this.parseClassElementName(p), k) {
          this.pushClassPrivateMethod(t, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(x.ConstructorIsGenerator, a.key), this.pushClassMethod(t, a, !0, !1, !1, !1);
        return;
      }
      let P = ve(this.state.type) && !this.state.containsEsc, A = this.match(138), C = this.parseClassElementName(r), _ = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(g), this.isClassMethod()) {
        if (p.kind = "method", A) {
          this.pushClassPrivateMethod(t, o, !1, !1);
          return;
        }
        let k = this.isNonstaticConstructor(a), O = !1;
        k && (a.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(x.DuplicateConstructor, C), k && this.
        hasPlugin("typescript") && r.override && this.raise(x.OverrideOnConstructor, C), i.hadConstructor = !0, O = i.hadSuperClass), this.pushClassMethod(
        t, a, !1, !1, k, O);
      } else if (this.isClassProperty())
        A ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l);
      else if (P && C.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(C);
        let k = this.eat(55);
        g.optional && this.unexpected(_), p.kind = "method";
        let O = this.match(138);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(g), O ? this.pushClassPrivateMethod(t, o, k, !0) : (this.isNonstaticConstructor(
        a) && this.raise(x.ConstructorIsAsync, a.key), this.pushClassMethod(t, a, k, !0, !1, !1));
      } else if (P && (C.name === "get" || C.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(C), p.kind = C.name;
        let k = this.match(138);
        this.parseClassElementName(a), k ? this.pushClassPrivateMethod(t, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(x.ConstructorIsAccessor,
        a.key), this.pushClassMethod(t, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (P && C.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(C);
        let k = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(t, c, k);
      } else this.isLineTerminator() ? A ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l) : this.unexpected();
    }
    parseClassElementName(t) {
      let {
        type: r,
        value: i
      } = this.state;
      if ((r === 132 || r === 133) && t.static && i === "prototype" && this.raise(x.StaticPrototype, this.state.startLoc), r === 138) {
        i === "constructor" && this.raise(x.ConstructorClassPrivateField, this.state.startLoc);
        let n = this.parsePrivateName();
        return t.key = n, n;
      }
      return this.parsePropertyName(t);
    }
    parseClassStaticBlock(t, r) {
      var i;
      this.scope.enter(208);
      let n = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n, t.body.push(this.
      finishNode(r, "StaticBlock")), (i = r.decorators) != null && i.length && this.raise(x.DecoratorStaticBlock, r);
    }
    pushClassProperty(t, r) {
      !r.computed && (r.key.name === "constructor" || r.key.value === "constructor") && this.raise(x.ConstructorClassField, r.key), t.body.push(
      this.parseClassProperty(r));
    }
    pushClassPrivateProperty(t, r) {
      let i = this.parseClassPrivateProperty(r);
      t.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassAccessorProperty(t, r, i) {
      if (!i && !r.computed) {
        let a = r.key;
        (a.name === "constructor" || a.value === "constructor") && this.raise(x.ConstructorClassField, a);
      }
      let n = this.parseClassAccessorProperty(r);
      t.body.push(n), i && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
    }
    pushClassMethod(t, r, i, n, a, o) {
      t.body.push(this.parseMethod(r, i, n, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(t, r, i, n) {
      let a = this.parseMethod(r, i, n, !1, !1, "ClassPrivateMethod", !0);
      t.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(t, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(80), this.expressionScope.enter(Gy()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, r, i, n = 8331) {
      if (ve(this.state.type))
        t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, n);
      else if (i || !r)
        t.id = null;
      else
        throw this.raise(x.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t, r) {
      let i = this.parseMaybeImportPhase(t, !0), n = this.maybeParseExportDefaultSpecifier(t, i), a = !n || this.eat(12), o = a && this.eatExportStar(
      t), l = o && this.maybeParseExportNamespaceSpecifier(t), u = a && (!l || this.eat(12)), c = n || o;
      if (o && !l) {
        if (n && this.unexpected(), r)
          throw this.raise(x.UnsupportedDecoratorExport, t);
        return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(t);
      n && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let g;
      if (c || p) {
        if (g = !1, r)
          throw this.raise(x.UnsupportedDecoratorExport, t);
        this.parseExportFrom(t, c);
      } else
        g = this.maybeParseExportDeclaration(t);
      if (c || p || g) {
        var P;
        let A = t;
        if (this.checkExport(A, !0, !1, !!A.source), ((P = A.declaration) == null ? void 0 : P.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, A.declaration, A);
        else if (r)
          throw this.raise(x.UnsupportedDecoratorExport, t);
        return this.finishNode(A, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let A = t, C = this.parseExportDefaultExpression();
        if (A.declaration = C, C.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, C, A);
        else if (r)
          throw this.raise(x.UnsupportedDecoratorExport, t);
        return this.checkExport(A, !0, !0), this.finishNode(A, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let i = r || this.parseIdentifier(!0), n = this.startNodeAtNode(i);
        return n.exported = i, t.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        t.specifiers || (t.specifiers = []);
        let r = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), r.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        t.specifiers || (t.specifiers = []);
        let r = t.exportKind === "type";
        return t.specifiers.push(...this.parseExportSpecifiers(r)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") &&
        (t.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions =
      []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let t = this.nextTokenInLineStart();
      return this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      let t = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(t, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, 13);
      if (this.match(80))
        return this.parseClass(t, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(x.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(t) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: t
      } = this.state;
      if (ve(t)) {
        if (t === 95 && !this.state.containsEsc || t === 100)
          return !1;
        if ((t === 130 || t === 129) && !this.state.containsEsc) {
          let {
            type: n
          } = this.lookahead();
          if (ve(n) && n !== 98 || n === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), i = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || ve(this.state.type) && i)
        return !0;
      if (this.match(65) && i) {
        let n = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return n === 34 || n === 39;
      }
      return !1;
    }
    parseExportFrom(t, r) {
      this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(
      t)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: t
      } = this.state;
      return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), !0) : t === 74 || t === 75 || t ===
      68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, r, i, n) {
      if (r) {
        var a;
        if (i) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = t.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            x.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = t.specifiers) != null && a.length)
          for (let l of t.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !n && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(x.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (t.declaration) {
          if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
            let l = t.declaration.id;
            if (!l) throw new Error("Assertion failure");
            this.checkDuplicateExports(t, l.name);
          } else if (t.declaration.type === "VariableDeclaration")
            for (let l of t.declaration.declarations)
              this.checkDeclaration(l.id);
        }
      }
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (let r of t.properties)
          this.checkDeclaration(r);
      else if (t.type === "ArrayPattern")
        for (let r of t.elements)
          r && this.checkDeclaration(r);
      else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type ===
      "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(x.DuplicateDefaultExport, t) : this.raise(x.DuplicateExport, t, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(t) {
      let r = [], i = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (i)
          i = !1;
        else if (this.expect(12), this.eat(8)) break;
        let n = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, t, n));
      }
      return r;
    }
    parseExportSpecifier(t, r, i, n) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = cV(t.local) : t.exported || (t.exported =
      zt(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let t = this.parseStringLiteral(this.state.value), r = t.value.match(LV);
        return r && this.raise(x.ModuleExportNameHasLoneSurrogate, t, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), t;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(t) {
      return t.assertions != null ? t.assertions.some(({
        key: r,
        value: i
      }) => i.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(t) {
      let {
        specifiers: r
      } = t, i = r.length === 1 ? r[0].type : null;
      if (t.phase === "source")
        i !== "ImportDefaultSpecifier" && this.raise(x.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (t.phase === "defer")
        i !== "ImportNamespaceSpecifier" && this.raise(x.DeferImportRequiresNamespace, r[0].loc.start);
      else if (t.module) {
        var n;
        i !== "ImportDefaultSpecifier" && this.raise(x.ImportReflectionNotBinding, r[0].loc.start), ((n = t.assertions) == null ? void 0 : n.
        length) > 0 && this.raise(x.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(t) {
      if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = t;
        if (r != null) {
          let i = r.find((n) => {
            let a;
            if (n.type === "ExportSpecifier" ? a = n.local : n.type === "ImportSpecifier" && (a = n.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          i !== void 0 && this.raise(x.ImportJSONBindingNotDefault, i.loc.start);
        }
      }
    }
    isPotentialImportPhase(t) {
      return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(t, r, i, n) {
      r || (i === "module" ? (this.expectPlugin("importReflection", n), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1),
      i === "source" ? (this.expectPlugin("sourcePhaseImports", n), t.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", n), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
    }
    parseMaybeImportPhase(t, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(t, r, null), null;
      let i = this.parseIdentifier(!0), {
        type: n
      } = this.state;
      return (Dt(n) ? n !== 98 || this.lookaheadCharCode() === 102 : n !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(
      t, r, i.name, i.loc.start), null) : (this.applyImportPhase(t, r, null), i);
    }
    isPrecedingIdImportPhase(t) {
      let {
        type: r
      } = this.state;
      return ve(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(t) {
      return this.match(133) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
    }
    parseImportSpecifiersAndAfter(t, r) {
      t.specifiers = [];
      let n = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), a = n && this.maybeParseStarImportSpecifier(t);
      return n && !a && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
    }
    parseImportSourceAndAttributes(t) {
      var r;
      return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.
      checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(t, r, i) {
      r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, i));
    }
    finishImportSpecifier(t, r, i = 8201) {
      return this.checkLVal(t.local, {
        in: {
          type: r
        },
        binding: i
      }), this.finishNode(t, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let i = this.startNode(), n = this.state.value;
        if (r.has(n) && this.raise(x.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: n
        }), r.add(n), this.match(133) ? i.key = this.parseStringLiteral(n) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), t;
    }
    parseModuleAttributes() {
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        let i = this.startNode();
        if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(x.ModuleAttributeDifferentFromType, i.key), r.has(i.key.name) &&
        this.raise(x.ModuleAttributesWithDuplicateKeys, i.key, {
          key: i.key.name
        }), r.add(i.key.name), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAttributes(t) {
      let r, i = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), i = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(x.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !i && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
    }
    maybeParseDefaultImportSpecifier(t, r) {
      if (r) {
        let i = this.startNodeAtNode(r);
        return i.local = r, t.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
      } else if (Dt(this.state.type))
        return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(t) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(x.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let i = this.startNode(), n = this.match(133), a = this.isContextual(130);
        i.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(i, n, t.importKind === "type" || t.importKind === "typeof", a, void 0);
        t.specifiers.push(o);
      }
    }
    parseImportSpecifier(t, r, i, n, a) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = t;
        if (r)
          throw this.raise(x.ImportBindingIsString, t, {
            importName: o.value
          });
        this.checkReservedWord(o.name, t.loc.start, !0, !0), t.local || (t.local = zt(o));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier", a);
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }, Gn = class extends rc {
    static {
      s(this, "Parser");
    }
    constructor(t, r) {
      t = DV(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = FV(this.options.plugins), this.filename = t.sourceFilename;
    }
    getScopeHandler() {
      return hs;
    }
    parse() {
      this.enterInitialScopes();
      let t = this.startNode(), r = this.startNode();
      return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t.comments.length = this.state.commentsLen,
      t;
    }
  };
  function FV(e) {
    let t = /* @__PURE__ */ new Map();
    for (let r of e) {
      let [i, n] = Array.isArray(r) ? r : [r, {}];
      t.has(i) || t.set(i, n || {});
    }
    return t;
  }
  s(FV, "pluginsMap");
  function BV(e, t) {
    var r;
    if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
      t = Object.assign({}, t);
      try {
        t.sourceType = "module";
        let i = us(t, e), n = i.parse();
        if (i.sawUnambiguousESM)
          return n;
        if (i.ambiguousScriptDifferentAst)
          try {
            return t.sourceType = "script", us(t, e).parse();
          } catch {
          }
        else
          n.program.sourceType = "script";
        return n;
      } catch (i) {
        try {
          return t.sourceType = "script", us(t, e).parse();
        } catch {
        }
        throw i;
      }
    } else
      return us(t, e).parse();
  }
  s(BV, "parse");
  function jV(e, t) {
    let r = us(t, e);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  s(jV, "parseExpression");
  function RV(e) {
    let t = {};
    for (let r of Object.keys(e))
      t[r] = Jt(e[r]);
    return t;
  }
  s(RV, "generateExportedTokenTypes");
  var qV = RV(kq);
  function us(e, t) {
    let r = Gn;
    return e != null && e.plugins && (NV(e.plugins), r = VV(e.plugins)), new r(e, t);
  }
  s(us, "getParser");
  var By = {};
  function VV(e) {
    let t = _V.filter((n) => Je(e, n)), r = t.join("/"), i = By[r];
    if (!i) {
      i = Gn;
      for (let n of t)
        i = eT[n](i);
      By[r] = i;
    }
    return i;
  }
  s(VV, "getParserClass");
  ms.parse = BV;
  ms.parseExpression = jV;
  ms.tokTypes = qV;
});

// ../node_modules/@babel/helper-hoist-variables/lib/index.js
var tT = v((hc) => {
  "use strict";
  Object.defineProperty(hc, "__esModule", {
    value: !0
  });
  hc.default = JV;
  var UV = le(), {
    assignmentExpression: KV,
    expressionStatement: WV,
    identifier: YV
  } = UV, XV = {
    Scope(e, t) {
      t.kind === "let" && e.skip();
    },
    FunctionParent(e) {
      e.skip();
    },
    VariableDeclaration(e, t) {
      if (t.kind && e.node.kind !== t.kind) return;
      let r = [], i = e.get("declarations"), n;
      for (let a of i) {
        n = a.node.id, a.node.init && r.push(WV(KV("=", a.node.id, a.node.init)));
        for (let o of Object.keys(a.getBindingIdentifiers()))
          t.emit(YV(o), o, a.node.init !== null);
      }
      e.parentPath.isFor({
        left: e.node
      }) ? e.replaceWith(n) : e.replaceWithMultiple(r);
    }
  };
  function JV(e, t, r = "var") {
    e.traverse(XV, {
      kind: r,
      emit: t
    });
  }
  s(JV, "hoistVariables");
});

// ../node_modules/@babel/traverse/lib/path/replacement.js
var uT = v((Tr) => {
  "use strict";
  Object.defineProperty(Tr, "__esModule", {
    value: !0
  });
  Tr._replaceWith = EU;
  Tr.replaceExpressionWithStatements = PU;
  Tr.replaceInline = AU;
  Tr.replaceWith = xU;
  Tr.replaceWithMultiple = bU;
  Tr.replaceWithSourceString = SU;
  var $V = _u(), mc = Rr(), HV = gr(), aT = Fr(), GV = zn(), zV = le(), QV = tT(), {
    FUNCTION_TYPES: rT,
    arrowFunctionExpression: ZV,
    assignmentExpression: oT,
    awaitExpression: eU,
    blockStatement: tU,
    buildUndefinedNode: dc,
    callExpression: rU,
    cloneNode: yc,
    conditionalExpression: iU,
    expressionStatement: sU,
    getBindingIdentifiers: nU,
    identifier: aU,
    inheritLeadingComments: oU,
    inheritTrailingComments: lU,
    inheritsComments: uU,
    isBlockStatement: cU,
    isEmptyStatement: iT,
    isExpression: lT,
    isExpressionStatement: pU,
    isIfStatement: fU,
    isProgram: hU,
    isStatement: dU,
    isVariableDeclaration: mU,
    removeComments: yU,
    returnStatement: sT,
    sequenceExpression: TU,
    validate: nT,
    yieldExpression: gU
  } = zV;
  function bU(e) {
    var t;
    this.resync(), e = this._verifyNodeList(e), oU(e[0], this.node), lU(e[e.length - 1], this.node), (t = (0, aT.getCachedPaths)(this.hub, this.
    parent)) == null || t.delete(this.node), this.node = this.container[this.key] = null;
    let r = this.insertAfter(e);
    return this.node ? this.requeue() : this.remove(), r;
  }
  s(bU, "replaceWithMultiple");
  function SU(e) {
    this.resync();
    let t;
    try {
      e = `(${e})`, t = (0, GV.parse)(e);
    } catch (i) {
      let n = i.loc;
      throw n && (i.message += ` - make sure this is an expression.
` + (0, $V.codeFrameColumns)(e, {
        start: {
          line: n.line,
          column: n.column + 1
        }
      }), i.code = "BABEL_REPLACE_SOURCE_ERROR"), i;
    }
    let r = t.program.body[0].expression;
    return mc.default.removeProperties(r), this.replaceWith(r);
  }
  s(SU, "replaceWithSourceString");
  function xU(e) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let t = e instanceof HV.default ? e.node : e;
    if (!t)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === t)
      return [this];
    if (this.isProgram() && !hU(t))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(t))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof t == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r = "";
    if (this.isNodeType("Statement") && lT(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    t) && !this.parentPath.isExportDefaultDeclaration() && (t = sU(t), r = "expression"), this.isNodeType("Expression") && dU(t) && !this.canHaveVariableDeclarationOrExpression() &&
    !this.canSwapBetweenExpressionAndStatement(t))
      return this.replaceExpressionWithStatements([t]);
    let i = this.node;
    return i && (uU(t, i), yU(i)), this._replaceWith(t), this.type = t.type, this.setScope(), this.requeue(), [r ? this.get(r) : this];
  }
  s(xU, "replaceWith");
  function EU(e) {
    var t;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? nT(this.parent, this.key, [e]) : nT(this.parent, this.key, e), this.debug(`Replace with ${e?.type}`), (t = (0, aT.getCachedPaths)(
    this.hub, this.parent)) == null || t.set(e, this).delete(this.node), this.node = this.container[this.key] = e;
  }
  s(EU, "_replaceWith");
  function PU(e) {
    this.resync();
    let t = [], r = Qn(e, t);
    if (r) {
      for (let P of t) this.scope.push({
        id: P
      });
      return this.replaceWith(r)[0].get("expressions");
    }
    let i = this.getFunctionParent(), n = i?.is("async"), a = i?.is("generator"), o = ZV([], tU(e));
    this.replaceWith(rU(o, []));
    let l = this.get("callee");
    (0, QV.default)(l.get("body"), (P) => {
      this.scope.push({
        id: P
      });
    }, "var");
    let u = this.get("callee").getCompletionRecords();
    for (let P of u) {
      if (!P.isExpressionStatement()) continue;
      let A = P.findParent((C) => C.isLoop());
      if (A) {
        let C = A.getData("expressionReplacementReturnUid");
        C ? C = aU(C.name) : (C = l.scope.generateDeclaredUidIdentifier("ret"), l.get("body").pushContainer("body", sT(yc(C))), A.setData("e\
xpressionReplacementReturnUid", C)), P.get("expression").replaceWith(oT("=", yc(C), P.node.expression));
      } else
        P.replaceWith(sT(P.node.expression));
    }
    l.arrowFunctionToExpression();
    let c = l, p = n && mc.default.hasType(this.get("callee.body").node, "AwaitExpression", rT), g = a && mc.default.hasType(this.get("calle\
e.body").node, "YieldExpression", rT);
    return p && (c.set("async", !0), g || this.replaceWith(eU(this.node))), g && (c.set("generator", !0), this.replaceWith(gU(this.node, !0))),
    c.get("body.body");
  }
  s(PU, "replaceExpressionWithStatements");
  function Qn(e, t) {
    let r = [], i = !0;
    for (let n of e)
      if (iT(n) || (i = !1), lT(n))
        r.push(n);
      else if (pU(n))
        r.push(n.expression);
      else if (mU(n)) {
        if (n.kind !== "var") return;
        for (let a of n.declarations) {
          let o = nU(a);
          for (let l of Object.keys(o))
            t.push(yc(o[l]));
          a.init && r.push(oT("=", a.id, a.init));
        }
        i = !0;
      } else if (fU(n)) {
        let a = n.consequent ? Qn([n.consequent], t) : dc(), o = n.alternate ? Qn([n.alternate], t) : dc();
        if (!a || !o) return;
        r.push(iU(n.test, a, o));
      } else if (cU(n)) {
        let a = Qn(n.body, t);
        if (!a) return;
        r.push(a);
      } else if (iT(n))
        e.indexOf(n) === 0 && (i = !0);
      else
        return;
    return i && r.push(dc()), r.length === 1 ? r[0] : TU(r);
  }
  s(Qn, "gatherSequenceExpressions");
  function AU(e) {
    if (this.resync(), Array.isArray(e))
      if (Array.isArray(this.container)) {
        e = this._verifyNodeList(e);
        let t = this._containerInsertAfter(e);
        return this.remove(), t;
      } else
        return this.replaceWithMultiple(e);
    else
      return this.replaceWith(e);
  }
  s(AU, "replaceInline");
});

// ../node_modules/@babel/traverse/lib/path/evaluation.js
var hT = v((Zn) => {
  "use strict";
  Object.defineProperty(Zn, "__esModule", {
    value: !0
  });
  Zn.evaluate = DU;
  Zn.evaluateTruthy = NU;
  var vU = ["Number", "String", "Math"], CU = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI",
  "encodeURIComponent", null, null], IU = ["random"];
  function cT(e) {
    return vU.includes(e);
  }
  s(cT, "isValidObjectCallee");
  function wU(e) {
    return CU.includes(e);
  }
  s(wU, "isValidIdentifierCallee");
  function OU(e) {
    return IU.includes(e);
  }
  s(OU, "isInvalidMethod");
  function NU() {
    let e = this.evaluate();
    if (e.confident) return !!e.value;
  }
  s(NU, "evaluateTruthy");
  function Qt(e, t) {
    t.confident && (t.deoptPath = e, t.confident = !1);
  }
  s(Qt, "deopt");
  var pT = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function dt(e, t) {
    let {
      node: r
    } = e, {
      seen: i
    } = t;
    if (i.has(r)) {
      let n = i.get(r);
      if (n.resolved)
        return n.value;
      Qt(e, t);
      return;
    } else {
      let n = {
        resolved: !1
      };
      i.set(r, n);
      let a = _U(e, t);
      return t.confident && (n.resolved = !0, n.value = a), a;
    }
  }
  s(dt, "evaluateCached");
  function _U(e, t) {
    if (t.confident) {
      if (e.isSequenceExpression()) {
        let r = e.get("expressions");
        return dt(r[r.length - 1], t);
      }
      if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
        return e.node.value;
      if (e.isNullLiteral())
        return null;
      if (e.isTemplateLiteral())
        return fT(e, e.node.quasis, t);
      if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
        let r = e.get("tag.object"), {
          node: {
            name: i
          }
        } = r, n = e.get("tag.property");
        if (r.isIdentifier() && i === "String" && !e.scope.getBinding(i) && n.isIdentifier() && n.node.name === "raw")
          return fT(e, e.node.quasi.quasis, t, !0);
      }
      if (e.isConditionalExpression()) {
        let r = dt(e.get("test"), t);
        return t.confident ? dt(r ? e.get("consequent") : e.get("alternate"), t) : void 0;
      }
      if (e.isExpressionWrapper())
        return dt(e.get("expression"), t);
      if (e.isMemberExpression() && !e.parentPath.isCallExpression({
        callee: e.node
      })) {
        let r = e.get("property"), i = e.get("object");
        if (i.isLiteral()) {
          let n = i.node.value, a = typeof n, o = null;
          if (e.node.computed) {
            if (o = dt(r, t), !t.confident) return;
          } else r.isIdentifier() && (o = r.node.name);
          if ((a === "number" || a === "string") && o != null && (typeof o == "number" || typeof o == "string"))
            return n[o];
        }
      }
      if (e.isReferencedIdentifier()) {
        let r = e.scope.getBinding(e.node.name);
        if (r) {
          if (r.constantViolations.length > 0 || e.node.start < r.path.node.end) {
            Qt(r.path, t);
            return;
          }
          if (r.hasValue)
            return r.value;
        }
        let i = e.node.name;
        if (pT.has(i)) {
          if (!r)
            return pT.get(i);
          Qt(r.path, t);
          return;
        }
        let n = e.resolve();
        if (n === e) {
          Qt(e, t);
          return;
        } else
          return dt(n, t);
      }
      if (e.isUnaryExpression({
        prefix: !0
      })) {
        if (e.node.operator === "void")
          return;
        let r = e.get("argument");
        if (e.node.operator === "typeof" && (r.isFunction() || r.isClass()))
          return "function";
        let i = dt(r, t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "!":
            return !i;
          case "+":
            return +i;
          case "-":
            return -i;
          case "~":
            return ~i;
          case "typeof":
            return typeof i;
        }
      }
      if (e.isArrayExpression()) {
        let r = [], i = e.get("elements");
        for (let n of i) {
          let a = n.evaluate();
          if (a.confident)
            r.push(a.value);
          else {
            Qt(a.deopt, t);
            return;
          }
        }
        return r;
      }
      if (e.isObjectExpression()) {
        let r = {}, i = e.get("properties");
        for (let n of i) {
          if (n.isObjectMethod() || n.isSpreadElement()) {
            Qt(n, t);
            return;
          }
          let a = n.get("key"), o;
          if (n.node.computed) {
            if (o = a.evaluate(), !o.confident) {
              Qt(o.deopt, t);
              return;
            }
            o = o.value;
          } else a.isIdentifier() ? o = a.node.name : o = a.node.value;
          let u = n.get("value").evaluate();
          if (!u.confident) {
            Qt(u.deopt, t);
            return;
          }
          u = u.value, r[o] = u;
        }
        return r;
      }
      if (e.isLogicalExpression()) {
        let r = t.confident, i = dt(e.get("left"), t), n = t.confident;
        t.confident = r;
        let a = dt(e.get("right"), t), o = t.confident;
        switch (e.node.operator) {
          case "||":
            return t.confident = n && (!!i || o), t.confident ? i || a : void 0;
          case "&&":
            return t.confident = n && (!i || o), t.confident ? i && a : void 0;
          case "??":
            return t.confident = n && (i != null || o), t.confident ? i ?? a : void 0;
        }
      }
      if (e.isBinaryExpression()) {
        let r = dt(e.get("left"), t);
        if (!t.confident) return;
        let i = dt(e.get("right"), t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "-":
            return r - i;
          case "+":
            return r + i;
          case "/":
            return r / i;
          case "*":
            return r * i;
          case "%":
            return r % i;
          case "**":
            return Math.pow(r, i);
          case "<":
            return r < i;
          case ">":
            return r > i;
          case "<=":
            return r <= i;
          case ">=":
            return r >= i;
          case "==":
            return r == i;
          case "!=":
            return r != i;
          case "===":
            return r === i;
          case "!==":
            return r !== i;
          case "|":
            return r | i;
          case "&":
            return r & i;
          case "^":
            return r ^ i;
          case "<<":
            return r << i;
          case ">>":
            return r >> i;
          case ">>>":
            return r >>> i;
        }
      }
      if (e.isCallExpression()) {
        let r = e.get("callee"), i, n;
        if (r.isIdentifier() && !e.scope.getBinding(r.node.name) && (cT(r.node.name) || wU(r.node.name)) && (n = global[r.node.name]), r.isMemberExpression()) {
          let a = r.get("object"), o = r.get("property");
          if (a.isIdentifier() && o.isIdentifier() && cT(a.node.name) && !OU(o.node.name)) {
            i = global[a.node.name];
            let l = o.node.name;
            hasOwnProperty.call(i, l) && (n = i[l]);
          }
          if (a.isLiteral() && o.isIdentifier()) {
            let l = typeof a.node.value;
            (l === "string" || l === "number") && (i = a.node.value, n = i[o.node.name]);
          }
        }
        if (n) {
          let a = e.get("arguments").map((o) => dt(o, t));
          return t.confident ? n.apply(i, a) : void 0;
        }
      }
      Qt(e, t);
    }
  }
  s(_U, "_evaluate");
  function fT(e, t, r, i = !1) {
    let n = "", a = 0, o = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
    for (let l of t) {
      if (!r.confident) break;
      n += i ? l.value.raw : l.value.cooked;
      let u = o[a++];
      u && (n += String(dt(u, r)));
    }
    if (r.confident)
      return n;
  }
  s(fT, "evaluateQuasis");
  function DU() {
    let e = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, t = dt(this, e);
    return e.confident || (t = void 0), {
      confident: e.confident,
      deopt: e.deoptPath,
      value: t
    };
  }
  s(DU, "evaluate");
});

// ../node_modules/@babel/template/lib/formatters.js
var dT = v((Ct) => {
  "use strict";
  Object.defineProperty(Ct, "__esModule", {
    value: !0
  });
  Ct.statements = Ct.statement = Ct.smart = Ct.program = Ct.expression = void 0;
  var kU = le(), {
    assertExpressionStatement: LU
  } = kU;
  function Tc(e) {
    return {
      code: /* @__PURE__ */ s((t) => `/* @babel/template */;
${t}`, "code"),
      validate: /* @__PURE__ */ s(() => {
      }, "validate"),
      unwrap: /* @__PURE__ */ s((t) => e(t.program.body.slice(1)), "unwrap")
    };
  }
  s(Tc, "makeStatementFormatter");
  var Kee = Ct.smart = Tc((e) => e.length > 1 ? e : e[0]), Wee = Ct.statements = Tc((e) => e), Yee = Ct.statement = Tc((e) => {
    if (e.length === 0)
      throw new Error("Found nothing to return.");
    if (e.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return e[0];
  }), MU = Ct.expression = {
    code: /* @__PURE__ */ s((e) => `(
${e}
)`, "code"),
    validate: /* @__PURE__ */ s((e) => {
      if (e.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (MU.unwrap(e).start === 0)
        throw new Error("Parse result included parens.");
    }, "validate"),
    unwrap: /* @__PURE__ */ s(({
      program: e
    }) => {
      let [t] = e.body;
      return LU(t), t.expression;
    }, "unwrap")
  }, Xee = Ct.program = {
    code: /* @__PURE__ */ s((e) => e, "code"),
    validate: /* @__PURE__ */ s(() => {
    }, "validate"),
    unwrap: /* @__PURE__ */ s((e) => e.program, "unwrap")
  };
});

// ../node_modules/@babel/template/lib/options.js
var ea = v((ys) => {
  "use strict";
  Object.defineProperty(ys, "__esModule", {
    value: !0
  });
  ys.merge = jU;
  ys.normalizeReplacements = qU;
  ys.validate = RU;
  var FU = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function BU(e, t) {
    if (e == null) return {};
    var r = {}, i = Object.keys(e), n, a;
    for (a = 0; a < i.length; a++)
      n = i[a], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
    return r;
  }
  s(BU, "_objectWithoutPropertiesLoose");
  function jU(e, t) {
    let {
      placeholderWhitelist: r = e.placeholderWhitelist,
      placeholderPattern: i = e.placeholderPattern,
      preserveComments: n = e.preserveComments,
      syntacticPlaceholders: a = e.syntacticPlaceholders
    } = t;
    return {
      parser: Object.assign({}, e.parser, t.parser),
      placeholderWhitelist: r,
      placeholderPattern: i,
      preserveComments: n,
      syntacticPlaceholders: a
    };
  }
  s(jU, "merge");
  function RU(e) {
    if (e != null && typeof e != "object")
      throw new Error("Unknown template options.");
    let t = e || {}, {
      placeholderWhitelist: r,
      placeholderPattern: i,
      preserveComments: n,
      syntacticPlaceholders: a
    } = t, o = BU(t, FU);
    if (r != null && !(r instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (i != null && !(i instanceof RegExp) && i !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (n != null && typeof n != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (a != null && typeof a != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (a === !0 && (r != null || i != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: o,
      placeholderWhitelist: r || void 0,
      placeholderPattern: i ?? void 0,
      preserveComments: n ?? void 0,
      syntacticPlaceholders: a ?? void 0
    };
  }
  s(RU, "validate");
  function qU(e) {
    if (Array.isArray(e))
      return e.reduce((t, r, i) => (t["$" + i] = r, t), {});
    if (typeof e == "object" || e == null)
      return e || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  s(qU, "normalizeReplacements");
});

// ../node_modules/@babel/template/lib/parse.js
var bc = v((gc) => {
  "use strict";
  Object.defineProperty(gc, "__esModule", {
    value: !0
  });
  gc.default = eK;
  var VU = le(), UU = zn(), KU = _u(), {
    isCallExpression: WU,
    isExpressionStatement: YU,
    isFunction: XU,
    isIdentifier: JU,
    isJSXIdentifier: $U,
    isNewExpression: HU,
    isPlaceholder: ta,
    isStatement: GU,
    isStringLiteral: mT,
    removePropertiesDeep: zU,
    traverse: QU
  } = VU, ZU = /^[_$A-Z0-9]+$/;
  function eK(e, t, r) {
    let {
      placeholderWhitelist: i,
      placeholderPattern: n,
      preserveComments: a,
      syntacticPlaceholders: o
    } = r, l = iK(t, r.parser, o);
    zU(l, {
      preserveComments: a
    }), e.validate(l);
    let u = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: i,
      placeholderPattern: n,
      syntacticPlaceholders: o
    };
    return QU(l, tK, u), Object.assign({
      ast: l
    }, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
  }
  s(eK, "parseAndBuildMetadata");
  function tK(e, t, r) {
    var i;
    let n, a = r.syntactic.placeholders.length > 0;
    if (ta(e)) {
      if (r.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      n = e.name.name, a = !0;
    } else {
      if (a || r.syntacticPlaceholders)
        return;
      if (JU(e) || $U(e))
        n = e.name;
      else if (mT(e))
        n = e.value;
      else
        return;
    }
    if (a && (r.placeholderPattern != null || r.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!a && (r.placeholderPattern === !1 || !(r.placeholderPattern || ZU).test(n)) && !((i = r.placeholderWhitelist) != null && i.has(n)))
      return;
    t = t.slice();
    let {
      node: o,
      key: l
    } = t[t.length - 1], u;
    mT(e) || ta(e, {
      expectedNode: "StringLiteral"
    }) ? u = "string" : HU(o) && l === "arguments" || WU(o) && l === "arguments" || XU(o) && l === "params" ? u = "param" : YU(o) && !ta(e) ?
    (u = "statement", t = t.slice(0, -1)) : GU(e) && ta(e) ? u = "statement" : u = "other";
    let {
      placeholders: c,
      placeholderNames: p
    } = a ? r.syntactic : r.legacy;
    c.push({
      name: n,
      type: u,
      resolve: /* @__PURE__ */ s((g) => rK(g, t), "resolve"),
      isDuplicate: p.has(n)
    }), p.add(n);
  }
  s(tK, "placeholderVisitorHandler");
  function rK(e, t) {
    let r = e;
    for (let a = 0; a < t.length - 1; a++) {
      let {
        key: o,
        index: l
      } = t[a];
      l === void 0 ? r = r[o] : r = r[o][l];
    }
    let {
      key: i,
      index: n
    } = t[t.length - 1];
    return {
      parent: r,
      key: i,
      index: n
    };
  }
  s(rK, "resolveAncestors");
  function iK(e, t, r) {
    let i = (t.plugins || []).slice();
    r !== !1 && i.push("placeholders"), t = Object.assign({
      allowReturnOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      sourceType: "module"
    }, t, {
      plugins: i
    });
    try {
      return (0, UU.parse)(e, t);
    } catch (n) {
      let a = n.loc;
      throw a && (n.message += `
` + (0, KU.codeFrameColumns)(e, {
        start: a
      }), n.code = "BABEL_TEMPLATE_PARSE_ERROR"), n;
    }
  }
  s(iK, "parseWithCodeFrame");
});

// ../node_modules/@babel/template/lib/populate.js
var Pc = v((Ec) => {
  "use strict";
  Object.defineProperty(Ec, "__esModule", {
    value: !0
  });
  Ec.default = uK;
  var sK = le(), {
    blockStatement: nK,
    cloneNode: xc,
    emptyStatement: aK,
    expressionStatement: Sc,
    identifier: ra,
    isStatement: yT,
    isStringLiteral: oK,
    stringLiteral: lK,
    validate: TT
  } = sK;
  function uK(e, t) {
    let r = xc(e.ast);
    return t && (e.placeholders.forEach((i) => {
      if (!hasOwnProperty.call(t, i.name)) {
        let n = i.name;
        throw new Error(`Error: No substitution given for "${n}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${n}'])}
            - { placeholderPattern: /^${n}$/ }`);
      }
    }), Object.keys(t).forEach((i) => {
      if (!e.placeholderNames.has(i))
        throw new Error(`Unknown substitution "${i}" given`);
    })), e.placeholders.slice().reverse().forEach((i) => {
      try {
        cK(i, r, t && t[i.name] || null);
      } catch (n) {
        throw n.message = `@babel/template placeholder "${i.name}": ${n.message}`, n;
      }
    }), r;
  }
  s(uK, "populatePlaceholders");
  function cK(e, t, r) {
    e.isDuplicate && (Array.isArray(r) ? r = r.map((o) => xc(o)) : typeof r == "object" && (r = xc(r)));
    let {
      parent: i,
      key: n,
      index: a
    } = e.resolve(t);
    if (e.type === "string") {
      if (typeof r == "string" && (r = lK(r)), !r || !oK(r))
        throw new Error("Expected string substitution");
    } else if (e.type === "statement")
      a === void 0 ? r ? Array.isArray(r) ? r = nK(r) : typeof r == "string" ? r = Sc(ra(r)) : yT(r) || (r = Sc(r)) : r = aK() : r && !Array.
      isArray(r) && (typeof r == "string" && (r = ra(r)), yT(r) || (r = Sc(r)));
    else if (e.type === "param") {
      if (typeof r == "string" && (r = ra(r)), a === void 0) throw new Error("Assertion failure.");
    } else if (typeof r == "string" && (r = ra(r)), Array.isArray(r))
      throw new Error("Cannot replace single expression with an array.");
    if (a === void 0)
      TT(i, n, r), i[n] = r;
    else {
      let o = i[n].slice();
      e.type === "statement" || e.type === "param" ? r == null ? o.splice(a, 1) : Array.isArray(r) ? o.splice(a, 1, ...r) : o[a] = r : o[a] =
      r, TT(i, n, o), i[n] = o;
    }
  }
  s(cK, "applyReplacement");
});

// ../node_modules/@babel/template/lib/string.js
var gT = v((Ac) => {
  "use strict";
  Object.defineProperty(Ac, "__esModule", {
    value: !0
  });
  Ac.default = dK;
  var pK = ea(), fK = bc(), hK = Pc();
  function dK(e, t, r) {
    t = e.code(t);
    let i;
    return (n) => {
      let a = (0, pK.normalizeReplacements)(n);
      return i || (i = (0, fK.default)(e, t, r)), e.unwrap((0, hK.default)(i, a));
    };
  }
  s(dK, "stringTemplate");
});

// ../node_modules/@babel/template/lib/literal.js
var bT = v((vc) => {
  "use strict";
  Object.defineProperty(vc, "__esModule", {
    value: !0
  });
  vc.default = gK;
  var mK = ea(), yK = bc(), TK = Pc();
  function gK(e, t, r) {
    let {
      metadata: i,
      names: n
    } = bK(e, t, r);
    return (a) => {
      let o = {};
      return a.forEach((l, u) => {
        o[n[u]] = l;
      }), (l) => {
        let u = (0, mK.normalizeReplacements)(l);
        return u && Object.keys(u).forEach((c) => {
          if (hasOwnProperty.call(o, c))
            throw new Error("Unexpected replacement overlap.");
        }), e.unwrap((0, TK.default)(i, u ? Object.assign(u, o) : o));
      };
    };
  }
  s(gK, "literalTemplate");
  function bK(e, t, r) {
    let i = "BABEL_TPL$", n = t.join("");
    do
      i = "$$" + i;
    while (n.includes(i));
    let {
      names: a,
      code: o
    } = SK(t, i);
    return {
      metadata: (0, yK.default)(e, e.code(o), {
        parser: r.parser,
        placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
        placeholderPattern: r.placeholderPattern,
        preserveComments: r.preserveComments,
        syntacticPlaceholders: r.syntacticPlaceholders
      }),
      names: a
    };
  }
  s(bK, "buildLiteralData");
  function SK(e, t) {
    let r = [], i = e[0];
    for (let n = 1; n < e.length; n++) {
      let a = `${t}${n - 1}`;
      r.push(a), i += a + e[n];
    }
    return {
      names: r,
      code: i
    };
  }
  s(SK, "buildTemplateCode");
});

// ../node_modules/@babel/template/lib/builder.js
var vT = v((Cc) => {
  "use strict";
  Object.defineProperty(Cc, "__esModule", {
    value: !0
  });
  Cc.default = AT;
  var qt = ea(), ST = gT(), xT = bT(), ET = (0, qt.validate)({
    placeholderPattern: !1
  });
  function AT(e, t) {
    let r = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), n = t || (0, qt.validate)(null);
    return Object.assign((a, ...o) => {
      if (typeof a == "string") {
        if (o.length > 1) throw new Error("Unexpected extra params.");
        return PT((0, ST.default)(e, a, (0, qt.merge)(n, (0, qt.validate)(o[0]))));
      } else if (Array.isArray(a)) {
        let l = r.get(a);
        return l || (l = (0, xT.default)(e, a, n), r.set(a, l)), PT(l(o));
      } else if (typeof a == "object" && a) {
        if (o.length > 0) throw new Error("Unexpected extra params.");
        return AT(e, (0, qt.merge)(n, (0, qt.validate)(a)));
      }
      throw new Error(`Unexpected template param ${typeof a}`);
    }, {
      ast: /* @__PURE__ */ s((a, ...o) => {
        if (typeof a == "string") {
          if (o.length > 1) throw new Error("Unexpected extra params.");
          return (0, ST.default)(e, a, (0, qt.merge)((0, qt.merge)(n, (0, qt.validate)(o[0])), ET))();
        } else if (Array.isArray(a)) {
          let l = i.get(a);
          return l || (l = (0, xT.default)(e, a, (0, qt.merge)(n, ET)), i.set(a, l)), l(o)();
        }
        throw new Error(`Unexpected template param ${typeof a}`);
      }, "ast")
    });
  }
  s(AT, "createTemplateBuilder");
  function PT(e) {
    let t = "";
    try {
      throw new Error();
    } catch (r) {
      r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
    }
    return (r) => {
      try {
        return e(r);
      } catch (i) {
        throw i.stack += `
    =============
${t}`, i;
      }
    };
  }
  s(PT, "extendedTrace");
});

// ../node_modules/@babel/template/lib/index.js
var CT = v((gt) => {
  "use strict";
  Object.defineProperty(gt, "__esModule", {
    value: !0
  });
  gt.statements = gt.statement = gt.smart = gt.program = gt.expression = gt.default = void 0;
  var Ts = dT(), gs = vT(), Ic = gt.smart = (0, gs.default)(Ts.smart), xK = gt.statement = (0, gs.default)(Ts.statement), EK = gt.statements =
  (0, gs.default)(Ts.statements), PK = gt.expression = (0, gs.default)(Ts.expression), AK = gt.program = (0, gs.default)(Ts.program), ote = gt.
  default = Object.assign(Ic.bind(void 0), {
    smart: Ic,
    statement: xK,
    statements: EK,
    expression: PK,
    program: AK,
    ast: Ic.ast
  });
});

// ../node_modules/@babel/helper-function-name/lib/index.js
var DT = v((wc) => {
  "use strict";
  Object.defineProperty(wc, "__esModule", {
    value: !0
  });
  wc.default = YK;
  var NT = CT(), vK = le(), {
    NOT_LOCAL_BINDING: IT,
    cloneNode: CK,
    identifier: IK,
    isAssignmentExpression: wK,
    isAssignmentPattern: OK,
    isFunction: _T,
    isIdentifier: wT,
    isLiteral: OT,
    isNullLiteral: NK,
    isObjectMethod: _K,
    isObjectProperty: DK,
    isRegExpLiteral: kK,
    isRestElement: LK,
    isTemplateLiteral: MK,
    isVariableDeclarator: FK,
    toBindingIdentifierName: BK
  } = vK;
  function jK(e) {
    let t = e.params.findIndex((r) => OK(r) || LK(r));
    return t === -1 ? e.params.length : t;
  }
  s(jK, "getFunctionArity");
  var RK = NT.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), qK = NT.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), VK = {
    "ReferencedIdentifier|BindingIdentifier"(e, t) {
      e.node.name !== t.name || e.scope.getBindingIdentifier(t.name) !== t.outerDeclar || (t.selfReference = !0, e.stop());
    }
  };
  function UK(e) {
    return NK(e) ? "null" : kK(e) ? `_${e.pattern}_${e.flags}` : MK(e) ? e.quasis.map((t) => t.value.raw).join("") : e.value !== void 0 ? e.
    value + "" : "";
  }
  s(UK, "getNameFromLiteralId");
  function KK(e, t, r, i) {
    if (e.selfReference)
      if (i.hasBinding(r.name) && !i.hasGlobal(r.name))
        i.rename(r.name);
      else {
        if (!_T(t)) return;
        let n = RK;
        t.generator && (n = qK);
        let a = n({
          FUNCTION: t,
          FUNCTION_ID: r,
          FUNCTION_KEY: i.generateUidIdentifier(r.name)
        }).expression, o = a.callee.body.body[0].params;
        for (let l = 0, u = jK(t); l < u; l++)
          o.push(i.generateUidIdentifier("x"));
        return a;
      }
    t.id = r, i.getProgramParent().references[r.name] = !0;
  }
  s(KK, "wrap");
  function WK(e, t, r) {
    let i = {
      selfAssignment: !1,
      selfReference: !1,
      outerDeclar: r.getBindingIdentifier(t),
      name: t
    }, n = r.getOwnBinding(t);
    return n ? n.kind === "param" && (i.selfReference = !0) : (i.outerDeclar || r.hasGlobal(t)) && r.traverse(e, VK, i), i;
  }
  s(WK, "visit");
  function YK({
    node: e,
    parent: t,
    scope: r,
    id: i
  }, n = !1, a = !1) {
    if (e.id) return;
    if ((DK(t) || _K(t, {
      kind: "method"
    })) && (!t.computed || OT(t.key)))
      i = t.key;
    else if (FK(t)) {
      if (i = t.id, wT(i) && !n) {
        let c = r.parent.getBinding(i.name);
        if (c && c.constant && r.getBinding(i.name) === c) {
          e.id = CK(i), e.id[IT] = !0;
          return;
        }
      }
    } else if (wK(t, {
      operator: "="
    }))
      i = t.left;
    else if (!i)
      return;
    let o;
    if (i && OT(i) ? o = UK(i) : i && wT(i) && (o = i.name), o === void 0 || !a && _T(e) && /[\uD800-\uDFFF]/.test(o))
      return;
    o = BK(o);
    let l = IK(o);
    l[IT] = !0;
    let u = WK(e, o, r);
    return KK(u, e, l, r) || e;
  }
  s(YK, "_default");
});

// ../node_modules/@babel/traverse/lib/path/conversion.js
var BT = v((Xr) => {
  "use strict";
  Object.defineProperty(Xr, "__esModule", {
    value: !0
  });
  Xr.arrowFunctionToExpression = hW;
  Xr.ensureBlock = cW;
  Xr.toComputedKey = uW;
  Xr.unwrapFunctionEnvironment = pW;
  var XK = le(), _c = au(), JK = DT(), Dc = es(), {
    arrowFunctionExpression: kc,
    assignmentExpression: Yr,
    binaryExpression: Oc,
    blockStatement: $K,
    callExpression: xi,
    conditionalExpression: HK,
    expressionStatement: kT,
    identifier: Be,
    isIdentifier: GK,
    jsxIdentifier: zK,
    logicalExpression: QK,
    LOGICAL_OPERATORS: ZK,
    memberExpression: kt,
    metaProperty: eW,
    numericLiteral: tW,
    objectExpression: rW,
    restElement: iW,
    returnStatement: sW,
    sequenceExpression: nW,
    spreadElement: aW,
    stringLiteral: LT,
    super: Nc,
    thisExpression: bs,
    toExpression: oW,
    unaryExpression: lW
  } = XK;
  function uW() {
    let e;
    if (this.isMemberExpression())
      e = this.node.property;
    else if (this.isProperty() || this.isMethod())
      e = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || GK(e) && (e = LT(e.name)), e;
  }
  s(uW, "toComputedKey");
  function cW() {
    let e = this.get("body"), t = e.node;
    if (Array.isArray(e))
      throw new Error("Can't convert array path to a block statement");
    if (!t)
      throw new Error("Can't convert node without a body");
    if (e.isBlockStatement())
      return t;
    let r = [], i = "body", n, a;
    e.isStatement() ? (a = "body", n = 0, r.push(e.node)) : (i += ".body.0", this.isFunction() ? (n = "argument", r.push(sW(e.node))) : (n =
    "expression", r.push(kT(e.node)))), this.node.body = $K(r);
    let o = this.get(i);
    return e.setup(o, a ? o.node[a] : o.node, a, n), this.node;
  }
  s(cW, "ensureBlock");
  Xr.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function pW() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    MT(this);
  }
  s(pW, "unwrapFunctionEnvironment");
  function fW(e, t) {
    e.node.type = t;
  }
  s(fW, "setType");
  function hW({
    allowInsertArrow: e = !0,
    allowInsertArrowWithRest: t = e,
    noNewArrows: r = !((i) => (i = arguments[0]) == null ? void 0 : i.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let {
      thisBinding: i,
      fnPath: n
    } = MT(this, r, e, t);
    if (n.ensureBlock(), fW(n, "FunctionExpression"), !r) {
      let a = i ? null : n.scope.generateUidIdentifier("arrowCheckId");
      return a && n.parentPath.scope.push({
        id: a,
        init: rW([])
      }), n.get("body").unshiftContainer("body", kT(xi(this.hub.addHelper("newArrowCheck"), [bs(), Be(a ? a.name : i)]))), n.replaceWith(xi(
      kt((0, JK.default)(this, !0) || n.node, Be("bind")), [a ? Be(a.name) : bs()])), n.get("callee.object");
    }
    return n;
  }
  s(hW, "arrowFunctionToExpression");
  var dW = (0, Dc.merge)([{
    CallExpression(e, {
      allSuperCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    }
  }, _c.default]);
  function MT(e, t = !0, r = !0, i = !0) {
    let n, a = e.findParent((A) => {
      if (A.isArrowFunctionExpression()) {
        var C;
        return (C = n) != null || (n = A), !1;
      }
      return A.isFunction() || A.isProgram() || A.isClassProperty({
        static: !1
      }) || A.isClassPrivateProperty({
        static: !1
      });
    }), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (n)
        a = n;
      else if (r)
        e.replaceWith(xi(kc([], oW(e.node)), [])), a = e.get("callee"), e = a.get("body");
      else
        throw e.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: l,
      argumentsPaths: u,
      newTargetPaths: c,
      superProps: p,
      superCalls: g
    } = EW(e);
    if (o && g.length > 0) {
      if (!r)
        throw g[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!i)
        throw g[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let A = [];
      a.traverse(dW, {
        allSuperCalls: A
      });
      let C = bW(a);
      A.forEach((_) => {
        let k = Be(C);
        k.loc = _.node.callee.loc, _.get("callee").replaceWith(k);
      });
    }
    if (u.length > 0) {
      let A = Ss(a, "arguments", () => {
        let C = /* @__PURE__ */ s(() => Be("arguments"), "args");
        return a.scope.path.isProgram() ? HK(Oc("===", lW("typeof", C()), LT("undefined")), a.scope.buildUndefinedNode(), C()) : C();
      });
      u.forEach((C) => {
        let _ = Be(A);
        _.loc = C.node.loc, C.replaceWith(_);
      });
    }
    if (c.length > 0) {
      let A = Ss(a, "newtarget", () => eW(Be("new"), Be("target")));
      c.forEach((C) => {
        let _ = Be(A);
        _.loc = C.node.loc, C.replaceWith(_);
      });
    }
    if (p.length > 0) {
      if (!r)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      p.reduce((C, _) => C.concat(yW(_)), []).forEach((C) => {
        let _ = C.node.computed ? "" : C.get("property").node.name, k = C.parentPath, O = k.isAssignmentExpression({
          left: C.node
        }), M = k.isCallExpression({
          callee: C.node
        }), F = k.isTaggedTemplateExpression({
          tag: C.node
        }), G = SW(a, O, _), $ = [];
        if (C.node.computed && $.push(C.get("property").node), O) {
          let oe = k.node.right;
          $.push(oe);
        }
        let K = xi(Be(G), $);
        M ? (k.unshiftContainer("arguments", bs()), C.replaceWith(kt(K, Be("call"))), l.push(k.get("arguments.0"))) : O ? k.replaceWith(K) :
        F ? (C.replaceWith(xi(kt(K, Be("bind"), !1), [bs()])), l.push(C.get("arguments.0"))) : C.replaceWith(K);
      });
    }
    let P;
    return (l.length > 0 || !t) && (P = gW(a, o), (t || o && FT(a)) && (l.forEach((A) => {
      let C = A.isJSX() ? zK(P) : Be(P);
      C.loc = A.node.loc, A.replaceWith(C);
    }), t || (P = null))), {
      thisBinding: P,
      fnPath: e
    };
  }
  s(MT, "hoistFunctionEnvironment");
  function mW(e) {
    return ZK.includes(e);
  }
  s(mW, "isLogicalOp");
  function yW(e) {
    if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
      let r = e.parentPath, i = r.node.operator.slice(0, -1), n = r.node.right, a = mW(i);
      if (e.node.computed) {
        let o = e.scope.generateDeclaredUidIdentifier("tmp"), l = e.node.object, u = e.node.property;
        r.get("left").replaceWith(kt(l, Yr("=", o, u), !0)), r.get("right").replaceWith(t(a ? "=" : i, kt(l, Be(o.name), !0), n));
      } else {
        let o = e.node.object, l = e.node.property;
        r.get("left").replaceWith(kt(o, l)), r.get("right").replaceWith(t(a ? "=" : i, kt(o, Be(l.name)), n));
      }
      return a ? r.replaceWith(QK(i, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
    } else if (e.parentPath.isUpdateExpression()) {
      let r = e.parentPath, i = e.scope.generateDeclaredUidIdentifier("tmp"), n = e.node.computed ? e.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [Yr("=", i, kt(e.node.object, n ? Yr("=", n, e.node.property) : e.node.property, e.node.computed)), Yr("=", kt(e.node.object,
      n ? Be(n.name) : e.node.property, e.node.computed), Oc(e.parentPath.node.operator[0], Be(i.name), tW(1)))];
      e.parentPath.node.prefix || a.push(Be(i.name)), r.replaceWith(nW(a));
      let o = r.get("expressions.0.right"), l = r.get("expressions.1.left");
      return [o, l];
    }
    return [e];
    function t(r, i, n) {
      return r === "=" ? Yr("=", i, n) : Oc(r, i, n);
    }
  }
  s(yW, "standardizeSuperProperty");
  function FT(e) {
    return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
  }
  s(FT, "hasSuperClass");
  var TW = (0, Dc.merge)([{
    CallExpression(e, {
      supers: t,
      thisBinding: r
    }) {
      e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, Yr("=", Be(r), Be("this"))])));
    }
  }, _c.default]);
  function gW(e, t) {
    return Ss(e, "this", (r) => {
      if (!t || !FT(e)) return bs();
      e.traverse(TW, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: r
      });
    });
  }
  s(gW, "getThisBinding");
  function bW(e) {
    return Ss(e, "supercall", () => {
      let t = e.scope.generateUidIdentifier("args");
      return kc([iW(t)], xi(Nc(), [aW(Be(t.name))]));
    });
  }
  s(bW, "getSuperBinding");
  function SW(e, t, r) {
    return Ss(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
      let n = [], a;
      if (r)
        a = kt(Nc(), Be(r));
      else {
        let o = e.scope.generateUidIdentifier("prop");
        n.unshift(o), a = kt(Nc(), Be(o.name), !0);
      }
      if (t) {
        let o = e.scope.generateUidIdentifier("value");
        n.push(o), a = Yr("=", a, Be(o.name));
      }
      return kc(n, a);
    });
  }
  s(SW, "getSuperPropBinding");
  function Ss(e, t, r) {
    let i = "binding:" + t, n = e.getData(i);
    if (!n) {
      let a = e.scope.generateUidIdentifier(t);
      n = a.name, e.setData(i, n), e.scope.push({
        id: a,
        init: r(n)
      });
    }
    return n;
  }
  s(Ss, "getBinding");
  var xW = (0, Dc.merge)([{
    ThisExpression(e, {
      thisPaths: t
    }) {
      t.push(e);
    },
    JSXIdentifier(e, {
      thisPaths: t
    }) {
      e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
        object: e.node
      }) && !e.parentPath.isJSXOpeningElement({
        name: e.node
      }) || t.push(e));
    },
    CallExpression(e, {
      superCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    },
    MemberExpression(e, {
      superProps: t
    }) {
      e.get("object").isSuper() && t.push(e);
    },
    Identifier(e, {
      argumentsPaths: t
    }) {
      if (!e.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let r = e.scope;
      do {
        if (r.hasOwnBinding("arguments")) {
          r.rename("arguments");
          return;
        }
        if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
      } while (r = r.parent);
      t.push(e);
    },
    MetaProperty(e, {
      newTargetPaths: t
    }) {
      e.get("meta").isIdentifier({
        name: "new"
      }) && e.get("property").isIdentifier({
        name: "target"
      }) && t.push(e);
    }
  }, _c.default]);
  function EW(e) {
    let t = [], r = [], i = [], n = [], a = [];
    return e.traverse(xW, {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: i,
      superProps: n,
      superCalls: a
    }), {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: i,
      superProps: n,
      superCalls: a
    };
  }
  s(EW, "getScopeInformation");
});

// ../node_modules/@babel/traverse/lib/path/introspection.js
var KT = v((Ue) => {
  "use strict";
  Object.defineProperty(Ue, "__esModule", {
    value: !0
  });
  Ue._guessExecutionStatusRelativeTo = YW;
  Ue._resolve = HW;
  Ue.canHaveVariableDeclarationOrExpression = BW;
  Ue.canSwapBetweenExpressionAndStatement = jW;
  Ue.equals = MW;
  Ue.getSource = UW;
  Ue.has = UT;
  Ue.is = void 0;
  Ue.isCompletionRecord = RW;
  Ue.isConstantExpression = GW;
  Ue.isInStrictMode = zW;
  Ue.isNodeType = FW;
  Ue.isStatementOrBlock = qW;
  Ue.isStatic = kW;
  Ue.isnt = LW;
  Ue.matchesPattern = DW;
  Ue.referencesImport = VW;
  Ue.resolve = $W;
  Ue.willIMaybeExecuteBefore = KW;
  var PW = le(), {
    STATEMENT_OR_BLOCK_KEYS: AW,
    VISITOR_KEYS: vW,
    isBlockStatement: VT,
    isExpression: CW,
    isIdentifier: IW,
    isLiteral: wW,
    isStringLiteral: OW,
    isType: NW,
    matchesPattern: _W
  } = PW;
  function DW(e, t) {
    return _W(this.node, e, t);
  }
  s(DW, "matchesPattern");
  function UT(e) {
    let t = this.node && this.node[e];
    return t && Array.isArray(t) ? !!t.length : !!t;
  }
  s(UT, "has");
  function kW() {
    return this.scope.isStatic(this.node);
  }
  s(kW, "isStatic");
  var hte = Ue.is = UT;
  function LW(e) {
    return !this.has(e);
  }
  s(LW, "isnt");
  function MW(e, t) {
    return this.node[e] === t;
  }
  s(MW, "equals");
  function FW(e) {
    return NW(this.type, e);
  }
  s(FW, "isNodeType");
  function BW() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  s(BW, "canHaveVariableDeclarationOrExpression");
  function jW(e) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? VT(e) : this.isBlockStatement() ?
    CW(e) : !1;
  }
  s(jW, "canSwapBetweenExpressionAndStatement");
  function RW(e) {
    let t = this, r = !0;
    do {
      let {
        type: i,
        container: n
      } = t;
      if (!r && (t.isFunction() || i === "StaticBlock"))
        return !!e;
      if (r = !1, Array.isArray(n) && t.key !== n.length - 1)
        return !1;
    } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
    return !0;
  }
  s(RW, "isCompletionRecord");
  function qW() {
    return this.parentPath.isLabeledStatement() || VT(this.container) ? !1 : AW.includes(this.key);
  }
  s(qW, "isStatementOrBlock");
  function VW(e, t) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? OW(this.node.property, {
        value: t
      }) : this.node.property.name === t)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(e, "*");
      }
      return !1;
    }
    let r = this.scope.getBinding(this.node.name);
    if (!r || r.kind !== "module") return !1;
    let i = r.path, n = i.parentPath;
    if (!n.isImportDeclaration()) return !1;
    if (n.node.source.value === e) {
      if (!t) return !0;
    } else
      return !1;
    return !!(i.isImportDefaultSpecifier() && t === "default" || i.isImportNamespaceSpecifier() && t === "*" || i.isImportSpecifier() && IW(
    i.node.imported, {
      name: t
    }));
  }
  s(VW, "referencesImport");
  function UW() {
    let e = this.node;
    if (e.end) {
      let t = this.hub.getCode();
      if (t) return t.slice(e.start, e.end);
    }
    return "";
  }
  s(UW, "getSource");
  function KW(e) {
    return this._guessExecutionStatusRelativeTo(e) !== "after";
  }
  s(KW, "willIMaybeExecuteBefore");
  function jT(e) {
    return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
  }
  s(jT, "getOuterFunction");
  function WW(e, t) {
    switch (e) {
      case "LogicalExpression":
        return t === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return t === "consequent" || t === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return t === "body";
      case "ForStatement":
        return t === "body" || t === "update";
      case "SwitchStatement":
        return t === "cases";
      case "TryStatement":
        return t === "handler";
      case "AssignmentPattern":
        return t === "right";
      case "OptionalMemberExpression":
        return t === "property";
      case "OptionalCallExpression":
        return t === "arguments";
      default:
        return !1;
    }
  }
  s(WW, "isExecutionUncertain");
  function RT(e, t) {
    for (let r = 0; r < t; r++) {
      let i = e[r];
      if (WW(i.parent.type, i.parentKey))
        return !0;
    }
    return !1;
  }
  s(RT, "isExecutionUncertainInList");
  var qT = Symbol();
  function YW(e) {
    return Lc(this, e, /* @__PURE__ */ new Map());
  }
  s(YW, "_guessExecutionStatusRelativeTo");
  function Lc(e, t, r) {
    let i = {
      this: jT(e),
      target: jT(t)
    };
    if (i.target.node !== i.this.node)
      return JW(e, i.target, r);
    let n = {
      target: t.getAncestry(),
      this: e.getAncestry()
    };
    if (n.target.indexOf(e) >= 0) return "after";
    if (n.this.indexOf(t) >= 0) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < n.this.length; ) {
      let p = n.this[o.this];
      o.target = n.target.indexOf(p), o.target >= 0 ? a = p : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (RT(n.this, o.this - 1) || RT(n.target, o.target - 1))
      return "unknown";
    let l = {
      this: n.this[o.this - 1],
      target: n.target[o.target - 1]
    };
    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container)
      return l.target.key > l.this.key ? "before" : "after";
    let u = vW[a.type], c = {
      this: u.indexOf(l.this.parentKey),
      target: u.indexOf(l.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  s(Lc, "_guessExecutionStatusRelativeToCached");
  function XW(e, t, r) {
    if (t.isFunctionDeclaration()) {
      if (t.parentPath.isExportDeclaration())
        return "unknown";
    } else return Lc(e, t, r) === "before" ? "before" : "unknown";
    let i = t.scope.getBinding(t.node.id.name);
    if (!i.references) return "before";
    let n = i.referencePaths, a;
    for (let o of n) {
      if (!!o.find((c) => c.node === t.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let u = Lc(e, o, r);
      if (a && a !== u)
        return "unknown";
      a = u;
    }
    return a;
  }
  s(XW, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function JW(e, t, r) {
    let i = r.get(e.node), n;
    if (!i)
      r.set(e.node, i = /* @__PURE__ */ new Map());
    else if (n = i.get(t.node))
      return n === qT ? "unknown" : n;
    i.set(t.node, qT);
    let a = XW(e, t, r);
    return i.set(t.node, a), a;
  }
  s(JW, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function $W(e, t) {
    return this._resolve(e, t) || this;
  }
  s($W, "resolve");
  function HW(e, t) {
    if (!(t && t.indexOf(this) >= 0))
      if (t = t || [], t.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(e, t);
      } else if (this.isReferencedIdentifier()) {
        let r = this.scope.getBinding(this.node.name);
        if (!r || !r.constant || r.kind === "module") return;
        if (r.path !== this) {
          let i = r.path.resolve(e, t);
          return this.find((n) => n.node === i.node) ? void 0 : i;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(e, t);
        if (e && this.isMemberExpression()) {
          let r = this.toComputedKey();
          if (!wW(r)) return;
          let i = r.value, n = this.get("object").resolve(e, t);
          if (n.isObjectExpression()) {
            let a = n.get("properties");
            for (let o of a) {
              if (!o.isProperty()) continue;
              let l = o.get("key"), u = o.isnt("computed") && l.isIdentifier({
                name: i
              });
              if (u = u || l.isLiteral({
                value: i
              }), u) return o.get("value").resolve(e, t);
            }
          } else if (n.isArrayExpression() && !isNaN(+i)) {
            let o = n.get("elements")[i];
            if (o) return o.resolve(e, t);
          }
        }
      }
  }
  s(HW, "_resolve");
  function GW() {
    if (this.isIdentifier()) {
      let e = this.scope.getBinding(this.node.name);
      return e ? e.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: e
      } = this.node;
      return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  s(GW, "isConstantExpression");
  function zW() {
    return !!(this.isProgram() ? this : this.parentPath).find((r) => {
      if (r.isProgram({
        sourceType: "module"
      }) || r.isClass()) return !0;
      if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
        return !1;
      let i;
      if (r.isFunction())
        i = r.node.body;
      else if (r.isProgram())
        i = r.node;
      else
        return !1;
      for (let n of i.directives)
        if (n.value.value === "use strict")
          return !0;
    });
  }
  s(zW, "isInStrictMode");
});

// ../node_modules/@babel/traverse/lib/path/context.js
var XT = v((qe) => {
  "use strict";
  Object.defineProperty(qe, "__esModule", {
    value: !0
  });
  qe._call = eY;
  qe._getQueueContexts = gY;
  qe._resyncKey = cY;
  qe._resyncList = pY;
  qe._resyncParent = uY;
  qe._resyncRemoved = fY;
  qe.call = ZW;
  qe.isBlacklisted = qe.isDenylisted = tY;
  qe.popContext = hY;
  qe.pushContext = dY;
  qe.requeue = TY;
  qe.resync = lY;
  qe.setContext = oY;
  qe.setKey = yY;
  qe.setScope = aY;
  qe.setup = mY;
  qe.skip = iY;
  qe.skipKey = sY;
  qe.stop = nY;
  qe.visit = rY;
  var QW = In(), WT = gr();
  function ZW(e) {
    let t = this.opts;
    if (this.debug(e), this.node && this._call(t[e]))
      return !0;
    if (this.node) {
      var r;
      return this._call((r = t[this.node.type]) == null ? void 0 : r[e]);
    }
    return !1;
  }
  s(ZW, "call");
  function eY(e) {
    if (!e) return !1;
    for (let t of e) {
      if (!t) continue;
      let r = this.node;
      if (!r) return !0;
      let i = t.call(this.state, this, this.state);
      if (i && typeof i == "object" && typeof i.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (i)
        throw new Error(`Unexpected return value from visitor method ${t}`);
      if (this.node !== r || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  s(eY, "_call");
  function tY() {
    var e;
    let t = (e = this.opts.denylist) != null ? e : this.opts.blacklist;
    return t && t.indexOf(this.node.type) > -1;
  }
  s(tY, "isDenylisted");
  function YT(e, t) {
    e.context !== t && (e.context = t, e.state = t.state, e.opts = t.opts);
  }
  s(YT, "restoreContext");
  function rY() {
    var e, t;
    if (!this.node || this.isDenylisted() || (e = (t = this.opts).shouldSkip) != null && e.call(t, this))
      return !1;
    let r = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (YT(this, r), this.debug("Recursing into..."),
    this.shouldStop = (0, QW.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), YT(this, r), this.call("exit"),
    this.shouldStop);
  }
  s(rY, "visit");
  function iY() {
    this.shouldSkip = !0;
  }
  s(iY, "skip");
  function sY(e) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[e] = !0;
  }
  s(sY, "skipKey");
  function nY() {
    this._traverseFlags |= WT.SHOULD_SKIP | WT.SHOULD_STOP;
  }
  s(nY, "stop");
  function aY() {
    var e, t;
    if ((e = this.opts) != null && e.noScope) return;
    let r = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) && (r = r.
    parentPath);
    let i;
    for (; r && !i; ) {
      var n;
      if ((n = r.opts) != null && n.noScope) return;
      i = r.scope, r = r.parentPath;
    }
    this.scope = this.getScope(i), (t = this.scope) == null || t.init();
  }
  s(aY, "setScope");
  function oY(e) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, e && (this.context = e, this.state = e.state, this.opts =
    e.opts), this.setScope(), this;
  }
  s(oY, "setContext");
  function lY() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }
  s(lY, "resync");
  function uY() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  s(uY, "_resyncParent");
  function cY() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let e = 0; e < this.container.length; e++)
          if (this.container[e] === this.node) {
            this.setKey(e);
            return;
          }
      } else
        for (let e of Object.keys(this.container))
          if (this.container[e] === this.node) {
            this.setKey(e);
            return;
          }
      this.key = null;
    }
  }
  s(cY, "_resyncKey");
  function pY() {
    if (!this.parent || !this.inList) return;
    let e = this.parent[this.listKey];
    this.container !== e && (this.container = e || null);
  }
  s(pY, "_resyncList");
  function fY() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && this._markRemoved();
  }
  s(fY, "_resyncRemoved");
  function hY() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  s(hY, "popContext");
  function dY(e) {
    this.contexts.push(e), this.setContext(e);
  }
  s(dY, "pushContext");
  function mY(e, t, r, i) {
    this.listKey = r, this.container = t, this.parentPath = e || this.parentPath, this.setKey(i);
  }
  s(mY, "setup");
  function yY(e) {
    var t;
    this.key = e, this.node = this.container[this.key], this.type = (t = this.node) == null ? void 0 : t.type;
  }
  s(yY, "setKey");
  function TY(e = this) {
    if (e.removed) return;
    let t = this.contexts;
    for (let r of t)
      r.maybeQueue(e);
  }
  s(TY, "requeue");
  function gY() {
    let e = this, t = this.contexts;
    for (; !t.length && (e = e.parentPath, !!e); )
      t = e.contexts;
    return t;
  }
  s(gY, "_getQueueContexts");
});

// ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var JT = v((ia) => {
  "use strict";
  Object.defineProperty(ia, "__esModule", {
    value: !0
  });
  ia.hooks = void 0;
  var gte = ia.hooks = [function(e, t) {
    if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.
    isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expr\
ession" && t.isExpressionStatement())
      return t.remove(), !0;
  }, function(e, t) {
    if (t.isSequenceExpression() && t.node.expressions.length === 1)
      return t.replaceWith(t.node.expressions[0]), !0;
  }, function(e, t) {
    if (t.isBinary())
      return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
  }, function(e, t) {
    if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
      return e.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/traverse/lib/path/removal.js
var HT = v((br) => {
  "use strict";
  Object.defineProperty(br, "__esModule", {
    value: !0
  });
  br._assertUnremoved = wY;
  br._callRemovalHooks = vY;
  br._markRemoved = IY;
  br._remove = CY;
  br._removeFromScope = AY;
  br.remove = PY;
  var bY = JT(), SY = Fr(), $T = gr(), xY = le(), {
    getBindingIdentifiers: EY
  } = xY;
  function PY() {
    var e;
    if (this._assertUnremoved(), this.resync(), (e = this.opts) != null && e.noScope || this._removeFromScope(), this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
  }
  s(PY, "remove");
  function AY() {
    let e = EY(this.node, !1, !1, !0);
    Object.keys(e).forEach((t) => this.scope.removeBinding(t));
  }
  s(AY, "_removeFromScope");
  function vY() {
    if (this.parentPath) {
      for (let e of bY.hooks)
        if (e(this, this.parentPath)) return !0;
    }
  }
  s(vY, "_callRemovalHooks");
  function CY() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }
  s(CY, "_remove");
  function IY() {
    this._traverseFlags |= $T.SHOULD_SKIP | $T.REMOVED, this.parent && (0, SY.getCachedPaths)(this.hub, this.parent).delete(this.node), this.
    node = null;
  }
  s(IY, "_markRemoved");
  function wY() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  s(wY, "_assertUnremoved");
});

// ../node_modules/@babel/traverse/lib/path/lib/hoister.js
var zT = v((sa) => {
  "use strict";
  Object.defineProperty(sa, "__esModule", {
    value: !0
  });
  sa.default = void 0;
  var GT = le(), OY = GT, {
    react: NY
  } = GT, {
    cloneNode: _Y,
    jsxExpressionContainer: DY,
    variableDeclaration: kY,
    variableDeclarator: LY
  } = OY, MY = {
    ReferencedIdentifier(e, t) {
      if (e.isJSXIdentifier() && NY.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
        return;
      if (e.node.name === "this") {
        let i = e.scope;
        do
          if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
            break;
        while (i = i.parent);
        i && t.breakOnScopePaths.push(i.path);
      }
      let r = e.scope.getBinding(e.node.name);
      if (r) {
        for (let i of r.constantViolations)
          if (i.scope !== r.path.scope) {
            t.mutableBinding = !0, e.stop();
            return;
          }
        r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
      }
    }
  }, Mc = class {
    static {
      s(this, "PathHoister");
    }
    constructor(t, r) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = r, this.path = t, this.attachAfter = !1;
    }
    isCompatibleScope(t) {
      for (let r of Object.keys(this.bindings)) {
        let i = this.bindings[r];
        if (!t.bindingIdentifierEquals(r, i.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let t = this.path.scope;
      do {
        if (this.isCompatibleScope(t))
          this.scopes.push(t);
        else
          break;
        if (this.breakOnScopePaths.indexOf(t.path) >= 0)
          break;
      } while (t = t.parent);
    }
    getAttachmentPath() {
      let t = this._getAttachmentPath();
      if (!t) return;
      let r = t.scope;
      if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction())
        for (let i of Object.keys(this.bindings)) {
          if (!r.hasOwnBinding(i)) continue;
          let n = this.bindings[i];
          if (n.kind === "param" || n.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(n.path).key >= t.key) {
            this.attachAfter = !0, t = n.path;
            for (let o of n.constantViolations)
              this.getAttachmentParentForPath(o).key > t.key && (t = o);
          }
        }
      return t;
    }
    _getAttachmentPath() {
      let r = this.scopes.pop();
      if (r) {
        if (r.path.isFunction())
          if (this.hasOwnParamBindings(r)) {
            if (this.scope === r) return;
            let i = r.path.get("body").get("body");
            for (let n = 0; n < i.length; n++)
              if (!i[n].node._blockHoist)
                return i[n];
          } else
            return this.getNextScopeAttachmentParent();
        else if (r.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let t = this.scopes.pop();
      if (t) return this.getAttachmentParentForPath(t.path);
    }
    getAttachmentParentForPath(t) {
      do
        if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
          return t;
      while (t = t.parentPath);
    }
    hasOwnParamBindings(t) {
      for (let r of Object.keys(this.bindings)) {
        if (!t.hasOwnBinding(r)) continue;
        let i = this.bindings[r];
        if (i.kind === "param" && i.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(MY, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let t = this.getAttachmentPath();
      if (!t || t.getFunctionParent() === this.path.getFunctionParent()) return;
      let r = t.scope.generateUidIdentifier("ref"), i = LY(r, this.path.node), n = this.attachAfter ? "insertAfter" : "insertBefore", [a] = t[n](
      [t.isVariableDeclarator() ? i : kY("var", [i])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (r = DY(r)), this.path.replaceWith(_Y(r)), t.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  sa.default = Mc;
});

// ../node_modules/@babel/traverse/lib/path/modification.js
var r0 = v((It) => {
  "use strict";
  Object.defineProperty(It, "__esModule", {
    value: !0
  });
  It._containerInsert = zY;
  It._containerInsertAfter = ZY;
  It._containerInsertBefore = QY;
  It._verifyNodeList = iX;
  It.hoist = aX;
  It.insertAfter = tX;
  It.insertBefore = GY;
  It.pushContainer = nX;
  It.unshiftContainer = sX;
  It.updateSiblingKeys = rX;
  var FY = Fr(), BY = zT(), jc = gr(), jY = le(), {
    arrowFunctionExpression: RY,
    assertExpression: qY,
    assignmentExpression: VY,
    blockStatement: QT,
    callExpression: UY,
    cloneNode: Fc,
    expressionStatement: Bc,
    isAssignmentExpression: KY,
    isCallExpression: WY,
    isExportNamedDeclaration: ZT,
    isExpression: YY,
    isIdentifier: XY,
    isSequenceExpression: JY,
    isSuper: $Y,
    thisExpression: HY
  } = jY;
  function GY(e) {
    this._assertUnremoved();
    let t = this._verifyNodeList(e), {
      parentPath: r,
      parent: i
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || ZT(i) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertBefore(t);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init")
      return this.node && t.push(this.node), this.replaceExpressionWithStatements(t);
    if (Array.isArray(this.container))
      return this._containerInsertBefore(t);
    if (this.isStatementOrBlock()) {
      let n = this.node, a = n && (!this.isExpressionStatement() || n.expression != null);
      return this.replaceWith(QT(a ? [n] : [])), this.unshiftContainer("body", t);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  s(GY, "insertBefore");
  function zY(e, t) {
    this.updateSiblingKeys(e, t.length);
    let r = [];
    this.container.splice(e, 0, ...t);
    for (let a = 0; a < t.length; a++) {
      var i;
      let o = e + a, l = this.getSibling(o);
      r.push(l), (i = this.context) != null && i.queue && l.pushContext(this.context);
    }
    let n = this._getQueueContexts();
    for (let a of r) {
      a.setScope(), a.debug("Inserted.");
      for (let o of n)
        o.maybeQueue(a, !0);
    }
    return r;
  }
  s(zY, "_containerInsert");
  function QY(e) {
    return this._containerInsert(this.key, e);
  }
  s(QY, "_containerInsertBefore");
  function ZY(e) {
    return this._containerInsert(this.key + 1, e);
  }
  s(ZY, "_containerInsertAfter");
  var e0 = /* @__PURE__ */ s((e) => e[e.length - 1], "last");
  function t0(e) {
    return JY(e.parent) && (e0(e.parent.expressions) !== e.node || t0(e.parentPath));
  }
  s(t0, "isHiddenInSequenceExpression");
  function eX(e, t) {
    if (!KY(e) || !XY(e.left))
      return !1;
    let r = t.getBlockParent();
    return r.hasOwnBinding(e.left.name) && r.getOwnBinding(e.left.name).constantViolations.length <= 1;
  }
  s(eX, "isAlmostConstantAssignment");
  function tX(e) {
    if (this._assertUnremoved(), this.isSequenceExpression())
      return e0(this.get("expressions")).insertAfter(e);
    let t = this._verifyNodeList(e), {
      parentPath: r,
      parent: i
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || ZT(i) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertAfter(t.map((n) => YY(n) ? Bc(n) : n));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
      if (this.node) {
        let n = this.node, {
          scope: a
        } = this;
        if (a.path.isPattern())
          return qY(n), this.replaceWith(UY(RY([], n), [])), this.get("callee.body").insertAfter(t), [this];
        if (t0(this))
          t.unshift(n);
        else if (WY(n) && $Y(n.callee))
          t.unshift(n), t.push(HY());
        else if (eX(n, a))
          t.unshift(n), t.push(Fc(n.left));
        else if (a.isPure(n, !0))
          t.push(n);
        else {
          r.isMethod({
            computed: !0,
            key: n
          }) && (a = a.parent);
          let o = a.generateDeclaredUidIdentifier();
          t.unshift(Bc(VY("=", Fc(o), n))), t.push(Bc(Fc(o)));
        }
      }
      return this.replaceExpressionWithStatements(t);
    } else {
      if (Array.isArray(this.container))
        return this._containerInsertAfter(t);
      if (this.isStatementOrBlock()) {
        let n = this.node, a = n && (!this.isExpressionStatement() || n.expression != null);
        return this.replaceWith(QT(a ? [n] : [])), this.pushContainer("body", t);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  s(tX, "insertAfter");
  function rX(e, t) {
    if (!this.parent) return;
    let r = (0, FY.getCachedPaths)(this.hub, this.parent) || [];
    for (let [, i] of r)
      typeof i.key == "number" && i.key >= e && (i.key += t);
  }
  s(rX, "updateSiblingKeys");
  function iX(e) {
    if (!e)
      return [];
    Array.isArray(e) || (e = [e]);
    for (let t = 0; t < e.length; t++) {
      let r = e[t], i;
      if (r ? typeof r != "object" ? i = "contains a non-object node" : r.type ? r instanceof jc.default && (i = "has a NodePath when it exp\
ected a raw object") : i = "without a type" : i = "has falsy node", i) {
        let n = Array.isArray(r) ? "array" : typeof r;
        throw new Error(`Node list ${i} with the index of ${t} and type of ${n}`);
      }
    }
    return e;
  }
  s(iX, "_verifyNodeList");
  function sX(e, t) {
    return this._assertUnremoved(), t = this._verifyNodeList(t), jc.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[e],
      listKey: e,
      key: 0
    }).setContext(this.context)._containerInsertBefore(t);
  }
  s(sX, "unshiftContainer");
  function nX(e, t) {
    this._assertUnremoved();
    let r = this._verifyNodeList(t), i = this.node[e];
    return jc.default.get({
      parentPath: this,
      parent: this.node,
      container: i,
      listKey: e,
      key: i.length
    }).setContext(this.context).replaceWithMultiple(r);
  }
  s(nX, "pushContainer");
  function aX(e = this.scope) {
    return new BY.default(this, e).run();
  }
  s(aX, "hoist");
});

// ../node_modules/@babel/traverse/lib/path/family.js
var n0 = v((st) => {
  "use strict";
  Object.defineProperty(st, "__esModule", {
    value: !0
  });
  st._getKey = AX;
  st._getPattern = vX;
  st.get = PX;
  st.getAllNextSiblings = xX;
  st.getAllPrevSiblings = EX;
  st.getBindingIdentifierPaths = wX;
  st.getBindingIdentifiers = CX;
  st.getCompletionRecords = TX;
  st.getNextSibling = SX;
  st.getOpposite = dX;
  st.getOuterBindingIdentifierPaths = OX;
  st.getOuterBindingIdentifiers = IX;
  st.getPrevSibling = bX;
  st.getSibling = gX;
  var qc = gr(), oX = le(), {
    getBindingIdentifiers: s0,
    getOuterBindingIdentifiers: lX,
    isDeclaration: uX,
    numericLiteral: cX,
    unaryExpression: pX
  } = oX, Vc = 0, xs = 1;
  function fX(e) {
    return {
      type: Vc,
      path: e
    };
  }
  s(fX, "NormalCompletion");
  function hX(e) {
    return {
      type: xs,
      path: e
    };
  }
  s(hX, "BreakCompletion");
  function dX() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  s(dX, "getOpposite");
  function Ei(e, t, r) {
    return e && t.push(...Pi(e, r)), t;
  }
  s(Ei, "addCompletionRecords");
  function mX(e, t, r) {
    let i = [];
    for (let n = 0; n < e.length; n++) {
      let a = e[n], o = Pi(a, r), l = [], u = [];
      for (let c of o)
        c.type === Vc && l.push(c), c.type === xs && u.push(c);
      l.length && (i = l), t.push(...u);
    }
    return t.push(...i), t;
  }
  s(mX, "completionRecordForSwitch");
  function yX(e) {
    e.forEach((t) => {
      t.type = xs;
    });
  }
  s(yX, "normalCompletionToBreak");
  function Rc(e, t) {
    e.forEach((r) => {
      r.path.isBreakStatement({
        label: null
      }) && (t ? r.path.replaceWith(pX("void", cX(0))) : r.path.remove());
    });
  }
  s(Rc, "replaceBreakStatementInBreakCompletion");
  function i0(e, t) {
    let r = [];
    if (t.canHaveBreak) {
      let i = [];
      for (let n = 0; n < e.length; n++) {
        let a = e[n], o = Object.assign({}, t, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let l = Pi(a, o);
        if (l.length > 0 && l.every((u) => u.type === xs)) {
          i.length > 0 && l.every((u) => u.path.isBreakStatement({
            label: null
          })) ? (yX(i), r.push(...i), i.some((u) => u.path.isDeclaration()) && (r.push(...l), Rc(l, !0)), Rc(l, !1)) : (r.push(...l), t.shouldPopulateBreak ||
          Rc(l, !0));
          break;
        }
        if (n === e.length - 1)
          r.push(...l);
        else {
          i = [];
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c.type === xs && r.push(c), c.type === Vc && i.push(c);
          }
        }
      }
    } else if (e.length)
      for (let i = e.length - 1; i >= 0; i--) {
        let n = Pi(e[i], t);
        if (n.length > 1 || n.length === 1 && !n[0].path.isVariableDeclaration()) {
          r.push(...n);
          break;
        }
      }
    return r;
  }
  s(i0, "getStatementListCompletion");
  function Pi(e, t) {
    let r = [];
    if (e.isIfStatement())
      r = Ei(e.get("consequent"), r, t), r = Ei(e.get("alternate"), r, t);
    else {
      if (e.isDoExpression() || e.isFor() || e.isWhile() || e.isLabeledStatement())
        return Ei(e.get("body"), r, t);
      if (e.isProgram() || e.isBlockStatement())
        return i0(e.get("body"), t);
      if (e.isFunction())
        return Pi(e.get("body"), t);
      if (e.isTryStatement())
        r = Ei(e.get("block"), r, t), r = Ei(e.get("handler"), r, t);
      else {
        if (e.isCatchClause())
          return Ei(e.get("body"), r, t);
        if (e.isSwitchStatement())
          return mX(e.get("cases"), r, t);
        if (e.isSwitchCase())
          return i0(e.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        e.isBreakStatement() ? r.push(hX(e)) : r.push(fX(e));
      }
    }
    return r;
  }
  s(Pi, "_getCompletionRecords");
  function TX() {
    return Pi(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((t) => t.path);
  }
  s(TX, "getCompletionRecords");
  function gX(e) {
    return qc.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: e
    }).setContext(this.context);
  }
  s(gX, "getSibling");
  function bX() {
    return this.getSibling(this.key - 1);
  }
  s(bX, "getPrevSibling");
  function SX() {
    return this.getSibling(this.key + 1);
  }
  s(SX, "getNextSibling");
  function xX() {
    let e = this.key, t = this.getSibling(++e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(++e);
    return r;
  }
  s(xX, "getAllNextSiblings");
  function EX() {
    let e = this.key, t = this.getSibling(--e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(--e);
    return r;
  }
  s(EX, "getAllPrevSiblings");
  function PX(e, t = !0) {
    t === !0 && (t = this.context);
    let r = e.split(".");
    return r.length === 1 ? this._getKey(e, t) : this._getPattern(r, t);
  }
  s(PX, "get");
  function AX(e, t) {
    let r = this.node, i = r[e];
    return Array.isArray(i) ? i.map((n, a) => qc.default.get({
      listKey: e,
      parentPath: this,
      parent: r,
      container: i,
      key: a
    }).setContext(t)) : qc.default.get({
      parentPath: this,
      parent: r,
      container: r,
      key: e
    }).setContext(t);
  }
  s(AX, "_getKey");
  function vX(e, t) {
    let r = this;
    for (let i of e)
      i === "." ? r = r.parentPath : Array.isArray(r) ? r = r[i] : r = r.get(i, t);
    return r;
  }
  s(vX, "_getPattern");
  function CX(e) {
    return s0(this.node, e);
  }
  s(CX, "getBindingIdentifiers");
  function IX(e) {
    return lX(this.node, e);
  }
  s(IX, "getOuterBindingIdentifiers");
  function wX(e = !1, t = !1) {
    let i = [this], n = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let a = i.shift();
      if (!a || !a.node) continue;
      let o = s0.keys[a.node.type];
      if (a.isIdentifier()) {
        e ? (n[a.node.name] = n[a.node.name] || []).push(a) : n[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let l = a.get("declaration");
        uX(l) && i.push(l);
        continue;
      }
      if (t) {
        if (a.isFunctionDeclaration()) {
          i.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let l = 0; l < o.length; l++) {
          let u = o[l], c = a.get(u);
          Array.isArray(c) ? i.push(...c) : c.node && i.push(c);
        }
    }
    return n;
  }
  s(wX, "getBindingIdentifierPaths");
  function OX(e = !1) {
    return this.getBindingIdentifierPaths(e, !0);
  }
  s(OX, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/traverse/lib/path/comments.js
var o0 = v((Es) => {
  "use strict";
  Object.defineProperty(Es, "__esModule", {
    value: !0
  });
  Es.addComment = LX;
  Es.addComments = MX;
  Es.shareCommentsWithSiblings = kX;
  var NX = le(), {
    addComment: _X,
    addComments: DX
  } = NX;
  function kX() {
    if (typeof this.key == "string") return;
    let e = this.node;
    if (!e) return;
    let t = e.trailingComments, r = e.leadingComments;
    if (!t && !r) return;
    let i = this.getSibling(this.key - 1), n = this.getSibling(this.key + 1), a = !!i.node, o = !!n.node;
    a && (r && i.addComments("trailing", a0(r, i.node.trailingComments)), t && !o && i.addComments("trailing", t)), o && (t && n.addComments(
    "leading", a0(t, n.node.leadingComments)), r && !a && n.addComments("leading", r));
  }
  s(kX, "shareCommentsWithSiblings");
  function a0(e, t) {
    if (!(t != null && t.length)) return e;
    let r = new Set(t);
    return e.filter((i) => !r.has(i));
  }
  s(a0, "removeIfExisting");
  function LX(e, t, r) {
    _X(this.node, e, t, r);
  }
  s(LX, "addComment");
  function MX(e, t) {
    DX(this.node, e, t);
  }
  s(MX, "addComments");
});

// ../node_modules/@babel/traverse/lib/path/index.js
var gr = v((Vt) => {
  "use strict";
  Object.defineProperty(Vt, "__esModule", {
    value: !0
  });
  Vt.default = Vt.SHOULD_STOP = Vt.SHOULD_SKIP = Vt.REMOVED = void 0;
  var FX = $l(), BX = Wd(), jX = Rr(), RX = fu(), u0 = le(), na = u0, qX = Fr(), VX = ii(), UX = pm(), KX = Nm(), WX = uT(), YX = hT(), XX = BT(),
  c0 = KT(), JX = XT(), $X = HT(), HX = r0(), GX = n0(), zX = o0(), QX = Gl(), {
    validate: ZX
  } = u0, l0 = BX("babel"), Uc = Vt.REMOVED = 1, Kc = Vt.SHOULD_STOP = 2, Wc = Vt.SHOULD_SKIP = 4, Sr = class e {
    static {
      s(this, "NodePath");
    }
    constructor(t, r) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container =
      null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = r, this.hub = t, this.data = null, this.
      context = null, this.scope = null;
    }
    static get({
      hub: t,
      parentPath: r,
      parent: i,
      container: n,
      listKey: a,
      key: o
    }) {
      if (!t && r && (t = r.hub), !i)
        throw new Error("To get a node path the parent needs to exist");
      let l = n[o], u = qX.getOrCreateCachedPaths(t, i), c = u.get(l);
      return c || (c = new e(t, i), l && u.set(l, c)), c.setup(r, n, a, o), c;
    }
    getScope(t) {
      return this.isScope() ? new RX.default(this) : t;
    }
    setData(t, r) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[t] = r;
    }
    getData(t, r) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let i = this.data[t];
      return i === void 0 && r !== void 0 && (i = this.data[t] = r), i;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(t, r = SyntaxError) {
      return this.hub.buildError(this.node, t, r);
    }
    traverse(t, r) {
      (0, jX.default)(this.node, t, this.scope, r, this);
    }
    set(t, r) {
      ZX(this.node, t, r), this.node[t] = r;
    }
    getPathLocation() {
      let t = [], r = this;
      do {
        let i = r.key;
        r.inList && (i = `${r.listKey}[${i}]`), t.unshift(i);
      } while (r = r.parentPath);
      return t.join(".");
    }
    debug(t) {
      l0.enabled && l0(`${this.getPathLocation()} ${this.type}: ${t}`);
    }
    toString() {
      return (0, VX.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(t) {
      t || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & Wc);
    }
    set shouldSkip(t) {
      t ? this._traverseFlags |= Wc : this._traverseFlags &= ~Wc;
    }
    get shouldStop() {
      return !!(this._traverseFlags & Kc);
    }
    set shouldStop(t) {
      t ? this._traverseFlags |= Kc : this._traverseFlags &= ~Kc;
    }
    get removed() {
      return !!(this._traverseFlags & Uc);
    }
    set removed(t) {
      t ? this._traverseFlags |= Uc : this._traverseFlags &= ~Uc;
    }
  };
  Object.assign(Sr.prototype, UX, KX, WX, YX, XX, c0, JX, $X, HX, GX, zX);
  Sr.prototype._guessExecutionStatusRelativeToDifferentFunctions = c0._guessExecutionStatusRelativeTo;
  for (let e of na.TYPES) {
    let t = `is${e}`, r = na[t];
    Sr.prototype[t] = function(i) {
      return r(this.node, i);
    }, Sr.prototype[`assert${e}`] = function(i) {
      if (!r(this.node, i))
        throw new TypeError(`Expected node path of type ${e}`);
    };
  }
  Object.assign(Sr.prototype, QX);
  for (let e of Object.keys(FX))
    e[0] !== "_" && (na.TYPES.includes(e) || na.TYPES.push(e));
  var Nte = Vt.default = Sr;
});

// ../node_modules/@babel/traverse/lib/context.js
var p0 = v((aa) => {
  "use strict";
  Object.defineProperty(aa, "__esModule", {
    value: !0
  });
  aa.default = void 0;
  var eJ = gr(), tJ = le(), {
    VISITOR_KEYS: rJ
  } = tJ, Yc = class {
    static {
      s(this, "TraversalContext");
    }
    constructor(t, r, i, n) {
      this.queue = null, this.priorityQueue = null, this.parentPath = n, this.scope = t, this.state = i, this.opts = r;
    }
    shouldVisit(t) {
      let r = this.opts;
      if (r.enter || r.exit || r[t.type]) return !0;
      let i = rJ[t.type];
      if (!(i != null && i.length)) return !1;
      for (let n of i)
        if (t[n])
          return !0;
      return !1;
    }
    create(t, r, i, n) {
      return eJ.default.get({
        parentPath: this.parentPath,
        parent: t,
        container: r,
        key: i,
        listKey: n
      });
    }
    maybeQueue(t, r) {
      this.queue && (r ? this.queue.push(t) : this.priorityQueue.push(t));
    }
    visitMultiple(t, r, i) {
      if (t.length === 0) return !1;
      let n = [];
      for (let a = 0; a < t.length; a++) {
        let o = t[a];
        o && this.shouldVisit(o) && n.push(this.create(r, t, a, i));
      }
      return this.visitQueue(n);
    }
    visitSingle(t, r) {
      return this.shouldVisit(t[r]) ? this.visitQueue([this.create(t, t, r)]) : !1;
    }
    visitQueue(t) {
      this.queue = t, this.priorityQueue = [];
      let r = /* @__PURE__ */ new WeakSet(), i = !1, n = 0;
      for (; n < t.length; ) {
        let a = t[n];
        if (n++, a.resync(), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && a.pushContext(this), a.key === null)
         continue;
        let {
          node: o
        } = a;
        if (!r.has(o)) {
          if (o && r.add(o), a.visit()) {
            i = !0;
            break;
          }
          if (this.priorityQueue.length && (i = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = t, i))
            break;
        }
      }
      for (let a = 0; a < n; a++)
        t[a].popContext();
      return this.queue = null, i;
    }
    visit(t, r) {
      let i = t[r];
      return i ? Array.isArray(i) ? this.visitMultiple(i, t, r) : this.visitSingle(t, r) : !1;
    }
  };
  aa.default = Yc;
});

// ../node_modules/@babel/traverse/lib/traverse-node.js
var In = v((Xc) => {
  "use strict";
  Object.defineProperty(Xc, "__esModule", {
    value: !0
  });
  Xc.traverseNode = aJ;
  var iJ = p0(), sJ = le(), {
    VISITOR_KEYS: nJ
  } = sJ;
  function aJ(e, t, r, i, n, a, o) {
    let l = nJ[e.type];
    if (!l) return !1;
    let u = new iJ.default(r, t, i, n);
    if (o)
      return a != null && a[n.parentKey] ? !1 : u.visitQueue([n]);
    for (let c of l)
      if (!(a != null && a[c]) && u.visit(e, c))
        return !0;
    return !1;
  }
  s(aJ, "traverseNode");
});

// ../node_modules/@babel/traverse/lib/hub.js
var f0 = v((oa) => {
  "use strict";
  Object.defineProperty(oa, "__esModule", {
    value: !0
  });
  oa.default = void 0;
  var Jc = class {
    static {
      s(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(t, r, i = TypeError) {
      return new i(r);
    }
  };
  oa.default = Jc;
});

// ../node_modules/@babel/traverse/lib/index.js
var Rr = v((Zt) => {
  "use strict";
  Object.defineProperty(Zt, "__esModule", {
    value: !0
  });
  Object.defineProperty(Zt, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return pJ.default;
    }, "get")
  });
  Object.defineProperty(Zt, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return uJ.default;
    }, "get")
  });
  Object.defineProperty(Zt, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cJ.default;
    }, "get")
  });
  Zt.visitors = Zt.default = void 0;
  var Ps = es();
  Zt.visitors = Ps;
  var oJ = le(), lJ = Fr(), h0 = In(), uJ = gr(), cJ = fu(), pJ = f0(), {
    VISITOR_KEYS: fJ,
    removeProperties: hJ,
    traverseFast: d0
  } = oJ;
  function wt(e, t = {}, r, i, n, a) {
    if (e) {
      if (!t.noScope && !r && e.type !== "Program" && e.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e.
        type} node without passing scope and parentPath.`);
      if (!n && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      fJ[e.type] && (Ps.explode(t), (0, h0.traverseNode)(e, t, r, i, n, null, a));
    }
  }
  s(wt, "traverse");
  var Rte = Zt.default = wt;
  wt.visitors = Ps;
  wt.verify = Ps.verify;
  wt.explode = Ps.explode;
  wt.cheap = function(e, t) {
    d0(e, t);
  };
  wt.node = function(e, t, r, i, n, a) {
    (0, h0.traverseNode)(e, t, r, i, n, a);
  };
  wt.clearNode = function(e, t) {
    hJ(e, t);
  };
  wt.removeProperties = function(e, t) {
    return d0(e, wt.clearNode, t), e;
  };
  function dJ(e, t) {
    e.node.type === t.type && (t.has = !0, e.stop());
  }
  s(dJ, "hasDenylistedType");
  wt.hasType = function(e, t, r) {
    if (r != null && r.includes(e.type)) return !1;
    if (e.type === t) return !0;
    let i = {
      has: !1,
      type: t
    };
    return wt(e, {
      noScope: !0,
      denylist: r,
      enter: dJ
    }, null, i), i.has;
  };
  wt.cache = lJ;
});

// src/csf-tools/index.ts
var kJ = {};
J0(kJ, {
  ConfigFile: () => fa,
  CsfFile: () => ca,
  NoMetaError: () => vs,
  babelParse: () => xr,
  babelParseExpression: () => TJ,
  babelPrint: () => yJ,
  enrichCsf: () => DJ,
  enrichCsfMeta: () => F0,
  enrichCsfStory: () => L0,
  extractDescription: () => up,
  extractSource: () => B0,
  formatConfig: () => O0,
  formatCsf: () => EJ,
  getStorySortParameter: () => NJ,
  loadConfig: () => w0,
  loadCsf: () => b0,
  parserOptions: () => $c,
  printConfig: () => N0,
  printCsf: () => S0,
  readConfig: () => vJ,
  readCsf: () => PJ,
  writeConfig: () => CJ,
  writeCsf: () => AJ
});
module.exports = $0(kJ);

// src/csf-tools/CsfFile.ts
var pa = require("node:fs/promises"), As = Ge(Ls(), 1), j = Ge(le(), 1), Hc = Ge(ii(), 1), Gc = Ge(Rr(), 1), Qc = Ge(require("recast"), 1), Er = require("@storybook/csf");

// src/csf-tools/babelParse.ts
var la = Ge(zn(), 1), ua = Ge(require("recast"), 1);
function mJ(e, t) {
  let n = /^\s*\/\/\s*@flow/.test(e) ? ["flow"] : ["typescript"], a = {
    ...t,
    plugins: [...t.plugins ?? [], ...n]
  };
  return la.parse(e, a);
}
s(mJ, "parseWithFlowOrTypescript");
var $c = {
  sourceType: "module",
  // FIXME: we should get this from the project config somehow?
  plugins: ["jsx", "decorators-legacy", "classProperties"],
  tokens: !0
}, xr = /* @__PURE__ */ s((e) => ua.parse(e, {
  parser: {
    parse(t) {
      return mJ(t, $c);
    }
  }
}), "babelParse"), yJ = /* @__PURE__ */ s((e) => ua.print(e, {
  quote: "single",
  trailingComma: !0,
  tabWidth: 2,
  wrapColumn: 80,
  arrowParensAlways: !0
}).code, "babelPrint"), TJ = /* @__PURE__ */ s((e) => la.parseExpression(e, $c), "babelParseExpression");

// src/csf-tools/findVarInitialization.ts
var er = Ge(le(), 1);
var tr = /* @__PURE__ */ s((e, t) => {
  let r = null, i = null;
  return t.body.find((n) => (er.isVariableDeclaration(n) ? i = n.declarations : er.isExportNamedDeclaration(n) && er.isVariableDeclaration(n.
  declaration) && (i = n.declaration.declarations), i && i.find((a) => er.isVariableDeclarator(a) && er.isIdentifier(a.id) && a.id.name === e ?
  (r = a.init, !0) : !1))), r;
}, "findVarInitialization");

// src/csf-tools/CsfFile.ts
var gJ = Gc.default.default || Gc.default, bJ = Hc.default.default || Hc.default, m0 = console;
function SJ(e) {
  if (j.isArrayExpression(e))
    return e.elements.map((t) => {
      if (j.isStringLiteral(t)) return t.value;
      throw new Error(`Expected string literal: ${t}`);
    });
  if (j.isStringLiteral(e)) return new RegExp(e.value);
  if (j.isRegExpLiteral(e)) return new RegExp(e.pattern, e.flags);
  throw new Error(`Unknown include/exclude: ${e}`);
}
s(SJ, "parseIncludeExclude");
function y0(e) {
  if (!j.isArrayExpression(e))
    throw new Error("CSF: Expected tags array");
  return e.elements.map((t) => {
    if (j.isStringLiteral(t)) return t.value;
    throw new Error("CSF: Expected tag to be string literal");
  });
}
s(y0, "parseTags");
var zc = /* @__PURE__ */ s((e, t) => {
  let { line: r, column: i } = e.loc?.start || {};
  return `${t || ""} (line ${r}, col ${i})`.trim();
}, "formatLocation"), T0 = /* @__PURE__ */ s((e, t, r) => {
  let i = e;
  if (j.isCallExpression(e)) {
    let { callee: n, arguments: a } = e;
    if (j.isProgram(t) && j.isMemberExpression(n) && j.isIdentifier(n.object) && j.isIdentifier(n.property) && n.property.name === "bind" &&
    (a.length === 0 || a.length === 1 && j.isObjectExpression(a[0]) && a[0].properties.length === 0)) {
      let o = n.object.name, l = tr(o, t);
      l && (r._templates[o] = l, i = l);
    }
  }
  return j.isArrowFunctionExpression(i) || j.isFunctionDeclaration(i) ? i.params.length > 0 : !1;
}, "isArgsStory"), xJ = /* @__PURE__ */ s((e) => {
  if (j.isArrayExpression(e))
    return e.elements.map((t) => {
      if (j.isStringLiteral(t))
        return t.value;
      throw new Error(`Expected string literal named export: ${t}`);
    });
  throw new Error(`Expected array of string literals: ${e}`);
}, "parseExportsOrder"), g0 = /* @__PURE__ */ s((e, t) => t.reduce(
  (r, i) => {
    let n = e[i];
    return n && (r[i] = n), r;
  },
  {}
), "sortExports"), vs = class extends Error {
  static {
    s(this, "NoMetaError");
  }
  constructor(t, r, i) {
    super(As.dedent`
      CSF: ${t} ${zc(r, i)}

      More info: https://storybook.js.org/docs/react/writing-stories#default-export
    `), this.name = this.constructor.name;
  }
}, ca = class {
  static {
    s(this, "CsfFile");
  }
  _ast;
  _fileName;
  _rawComponentPath;
  _makeTitle;
  _meta;
  _stories = {};
  _metaAnnotations = {};
  _storyExports = {};
  _metaStatement;
  _metaNode;
  _storyStatements = {};
  _storyAnnotations = {};
  _templates = {};
  _namedExportsOrder;
  imports;
  constructor(t, { fileName: r, makeTitle: i }) {
    this._ast = t, this._fileName = r, this.imports = [], this._makeTitle = i;
  }
  _parseTitle(t) {
    let r = j.isIdentifier(t) ? tr(t.name, this._ast.program) : t;
    if (j.isStringLiteral(r))
      return r.value;
    if (j.isTSSatisfiesExpression(r) && j.isStringLiteral(r.expression))
      return r.expression.value;
    throw new Error(As.dedent`
      CSF: unexpected dynamic title ${zc(r, this._fileName)}

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#string-literal-titles
    `);
  }
  _parseMeta(t, r) {
    let i = {};
    t.properties.forEach((n) => {
      if (j.isIdentifier(n.key)) {
        if (this._metaAnnotations[n.key.name] = n.value, n.key.name === "title")
          i.title = this._parseTitle(n.value);
        else if (["includeStories", "excludeStories"].includes(n.key.name))
          i[n.key.name] = SJ(n.value);
        else if (n.key.name === "component") {
          let a = n.value;
          if (j.isIdentifier(a)) {
            let l = a.name, u = r.body.find(
              (c) => j.isImportDeclaration(c) && c.specifiers.find((p) => p.local.name === l)
            );
            if (u) {
              let { source: c } = u;
              j.isStringLiteral(c) && (this._rawComponentPath = c.value);
            }
          }
          let { code: o } = Qc.print(n.value, {});
          i.component = o;
        } else if (n.key.name === "tags") {
          let a = n.value;
          j.isIdentifier(a) && (a = tr(a.name, this._ast.program)), i.tags = y0(a);
        } else if (n.key.name === "id")
          if (j.isStringLiteral(n.value))
            i.id = n.value.value;
          else
            throw new Error(`Unexpected component id: ${n.value}`);
      }
    }), this._meta = i;
  }
  getStoryExport(t) {
    let r = this._storyExports[t];
    if (r = j.isVariableDeclarator(r) ? r.init : r, j.isCallExpression(r)) {
      let { callee: i, arguments: n } = r;
      if (j.isMemberExpression(i) && j.isIdentifier(i.object) && j.isIdentifier(i.property) && i.property.name === "bind" && (n.length === 0 ||
      n.length === 1 && j.isObjectExpression(n[0]) && n[0].properties.length === 0)) {
        let { name: a } = i.object;
        r = this._templates[a];
      }
    }
    return r;
  }
  parse() {
    let t = this;
    if (gJ(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node: i, parent: n }) {
          let a, o = j.isIdentifier(i.declaration) && j.isProgram(n), l;
          if (o) {
            let u = i.declaration.name, c = /* @__PURE__ */ s((p) => j.isIdentifier(p.id) && p.id.name === u, "isVariableDeclarator");
            t._metaStatement = t._ast.program.body.find(
              (p) => j.isVariableDeclaration(p) && p.declarations.find(c)
            ), l = (t?._metaStatement?.declarations || []).find(
              c
            )?.init;
          } else
            t._metaStatement = i, l = i.declaration;
          if (j.isObjectExpression(l) ? a = l : (
            // export default { ... } as Meta<...>
            (j.isTSAsExpression(l) || j.isTSSatisfiesExpression(l)) && j.isObjectExpression(l.expression) && (a = l.expression)
          ), !t._meta && a && j.isProgram(n) && (t._metaNode = a, t._parseMeta(a, n)), t._metaStatement && !t._metaNode)
            throw new vs(
              "default export must be an object",
              t._metaStatement,
              t._fileName
            );
        }
      },
      ExportNamedDeclaration: {
        enter({ node: i, parent: n }) {
          let a;
          j.isVariableDeclaration(i.declaration) ? a = i.declaration.declarations.filter((o) => j.isVariableDeclarator(o)) : j.isFunctionDeclaration(
          i.declaration) && (a = [i.declaration]), a ? a.forEach((o) => {
            if (j.isIdentifier(o.id)) {
              let { name: l } = o.id;
              if (l === "__namedExportsOrder" && j.isVariableDeclarator(o)) {
                t._namedExportsOrder = xJ(o.init);
                return;
              }
              t._storyExports[l] = o, t._storyStatements[l] = i;
              let u = (0, Er.storyNameFromExport)(l);
              t._storyAnnotations[l] ? m0.warn(
                `Unexpected annotations for "${l}" before story declaration`
              ) : t._storyAnnotations[l] = {};
              let c;
              j.isVariableDeclarator(o) ? c = j.isTSAsExpression(o.init) || j.isTSSatisfiesExpression(o.init) ? o.init.expression : o.init :
              c = o;
              let p = {};
              j.isObjectExpression(c) ? (p.__isArgsStory = !0, c.properties.forEach((g) => {
                if (j.isIdentifier(g.key)) {
                  if (g.key.name === "render")
                    p.__isArgsStory = T0(
                      g.value,
                      n,
                      t
                    );
                  else if (g.key.name === "name" && j.isStringLiteral(g.value))
                    u = g.value.value;
                  else if (g.key.name === "storyName" && j.isStringLiteral(g.value))
                    m0.warn(
                      `Unexpected usage of "storyName" in "${l}". Please use "name" instead.`
                    );
                  else if (g.key.name === "parameters" && j.isObjectExpression(g.value)) {
                    let P = g.value.properties.find(
                      (A) => j.isObjectProperty(A) && j.isIdentifier(A.key) && A.key.name === "__id"
                    );
                    P && (p.__id = P.value.value);
                  }
                  t._storyAnnotations[l][g.key.name] = g.value;
                }
              })) : p.__isArgsStory = T0(c, n, t), t._stories[l] = {
                id: "FIXME",
                name: u,
                parameters: p
              };
            }
          }) : i.specifiers.length > 0 && i.specifiers.forEach((o) => {
            if (j.isExportSpecifier(o) && j.isIdentifier(o.exported)) {
              let { name: l } = o.exported;
              if (l === "default") {
                let u, c = j.isProgram(n) ? tr(o.local.name, n) : o.local;
                j.isObjectExpression(c) ? u = c : (
                  // export default { ... } as Meta<...>
                  j.isTSAsExpression(c) && j.isObjectExpression(c.expression) && (u = c.expression)
                ), !t._meta && u && j.isProgram(n) && t._parseMeta(u, n);
              } else
                t._storyAnnotations[l] = {}, t._stories[l] = { id: "FIXME", name: l, parameters: {} };
            }
          });
        }
      },
      ExpressionStatement: {
        enter({ node: i, parent: n }) {
          let { expression: a } = i;
          if (j.isProgram(n) && j.isAssignmentExpression(a) && j.isMemberExpression(a.left) && j.isIdentifier(a.left.object) && j.isIdentifier(
          a.left.property)) {
            let o = a.left.object.name, l = a.left.property.name, u = a.right;
            if (t._storyAnnotations[o] && (l === "story" && j.isObjectExpression(u) ? u.properties.forEach((c) => {
              j.isIdentifier(c.key) && (t._storyAnnotations[o][c.key.name] = c.value);
            }) : t._storyAnnotations[o][l] = u), l === "storyName" && j.isStringLiteral(u)) {
              let c = u.value, p = t._stories[o];
              if (!p) return;
              p.name = c;
            }
          }
        }
      },
      CallExpression: {
        enter({ node: i }) {
          let { callee: n } = i;
          if (j.isIdentifier(n) && n.name === "storiesOf")
            throw new Error(As.dedent`
              Unexpected \`storiesOf\` usage: ${zc(i, t._fileName)}.

              SB8 does not support \`storiesOf\`. 
            `);
        }
      },
      ImportDeclaration: {
        enter({ node: i }) {
          let { source: n } = i;
          if (j.isStringLiteral(n))
            t.imports.push(n.value);
          else
            throw new Error("CSF: unexpected import source");
        }
      }
    }), !t._meta)
      throw new vs("missing default export", t._ast, t._fileName);
    let r = Object.entries(t._stories);
    if (t._meta.title = this._makeTitle(t._meta?.title), t._metaAnnotations.play && (t._meta.tags = [...t._meta.tags || [], "play-fn"]), t._stories =
    r.reduce(
      (i, [n, a]) => {
        if (!(0, Er.isExportStory)(n, t._meta))
          return i;
        let o = a.parameters?.__id ?? (0, Er.toId)(t._meta?.id || t._meta?.title, (0, Er.storyNameFromExport)(n)), l = { ...a.parameters, __id: o },
        { includeStories: u } = t._meta || {};
        n === "__page" && (r.length === 1 || Array.isArray(u) && u.length === 1) && (l.docsOnly = !0), i[n] = { ...a, id: o, parameters: l };
        let { tags: c, play: p } = t._storyAnnotations[n];
        if (c) {
          let g = j.isIdentifier(c) ? tr(c.name, this._ast.program) : c;
          i[n].tags = y0(g);
        }
        return p && (i[n].tags = [...i[n].tags || [], "play-fn"]), i;
      },
      {}
    ), Object.keys(t._storyExports).forEach((i) => {
      (0, Er.isExportStory)(i, t._meta) || (delete t._storyExports[i], delete t._storyAnnotations[i]);
    }), t._namedExportsOrder) {
      let i = Object.keys(t._storyExports);
      t._storyExports = g0(t._storyExports, t._namedExportsOrder), t._stories = g0(t._stories, t._namedExportsOrder);
      let n = Object.keys(t._storyExports);
      if (i.length !== n.length)
        throw new Error(
          `Missing exports after sort: ${i.filter(
            (a) => !n.includes(a)
          )}`
        );
    }
    return t;
  }
  get meta() {
    return this._meta;
  }
  get stories() {
    return Object.values(this._stories);
  }
  get indexInputs() {
    if (!this._fileName)
      throw new Error(
        As.dedent`Cannot automatically create index inputs with CsfFile.indexInputs because the CsfFile instance was created without a the fileName option.
        Either add the fileName option when creating the CsfFile instance, or create the index inputs manually.`
      );
    return Object.entries(this._stories).map(([t, r]) => {
      let i = [...this._meta?.tags ?? [], ...r.tags ?? []];
      return {
        type: "story",
        importPath: this._fileName,
        rawComponentPath: this._rawComponentPath,
        exportName: t,
        name: r.name,
        title: this.meta?.title,
        metaId: this.meta?.id,
        tags: i,
        __id: r.id
      };
    });
  }
}, b0 = /* @__PURE__ */ s((e, t) => {
  let r = xr(e);
  return new ca(r, t);
}, "loadCsf"), EJ = /* @__PURE__ */ s((e, t = { sourceMaps: !1 }, r) => {
  let i = bJ(e._ast, t, r);
  return t.sourceMaps ? i : i.code;
}, "formatCsf"), S0 = /* @__PURE__ */ s((e, t = {}) => Qc.print(e._ast, t), "printCsf"), PJ = /* @__PURE__ */ s(async (e, t) => {
  let r = (await (0, pa.readFile)(e, "utf-8")).toString();
  return b0(r, { ...t, fileName: e });
}, "readCsf"), AJ = /* @__PURE__ */ s(async (e, t) => {
  if (!(t || e._fileName)) throw new Error("Please specify a fileName for writeCsf");
  await (0, pa.writeFile)(t, S0(e).code);
}, "writeCsf");

// src/csf-tools/ConfigFile.ts
var ha = require("node:fs/promises"), P0 = Ge(Ls(), 1), w = Ge(le(), 1), tp = Ge(ii(), 1), rp = Ge(Rr(), 1), A0 = Ge(require("recast"), 1);
var x0 = rp.default.default || rp.default, E0 = tp.default.default || tp.default, Zc = console, ep = /* @__PURE__ */ s(({
  expectedType: e,
  foundType: t,
  node: r
}) => {
  let i = "";
  if (r)
    try {
      i = JSON.stringify(r);
    } catch {
    }
  return P0.dedent`
      CSF Parsing error: Expected '${e}' but found '${t}' instead in '${r?.type}'.
      ${i}
    `;
}, "getCsfParsingErrorMessage"), Cs = /* @__PURE__ */ s((e) => w.isIdentifier(e.key) ? e.key.name : w.isStringLiteral(e.key) ? e.key.value :
null, "propKey"), v0 = /* @__PURE__ */ s((e, t) => {
  if (e.length === 0)
    return t;
  if (w.isObjectExpression(t)) {
    let [r, ...i] = e, n = t.properties.find((a) => Cs(a) === r);
    if (n)
      return v0(i, n.value);
  }
}, "_getPath"), C0 = /* @__PURE__ */ s((e, t) => {
  if (e.length === 0) {
    if (w.isObjectExpression(t))
      return t.properties;
    throw new Error("Expected object expression");
  }
  if (w.isObjectExpression(t)) {
    let [r, ...i] = e, n = t.properties.find((a) => Cs(a) === r);
    if (n)
      return i.length === 0 ? t.properties : C0(i, n.value);
  }
}, "_getPathProperties"), I0 = /* @__PURE__ */ s((e, t) => {
  let r = null, i = null;
  return t.body.find((n) => (w.isVariableDeclaration(n) ? i = n.declarations : w.isExportNamedDeclaration(n) && w.isVariableDeclaration(n.declaration) &&
  (i = n.declaration.declarations), i && i.find((a) => w.isVariableDeclarator(a) && w.isIdentifier(a.id) && a.id.name === e ? (r = a, !0) : !1))),
  r;
}, "_findVarDeclarator"), Ai = /* @__PURE__ */ s((e, t) => I0(e, t)?.init, "_findVarInitialization"), Is = /* @__PURE__ */ s((e, t) => {
  if (e.length === 0) return t;
  let [r, ...i] = e, n = Is(i, t);
  return w.objectExpression([w.objectProperty(w.identifier(r), n)]);
}, "_makeObjectExpression"), ip = /* @__PURE__ */ s((e, t, r) => {
  let [i, ...n] = e, a = r.properties.find(
    (o) => Cs(o) === i
  );
  a ? w.isObjectExpression(a.value) && n.length > 0 ? ip(n, t, a.value) : a.value = Is(n, t) : r.properties.push(
    w.objectProperty(w.identifier(i), Is(n, t))
  );
}, "_updateExportNode"), fa = class {
  static {
    s(this, "ConfigFile");
  }
  _ast;
  _code;
  _exports = {};
  // FIXME: this is a hack. this is only used in the case where the user is
  // modifying a named export that's a scalar. The _exports map is not suitable
  // for that. But rather than refactor the whole thing, we just use this as a stopgap.
  _exportDecls = {};
  _exportsObject;
  _quotes;
  fileName;
  hasDefaultExport = !1;
  constructor(t, r, i) {
    this._ast = t, this._code = r, this.fileName = i;
  }
  parse() {
    let t = this;
    return x0(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node: r, parent: i }) {
          t.hasDefaultExport = !0;
          let n = w.isIdentifier(r.declaration) && w.isProgram(i) ? Ai(r.declaration.name, i) : r.declaration;
          (w.isTSAsExpression(n) || w.isTSSatisfiesExpression(n)) && (n = n.expression), w.isObjectExpression(n) ? (t._exportsObject = n, n.
          properties.forEach((a) => {
            let o = Cs(a);
            if (o) {
              let l = a.value;
              w.isIdentifier(l) && (l = Ai(l.name, i)), t._exports[o] = l;
            }
          })) : Zc.warn(
            ep({
              expectedType: "ObjectExpression",
              foundType: n?.type,
              node: n || r.declaration
            })
          );
        }
      },
      ExportNamedDeclaration: {
        enter({ node: r, parent: i }) {
          w.isVariableDeclaration(r.declaration) ? r.declaration.declarations.forEach((n) => {
            if (w.isVariableDeclarator(n) && w.isIdentifier(n.id)) {
              let { name: a } = n.id, o = n.init;
              w.isIdentifier(o) && (o = Ai(o.name, i)), t._exports[a] = o, t._exportDecls[a] = n;
            }
          }) : r.specifiers ? r.specifiers.forEach((n) => {
            if (w.isExportSpecifier(n) && w.isIdentifier(n.local) && w.isIdentifier(n.exported)) {
              let { name: a } = n.local, { name: o } = n.exported, l = I0(a, i);
              t._exports[o] = l.init, t._exportDecls[o] = l;
            }
          }) : Zc.warn(
            ep({
              expectedType: "VariableDeclaration",
              foundType: r.declaration?.type,
              node: r.declaration
            })
          );
        }
      },
      ExpressionStatement: {
        enter({ node: r, parent: i }) {
          if (w.isAssignmentExpression(r.expression) && r.expression.operator === "=") {
            let { left: n, right: a } = r.expression;
            if (w.isMemberExpression(n) && w.isIdentifier(n.object) && n.object.name === "module" && w.isIdentifier(n.property) && n.property.
            name === "exports") {
              let o = a;
              w.isIdentifier(a) && (o = Ai(a.name, i)), (w.isTSAsExpression(o) || w.isTSSatisfiesExpression(o)) && (o = o.expression), w.isObjectExpression(
              o) ? (t._exportsObject = o, o.properties.forEach((l) => {
                let u = Cs(l);
                if (u) {
                  let c = l.value;
                  w.isIdentifier(c) && (c = Ai(
                    c.name,
                    i
                  )), t._exports[u] = c;
                }
              })) : Zc.warn(
                ep({
                  expectedType: "ObjectExpression",
                  foundType: o?.type,
                  node: o
                })
              );
            }
          }
        }
      }
    }), t;
  }
  getFieldNode(t) {
    let [r, ...i] = t, n = this._exports[r];
    if (n)
      return v0(i, n);
  }
  getFieldProperties(t) {
    let [r, ...i] = t, n = this._exports[r];
    if (n)
      return C0(i, n);
  }
  getFieldValue(t) {
    let r = this.getFieldNode(t);
    if (r) {
      let { code: i } = E0(r, {});
      return (0, eval)(`(() => (${i}))()`);
    }
  }
  getSafeFieldValue(t) {
    try {
      return this.getFieldValue(t);
    } catch {
    }
  }
  setFieldNode(t, r) {
    let [i, ...n] = t, a = this._exports[i];
    if (this._exportsObject)
      ip(t, r, this._exportsObject), this._exports[t[0]] = r;
    else if (a && w.isObjectExpression(a) && n.length > 0)
      ip(n, r, a);
    else if (a && n.length === 0 && this._exportDecls[t[0]]) {
      let o = this._exportDecls[t[0]];
      o.init = Is([], r);
    } else {
      if (this.hasDefaultExport)
        throw new Error(
          `Could not set the "${t.join(
            "."
          )}" field as the default export is not an object in this file.`
        );
      {
        let o = Is(n, r), l = w.exportNamedDeclaration(
          w.variableDeclaration("const", [w.variableDeclarator(w.identifier(i), o)])
        );
        this._exports[i] = o, this._ast.program.body.push(l);
      }
    }
  }
  /**
   * Returns the name of a node in a given path, supporting the following formats:
   * 1. { framework: 'value' }
   * 2. { framework: { name: 'value', options: {} } }
   */
  /**
   * Returns the name of a node in a given path, supporting the following formats:
   * @example
   * // 1. { framework: 'framework-name' }
   * // 2. { framework: { name: 'framework-name', options: {} }
   * getNameFromPath(['framework']) // => 'framework-name'
   */
  getNameFromPath(t) {
    let r = this.getFieldNode(t);
    if (r)
      return this._getPresetValue(r, "name");
  }
  /**
   * Returns an array of names of a node in a given path, supporting the following formats:
   * @example
   * const config = {
   *   addons: [
   *     'first-addon',
   *     { name: 'second-addon', options: {} }
   *   ]
   * }
   * // => ['first-addon', 'second-addon']
   * getNamesFromPath(['addons'])
   *
   */
  getNamesFromPath(t) {
    let r = this.getFieldNode(t);
    if (!r)
      return;
    let i = [];
    return w.isArrayExpression(r) && r.elements.forEach((n) => {
      i.push(this._getPresetValue(n, "name"));
    }), i;
  }
  _getPnpWrappedValue(t) {
    if (w.isCallExpression(t)) {
      let r = t.arguments[0];
      if (w.isStringLiteral(r))
        return r.value;
    }
  }
  /**
   * Given a node and a fallback property, returns a **non-evaluated** string value of the node.
   * 1. { node: 'value' }
   * 2. { node: { fallbackProperty: 'value' } }
   */
  _getPresetValue(t, r) {
    let i;
    if (w.isStringLiteral(t) ? i = t.value : w.isObjectExpression(t) && t.properties.forEach((n) => {
      w.isObjectProperty(n) && w.isIdentifier(n.key) && n.key.name === r && (w.isStringLiteral(n.value) ? i = n.value.value : i = this._getPnpWrappedValue(
      n.value)), w.isObjectProperty(n) && w.isStringLiteral(n.key) && n.key.value === "name" && w.isStringLiteral(n.value) && (i = n.value.value);
    }), !i)
      throw new Error(
        `The given node must be a string literal or an object expression with a "${r}" property that is a string literal.`
      );
    return i;
  }
  removeField(t) {
    let r = /* @__PURE__ */ s((n, a) => {
      let o = n.findIndex(
        (l) => w.isIdentifier(l.key) && l.key.name === a || w.isStringLiteral(l.key) && l.key.value === a
      );
      o >= 0 && n.splice(o, 1);
    }, "removeProperty");
    if (t.length === 1) {
      let n = !1;
      if (this._ast.program.body.forEach((a) => {
        if (w.isExportNamedDeclaration(a) && w.isVariableDeclaration(a.declaration)) {
          let o = a.declaration.declarations[0];
          w.isIdentifier(o.id) && o.id.name === t[0] && (this._ast.program.body.splice(this._ast.program.body.indexOf(a), 1), n = !0);
        }
        if (w.isExportDefaultDeclaration(a)) {
          let o = a.declaration;
          if (w.isIdentifier(o) && (o = Ai(o.name, this._ast.program)), (w.isTSAsExpression(o) || w.isTSSatisfiesExpression(o)) && (o = o.expression),
          w.isObjectExpression(o)) {
            let l = o.properties;
            r(l, t[0]), n = !0;
          }
        }
        if (w.isExpressionStatement(a) && w.isAssignmentExpression(a.expression) && w.isMemberExpression(a.expression.left) && w.isIdentifier(
        a.expression.left.object) && a.expression.left.object.name === "module" && w.isIdentifier(a.expression.left.property) && a.expression.
        left.property.name === "exports" && w.isObjectExpression(a.expression.right)) {
          let o = a.expression.right.properties;
          r(o, t[0]), n = !0;
        }
      }), n) return;
    }
    let i = this.getFieldProperties(t);
    if (i) {
      let n = t.at(-1);
      r(i, n);
    }
  }
  appendValueToArray(t, r) {
    let i = this.valueToNode(r);
    i && this.appendNodeToArray(t, i);
  }
  appendNodeToArray(t, r) {
    let i = this.getFieldNode(t);
    if (!i)
      this.setFieldNode(t, w.arrayExpression([r]));
    else if (w.isArrayExpression(i))
      i.elements.push(r);
    else
      throw new Error(`Expected array at '${t.join(".")}', got '${i.type}'`);
  }
  /**
   * Specialized helper to remove addons or other array entries
   * that can either be strings or objects with a name property.
   */
  removeEntryFromArray(t, r) {
    let i = this.getFieldNode(t);
    if (i)
      if (w.isArrayExpression(i)) {
        let n = i.elements.findIndex((a) => w.isStringLiteral(a) ? a.value === r : w.isObjectExpression(a) ? this._getPresetValue(a, "name") ===
        r : this._getPnpWrappedValue(a) === r);
        if (n >= 0)
          i.elements.splice(n, 1);
        else
          throw new Error(`Could not find '${r}' in array at '${t.join(".")}'`);
      } else
        throw new Error(`Expected array at '${t.join(".")}', got '${i.type}'`);
  }
  _inferQuotes() {
    if (!this._quotes) {
      let t = (this._ast.tokens || []).slice(0, 500).reduce(
        (r, i) => (i.type.label === "string" && (r[this._code[i.start]] += 1), r),
        { "'": 0, '"': 0 }
      );
      this._quotes = t["'"] > t['"'] ? "single" : "double";
    }
    return this._quotes;
  }
  valueToNode(t) {
    let r = this._inferQuotes(), i;
    if (r === "single") {
      let { code: n } = E0(w.valueToNode(t), { jsescOption: { quotes: r } }), a = xr(`const __x = ${n}`);
      x0(a, {
        VariableDeclaration: {
          enter({ node: o }) {
            o.declarations.length === 1 && w.isVariableDeclarator(o.declarations[0]) && w.isIdentifier(o.declarations[0].id) && o.declarations[0].
            id.name === "__x" && (i = o.declarations[0].init);
          }
        }
      });
    } else
      i = w.valueToNode(t);
    return i;
  }
  setFieldValue(t, r) {
    let i = this.valueToNode(r);
    if (!i)
      throw new Error(`Unexpected value ${JSON.stringify(r)}`);
    this.setFieldNode(t, i);
  }
  getBodyDeclarations() {
    return this._ast.program.body;
  }
  setBodyDeclaration(t) {
    this._ast.program.body.push(t);
  }
  /**
   * Import specifiers for a specific require import
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   * @example
   * // const { foo } = require('bar');
   * setRequireImport(['foo'], 'bar');
   *
   * // const foo = require('bar');
   * setRequireImport('foo', 'bar');
   *
   */
  setRequireImport(t, r) {
    let i = this._ast.program.body.find(
      (o) => w.isVariableDeclaration(o) && o.declarations.length === 1 && w.isVariableDeclarator(o.declarations[0]) && w.isCallExpression(o.
      declarations[0].init) && w.isIdentifier(o.declarations[0].init.callee) && o.declarations[0].init.callee.name === "require" && w.isStringLiteral(
      o.declarations[0].init.arguments[0]) && o.declarations[0].init.arguments[0].value === r
    ), n = /* @__PURE__ */ s((o) => w.isObjectPattern(i?.declarations[0].id) && i?.declarations[0].id.properties.find(
      (l) => w.isObjectProperty(l) && w.isIdentifier(l.key) && l.key.name === o
    ), "hasRequireSpecifier"), a = /* @__PURE__ */ s((o, l) => o.declarations.length === 1 && w.isVariableDeclarator(o.declarations[0]) && w.isIdentifier(
    o.declarations[0].id) && o.declarations[0].id.name === l, "hasDefaultRequireSpecifier");
    if (typeof t == "string") {
      let o = /* @__PURE__ */ s(() => {
        this._ast.program.body.unshift(
          w.variableDeclaration("const", [
            w.variableDeclarator(
              w.identifier(t),
              w.callExpression(w.identifier("require"), [w.stringLiteral(r)])
            )
          ])
        );
      }, "addDefaultRequireSpecifier");
      i && a(i, t) || o();
    } else i ? t.forEach((o) => {
      n(o) || i.declarations[0].id.properties.push(
        w.objectProperty(w.identifier(o), w.identifier(o), void 0, !0)
      );
    }) : this._ast.program.body.unshift(
      w.variableDeclaration("const", [
        w.variableDeclarator(
          w.objectPattern(
            t.map(
              (o) => w.objectProperty(w.identifier(o), w.identifier(o), void 0, !0)
            )
          ),
          w.callExpression(w.identifier("require"), [w.stringLiteral(r)])
        )
      ])
    );
  }
  /**
   * Set import specifiers for a given import statement.
   * @description Does not support setting type imports (yet)
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   * @example
   * // import { foo } from 'bar';
   * setImport(['foo'], 'bar');
   *
   * // import foo from 'bar';
   * setImport('foo', 'bar');
   *
   */
  setImport(t, r) {
    let i = /* @__PURE__ */ s((l) => w.importSpecifier(w.identifier(l), w.identifier(l)), "getNewImportSpecifier"), n = /* @__PURE__ */ s((l, u) => l.
    specifiers.find(
      (c) => w.isImportSpecifier(c) && w.isIdentifier(c.imported) && c.imported.name === u
    ), "hasImportSpecifier"), a = /* @__PURE__ */ s((l, u) => l.specifiers.find((c) => w.isImportDefaultSpecifier(c)), "hasDefaultImportSpec\
ifier"), o = this._ast.program.body.find(
      (l) => w.isImportDeclaration(l) && l.source.value === r
    );
    typeof t == "string" ? o ? a(o, t) || o.specifiers.push(
      w.importDefaultSpecifier(w.identifier(t))
    ) : this._ast.program.body.unshift(
      w.importDeclaration(
        [w.importDefaultSpecifier(w.identifier(t))],
        w.stringLiteral(r)
      )
    ) : o ? t.forEach((l) => {
      n(o, l) || o.specifiers.push(i(l));
    }) : this._ast.program.body.unshift(
      w.importDeclaration(
        t.map(
          (l) => w.importSpecifier(w.identifier(l), w.identifier(l))
        ),
        w.stringLiteral(r)
      )
    );
  }
}, w0 = /* @__PURE__ */ s((e, t) => {
  let r = xr(e);
  return new fa(r, e, t);
}, "loadConfig"), O0 = /* @__PURE__ */ s((e) => N0(e).code, "formatConfig"), N0 = /* @__PURE__ */ s((e, t = {}) => A0.print(e._ast, t), "pri\
ntConfig"), vJ = /* @__PURE__ */ s(async (e) => {
  let t = (await (0, ha.readFile)(e, "utf-8")).toString();
  return w0(t, e).parse();
}, "readConfig"), CJ = /* @__PURE__ */ s(async (e, t) => {
  let r = t || e.fileName;
  if (!r) throw new Error("Please specify a fileName for writeConfig");
  await (0, ha.writeFile)(r, O0(e));
}, "writeConfig");

// src/csf-tools/getStorySortParameter.ts
var xe = Ge(le(), 1), sp = Ge(Rr(), 1), np = Ge(ii(), 1), D0 = Ge(Ls(), 1);
var IJ = sp.default.default || sp.default, _0 = np.default.default || np.default, wJ = console, ap = /* @__PURE__ */ s((e, t) => {
  let r;
  return e.properties.forEach((i) => {
    xe.isIdentifier(i.key) && i.key.name === t && (r = i.value);
  }), r;
}, "getValue"), op = /* @__PURE__ */ s((e) => {
  let t = ws(e);
  if (xe.isArrayExpression(t))
    return t.elements.map((r) => op(r));
  if (xe.isObjectExpression(t))
    return t.properties.reduce((r, i) => (xe.isIdentifier(i.key) && (r[i.key.name] = op(i.value)), r), {});
  if (xe.isLiteral(t))
    return t.value;
  if (xe.isIdentifier(t))
    return vi(t.name, !0);
  throw new Error(`Unknown node type ${t.type}`);
}, "parseValue"), vi = /* @__PURE__ */ s((e, t) => {
  let r = D0.dedent`
    Unexpected '${e}'. Parameter 'options.storySort' should be defined inline e.g.:

    export default {
      parameters: {
        options: {
          storySort: <array | object | function>
        },
      },
    };
  `;
  if (t)
    throw new Error(r);
  wJ.info(r);
}, "unsupported"), ws = /* @__PURE__ */ s((e) => xe.isTSAsExpression(e) || xe.isTSSatisfiesExpression(e) ? e.expression : e, "stripTSModifie\
rs"), k0 = /* @__PURE__ */ s((e) => {
  let t = ws(e);
  if (xe.isObjectExpression(t)) {
    let r = ap(t, "options");
    if (r) {
      if (xe.isObjectExpression(r))
        return ap(r, "storySort");
      vi("options", !0);
    }
  }
}, "parseParameters"), OJ = /* @__PURE__ */ s((e, t) => {
  let r = ws(e);
  if (xe.isObjectExpression(r)) {
    let i = ap(r, "parameters");
    if (xe.isIdentifier(i) && (i = tr(i.name, t)), i)
      return k0(i);
  } else
    vi("default", !0);
}, "parseDefault"), NJ = /* @__PURE__ */ s((e) => {
  if (!e.includes("storySort")) return;
  let t, r = xr(e);
  if (IJ(r, {
    ExportNamedDeclaration: {
      enter({ node: i }) {
        xe.isVariableDeclaration(i.declaration) ? i.declaration.declarations.forEach((n) => {
          if (xe.isVariableDeclarator(n) && xe.isIdentifier(n.id)) {
            let { name: a } = n.id;
            if (a === "parameters" && n.init) {
              let o = ws(n.init);
              t = k0(o);
            }
          }
        }) : i.specifiers.forEach((n) => {
          xe.isIdentifier(n.exported) && n.exported.name === "parameters" && vi("parameters", !1);
        });
      }
    },
    ExportDefaultDeclaration: {
      enter({ node: i }) {
        let n = i.declaration;
        xe.isIdentifier(n) && (n = tr(n.name, r.program)), n = ws(n), xe.isObjectExpression(n) ? t = OJ(n, r.program) : vi("default", !1);
      }
    }
  }), !!t) {
    if (xe.isArrowFunctionExpression(t)) {
      let { code: i } = _0(t, {});
      return (0, eval)(i);
    }
    if (xe.isFunctionExpression(t)) {
      let { code: i } = _0(t, {}), n = t.id?.name, a = `(a, b) => {
      ${i};
      return ${n}(a, b)
    }`;
      return (0, eval)(a);
    }
    return xe.isLiteral(t) || xe.isArrayExpression(t) || xe.isObjectExpression(t) ? op(t) : vi("storySort", !0);
  }
}, "getStorySortParameter");

// src/csf-tools/enrichCsf.ts
var ee = Ge(le(), 1), lp = Ge(ii(), 1);
var _J = lp.default.default || lp.default, L0 = /* @__PURE__ */ s((e, t, r, i) => {
  let n = t.getStoryExport(r), a = !i?.disableSource && B0(n), o = !i?.disableDescription && up(t._storyStatements[r]), l = [], u = ee.memberExpression(
  ee.identifier(r), ee.identifier("parameters"));
  l.push(ee.spreadElement(u));
  let c = ee.optionalMemberExpression(
    u,
    ee.identifier("docs"),
    !1,
    !0
  ), p = [];
  if (a) {
    let g = ee.optionalMemberExpression(
      c,
      ee.identifier("source"),
      !1,
      !0
    );
    p.push(
      ee.objectProperty(
        ee.identifier("source"),
        ee.objectExpression([
          ee.objectProperty(ee.identifier("originalSource"), ee.stringLiteral(a)),
          ee.spreadElement(g)
        ])
      )
    );
  }
  if (o) {
    let g = ee.optionalMemberExpression(
      c,
      ee.identifier("description"),
      !1,
      !0
    );
    p.push(
      ee.objectProperty(
        ee.identifier("description"),
        ee.objectExpression([
          ee.objectProperty(ee.identifier("story"), ee.stringLiteral(o)),
          ee.spreadElement(g)
        ])
      )
    );
  }
  if (p.length > 0) {
    l.push(
      ee.objectProperty(
        ee.identifier("docs"),
        ee.objectExpression([ee.spreadElement(c), ...p])
      )
    );
    let g = ee.expressionStatement(
      ee.assignmentExpression("=", u, ee.objectExpression(l))
    );
    e._ast.program.body.push(g);
  }
}, "enrichCsfStory"), M0 = /* @__PURE__ */ s((e, t, r) => {
  if (!t.length) {
    e.properties.find(
      (u) => ee.isObjectProperty(u) && ee.isIdentifier(u.key) && u.key.name === "component"
    ) || e.properties.unshift(r);
    return;
  }
  let [i, ...n] = t, a = e.properties.find(
    (l) => ee.isObjectProperty(l) && ee.isIdentifier(l.key) && l.key.name === i && ee.isObjectExpression(l.value)
  ), o;
  a ? o = a.value : (o = ee.objectExpression([]), e.properties.push(ee.objectProperty(ee.identifier(i), o))), M0(o, n, r);
}, "addComponentDescription"), F0 = /* @__PURE__ */ s((e, t, r) => {
  let i = !r?.disableDescription && up(t._metaStatement);
  if (i) {
    let n = e._metaNode;
    n && ee.isObjectExpression(n) && M0(
      n,
      ["parameters", "docs", "description"],
      ee.objectProperty(ee.identifier("component"), ee.stringLiteral(i))
    );
  }
}, "enrichCsfMeta"), DJ = /* @__PURE__ */ s((e, t, r) => {
  F0(e, t, r), Object.keys(e._storyExports).forEach((i) => {
    L0(e, t, i, r);
  });
}, "enrichCsf"), B0 = /* @__PURE__ */ s((e) => {
  let t = ee.isVariableDeclarator(e) ? e.init : e, { code: r } = _J(t, {});
  return r;
}, "extractSource"), up = /* @__PURE__ */ s((e) => e?.leadingComments ? e.leadingComments.map((r) => r.type === "CommentLine" || !r.value.startsWith(
"*") ? null : r.value.split(`
`).map((i) => i.replace(/^(\s+)?(\*+)?(\s)?/, "")).join(`
`).trim()).filter(Boolean).join(`
`) : "", "extractDescription");
