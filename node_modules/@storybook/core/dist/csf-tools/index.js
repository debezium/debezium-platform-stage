import ESM_COMPAT_Module from "node:module";
import { fileURLToPath as ESM_COMPAT_fileURLToPath } from 'node:url';
import { dirname as ESM_COMPAT_dirname } from 'node:path';
const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
const __dirname = ESM_COMPAT_dirname(__filename);
const require = ESM_COMPAT_Module.createRequire(import.meta.url);
var k0 = Object.create;
var ha = Object.defineProperty;
var L0 = Object.getOwnPropertyDescriptor;
var M0 = Object.getOwnPropertyNames;
var F0 = Object.getPrototypeOf, B0 = Object.prototype.hasOwnProperty;
var s = (e, t) => ha(e, "name", { value: t, configurable: !0 }), Gr = /* @__PURE__ */ ((e) => typeof require < "u" ? require : typeof Proxy <
"u" ? new Proxy(e, {
  get: (t, r) => (typeof require < "u" ? require : t)[r]
}) : e)(function(e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
});
var v = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var j0 = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of M0(t))
      !B0.call(e, n) && n !== r && ha(e, n, { get: () => t[n], enumerable: !(i = L0(t, n)) || i.enumerable });
  return e;
};
var tt = (e, t, r) => (r = e != null ? k0(F0(e)) : {}, j0(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? ha(r, "default", { value: e, enumerable: !0 }) : r,
  e
));

// ../node_modules/ts-dedent/dist/index.js
var Ds = v((wi) => {
  "use strict";
  Object.defineProperty(wi, "__esModule", { value: !0 });
  wi.dedent = void 0;
  function hp(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    var i = Array.from(typeof e == "string" ? [e] : e);
    i[i.length - 1] = i[i.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var n = i.reduce(function(l, u) {
      var c = u.match(/\n([\t ]+|(?!\s).)/g);
      return c ? l.concat(c.map(function(p) {
        var g, P;
        return (P = (g = p.match(/[\t ]/g)) === null || g === void 0 ? void 0 : g.length) !== null && P !== void 0 ? P : 0;
      })) : l;
    }, []);
    if (n.length) {
      var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, n) + "}", "g");
      i = i.map(function(l) {
        return l.replace(a, `
`);
      });
    }
    i[0] = i[0].replace(/^\r?\n/, "");
    var o = i[0];
    return t.forEach(function(l, u) {
      var c = o.match(/(?:^|\n)( *)$/), p = c ? c[1] : "", g = l;
      typeof l == "string" && l.includes(`
`) && (g = String(l).split(`
`).map(function(P, A) {
        return A === 0 ? P : "" + p + P;
      }).join(`
`)), o += g + i[u + 1];
    }), o;
  }
  s(hp, "dedent");
  wi.dedent = hp;
  wi.default = hp;
});

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var ks = v((da) => {
  "use strict";
  Object.defineProperty(da, "__esModule", {
    value: !0
  });
  da.default = R0;
  function R0(e, t) {
    let r = Object.keys(t);
    for (let i of r)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  s(R0, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var Oi = v((ma) => {
  "use strict";
  Object.defineProperty(ma, "__esModule", {
    value: !0
  });
  ma.default = q0;
  var dp = /* @__PURE__ */ new Set();
  function q0(e, t, r = "") {
    if (dp.has(e)) return;
    dp.add(e);
    let {
      internal: i,
      trace: n
    } = V0(1, 2);
    i || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${n}`);
  }
  s(q0, "deprecationWarning");
  function V0(e, t) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: i
    } = Error, n;
    if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(o, l) {
      n = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = i, !n) return {
      internal: !1,
      trace: ""
    };
    let a = n.slice(1 + e, 1 + e + t);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  s(V0, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var We = v((d) => {
  "use strict";
  Object.defineProperty(d, "__esModule", {
    value: !0
  });
  d.isAccessor = tP;
  d.isAnyTypeAnnotation = Eb;
  d.isArgumentPlaceholder = zS;
  d.isArrayExpression = U0;
  d.isArrayPattern = qg;
  d.isArrayTypeAnnotation = Pb;
  d.isArrowFunctionExpression = Vg;
  d.isAssignmentExpression = K0;
  d.isAssignmentPattern = Rg;
  d.isAwaitExpression = cb;
  d.isBigIntLiteral = fb;
  d.isBinary = AE;
  d.isBinaryExpression = W0;
  d.isBindExpression = QS;
  d.isBlock = IE;
  d.isBlockParent = CE;
  d.isBlockStatement = $0;
  d.isBooleanLiteral = mg;
  d.isBooleanLiteralTypeAnnotation = vb;
  d.isBooleanTypeAnnotation = Ab;
  d.isBreakStatement = H0;
  d.isCallExpression = G0;
  d.isCatchClause = z0;
  d.isClass = QE;
  d.isClassAccessorProperty = Tb;
  d.isClassBody = Ug;
  d.isClassDeclaration = Wg;
  d.isClassExpression = Kg;
  d.isClassImplements = Ib;
  d.isClassMethod = rb;
  d.isClassPrivateMethod = bb;
  d.isClassPrivateProperty = gb;
  d.isClassProperty = yb;
  d.isCompletionStatement = NE;
  d.isConditional = _E;
  d.isConditionalExpression = Q0;
  d.isContinueStatement = Z0;
  d.isDebuggerStatement = eg;
  d.isDecimalLiteral = nx;
  d.isDeclaration = qE;
  d.isDeclareClass = wb;
  d.isDeclareExportAllDeclaration = Bb;
  d.isDeclareExportDeclaration = Fb;
  d.isDeclareFunction = Ob;
  d.isDeclareInterface = Nb;
  d.isDeclareModule = _b;
  d.isDeclareModuleExports = Db;
  d.isDeclareOpaqueType = Lb;
  d.isDeclareTypeAlias = kb;
  d.isDeclareVariable = Mb;
  d.isDeclaredPredicate = jb;
  d.isDecorator = ex;
  d.isDirective = X0;
  d.isDirectiveLiteral = J0;
  d.isDoExpression = tx;
  d.isDoWhileStatement = tg;
  d.isEmptyStatement = rg;
  d.isEmptyTypeAnnotation = Hb;
  d.isEnumBody = lP;
  d.isEnumBooleanBody = PS;
  d.isEnumBooleanMember = IS;
  d.isEnumDeclaration = ES;
  d.isEnumDefaultedMember = NS;
  d.isEnumMember = uP;
  d.isEnumNumberBody = AS;
  d.isEnumNumberMember = wS;
  d.isEnumStringBody = vS;
  d.isEnumStringMember = OS;
  d.isEnumSymbolBody = CS;
  d.isExistsTypeAnnotation = Rb;
  d.isExportAllDeclaration = Yg;
  d.isExportDeclaration = ZE;
  d.isExportDefaultDeclaration = Xg;
  d.isExportDefaultSpecifier = rx;
  d.isExportNamedDeclaration = Jg;
  d.isExportNamespaceSpecifier = hb;
  d.isExportSpecifier = $g;
  d.isExpression = PE;
  d.isExpressionStatement = ig;
  d.isExpressionWrapper = LE;
  d.isFile = sg;
  d.isFlow = iP;
  d.isFlowBaseAnnotation = nP;
  d.isFlowDeclaration = aP;
  d.isFlowPredicate = oP;
  d.isFlowType = sP;
  d.isFor = ME;
  d.isForInStatement = ng;
  d.isForOfStatement = Hg;
  d.isForStatement = ag;
  d.isForXStatement = FE;
  d.isFunction = BE;
  d.isFunctionDeclaration = og;
  d.isFunctionExpression = lg;
  d.isFunctionParent = jE;
  d.isFunctionTypeAnnotation = qb;
  d.isFunctionTypeParam = Vb;
  d.isGenericTypeAnnotation = Ub;
  d.isIdentifier = ug;
  d.isIfStatement = cg;
  d.isImmutable = YE;
  d.isImport = pb;
  d.isImportAttribute = ZS;
  d.isImportDeclaration = Gg;
  d.isImportDefaultSpecifier = zg;
  d.isImportExpression = eb;
  d.isImportNamespaceSpecifier = Qg;
  d.isImportOrExportDeclaration = mp;
  d.isImportSpecifier = Zg;
  d.isIndexedAccessType = _S;
  d.isInferredPredicate = Kb;
  d.isInterfaceDeclaration = Yb;
  d.isInterfaceExtends = Wb;
  d.isInterfaceTypeAnnotation = Xb;
  d.isInterpreterDirective = Y0;
  d.isIntersectionTypeAnnotation = Jb;
  d.isJSX = cP;
  d.isJSXAttribute = kS;
  d.isJSXClosingElement = LS;
  d.isJSXClosingFragment = JS;
  d.isJSXElement = MS;
  d.isJSXEmptyExpression = FS;
  d.isJSXExpressionContainer = BS;
  d.isJSXFragment = YS;
  d.isJSXIdentifier = RS;
  d.isJSXMemberExpression = qS;
  d.isJSXNamespacedName = VS;
  d.isJSXOpeningElement = US;
  d.isJSXOpeningFragment = XS;
  d.isJSXSpreadAttribute = KS;
  d.isJSXSpreadChild = jS;
  d.isJSXText = WS;
  d.isLVal = UE;
  d.isLabeledStatement = pg;
  d.isLiteral = WE;
  d.isLogicalExpression = Tg;
  d.isLoop = DE;
  d.isMemberExpression = gg;
  d.isMetaProperty = tb;
  d.isMethod = JE;
  d.isMiscellaneous = pP;
  d.isMixedTypeAnnotation = $b;
  d.isModuleDeclaration = SP;
  d.isModuleExpression = ax;
  d.isModuleSpecifier = eP;
  d.isNewExpression = bg;
  d.isNoop = $S;
  d.isNullLiteral = dg;
  d.isNullLiteralTypeAnnotation = Cb;
  d.isNullableTypeAnnotation = Gb;
  d.isNumberLiteral = yP;
  d.isNumberLiteralTypeAnnotation = zb;
  d.isNumberTypeAnnotation = Qb;
  d.isNumericLiteral = hg;
  d.isObjectExpression = xg;
  d.isObjectMember = $E;
  d.isObjectMethod = Eg;
  d.isObjectPattern = ib;
  d.isObjectProperty = Pg;
  d.isObjectTypeAnnotation = Zb;
  d.isObjectTypeCallProperty = tS;
  d.isObjectTypeIndexer = rS;
  d.isObjectTypeInternalSlot = eS;
  d.isObjectTypeProperty = iS;
  d.isObjectTypeSpreadProperty = sS;
  d.isOpaqueType = nS;
  d.isOptionalCallExpression = mb;
  d.isOptionalIndexedAccessType = DS;
  d.isOptionalMemberExpression = db;
  d.isParenthesizedExpression = Ig;
  d.isPattern = zE;
  d.isPatternLike = VE;
  d.isPipelineBareFunction = ux;
  d.isPipelinePrimaryTopicReference = cx;
  d.isPipelineTopicExpression = lx;
  d.isPlaceholder = HS;
  d.isPrivate = rP;
  d.isPrivateName = Sb;
  d.isProgram = Sg;
  d.isProperty = HE;
  d.isPureish = RE;
  d.isQualifiedTypeIdentifier = aS;
  d.isRecordExpression = ix;
  d.isRegExpLiteral = yg;
  d.isRegexLiteral = TP;
  d.isRestElement = Ag;
  d.isRestProperty = gP;
  d.isReturnStatement = vg;
  d.isScopable = vE;
  d.isSequenceExpression = Cg;
  d.isSpreadElement = sb;
  d.isSpreadProperty = bP;
  d.isStandardized = EE;
  d.isStatement = wE;
  d.isStaticBlock = xb;
  d.isStringLiteral = fg;
  d.isStringLiteralTypeAnnotation = oS;
  d.isStringTypeAnnotation = lS;
  d.isSuper = nb;
  d.isSwitchCase = wg;
  d.isSwitchStatement = Og;
  d.isSymbolTypeAnnotation = uS;
  d.isTSAnyKeyword = Sx;
  d.isTSArrayType = qx;
  d.isTSAsExpression = nE;
  d.isTSBaseType = mP;
  d.isTSBigIntKeyword = Ex;
  d.isTSBooleanKeyword = xx;
  d.isTSCallSignatureDeclaration = mx;
  d.isTSConditionalType = Jx;
  d.isTSConstructSignatureDeclaration = yx;
  d.isTSConstructorType = Mx;
  d.isTSDeclareFunction = fx;
  d.isTSDeclareMethod = hx;
  d.isTSEntityName = KE;
  d.isTSEnumDeclaration = lE;
  d.isTSEnumMember = uE;
  d.isTSExportAssignment = yE;
  d.isTSExpressionWithTypeArguments = eE;
  d.isTSExternalModuleReference = dE;
  d.isTSFunctionType = Lx;
  d.isTSImportEqualsDeclaration = hE;
  d.isTSImportType = fE;
  d.isTSIndexSignature = bx;
  d.isTSIndexedAccessType = zx;
  d.isTSInferType = $x;
  d.isTSInstantiationExpression = sE;
  d.isTSInterfaceBody = rE;
  d.isTSInterfaceDeclaration = tE;
  d.isTSIntersectionType = Xx;
  d.isTSIntrinsicKeyword = Px;
  d.isTSLiteralType = Zx;
  d.isTSMappedType = Qx;
  d.isTSMethodSignature = gx;
  d.isTSModuleBlock = pE;
  d.isTSModuleDeclaration = cE;
  d.isTSNamedTupleMember = Wx;
  d.isTSNamespaceExportDeclaration = TE;
  d.isTSNeverKeyword = Ax;
  d.isTSNonNullExpression = mE;
  d.isTSNullKeyword = vx;
  d.isTSNumberKeyword = Cx;
  d.isTSObjectKeyword = Ix;
  d.isTSOptionalType = Ux;
  d.isTSParameterProperty = px;
  d.isTSParenthesizedType = Hx;
  d.isTSPropertySignature = Tx;
  d.isTSQualifiedName = dx;
  d.isTSRestType = Kx;
  d.isTSSatisfiesExpression = aE;
  d.isTSStringKeyword = wx;
  d.isTSSymbolKeyword = Ox;
  d.isTSThisType = kx;
  d.isTSTupleType = Vx;
  d.isTSType = dP;
  d.isTSTypeAliasDeclaration = iE;
  d.isTSTypeAnnotation = gE;
  d.isTSTypeAssertion = oE;
  d.isTSTypeElement = hP;
  d.isTSTypeLiteral = Rx;
  d.isTSTypeOperator = Gx;
  d.isTSTypeParameter = xE;
  d.isTSTypeParameterDeclaration = SE;
  d.isTSTypeParameterInstantiation = bE;
  d.isTSTypePredicate = Bx;
  d.isTSTypeQuery = jx;
  d.isTSTypeReference = Fx;
  d.isTSUndefinedKeyword = Nx;
  d.isTSUnionType = Yx;
  d.isTSUnknownKeyword = _x;
  d.isTSVoidKeyword = Dx;
  d.isTaggedTemplateExpression = ab;
  d.isTemplateElement = ob;
  d.isTemplateLiteral = lb;
  d.isTerminatorless = OE;
  d.isThisExpression = Ng;
  d.isThisTypeAnnotation = cS;
  d.isThrowStatement = _g;
  d.isTopicReference = ox;
  d.isTryStatement = Dg;
  d.isTupleExpression = sx;
  d.isTupleTypeAnnotation = pS;
  d.isTypeAlias = hS;
  d.isTypeAnnotation = dS;
  d.isTypeCastExpression = mS;
  d.isTypeParameter = yS;
  d.isTypeParameterDeclaration = TS;
  d.isTypeParameterInstantiation = gS;
  d.isTypeScript = fP;
  d.isTypeofTypeAnnotation = fS;
  d.isUnaryExpression = kg;
  d.isUnaryLike = GE;
  d.isUnionTypeAnnotation = bS;
  d.isUpdateExpression = Lg;
  d.isUserWhitespacable = XE;
  d.isV8IntrinsicIdentifier = GS;
  d.isVariableDeclaration = Mg;
  d.isVariableDeclarator = Fg;
  d.isVariance = SS;
  d.isVoidTypeAnnotation = xS;
  d.isWhile = kE;
  d.isWhileStatement = Bg;
  d.isWithStatement = jg;
  d.isYieldExpression = ub;
  var T = ks(), Ni = Oi();
  function U0(e, t) {
    return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(U0, "isArrayExpression");
  function K0(e, t) {
    return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(K0, "isAssignmentExpression");
  function W0(e, t) {
    return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(W0, "isBinaryExpression");
  function Y0(e, t) {
    return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Y0, "isInterpreterDirective");
  function X0(e, t) {
    return !e || e.type !== "Directive" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(X0, "isDirective");
  function J0(e, t) {
    return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(J0, "isDirectiveLiteral");
  function $0(e, t) {
    return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s($0, "isBlockStatement");
  function H0(e, t) {
    return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(H0, "isBreakStatement");
  function G0(e, t) {
    return !e || e.type !== "CallExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(G0, "isCallExpression");
  function z0(e, t) {
    return !e || e.type !== "CatchClause" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(z0, "isCatchClause");
  function Q0(e, t) {
    return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Q0, "isConditionalExpression");
  function Z0(e, t) {
    return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Z0, "isContinueStatement");
  function eg(e, t) {
    return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(eg, "isDebuggerStatement");
  function tg(e, t) {
    return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tg, "isDoWhileStatement");
  function rg(e, t) {
    return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rg, "isEmptyStatement");
  function ig(e, t) {
    return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ig, "isExpressionStatement");
  function sg(e, t) {
    return !e || e.type !== "File" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sg, "isFile");
  function ng(e, t) {
    return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ng, "isForInStatement");
  function ag(e, t) {
    return !e || e.type !== "ForStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ag, "isForStatement");
  function og(e, t) {
    return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(og, "isFunctionDeclaration");
  function lg(e, t) {
    return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lg, "isFunctionExpression");
  function ug(e, t) {
    return !e || e.type !== "Identifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ug, "isIdentifier");
  function cg(e, t) {
    return !e || e.type !== "IfStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cg, "isIfStatement");
  function pg(e, t) {
    return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(pg, "isLabeledStatement");
  function fg(e, t) {
    return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fg, "isStringLiteral");
  function hg(e, t) {
    return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hg, "isNumericLiteral");
  function dg(e, t) {
    return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(dg, "isNullLiteral");
  function mg(e, t) {
    return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mg, "isBooleanLiteral");
  function yg(e, t) {
    return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yg, "isRegExpLiteral");
  function Tg(e, t) {
    return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Tg, "isLogicalExpression");
  function gg(e, t) {
    return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gg, "isMemberExpression");
  function bg(e, t) {
    return !e || e.type !== "NewExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bg, "isNewExpression");
  function Sg(e, t) {
    return !e || e.type !== "Program" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Sg, "isProgram");
  function xg(e, t) {
    return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xg, "isObjectExpression");
  function Eg(e, t) {
    return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Eg, "isObjectMethod");
  function Pg(e, t) {
    return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Pg, "isObjectProperty");
  function Ag(e, t) {
    return !e || e.type !== "RestElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ag, "isRestElement");
  function vg(e, t) {
    return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(vg, "isReturnStatement");
  function Cg(e, t) {
    return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Cg, "isSequenceExpression");
  function Ig(e, t) {
    return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ig, "isParenthesizedExpression");
  function wg(e, t) {
    return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wg, "isSwitchCase");
  function Og(e, t) {
    return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Og, "isSwitchStatement");
  function Ng(e, t) {
    return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ng, "isThisExpression");
  function _g(e, t) {
    return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(_g, "isThrowStatement");
  function Dg(e, t) {
    return !e || e.type !== "TryStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Dg, "isTryStatement");
  function kg(e, t) {
    return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(kg, "isUnaryExpression");
  function Lg(e, t) {
    return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Lg, "isUpdateExpression");
  function Mg(e, t) {
    return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Mg, "isVariableDeclaration");
  function Fg(e, t) {
    return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Fg, "isVariableDeclarator");
  function Bg(e, t) {
    return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Bg, "isWhileStatement");
  function jg(e, t) {
    return !e || e.type !== "WithStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(jg, "isWithStatement");
  function Rg(e, t) {
    return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Rg, "isAssignmentPattern");
  function qg(e, t) {
    return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(qg, "isArrayPattern");
  function Vg(e, t) {
    return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Vg, "isArrowFunctionExpression");
  function Ug(e, t) {
    return !e || e.type !== "ClassBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ug, "isClassBody");
  function Kg(e, t) {
    return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Kg, "isClassExpression");
  function Wg(e, t) {
    return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Wg, "isClassDeclaration");
  function Yg(e, t) {
    return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Yg, "isExportAllDeclaration");
  function Xg(e, t) {
    return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Xg, "isExportDefaultDeclaration");
  function Jg(e, t) {
    return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Jg, "isExportNamedDeclaration");
  function $g(e, t) {
    return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s($g, "isExportSpecifier");
  function Hg(e, t) {
    return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Hg, "isForOfStatement");
  function Gg(e, t) {
    return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Gg, "isImportDeclaration");
  function zg(e, t) {
    return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(zg, "isImportDefaultSpecifier");
  function Qg(e, t) {
    return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Qg, "isImportNamespaceSpecifier");
  function Zg(e, t) {
    return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Zg, "isImportSpecifier");
  function eb(e, t) {
    return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(eb, "isImportExpression");
  function tb(e, t) {
    return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tb, "isMetaProperty");
  function rb(e, t) {
    return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rb, "isClassMethod");
  function ib(e, t) {
    return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ib, "isObjectPattern");
  function sb(e, t) {
    return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sb, "isSpreadElement");
  function nb(e, t) {
    return !e || e.type !== "Super" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(nb, "isSuper");
  function ab(e, t) {
    return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ab, "isTaggedTemplateExpression");
  function ob(e, t) {
    return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ob, "isTemplateElement");
  function lb(e, t) {
    return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lb, "isTemplateLiteral");
  function ub(e, t) {
    return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ub, "isYieldExpression");
  function cb(e, t) {
    return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cb, "isAwaitExpression");
  function pb(e, t) {
    return !e || e.type !== "Import" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(pb, "isImport");
  function fb(e, t) {
    return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fb, "isBigIntLiteral");
  function hb(e, t) {
    return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hb, "isExportNamespaceSpecifier");
  function db(e, t) {
    return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(db, "isOptionalMemberExpression");
  function mb(e, t) {
    return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mb, "isOptionalCallExpression");
  function yb(e, t) {
    return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yb, "isClassProperty");
  function Tb(e, t) {
    return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Tb, "isClassAccessorProperty");
  function gb(e, t) {
    return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gb, "isClassPrivateProperty");
  function bb(e, t) {
    return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bb, "isClassPrivateMethod");
  function Sb(e, t) {
    return !e || e.type !== "PrivateName" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Sb, "isPrivateName");
  function xb(e, t) {
    return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xb, "isStaticBlock");
  function Eb(e, t) {
    return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Eb, "isAnyTypeAnnotation");
  function Pb(e, t) {
    return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Pb, "isArrayTypeAnnotation");
  function Ab(e, t) {
    return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ab, "isBooleanTypeAnnotation");
  function vb(e, t) {
    return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(vb, "isBooleanLiteralTypeAnnotation");
  function Cb(e, t) {
    return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Cb, "isNullLiteralTypeAnnotation");
  function Ib(e, t) {
    return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ib, "isClassImplements");
  function wb(e, t) {
    return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wb, "isDeclareClass");
  function Ob(e, t) {
    return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ob, "isDeclareFunction");
  function Nb(e, t) {
    return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Nb, "isDeclareInterface");
  function _b(e, t) {
    return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(_b, "isDeclareModule");
  function Db(e, t) {
    return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Db, "isDeclareModuleExports");
  function kb(e, t) {
    return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(kb, "isDeclareTypeAlias");
  function Lb(e, t) {
    return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Lb, "isDeclareOpaqueType");
  function Mb(e, t) {
    return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Mb, "isDeclareVariable");
  function Fb(e, t) {
    return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Fb, "isDeclareExportDeclaration");
  function Bb(e, t) {
    return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Bb, "isDeclareExportAllDeclaration");
  function jb(e, t) {
    return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(jb, "isDeclaredPredicate");
  function Rb(e, t) {
    return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Rb, "isExistsTypeAnnotation");
  function qb(e, t) {
    return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(qb, "isFunctionTypeAnnotation");
  function Vb(e, t) {
    return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Vb, "isFunctionTypeParam");
  function Ub(e, t) {
    return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ub, "isGenericTypeAnnotation");
  function Kb(e, t) {
    return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Kb, "isInferredPredicate");
  function Wb(e, t) {
    return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Wb, "isInterfaceExtends");
  function Yb(e, t) {
    return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Yb, "isInterfaceDeclaration");
  function Xb(e, t) {
    return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Xb, "isInterfaceTypeAnnotation");
  function Jb(e, t) {
    return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Jb, "isIntersectionTypeAnnotation");
  function $b(e, t) {
    return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s($b, "isMixedTypeAnnotation");
  function Hb(e, t) {
    return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Hb, "isEmptyTypeAnnotation");
  function Gb(e, t) {
    return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Gb, "isNullableTypeAnnotation");
  function zb(e, t) {
    return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(zb, "isNumberLiteralTypeAnnotation");
  function Qb(e, t) {
    return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Qb, "isNumberTypeAnnotation");
  function Zb(e, t) {
    return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Zb, "isObjectTypeAnnotation");
  function eS(e, t) {
    return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(eS, "isObjectTypeInternalSlot");
  function tS(e, t) {
    return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tS, "isObjectTypeCallProperty");
  function rS(e, t) {
    return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rS, "isObjectTypeIndexer");
  function iS(e, t) {
    return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(iS, "isObjectTypeProperty");
  function sS(e, t) {
    return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sS, "isObjectTypeSpreadProperty");
  function nS(e, t) {
    return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(nS, "isOpaqueType");
  function aS(e, t) {
    return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(aS, "isQualifiedTypeIdentifier");
  function oS(e, t) {
    return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(oS, "isStringLiteralTypeAnnotation");
  function lS(e, t) {
    return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lS, "isStringTypeAnnotation");
  function uS(e, t) {
    return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(uS, "isSymbolTypeAnnotation");
  function cS(e, t) {
    return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cS, "isThisTypeAnnotation");
  function pS(e, t) {
    return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(pS, "isTupleTypeAnnotation");
  function fS(e, t) {
    return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fS, "isTypeofTypeAnnotation");
  function hS(e, t) {
    return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hS, "isTypeAlias");
  function dS(e, t) {
    return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(dS, "isTypeAnnotation");
  function mS(e, t) {
    return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mS, "isTypeCastExpression");
  function yS(e, t) {
    return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yS, "isTypeParameter");
  function TS(e, t) {
    return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(TS, "isTypeParameterDeclaration");
  function gS(e, t) {
    return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gS, "isTypeParameterInstantiation");
  function bS(e, t) {
    return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bS, "isUnionTypeAnnotation");
  function SS(e, t) {
    return !e || e.type !== "Variance" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(SS, "isVariance");
  function xS(e, t) {
    return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xS, "isVoidTypeAnnotation");
  function ES(e, t) {
    return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ES, "isEnumDeclaration");
  function PS(e, t) {
    return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(PS, "isEnumBooleanBody");
  function AS(e, t) {
    return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(AS, "isEnumNumberBody");
  function vS(e, t) {
    return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(vS, "isEnumStringBody");
  function CS(e, t) {
    return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(CS, "isEnumSymbolBody");
  function IS(e, t) {
    return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(IS, "isEnumBooleanMember");
  function wS(e, t) {
    return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wS, "isEnumNumberMember");
  function OS(e, t) {
    return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(OS, "isEnumStringMember");
  function NS(e, t) {
    return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(NS, "isEnumDefaultedMember");
  function _S(e, t) {
    return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(_S, "isIndexedAccessType");
  function DS(e, t) {
    return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(DS, "isOptionalIndexedAccessType");
  function kS(e, t) {
    return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(kS, "isJSXAttribute");
  function LS(e, t) {
    return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(LS, "isJSXClosingElement");
  function MS(e, t) {
    return !e || e.type !== "JSXElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(MS, "isJSXElement");
  function FS(e, t) {
    return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(FS, "isJSXEmptyExpression");
  function BS(e, t) {
    return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(BS, "isJSXExpressionContainer");
  function jS(e, t) {
    return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(jS, "isJSXSpreadChild");
  function RS(e, t) {
    return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(RS, "isJSXIdentifier");
  function qS(e, t) {
    return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(qS, "isJSXMemberExpression");
  function VS(e, t) {
    return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(VS, "isJSXNamespacedName");
  function US(e, t) {
    return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(US, "isJSXOpeningElement");
  function KS(e, t) {
    return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(KS, "isJSXSpreadAttribute");
  function WS(e, t) {
    return !e || e.type !== "JSXText" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(WS, "isJSXText");
  function YS(e, t) {
    return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(YS, "isJSXFragment");
  function XS(e, t) {
    return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(XS, "isJSXOpeningFragment");
  function JS(e, t) {
    return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(JS, "isJSXClosingFragment");
  function $S(e, t) {
    return !e || e.type !== "Noop" ? !1 : t == null || (0, T.default)(e, t);
  }
  s($S, "isNoop");
  function HS(e, t) {
    return !e || e.type !== "Placeholder" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(HS, "isPlaceholder");
  function GS(e, t) {
    return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(GS, "isV8IntrinsicIdentifier");
  function zS(e, t) {
    return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(zS, "isArgumentPlaceholder");
  function QS(e, t) {
    return !e || e.type !== "BindExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(QS, "isBindExpression");
  function ZS(e, t) {
    return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ZS, "isImportAttribute");
  function ex(e, t) {
    return !e || e.type !== "Decorator" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ex, "isDecorator");
  function tx(e, t) {
    return !e || e.type !== "DoExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tx, "isDoExpression");
  function rx(e, t) {
    return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rx, "isExportDefaultSpecifier");
  function ix(e, t) {
    return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ix, "isRecordExpression");
  function sx(e, t) {
    return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sx, "isTupleExpression");
  function nx(e, t) {
    return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(nx, "isDecimalLiteral");
  function ax(e, t) {
    return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ax, "isModuleExpression");
  function ox(e, t) {
    return !e || e.type !== "TopicReference" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ox, "isTopicReference");
  function lx(e, t) {
    return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lx, "isPipelineTopicExpression");
  function ux(e, t) {
    return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(ux, "isPipelineBareFunction");
  function cx(e, t) {
    return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cx, "isPipelinePrimaryTopicReference");
  function px(e, t) {
    return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(px, "isTSParameterProperty");
  function fx(e, t) {
    return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fx, "isTSDeclareFunction");
  function hx(e, t) {
    return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hx, "isTSDeclareMethod");
  function dx(e, t) {
    return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(dx, "isTSQualifiedName");
  function mx(e, t) {
    return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mx, "isTSCallSignatureDeclaration");
  function yx(e, t) {
    return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yx, "isTSConstructSignatureDeclaration");
  function Tx(e, t) {
    return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Tx, "isTSPropertySignature");
  function gx(e, t) {
    return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gx, "isTSMethodSignature");
  function bx(e, t) {
    return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bx, "isTSIndexSignature");
  function Sx(e, t) {
    return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Sx, "isTSAnyKeyword");
  function xx(e, t) {
    return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xx, "isTSBooleanKeyword");
  function Ex(e, t) {
    return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ex, "isTSBigIntKeyword");
  function Px(e, t) {
    return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Px, "isTSIntrinsicKeyword");
  function Ax(e, t) {
    return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ax, "isTSNeverKeyword");
  function vx(e, t) {
    return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(vx, "isTSNullKeyword");
  function Cx(e, t) {
    return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Cx, "isTSNumberKeyword");
  function Ix(e, t) {
    return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ix, "isTSObjectKeyword");
  function wx(e, t) {
    return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(wx, "isTSStringKeyword");
  function Ox(e, t) {
    return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ox, "isTSSymbolKeyword");
  function Nx(e, t) {
    return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Nx, "isTSUndefinedKeyword");
  function _x(e, t) {
    return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(_x, "isTSUnknownKeyword");
  function Dx(e, t) {
    return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Dx, "isTSVoidKeyword");
  function kx(e, t) {
    return !e || e.type !== "TSThisType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(kx, "isTSThisType");
  function Lx(e, t) {
    return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Lx, "isTSFunctionType");
  function Mx(e, t) {
    return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Mx, "isTSConstructorType");
  function Fx(e, t) {
    return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Fx, "isTSTypeReference");
  function Bx(e, t) {
    return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Bx, "isTSTypePredicate");
  function jx(e, t) {
    return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(jx, "isTSTypeQuery");
  function Rx(e, t) {
    return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Rx, "isTSTypeLiteral");
  function qx(e, t) {
    return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(qx, "isTSArrayType");
  function Vx(e, t) {
    return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Vx, "isTSTupleType");
  function Ux(e, t) {
    return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Ux, "isTSOptionalType");
  function Kx(e, t) {
    return !e || e.type !== "TSRestType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Kx, "isTSRestType");
  function Wx(e, t) {
    return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Wx, "isTSNamedTupleMember");
  function Yx(e, t) {
    return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Yx, "isTSUnionType");
  function Xx(e, t) {
    return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Xx, "isTSIntersectionType");
  function Jx(e, t) {
    return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Jx, "isTSConditionalType");
  function $x(e, t) {
    return !e || e.type !== "TSInferType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s($x, "isTSInferType");
  function Hx(e, t) {
    return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Hx, "isTSParenthesizedType");
  function Gx(e, t) {
    return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Gx, "isTSTypeOperator");
  function zx(e, t) {
    return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(zx, "isTSIndexedAccessType");
  function Qx(e, t) {
    return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Qx, "isTSMappedType");
  function Zx(e, t) {
    return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(Zx, "isTSLiteralType");
  function eE(e, t) {
    return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(eE, "isTSExpressionWithTypeArguments");
  function tE(e, t) {
    return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(tE, "isTSInterfaceDeclaration");
  function rE(e, t) {
    return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(rE, "isTSInterfaceBody");
  function iE(e, t) {
    return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(iE, "isTSTypeAliasDeclaration");
  function sE(e, t) {
    return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(sE, "isTSInstantiationExpression");
  function nE(e, t) {
    return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(nE, "isTSAsExpression");
  function aE(e, t) {
    return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(aE, "isTSSatisfiesExpression");
  function oE(e, t) {
    return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(oE, "isTSTypeAssertion");
  function lE(e, t) {
    return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(lE, "isTSEnumDeclaration");
  function uE(e, t) {
    return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(uE, "isTSEnumMember");
  function cE(e, t) {
    return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(cE, "isTSModuleDeclaration");
  function pE(e, t) {
    return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(pE, "isTSModuleBlock");
  function fE(e, t) {
    return !e || e.type !== "TSImportType" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(fE, "isTSImportType");
  function hE(e, t) {
    return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(hE, "isTSImportEqualsDeclaration");
  function dE(e, t) {
    return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(dE, "isTSExternalModuleReference");
  function mE(e, t) {
    return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(mE, "isTSNonNullExpression");
  function yE(e, t) {
    return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yE, "isTSExportAssignment");
  function TE(e, t) {
    return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(TE, "isTSNamespaceExportDeclaration");
  function gE(e, t) {
    return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gE, "isTSTypeAnnotation");
  function bE(e, t) {
    return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bE, "isTSTypeParameterInstantiation");
  function SE(e, t) {
    return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(SE, "isTSTypeParameterDeclaration");
  function xE(e, t) {
    return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(xE, "isTSTypeParameter");
  function EE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(EE, "isStandardized");
  function PE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(PE, "isExpression");
  function AE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(AE, "isBinary");
  function vE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(vE, "isScopable");
  function CE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(CE, "isBlockParent");
  function IE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(IE, "isBlock");
  function wE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(wE, "isStatement");
  function OE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(OE, "isTerminatorless");
  function NE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(NE, "isCompletionStatement");
  function _E(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(_E, "isConditional");
  function DE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(DE, "isLoop");
  function kE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(kE, "isWhile");
  function LE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(LE, "isExpressionWrapper");
  function ME(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(ME, "isFor");
  function FE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(FE, "isForXStatement");
  function BE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(BE, "isFunction");
  function jE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(jE, "isFunctionParent");
  function RE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(RE, "isPureish");
  function qE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (e.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(qE, "isDeclaration");
  function VE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(VE, "isPatternLike");
  function UE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(UE, "isLVal");
  function KE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(KE, "isTSEntityName");
  function WE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(WE, "isLiteral");
  function YE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(YE, "isImmutable");
  function XE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(XE, "isUserWhitespacable");
  function JE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(JE, "isMethod");
  function $E(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s($E, "isObjectMember");
  function HE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(HE, "isProperty");
  function GE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(GE, "isUnaryLike");
  function zE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(zE, "isPattern");
  function QE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(QE, "isClass");
  function mp(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(mp, "isImportOrExportDeclaration");
  function ZE(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(ZE, "isExportDeclaration");
  function eP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(eP, "isModuleSpecifier");
  function tP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(tP, "isAccessor");
  function rP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(rP, "isPrivate");
  function iP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(iP, "isFlow");
  function sP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(sP, "isFlowType");
  function nP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(nP, "isFlowBaseAnnotation");
  function aP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(aP, "isFlowDeclaration");
  function oP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(oP, "isFlowPredicate");
  function lP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(lP, "isEnumBody");
  function uP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(uP, "isEnumMember");
  function cP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(cP, "isJSX");
  function pP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(pP, "isMiscellaneous");
  function fP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(fP, "isTypeScript");
  function hP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(hP, "isTSTypeElement");
  function dP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(dP, "isTSType");
  function mP(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return t == null || (0, T.default)(e, t);
  }
  s(mP, "isTSBaseType");
  function yP(e, t) {
    return (0, Ni.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(yP, "isNumberLiteral");
  function TP(e, t) {
    return (0, Ni.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(TP, "isRegexLiteral");
  function gP(e, t) {
    return (0, Ni.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(gP, "isRestProperty");
  function bP(e, t) {
    return (0, Ni.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, T.default)(e, t);
  }
  s(bP, "isSpreadProperty");
  function SP(e, t) {
    return (0, Ni.default)("isModuleDeclaration", "isImportOrExportDeclaration"), mp(e, t);
  }
  s(SP, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var Ta = v((ya) => {
  "use strict";
  Object.defineProperty(ya, "__esModule", {
    value: !0
  });
  ya.default = xP;
  var _i = We();
  function xP(e, t, r) {
    if (!(0, _i.isMemberExpression)(e)) return !1;
    let i = Array.isArray(t) ? t : t.split("."), n = [], a;
    for (a = e; (0, _i.isMemberExpression)(a); a = a.object)
      n.push(a.property);
    if (n.push(a), n.length < i.length || !r && n.length > i.length) return !1;
    for (let o = 0, l = n.length - 1; o < i.length; o++, l--) {
      let u = n[l], c;
      if ((0, _i.isIdentifier)(u))
        c = u.name;
      else if ((0, _i.isStringLiteral)(u))
        c = u.value;
      else if ((0, _i.isThisExpression)(u))
        c = "this";
      else
        return !1;
      if (i[o] !== c) return !1;
    }
    return !0;
  }
  s(xP, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var ba = v((ga) => {
  "use strict";
  Object.defineProperty(ga, "__esModule", {
    value: !0
  });
  ga.default = PP;
  var EP = Ta();
  function PP(e, t) {
    let r = e.split(".");
    return (i) => (0, EP.default)(i, r, t);
  }
  s(PP, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var yp = v((Ls) => {
  "use strict";
  Object.defineProperty(Ls, "__esModule", {
    value: !0
  });
  Ls.default = void 0;
  var AP = ba(), vP = (0, AP.default)("React.Component"), qJ = Ls.default = vP;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var Tp = v((Sa) => {
  "use strict";
  Object.defineProperty(Sa, "__esModule", {
    value: !0
  });
  Sa.default = CP;
  function CP(e) {
    return !!e && /^[a-z]/.test(e);
  }
  s(CP, "isCompatTag");
});

// ../node_modules/to-fast-properties/index.js
var bp = v((WJ, gp) => {
  "use strict";
  var Di = null;
  function ki(e) {
    if (Di !== null && typeof Di.property) {
      let t = Di;
      return Di = ki.prototype = null, t;
    }
    return Di = ki.prototype = e ?? /* @__PURE__ */ Object.create(null), new ki();
  }
  s(ki, "FastObject");
  ki();
  gp.exports = /* @__PURE__ */ s(function(t) {
    return ki(t);
  }, "toFastproperties");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var Ms = v((xa) => {
  "use strict";
  Object.defineProperty(xa, "__esModule", {
    value: !0
  });
  xa.default = IP;
  var Sp = Et();
  function IP(e, t) {
    if (e === t) return !0;
    if (e == null || Sp.ALIAS_KEYS[t]) return !1;
    let r = Sp.FLIPPED_ALIAS_KEYS[t];
    if (r) {
      if (r[0] === e) return !0;
      for (let i of r)
        if (e === i) return !0;
    }
    return !1;
  }
  s(IP, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var Pa = v((Ea) => {
  "use strict";
  Object.defineProperty(Ea, "__esModule", {
    value: !0
  });
  Ea.default = OP;
  var wP = Et();
  function OP(e, t) {
    if (e === t) return !0;
    let r = wP.PLACEHOLDERS_ALIAS[e];
    if (r) {
      for (let i of r)
        if (t === i) return !0;
    }
    return !1;
  }
  s(OP, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var zr = v((Aa) => {
  "use strict";
  Object.defineProperty(Aa, "__esModule", {
    value: !0
  });
  Aa.default = LP;
  var NP = ks(), _P = Ms(), DP = Pa(), kP = Et();
  function LP(e, t, r) {
    return t ? (0, _P.default)(t.type, e) ? typeof r > "u" ? !0 : (0, NP.default)(t, r) : !r && t.type === "Placeholder" && e in kP.FLIPPED_ALIAS_KEYS ?
    (0, DP.default)(t.expectedNode, e) : !1 : !1;
  }
  s(LP, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var vp = v((Li) => {
  "use strict";
  Object.defineProperty(Li, "__esModule", {
    value: !0
  });
  Li.isIdentifierChar = Ap;
  Li.isIdentifierName = jP;
  Li.isIdentifierStart = Pp;
  var Ca = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  xp = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", MP = new RegExp("[" + Ca + "]"), FP = new RegExp("[" + Ca + xp + "]");
  Ca = xp = null;
  var Ep = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], BP = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2,
  5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6,
  1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function va(e, t) {
    let r = 65536;
    for (let i = 0, n = t.length; i < n; i += 2) {
      if (r += t[i], r > e) return !1;
      if (r += t[i + 1], r >= e) return !0;
    }
    return !1;
  }
  s(va, "isInAstralSet");
  function Pp(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && MP.test(String.fromCharCode(e)) :
    va(e, Ep);
  }
  s(Pp, "isIdentifierStart");
  function Ap(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && FP.test(
    String.fromCharCode(e)) : va(e, Ep) || va(e, BP);
  }
  s(Ap, "isIdentifierChar");
  function jP(e) {
    let t = !0;
    for (let r = 0; r < e.length; r++) {
      let i = e.charCodeAt(r);
      if ((i & 64512) === 55296 && r + 1 < e.length) {
        let n = e.charCodeAt(++r);
        (n & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (n & 1023));
      }
      if (t) {
        if (t = !1, !Pp(i))
          return !1;
      } else if (!Ap(i))
        return !1;
    }
    return !t;
  }
  s(jP, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var Op = v((Ir) => {
  "use strict";
  Object.defineProperty(Ir, "__esModule", {
    value: !0
  });
  Ir.isKeyword = KP;
  Ir.isReservedWord = Cp;
  Ir.isStrictBindOnlyReservedWord = wp;
  Ir.isStrictBindReservedWord = UP;
  Ir.isStrictReservedWord = Ip;
  var Ia = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, RP = new Set(Ia.keyword), qP = new Set(Ia.strict), VP = new Set(Ia.strictBind);
  function Cp(e, t) {
    return t && e === "await" || e === "enum";
  }
  s(Cp, "isReservedWord");
  function Ip(e, t) {
    return Cp(e, t) || qP.has(e);
  }
  s(Ip, "isStrictReservedWord");
  function wp(e) {
    return VP.has(e);
  }
  s(wp, "isStrictBindOnlyReservedWord");
  function UP(e, t) {
    return Ip(e, t) || wp(e);
  }
  s(UP, "isStrictBindReservedWord");
  function KP(e) {
    return RP.has(e);
  }
  s(KP, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var Fi = v((Bt) => {
  "use strict";
  Object.defineProperty(Bt, "__esModule", {
    value: !0
  });
  Object.defineProperty(Bt, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return wa.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(Bt, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return wa.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(Bt, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return wa.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(Bt, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Mi.isKeyword;
    }, "get")
  });
  Object.defineProperty(Bt, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Mi.isReservedWord;
    }, "get")
  });
  Object.defineProperty(Bt, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Mi.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(Bt, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Mi.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(Bt, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Mi.isStrictReservedWord;
    }, "get")
  });
  var wa = vp(), Mi = Op();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var Qr = v((Na) => {
  "use strict";
  Object.defineProperty(Na, "__esModule", {
    value: !0
  });
  Na.default = WP;
  var Oa = Fi();
  function WP(e, t = !0) {
    return typeof e != "string" || t && ((0, Oa.isKeyword)(e) || (0, Oa.isStrictReservedWord)(e, !0)) ? !1 : (0, Oa.isIdentifierName)(e);
  }
  s(WP, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var kp = v((Bi) => {
  "use strict";
  Object.defineProperty(Bi, "__esModule", {
    value: !0
  });
  Bi.readCodePoint = Dp;
  Bi.readInt = _p;
  Bi.readStringContents = XP;
  var YP = /* @__PURE__ */ s(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), Np = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Fs = {
    bin: /* @__PURE__ */ s((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ s((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ s((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ s((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function XP(e, t, r, i, n, a) {
    let o = r, l = i, u = n, c = "", p = null, g = r, {
      length: P
    } = t;
    for (; ; ) {
      if (r >= P) {
        a.unterminated(o, l, u), c += t.slice(g, r);
        break;
      }
      let A = t.charCodeAt(r);
      if (JP(e, A, t, r)) {
        c += t.slice(g, r);
        break;
      }
      if (A === 92) {
        c += t.slice(g, r);
        let C = $P(t, r, i, n, e === "template", a);
        C.ch === null && !p ? p = {
          pos: r,
          lineStart: i,
          curLine: n
        } : c += C.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = C, g = r;
      } else A === 8232 || A === 8233 ? (++r, ++n, i = r) : A === 10 || A === 13 ? e === "template" ? (c += t.slice(g, r) + `
`, ++r, A === 13 && t.charCodeAt(r) === 10 && ++r, ++n, g = i = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: n,
      containsInvalid: !!p
    };
  }
  s(XP, "readStringContents");
  function JP(e, t, r, i) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  s(JP, "isStringEnd");
  function $P(e, t, r, i, n, a) {
    let o = !n;
    t++;
    let l = /* @__PURE__ */ s((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: i
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = _a(e, t, r, i, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = Dp(e, t, r, i, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(t - 1, r, i);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, g = e.slice(c, t + 2).match(/^[0-7]+/)[0], P = parseInt(g, 8);
          P > 255 && (g = g.slice(0, -1), P = parseInt(g, 8)), t += g.length - 1;
          let A = e.charCodeAt(t);
          if (g !== "0" || A === 56 || A === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(c, r, i);
          }
          return l(String.fromCharCode(P));
        }
        return l(String.fromCharCode(u));
    }
  }
  s($P, "readEscapedChar");
  function _a(e, t, r, i, n, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = _p(e, t, r, i, 16, n, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, i) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  s(_a, "readHexChar");
  function _p(e, t, r, i, n, a, o, l, u, c) {
    let p = t, g = n === 16 ? Np.hex : Np.decBinOct, P = n === 16 ? Fs.hex : n === 10 ? Fs.dec : n === 8 ? Fs.oct : Fs.bin, A = !1, C = 0;
    for (let _ = 0, k = a ?? 1 / 0; _ < k; ++_) {
      let O = e.charCodeAt(t), M;
      if (O === 95 && l !== "bail") {
        let F = e.charCodeAt(t - 1), G = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(G) || !P(G) || g.has(F) || g.has(G)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, i);
        }
        ++t;
        continue;
      }
      if (O >= 97 ? M = O - 97 + 10 : O >= 65 ? M = O - 65 + 10 : YP(O) ? M = O - 48 : M = 1 / 0, M >= n) {
        if (M <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (M <= 9 && u.invalidDigit(t, r, i, n))
          M = 0;
        else if (o)
          M = 0, A = !0;
        else
          break;
      }
      ++t, C = C * n + M;
    }
    return t === p || a != null && t - p !== a || A ? {
      n: null,
      pos: t
    } : {
      n: C,
      pos: t
    };
  }
  s(_p, "readInt");
  function Dp(e, t, r, i, n, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = _a(e, t, r, i, e.indexOf("}", t) - t, !0, n, a), ++t, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(t, r, i);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = _a(e, t, r, i, 4, !1, n, a));
    return {
      code: l,
      pos: t
    };
  }
  s(Dp, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var ir = v((pe) => {
  "use strict";
  Object.defineProperty(pe, "__esModule", {
    value: !0
  });
  pe.UPDATE_OPERATORS = pe.UNARY_OPERATORS = pe.STRING_UNARY_OPERATORS = pe.STATEMENT_OR_BLOCK_KEYS = pe.NUMBER_UNARY_OPERATORS = pe.NUMBER_BINARY_OPERATORS =
  pe.NOT_LOCAL_BINDING = pe.LOGICAL_OPERATORS = pe.INHERIT_KEYS = pe.FOR_INIT_KEYS = pe.FLATTENABLE_KEYS = pe.EQUALITY_BINARY_OPERATORS = pe.
  COMPARISON_BINARY_OPERATORS = pe.COMMENT_KEYS = pe.BOOLEAN_UNARY_OPERATORS = pe.BOOLEAN_NUMBER_BINARY_OPERATORS = pe.BOOLEAN_BINARY_OPERATORS =
  pe.BLOCK_SCOPED_SYMBOL = pe.BINARY_OPERATORS = pe.ASSIGNMENT_OPERATORS = void 0;
  var l$ = pe.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], u$ = pe.FLATTENABLE_KEYS = ["body", "expressions"], c$ = pe.FOR_INIT_KEYS =
  ["left", "init"], p$ = pe.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], HP = pe.LOGICAL_OPERATORS = ["||", "&&",
  "??"], f$ = pe.UPDATE_OPERATORS = ["++", "--"], GP = pe.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], zP = pe.EQUALITY_BINARY_OPERATORS =
  ["==", "===", "!=", "!=="], QP = pe.COMPARISON_BINARY_OPERATORS = [...zP, "in", "instanceof"], ZP = pe.BOOLEAN_BINARY_OPERATORS = [...QP, ...GP],
  Lp = pe.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], h$ = pe.BINARY_OPERATORS = ["+", ...Lp, ...ZP,
  "|>"], d$ = pe.ASSIGNMENT_OPERATORS = ["=", "+=", ...Lp.map((e) => e + "="), ...HP.map((e) => e + "=")], eA = pe.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], tA = pe.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], rA = pe.STRING_UNARY_OPERATORS = ["typeof"], m$ = pe.UNARY_OPERATORS = [
  "void", "throw", ...eA, ...tA, ...rA], y$ = pe.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, T$ = pe.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), g$ = pe.NOT_LOCAL_BINDING = Symbol.for("should not be consider\
ed a local binding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var Ut = v((ge) => {
  "use strict";
  Object.defineProperty(ge, "__esModule", {
    value: !0
  });
  ge.VISITOR_KEYS = ge.NODE_PARENT_VALIDATIONS = ge.NODE_FIELDS = ge.FLIPPED_ALIAS_KEYS = ge.DEPRECATED_KEYS = ge.BUILDER_KEYS = ge.ALIAS_KEYS =
  void 0;
  ge.arrayOf = Fp;
  ge.arrayOfType = Bp;
  ge.assertEach = jp;
  ge.assertNodeOrValueType = dA;
  ge.assertNodeType = ka;
  ge.assertOneOf = hA;
  ge.assertOptionalChainStart = yA;
  ge.assertShape = mA;
  ge.assertValueType = Fa;
  ge.chain = Rp;
  ge.default = qp;
  ge.defineAliasedType = bA;
  ge.typeIs = Rs;
  ge.validate = Ma;
  ge.validateArrayOfType = fA;
  ge.validateOptional = cA;
  ge.validateOptionalType = pA;
  ge.validateType = uA;
  var Mp = zr(), js = qs(), iA = ge.VISITOR_KEYS = {}, sA = ge.ALIAS_KEYS = {}, Da = ge.FLIPPED_ALIAS_KEYS = {}, nA = ge.NODE_FIELDS = {}, aA = ge.
  BUILDER_KEYS = {}, oA = ge.DEPRECATED_KEYS = {}, lA = ge.NODE_PARENT_VALIDATIONS = {};
  function Bs(e) {
    return Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
  }
  s(Bs, "getType");
  function Ma(e) {
    return {
      validate: e
    };
  }
  s(Ma, "validate");
  function Rs(e) {
    return typeof e == "string" ? ka(e) : ka(...e);
  }
  s(Rs, "typeIs");
  function uA(e) {
    return Ma(Rs(e));
  }
  s(uA, "validateType");
  function cA(e) {
    return {
      validate: e,
      optional: !0
    };
  }
  s(cA, "validateOptional");
  function pA(e) {
    return {
      validate: Rs(e),
      optional: !0
    };
  }
  s(pA, "validateOptionalType");
  function Fp(e) {
    return Rp(Fa("array"), jp(e));
  }
  s(Fp, "arrayOf");
  function Bp(e) {
    return Fp(Rs(e));
  }
  s(Bp, "arrayOfType");
  function fA(e) {
    return Ma(Bp(e));
  }
  s(fA, "validateArrayOfType");
  function jp(e) {
    function t(r, i, n) {
      if (Array.isArray(n))
        for (let a = 0; a < n.length; a++) {
          let o = `${i}[${a}]`, l = n[a];
          e(r, o, l), process.env.BABEL_TYPES_8_BREAKING && (0, js.validateChild)(r, o, l);
        }
    }
    return s(t, "validator"), t.each = e, t;
  }
  s(jp, "assertEach");
  function hA(...e) {
    function t(r, i, n) {
      if (e.indexOf(n) < 0)
        throw new TypeError(`Property ${i} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(n)}`);
    }
    return s(t, "validate"), t.oneOf = e, t;
  }
  s(hA, "assertOneOf");
  function ka(...e) {
    function t(r, i, n) {
      for (let a of e)
        if ((0, Mp.default)(a, n)) {
          (0, js.validateChild)(r, i, n);
          return;
        }
      throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return s(t, "validate"), t.oneOfNodeTypes = e, t;
  }
  s(ka, "assertNodeType");
  function dA(...e) {
    function t(r, i, n) {
      for (let a of e)
        if (Bs(n) === a || (0, Mp.default)(a, n)) {
          (0, js.validateChild)(r, i, n);
          return;
        }
      throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return s(t, "validate"), t.oneOfNodeOrValueTypes = e, t;
  }
  s(dA, "assertNodeOrValueType");
  function Fa(e) {
    function t(r, i, n) {
      if (!(Bs(n) === e))
        throw new TypeError(`Property ${i} expected type of ${e} but got ${Bs(n)}`);
    }
    return s(t, "validate"), t.type = e, t;
  }
  s(Fa, "assertValueType");
  function mA(e) {
    function t(r, i, n) {
      let a = [];
      for (let o of Object.keys(e))
        try {
          (0, js.validateField)(r, o, n[o], e[o]);
        } catch (l) {
          if (l instanceof TypeError) {
            a.push(l.message);
            continue;
          }
          throw l;
        }
      if (a.length)
        throw new TypeError(`Property ${i} of ${r.type} expected to have the following:
${a.join(`
`)}`);
    }
    return s(t, "validate"), t.shapeOf = e, t;
  }
  s(mA, "assertShape");
  function yA() {
    function e(t) {
      var r;
      let i = t;
      for (; t; ) {
        let {
          type: n
        } = i;
        if (n === "OptionalCallExpression") {
          if (i.optional) return;
          i = i.callee;
          continue;
        }
        if (n === "OptionalMemberExpression") {
          if (i.optional) return;
          i = i.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = i) == null ? void 0 : r.type}`);
    }
    return s(e, "validate"), e;
  }
  s(yA, "assertOptionalChainStart");
  function Rp(...e) {
    function t(...r) {
      for (let i of e)
        i(...r);
    }
    if (s(t, "validate"), t.chainOf = e, e.length >= 2 && "type" in e[0] && e[0].type === "array" && !("each" in e[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return t;
  }
  s(Rp, "chain");
  var TA = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], gA = ["default", "optional", "deprecated",
  "validate"], La = {};
  function bA(...e) {
    return (t, r = {}) => {
      let i = r.aliases;
      if (!i) {
        var n, a;
        r.inherits && (i = (n = La[r.inherits].aliases) == null ? void 0 : n.slice()), (a = i) != null || (i = []), r.aliases = i;
      }
      let o = e.filter((l) => !i.includes(l));
      i.unshift(...o), qp(t, r);
    };
  }
  s(bA, "defineAliasedType");
  function qp(e, t = {}) {
    let r = t.inherits && La[t.inherits] || {}, i = t.fields;
    if (!i && (i = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let c = r.fields[u], p = c.default;
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        i[u] = {
          default: Array.isArray(p) ? [] : p,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let n = t.visitor || r.visitor || [], a = t.aliases || r.aliases || [], o = t.builder || r.builder || t.visitor || [];
    for (let l of Object.keys(t))
      if (TA.indexOf(l) === -1)
        throw new Error(`Unknown type option "${l}" on ${e}`);
    t.deprecatedAlias && (oA[t.deprecatedAlias] = e);
    for (let l of n.concat(o))
      i[l] = i[l] || {};
    for (let l of Object.keys(i)) {
      let u = i[l];
      u.default !== void 0 && o.indexOf(l) === -1 && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default !=
      null && (u.validate = Fa(Bs(u.default)));
      for (let c of Object.keys(u))
        if (gA.indexOf(c) === -1)
          throw new Error(`Unknown field key "${c}" on ${e}.${l}`);
    }
    iA[e] = t.visitor = n, aA[e] = t.builder = o, nA[e] = t.fields = i, sA[e] = t.aliases = a, a.forEach((l) => {
      Da[l] = Da[l] || [], Da[l].push(e);
    }), t.validate && (lA[e] = t.validate), La[e] = t;
  }
  s(qp, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var ja = v((yt) => {
  "use strict";
  Object.defineProperty(yt, "__esModule", {
    value: !0
  });
  yt.patternLikeCommon = yt.functionTypeAnnotationCommon = yt.functionDeclarationCommon = yt.functionCommon = yt.classMethodOrPropertyCommon =
  yt.classMethodOrDeclareMethodCommon = void 0;
  var at = zr(), SA = Qr(), Vp = Fi(), xA = kp(), ji = ir(), f = Ut(), q = (0, f.defineAliasedType)("Standardized");
  q("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeOrValueType)("null", "Expression", "Spread\
Element"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  q("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, f.assertValueType)("string");
          let e = (0, f.assertOneOf)(...ji.ASSIGNMENT_OPERATORS), t = (0, f.assertOneOf)("=");
          return function(r, i, n) {
            ((0, at.default)("Pattern", r.left) ? t : e)(r, i, n);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, f.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  q("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, f.assertOneOf)(...ji.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let e = (0, f.assertNodeType)("Expression"), t = (0, f.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(i, n, a) {
            (i.operator === "in" ? t : e)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  q("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("string")
      }
    }
  });
  q("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, f.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  q("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("string")
      }
    }
  });
  q("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  q("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  q("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, f.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, f.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  q("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, f.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  q("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, f.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, f.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  q("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  q("DebuggerStatement", {
    aliases: ["Statement"]
  });
  q("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  q("EmptyStatement", {
    aliases: ["Statement"]
  });
  q("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, f.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  q("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, f.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertEach)((0, f.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, f.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  q("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, f.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, f.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  var Zr = /* @__PURE__ */ s(() => ({
    params: {
      validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  yt.functionCommon = Zr;
  var wr = /* @__PURE__ */ s(() => ({
    returnType: {
      validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, f.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  yt.functionTypeAnnotationCommon = wr;
  var Up = /* @__PURE__ */ s(() => Object.assign({}, Zr(), {
    declare: {
      validate: (0, f.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, f.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  yt.functionDeclarationCommon = Up;
  q("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, Up(), wr(), {
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, f.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
      };
      let e = (0, f.assertNodeType)("Identifier");
      return function(t, r, i) {
        (0, at.default)("ExportDefaultDeclaration", t) || e(i, "id", i.id);
      };
    }()
  });
  q("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Zr(), wr(), {
      id: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, f.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var ei = /* @__PURE__ */ s(() => ({
    typeAnnotation: {
      validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, f.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "patternLikeCommon");
  yt.patternLikeCommon = ei;
  q("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, ei(), {
      name: {
        validate: (0, f.chain)((0, f.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, SA.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(e, t, r) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let i = /\.(\w+)$/.exec(t);
      if (!i) return;
      let [, n] = i, a = {
        computed: !1
      };
      if (n === "property") {
        if ((0, at.default)("MemberExpression", e, a) || (0, at.default)("OptionalMemberExpression", e, a)) return;
      } else if (n === "key") {
        if ((0, at.default)("Property", e, a) || (0, at.default)("Method", e, a)) return;
      } else if (n === "exported") {
        if ((0, at.default)("ExportSpecifier", e)) return;
      } else if (n === "imported") {
        if ((0, at.default)("ImportSpecifier", e, {
          imported: r
        })) return;
      } else if (n === "meta" && (0, at.default)("MetaProperty", e, {
        meta: r
      }))
        return;
      if (((0, Vp.isKeyword)(r.name) || (0, Vp.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    }
  });
  q("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, f.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, f.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, f.chain)((0, f.assertValueType)("number"), Object.assign(function(e, t, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let i = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, f.assertValueType)("string")
      },
      flags: {
        validate: (0, f.chain)((0, f.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let i = /[^gimsuy]/.exec(r);
          if (i)
            throw new TypeError(`"${i[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  q("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, f.assertOneOf)(...ji.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, f.assertNodeType)("Expression")
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, f.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let e = (0, f.assertNodeType)("Identifier", "PrivateName"), t = (0, f.assertNodeType)("Expression"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, f.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  });
  q("NewExpression", {
    inherits: "CallExpression"
  });
  q("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, f.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, f.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  q("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ObjectMethod", "ObjectProperty", "S\
preadElement")))
      }
    }
  });
  q("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, Zr(), wr(), {
      kind: Object.assign({
        validate: (0, f.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, f.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ s(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  q("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t = (0, f.
          assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, f.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, f.chain)((0, f.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !(0, at.default)("Identifier", e.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      let e = (0, f.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), t = (0, f.assertNodeType)("Expression");
      return function(r, i, n) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, at.default)("ObjectPattern", r) ? e : t)(n, "value", n.value);
      };
    }()
  });
  q("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, ei(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, f.assertNodeType)("LVal")
      }
    }),
    validate(e, t) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let r = /(\w+)\[(\d+)\]/.exec(t);
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, i, n] = r;
      if (e[i].length > +n + 1)
        throw new TypeError(`RestElement must be last element of ${i}`);
    }
  });
  q("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  q("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  q("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Statement")))
      }
    }
  });
  q("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, f.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("SwitchCase")))
      }
    }
  });
  q("ThisExpression", {
    aliases: ["Expression"]
  });
  q("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, f.chain)((0, f.assertNodeType)("BlockStatement"), Object.assign(function(e) {
          if (process.env.BABEL_TYPES_8_BREAKING && !e.handler && !e.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, f.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    }
  });
  q("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, f.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, f.assertOneOf)(...ji.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  q("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "MemberExpression") : (0, f.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, f.assertOneOf)(...ji.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  q("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, f.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(e, t, r) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, at.default)("ForXStatement", e, {
        left: r
      }) && r.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`);
    }
  });
  q("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, f.assertNodeType)("LVal");
          let e = (0, f.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), t = (0, f.assertNodeType)("Identifier");
          return function(r, i, n) {
            (r.init ? e : t)(r, i, n);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, f.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      }
    }
  });
  q("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, ei(), {
      left: {
        validate: (0, f.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  });
  q("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, ei(), {
      elements: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  q("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Zr(), wr(), {
      expression: {
        validate: (0, f.assertValueType)("boolean")
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, f.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  q("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ClassMethod", "ClassPrivateMethod",
        "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  q("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, f.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, f.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  q("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, f.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, f.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, f.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, f.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      let e = (0, f.assertNodeType)("Identifier");
      return function(t, r, i) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, at.default)("ExportDefaultDeclaration", t) || e(i, "id", i.id));
      };
    }()
  });
  q("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, f.assertNodeType)("StringLiteral")
      },
      exportKind: (0, f.validateOptional)((0, f.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      }
    }
  });
  q("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, f.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, f.validateOptional)((0, f.assertOneOf)("value"))
    }
  });
  q("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertNodeType)("Declaration"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)(function() {
          let e = (0, f.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t = (0, f.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(r, i, n) {
            (r.source ? e : t)(r, i, n);
          } : e;
        }()))
      },
      source: {
        validate: (0, f.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, f.validateOptional)((0, f.assertOneOf)("type", "value"))
    }
  });
  q("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, f.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, f.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, f.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  q("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, f.assertNodeType)("VariableDeclaration", "LVal");
          let e = (0, f.assertNodeType)("VariableDeclaration"), t = (0, f.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(r, i, n) {
            (0, at.default)("VariableDeclaration", n) ? e(r, i, n) : t(r, i, n);
          };
        }()
      },
      right: {
        validate: (0, f.assertNodeType)("Expression")
      },
      body: {
        validate: (0, f.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  q("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, f.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, f.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("ImportSpecifier", "ImportDefaultSpe\
cifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, f.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, f.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  q("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  q("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  q("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, f.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, f.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, f.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  q("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, f.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, f.assertNodeType)("Expression")
      },
      options: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  q("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, f.chain)((0, f.assertNodeType)("Identifier"), Object.assign(function(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let i;
          switch (r.name) {
            case "function":
              i = "sent";
              break;
            case "new":
              i = "target";
              break;
            case "import":
              i = "meta";
              break;
          }
          if (!(0, at.default)("Identifier", e.property, {
            name: i
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  var Vs = /* @__PURE__ */ s(() => ({
    abstract: {
      validate: (0, f.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, f.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, f.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, f.chain)(function() {
        let e = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, f.assertNodeType)("Expressi\
on");
        return function(r, i, n) {
          (r.computed ? t : e)(r, i, n);
        };
      }(), (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  yt.classMethodOrPropertyCommon = Vs;
  var Ba = /* @__PURE__ */ s(() => Object.assign({}, Zr(), Vs(), {
    params: {
      validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Identifier", "Pattern", "RestElement",
      "TSParameterProperty")))
    },
    kind: {
      validate: (0, f.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, f.chain)((0, f.assertValueType)("string"), (0, f.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  yt.classMethodOrDeclareMethodCommon = Ba;
  q("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, Ba(), wr(), {
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    })
  });
  q("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, ei(), {
      properties: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  q("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("Super", {
    aliases: ["Expression"]
  });
  q("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, f.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, f.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  q("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, f.chain)((0, f.assertShape)({
          raw: {
            validate: (0, f.assertValueType)("string")
          },
          cooked: {
            validate: (0, f.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ s(function(t) {
          let r = t.value.raw, i = !1, n = /* @__PURE__ */ s(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, xA.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              i = !0;
            },
            strictNumericEscape: n,
            invalidEscapeSequence: n,
            numericSeparatorInEscapeSequence: n,
            unexpectedNumericSeparator: n,
            invalidDigit: n,
            invalidCodePoint: n
          });
          if (!i) throw new Error("Invalid raw");
          t.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  q("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Expression", "TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  q("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, f.chain)((0, f.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !e.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, f.assertNodeType)("Expression")
      }
    }
  });
  q("Import", {
    aliases: ["Expression"]
  });
  q("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, f.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  q("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  q("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, f.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let e = (0, f.assertNodeType)("Identifier"), t = (0, f.assertNodeType)("Expression");
          return Object.assign(function(i, n, a) {
            (i.computed ? t : e)(i, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("boolean"), (0, f.assertOptionalChainStart)()) : (0, f.
        assertValueType)("boolean")
      }
    }
  });
  q("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, f.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("boolean"), (0, f.assertOptionalChainStart)()) : (0, f.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, f.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, f.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  q("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, Vs(), {
      value: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, f.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  q("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, Vs(), {
      key: {
        validate: (0, f.chain)(function() {
          let e = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t = (0, f.assertNodeType)(
          "Expression");
          return function(r, i, n) {
            (r.computed ? t : e)(r, i, n);
          };
        }(), (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, f.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  q("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, f.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, f.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, f.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, f.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, f.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  q("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, Ba(), wr(), {
      kind: {
        validate: (0, f.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, f.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, f.assertNodeType)("BlockStatement")
      }
    })
  });
  q("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, f.assertNodeType)("Identifier")
      }
    }
  });
  q("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var Kp = v(() => {
  "use strict";
  var I = Ut(), H = (0, I.defineAliasedType)("Flow"), Ra = /* @__PURE__ */ s((e) => {
    let t = e === "DeclareClass";
    H(e, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...t ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, I.validateType)("Identifier"),
        typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, I.validateOptional)((0, I.arrayOfType)("InterfaceExtends"))
      }, t ? {
        mixins: (0, I.validateOptional)((0, I.arrayOfType)("InterfaceExtends")),
        implements: (0, I.validateOptional)((0, I.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, I.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  H("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, I.validateType)("FlowType")
    }
  });
  H("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ra("DeclareClass");
  H("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      predicate: (0, I.validateOptionalType)("DeclaredPredicate")
    }
  });
  Ra("DeclareInterface");
  H("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)(["Identifier", "StringLiteral"]),
      body: (0, I.validateType)("BlockStatement"),
      kind: (0, I.validateOptional)((0, I.assertOneOf)("CommonJS", "ES"))
    }
  });
  H("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, I.validateType)("TypeAnnotation")
    }
  });
  H("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, I.validateType)("FlowType")
    }
  });
  H("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, I.validateOptionalType)("FlowType"),
      impltype: (0, I.validateOptionalType)("FlowType")
    }
  });
  H("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier")
    }
  });
  H("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, I.validateOptionalType)("Flow"),
      specifiers: (0, I.validateOptional)((0, I.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, I.validateOptionalType)("StringLiteral"),
      default: (0, I.validateOptional)((0, I.assertValueType)("boolean"))
    }
  });
  H("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, I.validateType)("StringLiteral"),
      exportKind: (0, I.validateOptional)((0, I.assertOneOf)("type", "value"))
    }
  });
  H("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, I.validateType)("Flow")
    }
  });
  H("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  H("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, I.validate)((0, I.arrayOfType)("FunctionTypeParam")),
      rest: (0, I.validateOptionalType)("FunctionTypeParam"),
      this: (0, I.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, I.validateType)("FlowType")
    }
  });
  H("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, I.validateOptionalType)("Identifier"),
      typeAnnotation: (0, I.validateType)("FlowType"),
      optional: (0, I.validateOptional)((0, I.assertValueType)("boolean"))
    }
  });
  H("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, I.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, I.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  H("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  H("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, I.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, I.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ra("InterfaceDeclaration");
  H("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, I.validateOptional)((0, I.arrayOfType)("InterfaceExtends")),
      body: (0, I.validateType)("ObjectTypeAnnotation")
    }
  });
  H("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, I.validate)((0, I.arrayOfType)("FlowType"))
    }
  });
  H("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, I.validateType)("FlowType")
    }
  });
  H("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, I.validate)((0, I.assertValueType)("number"))
    }
  });
  H("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, I.validate)((0, I.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, I.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, I.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, I.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, I.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, I.validateOptional)((0, I.assertValueType)("boolean"))
    }
  });
  H("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      value: (0, I.validateType)("FlowType"),
      optional: (0, I.validate)((0, I.assertValueType)("boolean")),
      static: (0, I.validate)((0, I.assertValueType)("boolean")),
      method: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, I.validateType)("FlowType"),
      static: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, I.validateOptionalType)("Identifier"),
      key: (0, I.validateType)("FlowType"),
      value: (0, I.validateType)("FlowType"),
      static: (0, I.validate)((0, I.assertValueType)("boolean")),
      variance: (0, I.validateOptionalType)("Variance")
    }
  });
  H("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, I.validateType)(["Identifier", "StringLiteral"]),
      value: (0, I.validateType)("FlowType"),
      kind: (0, I.validate)((0, I.assertOneOf)("init", "get", "set")),
      static: (0, I.validate)((0, I.assertValueType)("boolean")),
      proto: (0, I.validate)((0, I.assertValueType)("boolean")),
      optional: (0, I.validate)((0, I.assertValueType)("boolean")),
      variance: (0, I.validateOptionalType)("Variance"),
      method: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, I.validateType)("FlowType")
    }
  });
  H("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, I.validateOptionalType)("FlowType"),
      impltype: (0, I.validateType)("FlowType")
    }
  });
  H("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      qualification: (0, I.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  H("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, I.validate)((0, I.assertValueType)("string"))
    }
  });
  H("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, I.validate)((0, I.arrayOfType)("FlowType"))
    }
  });
  H("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, I.validateType)("FlowType")
    }
  });
  H("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      typeParameters: (0, I.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, I.validateType)("FlowType")
    }
  });
  H("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, I.validateType)("FlowType")
    }
  });
  H("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, I.validateType)("Expression"),
      typeAnnotation: (0, I.validateType)("TypeAnnotation")
    }
  });
  H("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, I.validate)((0, I.assertValueType)("string")),
      bound: (0, I.validateOptionalType)("TypeAnnotation"),
      default: (0, I.validateOptionalType)("FlowType"),
      variance: (0, I.validateOptionalType)("Variance")
    }
  });
  H("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, I.validate)((0, I.arrayOfType)("TypeParameter"))
    }
  });
  H("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, I.validate)((0, I.arrayOfType)("FlowType"))
    }
  });
  H("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, I.validate)((0, I.arrayOfType)("FlowType"))
    }
  });
  H("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, I.validate)((0, I.assertOneOf)("minus", "plus"))
    }
  });
  H("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  H("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      body: (0, I.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  H("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, I.validate)((0, I.assertValueType)("boolean")),
      members: (0, I.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, I.validate)((0, I.assertValueType)("boolean")),
      members: (0, I.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, I.validate)((0, I.assertValueType)("boolean")),
      members: (0, I.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, I.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
  H("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      init: (0, I.validateType)("BooleanLiteral")
    }
  });
  H("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      init: (0, I.validateType)("NumericLiteral")
    }
  });
  H("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, I.validateType)("Identifier"),
      init: (0, I.validateType)("StringLiteral")
    }
  });
  H("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, I.validateType)("Identifier")
    }
  });
  H("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, I.validateType)("FlowType"),
      indexType: (0, I.validateType)("FlowType")
    }
  });
  H("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, I.validateType)("FlowType"),
      indexType: (0, I.validateType)("FlowType"),
      optional: (0, I.validate)((0, I.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var Wp = v(() => {
  "use strict";
  var Ee = Ut(), ot = (0, Ee.defineAliasedType)("JSX");
  ot("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, Ee.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  ot("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  ot("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, Ee.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, Ee.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, Ee.chain)((0, Ee.assertValueType)("array"), (0, Ee.assertEach)((0, Ee.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, Ee.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  ot("JSXEmptyExpression", {});
  ot("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, Ee.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  ot("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, Ee.assertNodeType)("Expression")
      }
    }
  });
  ot("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Ee.assertValueType)("string")
      }
    }
  });
  ot("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, Ee.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ot("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ot("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, Ee.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, Ee.chain)((0, Ee.assertValueType)("array"), (0, Ee.assertEach)((0, Ee.assertNodeType)("JSXAttribute", "JSXSpreadAttrib\
ute")))
      },
      typeParameters: {
        validate: (0, Ee.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  ot("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, Ee.assertNodeType)("Expression")
      }
    }
  });
  ot("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, Ee.assertValueType)("string")
      }
    }
  });
  ot("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, Ee.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, Ee.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, Ee.chain)((0, Ee.assertValueType)("array"), (0, Ee.assertEach)((0, Ee.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  ot("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  ot("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Ua = v((sr) => {
  "use strict";
  Object.defineProperty(sr, "__esModule", {
    value: !0
  });
  sr.PLACEHOLDERS_FLIPPED_ALIAS = sr.PLACEHOLDERS_ALIAS = sr.PLACEHOLDERS = void 0;
  var EA = Ut(), PA = sr.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBo\
dy", "Pattern"], Va = sr.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let e of PA) {
    let t = EA.ALIAS_KEYS[e];
    t != null && t.length && (Va[e] = t);
  }
  var qa = sr.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(Va).forEach((e) => {
    Va[e].forEach((t) => {
      hasOwnProperty.call(qa, t) || (qa[t] = []), qa[t].push(e);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var Yp = v(() => {
  "use strict";
  var Us = Ut(), AA = Ua(), Ka = (0, Us.defineAliasedType)("Miscellaneous");
  Ka("Noop", {
    visitor: []
  });
  Ka("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, Us.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, Us.assertOneOf)(...AA.PLACEHOLDERS)
      }
    }
  });
  Ka("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Us.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var Xp = v(() => {
  "use strict";
  var be = Ut();
  (0, be.default)("ArgumentPlaceholder", {});
  (0, be.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, be.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, be.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, be.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, be.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, be.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, be.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, be.assertNodeType)("Expression")
      }
    }
  });
  (0, be.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, be.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, be.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, be.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, be.assertNodeType)("Identifier")
      }
    }
  });
  (0, be.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, be.chain)((0, be.assertValueType)("array"), (0, be.assertEach)((0, be.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, be.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, be.chain)((0, be.assertValueType)("array"), (0, be.assertEach)((0, be.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, be.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, be.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, be.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, be.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, be.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, be.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, be.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, be.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, be.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, be.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var ef = v(() => {
  "use strict";
  var D = Ut(), Jp = ja(), vA = zr(), se = (0, D.defineAliasedType)("TypeScript"), Tt = (0, D.assertValueType)("boolean"), $p = /* @__PURE__ */ s(
  () => ({
    returnType: {
      validate: (0, D.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, D.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  se("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, D.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, D.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, D.chain)((0, D.assertValueType)("array"), (0, D.assertEach)((0, D.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  });
  se("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Jp.functionDeclarationCommon)(), $p())
  });
  se("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Jp.classMethodOrDeclareMethodCommon)(), $p())
  });
  se("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, D.validateType)("TSEntityName"),
      right: (0, D.validateType)("Identifier")
    }
  });
  var Ks = /* @__PURE__ */ s(() => ({
    typeParameters: (0, D.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, D.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, D.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), Hp = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Ks()
  };
  se("TSCallSignatureDeclaration", Hp);
  se("TSConstructSignatureDeclaration", Hp);
  var Gp = /* @__PURE__ */ s(() => ({
    key: (0, D.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, D.validateOptional)(Tt)
  }), "namedTypeElementCommon");
  se("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, Gp(), {
      readonly: (0, D.validateOptional)(Tt),
      typeAnnotation: (0, D.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, D.assertOneOf)("get", "set")
      }
    })
  });
  se("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Ks(), Gp(), {
      kind: {
        validate: (0, D.assertOneOf)("method", "get", "set")
      }
    })
  });
  se("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, D.validateOptional)(Tt),
      static: (0, D.validateOptional)(Tt),
      parameters: (0, D.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, D.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var CA = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword",
  "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let e of CA)
    se(e, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  se("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var zp = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  se("TSFunctionType", Object.assign({}, zp, {
    fields: Ks()
  }));
  se("TSConstructorType", Object.assign({}, zp, {
    fields: Object.assign({}, Ks(), {
      abstract: (0, D.validateOptional)(Tt)
    })
  }));
  se("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, D.validateType)("TSEntityName"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  se("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, D.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, D.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, D.validateOptional)(Tt)
    }
  });
  se("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, D.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  se("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, D.validateArrayOfType)("TSTypeElement")
    }
  });
  se("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, D.validateType)("TSType")
    }
  });
  se("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, D.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  se("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, D.validateType)("Identifier"),
      optional: {
        validate: Tt,
        default: !1
      },
      elementType: (0, D.validateType)("TSType")
    }
  });
  var Qp = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, D.validateArrayOfType)("TSType")
    }
  };
  se("TSUnionType", Qp);
  se("TSIntersectionType", Qp);
  se("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, D.validateType)("TSType"),
      extendsType: (0, D.validateType)("TSType"),
      trueType: (0, D.validateType)("TSType"),
      falseType: (0, D.validateType)("TSType")
    }
  });
  se("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, D.validateType)("TSTypeParameter")
    }
  });
  se("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, D.validate)((0, D.assertValueType)("string")),
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, D.validateType)("TSType"),
      indexType: (0, D.validateType)("TSType")
    }
  });
  se("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, D.validateOptional)((0, D.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, D.validateType)("TSTypeParameter"),
      optional: (0, D.validateOptional)((0, D.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, D.validateOptionalType)("TSType"),
      nameType: (0, D.validateOptionalType)("TSType")
    }
  });
  se("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let e = (0, D.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, D.assertOneOf)("-"), r = (0, D.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function i(n, a, o) {
            (0, vA.default)("UnaryExpression", o) ? (t(o, "operator", o.operator), e(o, "argument", o.argument)) : r(n, a, o);
          }
          return s(i, "validator"), i.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], i;
        }()
      }
    }
  });
  se("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, D.validateType)("TSEntityName"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  se("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, D.validateOptional)(Tt),
      id: (0, D.validateType)("Identifier"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, D.validateOptional)((0, D.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, D.validateType)("TSInterfaceBody")
    }
  });
  se("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, D.validateArrayOfType)("TSTypeElement")
    }
  });
  se("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, D.validateOptional)(Tt),
      id: (0, D.validateType)("Identifier"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, D.validateType)("TSType")
    }
  });
  se("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, D.validateType)("Expression"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var Zp = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, D.validateType)("Expression"),
      typeAnnotation: (0, D.validateType)("TSType")
    }
  };
  se("TSAsExpression", Zp);
  se("TSSatisfiesExpression", Zp);
  se("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, D.validateType)("TSType"),
      expression: (0, D.validateType)("Expression")
    }
  });
  se("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, D.validateOptional)(Tt),
      const: (0, D.validateOptional)(Tt),
      id: (0, D.validateType)("Identifier"),
      members: (0, D.validateArrayOfType)("TSEnumMember"),
      initializer: (0, D.validateOptionalType)("Expression")
    }
  });
  se("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, D.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, D.validateOptionalType)("Expression")
    }
  });
  se("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, D.validateOptional)(Tt),
      global: (0, D.validateOptional)(Tt),
      id: (0, D.validateType)(["Identifier", "StringLiteral"]),
      body: (0, D.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  se("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, D.validateArrayOfType)("Statement")
    }
  });
  se("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, D.validateType)("StringLiteral"),
      qualifier: (0, D.validateOptionalType)("TSEntityName"),
      typeParameters: (0, D.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, D.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  se("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, D.validate)(Tt),
      id: (0, D.validateType)("Identifier"),
      moduleReference: (0, D.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, D.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  se("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, D.validateType)("StringLiteral")
    }
  });
  se("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, D.validateType)("Expression")
    }
  });
  se("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, D.validateType)("Expression")
    }
  });
  se("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, D.validateType)("Identifier")
    }
  });
  se("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, D.assertNodeType)("TSType")
      }
    }
  });
  se("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, D.chain)((0, D.assertValueType)("array"), (0, D.assertEach)((0, D.assertNodeType)("TSType")))
      }
    }
  });
  se("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, D.chain)((0, D.assertValueType)("array"), (0, D.assertEach)((0, D.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  se("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, D.assertValueType)("string")
      },
      in: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, D.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, D.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, D.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var tf = v((Ws) => {
  "use strict";
  Object.defineProperty(Ws, "__esModule", {
    value: !0
  });
  Ws.DEPRECATED_ALIASES = void 0;
  var B$ = Ws.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var Et = v((lt) => {
  "use strict";
  Object.defineProperty(lt, "__esModule", {
    value: !0
  });
  Object.defineProperty(lt, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ge.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(lt, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ge.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(lt, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Wa.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(lt, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ge.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(lt, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ge.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(lt, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ge.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(lt, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ge.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(lt, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ri.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(lt, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ri.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(lt, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ri.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  lt.TYPES = void 0;
  Object.defineProperty(lt, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return Ge.VISITOR_KEYS;
    }, "get")
  });
  var nr = bp();
  ja();
  Kp();
  Wp();
  Yp();
  Xp();
  ef();
  var Ge = Ut(), Ri = Ua(), Wa = tf();
  Object.keys(Wa.DEPRECATED_ALIASES).forEach((e) => {
    Ge.FLIPPED_ALIAS_KEYS[e] = Ge.FLIPPED_ALIAS_KEYS[Wa.DEPRECATED_ALIASES[e]];
  });
  nr(Ge.VISITOR_KEYS);
  nr(Ge.ALIAS_KEYS);
  nr(Ge.FLIPPED_ALIAS_KEYS);
  nr(Ge.NODE_FIELDS);
  nr(Ge.BUILDER_KEYS);
  nr(Ge.DEPRECATED_KEYS);
  nr(Ri.PLACEHOLDERS_ALIAS);
  nr(Ri.PLACEHOLDERS_FLIPPED_ALIAS);
  var R$ = lt.TYPES = [].concat(Object.keys(Ge.VISITOR_KEYS), Object.keys(Ge.FLIPPED_ALIAS_KEYS), Object.keys(Ge.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var qs = v((qi) => {
  "use strict";
  Object.defineProperty(qi, "__esModule", {
    value: !0
  });
  qi.default = IA;
  qi.validateChild = nf;
  qi.validateField = sf;
  var rf = Et();
  function IA(e, t, r) {
    if (!e) return;
    let i = rf.NODE_FIELDS[e.type];
    if (!i) return;
    let n = i[t];
    sf(e, t, r, n), nf(e, t, r);
  }
  s(IA, "validate");
  function sf(e, t, r, i) {
    i != null && i.validate && (i.optional && r == null || i.validate(e, t, r));
  }
  s(sf, "validateField");
  function nf(e, t, r) {
    if (r == null) return;
    let i = rf.NODE_PARENT_VALIDATIONS[r.type];
    i && i(e, t, r);
  }
  s(nf, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/validateNode.js
var af = v((Ya) => {
  "use strict";
  Object.defineProperty(Ya, "__esModule", {
    value: !0
  });
  Ya.default = NA;
  var wA = qs(), OA = le();
  function NA(e) {
    let t = OA.BUILDER_KEYS[e.type];
    for (let r of t)
      (0, wA.default)(e, r, e[r]);
    return e;
  }
  s(NA, "validateNode");
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var ut = v((h) => {
  "use strict";
  Object.defineProperty(h, "__esModule", {
    value: !0
  });
  h.anyTypeAnnotation = o1;
  h.argumentPlaceholder = FC;
  h.arrayExpression = _A;
  h.arrayPattern = Cv;
  h.arrayTypeAnnotation = l1;
  h.arrowFunctionExpression = Iv;
  h.assignmentExpression = DA;
  h.assignmentPattern = vv;
  h.awaitExpression = Hv;
  h.bigIntLiteral = zv;
  h.binaryExpression = kA;
  h.bindExpression = BC;
  h.blockStatement = BA;
  h.booleanLiteral = iv;
  h.booleanLiteralTypeAnnotation = c1;
  h.booleanTypeAnnotation = u1;
  h.breakStatement = jA;
  h.callExpression = RA;
  h.catchClause = qA;
  h.classAccessorProperty = r1;
  h.classBody = wv;
  h.classDeclaration = Nv;
  h.classExpression = Ov;
  h.classImplements = f1;
  h.classMethod = Uv;
  h.classPrivateMethod = s1;
  h.classPrivateProperty = i1;
  h.classProperty = t1;
  h.conditionalExpression = VA;
  h.continueStatement = UA;
  h.debuggerStatement = KA;
  h.decimalLiteral = WC;
  h.declareClass = h1;
  h.declareExportAllDeclaration = E1;
  h.declareExportDeclaration = x1;
  h.declareFunction = d1;
  h.declareInterface = m1;
  h.declareModule = y1;
  h.declareModuleExports = T1;
  h.declareOpaqueType = b1;
  h.declareTypeAlias = g1;
  h.declareVariable = S1;
  h.declaredPredicate = P1;
  h.decorator = RC;
  h.directive = MA;
  h.directiveLiteral = FA;
  h.doExpression = qC;
  h.doWhileStatement = WA;
  h.emptyStatement = YA;
  h.emptyTypeAnnotation = L1;
  h.enumBooleanBody = lC;
  h.enumBooleanMember = fC;
  h.enumDeclaration = oC;
  h.enumDefaultedMember = mC;
  h.enumNumberBody = uC;
  h.enumNumberMember = hC;
  h.enumStringBody = cC;
  h.enumStringMember = dC;
  h.enumSymbolBody = pC;
  h.existsTypeAnnotation = A1;
  h.exportAllDeclaration = _v;
  h.exportDefaultDeclaration = Dv;
  h.exportDefaultSpecifier = VC;
  h.exportNamedDeclaration = kv;
  h.exportNamespaceSpecifier = Qv;
  h.exportSpecifier = Lv;
  h.expressionStatement = XA;
  h.file = JA;
  h.forInStatement = $A;
  h.forOfStatement = Mv;
  h.forStatement = HA;
  h.functionDeclaration = GA;
  h.functionExpression = zA;
  h.functionTypeAnnotation = v1;
  h.functionTypeParam = C1;
  h.genericTypeAnnotation = I1;
  h.identifier = QA;
  h.ifStatement = ZA;
  h.import = Gv;
  h.importAttribute = jC;
  h.importDeclaration = Fv;
  h.importDefaultSpecifier = Bv;
  h.importExpression = qv;
  h.importNamespaceSpecifier = jv;
  h.importSpecifier = Rv;
  h.indexedAccessType = yC;
  h.inferredPredicate = w1;
  h.interfaceDeclaration = N1;
  h.interfaceExtends = O1;
  h.interfaceTypeAnnotation = _1;
  h.interpreterDirective = LA;
  h.intersectionTypeAnnotation = D1;
  h.jSXAttribute = h.jsxAttribute = gC;
  h.jSXClosingElement = h.jsxClosingElement = bC;
  h.jSXClosingFragment = h.jsxClosingFragment = DC;
  h.jSXElement = h.jsxElement = SC;
  h.jSXEmptyExpression = h.jsxEmptyExpression = xC;
  h.jSXExpressionContainer = h.jsxExpressionContainer = EC;
  h.jSXFragment = h.jsxFragment = NC;
  h.jSXIdentifier = h.jsxIdentifier = AC;
  h.jSXMemberExpression = h.jsxMemberExpression = vC;
  h.jSXNamespacedName = h.jsxNamespacedName = CC;
  h.jSXOpeningElement = h.jsxOpeningElement = IC;
  h.jSXOpeningFragment = h.jsxOpeningFragment = _C;
  h.jSXSpreadAttribute = h.jsxSpreadAttribute = wC;
  h.jSXSpreadChild = h.jsxSpreadChild = PC;
  h.jSXText = h.jsxText = OC;
  h.labeledStatement = ev;
  h.logicalExpression = sv;
  h.memberExpression = nv;
  h.metaProperty = Vv;
  h.mixedTypeAnnotation = k1;
  h.moduleExpression = YC;
  h.newExpression = av;
  h.noop = kC;
  h.nullLiteral = rv;
  h.nullLiteralTypeAnnotation = p1;
  h.nullableTypeAnnotation = M1;
  h.numberLiteral = ow;
  h.numberLiteralTypeAnnotation = F1;
  h.numberTypeAnnotation = B1;
  h.numericLiteral = of;
  h.objectExpression = lv;
  h.objectMethod = uv;
  h.objectPattern = Kv;
  h.objectProperty = cv;
  h.objectTypeAnnotation = j1;
  h.objectTypeCallProperty = q1;
  h.objectTypeIndexer = V1;
  h.objectTypeInternalSlot = R1;
  h.objectTypeProperty = U1;
  h.objectTypeSpreadProperty = K1;
  h.opaqueType = W1;
  h.optionalCallExpression = e1;
  h.optionalIndexedAccessType = TC;
  h.optionalMemberExpression = Zv;
  h.parenthesizedExpression = hv;
  h.pipelineBareFunction = $C;
  h.pipelinePrimaryTopicReference = HC;
  h.pipelineTopicExpression = JC;
  h.placeholder = LC;
  h.privateName = n1;
  h.program = ov;
  h.qualifiedTypeIdentifier = Y1;
  h.recordExpression = UC;
  h.regExpLiteral = lf;
  h.regexLiteral = lw;
  h.restElement = uf;
  h.restProperty = uw;
  h.returnStatement = pv;
  h.sequenceExpression = fv;
  h.spreadElement = cf;
  h.spreadProperty = cw;
  h.staticBlock = a1;
  h.stringLiteral = tv;
  h.stringLiteralTypeAnnotation = X1;
  h.stringTypeAnnotation = J1;
  h.super = Wv;
  h.switchCase = dv;
  h.switchStatement = mv;
  h.symbolTypeAnnotation = $1;
  h.taggedTemplateExpression = Yv;
  h.templateElement = Xv;
  h.templateLiteral = Jv;
  h.thisExpression = yv;
  h.thisTypeAnnotation = H1;
  h.throwStatement = Tv;
  h.topicReference = XC;
  h.tryStatement = gv;
  h.tSAnyKeyword = h.tsAnyKeyword = nI;
  h.tSArrayType = h.tsArrayType = vI;
  h.tSAsExpression = h.tsAsExpression = WI;
  h.tSBigIntKeyword = h.tsBigIntKeyword = oI;
  h.tSBooleanKeyword = h.tsBooleanKeyword = aI;
  h.tSCallSignatureDeclaration = h.tsCallSignatureDeclaration = eI;
  h.tSConditionalType = h.tsConditionalType = DI;
  h.tSConstructSignatureDeclaration = h.tsConstructSignatureDeclaration = tI;
  h.tSConstructorType = h.tsConstructorType = SI;
  h.tSDeclareFunction = h.tsDeclareFunction = zC;
  h.tSDeclareMethod = h.tsDeclareMethod = QC;
  h.tSEnumDeclaration = h.tsEnumDeclaration = JI;
  h.tSEnumMember = h.tsEnumMember = $I;
  h.tSExportAssignment = h.tsExportAssignment = tw;
  h.tSExpressionWithTypeArguments = h.tsExpressionWithTypeArguments = RI;
  h.tSExternalModuleReference = h.tsExternalModuleReference = ZI;
  h.tSFunctionType = h.tsFunctionType = bI;
  h.tSImportEqualsDeclaration = h.tsImportEqualsDeclaration = QI;
  h.tSImportType = h.tsImportType = zI;
  h.tSIndexSignature = h.tsIndexSignature = sI;
  h.tSIndexedAccessType = h.tsIndexedAccessType = FI;
  h.tSInferType = h.tsInferType = kI;
  h.tSInstantiationExpression = h.tsInstantiationExpression = KI;
  h.tSInterfaceBody = h.tsInterfaceBody = VI;
  h.tSInterfaceDeclaration = h.tsInterfaceDeclaration = qI;
  h.tSIntersectionType = h.tsIntersectionType = _I;
  h.tSIntrinsicKeyword = h.tsIntrinsicKeyword = lI;
  h.tSLiteralType = h.tsLiteralType = jI;
  h.tSMappedType = h.tsMappedType = BI;
  h.tSMethodSignature = h.tsMethodSignature = iI;
  h.tSModuleBlock = h.tsModuleBlock = GI;
  h.tSModuleDeclaration = h.tsModuleDeclaration = HI;
  h.tSNamedTupleMember = h.tsNamedTupleMember = OI;
  h.tSNamespaceExportDeclaration = h.tsNamespaceExportDeclaration = rw;
  h.tSNeverKeyword = h.tsNeverKeyword = uI;
  h.tSNonNullExpression = h.tsNonNullExpression = ew;
  h.tSNullKeyword = h.tsNullKeyword = cI;
  h.tSNumberKeyword = h.tsNumberKeyword = pI;
  h.tSObjectKeyword = h.tsObjectKeyword = fI;
  h.tSOptionalType = h.tsOptionalType = II;
  h.tSParameterProperty = h.tsParameterProperty = GC;
  h.tSParenthesizedType = h.tsParenthesizedType = LI;
  h.tSPropertySignature = h.tsPropertySignature = rI;
  h.tSQualifiedName = h.tsQualifiedName = ZC;
  h.tSRestType = h.tsRestType = wI;
  h.tSSatisfiesExpression = h.tsSatisfiesExpression = YI;
  h.tSStringKeyword = h.tsStringKeyword = hI;
  h.tSSymbolKeyword = h.tsSymbolKeyword = dI;
  h.tSThisType = h.tsThisType = gI;
  h.tSTupleType = h.tsTupleType = CI;
  h.tSTypeAliasDeclaration = h.tsTypeAliasDeclaration = UI;
  h.tSTypeAnnotation = h.tsTypeAnnotation = iw;
  h.tSTypeAssertion = h.tsTypeAssertion = XI;
  h.tSTypeLiteral = h.tsTypeLiteral = AI;
  h.tSTypeOperator = h.tsTypeOperator = MI;
  h.tSTypeParameter = h.tsTypeParameter = aw;
  h.tSTypeParameterDeclaration = h.tsTypeParameterDeclaration = nw;
  h.tSTypeParameterInstantiation = h.tsTypeParameterInstantiation = sw;
  h.tSTypePredicate = h.tsTypePredicate = EI;
  h.tSTypeQuery = h.tsTypeQuery = PI;
  h.tSTypeReference = h.tsTypeReference = xI;
  h.tSUndefinedKeyword = h.tsUndefinedKeyword = mI;
  h.tSUnionType = h.tsUnionType = NI;
  h.tSUnknownKeyword = h.tsUnknownKeyword = yI;
  h.tSVoidKeyword = h.tsVoidKeyword = TI;
  h.tupleExpression = KC;
  h.tupleTypeAnnotation = G1;
  h.typeAlias = Q1;
  h.typeAnnotation = Z1;
  h.typeCastExpression = eC;
  h.typeParameter = tC;
  h.typeParameterDeclaration = rC;
  h.typeParameterInstantiation = iC;
  h.typeofTypeAnnotation = z1;
  h.unaryExpression = bv;
  h.unionTypeAnnotation = sC;
  h.updateExpression = Sv;
  h.v8IntrinsicIdentifier = MC;
  h.variableDeclaration = xv;
  h.variableDeclarator = Ev;
  h.variance = nC;
  h.voidTypeAnnotation = aC;
  h.whileStatement = Pv;
  h.withStatement = Av;
  h.yieldExpression = $v;
  var E = af(), Ys = Oi();
  function _A(e = []) {
    return (0, E.default)({
      type: "ArrayExpression",
      elements: e
    });
  }
  s(_A, "arrayExpression");
  function DA(e, t, r) {
    return (0, E.default)({
      type: "AssignmentExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  s(DA, "assignmentExpression");
  function kA(e, t, r) {
    return (0, E.default)({
      type: "BinaryExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  s(kA, "binaryExpression");
  function LA(e) {
    return (0, E.default)({
      type: "InterpreterDirective",
      value: e
    });
  }
  s(LA, "interpreterDirective");
  function MA(e) {
    return (0, E.default)({
      type: "Directive",
      value: e
    });
  }
  s(MA, "directive");
  function FA(e) {
    return (0, E.default)({
      type: "DirectiveLiteral",
      value: e
    });
  }
  s(FA, "directiveLiteral");
  function BA(e, t = []) {
    return (0, E.default)({
      type: "BlockStatement",
      body: e,
      directives: t
    });
  }
  s(BA, "blockStatement");
  function jA(e = null) {
    return (0, E.default)({
      type: "BreakStatement",
      label: e
    });
  }
  s(jA, "breakStatement");
  function RA(e, t) {
    return (0, E.default)({
      type: "CallExpression",
      callee: e,
      arguments: t
    });
  }
  s(RA, "callExpression");
  function qA(e = null, t) {
    return (0, E.default)({
      type: "CatchClause",
      param: e,
      body: t
    });
  }
  s(qA, "catchClause");
  function VA(e, t, r) {
    return (0, E.default)({
      type: "ConditionalExpression",
      test: e,
      consequent: t,
      alternate: r
    });
  }
  s(VA, "conditionalExpression");
  function UA(e = null) {
    return (0, E.default)({
      type: "ContinueStatement",
      label: e
    });
  }
  s(UA, "continueStatement");
  function KA() {
    return {
      type: "DebuggerStatement"
    };
  }
  s(KA, "debuggerStatement");
  function WA(e, t) {
    return (0, E.default)({
      type: "DoWhileStatement",
      test: e,
      body: t
    });
  }
  s(WA, "doWhileStatement");
  function YA() {
    return {
      type: "EmptyStatement"
    };
  }
  s(YA, "emptyStatement");
  function XA(e) {
    return (0, E.default)({
      type: "ExpressionStatement",
      expression: e
    });
  }
  s(XA, "expressionStatement");
  function JA(e, t = null, r = null) {
    return (0, E.default)({
      type: "File",
      program: e,
      comments: t,
      tokens: r
    });
  }
  s(JA, "file");
  function $A(e, t, r) {
    return (0, E.default)({
      type: "ForInStatement",
      left: e,
      right: t,
      body: r
    });
  }
  s($A, "forInStatement");
  function HA(e = null, t = null, r = null, i) {
    return (0, E.default)({
      type: "ForStatement",
      init: e,
      test: t,
      update: r,
      body: i
    });
  }
  s(HA, "forStatement");
  function GA(e = null, t, r, i = !1, n = !1) {
    return (0, E.default)({
      type: "FunctionDeclaration",
      id: e,
      params: t,
      body: r,
      generator: i,
      async: n
    });
  }
  s(GA, "functionDeclaration");
  function zA(e = null, t, r, i = !1, n = !1) {
    return (0, E.default)({
      type: "FunctionExpression",
      id: e,
      params: t,
      body: r,
      generator: i,
      async: n
    });
  }
  s(zA, "functionExpression");
  function QA(e) {
    return (0, E.default)({
      type: "Identifier",
      name: e
    });
  }
  s(QA, "identifier");
  function ZA(e, t, r = null) {
    return (0, E.default)({
      type: "IfStatement",
      test: e,
      consequent: t,
      alternate: r
    });
  }
  s(ZA, "ifStatement");
  function ev(e, t) {
    return (0, E.default)({
      type: "LabeledStatement",
      label: e,
      body: t
    });
  }
  s(ev, "labeledStatement");
  function tv(e) {
    return (0, E.default)({
      type: "StringLiteral",
      value: e
    });
  }
  s(tv, "stringLiteral");
  function of(e) {
    return (0, E.default)({
      type: "NumericLiteral",
      value: e
    });
  }
  s(of, "numericLiteral");
  function rv() {
    return {
      type: "NullLiteral"
    };
  }
  s(rv, "nullLiteral");
  function iv(e) {
    return (0, E.default)({
      type: "BooleanLiteral",
      value: e
    });
  }
  s(iv, "booleanLiteral");
  function lf(e, t = "") {
    return (0, E.default)({
      type: "RegExpLiteral",
      pattern: e,
      flags: t
    });
  }
  s(lf, "regExpLiteral");
  function sv(e, t, r) {
    return (0, E.default)({
      type: "LogicalExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  s(sv, "logicalExpression");
  function nv(e, t, r = !1, i = null) {
    return (0, E.default)({
      type: "MemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: i
    });
  }
  s(nv, "memberExpression");
  function av(e, t) {
    return (0, E.default)({
      type: "NewExpression",
      callee: e,
      arguments: t
    });
  }
  s(av, "newExpression");
  function ov(e, t = [], r = "script", i = null) {
    return (0, E.default)({
      type: "Program",
      body: e,
      directives: t,
      sourceType: r,
      interpreter: i
    });
  }
  s(ov, "program");
  function lv(e) {
    return (0, E.default)({
      type: "ObjectExpression",
      properties: e
    });
  }
  s(lv, "objectExpression");
  function uv(e = "method", t, r, i, n = !1, a = !1, o = !1) {
    return (0, E.default)({
      type: "ObjectMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      computed: n,
      generator: a,
      async: o
    });
  }
  s(uv, "objectMethod");
  function cv(e, t, r = !1, i = !1, n = null) {
    return (0, E.default)({
      type: "ObjectProperty",
      key: e,
      value: t,
      computed: r,
      shorthand: i,
      decorators: n
    });
  }
  s(cv, "objectProperty");
  function uf(e) {
    return (0, E.default)({
      type: "RestElement",
      argument: e
    });
  }
  s(uf, "restElement");
  function pv(e = null) {
    return (0, E.default)({
      type: "ReturnStatement",
      argument: e
    });
  }
  s(pv, "returnStatement");
  function fv(e) {
    return (0, E.default)({
      type: "SequenceExpression",
      expressions: e
    });
  }
  s(fv, "sequenceExpression");
  function hv(e) {
    return (0, E.default)({
      type: "ParenthesizedExpression",
      expression: e
    });
  }
  s(hv, "parenthesizedExpression");
  function dv(e = null, t) {
    return (0, E.default)({
      type: "SwitchCase",
      test: e,
      consequent: t
    });
  }
  s(dv, "switchCase");
  function mv(e, t) {
    return (0, E.default)({
      type: "SwitchStatement",
      discriminant: e,
      cases: t
    });
  }
  s(mv, "switchStatement");
  function yv() {
    return {
      type: "ThisExpression"
    };
  }
  s(yv, "thisExpression");
  function Tv(e) {
    return (0, E.default)({
      type: "ThrowStatement",
      argument: e
    });
  }
  s(Tv, "throwStatement");
  function gv(e, t = null, r = null) {
    return (0, E.default)({
      type: "TryStatement",
      block: e,
      handler: t,
      finalizer: r
    });
  }
  s(gv, "tryStatement");
  function bv(e, t, r = !0) {
    return (0, E.default)({
      type: "UnaryExpression",
      operator: e,
      argument: t,
      prefix: r
    });
  }
  s(bv, "unaryExpression");
  function Sv(e, t, r = !1) {
    return (0, E.default)({
      type: "UpdateExpression",
      operator: e,
      argument: t,
      prefix: r
    });
  }
  s(Sv, "updateExpression");
  function xv(e, t) {
    return (0, E.default)({
      type: "VariableDeclaration",
      kind: e,
      declarations: t
    });
  }
  s(xv, "variableDeclaration");
  function Ev(e, t = null) {
    return (0, E.default)({
      type: "VariableDeclarator",
      id: e,
      init: t
    });
  }
  s(Ev, "variableDeclarator");
  function Pv(e, t) {
    return (0, E.default)({
      type: "WhileStatement",
      test: e,
      body: t
    });
  }
  s(Pv, "whileStatement");
  function Av(e, t) {
    return (0, E.default)({
      type: "WithStatement",
      object: e,
      body: t
    });
  }
  s(Av, "withStatement");
  function vv(e, t) {
    return (0, E.default)({
      type: "AssignmentPattern",
      left: e,
      right: t
    });
  }
  s(vv, "assignmentPattern");
  function Cv(e) {
    return (0, E.default)({
      type: "ArrayPattern",
      elements: e
    });
  }
  s(Cv, "arrayPattern");
  function Iv(e, t, r = !1) {
    return (0, E.default)({
      type: "ArrowFunctionExpression",
      params: e,
      body: t,
      async: r,
      expression: null
    });
  }
  s(Iv, "arrowFunctionExpression");
  function wv(e) {
    return (0, E.default)({
      type: "ClassBody",
      body: e
    });
  }
  s(wv, "classBody");
  function Ov(e = null, t = null, r, i = null) {
    return (0, E.default)({
      type: "ClassExpression",
      id: e,
      superClass: t,
      body: r,
      decorators: i
    });
  }
  s(Ov, "classExpression");
  function Nv(e = null, t = null, r, i = null) {
    return (0, E.default)({
      type: "ClassDeclaration",
      id: e,
      superClass: t,
      body: r,
      decorators: i
    });
  }
  s(Nv, "classDeclaration");
  function _v(e) {
    return (0, E.default)({
      type: "ExportAllDeclaration",
      source: e
    });
  }
  s(_v, "exportAllDeclaration");
  function Dv(e) {
    return (0, E.default)({
      type: "ExportDefaultDeclaration",
      declaration: e
    });
  }
  s(Dv, "exportDefaultDeclaration");
  function kv(e = null, t = [], r = null) {
    return (0, E.default)({
      type: "ExportNamedDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    });
  }
  s(kv, "exportNamedDeclaration");
  function Lv(e, t) {
    return (0, E.default)({
      type: "ExportSpecifier",
      local: e,
      exported: t
    });
  }
  s(Lv, "exportSpecifier");
  function Mv(e, t, r, i = !1) {
    return (0, E.default)({
      type: "ForOfStatement",
      left: e,
      right: t,
      body: r,
      await: i
    });
  }
  s(Mv, "forOfStatement");
  function Fv(e, t) {
    return (0, E.default)({
      type: "ImportDeclaration",
      specifiers: e,
      source: t
    });
  }
  s(Fv, "importDeclaration");
  function Bv(e) {
    return (0, E.default)({
      type: "ImportDefaultSpecifier",
      local: e
    });
  }
  s(Bv, "importDefaultSpecifier");
  function jv(e) {
    return (0, E.default)({
      type: "ImportNamespaceSpecifier",
      local: e
    });
  }
  s(jv, "importNamespaceSpecifier");
  function Rv(e, t) {
    return (0, E.default)({
      type: "ImportSpecifier",
      local: e,
      imported: t
    });
  }
  s(Rv, "importSpecifier");
  function qv(e, t = null) {
    return (0, E.default)({
      type: "ImportExpression",
      source: e,
      options: t
    });
  }
  s(qv, "importExpression");
  function Vv(e, t) {
    return (0, E.default)({
      type: "MetaProperty",
      meta: e,
      property: t
    });
  }
  s(Vv, "metaProperty");
  function Uv(e = "method", t, r, i, n = !1, a = !1, o = !1, l = !1) {
    return (0, E.default)({
      type: "ClassMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      computed: n,
      static: a,
      generator: o,
      async: l
    });
  }
  s(Uv, "classMethod");
  function Kv(e) {
    return (0, E.default)({
      type: "ObjectPattern",
      properties: e
    });
  }
  s(Kv, "objectPattern");
  function cf(e) {
    return (0, E.default)({
      type: "SpreadElement",
      argument: e
    });
  }
  s(cf, "spreadElement");
  function Wv() {
    return {
      type: "Super"
    };
  }
  s(Wv, "_super");
  function Yv(e, t) {
    return (0, E.default)({
      type: "TaggedTemplateExpression",
      tag: e,
      quasi: t
    });
  }
  s(Yv, "taggedTemplateExpression");
  function Xv(e, t = !1) {
    return (0, E.default)({
      type: "TemplateElement",
      value: e,
      tail: t
    });
  }
  s(Xv, "templateElement");
  function Jv(e, t) {
    return (0, E.default)({
      type: "TemplateLiteral",
      quasis: e,
      expressions: t
    });
  }
  s(Jv, "templateLiteral");
  function $v(e = null, t = !1) {
    return (0, E.default)({
      type: "YieldExpression",
      argument: e,
      delegate: t
    });
  }
  s($v, "yieldExpression");
  function Hv(e) {
    return (0, E.default)({
      type: "AwaitExpression",
      argument: e
    });
  }
  s(Hv, "awaitExpression");
  function Gv() {
    return {
      type: "Import"
    };
  }
  s(Gv, "_import");
  function zv(e) {
    return (0, E.default)({
      type: "BigIntLiteral",
      value: e
    });
  }
  s(zv, "bigIntLiteral");
  function Qv(e) {
    return (0, E.default)({
      type: "ExportNamespaceSpecifier",
      exported: e
    });
  }
  s(Qv, "exportNamespaceSpecifier");
  function Zv(e, t, r = !1, i) {
    return (0, E.default)({
      type: "OptionalMemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: i
    });
  }
  s(Zv, "optionalMemberExpression");
  function e1(e, t, r) {
    return (0, E.default)({
      type: "OptionalCallExpression",
      callee: e,
      arguments: t,
      optional: r
    });
  }
  s(e1, "optionalCallExpression");
  function t1(e, t = null, r = null, i = null, n = !1, a = !1) {
    return (0, E.default)({
      type: "ClassProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    });
  }
  s(t1, "classProperty");
  function r1(e, t = null, r = null, i = null, n = !1, a = !1) {
    return (0, E.default)({
      type: "ClassAccessorProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: i,
      computed: n,
      static: a
    });
  }
  s(r1, "classAccessorProperty");
  function i1(e, t = null, r = null, i = !1) {
    return (0, E.default)({
      type: "ClassPrivateProperty",
      key: e,
      value: t,
      decorators: r,
      static: i
    });
  }
  s(i1, "classPrivateProperty");
  function s1(e = "method", t, r, i, n = !1) {
    return (0, E.default)({
      type: "ClassPrivateMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      static: n
    });
  }
  s(s1, "classPrivateMethod");
  function n1(e) {
    return (0, E.default)({
      type: "PrivateName",
      id: e
    });
  }
  s(n1, "privateName");
  function a1(e) {
    return (0, E.default)({
      type: "StaticBlock",
      body: e
    });
  }
  s(a1, "staticBlock");
  function o1() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  s(o1, "anyTypeAnnotation");
  function l1(e) {
    return (0, E.default)({
      type: "ArrayTypeAnnotation",
      elementType: e
    });
  }
  s(l1, "arrayTypeAnnotation");
  function u1() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  s(u1, "booleanTypeAnnotation");
  function c1(e) {
    return (0, E.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: e
    });
  }
  s(c1, "booleanLiteralTypeAnnotation");
  function p1() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  s(p1, "nullLiteralTypeAnnotation");
  function f1(e, t = null) {
    return (0, E.default)({
      type: "ClassImplements",
      id: e,
      typeParameters: t
    });
  }
  s(f1, "classImplements");
  function h1(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "DeclareClass",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    });
  }
  s(h1, "declareClass");
  function d1(e) {
    return (0, E.default)({
      type: "DeclareFunction",
      id: e
    });
  }
  s(d1, "declareFunction");
  function m1(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "DeclareInterface",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    });
  }
  s(m1, "declareInterface");
  function y1(e, t, r = null) {
    return (0, E.default)({
      type: "DeclareModule",
      id: e,
      body: t,
      kind: r
    });
  }
  s(y1, "declareModule");
  function T1(e) {
    return (0, E.default)({
      type: "DeclareModuleExports",
      typeAnnotation: e
    });
  }
  s(T1, "declareModuleExports");
  function g1(e, t = null, r) {
    return (0, E.default)({
      type: "DeclareTypeAlias",
      id: e,
      typeParameters: t,
      right: r
    });
  }
  s(g1, "declareTypeAlias");
  function b1(e, t = null, r = null) {
    return (0, E.default)({
      type: "DeclareOpaqueType",
      id: e,
      typeParameters: t,
      supertype: r
    });
  }
  s(b1, "declareOpaqueType");
  function S1(e) {
    return (0, E.default)({
      type: "DeclareVariable",
      id: e
    });
  }
  s(S1, "declareVariable");
  function x1(e = null, t = null, r = null) {
    return (0, E.default)({
      type: "DeclareExportDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    });
  }
  s(x1, "declareExportDeclaration");
  function E1(e) {
    return (0, E.default)({
      type: "DeclareExportAllDeclaration",
      source: e
    });
  }
  s(E1, "declareExportAllDeclaration");
  function P1(e) {
    return (0, E.default)({
      type: "DeclaredPredicate",
      value: e
    });
  }
  s(P1, "declaredPredicate");
  function A1() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  s(A1, "existsTypeAnnotation");
  function v1(e = null, t, r = null, i) {
    return (0, E.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: e,
      params: t,
      rest: r,
      returnType: i
    });
  }
  s(v1, "functionTypeAnnotation");
  function C1(e = null, t) {
    return (0, E.default)({
      type: "FunctionTypeParam",
      name: e,
      typeAnnotation: t
    });
  }
  s(C1, "functionTypeParam");
  function I1(e, t = null) {
    return (0, E.default)({
      type: "GenericTypeAnnotation",
      id: e,
      typeParameters: t
    });
  }
  s(I1, "genericTypeAnnotation");
  function w1() {
    return {
      type: "InferredPredicate"
    };
  }
  s(w1, "inferredPredicate");
  function O1(e, t = null) {
    return (0, E.default)({
      type: "InterfaceExtends",
      id: e,
      typeParameters: t
    });
  }
  s(O1, "interfaceExtends");
  function N1(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "InterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    });
  }
  s(N1, "interfaceDeclaration");
  function _1(e = null, t) {
    return (0, E.default)({
      type: "InterfaceTypeAnnotation",
      extends: e,
      body: t
    });
  }
  s(_1, "interfaceTypeAnnotation");
  function D1(e) {
    return (0, E.default)({
      type: "IntersectionTypeAnnotation",
      types: e
    });
  }
  s(D1, "intersectionTypeAnnotation");
  function k1() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  s(k1, "mixedTypeAnnotation");
  function L1() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  s(L1, "emptyTypeAnnotation");
  function M1(e) {
    return (0, E.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: e
    });
  }
  s(M1, "nullableTypeAnnotation");
  function F1(e) {
    return (0, E.default)({
      type: "NumberLiteralTypeAnnotation",
      value: e
    });
  }
  s(F1, "numberLiteralTypeAnnotation");
  function B1() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  s(B1, "numberTypeAnnotation");
  function j1(e, t = [], r = [], i = [], n = !1) {
    return (0, E.default)({
      type: "ObjectTypeAnnotation",
      properties: e,
      indexers: t,
      callProperties: r,
      internalSlots: i,
      exact: n
    });
  }
  s(j1, "objectTypeAnnotation");
  function R1(e, t, r, i, n) {
    return (0, E.default)({
      type: "ObjectTypeInternalSlot",
      id: e,
      value: t,
      optional: r,
      static: i,
      method: n
    });
  }
  s(R1, "objectTypeInternalSlot");
  function q1(e) {
    return (0, E.default)({
      type: "ObjectTypeCallProperty",
      value: e,
      static: null
    });
  }
  s(q1, "objectTypeCallProperty");
  function V1(e = null, t, r, i = null) {
    return (0, E.default)({
      type: "ObjectTypeIndexer",
      id: e,
      key: t,
      value: r,
      variance: i,
      static: null
    });
  }
  s(V1, "objectTypeIndexer");
  function U1(e, t, r = null) {
    return (0, E.default)({
      type: "ObjectTypeProperty",
      key: e,
      value: t,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  s(U1, "objectTypeProperty");
  function K1(e) {
    return (0, E.default)({
      type: "ObjectTypeSpreadProperty",
      argument: e
    });
  }
  s(K1, "objectTypeSpreadProperty");
  function W1(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "OpaqueType",
      id: e,
      typeParameters: t,
      supertype: r,
      impltype: i
    });
  }
  s(W1, "opaqueType");
  function Y1(e, t) {
    return (0, E.default)({
      type: "QualifiedTypeIdentifier",
      id: e,
      qualification: t
    });
  }
  s(Y1, "qualifiedTypeIdentifier");
  function X1(e) {
    return (0, E.default)({
      type: "StringLiteralTypeAnnotation",
      value: e
    });
  }
  s(X1, "stringLiteralTypeAnnotation");
  function J1() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  s(J1, "stringTypeAnnotation");
  function $1() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  s($1, "symbolTypeAnnotation");
  function H1() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  s(H1, "thisTypeAnnotation");
  function G1(e) {
    return (0, E.default)({
      type: "TupleTypeAnnotation",
      types: e
    });
  }
  s(G1, "tupleTypeAnnotation");
  function z1(e) {
    return (0, E.default)({
      type: "TypeofTypeAnnotation",
      argument: e
    });
  }
  s(z1, "typeofTypeAnnotation");
  function Q1(e, t = null, r) {
    return (0, E.default)({
      type: "TypeAlias",
      id: e,
      typeParameters: t,
      right: r
    });
  }
  s(Q1, "typeAlias");
  function Z1(e) {
    return (0, E.default)({
      type: "TypeAnnotation",
      typeAnnotation: e
    });
  }
  s(Z1, "typeAnnotation");
  function eC(e, t) {
    return (0, E.default)({
      type: "TypeCastExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  s(eC, "typeCastExpression");
  function tC(e = null, t = null, r = null) {
    return (0, E.default)({
      type: "TypeParameter",
      bound: e,
      default: t,
      variance: r,
      name: null
    });
  }
  s(tC, "typeParameter");
  function rC(e) {
    return (0, E.default)({
      type: "TypeParameterDeclaration",
      params: e
    });
  }
  s(rC, "typeParameterDeclaration");
  function iC(e) {
    return (0, E.default)({
      type: "TypeParameterInstantiation",
      params: e
    });
  }
  s(iC, "typeParameterInstantiation");
  function sC(e) {
    return (0, E.default)({
      type: "UnionTypeAnnotation",
      types: e
    });
  }
  s(sC, "unionTypeAnnotation");
  function nC(e) {
    return (0, E.default)({
      type: "Variance",
      kind: e
    });
  }
  s(nC, "variance");
  function aC() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  s(aC, "voidTypeAnnotation");
  function oC(e, t) {
    return (0, E.default)({
      type: "EnumDeclaration",
      id: e,
      body: t
    });
  }
  s(oC, "enumDeclaration");
  function lC(e) {
    return (0, E.default)({
      type: "EnumBooleanBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  s(lC, "enumBooleanBody");
  function uC(e) {
    return (0, E.default)({
      type: "EnumNumberBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  s(uC, "enumNumberBody");
  function cC(e) {
    return (0, E.default)({
      type: "EnumStringBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  s(cC, "enumStringBody");
  function pC(e) {
    return (0, E.default)({
      type: "EnumSymbolBody",
      members: e,
      hasUnknownMembers: null
    });
  }
  s(pC, "enumSymbolBody");
  function fC(e) {
    return (0, E.default)({
      type: "EnumBooleanMember",
      id: e,
      init: null
    });
  }
  s(fC, "enumBooleanMember");
  function hC(e, t) {
    return (0, E.default)({
      type: "EnumNumberMember",
      id: e,
      init: t
    });
  }
  s(hC, "enumNumberMember");
  function dC(e, t) {
    return (0, E.default)({
      type: "EnumStringMember",
      id: e,
      init: t
    });
  }
  s(dC, "enumStringMember");
  function mC(e) {
    return (0, E.default)({
      type: "EnumDefaultedMember",
      id: e
    });
  }
  s(mC, "enumDefaultedMember");
  function yC(e, t) {
    return (0, E.default)({
      type: "IndexedAccessType",
      objectType: e,
      indexType: t
    });
  }
  s(yC, "indexedAccessType");
  function TC(e, t) {
    return (0, E.default)({
      type: "OptionalIndexedAccessType",
      objectType: e,
      indexType: t,
      optional: null
    });
  }
  s(TC, "optionalIndexedAccessType");
  function gC(e, t = null) {
    return (0, E.default)({
      type: "JSXAttribute",
      name: e,
      value: t
    });
  }
  s(gC, "jsxAttribute");
  function bC(e) {
    return (0, E.default)({
      type: "JSXClosingElement",
      name: e
    });
  }
  s(bC, "jsxClosingElement");
  function SC(e, t = null, r, i = null) {
    return (0, E.default)({
      type: "JSXElement",
      openingElement: e,
      closingElement: t,
      children: r,
      selfClosing: i
    });
  }
  s(SC, "jsxElement");
  function xC() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  s(xC, "jsxEmptyExpression");
  function EC(e) {
    return (0, E.default)({
      type: "JSXExpressionContainer",
      expression: e
    });
  }
  s(EC, "jsxExpressionContainer");
  function PC(e) {
    return (0, E.default)({
      type: "JSXSpreadChild",
      expression: e
    });
  }
  s(PC, "jsxSpreadChild");
  function AC(e) {
    return (0, E.default)({
      type: "JSXIdentifier",
      name: e
    });
  }
  s(AC, "jsxIdentifier");
  function vC(e, t) {
    return (0, E.default)({
      type: "JSXMemberExpression",
      object: e,
      property: t
    });
  }
  s(vC, "jsxMemberExpression");
  function CC(e, t) {
    return (0, E.default)({
      type: "JSXNamespacedName",
      namespace: e,
      name: t
    });
  }
  s(CC, "jsxNamespacedName");
  function IC(e, t, r = !1) {
    return (0, E.default)({
      type: "JSXOpeningElement",
      name: e,
      attributes: t,
      selfClosing: r
    });
  }
  s(IC, "jsxOpeningElement");
  function wC(e) {
    return (0, E.default)({
      type: "JSXSpreadAttribute",
      argument: e
    });
  }
  s(wC, "jsxSpreadAttribute");
  function OC(e) {
    return (0, E.default)({
      type: "JSXText",
      value: e
    });
  }
  s(OC, "jsxText");
  function NC(e, t, r) {
    return (0, E.default)({
      type: "JSXFragment",
      openingFragment: e,
      closingFragment: t,
      children: r
    });
  }
  s(NC, "jsxFragment");
  function _C() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  s(_C, "jsxOpeningFragment");
  function DC() {
    return {
      type: "JSXClosingFragment"
    };
  }
  s(DC, "jsxClosingFragment");
  function kC() {
    return {
      type: "Noop"
    };
  }
  s(kC, "noop");
  function LC(e, t) {
    return (0, E.default)({
      type: "Placeholder",
      expectedNode: e,
      name: t
    });
  }
  s(LC, "placeholder");
  function MC(e) {
    return (0, E.default)({
      type: "V8IntrinsicIdentifier",
      name: e
    });
  }
  s(MC, "v8IntrinsicIdentifier");
  function FC() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  s(FC, "argumentPlaceholder");
  function BC(e, t) {
    return (0, E.default)({
      type: "BindExpression",
      object: e,
      callee: t
    });
  }
  s(BC, "bindExpression");
  function jC(e, t) {
    return (0, E.default)({
      type: "ImportAttribute",
      key: e,
      value: t
    });
  }
  s(jC, "importAttribute");
  function RC(e) {
    return (0, E.default)({
      type: "Decorator",
      expression: e
    });
  }
  s(RC, "decorator");
  function qC(e, t = !1) {
    return (0, E.default)({
      type: "DoExpression",
      body: e,
      async: t
    });
  }
  s(qC, "doExpression");
  function VC(e) {
    return (0, E.default)({
      type: "ExportDefaultSpecifier",
      exported: e
    });
  }
  s(VC, "exportDefaultSpecifier");
  function UC(e) {
    return (0, E.default)({
      type: "RecordExpression",
      properties: e
    });
  }
  s(UC, "recordExpression");
  function KC(e = []) {
    return (0, E.default)({
      type: "TupleExpression",
      elements: e
    });
  }
  s(KC, "tupleExpression");
  function WC(e) {
    return (0, E.default)({
      type: "DecimalLiteral",
      value: e
    });
  }
  s(WC, "decimalLiteral");
  function YC(e) {
    return (0, E.default)({
      type: "ModuleExpression",
      body: e
    });
  }
  s(YC, "moduleExpression");
  function XC() {
    return {
      type: "TopicReference"
    };
  }
  s(XC, "topicReference");
  function JC(e) {
    return (0, E.default)({
      type: "PipelineTopicExpression",
      expression: e
    });
  }
  s(JC, "pipelineTopicExpression");
  function $C(e) {
    return (0, E.default)({
      type: "PipelineBareFunction",
      callee: e
    });
  }
  s($C, "pipelineBareFunction");
  function HC() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  s(HC, "pipelinePrimaryTopicReference");
  function GC(e) {
    return (0, E.default)({
      type: "TSParameterProperty",
      parameter: e
    });
  }
  s(GC, "tsParameterProperty");
  function zC(e = null, t = null, r, i = null) {
    return (0, E.default)({
      type: "TSDeclareFunction",
      id: e,
      typeParameters: t,
      params: r,
      returnType: i
    });
  }
  s(zC, "tsDeclareFunction");
  function QC(e = null, t, r = null, i, n = null) {
    return (0, E.default)({
      type: "TSDeclareMethod",
      decorators: e,
      key: t,
      typeParameters: r,
      params: i,
      returnType: n
    });
  }
  s(QC, "tsDeclareMethod");
  function ZC(e, t) {
    return (0, E.default)({
      type: "TSQualifiedName",
      left: e,
      right: t
    });
  }
  s(ZC, "tsQualifiedName");
  function eI(e = null, t, r = null) {
    return (0, E.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(eI, "tsCallSignatureDeclaration");
  function tI(e = null, t, r = null) {
    return (0, E.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(tI, "tsConstructSignatureDeclaration");
  function rI(e, t = null) {
    return (0, E.default)({
      type: "TSPropertySignature",
      key: e,
      typeAnnotation: t,
      kind: null
    });
  }
  s(rI, "tsPropertySignature");
  function iI(e, t = null, r, i = null) {
    return (0, E.default)({
      type: "TSMethodSignature",
      key: e,
      typeParameters: t,
      parameters: r,
      typeAnnotation: i,
      kind: null
    });
  }
  s(iI, "tsMethodSignature");
  function sI(e, t = null) {
    return (0, E.default)({
      type: "TSIndexSignature",
      parameters: e,
      typeAnnotation: t
    });
  }
  s(sI, "tsIndexSignature");
  function nI() {
    return {
      type: "TSAnyKeyword"
    };
  }
  s(nI, "tsAnyKeyword");
  function aI() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  s(aI, "tsBooleanKeyword");
  function oI() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  s(oI, "tsBigIntKeyword");
  function lI() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  s(lI, "tsIntrinsicKeyword");
  function uI() {
    return {
      type: "TSNeverKeyword"
    };
  }
  s(uI, "tsNeverKeyword");
  function cI() {
    return {
      type: "TSNullKeyword"
    };
  }
  s(cI, "tsNullKeyword");
  function pI() {
    return {
      type: "TSNumberKeyword"
    };
  }
  s(pI, "tsNumberKeyword");
  function fI() {
    return {
      type: "TSObjectKeyword"
    };
  }
  s(fI, "tsObjectKeyword");
  function hI() {
    return {
      type: "TSStringKeyword"
    };
  }
  s(hI, "tsStringKeyword");
  function dI() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  s(dI, "tsSymbolKeyword");
  function mI() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  s(mI, "tsUndefinedKeyword");
  function yI() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  s(yI, "tsUnknownKeyword");
  function TI() {
    return {
      type: "TSVoidKeyword"
    };
  }
  s(TI, "tsVoidKeyword");
  function gI() {
    return {
      type: "TSThisType"
    };
  }
  s(gI, "tsThisType");
  function bI(e = null, t, r = null) {
    return (0, E.default)({
      type: "TSFunctionType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(bI, "tsFunctionType");
  function SI(e = null, t, r = null) {
    return (0, E.default)({
      type: "TSConstructorType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  s(SI, "tsConstructorType");
  function xI(e, t = null) {
    return (0, E.default)({
      type: "TSTypeReference",
      typeName: e,
      typeParameters: t
    });
  }
  s(xI, "tsTypeReference");
  function EI(e, t = null, r = null) {
    return (0, E.default)({
      type: "TSTypePredicate",
      parameterName: e,
      typeAnnotation: t,
      asserts: r
    });
  }
  s(EI, "tsTypePredicate");
  function PI(e, t = null) {
    return (0, E.default)({
      type: "TSTypeQuery",
      exprName: e,
      typeParameters: t
    });
  }
  s(PI, "tsTypeQuery");
  function AI(e) {
    return (0, E.default)({
      type: "TSTypeLiteral",
      members: e
    });
  }
  s(AI, "tsTypeLiteral");
  function vI(e) {
    return (0, E.default)({
      type: "TSArrayType",
      elementType: e
    });
  }
  s(vI, "tsArrayType");
  function CI(e) {
    return (0, E.default)({
      type: "TSTupleType",
      elementTypes: e
    });
  }
  s(CI, "tsTupleType");
  function II(e) {
    return (0, E.default)({
      type: "TSOptionalType",
      typeAnnotation: e
    });
  }
  s(II, "tsOptionalType");
  function wI(e) {
    return (0, E.default)({
      type: "TSRestType",
      typeAnnotation: e
    });
  }
  s(wI, "tsRestType");
  function OI(e, t, r = !1) {
    return (0, E.default)({
      type: "TSNamedTupleMember",
      label: e,
      elementType: t,
      optional: r
    });
  }
  s(OI, "tsNamedTupleMember");
  function NI(e) {
    return (0, E.default)({
      type: "TSUnionType",
      types: e
    });
  }
  s(NI, "tsUnionType");
  function _I(e) {
    return (0, E.default)({
      type: "TSIntersectionType",
      types: e
    });
  }
  s(_I, "tsIntersectionType");
  function DI(e, t, r, i) {
    return (0, E.default)({
      type: "TSConditionalType",
      checkType: e,
      extendsType: t,
      trueType: r,
      falseType: i
    });
  }
  s(DI, "tsConditionalType");
  function kI(e) {
    return (0, E.default)({
      type: "TSInferType",
      typeParameter: e
    });
  }
  s(kI, "tsInferType");
  function LI(e) {
    return (0, E.default)({
      type: "TSParenthesizedType",
      typeAnnotation: e
    });
  }
  s(LI, "tsParenthesizedType");
  function MI(e) {
    return (0, E.default)({
      type: "TSTypeOperator",
      typeAnnotation: e,
      operator: null
    });
  }
  s(MI, "tsTypeOperator");
  function FI(e, t) {
    return (0, E.default)({
      type: "TSIndexedAccessType",
      objectType: e,
      indexType: t
    });
  }
  s(FI, "tsIndexedAccessType");
  function BI(e, t = null, r = null) {
    return (0, E.default)({
      type: "TSMappedType",
      typeParameter: e,
      typeAnnotation: t,
      nameType: r
    });
  }
  s(BI, "tsMappedType");
  function jI(e) {
    return (0, E.default)({
      type: "TSLiteralType",
      literal: e
    });
  }
  s(jI, "tsLiteralType");
  function RI(e, t = null) {
    return (0, E.default)({
      type: "TSExpressionWithTypeArguments",
      expression: e,
      typeParameters: t
    });
  }
  s(RI, "tsExpressionWithTypeArguments");
  function qI(e, t = null, r = null, i) {
    return (0, E.default)({
      type: "TSInterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    });
  }
  s(qI, "tsInterfaceDeclaration");
  function VI(e) {
    return (0, E.default)({
      type: "TSInterfaceBody",
      body: e
    });
  }
  s(VI, "tsInterfaceBody");
  function UI(e, t = null, r) {
    return (0, E.default)({
      type: "TSTypeAliasDeclaration",
      id: e,
      typeParameters: t,
      typeAnnotation: r
    });
  }
  s(UI, "tsTypeAliasDeclaration");
  function KI(e, t = null) {
    return (0, E.default)({
      type: "TSInstantiationExpression",
      expression: e,
      typeParameters: t
    });
  }
  s(KI, "tsInstantiationExpression");
  function WI(e, t) {
    return (0, E.default)({
      type: "TSAsExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  s(WI, "tsAsExpression");
  function YI(e, t) {
    return (0, E.default)({
      type: "TSSatisfiesExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  s(YI, "tsSatisfiesExpression");
  function XI(e, t) {
    return (0, E.default)({
      type: "TSTypeAssertion",
      typeAnnotation: e,
      expression: t
    });
  }
  s(XI, "tsTypeAssertion");
  function JI(e, t) {
    return (0, E.default)({
      type: "TSEnumDeclaration",
      id: e,
      members: t
    });
  }
  s(JI, "tsEnumDeclaration");
  function $I(e, t = null) {
    return (0, E.default)({
      type: "TSEnumMember",
      id: e,
      initializer: t
    });
  }
  s($I, "tsEnumMember");
  function HI(e, t) {
    return (0, E.default)({
      type: "TSModuleDeclaration",
      id: e,
      body: t
    });
  }
  s(HI, "tsModuleDeclaration");
  function GI(e) {
    return (0, E.default)({
      type: "TSModuleBlock",
      body: e
    });
  }
  s(GI, "tsModuleBlock");
  function zI(e, t = null, r = null) {
    return (0, E.default)({
      type: "TSImportType",
      argument: e,
      qualifier: t,
      typeParameters: r
    });
  }
  s(zI, "tsImportType");
  function QI(e, t) {
    return (0, E.default)({
      type: "TSImportEqualsDeclaration",
      id: e,
      moduleReference: t,
      isExport: null
    });
  }
  s(QI, "tsImportEqualsDeclaration");
  function ZI(e) {
    return (0, E.default)({
      type: "TSExternalModuleReference",
      expression: e
    });
  }
  s(ZI, "tsExternalModuleReference");
  function ew(e) {
    return (0, E.default)({
      type: "TSNonNullExpression",
      expression: e
    });
  }
  s(ew, "tsNonNullExpression");
  function tw(e) {
    return (0, E.default)({
      type: "TSExportAssignment",
      expression: e
    });
  }
  s(tw, "tsExportAssignment");
  function rw(e) {
    return (0, E.default)({
      type: "TSNamespaceExportDeclaration",
      id: e
    });
  }
  s(rw, "tsNamespaceExportDeclaration");
  function iw(e) {
    return (0, E.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: e
    });
  }
  s(iw, "tsTypeAnnotation");
  function sw(e) {
    return (0, E.default)({
      type: "TSTypeParameterInstantiation",
      params: e
    });
  }
  s(sw, "tsTypeParameterInstantiation");
  function nw(e) {
    return (0, E.default)({
      type: "TSTypeParameterDeclaration",
      params: e
    });
  }
  s(nw, "tsTypeParameterDeclaration");
  function aw(e = null, t = null, r) {
    return (0, E.default)({
      type: "TSTypeParameter",
      constraint: e,
      default: t,
      name: r
    });
  }
  s(aw, "tsTypeParameter");
  function ow(e) {
    return (0, Ys.default)("NumberLiteral", "NumericLiteral", "The node type "), of(e);
  }
  s(ow, "NumberLiteral");
  function lw(e, t = "") {
    return (0, Ys.default)("RegexLiteral", "RegExpLiteral", "The node type "), lf(e, t);
  }
  s(lw, "RegexLiteral");
  function uw(e) {
    return (0, Ys.default)("RestProperty", "RestElement", "The node type "), uf(e);
  }
  s(uw, "RestProperty");
  function cw(e) {
    return (0, Ys.default)("SpreadProperty", "SpreadElement", "The node type "), cf(e);
  }
  s(cw, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var pf = v((Xa) => {
  "use strict";
  Object.defineProperty(Xa, "__esModule", {
    value: !0
  });
  Xa.default = hw;
  var pw = ut(), fw = le();
  function hw(e, t) {
    let r = e.value.split(/\r\n|\n|\r/), i = 0;
    for (let a = 0; a < r.length; a++)
      r[a].match(/[^ \t]/) && (i = a);
    let n = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, c = a === i, p = o.replace(/\t/g, " ");
      l || (p = p.replace(/^[ ]+/, "")), u || (p = p.replace(/[ ]+$/, "")), p && (c || (p += " "), n += p);
    }
    n && t.push((0, fw.inherits)((0, pw.stringLiteral)(n), e));
  }
  s(hw, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var ff = v(($a) => {
  "use strict";
  Object.defineProperty($a, "__esModule", {
    value: !0
  });
  $a.default = mw;
  var Ja = We(), dw = pf();
  function mw(e) {
    let t = [];
    for (let r = 0; r < e.children.length; r++) {
      let i = e.children[r];
      if ((0, Ja.isJSXText)(i)) {
        (0, dw.default)(i, t);
        continue;
      }
      (0, Ja.isJSXExpressionContainer)(i) && (i = i.expression), !(0, Ja.isJSXEmptyExpression)(i) && t.push(i);
    }
    return t;
  }
  s(mw, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var Ga = v((Ha) => {
  "use strict";
  Object.defineProperty(Ha, "__esModule", {
    value: !0
  });
  Ha.default = Tw;
  var yw = Et();
  function Tw(e) {
    return !!(e && yw.VISITOR_KEYS[e.type]);
  }
  s(Tw, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var hf = v((za) => {
  "use strict";
  Object.defineProperty(za, "__esModule", {
    value: !0
  });
  za.default = bw;
  var gw = Ga();
  function bw(e) {
    if (!(0, gw.default)(e)) {
      var t;
      let r = (t = e?.type) != null ? t : JSON.stringify(e);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  s(bw, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var df = v((m) => {
  "use strict";
  Object.defineProperty(m, "__esModule", {
    value: !0
  });
  m.assertAccessor = MD;
  m.assertAnyTypeAnnotation = tN;
  m.assertArgumentPlaceholder = N_;
  m.assertArrayExpression = xw;
  m.assertArrayPattern = bO;
  m.assertArrayTypeAnnotation = rN;
  m.assertArrowFunctionExpression = SO;
  m.assertAssignmentExpression = Ew;
  m.assertAssignmentPattern = gO;
  m.assertAwaitExpression = KO;
  m.assertBigIntLiteral = YO;
  m.assertBinary = iD;
  m.assertBinaryExpression = Pw;
  m.assertBindExpression = __;
  m.assertBlock = aD;
  m.assertBlockParent = nD;
  m.assertBlockStatement = Iw;
  m.assertBooleanLiteral = $w;
  m.assertBooleanLiteralTypeAnnotation = sN;
  m.assertBooleanTypeAnnotation = iN;
  m.assertBreakStatement = ww;
  m.assertCallExpression = Ow;
  m.assertCatchClause = Nw;
  m.assertClass = _D;
  m.assertClassAccessorProperty = GO;
  m.assertClassBody = xO;
  m.assertClassDeclaration = PO;
  m.assertClassExpression = EO;
  m.assertClassImplements = aN;
  m.assertClassMethod = MO;
  m.assertClassPrivateMethod = QO;
  m.assertClassPrivateProperty = zO;
  m.assertClassProperty = HO;
  m.assertCompletionStatement = uD;
  m.assertConditional = cD;
  m.assertConditionalExpression = _w;
  m.assertContinueStatement = Dw;
  m.assertDebuggerStatement = kw;
  m.assertDecimalLiteral = j_;
  m.assertDeclaration = bD;
  m.assertDeclareClass = oN;
  m.assertDeclareExportAllDeclaration = yN;
  m.assertDeclareExportDeclaration = mN;
  m.assertDeclareFunction = lN;
  m.assertDeclareInterface = uN;
  m.assertDeclareModule = cN;
  m.assertDeclareModuleExports = pN;
  m.assertDeclareOpaqueType = hN;
  m.assertDeclareTypeAlias = fN;
  m.assertDeclareVariable = dN;
  m.assertDeclaredPredicate = TN;
  m.assertDecorator = k_;
  m.assertDirective = vw;
  m.assertDirectiveLiteral = Cw;
  m.assertDoExpression = L_;
  m.assertDoWhileStatement = Lw;
  m.assertEmptyStatement = Mw;
  m.assertEmptyTypeAnnotation = wN;
  m.assertEnumBody = UD;
  m.assertEnumBooleanBody = r_;
  m.assertEnumBooleanMember = a_;
  m.assertEnumDeclaration = t_;
  m.assertEnumDefaultedMember = u_;
  m.assertEnumMember = KD;
  m.assertEnumNumberBody = i_;
  m.assertEnumNumberMember = o_;
  m.assertEnumStringBody = s_;
  m.assertEnumStringMember = l_;
  m.assertEnumSymbolBody = n_;
  m.assertExistsTypeAnnotation = gN;
  m.assertExportAllDeclaration = AO;
  m.assertExportDeclaration = kD;
  m.assertExportDefaultDeclaration = vO;
  m.assertExportDefaultSpecifier = M_;
  m.assertExportNamedDeclaration = CO;
  m.assertExportNamespaceSpecifier = XO;
  m.assertExportSpecifier = IO;
  m.assertExpression = rD;
  m.assertExpressionStatement = Fw;
  m.assertExpressionWrapper = hD;
  m.assertFile = Bw;
  m.assertFlow = BD;
  m.assertFlowBaseAnnotation = RD;
  m.assertFlowDeclaration = qD;
  m.assertFlowPredicate = VD;
  m.assertFlowType = jD;
  m.assertFor = dD;
  m.assertForInStatement = jw;
  m.assertForOfStatement = wO;
  m.assertForStatement = Rw;
  m.assertForXStatement = mD;
  m.assertFunction = yD;
  m.assertFunctionDeclaration = qw;
  m.assertFunctionExpression = Vw;
  m.assertFunctionParent = TD;
  m.assertFunctionTypeAnnotation = bN;
  m.assertFunctionTypeParam = SN;
  m.assertGenericTypeAnnotation = xN;
  m.assertIdentifier = Uw;
  m.assertIfStatement = Kw;
  m.assertImmutable = AD;
  m.assertImport = WO;
  m.assertImportAttribute = D_;
  m.assertImportDeclaration = OO;
  m.assertImportDefaultSpecifier = NO;
  m.assertImportExpression = kO;
  m.assertImportNamespaceSpecifier = _O;
  m.assertImportOrExportDeclaration = DD;
  m.assertImportSpecifier = DO;
  m.assertIndexedAccessType = c_;
  m.assertInferredPredicate = EN;
  m.assertInterfaceDeclaration = AN;
  m.assertInterfaceExtends = PN;
  m.assertInterfaceTypeAnnotation = vN;
  m.assertInterpreterDirective = Aw;
  m.assertIntersectionTypeAnnotation = CN;
  m.assertJSX = WD;
  m.assertJSXAttribute = f_;
  m.assertJSXClosingElement = h_;
  m.assertJSXClosingFragment = C_;
  m.assertJSXElement = d_;
  m.assertJSXEmptyExpression = m_;
  m.assertJSXExpressionContainer = y_;
  m.assertJSXFragment = A_;
  m.assertJSXIdentifier = g_;
  m.assertJSXMemberExpression = b_;
  m.assertJSXNamespacedName = S_;
  m.assertJSXOpeningElement = x_;
  m.assertJSXOpeningFragment = v_;
  m.assertJSXSpreadAttribute = E_;
  m.assertJSXSpreadChild = T_;
  m.assertJSXText = P_;
  m.assertLVal = xD;
  m.assertLabeledStatement = Ww;
  m.assertLiteral = PD;
  m.assertLogicalExpression = Gw;
  m.assertLoop = pD;
  m.assertMemberExpression = zw;
  m.assertMetaProperty = LO;
  m.assertMethod = CD;
  m.assertMiscellaneous = YD;
  m.assertMixedTypeAnnotation = IN;
  m.assertModuleDeclaration = ek;
  m.assertModuleExpression = R_;
  m.assertModuleSpecifier = LD;
  m.assertNewExpression = Qw;
  m.assertNoop = I_;
  m.assertNullLiteral = Jw;
  m.assertNullLiteralTypeAnnotation = nN;
  m.assertNullableTypeAnnotation = ON;
  m.assertNumberLiteral = GD;
  m.assertNumberLiteralTypeAnnotation = NN;
  m.assertNumberTypeAnnotation = _N;
  m.assertNumericLiteral = Xw;
  m.assertObjectExpression = eO;
  m.assertObjectMember = ID;
  m.assertObjectMethod = tO;
  m.assertObjectPattern = FO;
  m.assertObjectProperty = rO;
  m.assertObjectTypeAnnotation = DN;
  m.assertObjectTypeCallProperty = LN;
  m.assertObjectTypeIndexer = MN;
  m.assertObjectTypeInternalSlot = kN;
  m.assertObjectTypeProperty = FN;
  m.assertObjectTypeSpreadProperty = BN;
  m.assertOpaqueType = jN;
  m.assertOptionalCallExpression = $O;
  m.assertOptionalIndexedAccessType = p_;
  m.assertOptionalMemberExpression = JO;
  m.assertParenthesizedExpression = aO;
  m.assertPattern = ND;
  m.assertPatternLike = SD;
  m.assertPipelineBareFunction = U_;
  m.assertPipelinePrimaryTopicReference = K_;
  m.assertPipelineTopicExpression = V_;
  m.assertPlaceholder = w_;
  m.assertPrivate = FD;
  m.assertPrivateName = ZO;
  m.assertProgram = Zw;
  m.assertProperty = wD;
  m.assertPureish = gD;
  m.assertQualifiedTypeIdentifier = RN;
  m.assertRecordExpression = F_;
  m.assertRegExpLiteral = Hw;
  m.assertRegexLiteral = zD;
  m.assertRestElement = iO;
  m.assertRestProperty = QD;
  m.assertReturnStatement = sO;
  m.assertScopable = sD;
  m.assertSequenceExpression = nO;
  m.assertSpreadElement = BO;
  m.assertSpreadProperty = ZD;
  m.assertStandardized = tD;
  m.assertStatement = oD;
  m.assertStaticBlock = eN;
  m.assertStringLiteral = Yw;
  m.assertStringLiteralTypeAnnotation = qN;
  m.assertStringTypeAnnotation = VN;
  m.assertSuper = jO;
  m.assertSwitchCase = oO;
  m.assertSwitchStatement = lO;
  m.assertSymbolTypeAnnotation = UN;
  m.assertTSAnyKeyword = Z_;
  m.assertTSArrayType = b2;
  m.assertTSAsExpression = j2;
  m.assertTSBaseType = HD;
  m.assertTSBigIntKeyword = t2;
  m.assertTSBooleanKeyword = e2;
  m.assertTSCallSignatureDeclaration = $_;
  m.assertTSConditionalType = C2;
  m.assertTSConstructSignatureDeclaration = H_;
  m.assertTSConstructorType = d2;
  m.assertTSDeclareFunction = Y_;
  m.assertTSDeclareMethod = X_;
  m.assertTSEntityName = ED;
  m.assertTSEnumDeclaration = V2;
  m.assertTSEnumMember = U2;
  m.assertTSExportAssignment = H2;
  m.assertTSExpressionWithTypeArguments = k2;
  m.assertTSExternalModuleReference = J2;
  m.assertTSFunctionType = h2;
  m.assertTSImportEqualsDeclaration = X2;
  m.assertTSImportType = Y2;
  m.assertTSIndexSignature = Q_;
  m.assertTSIndexedAccessType = N2;
  m.assertTSInferType = I2;
  m.assertTSInstantiationExpression = B2;
  m.assertTSInterfaceBody = M2;
  m.assertTSInterfaceDeclaration = L2;
  m.assertTSIntersectionType = v2;
  m.assertTSIntrinsicKeyword = r2;
  m.assertTSLiteralType = D2;
  m.assertTSMappedType = _2;
  m.assertTSMethodSignature = z_;
  m.assertTSModuleBlock = W2;
  m.assertTSModuleDeclaration = K2;
  m.assertTSNamedTupleMember = P2;
  m.assertTSNamespaceExportDeclaration = G2;
  m.assertTSNeverKeyword = i2;
  m.assertTSNonNullExpression = $2;
  m.assertTSNullKeyword = s2;
  m.assertTSNumberKeyword = n2;
  m.assertTSObjectKeyword = a2;
  m.assertTSOptionalType = x2;
  m.assertTSParameterProperty = W_;
  m.assertTSParenthesizedType = w2;
  m.assertTSPropertySignature = G_;
  m.assertTSQualifiedName = J_;
  m.assertTSRestType = E2;
  m.assertTSSatisfiesExpression = R2;
  m.assertTSStringKeyword = o2;
  m.assertTSSymbolKeyword = l2;
  m.assertTSThisType = f2;
  m.assertTSTupleType = S2;
  m.assertTSType = $D;
  m.assertTSTypeAliasDeclaration = F2;
  m.assertTSTypeAnnotation = z2;
  m.assertTSTypeAssertion = q2;
  m.assertTSTypeElement = JD;
  m.assertTSTypeLiteral = g2;
  m.assertTSTypeOperator = O2;
  m.assertTSTypeParameter = eD;
  m.assertTSTypeParameterDeclaration = Z2;
  m.assertTSTypeParameterInstantiation = Q2;
  m.assertTSTypePredicate = y2;
  m.assertTSTypeQuery = T2;
  m.assertTSTypeReference = m2;
  m.assertTSUndefinedKeyword = u2;
  m.assertTSUnionType = A2;
  m.assertTSUnknownKeyword = c2;
  m.assertTSVoidKeyword = p2;
  m.assertTaggedTemplateExpression = RO;
  m.assertTemplateElement = qO;
  m.assertTemplateLiteral = VO;
  m.assertTerminatorless = lD;
  m.assertThisExpression = uO;
  m.assertThisTypeAnnotation = KN;
  m.assertThrowStatement = cO;
  m.assertTopicReference = q_;
  m.assertTryStatement = pO;
  m.assertTupleExpression = B_;
  m.assertTupleTypeAnnotation = WN;
  m.assertTypeAlias = XN;
  m.assertTypeAnnotation = JN;
  m.assertTypeCastExpression = $N;
  m.assertTypeParameter = HN;
  m.assertTypeParameterDeclaration = GN;
  m.assertTypeParameterInstantiation = zN;
  m.assertTypeScript = XD;
  m.assertTypeofTypeAnnotation = YN;
  m.assertUnaryExpression = fO;
  m.assertUnaryLike = OD;
  m.assertUnionTypeAnnotation = QN;
  m.assertUpdateExpression = hO;
  m.assertUserWhitespacable = vD;
  m.assertV8IntrinsicIdentifier = O_;
  m.assertVariableDeclaration = dO;
  m.assertVariableDeclarator = mO;
  m.assertVariance = ZN;
  m.assertVoidTypeAnnotation = e_;
  m.assertWhile = fD;
  m.assertWhileStatement = yO;
  m.assertWithStatement = TO;
  m.assertYieldExpression = UO;
  var Sw = zr(), Vi = Oi();
  function y(e, t, r) {
    if (!(0, Sw.default)(e, t, r))
      throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
  }
  s(y, "assert");
  function xw(e, t) {
    y("ArrayExpression", e, t);
  }
  s(xw, "assertArrayExpression");
  function Ew(e, t) {
    y("AssignmentExpression", e, t);
  }
  s(Ew, "assertAssignmentExpression");
  function Pw(e, t) {
    y("BinaryExpression", e, t);
  }
  s(Pw, "assertBinaryExpression");
  function Aw(e, t) {
    y("InterpreterDirective", e, t);
  }
  s(Aw, "assertInterpreterDirective");
  function vw(e, t) {
    y("Directive", e, t);
  }
  s(vw, "assertDirective");
  function Cw(e, t) {
    y("DirectiveLiteral", e, t);
  }
  s(Cw, "assertDirectiveLiteral");
  function Iw(e, t) {
    y("BlockStatement", e, t);
  }
  s(Iw, "assertBlockStatement");
  function ww(e, t) {
    y("BreakStatement", e, t);
  }
  s(ww, "assertBreakStatement");
  function Ow(e, t) {
    y("CallExpression", e, t);
  }
  s(Ow, "assertCallExpression");
  function Nw(e, t) {
    y("CatchClause", e, t);
  }
  s(Nw, "assertCatchClause");
  function _w(e, t) {
    y("ConditionalExpression", e, t);
  }
  s(_w, "assertConditionalExpression");
  function Dw(e, t) {
    y("ContinueStatement", e, t);
  }
  s(Dw, "assertContinueStatement");
  function kw(e, t) {
    y("DebuggerStatement", e, t);
  }
  s(kw, "assertDebuggerStatement");
  function Lw(e, t) {
    y("DoWhileStatement", e, t);
  }
  s(Lw, "assertDoWhileStatement");
  function Mw(e, t) {
    y("EmptyStatement", e, t);
  }
  s(Mw, "assertEmptyStatement");
  function Fw(e, t) {
    y("ExpressionStatement", e, t);
  }
  s(Fw, "assertExpressionStatement");
  function Bw(e, t) {
    y("File", e, t);
  }
  s(Bw, "assertFile");
  function jw(e, t) {
    y("ForInStatement", e, t);
  }
  s(jw, "assertForInStatement");
  function Rw(e, t) {
    y("ForStatement", e, t);
  }
  s(Rw, "assertForStatement");
  function qw(e, t) {
    y("FunctionDeclaration", e, t);
  }
  s(qw, "assertFunctionDeclaration");
  function Vw(e, t) {
    y("FunctionExpression", e, t);
  }
  s(Vw, "assertFunctionExpression");
  function Uw(e, t) {
    y("Identifier", e, t);
  }
  s(Uw, "assertIdentifier");
  function Kw(e, t) {
    y("IfStatement", e, t);
  }
  s(Kw, "assertIfStatement");
  function Ww(e, t) {
    y("LabeledStatement", e, t);
  }
  s(Ww, "assertLabeledStatement");
  function Yw(e, t) {
    y("StringLiteral", e, t);
  }
  s(Yw, "assertStringLiteral");
  function Xw(e, t) {
    y("NumericLiteral", e, t);
  }
  s(Xw, "assertNumericLiteral");
  function Jw(e, t) {
    y("NullLiteral", e, t);
  }
  s(Jw, "assertNullLiteral");
  function $w(e, t) {
    y("BooleanLiteral", e, t);
  }
  s($w, "assertBooleanLiteral");
  function Hw(e, t) {
    y("RegExpLiteral", e, t);
  }
  s(Hw, "assertRegExpLiteral");
  function Gw(e, t) {
    y("LogicalExpression", e, t);
  }
  s(Gw, "assertLogicalExpression");
  function zw(e, t) {
    y("MemberExpression", e, t);
  }
  s(zw, "assertMemberExpression");
  function Qw(e, t) {
    y("NewExpression", e, t);
  }
  s(Qw, "assertNewExpression");
  function Zw(e, t) {
    y("Program", e, t);
  }
  s(Zw, "assertProgram");
  function eO(e, t) {
    y("ObjectExpression", e, t);
  }
  s(eO, "assertObjectExpression");
  function tO(e, t) {
    y("ObjectMethod", e, t);
  }
  s(tO, "assertObjectMethod");
  function rO(e, t) {
    y("ObjectProperty", e, t);
  }
  s(rO, "assertObjectProperty");
  function iO(e, t) {
    y("RestElement", e, t);
  }
  s(iO, "assertRestElement");
  function sO(e, t) {
    y("ReturnStatement", e, t);
  }
  s(sO, "assertReturnStatement");
  function nO(e, t) {
    y("SequenceExpression", e, t);
  }
  s(nO, "assertSequenceExpression");
  function aO(e, t) {
    y("ParenthesizedExpression", e, t);
  }
  s(aO, "assertParenthesizedExpression");
  function oO(e, t) {
    y("SwitchCase", e, t);
  }
  s(oO, "assertSwitchCase");
  function lO(e, t) {
    y("SwitchStatement", e, t);
  }
  s(lO, "assertSwitchStatement");
  function uO(e, t) {
    y("ThisExpression", e, t);
  }
  s(uO, "assertThisExpression");
  function cO(e, t) {
    y("ThrowStatement", e, t);
  }
  s(cO, "assertThrowStatement");
  function pO(e, t) {
    y("TryStatement", e, t);
  }
  s(pO, "assertTryStatement");
  function fO(e, t) {
    y("UnaryExpression", e, t);
  }
  s(fO, "assertUnaryExpression");
  function hO(e, t) {
    y("UpdateExpression", e, t);
  }
  s(hO, "assertUpdateExpression");
  function dO(e, t) {
    y("VariableDeclaration", e, t);
  }
  s(dO, "assertVariableDeclaration");
  function mO(e, t) {
    y("VariableDeclarator", e, t);
  }
  s(mO, "assertVariableDeclarator");
  function yO(e, t) {
    y("WhileStatement", e, t);
  }
  s(yO, "assertWhileStatement");
  function TO(e, t) {
    y("WithStatement", e, t);
  }
  s(TO, "assertWithStatement");
  function gO(e, t) {
    y("AssignmentPattern", e, t);
  }
  s(gO, "assertAssignmentPattern");
  function bO(e, t) {
    y("ArrayPattern", e, t);
  }
  s(bO, "assertArrayPattern");
  function SO(e, t) {
    y("ArrowFunctionExpression", e, t);
  }
  s(SO, "assertArrowFunctionExpression");
  function xO(e, t) {
    y("ClassBody", e, t);
  }
  s(xO, "assertClassBody");
  function EO(e, t) {
    y("ClassExpression", e, t);
  }
  s(EO, "assertClassExpression");
  function PO(e, t) {
    y("ClassDeclaration", e, t);
  }
  s(PO, "assertClassDeclaration");
  function AO(e, t) {
    y("ExportAllDeclaration", e, t);
  }
  s(AO, "assertExportAllDeclaration");
  function vO(e, t) {
    y("ExportDefaultDeclaration", e, t);
  }
  s(vO, "assertExportDefaultDeclaration");
  function CO(e, t) {
    y("ExportNamedDeclaration", e, t);
  }
  s(CO, "assertExportNamedDeclaration");
  function IO(e, t) {
    y("ExportSpecifier", e, t);
  }
  s(IO, "assertExportSpecifier");
  function wO(e, t) {
    y("ForOfStatement", e, t);
  }
  s(wO, "assertForOfStatement");
  function OO(e, t) {
    y("ImportDeclaration", e, t);
  }
  s(OO, "assertImportDeclaration");
  function NO(e, t) {
    y("ImportDefaultSpecifier", e, t);
  }
  s(NO, "assertImportDefaultSpecifier");
  function _O(e, t) {
    y("ImportNamespaceSpecifier", e, t);
  }
  s(_O, "assertImportNamespaceSpecifier");
  function DO(e, t) {
    y("ImportSpecifier", e, t);
  }
  s(DO, "assertImportSpecifier");
  function kO(e, t) {
    y("ImportExpression", e, t);
  }
  s(kO, "assertImportExpression");
  function LO(e, t) {
    y("MetaProperty", e, t);
  }
  s(LO, "assertMetaProperty");
  function MO(e, t) {
    y("ClassMethod", e, t);
  }
  s(MO, "assertClassMethod");
  function FO(e, t) {
    y("ObjectPattern", e, t);
  }
  s(FO, "assertObjectPattern");
  function BO(e, t) {
    y("SpreadElement", e, t);
  }
  s(BO, "assertSpreadElement");
  function jO(e, t) {
    y("Super", e, t);
  }
  s(jO, "assertSuper");
  function RO(e, t) {
    y("TaggedTemplateExpression", e, t);
  }
  s(RO, "assertTaggedTemplateExpression");
  function qO(e, t) {
    y("TemplateElement", e, t);
  }
  s(qO, "assertTemplateElement");
  function VO(e, t) {
    y("TemplateLiteral", e, t);
  }
  s(VO, "assertTemplateLiteral");
  function UO(e, t) {
    y("YieldExpression", e, t);
  }
  s(UO, "assertYieldExpression");
  function KO(e, t) {
    y("AwaitExpression", e, t);
  }
  s(KO, "assertAwaitExpression");
  function WO(e, t) {
    y("Import", e, t);
  }
  s(WO, "assertImport");
  function YO(e, t) {
    y("BigIntLiteral", e, t);
  }
  s(YO, "assertBigIntLiteral");
  function XO(e, t) {
    y("ExportNamespaceSpecifier", e, t);
  }
  s(XO, "assertExportNamespaceSpecifier");
  function JO(e, t) {
    y("OptionalMemberExpression", e, t);
  }
  s(JO, "assertOptionalMemberExpression");
  function $O(e, t) {
    y("OptionalCallExpression", e, t);
  }
  s($O, "assertOptionalCallExpression");
  function HO(e, t) {
    y("ClassProperty", e, t);
  }
  s(HO, "assertClassProperty");
  function GO(e, t) {
    y("ClassAccessorProperty", e, t);
  }
  s(GO, "assertClassAccessorProperty");
  function zO(e, t) {
    y("ClassPrivateProperty", e, t);
  }
  s(zO, "assertClassPrivateProperty");
  function QO(e, t) {
    y("ClassPrivateMethod", e, t);
  }
  s(QO, "assertClassPrivateMethod");
  function ZO(e, t) {
    y("PrivateName", e, t);
  }
  s(ZO, "assertPrivateName");
  function eN(e, t) {
    y("StaticBlock", e, t);
  }
  s(eN, "assertStaticBlock");
  function tN(e, t) {
    y("AnyTypeAnnotation", e, t);
  }
  s(tN, "assertAnyTypeAnnotation");
  function rN(e, t) {
    y("ArrayTypeAnnotation", e, t);
  }
  s(rN, "assertArrayTypeAnnotation");
  function iN(e, t) {
    y("BooleanTypeAnnotation", e, t);
  }
  s(iN, "assertBooleanTypeAnnotation");
  function sN(e, t) {
    y("BooleanLiteralTypeAnnotation", e, t);
  }
  s(sN, "assertBooleanLiteralTypeAnnotation");
  function nN(e, t) {
    y("NullLiteralTypeAnnotation", e, t);
  }
  s(nN, "assertNullLiteralTypeAnnotation");
  function aN(e, t) {
    y("ClassImplements", e, t);
  }
  s(aN, "assertClassImplements");
  function oN(e, t) {
    y("DeclareClass", e, t);
  }
  s(oN, "assertDeclareClass");
  function lN(e, t) {
    y("DeclareFunction", e, t);
  }
  s(lN, "assertDeclareFunction");
  function uN(e, t) {
    y("DeclareInterface", e, t);
  }
  s(uN, "assertDeclareInterface");
  function cN(e, t) {
    y("DeclareModule", e, t);
  }
  s(cN, "assertDeclareModule");
  function pN(e, t) {
    y("DeclareModuleExports", e, t);
  }
  s(pN, "assertDeclareModuleExports");
  function fN(e, t) {
    y("DeclareTypeAlias", e, t);
  }
  s(fN, "assertDeclareTypeAlias");
  function hN(e, t) {
    y("DeclareOpaqueType", e, t);
  }
  s(hN, "assertDeclareOpaqueType");
  function dN(e, t) {
    y("DeclareVariable", e, t);
  }
  s(dN, "assertDeclareVariable");
  function mN(e, t) {
    y("DeclareExportDeclaration", e, t);
  }
  s(mN, "assertDeclareExportDeclaration");
  function yN(e, t) {
    y("DeclareExportAllDeclaration", e, t);
  }
  s(yN, "assertDeclareExportAllDeclaration");
  function TN(e, t) {
    y("DeclaredPredicate", e, t);
  }
  s(TN, "assertDeclaredPredicate");
  function gN(e, t) {
    y("ExistsTypeAnnotation", e, t);
  }
  s(gN, "assertExistsTypeAnnotation");
  function bN(e, t) {
    y("FunctionTypeAnnotation", e, t);
  }
  s(bN, "assertFunctionTypeAnnotation");
  function SN(e, t) {
    y("FunctionTypeParam", e, t);
  }
  s(SN, "assertFunctionTypeParam");
  function xN(e, t) {
    y("GenericTypeAnnotation", e, t);
  }
  s(xN, "assertGenericTypeAnnotation");
  function EN(e, t) {
    y("InferredPredicate", e, t);
  }
  s(EN, "assertInferredPredicate");
  function PN(e, t) {
    y("InterfaceExtends", e, t);
  }
  s(PN, "assertInterfaceExtends");
  function AN(e, t) {
    y("InterfaceDeclaration", e, t);
  }
  s(AN, "assertInterfaceDeclaration");
  function vN(e, t) {
    y("InterfaceTypeAnnotation", e, t);
  }
  s(vN, "assertInterfaceTypeAnnotation");
  function CN(e, t) {
    y("IntersectionTypeAnnotation", e, t);
  }
  s(CN, "assertIntersectionTypeAnnotation");
  function IN(e, t) {
    y("MixedTypeAnnotation", e, t);
  }
  s(IN, "assertMixedTypeAnnotation");
  function wN(e, t) {
    y("EmptyTypeAnnotation", e, t);
  }
  s(wN, "assertEmptyTypeAnnotation");
  function ON(e, t) {
    y("NullableTypeAnnotation", e, t);
  }
  s(ON, "assertNullableTypeAnnotation");
  function NN(e, t) {
    y("NumberLiteralTypeAnnotation", e, t);
  }
  s(NN, "assertNumberLiteralTypeAnnotation");
  function _N(e, t) {
    y("NumberTypeAnnotation", e, t);
  }
  s(_N, "assertNumberTypeAnnotation");
  function DN(e, t) {
    y("ObjectTypeAnnotation", e, t);
  }
  s(DN, "assertObjectTypeAnnotation");
  function kN(e, t) {
    y("ObjectTypeInternalSlot", e, t);
  }
  s(kN, "assertObjectTypeInternalSlot");
  function LN(e, t) {
    y("ObjectTypeCallProperty", e, t);
  }
  s(LN, "assertObjectTypeCallProperty");
  function MN(e, t) {
    y("ObjectTypeIndexer", e, t);
  }
  s(MN, "assertObjectTypeIndexer");
  function FN(e, t) {
    y("ObjectTypeProperty", e, t);
  }
  s(FN, "assertObjectTypeProperty");
  function BN(e, t) {
    y("ObjectTypeSpreadProperty", e, t);
  }
  s(BN, "assertObjectTypeSpreadProperty");
  function jN(e, t) {
    y("OpaqueType", e, t);
  }
  s(jN, "assertOpaqueType");
  function RN(e, t) {
    y("QualifiedTypeIdentifier", e, t);
  }
  s(RN, "assertQualifiedTypeIdentifier");
  function qN(e, t) {
    y("StringLiteralTypeAnnotation", e, t);
  }
  s(qN, "assertStringLiteralTypeAnnotation");
  function VN(e, t) {
    y("StringTypeAnnotation", e, t);
  }
  s(VN, "assertStringTypeAnnotation");
  function UN(e, t) {
    y("SymbolTypeAnnotation", e, t);
  }
  s(UN, "assertSymbolTypeAnnotation");
  function KN(e, t) {
    y("ThisTypeAnnotation", e, t);
  }
  s(KN, "assertThisTypeAnnotation");
  function WN(e, t) {
    y("TupleTypeAnnotation", e, t);
  }
  s(WN, "assertTupleTypeAnnotation");
  function YN(e, t) {
    y("TypeofTypeAnnotation", e, t);
  }
  s(YN, "assertTypeofTypeAnnotation");
  function XN(e, t) {
    y("TypeAlias", e, t);
  }
  s(XN, "assertTypeAlias");
  function JN(e, t) {
    y("TypeAnnotation", e, t);
  }
  s(JN, "assertTypeAnnotation");
  function $N(e, t) {
    y("TypeCastExpression", e, t);
  }
  s($N, "assertTypeCastExpression");
  function HN(e, t) {
    y("TypeParameter", e, t);
  }
  s(HN, "assertTypeParameter");
  function GN(e, t) {
    y("TypeParameterDeclaration", e, t);
  }
  s(GN, "assertTypeParameterDeclaration");
  function zN(e, t) {
    y("TypeParameterInstantiation", e, t);
  }
  s(zN, "assertTypeParameterInstantiation");
  function QN(e, t) {
    y("UnionTypeAnnotation", e, t);
  }
  s(QN, "assertUnionTypeAnnotation");
  function ZN(e, t) {
    y("Variance", e, t);
  }
  s(ZN, "assertVariance");
  function e_(e, t) {
    y("VoidTypeAnnotation", e, t);
  }
  s(e_, "assertVoidTypeAnnotation");
  function t_(e, t) {
    y("EnumDeclaration", e, t);
  }
  s(t_, "assertEnumDeclaration");
  function r_(e, t) {
    y("EnumBooleanBody", e, t);
  }
  s(r_, "assertEnumBooleanBody");
  function i_(e, t) {
    y("EnumNumberBody", e, t);
  }
  s(i_, "assertEnumNumberBody");
  function s_(e, t) {
    y("EnumStringBody", e, t);
  }
  s(s_, "assertEnumStringBody");
  function n_(e, t) {
    y("EnumSymbolBody", e, t);
  }
  s(n_, "assertEnumSymbolBody");
  function a_(e, t) {
    y("EnumBooleanMember", e, t);
  }
  s(a_, "assertEnumBooleanMember");
  function o_(e, t) {
    y("EnumNumberMember", e, t);
  }
  s(o_, "assertEnumNumberMember");
  function l_(e, t) {
    y("EnumStringMember", e, t);
  }
  s(l_, "assertEnumStringMember");
  function u_(e, t) {
    y("EnumDefaultedMember", e, t);
  }
  s(u_, "assertEnumDefaultedMember");
  function c_(e, t) {
    y("IndexedAccessType", e, t);
  }
  s(c_, "assertIndexedAccessType");
  function p_(e, t) {
    y("OptionalIndexedAccessType", e, t);
  }
  s(p_, "assertOptionalIndexedAccessType");
  function f_(e, t) {
    y("JSXAttribute", e, t);
  }
  s(f_, "assertJSXAttribute");
  function h_(e, t) {
    y("JSXClosingElement", e, t);
  }
  s(h_, "assertJSXClosingElement");
  function d_(e, t) {
    y("JSXElement", e, t);
  }
  s(d_, "assertJSXElement");
  function m_(e, t) {
    y("JSXEmptyExpression", e, t);
  }
  s(m_, "assertJSXEmptyExpression");
  function y_(e, t) {
    y("JSXExpressionContainer", e, t);
  }
  s(y_, "assertJSXExpressionContainer");
  function T_(e, t) {
    y("JSXSpreadChild", e, t);
  }
  s(T_, "assertJSXSpreadChild");
  function g_(e, t) {
    y("JSXIdentifier", e, t);
  }
  s(g_, "assertJSXIdentifier");
  function b_(e, t) {
    y("JSXMemberExpression", e, t);
  }
  s(b_, "assertJSXMemberExpression");
  function S_(e, t) {
    y("JSXNamespacedName", e, t);
  }
  s(S_, "assertJSXNamespacedName");
  function x_(e, t) {
    y("JSXOpeningElement", e, t);
  }
  s(x_, "assertJSXOpeningElement");
  function E_(e, t) {
    y("JSXSpreadAttribute", e, t);
  }
  s(E_, "assertJSXSpreadAttribute");
  function P_(e, t) {
    y("JSXText", e, t);
  }
  s(P_, "assertJSXText");
  function A_(e, t) {
    y("JSXFragment", e, t);
  }
  s(A_, "assertJSXFragment");
  function v_(e, t) {
    y("JSXOpeningFragment", e, t);
  }
  s(v_, "assertJSXOpeningFragment");
  function C_(e, t) {
    y("JSXClosingFragment", e, t);
  }
  s(C_, "assertJSXClosingFragment");
  function I_(e, t) {
    y("Noop", e, t);
  }
  s(I_, "assertNoop");
  function w_(e, t) {
    y("Placeholder", e, t);
  }
  s(w_, "assertPlaceholder");
  function O_(e, t) {
    y("V8IntrinsicIdentifier", e, t);
  }
  s(O_, "assertV8IntrinsicIdentifier");
  function N_(e, t) {
    y("ArgumentPlaceholder", e, t);
  }
  s(N_, "assertArgumentPlaceholder");
  function __(e, t) {
    y("BindExpression", e, t);
  }
  s(__, "assertBindExpression");
  function D_(e, t) {
    y("ImportAttribute", e, t);
  }
  s(D_, "assertImportAttribute");
  function k_(e, t) {
    y("Decorator", e, t);
  }
  s(k_, "assertDecorator");
  function L_(e, t) {
    y("DoExpression", e, t);
  }
  s(L_, "assertDoExpression");
  function M_(e, t) {
    y("ExportDefaultSpecifier", e, t);
  }
  s(M_, "assertExportDefaultSpecifier");
  function F_(e, t) {
    y("RecordExpression", e, t);
  }
  s(F_, "assertRecordExpression");
  function B_(e, t) {
    y("TupleExpression", e, t);
  }
  s(B_, "assertTupleExpression");
  function j_(e, t) {
    y("DecimalLiteral", e, t);
  }
  s(j_, "assertDecimalLiteral");
  function R_(e, t) {
    y("ModuleExpression", e, t);
  }
  s(R_, "assertModuleExpression");
  function q_(e, t) {
    y("TopicReference", e, t);
  }
  s(q_, "assertTopicReference");
  function V_(e, t) {
    y("PipelineTopicExpression", e, t);
  }
  s(V_, "assertPipelineTopicExpression");
  function U_(e, t) {
    y("PipelineBareFunction", e, t);
  }
  s(U_, "assertPipelineBareFunction");
  function K_(e, t) {
    y("PipelinePrimaryTopicReference", e, t);
  }
  s(K_, "assertPipelinePrimaryTopicReference");
  function W_(e, t) {
    y("TSParameterProperty", e, t);
  }
  s(W_, "assertTSParameterProperty");
  function Y_(e, t) {
    y("TSDeclareFunction", e, t);
  }
  s(Y_, "assertTSDeclareFunction");
  function X_(e, t) {
    y("TSDeclareMethod", e, t);
  }
  s(X_, "assertTSDeclareMethod");
  function J_(e, t) {
    y("TSQualifiedName", e, t);
  }
  s(J_, "assertTSQualifiedName");
  function $_(e, t) {
    y("TSCallSignatureDeclaration", e, t);
  }
  s($_, "assertTSCallSignatureDeclaration");
  function H_(e, t) {
    y("TSConstructSignatureDeclaration", e, t);
  }
  s(H_, "assertTSConstructSignatureDeclaration");
  function G_(e, t) {
    y("TSPropertySignature", e, t);
  }
  s(G_, "assertTSPropertySignature");
  function z_(e, t) {
    y("TSMethodSignature", e, t);
  }
  s(z_, "assertTSMethodSignature");
  function Q_(e, t) {
    y("TSIndexSignature", e, t);
  }
  s(Q_, "assertTSIndexSignature");
  function Z_(e, t) {
    y("TSAnyKeyword", e, t);
  }
  s(Z_, "assertTSAnyKeyword");
  function e2(e, t) {
    y("TSBooleanKeyword", e, t);
  }
  s(e2, "assertTSBooleanKeyword");
  function t2(e, t) {
    y("TSBigIntKeyword", e, t);
  }
  s(t2, "assertTSBigIntKeyword");
  function r2(e, t) {
    y("TSIntrinsicKeyword", e, t);
  }
  s(r2, "assertTSIntrinsicKeyword");
  function i2(e, t) {
    y("TSNeverKeyword", e, t);
  }
  s(i2, "assertTSNeverKeyword");
  function s2(e, t) {
    y("TSNullKeyword", e, t);
  }
  s(s2, "assertTSNullKeyword");
  function n2(e, t) {
    y("TSNumberKeyword", e, t);
  }
  s(n2, "assertTSNumberKeyword");
  function a2(e, t) {
    y("TSObjectKeyword", e, t);
  }
  s(a2, "assertTSObjectKeyword");
  function o2(e, t) {
    y("TSStringKeyword", e, t);
  }
  s(o2, "assertTSStringKeyword");
  function l2(e, t) {
    y("TSSymbolKeyword", e, t);
  }
  s(l2, "assertTSSymbolKeyword");
  function u2(e, t) {
    y("TSUndefinedKeyword", e, t);
  }
  s(u2, "assertTSUndefinedKeyword");
  function c2(e, t) {
    y("TSUnknownKeyword", e, t);
  }
  s(c2, "assertTSUnknownKeyword");
  function p2(e, t) {
    y("TSVoidKeyword", e, t);
  }
  s(p2, "assertTSVoidKeyword");
  function f2(e, t) {
    y("TSThisType", e, t);
  }
  s(f2, "assertTSThisType");
  function h2(e, t) {
    y("TSFunctionType", e, t);
  }
  s(h2, "assertTSFunctionType");
  function d2(e, t) {
    y("TSConstructorType", e, t);
  }
  s(d2, "assertTSConstructorType");
  function m2(e, t) {
    y("TSTypeReference", e, t);
  }
  s(m2, "assertTSTypeReference");
  function y2(e, t) {
    y("TSTypePredicate", e, t);
  }
  s(y2, "assertTSTypePredicate");
  function T2(e, t) {
    y("TSTypeQuery", e, t);
  }
  s(T2, "assertTSTypeQuery");
  function g2(e, t) {
    y("TSTypeLiteral", e, t);
  }
  s(g2, "assertTSTypeLiteral");
  function b2(e, t) {
    y("TSArrayType", e, t);
  }
  s(b2, "assertTSArrayType");
  function S2(e, t) {
    y("TSTupleType", e, t);
  }
  s(S2, "assertTSTupleType");
  function x2(e, t) {
    y("TSOptionalType", e, t);
  }
  s(x2, "assertTSOptionalType");
  function E2(e, t) {
    y("TSRestType", e, t);
  }
  s(E2, "assertTSRestType");
  function P2(e, t) {
    y("TSNamedTupleMember", e, t);
  }
  s(P2, "assertTSNamedTupleMember");
  function A2(e, t) {
    y("TSUnionType", e, t);
  }
  s(A2, "assertTSUnionType");
  function v2(e, t) {
    y("TSIntersectionType", e, t);
  }
  s(v2, "assertTSIntersectionType");
  function C2(e, t) {
    y("TSConditionalType", e, t);
  }
  s(C2, "assertTSConditionalType");
  function I2(e, t) {
    y("TSInferType", e, t);
  }
  s(I2, "assertTSInferType");
  function w2(e, t) {
    y("TSParenthesizedType", e, t);
  }
  s(w2, "assertTSParenthesizedType");
  function O2(e, t) {
    y("TSTypeOperator", e, t);
  }
  s(O2, "assertTSTypeOperator");
  function N2(e, t) {
    y("TSIndexedAccessType", e, t);
  }
  s(N2, "assertTSIndexedAccessType");
  function _2(e, t) {
    y("TSMappedType", e, t);
  }
  s(_2, "assertTSMappedType");
  function D2(e, t) {
    y("TSLiteralType", e, t);
  }
  s(D2, "assertTSLiteralType");
  function k2(e, t) {
    y("TSExpressionWithTypeArguments", e, t);
  }
  s(k2, "assertTSExpressionWithTypeArguments");
  function L2(e, t) {
    y("TSInterfaceDeclaration", e, t);
  }
  s(L2, "assertTSInterfaceDeclaration");
  function M2(e, t) {
    y("TSInterfaceBody", e, t);
  }
  s(M2, "assertTSInterfaceBody");
  function F2(e, t) {
    y("TSTypeAliasDeclaration", e, t);
  }
  s(F2, "assertTSTypeAliasDeclaration");
  function B2(e, t) {
    y("TSInstantiationExpression", e, t);
  }
  s(B2, "assertTSInstantiationExpression");
  function j2(e, t) {
    y("TSAsExpression", e, t);
  }
  s(j2, "assertTSAsExpression");
  function R2(e, t) {
    y("TSSatisfiesExpression", e, t);
  }
  s(R2, "assertTSSatisfiesExpression");
  function q2(e, t) {
    y("TSTypeAssertion", e, t);
  }
  s(q2, "assertTSTypeAssertion");
  function V2(e, t) {
    y("TSEnumDeclaration", e, t);
  }
  s(V2, "assertTSEnumDeclaration");
  function U2(e, t) {
    y("TSEnumMember", e, t);
  }
  s(U2, "assertTSEnumMember");
  function K2(e, t) {
    y("TSModuleDeclaration", e, t);
  }
  s(K2, "assertTSModuleDeclaration");
  function W2(e, t) {
    y("TSModuleBlock", e, t);
  }
  s(W2, "assertTSModuleBlock");
  function Y2(e, t) {
    y("TSImportType", e, t);
  }
  s(Y2, "assertTSImportType");
  function X2(e, t) {
    y("TSImportEqualsDeclaration", e, t);
  }
  s(X2, "assertTSImportEqualsDeclaration");
  function J2(e, t) {
    y("TSExternalModuleReference", e, t);
  }
  s(J2, "assertTSExternalModuleReference");
  function $2(e, t) {
    y("TSNonNullExpression", e, t);
  }
  s($2, "assertTSNonNullExpression");
  function H2(e, t) {
    y("TSExportAssignment", e, t);
  }
  s(H2, "assertTSExportAssignment");
  function G2(e, t) {
    y("TSNamespaceExportDeclaration", e, t);
  }
  s(G2, "assertTSNamespaceExportDeclaration");
  function z2(e, t) {
    y("TSTypeAnnotation", e, t);
  }
  s(z2, "assertTSTypeAnnotation");
  function Q2(e, t) {
    y("TSTypeParameterInstantiation", e, t);
  }
  s(Q2, "assertTSTypeParameterInstantiation");
  function Z2(e, t) {
    y("TSTypeParameterDeclaration", e, t);
  }
  s(Z2, "assertTSTypeParameterDeclaration");
  function eD(e, t) {
    y("TSTypeParameter", e, t);
  }
  s(eD, "assertTSTypeParameter");
  function tD(e, t) {
    y("Standardized", e, t);
  }
  s(tD, "assertStandardized");
  function rD(e, t) {
    y("Expression", e, t);
  }
  s(rD, "assertExpression");
  function iD(e, t) {
    y("Binary", e, t);
  }
  s(iD, "assertBinary");
  function sD(e, t) {
    y("Scopable", e, t);
  }
  s(sD, "assertScopable");
  function nD(e, t) {
    y("BlockParent", e, t);
  }
  s(nD, "assertBlockParent");
  function aD(e, t) {
    y("Block", e, t);
  }
  s(aD, "assertBlock");
  function oD(e, t) {
    y("Statement", e, t);
  }
  s(oD, "assertStatement");
  function lD(e, t) {
    y("Terminatorless", e, t);
  }
  s(lD, "assertTerminatorless");
  function uD(e, t) {
    y("CompletionStatement", e, t);
  }
  s(uD, "assertCompletionStatement");
  function cD(e, t) {
    y("Conditional", e, t);
  }
  s(cD, "assertConditional");
  function pD(e, t) {
    y("Loop", e, t);
  }
  s(pD, "assertLoop");
  function fD(e, t) {
    y("While", e, t);
  }
  s(fD, "assertWhile");
  function hD(e, t) {
    y("ExpressionWrapper", e, t);
  }
  s(hD, "assertExpressionWrapper");
  function dD(e, t) {
    y("For", e, t);
  }
  s(dD, "assertFor");
  function mD(e, t) {
    y("ForXStatement", e, t);
  }
  s(mD, "assertForXStatement");
  function yD(e, t) {
    y("Function", e, t);
  }
  s(yD, "assertFunction");
  function TD(e, t) {
    y("FunctionParent", e, t);
  }
  s(TD, "assertFunctionParent");
  function gD(e, t) {
    y("Pureish", e, t);
  }
  s(gD, "assertPureish");
  function bD(e, t) {
    y("Declaration", e, t);
  }
  s(bD, "assertDeclaration");
  function SD(e, t) {
    y("PatternLike", e, t);
  }
  s(SD, "assertPatternLike");
  function xD(e, t) {
    y("LVal", e, t);
  }
  s(xD, "assertLVal");
  function ED(e, t) {
    y("TSEntityName", e, t);
  }
  s(ED, "assertTSEntityName");
  function PD(e, t) {
    y("Literal", e, t);
  }
  s(PD, "assertLiteral");
  function AD(e, t) {
    y("Immutable", e, t);
  }
  s(AD, "assertImmutable");
  function vD(e, t) {
    y("UserWhitespacable", e, t);
  }
  s(vD, "assertUserWhitespacable");
  function CD(e, t) {
    y("Method", e, t);
  }
  s(CD, "assertMethod");
  function ID(e, t) {
    y("ObjectMember", e, t);
  }
  s(ID, "assertObjectMember");
  function wD(e, t) {
    y("Property", e, t);
  }
  s(wD, "assertProperty");
  function OD(e, t) {
    y("UnaryLike", e, t);
  }
  s(OD, "assertUnaryLike");
  function ND(e, t) {
    y("Pattern", e, t);
  }
  s(ND, "assertPattern");
  function _D(e, t) {
    y("Class", e, t);
  }
  s(_D, "assertClass");
  function DD(e, t) {
    y("ImportOrExportDeclaration", e, t);
  }
  s(DD, "assertImportOrExportDeclaration");
  function kD(e, t) {
    y("ExportDeclaration", e, t);
  }
  s(kD, "assertExportDeclaration");
  function LD(e, t) {
    y("ModuleSpecifier", e, t);
  }
  s(LD, "assertModuleSpecifier");
  function MD(e, t) {
    y("Accessor", e, t);
  }
  s(MD, "assertAccessor");
  function FD(e, t) {
    y("Private", e, t);
  }
  s(FD, "assertPrivate");
  function BD(e, t) {
    y("Flow", e, t);
  }
  s(BD, "assertFlow");
  function jD(e, t) {
    y("FlowType", e, t);
  }
  s(jD, "assertFlowType");
  function RD(e, t) {
    y("FlowBaseAnnotation", e, t);
  }
  s(RD, "assertFlowBaseAnnotation");
  function qD(e, t) {
    y("FlowDeclaration", e, t);
  }
  s(qD, "assertFlowDeclaration");
  function VD(e, t) {
    y("FlowPredicate", e, t);
  }
  s(VD, "assertFlowPredicate");
  function UD(e, t) {
    y("EnumBody", e, t);
  }
  s(UD, "assertEnumBody");
  function KD(e, t) {
    y("EnumMember", e, t);
  }
  s(KD, "assertEnumMember");
  function WD(e, t) {
    y("JSX", e, t);
  }
  s(WD, "assertJSX");
  function YD(e, t) {
    y("Miscellaneous", e, t);
  }
  s(YD, "assertMiscellaneous");
  function XD(e, t) {
    y("TypeScript", e, t);
  }
  s(XD, "assertTypeScript");
  function JD(e, t) {
    y("TSTypeElement", e, t);
  }
  s(JD, "assertTSTypeElement");
  function $D(e, t) {
    y("TSType", e, t);
  }
  s($D, "assertTSType");
  function HD(e, t) {
    y("TSBaseType", e, t);
  }
  s(HD, "assertTSBaseType");
  function GD(e, t) {
    (0, Vi.default)("assertNumberLiteral", "assertNumericLiteral"), y("NumberLiteral", e, t);
  }
  s(GD, "assertNumberLiteral");
  function zD(e, t) {
    (0, Vi.default)("assertRegexLiteral", "assertRegExpLiteral"), y("RegexLiteral", e, t);
  }
  s(zD, "assertRegexLiteral");
  function QD(e, t) {
    (0, Vi.default)("assertRestProperty", "assertRestElement"), y("RestProperty", e, t);
  }
  s(QD, "assertRestProperty");
  function ZD(e, t) {
    (0, Vi.default)("assertSpreadProperty", "assertSpreadElement"), y("SpreadProperty", e, t);
  }
  s(ZD, "assertSpreadProperty");
  function ek(e, t) {
    (0, Vi.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), y("ModuleDeclaration", e, t);
  }
  s(ek, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var mf = v((Xs) => {
  "use strict";
  Object.defineProperty(Xs, "__esModule", {
    value: !0
  });
  Xs.default = void 0;
  var Ot = ut(), sH = Xs.default = tk;
  function tk(e) {
    switch (e) {
      case "string":
        return (0, Ot.stringTypeAnnotation)();
      case "number":
        return (0, Ot.numberTypeAnnotation)();
      case "undefined":
        return (0, Ot.voidTypeAnnotation)();
      case "boolean":
        return (0, Ot.booleanTypeAnnotation)();
      case "function":
        return (0, Ot.genericTypeAnnotation)((0, Ot.identifier)("Function"));
      case "object":
        return (0, Ot.genericTypeAnnotation)((0, Ot.identifier)("Object"));
      case "symbol":
        return (0, Ot.genericTypeAnnotation)((0, Ot.identifier)("Symbol"));
      case "bigint":
        return (0, Ot.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e);
  }
  s(tk, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var Za = v((Qa) => {
  "use strict";
  Object.defineProperty(Qa, "__esModule", {
    value: !0
  });
  Qa.default = Tf;
  var Ui = We();
  function yf(e) {
    return (0, Ui.isIdentifier)(e) ? e.name : `${e.id.name}.${yf(e.qualification)}`;
  }
  s(yf, "getQualifiedName");
  function Tf(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Ui.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, Ui.isFlowBaseAnnotation)(l)) {
          i.set(l.type, l);
          continue;
        }
        if ((0, Ui.isUnionTypeAnnotation)(l)) {
          n.has(l.types) || (t.push(...l.types), n.add(l.types));
          continue;
        }
        if ((0, Ui.isGenericTypeAnnotation)(l)) {
          let u = yf(l.id);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = Tf(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(Tf, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var gf = v((eo) => {
  "use strict";
  Object.defineProperty(eo, "__esModule", {
    value: !0
  });
  eo.default = sk;
  var rk = ut(), ik = Za();
  function sk(e) {
    let t = (0, ik.default)(e);
    return t.length === 1 ? t[0] : (0, rk.unionTypeAnnotation)(t);
  }
  s(sk, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var xf = v((to) => {
  "use strict";
  Object.defineProperty(to, "__esModule", {
    value: !0
  });
  to.default = Sf;
  var Ki = We();
  function bf(e) {
    return (0, Ki.isIdentifier)(e) ? e.name : `${e.right.name}.${bf(e.left)}`;
  }
  s(bf, "getQualifiedName");
  function Sf(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Ki.isTSAnyKeyword)(l))
          return [l];
        if ((0, Ki.isTSBaseType)(l)) {
          i.set(l.type, l);
          continue;
        }
        if ((0, Ki.isTSUnionType)(l)) {
          n.has(l.types) || (t.push(...l.types), n.add(l.types));
          continue;
        }
        if ((0, Ki.isTSTypeReference)(l) && l.typeParameters) {
          let u = bf(l.typeName);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = Sf(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  s(Sf, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var Ef = v((ro) => {
  "use strict";
  Object.defineProperty(ro, "__esModule", {
    value: !0
  });
  ro.default = lk;
  var nk = ut(), ak = xf(), ok = We();
  function lk(e) {
    let t = e.map((i) => (0, ok.isTSTypeAnnotation)(i) ? i.typeAnnotation : i), r = (0, ak.default)(t);
    return r.length === 1 ? r[0] : (0, nk.tsUnionType)(r);
  }
  s(lk, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var Pf = v((b) => {
  "use strict";
  Object.defineProperty(b, "__esModule", {
    value: !0
  });
  Object.defineProperty(b, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(b, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.arrayExpression;
    }, "get")
  });
  Object.defineProperty(b, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.arrayPattern;
    }, "get")
  });
  Object.defineProperty(b, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(b, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(b, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(b, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.awaitExpression;
    }, "get")
  });
  Object.defineProperty(b, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(b, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.binaryExpression;
    }, "get")
  });
  Object.defineProperty(b, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.bindExpression;
    }, "get")
  });
  Object.defineProperty(b, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.blockStatement;
    }, "get")
  });
  Object.defineProperty(b, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(b, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.breakStatement;
    }, "get")
  });
  Object.defineProperty(b, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.callExpression;
    }, "get")
  });
  Object.defineProperty(b, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.catchClause;
    }, "get")
  });
  Object.defineProperty(b, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(b, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classBody;
    }, "get")
  });
  Object.defineProperty(b, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classExpression;
    }, "get")
  });
  Object.defineProperty(b, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classImplements;
    }, "get")
  });
  Object.defineProperty(b, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classMethod;
    }, "get")
  });
  Object.defineProperty(b, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(b, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(b, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.classProperty;
    }, "get")
  });
  Object.defineProperty(b, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(b, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.continueStatement;
    }, "get")
  });
  Object.defineProperty(b, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(b, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(b, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareClass;
    }, "get")
  });
  Object.defineProperty(b, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareFunction;
    }, "get")
  });
  Object.defineProperty(b, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareInterface;
    }, "get")
  });
  Object.defineProperty(b, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareModule;
    }, "get")
  });
  Object.defineProperty(b, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(b, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(b, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(b, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declareVariable;
    }, "get")
  });
  Object.defineProperty(b, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(b, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.decorator;
    }, "get")
  });
  Object.defineProperty(b, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.directive;
    }, "get")
  });
  Object.defineProperty(b, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(b, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.doExpression;
    }, "get")
  });
  Object.defineProperty(b, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(b, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.emptyStatement;
    }, "get")
  });
  Object.defineProperty(b, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumStringBody;
    }, "get")
  });
  Object.defineProperty(b, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumStringMember;
    }, "get")
  });
  Object.defineProperty(b, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(b, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.expressionStatement;
    }, "get")
  });
  Object.defineProperty(b, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.file;
    }, "get")
  });
  Object.defineProperty(b, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.forInStatement;
    }, "get")
  });
  Object.defineProperty(b, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.forOfStatement;
    }, "get")
  });
  Object.defineProperty(b, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.forStatement;
    }, "get")
  });
  Object.defineProperty(b, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.functionExpression;
    }, "get")
  });
  Object.defineProperty(b, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(b, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.identifier;
    }, "get")
  });
  Object.defineProperty(b, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.ifStatement;
    }, "get")
  });
  Object.defineProperty(b, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.import;
    }, "get")
  });
  Object.defineProperty(b, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importAttribute;
    }, "get")
  });
  Object.defineProperty(b, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importExpression;
    }, "get")
  });
  Object.defineProperty(b, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.importSpecifier;
    }, "get")
  });
  Object.defineProperty(b, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(b, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(b, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(b, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(b, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(b, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(b, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(b, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(b, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(b, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(b, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(b, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.jsxText;
    }, "get")
  });
  Object.defineProperty(b, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.labeledStatement;
    }, "get")
  });
  Object.defineProperty(b, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.logicalExpression;
    }, "get")
  });
  Object.defineProperty(b, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.memberExpression;
    }, "get")
  });
  Object.defineProperty(b, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.metaProperty;
    }, "get")
  });
  Object.defineProperty(b, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.moduleExpression;
    }, "get")
  });
  Object.defineProperty(b, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.newExpression;
    }, "get")
  });
  Object.defineProperty(b, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.noop;
    }, "get")
  });
  Object.defineProperty(b, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.nullLiteral;
    }, "get")
  });
  Object.defineProperty(b, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.numberLiteral;
    }, "get")
  });
  Object.defineProperty(b, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.numericLiteral;
    }, "get")
  });
  Object.defineProperty(b, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectExpression;
    }, "get")
  });
  Object.defineProperty(b, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectMethod;
    }, "get")
  });
  Object.defineProperty(b, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectPattern;
    }, "get")
  });
  Object.defineProperty(b, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(b, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(b, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.opaqueType;
    }, "get")
  });
  Object.defineProperty(b, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(b, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(b, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(b, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(b, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(b, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(b, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.placeholder;
    }, "get")
  });
  Object.defineProperty(b, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.privateName;
    }, "get")
  });
  Object.defineProperty(b, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.program;
    }, "get")
  });
  Object.defineProperty(b, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.recordExpression;
    }, "get")
  });
  Object.defineProperty(b, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(b, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.regexLiteral;
    }, "get")
  });
  Object.defineProperty(b, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.restElement;
    }, "get")
  });
  Object.defineProperty(b, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.restProperty;
    }, "get")
  });
  Object.defineProperty(b, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.returnStatement;
    }, "get")
  });
  Object.defineProperty(b, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(b, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.spreadElement;
    }, "get")
  });
  Object.defineProperty(b, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.spreadProperty;
    }, "get")
  });
  Object.defineProperty(b, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.staticBlock;
    }, "get")
  });
  Object.defineProperty(b, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.stringLiteral;
    }, "get")
  });
  Object.defineProperty(b, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.super;
    }, "get")
  });
  Object.defineProperty(b, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.switchCase;
    }, "get")
  });
  Object.defineProperty(b, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.switchStatement;
    }, "get")
  });
  Object.defineProperty(b, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsArrayType;
    }, "get")
  });
  Object.defineProperty(b, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(b, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(b, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(b, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(b, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(b, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(b, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(b, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(b, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsImportType;
    }, "get")
  });
  Object.defineProperty(b, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(b, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(b, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsInferType;
    }, "get")
  });
  Object.defineProperty(b, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(b, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(b, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(b, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsMappedType;
    }, "get")
  });
  Object.defineProperty(b, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(b, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(b, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(b, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(b, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(b, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(b, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(b, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(b, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsRestType;
    }, "get")
  });
  Object.defineProperty(b, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(b, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsThisType;
    }, "get")
  });
  Object.defineProperty(b, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTupleType;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(b, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(b, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(b, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsUnionType;
    }, "get")
  });
  Object.defineProperty(b, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(b, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(b, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.templateElement;
    }, "get")
  });
  Object.defineProperty(b, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.templateLiteral;
    }, "get")
  });
  Object.defineProperty(b, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.thisExpression;
    }, "get")
  });
  Object.defineProperty(b, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.throwStatement;
    }, "get")
  });
  Object.defineProperty(b, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.topicReference;
    }, "get")
  });
  Object.defineProperty(b, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tryStatement;
    }, "get")
  });
  Object.defineProperty(b, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tupleExpression;
    }, "get")
  });
  Object.defineProperty(b, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeAlias;
    }, "get")
  });
  Object.defineProperty(b, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeParameter;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(b, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.unaryExpression;
    }, "get")
  });
  Object.defineProperty(b, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.updateExpression;
    }, "get")
  });
  Object.defineProperty(b, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(b, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(b, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(b, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.variance;
    }, "get")
  });
  Object.defineProperty(b, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(b, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.whileStatement;
    }, "get")
  });
  Object.defineProperty(b, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.withStatement;
    }, "get")
  });
  Object.defineProperty(b, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S.yieldExpression;
    }, "get")
  });
  var S = ut();
});

// ../node_modules/@babel/types/lib/builders/productions.js
var vf = v((io) => {
  "use strict";
  Object.defineProperty(io, "__esModule", {
    value: !0
  });
  io.buildUndefinedNode = uk;
  var Af = ut();
  function uk() {
    return (0, Af.unaryExpression)("void", (0, Af.numericLiteral)(0), !0);
  }
  s(uk, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var ar = v((so) => {
  "use strict";
  Object.defineProperty(so, "__esModule", {
    value: !0
  });
  so.default = ck;
  var Cf = Et(), If = We(), {
    hasOwn: Kt
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function wf(e, t, r, i) {
    return e && typeof e.type == "string" ? Nf(e, t, r, i) : e;
  }
  s(wf, "cloneIfNode");
  function Of(e, t, r, i) {
    return Array.isArray(e) ? e.map((n) => wf(n, t, r, i)) : wf(e, t, r, i);
  }
  s(Of, "cloneIfNodeOrArray");
  function ck(e, t = !0, r = !1) {
    return Nf(e, t, r, /* @__PURE__ */ new Map());
  }
  s(ck, "cloneNode");
  function Nf(e, t = !0, r = !1, i) {
    if (!e) return e;
    let {
      type: n
    } = e, a = {
      type: e.type
    };
    if ((0, If.isIdentifier)(e))
      a.name = e.name, Kt(e, "optional") && typeof e.optional == "boolean" && (a.optional = e.optional), Kt(e, "typeAnnotation") && (a.typeAnnotation =
      t ? Of(e.typeAnnotation, !0, r, i) : e.typeAnnotation);
    else if (Kt(Cf.NODE_FIELDS, n))
      for (let o of Object.keys(Cf.NODE_FIELDS[n]))
        Kt(e, o) && (t ? a[o] = (0, If.isFile)(e) && o === "comments" ? Js(e.comments, t, r, i) : Of(e[o], !0, r, i) : a[o] = e[o]);
    else
      throw new Error(`Unknown node type: "${n}"`);
    return Kt(e, "loc") && (r ? a.loc = null : a.loc = e.loc), Kt(e, "leadingComments") && (a.leadingComments = Js(e.leadingComments, t, r, i)),
    Kt(e, "innerComments") && (a.innerComments = Js(e.innerComments, t, r, i)), Kt(e, "trailingComments") && (a.trailingComments = Js(e.trailingComments,
    t, r, i)), Kt(e, "extra") && (a.extra = Object.assign({}, e.extra)), a;
  }
  s(Nf, "cloneNodeInternal");
  function Js(e, t, r, i) {
    return !e || !t ? e : e.map((n) => {
      let a = i.get(n);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = n, c = {
        type: o,
        value: l,
        loc: u
      };
      return r && (c.loc = null), i.set(n, c), c;
    });
  }
  s(Js, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var _f = v((no) => {
  "use strict";
  Object.defineProperty(no, "__esModule", {
    value: !0
  });
  no.default = fk;
  var pk = ar();
  function fk(e) {
    return (0, pk.default)(e, !1);
  }
  s(fk, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var Df = v((ao) => {
  "use strict";
  Object.defineProperty(ao, "__esModule", {
    value: !0
  });
  ao.default = dk;
  var hk = ar();
  function dk(e) {
    return (0, hk.default)(e);
  }
  s(dk, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var kf = v((oo) => {
  "use strict";
  Object.defineProperty(oo, "__esModule", {
    value: !0
  });
  oo.default = yk;
  var mk = ar();
  function yk(e) {
    return (0, mk.default)(e, !0, !0);
  }
  s(yk, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var Lf = v((lo) => {
  "use strict";
  Object.defineProperty(lo, "__esModule", {
    value: !0
  });
  lo.default = gk;
  var Tk = ar();
  function gk(e) {
    return (0, Tk.default)(e, !1, !0);
  }
  s(gk, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var co = v((uo) => {
  "use strict";
  Object.defineProperty(uo, "__esModule", {
    value: !0
  });
  uo.default = bk;
  function bk(e, t, r) {
    if (!r || !e) return e;
    let i = `${t}Comments`;
    return e[i] ? t === "leading" ? e[i] = r.concat(e[i]) : e[i].push(...r) : e[i] = r, e;
  }
  s(bk, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var Mf = v((po) => {
  "use strict";
  Object.defineProperty(po, "__esModule", {
    value: !0
  });
  po.default = xk;
  var Sk = co();
  function xk(e, t, r, i) {
    return (0, Sk.default)(e, t, [{
      type: i ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  s(xk, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var $s = v((fo) => {
  "use strict";
  Object.defineProperty(fo, "__esModule", {
    value: !0
  });
  fo.default = Ek;
  function Ek(e, t, r) {
    t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
  }
  s(Ek, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var mo = v((ho) => {
  "use strict";
  Object.defineProperty(ho, "__esModule", {
    value: !0
  });
  ho.default = Ak;
  var Pk = $s();
  function Ak(e, t) {
    (0, Pk.default)("innerComments", e, t);
  }
  s(Ak, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var To = v((yo) => {
  "use strict";
  Object.defineProperty(yo, "__esModule", {
    value: !0
  });
  yo.default = Ck;
  var vk = $s();
  function Ck(e, t) {
    (0, vk.default)("leadingComments", e, t);
  }
  s(Ck, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var bo = v((go) => {
  "use strict";
  Object.defineProperty(go, "__esModule", {
    value: !0
  });
  go.default = wk;
  var Ik = $s();
  function wk(e, t) {
    (0, Ik.default)("trailingComments", e, t);
  }
  s(wk, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var xo = v((So) => {
  "use strict";
  Object.defineProperty(So, "__esModule", {
    value: !0
  });
  So.default = Dk;
  var Ok = bo(), Nk = To(), _k = mo();
  function Dk(e, t) {
    return (0, Ok.default)(e, t), (0, Nk.default)(e, t), (0, _k.default)(e, t), e;
  }
  s(Dk, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var Ff = v((Eo) => {
  "use strict";
  Object.defineProperty(Eo, "__esModule", {
    value: !0
  });
  Eo.default = Lk;
  var kk = ir();
  function Lk(e) {
    return kk.COMMENT_KEYS.forEach((t) => {
      e[t] = null;
    }), e;
  }
  s(Lk, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var Bf = v((L) => {
  "use strict";
  Object.defineProperty(L, "__esModule", {
    value: !0
  });
  L.WHILE_TYPES = L.USERWHITESPACABLE_TYPES = L.UNARYLIKE_TYPES = L.TYPESCRIPT_TYPES = L.TSTYPE_TYPES = L.TSTYPEELEMENT_TYPES = L.TSENTITYNAME_TYPES =
  L.TSBASETYPE_TYPES = L.TERMINATORLESS_TYPES = L.STATEMENT_TYPES = L.STANDARDIZED_TYPES = L.SCOPABLE_TYPES = L.PUREISH_TYPES = L.PROPERTY_TYPES =
  L.PRIVATE_TYPES = L.PATTERN_TYPES = L.PATTERNLIKE_TYPES = L.OBJECTMEMBER_TYPES = L.MODULESPECIFIER_TYPES = L.MODULEDECLARATION_TYPES = L.MISCELLANEOUS_TYPES =
  L.METHOD_TYPES = L.LVAL_TYPES = L.LOOP_TYPES = L.LITERAL_TYPES = L.JSX_TYPES = L.IMPORTOREXPORTDECLARATION_TYPES = L.IMMUTABLE_TYPES = L.FUNCTION_TYPES =
  L.FUNCTIONPARENT_TYPES = L.FOR_TYPES = L.FORXSTATEMENT_TYPES = L.FLOW_TYPES = L.FLOWTYPE_TYPES = L.FLOWPREDICATE_TYPES = L.FLOWDECLARATION_TYPES =
  L.FLOWBASEANNOTATION_TYPES = L.EXPRESSION_TYPES = L.EXPRESSIONWRAPPER_TYPES = L.EXPORTDECLARATION_TYPES = L.ENUMMEMBER_TYPES = L.ENUMBODY_TYPES =
  L.DECLARATION_TYPES = L.CONDITIONAL_TYPES = L.COMPLETIONSTATEMENT_TYPES = L.CLASS_TYPES = L.BLOCK_TYPES = L.BLOCKPARENT_TYPES = L.BINARY_TYPES =
  L.ACCESSOR_TYPES = void 0;
  var ae = Et(), YH = L.STANDARDIZED_TYPES = ae.FLIPPED_ALIAS_KEYS.Standardized, XH = L.EXPRESSION_TYPES = ae.FLIPPED_ALIAS_KEYS.Expression,
  JH = L.BINARY_TYPES = ae.FLIPPED_ALIAS_KEYS.Binary, $H = L.SCOPABLE_TYPES = ae.FLIPPED_ALIAS_KEYS.Scopable, HH = L.BLOCKPARENT_TYPES = ae.
  FLIPPED_ALIAS_KEYS.BlockParent, GH = L.BLOCK_TYPES = ae.FLIPPED_ALIAS_KEYS.Block, zH = L.STATEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.Statement,
  QH = L.TERMINATORLESS_TYPES = ae.FLIPPED_ALIAS_KEYS.Terminatorless, ZH = L.COMPLETIONSTATEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.CompletionStatement,
  eG = L.CONDITIONAL_TYPES = ae.FLIPPED_ALIAS_KEYS.Conditional, tG = L.LOOP_TYPES = ae.FLIPPED_ALIAS_KEYS.Loop, rG = L.WHILE_TYPES = ae.FLIPPED_ALIAS_KEYS.
  While, iG = L.EXPRESSIONWRAPPER_TYPES = ae.FLIPPED_ALIAS_KEYS.ExpressionWrapper, sG = L.FOR_TYPES = ae.FLIPPED_ALIAS_KEYS.For, nG = L.FORXSTATEMENT_TYPES =
  ae.FLIPPED_ALIAS_KEYS.ForXStatement, aG = L.FUNCTION_TYPES = ae.FLIPPED_ALIAS_KEYS.Function, oG = L.FUNCTIONPARENT_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FunctionParent, lG = L.PUREISH_TYPES = ae.FLIPPED_ALIAS_KEYS.Pureish, uG = L.DECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.Declaration, cG = L.
  PATTERNLIKE_TYPES = ae.FLIPPED_ALIAS_KEYS.PatternLike, pG = L.LVAL_TYPES = ae.FLIPPED_ALIAS_KEYS.LVal, fG = L.TSENTITYNAME_TYPES = ae.FLIPPED_ALIAS_KEYS.
  TSEntityName, hG = L.LITERAL_TYPES = ae.FLIPPED_ALIAS_KEYS.Literal, dG = L.IMMUTABLE_TYPES = ae.FLIPPED_ALIAS_KEYS.Immutable, mG = L.USERWHITESPACABLE_TYPES =
  ae.FLIPPED_ALIAS_KEYS.UserWhitespacable, yG = L.METHOD_TYPES = ae.FLIPPED_ALIAS_KEYS.Method, TG = L.OBJECTMEMBER_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ObjectMember, gG = L.PROPERTY_TYPES = ae.FLIPPED_ALIAS_KEYS.Property, bG = L.UNARYLIKE_TYPES = ae.FLIPPED_ALIAS_KEYS.UnaryLike, SG = L.PATTERN_TYPES =
  ae.FLIPPED_ALIAS_KEYS.Pattern, xG = L.CLASS_TYPES = ae.FLIPPED_ALIAS_KEYS.Class, Mk = L.IMPORTOREXPORTDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ImportOrExportDeclaration, EG = L.EXPORTDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.ExportDeclaration, PG = L.MODULESPECIFIER_TYPES = ae.FLIPPED_ALIAS_KEYS.
  ModuleSpecifier, AG = L.ACCESSOR_TYPES = ae.FLIPPED_ALIAS_KEYS.Accessor, vG = L.PRIVATE_TYPES = ae.FLIPPED_ALIAS_KEYS.Private, CG = L.FLOW_TYPES =
  ae.FLIPPED_ALIAS_KEYS.Flow, IG = L.FLOWTYPE_TYPES = ae.FLIPPED_ALIAS_KEYS.FlowType, wG = L.FLOWBASEANNOTATION_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FlowBaseAnnotation, OG = L.FLOWDECLARATION_TYPES = ae.FLIPPED_ALIAS_KEYS.FlowDeclaration, NG = L.FLOWPREDICATE_TYPES = ae.FLIPPED_ALIAS_KEYS.
  FlowPredicate, _G = L.ENUMBODY_TYPES = ae.FLIPPED_ALIAS_KEYS.EnumBody, DG = L.ENUMMEMBER_TYPES = ae.FLIPPED_ALIAS_KEYS.EnumMember, kG = L.
  JSX_TYPES = ae.FLIPPED_ALIAS_KEYS.JSX, LG = L.MISCELLANEOUS_TYPES = ae.FLIPPED_ALIAS_KEYS.Miscellaneous, MG = L.TYPESCRIPT_TYPES = ae.FLIPPED_ALIAS_KEYS.
  TypeScript, FG = L.TSTYPEELEMENT_TYPES = ae.FLIPPED_ALIAS_KEYS.TSTypeElement, BG = L.TSTYPE_TYPES = ae.FLIPPED_ALIAS_KEYS.TSType, jG = L.TSBASETYPE_TYPES =
  ae.FLIPPED_ALIAS_KEYS.TSBaseType, RG = L.MODULEDECLARATION_TYPES = Mk;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var vo = v((Ao) => {
  "use strict";
  Object.defineProperty(Ao, "__esModule", {
    value: !0
  });
  Ao.default = Fk;
  var Hs = We(), Po = ut();
  function Fk(e, t) {
    if ((0, Hs.isBlockStatement)(e))
      return e;
    let r = [];
    return (0, Hs.isEmptyStatement)(e) ? r = [] : ((0, Hs.isStatement)(e) || ((0, Hs.isFunction)(t) ? e = (0, Po.returnStatement)(e) : e = (0, Po.
    expressionStatement)(e)), r = [e]), (0, Po.blockStatement)(r);
  }
  s(Fk, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var jf = v((Co) => {
  "use strict";
  Object.defineProperty(Co, "__esModule", {
    value: !0
  });
  Co.default = jk;
  var Bk = vo();
  function jk(e, t = "body") {
    let r = (0, Bk.default)(e[t], e);
    return e[t] = r, r;
  }
  s(jk, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var wo = v((Io) => {
  "use strict";
  Object.defineProperty(Io, "__esModule", {
    value: !0
  });
  Io.default = Vk;
  var Rk = Qr(), qk = Fi();
  function Vk(e) {
    e = e + "";
    let t = "";
    for (let r of e)
      t += (0, qk.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, i) {
      return i ? i.toUpperCase() : "";
    }), (0, Rk.default)(t) || (t = `_${t}`), t || "_";
  }
  s(Vk, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var Rf = v((Oo) => {
  "use strict";
  Object.defineProperty(Oo, "__esModule", {
    value: !0
  });
  Oo.default = Kk;
  var Uk = wo();
  function Kk(e) {
    return e = (0, Uk.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
  }
  s(Kk, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var qf = v((No) => {
  "use strict";
  Object.defineProperty(No, "__esModule", {
    value: !0
  });
  No.default = Xk;
  var Wk = We(), Yk = ut();
  function Xk(e, t = e.key || e.property) {
    return !e.computed && (0, Wk.isIdentifier)(t) && (t = (0, Yk.stringLiteral)(t.name)), t;
  }
  s(Xk, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var Vf = v((Gs) => {
  "use strict";
  Object.defineProperty(Gs, "__esModule", {
    value: !0
  });
  Gs.default = void 0;
  var Wi = We(), zG = Gs.default = Jk;
  function Jk(e) {
    if ((0, Wi.isExpressionStatement)(e) && (e = e.expression), (0, Wi.isExpression)(e))
      return e;
    if ((0, Wi.isClass)(e) ? e.type = "ClassExpression" : (0, Wi.isFunction)(e) && (e.type = "FunctionExpression"), !(0, Wi.isExpression)(e))
      throw new Error(`cannot turn ${e.type} to an expression`);
    return e;
  }
  s(Jk, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var ko = v((Do) => {
  "use strict";
  Object.defineProperty(Do, "__esModule", {
    value: !0
  });
  Do.default = _o;
  var $k = Et();
  function _o(e, t, r) {
    if (!e) return;
    let i = $k.VISITOR_KEYS[e.type];
    if (i) {
      r = r || {}, t(e, r);
      for (let n of i) {
        let a = e[n];
        if (Array.isArray(a))
          for (let o of a)
            _o(o, t, r);
        else
          _o(a, t, r);
      }
    }
  }
  s(_o, "traverseFast");
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var Mo = v((Lo) => {
  "use strict";
  Object.defineProperty(Lo, "__esModule", {
    value: !0
  });
  Lo.default = zk;
  var Hk = ir(), Uf = ["tokens", "start", "end", "loc", "raw", "rawValue"], Gk = [...Hk.COMMENT_KEYS, "comments", ...Uf];
  function zk(e, t = {}) {
    let r = t.preserveComments ? Uf : Gk;
    for (let n of r)
      e[n] != null && (e[n] = void 0);
    for (let n of Object.keys(e))
      n[0] === "_" && e[n] != null && (e[n] = void 0);
    let i = Object.getOwnPropertySymbols(e);
    for (let n of i)
      e[n] = null;
  }
  s(zk, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var Bo = v((Fo) => {
  "use strict";
  Object.defineProperty(Fo, "__esModule", {
    value: !0
  });
  Fo.default = eL;
  var Qk = ko(), Zk = Mo();
  function eL(e, t) {
    return (0, Qk.default)(e, Zk.default, t), e;
  }
  s(eL, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var Wf = v((jo) => {
  "use strict";
  Object.defineProperty(jo, "__esModule", {
    value: !0
  });
  jo.default = Or;
  var Kf = We(), tL = ar(), rL = Bo();
  function Or(e, t = e.key) {
    let r;
    return e.kind === "method" ? Or.increment() + "" : ((0, Kf.isIdentifier)(t) ? r = t.name : (0, Kf.isStringLiteral)(t) ? r = JSON.stringify(
    t.value) : r = JSON.stringify((0, rL.default)((0, tL.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
  }
  s(Or, "toKeyAlias");
  Or.uid = 0;
  Or.increment = function() {
    return Or.uid >= Number.MAX_SAFE_INTEGER ? Or.uid = 0 : Or.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var Yf = v((Qs) => {
  "use strict";
  Object.defineProperty(Qs, "__esModule", {
    value: !0
  });
  Qs.default = void 0;
  var zs = We(), iL = ut(), lz = Qs.default = sL;
  function sL(e, t) {
    if ((0, zs.isStatement)(e))
      return e;
    let r = !1, i;
    if ((0, zs.isClass)(e))
      r = !0, i = "ClassDeclaration";
    else if ((0, zs.isFunction)(e))
      r = !0, i = "FunctionDeclaration";
    else if ((0, zs.isAssignmentExpression)(e))
      return (0, iL.expressionStatement)(e);
    if (r && !e.id && (i = !1), !i) {
      if (t)
        return !1;
      throw new Error(`cannot turn ${e.type} to a statement`);
    }
    return e.type = i, e;
  }
  s(sL, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var Xf = v((Zs) => {
  "use strict";
  Object.defineProperty(Zs, "__esModule", {
    value: !0
  });
  Zs.default = void 0;
  var nL = Qr(), rt = ut(), pz = Zs.default = Ro, aL = Function.call.bind(Object.prototype.toString);
  function oL(e) {
    return aL(e) === "[object RegExp]";
  }
  s(oL, "isRegExp");
  function lL(e) {
    if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    let t = Object.getPrototypeOf(e);
    return t === null || Object.getPrototypeOf(t) === null;
  }
  s(lL, "isPlainObject");
  function Ro(e) {
    if (e === void 0)
      return (0, rt.identifier)("undefined");
    if (e === !0 || e === !1)
      return (0, rt.booleanLiteral)(e);
    if (e === null)
      return (0, rt.nullLiteral)();
    if (typeof e == "string")
      return (0, rt.stringLiteral)(e);
    if (typeof e == "number") {
      let t;
      if (Number.isFinite(e))
        t = (0, rt.numericLiteral)(Math.abs(e));
      else {
        let r;
        Number.isNaN(e) ? r = (0, rt.numericLiteral)(0) : r = (0, rt.numericLiteral)(1), t = (0, rt.binaryExpression)("/", r, (0, rt.numericLiteral)(
        0));
      }
      return (e < 0 || Object.is(e, -0)) && (t = (0, rt.unaryExpression)("-", t)), t;
    }
    if (oL(e)) {
      let t = e.source, r = e.toString().match(/\/([a-z]+|)$/)[1];
      return (0, rt.regExpLiteral)(t, r);
    }
    if (Array.isArray(e))
      return (0, rt.arrayExpression)(e.map(Ro));
    if (lL(e)) {
      let t = [];
      for (let r of Object.keys(e)) {
        let i;
        (0, nL.default)(r) ? i = (0, rt.identifier)(r) : i = (0, rt.stringLiteral)(r), t.push((0, rt.objectProperty)(i, Ro(e[r])));
      }
      return (0, rt.objectExpression)(t);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  s(Ro, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var Jf = v((qo) => {
  "use strict";
  Object.defineProperty(qo, "__esModule", {
    value: !0
  });
  qo.default = cL;
  var uL = ut();
  function cL(e, t, r = !1) {
    return e.object = (0, uL.memberExpression)(e.object, e.property, e.computed), e.property = t, e.computed = !!r, e;
  }
  s(cL, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var Hf = v((Vo) => {
  "use strict";
  Object.defineProperty(Vo, "__esModule", {
    value: !0
  });
  Vo.default = fL;
  var $f = ir(), pL = xo();
  function fL(e, t) {
    if (!e || !t) return e;
    for (let r of $f.INHERIT_KEYS.optional)
      e[r] == null && (e[r] = t[r]);
    for (let r of Object.keys(t))
      r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
    for (let r of $f.INHERIT_KEYS.force)
      e[r] = t[r];
    return (0, pL.default)(e, t), e;
  }
  s(fL, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var Gf = v((Uo) => {
  "use strict";
  Object.defineProperty(Uo, "__esModule", {
    value: !0
  });
  Uo.default = mL;
  var hL = ut(), dL = le();
  function mL(e, t) {
    if ((0, dL.isSuper)(e.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e.object = (0, hL.memberExpression)(t, e.object), e;
  }
  s(mL, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var Yi = v((Wo) => {
  "use strict";
  Object.defineProperty(Wo, "__esModule", {
    value: !0
  });
  Wo.default = Ko;
  var or = We();
  function Ko(e, t, r, i) {
    let n = [].concat(e), a = /* @__PURE__ */ Object.create(null);
    for (; n.length; ) {
      let o = n.shift();
      if (!o || i && ((0, or.isAssignmentExpression)(o) || (0, or.isUnaryExpression)(o)))
        continue;
      let l = Ko.keys[o.type];
      if ((0, or.isIdentifier)(o)) {
        t ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, or.isExportDeclaration)(o) && !(0, or.isExportAllDeclaration)(o)) {
        (0, or.isDeclaration)(o.declaration) && n.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, or.isFunctionDeclaration)(o)) {
          n.push(o.id);
          continue;
        }
        if ((0, or.isFunctionExpression)(o))
          continue;
      }
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], p = o[c];
          p && (Array.isArray(p) ? n.push(...p) : n.push(p));
        }
    }
    return a;
  }
  s(Ko, "getBindingIdentifiers");
  Ko.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var zf = v((en) => {
  "use strict";
  Object.defineProperty(en, "__esModule", {
    value: !0
  });
  en.default = void 0;
  var yL = Yi(), Ez = en.default = TL;
  function TL(e, t) {
    return (0, yL.default)(e, t, !0);
  }
  s(TL, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var Qf = v((Xo) => {
  "use strict";
  Object.defineProperty(Xo, "__esModule", {
    value: !0
  });
  Xo.default = bL;
  var gL = Et();
  function bL(e, t, r) {
    typeof t == "function" && (t = {
      enter: t
    });
    let {
      enter: i,
      exit: n
    } = t;
    Yo(e, i, n, r, []);
  }
  s(bL, "traverse");
  function Yo(e, t, r, i, n) {
    let a = gL.VISITOR_KEYS[e.type];
    if (a) {
      t && t(e, n, i);
      for (let o of a) {
        let l = e[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (n.push({
              node: e,
              key: o,
              index: u
            }), Yo(c, t, r, i, n), n.pop());
          }
        else l && (n.push({
          node: e,
          key: o
        }), Yo(l, t, r, i, n), n.pop());
      }
      r && r(e, n, i);
    }
  }
  s(Yo, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var Zf = v((Jo) => {
  "use strict";
  Object.defineProperty(Jo, "__esModule", {
    value: !0
  });
  Jo.default = xL;
  var SL = Yi();
  function xL(e, t, r) {
    if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let i = SL.default.keys[t.type];
    if (i)
      for (let n = 0; n < i.length; n++) {
        let a = i[n], o = t[a];
        if (Array.isArray(o)) {
          if (o.indexOf(e) >= 0) return !0;
        } else if (o === e) return !0;
      }
    return !1;
  }
  s(xL, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var Ho = v(($o) => {
  "use strict";
  Object.defineProperty($o, "__esModule", {
    value: !0
  });
  $o.default = AL;
  var EL = We(), PL = ir();
  function AL(e) {
    return (0, EL.isVariableDeclaration)(e) && (e.kind !== "var" || e[PL.BLOCK_SCOPED_SYMBOL]);
  }
  s(AL, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var th = v((Go) => {
  "use strict";
  Object.defineProperty(Go, "__esModule", {
    value: !0
  });
  Go.default = CL;
  var eh = We(), vL = Ho();
  function CL(e) {
    return (0, eh.isFunctionDeclaration)(e) || (0, eh.isClassDeclaration)(e) || (0, vL.default)(e);
  }
  s(CL, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var rh = v((zo) => {
  "use strict";
  Object.defineProperty(zo, "__esModule", {
    value: !0
  });
  zo.default = OL;
  var IL = Ms(), wL = We();
  function OL(e) {
    return (0, IL.default)(e.type, "Immutable") ? !0 : (0, wL.isIdentifier)(e) ? e.name === "undefined" : !1;
  }
  s(OL, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var sh = v((Zo) => {
  "use strict";
  Object.defineProperty(Zo, "__esModule", {
    value: !0
  });
  Zo.default = Qo;
  var ih = Et();
  function Qo(e, t) {
    if (typeof e != "object" || typeof t != "object" || e == null || t == null)
      return e === t;
    if (e.type !== t.type)
      return !1;
    let r = Object.keys(ih.NODE_FIELDS[e.type] || e.type), i = ih.VISITOR_KEYS[e.type];
    for (let n of r) {
      let a = e[n], o = t[n];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!Qo(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(i != null && i.includes(n))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!Qo(a, o))
          return !1;
      }
    }
    return !0;
  }
  s(Qo, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var nh = v((el) => {
  "use strict";
  Object.defineProperty(el, "__esModule", {
    value: !0
  });
  el.default = NL;
  function NL(e, t, r) {
    switch (t.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t.property === e ? !!t.computed : t.object === e;
      case "JSXMemberExpression":
        return t.object === e;
      case "VariableDeclarator":
        return t.init === e;
      case "ArrowFunctionExpression":
        return t.body === e;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t.key === e ? !!t.computed : !1;
      case "ObjectProperty":
        return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return t.key === e ? !!t.computed : !0;
      case "ClassPrivateProperty":
        return t.key !== e;
      case "ClassDeclaration":
      case "ClassExpression":
        return t.superClass === e;
      case "AssignmentExpression":
        return t.right === e;
      case "AssignmentPattern":
        return t.right === e;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : t.local === e;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return t.key !== e;
      case "TSEnumMember":
        return t.id !== e;
      case "TSPropertySignature":
        return t.key === e ? !!t.computed : !0;
    }
    return !0;
  }
  s(NL, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var ah = v((tl) => {
  "use strict";
  Object.defineProperty(tl, "__esModule", {
    value: !0
  });
  tl.default = _L;
  var Nr = We();
  function _L(e, t) {
    return (0, Nr.isBlockStatement)(e) && ((0, Nr.isFunction)(t) || (0, Nr.isCatchClause)(t)) ? !1 : (0, Nr.isPattern)(e) && ((0, Nr.isFunction)(
    t) || (0, Nr.isCatchClause)(t)) ? !0 : (0, Nr.isScopable)(e);
  }
  s(_L, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var lh = v((rl) => {
  "use strict";
  Object.defineProperty(rl, "__esModule", {
    value: !0
  });
  rl.default = DL;
  var oh = We();
  function DL(e) {
    return (0, oh.isImportDefaultSpecifier)(e) || (0, oh.isIdentifier)(e.imported || e.exported, {
      name: "default"
    });
  }
  s(DL, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var uh = v((il) => {
  "use strict";
  Object.defineProperty(il, "__esModule", {
    value: !0
  });
  il.default = ML;
  var kL = Qr(), LL = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implement\
s", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transie\
nt", "volatile"]);
  function ML(e) {
    return (0, kL.default)(e) && !LL.has(e);
  }
  s(ML, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var ch = v((sl) => {
  "use strict";
  Object.defineProperty(sl, "__esModule", {
    value: !0
  });
  sl.default = jL;
  var FL = We(), BL = ir();
  function jL(e) {
    return (0, FL.isVariableDeclaration)(e, {
      kind: "var"
    }) && !e[BL.BLOCK_SCOPED_SYMBOL];
  }
  s(jL, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var ph = v((al) => {
  "use strict";
  Object.defineProperty(al, "__esModule", {
    value: !0
  });
  al.default = tn;
  var RL = Yi(), _r = We(), nl = ut(), qL = ar();
  function tn(e, t, r) {
    let i = [], n = !0;
    for (let a of e)
      if ((0, _r.isEmptyStatement)(a) || (n = !1), (0, _r.isExpression)(a))
        i.push(a);
      else if ((0, _r.isExpressionStatement)(a))
        i.push(a.expression);
      else if ((0, _r.isVariableDeclaration)(a)) {
        if (a.kind !== "var") return;
        for (let o of a.declarations) {
          let l = (0, RL.default)(o);
          for (let u of Object.keys(l))
            r.push({
              kind: a.kind,
              id: (0, qL.default)(l[u])
            });
          o.init && i.push((0, nl.assignmentExpression)("=", o.id, o.init));
        }
        n = !0;
      } else if ((0, _r.isIfStatement)(a)) {
        let o = a.consequent ? tn([a.consequent], t, r) : t.buildUndefinedNode(), l = a.alternate ? tn([a.alternate], t, r) : t.buildUndefinedNode();
        if (!o || !l) return;
        i.push((0, nl.conditionalExpression)(a.test, o, l));
      } else if ((0, _r.isBlockStatement)(a)) {
        let o = tn(a.body, t, r);
        if (!o) return;
        i.push(o);
      } else if ((0, _r.isEmptyStatement)(a))
        e.indexOf(a) === 0 && (n = !0);
      else
        return;
    return n && i.push(t.buildUndefinedNode()), i.length === 1 ? i[0] : (0, nl.sequenceExpression)(i);
  }
  s(tn, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var fh = v((ol) => {
  "use strict";
  Object.defineProperty(ol, "__esModule", {
    value: !0
  });
  ol.default = UL;
  var VL = ph();
  function UL(e, t) {
    if (!(e != null && e.length)) return;
    let r = [], i = (0, VL.default)(e, t, r);
    if (i) {
      for (let n of r)
        t.push(n);
      return i;
    }
  }
  s(UL, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var le = v((V) => {
  "use strict";
  Object.defineProperty(V, "__esModule", {
    value: !0
  });
  var Wt = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(V, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return WM.default;
    }, "get")
  });
  Object.defineProperty(V, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return eM.default;
    }, "get")
  });
  Object.defineProperty(V, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return tM.default;
    }, "get")
  });
  Object.defineProperty(V, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return yM.default;
    }, "get")
  });
  Object.defineProperty(V, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return XL.default;
    }, "get")
  });
  Object.defineProperty(V, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return KM.default;
    }, "get")
  });
  Object.defineProperty(V, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return GL.default;
    }, "get")
  });
  Object.defineProperty(V, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return zL.default;
    }, "get")
  });
  Object.defineProperty(V, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return QL.default;
    }, "get")
  });
  Object.defineProperty(V, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return HL.default;
    }, "get")
  });
  Object.defineProperty(V, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ZL.default;
    }, "get")
  });
  Object.defineProperty(V, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return hh.default;
    }, "get")
  });
  Object.defineProperty(V, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return $L.default;
    }, "get")
  });
  Object.defineProperty(V, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return JL.default;
    }, "get")
  });
  Object.defineProperty(V, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return hh.default;
    }, "get")
  });
  Object.defineProperty(V, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return oM.default;
    }, "get")
  });
  Object.defineProperty(V, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return EM.default;
    }, "get")
  });
  Object.defineProperty(V, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return PM.default;
    }, "get")
  });
  Object.defineProperty(V, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rM.default;
    }, "get")
  });
  Object.defineProperty(V, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return iM.default;
    }, "get")
  });
  Object.defineProperty(V, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return nM.default;
    }, "get")
  });
  Object.defineProperty(V, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return TM.default;
    }, "get")
  });
  Object.defineProperty(V, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return sM.default;
    }, "get")
  });
  Object.defineProperty(V, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return CM.default;
    }, "get")
  });
  Object.defineProperty(V, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return IM.default;
    }, "get")
  });
  Object.defineProperty(V, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return wM.default;
    }, "get")
  });
  Object.defineProperty(V, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return OM.default;
    }, "get")
  });
  Object.defineProperty(V, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return NM.default;
    }, "get")
  });
  Object.defineProperty(V, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return _M.default;
    }, "get")
  });
  Object.defineProperty(V, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return DM.default;
    }, "get")
  });
  Object.defineProperty(V, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return kM.default;
    }, "get")
  });
  Object.defineProperty(V, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return LM.default;
    }, "get")
  });
  Object.defineProperty(V, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return MM.default;
    }, "get")
  });
  Object.defineProperty(V, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return FM.default;
    }, "get")
  });
  Object.defineProperty(V, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return BM.default;
    }, "get")
  });
  Object.defineProperty(V, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return jM.default;
    }, "get")
  });
  Object.defineProperty(V, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return RM.default;
    }, "get")
  });
  Object.defineProperty(V, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return qM.default;
    }, "get")
  });
  Object.defineProperty(V, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return VM.default;
    }, "get")
  });
  Object.defineProperty(V, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return gM.default;
    }, "get")
  });
  V.react = void 0;
  Object.defineProperty(V, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return aM.default;
    }, "get")
  });
  Object.defineProperty(V, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return bM.default;
    }, "get")
  });
  Object.defineProperty(V, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return SM.default;
    }, "get")
  });
  Object.defineProperty(V, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return xM.default;
    }, "get")
  });
  Object.defineProperty(V, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return vM.default;
    }, "get")
  });
  Object.defineProperty(V, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return lM.default;
    }, "get")
  });
  Object.defineProperty(V, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return uM.default;
    }, "get")
  });
  Object.defineProperty(V, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return cM.default;
    }, "get")
  });
  Object.defineProperty(V, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return pM.default;
    }, "get")
  });
  Object.defineProperty(V, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return fM.default;
    }, "get")
  });
  Object.defineProperty(V, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return hM.default;
    }, "get")
  });
  Object.defineProperty(V, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return dM.default;
    }, "get")
  });
  Object.defineProperty(V, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return rn.default;
    }, "get")
  });
  Object.defineProperty(V, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return AM.default;
    }, "get")
  });
  Object.defineProperty(V, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return UM.default;
    }, "get")
  });
  Object.defineProperty(V, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return mM.default;
    }, "get")
  });
  var KL = yp(), WL = Tp(), YL = ff(), XL = hf(), ll = df();
  Object.keys(ll).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === ll[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ll[e];
      }, "get")
    });
  });
  var JL = mf(), hh = gf(), $L = Ef(), ul = ut();
  Object.keys(ul).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === ul[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ul[e];
      }, "get")
    });
  });
  var cl = Pf();
  Object.keys(cl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === cl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return cl[e];
      }, "get")
    });
  });
  var pl = vf();
  Object.keys(pl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === pl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return pl[e];
      }, "get")
    });
  });
  var HL = ar(), GL = _f(), zL = Df(), QL = kf(), ZL = Lf(), eM = Mf(), tM = co(), rM = mo(), iM = To(), sM = xo(), nM = bo(), aM = Ff(), fl = Bf();
  Object.keys(fl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === fl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return fl[e];
      }, "get")
    });
  });
  var hl = ir();
  Object.keys(hl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === hl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return hl[e];
      }, "get")
    });
  });
  var oM = jf(), lM = Rf(), uM = vo(), cM = qf(), pM = Vf(), fM = wo(), hM = Wf(), dM = Yf(), mM = Xf(), dl = Et();
  Object.keys(dl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === dl[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return dl[e];
      }, "get")
    });
  });
  var yM = Jf(), TM = Hf(), gM = Gf(), bM = Mo(), SM = Bo(), xM = Za(), EM = Yi(), PM = zf(), rn = Qf();
  Object.keys(rn).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === rn[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return rn[e];
      }, "get")
    });
  });
  var AM = ko(), vM = ks(), CM = zr(), IM = Zf(), wM = th(), OM = rh(), NM = Ho(), _M = Ga(), DM = sh(), kM = Pa(), LM = nh(), MM = ah(), FM = lh(),
  BM = Ms(), jM = uh(), RM = Qr(), qM = ch(), VM = Ta(), UM = qs(), KM = ba(), ml = We();
  Object.keys(ml).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Wt, e) || e in V && V[e] === ml[e] || Object.defineProperty(
    V, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ml[e];
      }, "get")
    });
  });
  var WM = Oi(), zz = V.react = {
    isReactComponent: KL.default,
    isCompatTag: WL.default,
    buildChildren: YL.default
  };
  V.toSequenceExpression = fh().default;
});

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var mh = v((sn, dh) => {
  (function(e, t) {
    typeof sn == "object" && typeof dh < "u" ? t(sn) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.setArray = {}));
  })(sn, function(e) {
    "use strict";
    class t {
      static {
        s(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function r(l) {
      return l;
    }
    s(r, "cast");
    function i(l, u) {
      return l._indexes[u];
    }
    s(i, "get");
    function n(l, u) {
      let c = i(l, u);
      if (c !== void 0)
        return c;
      let { array: p, _indexes: g } = l, P = p.push(u);
      return g[u] = P - 1;
    }
    s(n, "put");
    function a(l) {
      let { array: u, _indexes: c } = l;
      if (u.length === 0)
        return;
      let p = u.pop();
      c[p] = void 0;
    }
    s(a, "pop");
    function o(l, u) {
      let c = i(l, u);
      if (c === void 0)
        return;
      let { array: p, _indexes: g } = l;
      for (let P = c + 1; P < p.length; P++) {
        let A = p[P];
        p[P - 1] = A, g[A]--;
      }
      g[u] = void 0, p.pop();
    }
    s(o, "remove"), e.SetArray = t, e.get = i, e.pop = a, e.put = n, e.remove = o, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var yl = v((nn, yh) => {
  (function(e, t) {
    typeof nn == "object" && typeof yh < "u" ? t(nn) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.sourcemapCodec = {}));
  })(nn, function(e) {
    "use strict";
    let i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(64), a = new Uint8Array(128);
    for (let _ = 0; _ < i.length; _++) {
      let k = i.charCodeAt(_);
      n[_] = k, a[k] = _;
    }
    let o = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(_) {
        return Buffer.from(_.buffer, _.byteOffset, _.byteLength).toString();
      }
    } : {
      decode(_) {
        let k = "";
        for (let O = 0; O < _.length; O++)
          k += String.fromCharCode(_[O]);
        return k;
      }
    };
    function l(_) {
      let k = new Int32Array(5), O = [], M = 0;
      do {
        let F = u(_, M), G = [], $ = !0, K = 0;
        k[0] = 0;
        for (let oe = M; oe < F; oe++) {
          let Oe;
          oe = c(_, oe, k, 0);
          let Ne = k[0];
          Ne < K && ($ = !1), K = Ne, p(_, oe, F) ? (oe = c(_, oe, k, 1), oe = c(_, oe, k, 2), oe = c(_, oe, k, 3), p(_, oe, F) ? (oe = c(_,
          oe, k, 4), Oe = [Ne, k[1], k[2], k[3], k[4]]) : Oe = [Ne, k[1], k[2], k[3]]) : Oe = [Ne], G.push(Oe);
        }
        $ || g(G), O.push(G), M = F + 1;
      } while (M <= _.length);
      return O;
    }
    s(l, "decode");
    function u(_, k) {
      let O = _.indexOf(";", k);
      return O === -1 ? _.length : O;
    }
    s(u, "indexOf");
    function c(_, k, O, M) {
      let F = 0, G = 0, $ = 0;
      do {
        let oe = _.charCodeAt(k++);
        $ = a[oe], F |= ($ & 31) << G, G += 5;
      } while ($ & 32);
      let K = F & 1;
      return F >>>= 1, K && (F = -2147483648 | -F), O[M] += F, k;
    }
    s(c, "decodeInteger");
    function p(_, k, O) {
      return k >= O ? !1 : _.charCodeAt(k) !== 44;
    }
    s(p, "hasMoreVlq");
    function g(_) {
      _.sort(P);
    }
    s(g, "sort");
    function P(_, k) {
      return _[0] - k[0];
    }
    s(P, "sortComparator");
    function A(_) {
      let k = new Int32Array(5), O = 1024 * 16, M = O - 36, F = new Uint8Array(O), G = F.subarray(0, M), $ = 0, K = "";
      for (let oe = 0; oe < _.length; oe++) {
        let Oe = _[oe];
        if (oe > 0 && ($ === O && (K += o.decode(F), $ = 0), F[$++] = 59), Oe.length !== 0) {
          k[0] = 0;
          for (let Ne = 0; Ne < Oe.length; Ne++) {
            let $e = Oe[Ne];
            $ > M && (K += o.decode(G), F.copyWithin(0, M, $), $ -= M), Ne > 0 && (F[$++] = 44), $ = C(F, $, k, $e, 0), $e.length !== 1 && ($ =
            C(F, $, k, $e, 1), $ = C(F, $, k, $e, 2), $ = C(F, $, k, $e, 3), $e.length !== 4 && ($ = C(F, $, k, $e, 4)));
          }
        }
      }
      return K + o.decode(F.subarray(0, $));
    }
    s(A, "encode");
    function C(_, k, O, M, F) {
      let G = M[F], $ = G - O[F];
      O[F] = G, $ = $ < 0 ? -$ << 1 | 1 : $ << 1;
      do {
        let K = $ & 31;
        $ >>>= 5, $ > 0 && (K |= 32), _[k++] = n[K];
      } while ($ > 0);
      return k;
    }
    s(C, "encodeInteger"), e.decode = l, e.encode = A, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var Th = v((Tl, gl) => {
  (function(e, t) {
    typeof Tl == "object" && typeof gl < "u" ? gl.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, e.resolveURI = t());
  })(Tl, function() {
    "use strict";
    let e = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var i;
    (function(O) {
      O[O.Empty = 1] = "Empty", O[O.Hash = 2] = "Hash", O[O.Query = 3] = "Query", O[O.RelativePath = 4] = "RelativePath", O[O.AbsolutePath =
      5] = "AbsolutePath", O[O.SchemeRelative = 6] = "SchemeRelative", O[O.Absolute = 7] = "Absolute";
    })(i || (i = {}));
    function n(O) {
      return e.test(O);
    }
    s(n, "isAbsoluteUrl");
    function a(O) {
      return O.startsWith("//");
    }
    s(a, "isSchemeRelativeUrl");
    function o(O) {
      return O.startsWith("/");
    }
    s(o, "isAbsolutePath");
    function l(O) {
      return O.startsWith("file:");
    }
    s(l, "isFileUrl");
    function u(O) {
      return /^[.?#]/.test(O);
    }
    s(u, "isRelative");
    function c(O) {
      let M = t.exec(O);
      return g(M[1], M[2] || "", M[3], M[4] || "", M[5] || "/", M[6] || "", M[7] || "");
    }
    s(c, "parseAbsoluteUrl");
    function p(O) {
      let M = r.exec(O), F = M[2];
      return g("file:", "", M[1] || "", "", o(F) ? F : "/" + F, M[3] || "", M[4] || "");
    }
    s(p, "parseFileUrl");
    function g(O, M, F, G, $, K, oe) {
      return {
        scheme: O,
        user: M,
        host: F,
        port: G,
        path: $,
        query: K,
        hash: oe,
        type: i.Absolute
      };
    }
    s(g, "makeUrl");
    function P(O) {
      if (a(O)) {
        let F = c("http:" + O);
        return F.scheme = "", F.type = i.SchemeRelative, F;
      }
      if (o(O)) {
        let F = c("http://foo.com" + O);
        return F.scheme = "", F.host = "", F.type = i.AbsolutePath, F;
      }
      if (l(O))
        return p(O);
      if (n(O))
        return c(O);
      let M = c("http://foo.com/" + O);
      return M.scheme = "", M.host = "", M.type = O ? O.startsWith("?") ? i.Query : O.startsWith("#") ? i.Hash : i.RelativePath : i.Empty, M;
    }
    s(P, "parseUrl");
    function A(O) {
      if (O.endsWith("/.."))
        return O;
      let M = O.lastIndexOf("/");
      return O.slice(0, M + 1);
    }
    s(A, "stripPathFilename");
    function C(O, M) {
      _(M, M.type), O.path === "/" ? O.path = M.path : O.path = A(M.path) + O.path;
    }
    s(C, "mergePaths");
    function _(O, M) {
      let F = M <= i.RelativePath, G = O.path.split("/"), $ = 1, K = 0, oe = !1;
      for (let Ne = 1; Ne < G.length; Ne++) {
        let $e = G[Ne];
        if (!$e) {
          oe = !0;
          continue;
        }
        if (oe = !1, $e !== ".") {
          if ($e === "..") {
            K ? (oe = !0, K--, $--) : F && (G[$++] = $e);
            continue;
          }
          G[$++] = $e, K++;
        }
      }
      let Oe = "";
      for (let Ne = 1; Ne < $; Ne++)
        Oe += "/" + G[Ne];
      (!Oe || oe && !Oe.endsWith("/..")) && (Oe += "/"), O.path = Oe;
    }
    s(_, "normalizePath");
    function k(O, M) {
      if (!O && !M)
        return "";
      let F = P(O), G = F.type;
      if (M && G !== i.Absolute) {
        let K = P(M), oe = K.type;
        switch (G) {
          case i.Empty:
            F.hash = K.hash;
          case i.Hash:
            F.query = K.query;
          case i.Query:
          case i.RelativePath:
            C(F, K);
          case i.AbsolutePath:
            F.user = K.user, F.host = K.host, F.port = K.port;
          case i.SchemeRelative:
            F.scheme = K.scheme;
        }
        oe > G && (G = oe);
      }
      _(F, G);
      let $ = F.query + F.hash;
      switch (G) {
        case i.Hash:
        case i.Query:
          return $;
        case i.RelativePath: {
          let K = F.path.slice(1);
          return K ? u(M || O) && !u(K) ? "./" + K + $ : K + $ : $ || ".";
        }
        case i.AbsolutePath:
          return F.path + $;
        default:
          return F.scheme + "//" + F.user + F.host + F.port + F.path + $;
      }
    }
    return s(k, "resolve"), k;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var bl = v((an, gh) => {
  (function(e, t) {
    typeof an == "object" && typeof gh < "u" ? t(an, yl(), Th()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.traceMapping = {}, e.sourcemapCodec,
    e.resolveURI));
  })(an, function(e, t, r) {
    "use strict";
    function i(N, B) {
      return B && !B.endsWith("/") && (B += "/"), r(N, B);
    }
    s(i, "resolve");
    function n(N) {
      if (!N)
        return "";
      let B = N.lastIndexOf("/");
      return N.slice(0, B + 1);
    }
    s(n, "stripFilename");
    let a = 0, o = 1, l = 2, u = 3, c = 4, p = 1, g = 2;
    function P(N, B) {
      let R = A(N, 0);
      if (R === N.length)
        return N;
      B || (N = N.slice());
      for (let W = R; W < N.length; W = A(N, W + 1))
        N[W] = _(N[W], B);
      return N;
    }
    s(P, "maybeSort");
    function A(N, B) {
      for (let R = B; R < N.length; R++)
        if (!C(N[R]))
          return R;
      return N.length;
    }
    s(A, "nextUnsortedSegmentLine");
    function C(N) {
      for (let B = 1; B < N.length; B++)
        if (N[B][a] < N[B - 1][a])
          return !1;
      return !0;
    }
    s(C, "isSorted");
    function _(N, B) {
      return B || (N = N.slice()), N.sort(k);
    }
    s(_, "sortSegments");
    function k(N, B) {
      return N[a] - B[a];
    }
    s(k, "sortComparator");
    let O = !1;
    function M(N, B, R, W) {
      for (; R <= W; ) {
        let ue = R + (W - R >> 1), te = N[ue][a] - B;
        if (te === 0)
          return O = !0, ue;
        te < 0 ? R = ue + 1 : W = ue - 1;
      }
      return O = !1, R - 1;
    }
    s(M, "binarySearch");
    function F(N, B, R) {
      for (let W = R + 1; W < N.length && N[W][a] === B; R = W++)
        ;
      return R;
    }
    s(F, "upperBound");
    function G(N, B, R) {
      for (let W = R - 1; W >= 0 && N[W][a] === B; R = W--)
        ;
      return R;
    }
    s(G, "lowerBound");
    function $() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    s($, "memoizedState");
    function K(N, B, R, W) {
      let { lastKey: ue, lastNeedle: te, lastIndex: Se } = R, De = 0, me = N.length - 1;
      if (W === ue) {
        if (B === te)
          return O = Se !== -1 && N[Se][a] === B, Se;
        B >= te ? De = Se === -1 ? 0 : Se : me = Se;
      }
      return R.lastKey = W, R.lastNeedle = B, R.lastIndex = M(N, B, De, me);
    }
    s(K, "memoizedBinarySearch");
    function oe(N, B) {
      let R = B.map(Ne);
      for (let W = 0; W < N.length; W++) {
        let ue = N[W];
        for (let te = 0; te < ue.length; te++) {
          let Se = ue[te];
          if (Se.length === 1)
            continue;
          let De = Se[o], me = Se[l], ke = Se[u], mt = R[De], Ke = mt[me] || (mt[me] = []), Ve = B[De], nt = F(Ke, ke, K(Ke, ke, Ve, me));
          Ve.lastIndex = ++nt, Oe(Ke, nt, [ke, W, Se[a]]);
        }
      }
      return R;
    }
    s(oe, "buildBySources");
    function Oe(N, B, R) {
      for (let W = N.length; W > B; W--)
        N[W] = N[W - 1];
      N[B] = R;
    }
    s(Oe, "insert");
    function Ne() {
      return { __proto__: null };
    }
    s(Ne, "buildNullArray");
    let $e = /* @__PURE__ */ s(function(N, B) {
      let R = Lt(N);
      if (!("sections" in R))
        return new Ie(R, B);
      let W = [], ue = [], te = [], Se = [], De = [];
      rr(R, B, W, ue, te, Se, De, 0, 0, 1 / 0, 1 / 0);
      let me = {
        version: 3,
        file: R.file,
        names: Se,
        sources: ue,
        sourcesContent: te,
        mappings: W,
        ignoreList: De
      };
      return ap(me);
    }, "AnyMap");
    function Lt(N) {
      return typeof N == "string" ? JSON.parse(N) : N;
    }
    s(Lt, "parse");
    function rr(N, B, R, W, ue, te, Se, De, me, ke, mt) {
      let { sections: Ke } = N;
      for (let Ve = 0; Ve < Ke.length; Ve++) {
        let { map: nt, offset: Ft } = Ke[Ve], vr = ke, $r = mt;
        if (Ve + 1 < Ke.length) {
          let Hr = Ke[Ve + 1].offset;
          vr = Math.min(ke, De + Hr.line), vr === ke ? $r = Math.min(mt, me + Hr.column) : vr < ke && ($r = me + Hr.column);
        }
        Is(nt, B, R, W, ue, te, Se, De + Ft.line, me + Ft.column, vr, $r);
      }
    }
    s(rr, "recurse");
    function Is(N, B, R, W, ue, te, Se, De, me, ke, mt) {
      let Ke = Lt(N);
      if ("sections" in Ke)
        return rr(...arguments);
      let Ve = new Ie(Ke, B), nt = W.length, Ft = te.length, vr = He(Ve), { resolvedSources: $r, sourcesContent: Hr, ignoreList: ca } = Ve;
      if (Mt(W, $r), Mt(te, Ve.names), Hr)
        Mt(ue, Hr);
      else
        for (let xt = 0; xt < $r.length; xt++)
          ue.push(null);
      if (ca)
        for (let xt = 0; xt < ca.length; xt++)
          Se.push(ca[xt] + nt);
      for (let xt = 0; xt < vr.length; xt++) {
        let pa = De + xt;
        if (pa > ke)
          return;
        let lp = ie(R, pa), D0 = xt === 0 ? me : 0, up = vr[xt];
        for (let fa = 0; fa < up.length; fa++) {
          let Cr = up[fa], _s = D0 + Cr[a];
          if (pa === ke && _s >= mt)
            return;
          if (Cr.length === 1) {
            lp.push([_s]);
            continue;
          }
          let cp = nt + Cr[o], pp = Cr[l], fp = Cr[u];
          lp.push(Cr.length === 4 ? [_s, cp, pp, fp] : [_s, cp, pp, fp, Ft + Cr[c]]);
        }
      }
    }
    s(Is, "addSection");
    function Mt(N, B) {
      for (let R = 0; R < B.length; R++)
        N.push(B[R]);
    }
    s(Mt, "append");
    function ie(N, B) {
      for (let R = N.length; R <= B; R++)
        N[R] = [];
      return N[B];
    }
    s(ie, "getLine");
    let Q = "`line` must be greater than 0 (lines start at line 1)", ne = "`column` must be greater than or equal to 0 (columns start at col\
umn 0)", ce = -1, _e = 1;
    class Ie {
      static {
        s(this, "TraceMap");
      }
      constructor(B, R) {
        let W = typeof B == "string";
        if (!W && B._decodedMemo)
          return B;
        let ue = W ? JSON.parse(B) : B, { version: te, file: Se, names: De, sourceRoot: me, sources: ke, sourcesContent: mt } = ue;
        this.version = te, this.file = Se, this.names = De || [], this.sourceRoot = me, this.sources = ke, this.sourcesContent = mt, this.ignoreList =
        ue.ignoreList || ue.x_google_ignoreList || void 0;
        let Ke = i(me || "", n(R));
        this.resolvedSources = ke.map((nt) => i(nt || "", Ke));
        let { mappings: Ve } = ue;
        typeof Ve == "string" ? (this._encoded = Ve, this._decoded = void 0) : (this._encoded = void 0, this._decoded = P(Ve, W)), this._decodedMemo =
        $(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function Me(N) {
      return N;
    }
    s(Me, "cast");
    function et(N) {
      var B, R;
      return (B = (R = N)._encoded) !== null && B !== void 0 ? B : R._encoded = t.encode(N._decoded);
    }
    s(et, "encodedMappings");
    function He(N) {
      var B;
      return (B = N)._decoded || (B._decoded = t.decode(N._encoded));
    }
    s(He, "decodedMappings");
    function Ci(N, B, R) {
      let W = He(N);
      if (B >= W.length)
        return null;
      let ue = W[B], te = Ns(ue, N._decodedMemo, B, R, _e);
      return te === -1 ? null : ue[te];
    }
    s(Ci, "traceSegment");
    function Xr(N, B) {
      let { line: R, column: W, bias: ue } = B;
      if (R--, R < 0)
        throw new Error(Q);
      if (W < 0)
        throw new Error(ne);
      let te = He(N);
      if (R >= te.length)
        return Os(null, null, null, null);
      let Se = te[R], De = Ns(Se, N._decodedMemo, R, W, ue || _e);
      if (De === -1)
        return Os(null, null, null, null);
      let me = Se[De];
      if (me.length === 1)
        return Os(null, null, null, null);
      let { names: ke, resolvedSources: mt } = N;
      return Os(mt[me[o]], me[l] + 1, me[u], me.length === 5 ? ke[me[c]] : null);
    }
    s(Xr, "originalPositionFor");
    function xr(N, B) {
      let { source: R, line: W, column: ue, bias: te } = B;
      return op(N, R, W, ue, te || _e, !1);
    }
    s(xr, "generatedPositionFor");
    function Jr(N, B) {
      let { source: R, line: W, column: ue, bias: te } = B;
      return op(N, R, W, ue, te || ce, !0);
    }
    s(Jr, "allGeneratedPositionsFor");
    function Er(N, B) {
      let R = He(N), { names: W, resolvedSources: ue } = N;
      for (let te = 0; te < R.length; te++) {
        let Se = R[te];
        for (let De = 0; De < Se.length; De++) {
          let me = Se[De], ke = te + 1, mt = me[0], Ke = null, Ve = null, nt = null, Ft = null;
          me.length !== 1 && (Ke = ue[me[1]], Ve = me[2] + 1, nt = me[3]), me.length === 5 && (Ft = W[me[4]]), B({
            generatedLine: ke,
            generatedColumn: mt,
            source: Ke,
            originalLine: Ve,
            originalColumn: nt,
            name: Ft
          });
        }
      }
    }
    s(Er, "eachMapping");
    function Pr(N, B) {
      let { sources: R, resolvedSources: W } = N, ue = R.indexOf(B);
      return ue === -1 && (ue = W.indexOf(B)), ue;
    }
    s(Pr, "sourceIndex");
    function Ar(N, B) {
      let { sourcesContent: R } = N;
      if (R == null)
        return null;
      let W = Pr(N, B);
      return W === -1 ? null : R[W];
    }
    s(Ar, "sourceContentFor");
    function ws(N, B) {
      let { ignoreList: R } = N;
      if (R == null)
        return !1;
      let W = Pr(N, B);
      return W === -1 ? !1 : R.includes(W);
    }
    s(ws, "isIgnored");
    function ap(N, B) {
      let R = new Ie(ua(N, []), B);
      return R._decoded = N.mappings, R;
    }
    s(ap, "presortedDecodedMap");
    function O0(N) {
      return ua(N, He(N));
    }
    s(O0, "decodedMap");
    function N0(N) {
      return ua(N, et(N));
    }
    s(N0, "encodedMap");
    function ua(N, B) {
      return {
        version: N.version,
        file: N.file,
        names: N.names,
        sourceRoot: N.sourceRoot,
        sources: N.sources,
        sourcesContent: N.sourcesContent,
        mappings: B,
        ignoreList: N.ignoreList || N.x_google_ignoreList
      };
    }
    s(ua, "clone");
    function Os(N, B, R, W) {
      return { source: N, line: B, column: R, name: W };
    }
    s(Os, "OMapping");
    function Ii(N, B) {
      return { line: N, column: B };
    }
    s(Ii, "GMapping");
    function Ns(N, B, R, W, ue) {
      let te = K(N, W, B, R);
      return O ? te = (ue === ce ? F : G)(N, W, te) : ue === ce && te++, te === -1 || te === N.length ? -1 : te;
    }
    s(Ns, "traceSegmentInternal");
    function _0(N, B, R, W, ue) {
      let te = Ns(N, B, R, W, _e);
      if (!O && ue === ce && te++, te === -1 || te === N.length)
        return [];
      let Se = O ? W : N[te][a];
      O || (te = G(N, Se, te));
      let De = F(N, Se, te), me = [];
      for (; te <= De; te++) {
        let ke = N[te];
        me.push(Ii(ke[p] + 1, ke[g]));
      }
      return me;
    }
    s(_0, "sliceGeneratedPositions");
    function op(N, B, R, W, ue, te) {
      var Se;
      if (R--, R < 0)
        throw new Error(Q);
      if (W < 0)
        throw new Error(ne);
      let { sources: De, resolvedSources: me } = N, ke = De.indexOf(B);
      if (ke === -1 && (ke = me.indexOf(B)), ke === -1)
        return te ? [] : Ii(null, null);
      let Ke = ((Se = N)._bySources || (Se._bySources = oe(He(N), N._bySourceMemos = De.map($))))[ke][R];
      if (Ke == null)
        return te ? [] : Ii(null, null);
      let Ve = N._bySourceMemos[ke];
      if (te)
        return _0(Ke, Ve, R, W, ue);
      let nt = Ns(Ke, Ve, R, W, ue);
      if (nt === -1)
        return Ii(null, null);
      let Ft = Ke[nt];
      return Ii(Ft[p] + 1, Ft[g]);
    }
    s(op, "generatedPosition"), e.AnyMap = $e, e.GREATEST_LOWER_BOUND = _e, e.LEAST_UPPER_BOUND = ce, e.TraceMap = Ie, e.allGeneratedPositionsFor =
    Jr, e.decodedMap = O0, e.decodedMappings = He, e.eachMapping = Er, e.encodedMap = N0, e.encodedMappings = et, e.generatedPositionFor = xr,
    e.isIgnored = ws, e.originalPositionFor = Xr, e.presortedDecodedMap = ap, e.sourceContentFor = Ar, e.traceSegment = Ci;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var Sh = v((on, bh) => {
  (function(e, t) {
    typeof on == "object" && typeof bh < "u" ? t(on, mh(), yl(), bl()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], t) : (e = typeof globalThis < "u" ? globalThis : e || self,
    t(e.genMapping = {}, e.setArray, e.sourcemapCodec, e.traceMapping));
  })(on, function(e, t, r, i) {
    "use strict";
    class p {
      static {
        s(this, "GenMapping");
      }
      constructor({ file: Q, sourceRoot: ne } = {}) {
        this._names = new t.SetArray(), this._sources = new t.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = Q, this.
        sourceRoot = ne, this._ignoreList = new t.SetArray();
      }
    }
    function g(ie) {
      return ie;
    }
    s(g, "cast");
    function P(ie, Q, ne, ce, _e, Ie, Me, et) {
      return K(!1, ie, Q, ne, ce, _e, Ie, Me, et);
    }
    s(P, "addSegment");
    function A(ie, Q) {
      return Mt(!1, ie, Q);
    }
    s(A, "addMapping");
    let C = /* @__PURE__ */ s((ie, Q, ne, ce, _e, Ie, Me, et) => K(!0, ie, Q, ne, ce, _e, Ie, Me, et), "maybeAddSegment"), _ = /* @__PURE__ */ s(
    (ie, Q) => Mt(!0, ie, Q), "maybeAddMapping");
    function k(ie, Q, ne) {
      let { _sources: ce, _sourcesContent: _e } = ie, Ie = t.put(ce, Q);
      _e[Ie] = ne;
    }
    s(k, "setSourceContent");
    function O(ie, Q, ne = !0) {
      let { _sources: ce, _sourcesContent: _e, _ignoreList: Ie } = ie, Me = t.put(ce, Q);
      Me === _e.length && (_e[Me] = null), ne ? t.put(Ie, Me) : t.remove(Ie, Me);
    }
    s(O, "setIgnore");
    function M(ie) {
      let { _mappings: Q, _sources: ne, _sourcesContent: ce, _names: _e, _ignoreList: Ie } = ie;
      return $e(Q), {
        version: 3,
        file: ie.file || void 0,
        names: _e.array,
        sourceRoot: ie.sourceRoot || void 0,
        sources: ne.array,
        sourcesContent: ce,
        mappings: Q,
        ignoreList: Ie.array
      };
    }
    s(M, "toDecodedMap");
    function F(ie) {
      let Q = M(ie);
      return Object.assign(Object.assign({}, Q), { mappings: r.encode(Q.mappings) });
    }
    s(F, "toEncodedMap");
    function G(ie) {
      let Q = new i.TraceMap(ie), ne = new p({ file: Q.file, sourceRoot: Q.sourceRoot });
      return Lt(ne._names, Q.names), Lt(ne._sources, Q.sources), ne._sourcesContent = Q.sourcesContent || Q.sources.map(() => null), ne._mappings =
      i.decodedMappings(Q), Q.ignoreList && Lt(ne._ignoreList, Q.ignoreList), ne;
    }
    s(G, "fromMap");
    function $(ie) {
      let Q = [], { _mappings: ne, _sources: ce, _names: _e } = ie;
      for (let Ie = 0; Ie < ne.length; Ie++) {
        let Me = ne[Ie];
        for (let et = 0; et < Me.length; et++) {
          let He = Me[et], Ci = { line: Ie + 1, column: He[0] }, Xr, xr, Jr;
          He.length !== 1 && (Xr = ce.array[He[1]], xr = { line: He[2] + 1, column: He[3] }, He.length === 5 && (Jr = _e.array[He[4]])), Q.push(
          { generated: Ci, source: Xr, original: xr, name: Jr });
        }
      }
      return Q;
    }
    s($, "allMappings");
    function K(ie, Q, ne, ce, _e, Ie, Me, et, He) {
      let { _mappings: Ci, _sources: Xr, _sourcesContent: xr, _names: Jr } = Q, Er = oe(Ci, ne), Pr = Oe(Er, ce);
      if (!_e)
        return ie && rr(Er, Pr) ? void 0 : Ne(Er, Pr, [ce]);
      let Ar = t.put(Xr, _e), ws = et ? t.put(Jr, et) : -1;
      if (Ar === xr.length && (xr[Ar] = He ?? null), !(ie && Is(Er, Pr, Ar, Ie, Me, ws)))
        return Ne(Er, Pr, et ? [ce, Ar, Ie, Me, ws] : [ce, Ar, Ie, Me]);
    }
    s(K, "addSegmentInternal");
    function oe(ie, Q) {
      for (let ne = ie.length; ne <= Q; ne++)
        ie[ne] = [];
      return ie[Q];
    }
    s(oe, "getLine");
    function Oe(ie, Q) {
      let ne = ie.length;
      for (let ce = ne - 1; ce >= 0; ne = ce--) {
        let _e = ie[ce];
        if (Q >= _e[0])
          break;
      }
      return ne;
    }
    s(Oe, "getColumnIndex");
    function Ne(ie, Q, ne) {
      for (let ce = ie.length; ce > Q; ce--)
        ie[ce] = ie[ce - 1];
      ie[Q] = ne;
    }
    s(Ne, "insert");
    function $e(ie) {
      let { length: Q } = ie, ne = Q;
      for (let ce = ne - 1; ce >= 0 && !(ie[ce].length > 0); ne = ce, ce--)
        ;
      ne < Q && (ie.length = ne);
    }
    s($e, "removeEmptyFinalLines");
    function Lt(ie, Q) {
      for (let ne = 0; ne < Q.length; ne++)
        t.put(ie, Q[ne]);
    }
    s(Lt, "putAll");
    function rr(ie, Q) {
      return Q === 0 ? !0 : ie[Q - 1].length === 1;
    }
    s(rr, "skipSourceless");
    function Is(ie, Q, ne, ce, _e, Ie) {
      if (Q === 0)
        return !1;
      let Me = ie[Q - 1];
      return Me.length === 1 ? !1 : ne === Me[1] && ce === Me[2] && _e === Me[3] && Ie === (Me.length === 5 ? Me[4] : -1);
    }
    s(Is, "skipSource");
    function Mt(ie, Q, ne) {
      let { generated: ce, source: _e, original: Ie, name: Me, content: et } = ne;
      return _e ? K(ie, Q, ce.line - 1, ce.column, _e, Ie.line - 1, Ie.column, Me, et) : K(ie, Q, ce.line - 1, ce.column, null, null, null, null,
      null);
    }
    s(Mt, "addMappingInternal"), e.GenMapping = p, e.addMapping = A, e.addSegment = P, e.allMappings = $, e.fromMap = G, e.maybeAddMapping =
    _, e.maybeAddSegment = C, e.setIgnore = O, e.setSourceContent = k, e.toDecodedMap = M, e.toEncodedMap = F, Object.defineProperty(e, "__e\
sModule", { value: !0 });
  });
});

// ../node_modules/@babel/generator/lib/source-map.js
var xh = v((ln) => {
  "use strict";
  Object.defineProperty(ln, "__esModule", {
    value: !0
  });
  ln.default = void 0;
  var lr = Sh(), Sl = bl(), xl = class {
    static {
      s(this, "SourceMap");
    }
    constructor(t, r) {
      var i;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let n = this._map = new lr.GenMapping({
        sourceRoot: t.sourceRoot
      });
      if (this._sourceFileName = (i = t.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
        this._inputMap = new Sl.TraceMap(t.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, lr.setSourceContent)(n, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !t.inputSourceMap)
        (0, lr.setSourceContent)(n, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, lr.setSourceContent)(n, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, lr.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, lr.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, lr.allMappings)(this._map));
    }
    mark(t, r, i, n, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, Sl.originalPositionFor)(this._inputMap, {
            line: r,
            column: i
          }), !u.name && a) {
            let c = (0, Sl.originalPositionFor)(this._inputMap, a);
            c.name && (n = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: i
          };
      (0, lr.maybeAddMapping)(this._map, {
        name: n,
        generated: t,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  ln.default = xl;
});

// ../node_modules/@babel/generator/lib/buffer.js
var Eh = v((un) => {
  "use strict";
  Object.defineProperty(un, "__esModule", {
    value: !0
  });
  un.default = void 0;
  var El = class {
    static {
      s(this, "Buffer");
    }
    constructor(t, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = t, this._indentChar = r;
      for (let i = 0; i < 64; i++)
        this._fastIndentations.push(r.repeat(i));
      this._allocQueue();
    }
    _allocQueue() {
      let t = this._queue;
      for (let r = 0; r < 16; r++)
        t.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(t, r, i, n, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = t, l.repeat = r, l.line = i, l.column = n, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let t = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: t?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let i = t ? t.get() : null;
          return r.map = i, i;
        },
        set map(i) {
          Object.defineProperty(r, "map", {
            value: i,
            writable: !0
          });
        },
        get rawMappings() {
          let i = t?.getRawMappings();
          return r.rawMappings = i, i;
        },
        set rawMappings(i) {
          Object.defineProperty(r, "rawMappings", {
            value: i,
            writable: !0
          });
        }
      };
      return r;
    }
    append(t, r) {
      this._flush(), this._append(t, this._sourcePosition, r);
    }
    appendChar(t) {
      this._flush(), this._appendChar(t, 1, this._sourcePosition);
    }
    queue(t) {
      if (t === 10)
        for (; this._queueCursor !== 0; ) {
          let i = this._queue[this._queueCursor - 1].char;
          if (i !== 32 && i !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(t, 1, r.line, r.column, r.filename);
    }
    queueIndentation(t) {
      t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
    }
    _flush() {
      let t = this._queueCursor, r = this._queue;
      for (let i = 0; i < t; i++) {
        let n = r[i];
        this._appendChar(n.char, n.repeat, n);
      }
      this._queueCursor = 0;
    }
    _appendChar(t, r, i) {
      if (this._last = t, t === -1) {
        let n = this._fastIndentations[r];
        n !== void 0 ? this._str += n : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
      t !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
    }
    _append(t, r, i) {
      let n = t.length, a = this._position;
      if (this._last = t.charCodeAt(n - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount =
      0) : this._str += t, !i && !this._map) {
        a.column += n;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = r, p = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let g = t.indexOf(`
`), P = 0;
      for (g !== 0 && this._mark(p, o, l, u, c); g !== -1; )
        a.line++, a.column = 0, P = g + 1, P < n && p !== void 0 && this._mark(++p, 0, null, null, c), g = t.indexOf(`
`, P);
      a.column += n - P;
    }
    _mark(t, r, i, n, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, t, r, i, n, a);
    }
    removeTrailingNewline() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let t = this._queueCursor;
      return t !== 0 ? this._queue[t - 1].char : this._last;
    }
    getNewlineCount() {
      let t = this._queueCursor, r = 0;
      if (t === 0) return this._last === 10 ? 1 : 0;
      for (let i = t - 1; i >= 0 && this._queue[i].char === 10; i--)
        r++;
      return r === t && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let t = this._queue, r = this._queueCursor;
      if (r !== 0)
        return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(t, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", t);
      let i = t.identifierName, n = this._sourcePosition;
      i && (this._canMarkIdName = !1, n.identifierName = i), r(), i && (this._canMarkIdName = !0, n.identifierName = void 0, n.identifierNamePos =
      void 0), this.source("end", t);
    }
    source(t, r) {
      this._map && this._normalizePosition(t, r, 0);
    }
    sourceWithOffset(t, r, i) {
      this._map && this._normalizePosition(t, r, i);
    }
    withSource(t, r, i) {
      this._map && this.source(t, r), i();
    }
    _normalizePosition(t, r, i) {
      let n = r[t], a = this._sourcePosition;
      n && (a.line = n.line, a.column = Math.max(n.column + i, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let t = this._queue, r = this._queueCursor, i = -1, n = 0;
      for (let a = 0; a < r; a++) {
        let o = t[a];
        o.char === 10 && (i = n), n += o.repeat;
      }
      return i === -1 ? this._position.column + n : n - 1 - i;
    }
    getCurrentLine() {
      let t = 0, r = this._queue;
      for (let i = 0; i < this._queueCursor; i++)
        r[i].char === 10 && t++;
      return this._position.line + t;
    }
  };
  un.default = El;
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var Ih = v((pn) => {
  "use strict";
  Object.defineProperty(pn, "__esModule", {
    value: !0
  });
  pn.nodes = void 0;
  var YM = le(), {
    FLIPPED_ALIAS_KEYS: XM,
    isArrayExpression: JM,
    isAssignmentExpression: Ah,
    isBinary: vh,
    isBlockStatement: $M,
    isCallExpression: Ch,
    isFunction: Xi,
    isIdentifier: cn,
    isLiteral: HM,
    isMemberExpression: Pl,
    isObjectExpression: GM,
    isOptionalCallExpression: zM,
    isOptionalMemberExpression: QM,
    isStringLiteral: ZM
  } = YM;
  function ti(e, t) {
    return e && (Pl(e) || QM(e) ? (ti(e.object, t), e.computed && ti(e.property, t)) : vh(e) || Ah(e) ? (ti(e.left, t), ti(e.right, t)) : Ch(
    e) || zM(e) ? (t.hasCall = !0, ti(e.callee, t)) : Xi(e) ? t.hasFunction = !0 : cn(e) && (t.hasHelper = t.hasHelper || e.callee && Yt(e.callee))),
    t;
  }
  s(ti, "crawlInternal");
  function Ph(e) {
    return ti(e, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  s(Ph, "crawl");
  function Yt(e) {
    return e ? Pl(e) ? Yt(e.object) || Yt(e.property) : cn(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : Ch(e) ? Yt(e.callee) :
    vh(e) || Ah(e) ? cn(e.left) && Yt(e.left) || Yt(e.right) : !1 : !1;
  }
  s(Yt, "isHelper");
  function e3(e) {
    return HM(e) || GM(e) || JM(e) || cn(e) || Pl(e);
  }
  s(e3, "isType");
  var Dr = pn.nodes = {
    AssignmentExpression(e) {
      let t = Ph(e.right);
      if (t.hasCall && t.hasHelper || t.hasFunction)
        return t.hasFunction ? 3 : 2;
    },
    SwitchCase(e, t) {
      return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
    },
    LogicalExpression(e) {
      if (Xi(e.left) || Xi(e.right))
        return 2;
    },
    Literal(e) {
      if (ZM(e) && e.value === "use strict")
        return 2;
    },
    CallExpression(e) {
      if (Xi(e.callee) || Yt(e))
        return 3;
    },
    OptionalCallExpression(e) {
      if (Xi(e.callee))
        return 3;
    },
    VariableDeclaration(e) {
      for (let t = 0; t < e.declarations.length; t++) {
        let r = e.declarations[t], i = Yt(r.id) && !e3(r.init);
        if (!i && r.init) {
          let n = Ph(r.init);
          i = Yt(r.init) && n.hasCall || n.hasFunction;
        }
        if (i)
          return 3;
      }
    },
    IfStatement(e) {
      if ($M(e.consequent))
        return 3;
    }
  };
  Dr.ObjectProperty = Dr.ObjectTypeProperty = Dr.ObjectMethod = function(e, t) {
    if (t.properties[0] === e)
      return 1;
  };
  Dr.ObjectTypeCallProperty = function(e, t) {
    var r;
    if (t.callProperties[0] === e && !((r = t.properties) != null && r.length))
      return 1;
  };
  Dr.ObjectTypeIndexer = function(e, t) {
    var r, i;
    if (t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length))
      return 1;
  };
  Dr.ObjectTypeInternalSlot = function(e, t) {
    var r, i, n;
    if (t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length) && !((n = t.indexers) !=
    null && n.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  e, t]) {
    [e].concat(XM[e] || []).forEach(function(r) {
      let i = t ? 3 : 0;
      Dr[r] = () => i;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var Dh = v((Pe) => {
  "use strict";
  Object.defineProperty(Pe, "__esModule", {
    value: !0
  });
  Pe.ArrowFunctionExpression = O3;
  Pe.AssignmentExpression = _3;
  Pe.Binary = T3;
  Pe.BinaryExpression = A3;
  Pe.ClassExpression = I3;
  Pe.ConditionalExpression = Al;
  Pe.DoExpression = y3;
  Pe.FunctionExpression = w3;
  Pe.FunctionTypeAnnotation = h3;
  Pe.Identifier = k3;
  Pe.LogicalExpression = D3;
  Pe.NullableTypeAnnotation = f3;
  Pe.ObjectExpression = m3;
  Pe.OptionalIndexedAccessType = b3;
  Pe.OptionalCallExpression = Pe.OptionalMemberExpression = N3;
  Pe.SequenceExpression = v3;
  Pe.TSTypeAssertion = Pe.TSSatisfiesExpression = Pe.TSAsExpression = S3;
  Pe.TSInferType = E3;
  Pe.TSInstantiationExpression = P3;
  Pe.TSIntersectionType = Pe.TSUnionType = x3;
  Pe.UnaryLike = _h;
  Pe.IntersectionTypeAnnotation = Pe.UnionTypeAnnotation = g3;
  Pe.UpdateExpression = d3;
  Pe.AwaitExpression = Pe.YieldExpression = C3;
  var t3 = le(), {
    isArrayTypeAnnotation: r3,
    isArrowFunctionExpression: i3,
    isBinaryExpression: s3,
    isCallExpression: n3,
    isExportDeclaration: a3,
    isForOfStatement: o3,
    isIndexedAccessType: l3,
    isMemberExpression: Oh,
    isObjectPattern: u3,
    isOptionalMemberExpression: c3,
    isYieldExpression: p3
  } = t3, wh = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function Nh(e) {
    return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
  }
  s(Nh, "isTSTypeExpression");
  var fn = /* @__PURE__ */ s((e, t) => {
    let r = t.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
  }, "isClassExtendsClause"), Ji = /* @__PURE__ */ s((e, t) => {
    let r = t.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function f3(e, t) {
    return r3(t);
  }
  s(f3, "NullableTypeAnnotation");
  function h3(e, t, r) {
    if (r.length < 3) return;
    let i = t.type;
    return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || i === "TypeAnnotation" && i3(
    r[r.length - 3]);
  }
  s(h3, "FunctionTypeAnnotation");
  function d3(e, t) {
    return Ji(e, t) || fn(e, t);
  }
  s(d3, "UpdateExpression");
  function m3(e, t, r) {
    return $i(r, 3);
  }
  s(m3, "ObjectExpression");
  function y3(e, t, r) {
    return !e.async && $i(r, 1);
  }
  s(y3, "DoExpression");
  function T3(e, t) {
    let r = t.type;
    if (e.operator === "**" && r === "BinaryExpression" && t.operator === "**")
      return t.left === e;
    if (fn(e, t) || Ji(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    if (r === "BinaryExpression" || r === "LogicalExpression") {
      let i = wh.get(t.operator), n = wh.get(e.operator);
      if (i === n && t.right === e && r !== "LogicalExpression" || i > n)
        return !0;
    }
  }
  s(T3, "Binary");
  function g3(e, t) {
    let r = t.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  s(g3, "UnionTypeAnnotation");
  function b3(e, t) {
    return l3(t) && t.objectType === e;
  }
  s(b3, "OptionalIndexedAccessType");
  function S3() {
    return !0;
  }
  s(S3, "TSAsExpression");
  function x3(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
  }
  s(x3, "TSUnionType");
  function E3(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSOptionalType";
  }
  s(E3, "TSInferType");
  function P3(e, t) {
    let r = t.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
  }
  s(P3, "TSInstantiationExpression");
  function A3(e, t) {
    if (e.operator === "in") {
      let r = t.type;
      return r === "VariableDeclarator" || r === "ForStatement" || r === "ForInStatement" || r === "ForOfStatement";
    }
    return !1;
  }
  s(A3, "BinaryExpression");
  function v3(e, t) {
    let r = t.type;
    return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && t.test === e || r === "Whil\
eStatement" && t.test === e || r === "ForInStatement" && t.right === e || r === "SwitchStatement" && t.discriminant === e || r === "Expressi\
onStatement" && t.expression === e);
  }
  s(v3, "SequenceExpression");
  function C3(e, t) {
    let r = t.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || Ji(e, t) || r === "A\
waitExpression" && p3(e) || r === "ConditionalExpression" && e === t.test || fn(e, t);
  }
  s(C3, "YieldExpression");
  function I3(e, t, r) {
    return $i(r, 5);
  }
  s(I3, "ClassExpression");
  function _h(e, t) {
    return Ji(e, t) || s3(t) && t.operator === "**" && t.left === e || fn(e, t);
  }
  s(_h, "UnaryLike");
  function w3(e, t, r) {
    return $i(r, 5);
  }
  s(w3, "FunctionExpression");
  function O3(e, t) {
    return a3(t) || Al(e, t);
  }
  s(O3, "ArrowFunctionExpression");
  function Al(e, t) {
    let r = t.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && t.test === e || r === "AwaitExpression" || Nh(r) ? !0 : _h(e, t);
  }
  s(Al, "ConditionalExpression");
  function N3(e, t) {
    return n3(t) && t.callee === e || Oh(t) && t.object === e;
  }
  s(N3, "OptionalMemberExpression");
  function _3(e, t) {
    return u3(e.left) ? !0 : Al(e, t);
  }
  s(_3, "AssignmentExpression");
  function D3(e, t) {
    let r = t.type;
    if (Nh(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (e.operator) {
      case "||":
        return t.operator === "??" || t.operator === "&&";
      case "&&":
        return t.operator === "??";
      case "??":
        return t.operator !== "??";
    }
  }
  s(D3, "LogicalExpression");
  function k3(e, t, r) {
    var i;
    let n = t.type;
    if ((i = e.extra) != null && i.parenthesized && n === "AssignmentExpression" && t.left === e) {
      let a = t.right.type;
      if ((a === "FunctionExpression" || a === "ClassExpression") && t.right.id == null)
        return !0;
    }
    if (e.name === "let") {
      let a = Oh(t, {
        object: e,
        computed: !0
      }) || c3(t, {
        object: e,
        computed: !0,
        optional: !1
      });
      return $i(r, a ? 57 : 32);
    }
    return e.name === "async" && o3(t) && e === t.left;
  }
  s(k3, "Identifier");
  function $i(e, t) {
    let r = t & 1, i = t & 2, n = t & 4, a = t & 8, o = t & 16, l = t & 32, u = e.length - 1;
    if (u <= 0) return;
    let c = e[u];
    u--;
    let p = e[u];
    for (; u >= 0; ) {
      let g = p.type;
      if (r && g === "ExpressionStatement" && p.expression === c || n && g === "ExportDefaultDeclaration" && c === p.declaration || i && g ===
      "ArrowFunctionExpression" && p.body === c || a && g === "ForStatement" && p.init === c || o && g === "ForInStatement" && p.left === c ||
      l && g === "ForOfStatement" && p.left === c)
        return !0;
      if (u > 0 && (Ji(c, p) && g !== "NewExpression" || g === "SequenceExpression" && p.expressions[0] === c || g === "UpdateExpression" &&
      !p.prefix || g === "ConditionalExpression" && p.test === c || (g === "BinaryExpression" || g === "LogicalExpression") && p.left === c ||
      g === "AssignmentExpression" && p.left === c))
        c = p, u--, p = e[u];
      else
        return !1;
    }
    return !1;
  }
  s($i, "isFirstInContext");
});

// ../node_modules/@babel/generator/lib/node/index.js
var Cl = v((ri) => {
  "use strict";
  Object.defineProperty(ri, "__esModule", {
    value: !0
  });
  ri.needsParens = X3;
  ri.needsWhitespace = vl;
  ri.needsWhitespaceAfter = Y3;
  ri.needsWhitespaceBefore = W3;
  var L3 = Ih(), M3 = Dh(), F3 = le(), {
    FLIPPED_ALIAS_KEYS: B3,
    isCallExpression: j3,
    isExpressionStatement: R3,
    isMemberExpression: q3,
    isNewExpression: V3
  } = F3;
  function kh(e) {
    let t = /* @__PURE__ */ new Map();
    function r(i, n) {
      let a = t.get(i);
      t.set(i, a ? function(o, l, u) {
        var c;
        return (c = a(o, l, u)) != null ? c : n(o, l, u);
      } : n);
    }
    s(r, "add");
    for (let i of Object.keys(e)) {
      let n = B3[i];
      if (n)
        for (let a of n)
          r(a, e[i]);
      else
        r(i, e[i]);
    }
    return t;
  }
  s(kh, "expandAliases");
  var U3 = kh(M3), K3 = kh(L3.nodes);
  function Lh(e) {
    return j3(e) ? !0 : q3(e) && Lh(e.object);
  }
  s(Lh, "isOrHasCallExpression");
  function vl(e, t, r) {
    var i;
    if (!e) return !1;
    R3(e) && (e = e.expression);
    let n = (i = K3.get(e.type)) == null ? void 0 : i(e, t);
    return typeof n == "number" ? (n & r) !== 0 : !1;
  }
  s(vl, "needsWhitespace");
  function W3(e, t) {
    return vl(e, t, 1);
  }
  s(W3, "needsWhitespaceBefore");
  function Y3(e, t) {
    return vl(e, t, 2);
  }
  s(Y3, "needsWhitespaceAfter");
  function X3(e, t, r) {
    var i;
    return t ? V3(t) && t.callee === e && Lh(e) ? !0 : (i = U3.get(e.type)) == null ? void 0 : i(e, t, r) : !1;
  }
  s(X3, "needsParens");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var Mh = v((Hi) => {
  "use strict";
  Object.defineProperty(Hi, "__esModule", {
    value: !0
  });
  Hi.TaggedTemplateExpression = J3;
  Hi.TemplateElement = $3;
  Hi.TemplateLiteral = H3;
  function J3(e) {
    this.print(e.tag, e), this.print(e.typeParameters, e), this.print(e.quasi, e);
  }
  s(J3, "TaggedTemplateExpression");
  function $3(e, t) {
    let r = t.quasis[0] === e, i = t.quasis[t.quasis.length - 1] === e, n = (r ? "`" : "}") + e.value.raw + (i ? "`" : "${");
    this.token(n, !0);
  }
  s($3, "TemplateElement");
  function H3(e) {
    let t = e.quasis;
    for (let r = 0; r < t.length; r++)
      this.print(t[r], e), r + 1 < t.length && this.print(e.expressions[r], e);
  }
  s(H3, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var jh = v((Ce) => {
  "use strict";
  Object.defineProperty(Ce, "__esModule", {
    value: !0
  });
  Ce.LogicalExpression = Ce.BinaryExpression = Ce.AssignmentExpression = xF;
  Ce.AssignmentPattern = SF;
  Ce.AwaitExpression = yF;
  Ce.BindExpression = EF;
  Ce.CallExpression = dF;
  Ce.ConditionalExpression = sF;
  Ce.Decorator = pF;
  Ce.DoExpression = tF;
  Ce.EmptyStatement = gF;
  Ce.ExpressionStatement = bF;
  Ce.Import = mF;
  Ce.MemberExpression = PF;
  Ce.MetaProperty = AF;
  Ce.ModuleExpression = IF;
  Ce.NewExpression = nF;
  Ce.OptionalCallExpression = hF;
  Ce.OptionalMemberExpression = fF;
  Ce.ParenthesizedExpression = rF;
  Ce.PrivateName = vF;
  Ce.SequenceExpression = aF;
  Ce.Super = lF;
  Ce.ThisExpression = oF;
  Ce.UnaryExpression = eF;
  Ce.UpdateExpression = iF;
  Ce.V8IntrinsicIdentifier = CF;
  Ce.YieldExpression = TF;
  Ce._shouldPrintDecoratorsBeforeExport = cF;
  var G3 = le(), z3 = Cl(), {
    isCallExpression: Q3,
    isLiteral: Fh,
    isMemberExpression: Il,
    isNewExpression: Z3
  } = G3;
  function eF(e) {
    let {
      operator: t
    } = e;
    t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument,
    e);
  }
  s(eF, "UnaryExpression");
  function tF(e) {
    e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body, e);
  }
  s(tF, "DoExpression");
  function rF(e) {
    this.tokenChar(40), this.print(e.expression, e), this.rightParens(e);
  }
  s(rF, "ParenthesizedExpression");
  function iF(e) {
    e.prefix ? (this.token(e.operator), this.print(e.argument, e)) : (this.printTerminatorless(e.argument, e, !0), this.token(e.operator));
  }
  s(iF, "UpdateExpression");
  function sF(e) {
    this.print(e.test, e), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent, e), this.space(), this.tokenChar(58), this.
    space(), this.print(e.alternate, e);
  }
  s(sF, "ConditionalExpression");
  function nF(e, t) {
    this.word("new"), this.space(), this.print(e.callee, e), !(this.format.minified && e.arguments.length === 0 && !e.optional && !Q3(t, {
      callee: e
    }) && !Il(t) && !Z3(t)) && (this.print(e.typeArguments, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.tokenChar(
    40), this.printList(e.arguments, e), this.rightParens(e));
  }
  s(nF, "NewExpression");
  function aF(e) {
    this.printList(e.expressions, e);
  }
  s(aF, "SequenceExpression");
  function oF() {
    this.word("this");
  }
  s(oF, "ThisExpression");
  function lF() {
    this.word("super");
  }
  s(lF, "Super");
  function Bh(e) {
    switch (e.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !e.computed && e.property.type === "Identifier" && Bh(e.object);
      default:
        return !1;
    }
  }
  s(Bh, "isDecoratorMemberExpression");
  function uF(e) {
    return e.type === "ParenthesizedExpression" ? !1 : !Bh(e.type === "CallExpression" ? e.callee : e);
  }
  s(uF, "shouldParenthesizeDecoratorExpression");
  function cF(e) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start ===
    e.declaration.start;
  }
  s(cF, "_shouldPrintDecoratorsBeforeExport");
  function pF(e) {
    this.tokenChar(64);
    let {
      expression: t
    } = e;
    uF(t) ? (this.tokenChar(40), this.print(t, e), this.tokenChar(41)) : this.print(t, e), this.newline();
  }
  s(pF, "Decorator");
  function fF(e) {
    let {
      computed: t
    } = e, {
      optional: r,
      property: i
    } = e;
    if (this.print(e.object, e), !t && Il(i))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    Fh(i) && typeof i.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(i, e), this.tokenChar(93)) :
    (r || this.tokenChar(46), this.print(i, e));
  }
  s(fF, "OptionalMemberExpression");
  function hF(e) {
    this.print(e.callee, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.print(e.typeArguments, e), this.tokenChar(
    40), this.printList(e.arguments, e), this.rightParens(e);
  }
  s(hF, "OptionalCallExpression");
  function dF(e) {
    this.print(e.callee, e), this.print(e.typeArguments, e), this.print(e.typeParameters, e), this.tokenChar(40), this.printList(e.arguments,
    e), this.rightParens(e);
  }
  s(dF, "CallExpression");
  function mF() {
    this.word("import");
  }
  s(mF, "Import");
  function yF(e) {
    this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
  }
  s(yF, "AwaitExpression");
  function TF(e) {
    this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument, e))) : e.argument && (this.
    space(), this.printTerminatorless(e.argument, e, !1));
  }
  s(TF, "YieldExpression");
  function gF() {
    this.semicolon(!0);
  }
  s(gF, "EmptyStatement");
  function bF(e) {
    this.print(e.expression, e), this.semicolon();
  }
  s(bF, "ExpressionStatement");
  function SF(e) {
    this.print(e.left, e), e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation, e), this.space(), this.tokenChar(61), this.
    space(), this.print(e.right, e);
  }
  s(SF, "AssignmentPattern");
  function xF(e, t) {
    let r = this.inForStatementInitCounter && e.operator === "in" && !z3.needsParens(e, t);
    r && this.tokenChar(40), this.print(e.left, e), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) :
    this.token(e.operator), this.space(), this.print(e.right, e), r && this.tokenChar(41);
  }
  s(xF, "AssignmentExpression");
  function EF(e) {
    this.print(e.object, e), this.token("::"), this.print(e.callee, e);
  }
  s(EF, "BindExpression");
  function PF(e) {
    if (this.print(e.object, e), !e.computed && Il(e.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let t = e.computed;
    Fh(e.property) && typeof e.property.value == "number" && (t = !0), t ? (this.tokenChar(91), this.print(e.property, e), this.tokenChar(93)) :
    (this.tokenChar(46), this.print(e.property, e));
  }
  s(PF, "MemberExpression");
  function AF(e) {
    this.print(e.meta, e), this.tokenChar(46), this.print(e.property, e);
  }
  s(AF, "MetaProperty");
  function vF(e) {
    this.tokenChar(35), this.print(e.id, e);
  }
  s(vF, "PrivateName");
  function CF(e) {
    this.tokenChar(37), this.word(e.name);
  }
  s(CF, "V8IntrinsicIdentifier");
  function IF(e) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: t
    } = e;
    (t.body.length || t.directives.length) && this.newline(), this.print(t, e), this.dedent(), this.rightBrace(e);
  }
  s(IF, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var Uh = v((Re) => {
  "use strict";
  Object.defineProperty(Re, "__esModule", {
    value: !0
  });
  Re.BreakStatement = BF;
  Re.CatchClause = KF;
  Re.ContinueStatement = jF;
  Re.DebuggerStatement = XF;
  Re.DoWhileStatement = FF;
  Re.ForOfStatement = Re.ForInStatement = void 0;
  Re.ForStatement = LF;
  Re.IfStatement = kF;
  Re.LabeledStatement = VF;
  Re.ReturnStatement = RF;
  Re.SwitchCase = YF;
  Re.SwitchStatement = WF;
  Re.ThrowStatement = qF;
  Re.TryStatement = UF;
  Re.VariableDeclaration = JF;
  Re.VariableDeclarator = $F;
  Re.WhileStatement = MF;
  Re.WithStatement = DF;
  var wF = le(), {
    isFor: Rh,
    isForStatement: OF,
    isIfStatement: NF,
    isStatement: _F
  } = wF;
  function DF(e) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(e.object, e), this.tokenChar(41), this.printBlock(e);
  }
  s(DF, "WithStatement");
  function kF(e) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.space();
    let t = e.alternate && NF(qh(e.consequent));
    t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent, e), t && (this.dedent(), this.newline(),
    this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    e.alternate, e));
  }
  s(kF, "IfStatement");
  function qh(e) {
    let {
      body: t
    } = e;
    return _F(t) === !1 ? e : qh(t);
  }
  s(qh, "getLastStatement");
  function LF(e) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(e.init, e), this.inForStatementInitCounter--,
    this.tokenChar(59), e.test && (this.space(), this.print(e.test, e)), this.tokenChar(59), e.update && (this.space(), this.print(e.update,
    e)), this.tokenChar(41), this.printBlock(e);
  }
  s(LF, "ForStatement");
  function MF(e) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.printBlock(e);
  }
  s(MF, "WhileStatement");
  function Vh(e) {
    this.word("for"), this.space();
    let t = e.type === "ForOfStatement";
    t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(e.left, e), this.space(),
    this.word(t ? "of" : "in"), this.space(), this.print(e.right, e), this.tokenChar(41), this.printBlock(e);
  }
  s(Vh, "ForXStatement");
  var bQ = Re.ForInStatement = Vh, SQ = Re.ForOfStatement = Vh;
  function FF(e) {
    this.word("do"), this.space(), this.print(e.body, e), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test,
    e), this.tokenChar(41), this.semicolon();
  }
  s(FF, "DoWhileStatement");
  function hn(e, t, r, i) {
    t && (e.space(), e.printTerminatorless(t, r, i)), e.semicolon();
  }
  s(hn, "printStatementAfterKeyword");
  function BF(e) {
    this.word("break"), hn(this, e.label, e, !0);
  }
  s(BF, "BreakStatement");
  function jF(e) {
    this.word("continue"), hn(this, e.label, e, !0);
  }
  s(jF, "ContinueStatement");
  function RF(e) {
    this.word("return"), hn(this, e.argument, e, !1);
  }
  s(RF, "ReturnStatement");
  function qF(e) {
    this.word("throw"), hn(this, e.argument, e, !1);
  }
  s(qF, "ThrowStatement");
  function VF(e) {
    this.print(e.label, e), this.tokenChar(58), this.space(), this.print(e.body, e);
  }
  s(VF, "LabeledStatement");
  function UF(e) {
    this.word("try"), this.space(), this.print(e.block, e), this.space(), e.handlers ? this.print(e.handlers[0], e) : this.print(e.handler, e),
    e.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e.finalizer, e));
  }
  s(UF, "TryStatement");
  function KF(e) {
    this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param, e), this.print(e.param.typeAnnotation, e), this.tokenChar(
    41), this.space()), this.print(e.body, e);
  }
  s(KF, "CatchClause");
  function WF(e) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant, e), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(e.cases, e, {
      indent: !0,
      addNewlines(t, r) {
        if (!t && e.cases[e.cases.length - 1] === r) return -1;
      }
    }), this.rightBrace(e);
  }
  s(WF, "SwitchStatement");
  function YF(e) {
    e.test ? (this.word("case"), this.space(), this.print(e.test, e), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.
    length && (this.newline(), this.printSequence(e.consequent, e, {
      indent: !0
    }));
  }
  s(YF, "SwitchCase");
  function XF() {
    this.word("debugger"), this.semicolon();
  }
  s(XF, "DebuggerStatement");
  function JF(e, t) {
    e.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = e;
    this.word(r, r === "using" || r === "await using"), this.space();
    let i = !1;
    if (!Rh(t))
      for (let n of e.declarations)
        n.init && (i = !0);
    if (this.printList(e.declarations, e, {
      separator: i ? function() {
        this.tokenChar(44), this.newline();
      } : void 0,
      indent: e.declarations.length > 1
    }), Rh(t)) {
      if (OF(t)) {
        if (t.init === e) return;
      } else if (t.left === e) return;
    }
    this.semicolon();
  }
  s(JF, "VariableDeclaration");
  function $F(e) {
    this.print(e.id, e), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation, e), e.init && (this.space(), this.tokenChar(61), this.
    space(), this.print(e.init, e));
  }
  s($F, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var Kh = v((Pt) => {
  "use strict";
  Object.defineProperty(Pt, "__esModule", {
    value: !0
  });
  Pt.ClassAccessorProperty = tB;
  Pt.ClassBody = ZF;
  Pt.ClassExpression = Pt.ClassDeclaration = QF;
  Pt.ClassMethod = iB;
  Pt.ClassPrivateMethod = sB;
  Pt.ClassPrivateProperty = rB;
  Pt.ClassProperty = eB;
  Pt.StaticBlock = aB;
  Pt._classMethodHead = nB;
  var HF = le(), {
    isExportDefaultDeclaration: GF,
    isExportNamedDeclaration: zF
  } = HF;
  function QF(e, t) {
    (!(GF(t) || zF(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators, e), e.declare && (this.word("declare"),
    this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id, e)), this.
    print(e.typeParameters, e), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass, e), this.print(e.
    superTypeParameters, e)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e)), this.space(),
    this.print(e.body, e);
  }
  s(QF, "ClassDeclaration");
  function ZF(e) {
    this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, e, {
      indent: !0
    }), this.endsWith(10) || this.newline(), this.rightBrace(e));
  }
  s(ZF, "ClassBody");
  function eB(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) :
    (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation,
    e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  s(eB, "ClassProperty");
  function tB(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.
    print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(
    33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  s(tB, "ClassAccessorProperty");
  function rB(e) {
    this.printJoin(e.decorators, e), e.static && (this.word("static"), this.space()), this.print(e.key, e), this.print(e.typeAnnotation, e),
    e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  s(rB, "ClassPrivateProperty");
  function iB(e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }
  s(iB, "ClassMethod");
  function sB(e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }
  s(sB, "ClassPrivateMethod");
  function nB(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this._methodHead(e);
  }
  s(nB, "_classMethodHead");
  function aB(e) {
    this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    e.body, e, {
      indent: !0
    }), this.rightBrace(e));
  }
  s(aB, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var Wh = v((Nt) => {
  "use strict";
  Object.defineProperty(Nt, "__esModule", {
    value: !0
  });
  Nt.ArrowFunctionExpression = yB;
  Nt.FunctionDeclaration = Nt.FunctionExpression = mB;
  Nt._functionHead = dB;
  Nt._methodHead = fB;
  Nt._param = pB;
  Nt._parameters = cB;
  Nt._params = uB;
  Nt._predicate = hB;
  var oB = le(), {
    isIdentifier: lB
  } = oB;
  function uB(e, t, r) {
    this.print(e.typeParameters, e);
    let i = gB.call(this, t, r);
    i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(e.params, e), this.tokenChar(41);
    let n = e.type === "ArrowFunctionExpression";
    this.print(e.returnType, e, n), this._noLineTerminator = n;
  }
  s(uB, "_params");
  function cB(e, t) {
    let r = e.length;
    for (let i = 0; i < r; i++)
      this._param(e[i], t), i < e.length - 1 && (this.tokenChar(44), this.space());
  }
  s(cB, "_parameters");
  function pB(e, t) {
    this.printJoin(e.decorators, e), this.print(e, t), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(pB, "_param");
  function fB(e) {
    let t = e.kind, r = e.key;
    (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t ===
    "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r, e), this.tokenChar(93)) : this.print(r, e),
    e.optional && this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
  }
  s(fB, "_methodHead");
  function hB(e, t) {
    e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, e, t));
  }
  s(hB, "_predicate");
  function dB(e, t) {
    e.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), e.generator && (this._endsWithInnerRaw =
    !1, this.tokenChar(42)), this.space(), e.id && this.print(e.id, e), this._params(e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(
    e);
  }
  s(dB, "_functionHead");
  function mB(e, t) {
    this._functionHead(e, t), this.space(), this.print(e.body, e);
  }
  s(mB, "FunctionExpression");
  function yB(e, t) {
    e.async && (this.word("async", !0), this.space());
    let r;
    !this.format.retainLines && e.params.length === 1 && lB(r = e.params[0]) && !TB(e, r) ? this.print(r, e, !0) : this._params(e, void 0, t),
    this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e.body, e);
  }
  s(yB, "ArrowFunctionExpression");
  function TB(e, t) {
    var r, i;
    return !!(e.typeParameters || e.returnType || e.predicate || t.typeAnnotation || t.optional || (r = t.leadingComments) != null && r.length ||
    (i = t.trailingComments) != null && i.length);
  }
  s(TB, "hasTypesOrComments");
  function gB(e, t) {
    let r = e;
    if (!r && t) {
      let u = t.type;
      u === "VariableDeclarator" ? r = t.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = t.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = t.key);
    }
    if (!r) return;
    let i;
    if (r.type === "Identifier") {
      var n, a;
      i = {
        pos: (n = r.loc) == null ? void 0 : n.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      i = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      i = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return i;
  }
  s(gB, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var wl = v((ct) => {
  "use strict";
  Object.defineProperty(ct, "__esModule", {
    value: !0
  });
  ct.ExportAllDeclaration = _B;
  ct.ExportDefaultDeclaration = kB;
  ct.ExportDefaultSpecifier = IB;
  ct.ExportNamedDeclaration = DB;
  ct.ExportNamespaceSpecifier = OB;
  ct.ExportSpecifier = wB;
  ct.ImportAttribute = MB;
  ct.ImportDeclaration = LB;
  ct.ImportDefaultSpecifier = CB;
  ct.ImportExpression = BB;
  ct.ImportNamespaceSpecifier = FB;
  ct.ImportSpecifier = vB;
  ct._printAttributes = NB;
  var bB = le(), {
    isClassDeclaration: SB,
    isExportDefaultSpecifier: xB,
    isExportNamespaceSpecifier: EB,
    isImportDefaultSpecifier: PB,
    isImportNamespaceSpecifier: AB,
    isStatement: Xh
  } = bB;
  function vB(e) {
    (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported, e), e.local &&
    e.local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local, e));
  }
  s(vB, "ImportSpecifier");
  function CB(e) {
    this.print(e.local, e);
  }
  s(CB, "ImportDefaultSpecifier");
  function IB(e) {
    this.print(e.exported, e);
  }
  s(IB, "ExportDefaultSpecifier");
  function wB(e) {
    e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local, e), e.exported && e.local.name !== e.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(e.exported, e));
  }
  s(wB, "ExportSpecifier");
  function OB(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported, e);
  }
  s(OB, "ExportNamespaceSpecifier");
  var Yh = !1;
  function NB(e) {
    let {
      importAttributesKeyword: t
    } = this.format, {
      attributes: r,
      assertions: i
    } = e;
    r && !t && !Yh && (Yh = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify \
the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\
\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let n = t === "assert" || !t && i;
    if (this.word(n ? "assert" : "with"), this.space(), !n && t !== "with") {
      this.printList(r || i, e);
      return;
    }
    this.tokenChar(123), this.space(), this.printList(r || i, e), this.space(), this.tokenChar(125);
  }
  s(NB, "_printAttributes");
  function _B(e) {
    var t, r;
    this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0),
    this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
  }
  s(_B, "ExportAllDeclaration");
  function Jh(e, t) {
    SB(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators, t);
  }
  s(Jh, "maybePrintDecoratorsBeforeExport");
  function DB(e) {
    if (Jh(this, e), this.word("export"), this.space(), e.declaration) {
      let i = e.declaration;
      this.print(i, e), Xh(i) || this.semicolon();
    } else {
      e.exportKind === "type" && (this.word("type"), this.space());
      let i = e.specifiers.slice(0), n = !1;
      for (; ; ) {
        let a = i[0];
        if (xB(a) || EB(a))
          n = !0, this.print(i.shift(), e), i.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      if ((i.length || !i.length && !n) && (this.tokenChar(123), i.length && (this.space(), this.printList(i, e), this.space()), this.tokenChar(
      125)), e.source) {
        var t, r;
        this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.
        print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e);
      }
      this.semicolon();
    }
  }
  s(DB, "ExportNamedDeclaration");
  function kB(e) {
    Jh(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
    let t = e.declaration;
    this.print(t, e), Xh(t) || this.semicolon();
  }
  s(kB, "ExportDefaultDeclaration");
  function LB(e) {
    var t, r;
    this.word("import"), this.space();
    let i = e.importKind === "type" || e.importKind === "typeof";
    i ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
    let n = e.specifiers.slice(0), a = !!n.length;
    for (; a; ) {
      let o = n[0];
      if (PB(o) || AB(o))
        this.print(n.shift(), e), n.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    n.length ? (this.tokenChar(123), this.space(), this.printList(n, e), this.space(), this.tokenChar(125)) : i && !a && (this.tokenChar(123),
    this.tokenChar(125)), (a || i) && (this.space(), this.word("from"), this.space()), (t = e.attributes) != null && t.length || (r = e.assertions) !=
    null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
  }
  s(LB, "ImportDeclaration");
  function MB(e) {
    this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
  }
  s(MB, "ImportAttribute");
  function FB(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local, e);
  }
  s(FB, "ImportNamespaceSpecifier");
  function BB(e) {
    this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40), this.print(e.source, e), e.options != null &&
    (this.tokenChar(44), this.space(), this.print(e.options, e)), this.tokenChar(41);
  }
  s(BB, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var zh = v((OQ, Gh) => {
  "use strict";
  var $h = {}, jB = $h.hasOwnProperty, Hh = /* @__PURE__ */ s((e, t) => {
    for (let r in e)
      jB.call(e, r) && t(r, e[r]);
  }, "forOwn"), RB = /* @__PURE__ */ s((e, t) => (t && Hh(t, (r, i) => {
    e[r] = i;
  }), e), "extend"), qB = /* @__PURE__ */ s((e, t) => {
    let r = e.length, i = -1;
    for (; ++i < r; )
      t(e[i]);
  }, "forEach"), Gi = $h.toString, VB = Array.isArray, UB = Buffer.isBuffer, KB = /* @__PURE__ */ s((e) => Gi.call(e) == "[object Object]", "\
isObject"), WB = /* @__PURE__ */ s((e) => typeof e == "string" || Gi.call(e) == "[object String]", "isString"), YB = /* @__PURE__ */ s((e) => typeof e ==
  "number" || Gi.call(e) == "[object Number]", "isNumber"), XB = /* @__PURE__ */ s((e) => typeof e == "function", "isFunction"), JB = /* @__PURE__ */ s(
  (e) => Gi.call(e) == "[object Map]", "isMap"), $B = /* @__PURE__ */ s((e) => Gi.call(e) == "[object Set]", "isSet"), HB = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, GB = /["'\\\b\f\n\r\t]/, zB = /[0-9]/, QB = /[ !#-&\(-\[\]-_a-~]/, ur = /* @__PURE__ */ s((e, t) => {
    let r = /* @__PURE__ */ s(() => {
      c = u, ++t.indentLevel, u = t.indent.repeat(t.indentLevel);
    }, "increaseIndentation"), i = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, n = t && t.json;
    n && (i.quotes = "double", i.wrap = !0), t = RB(i, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes =
    "single");
    let a = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", o = t.compact, l = t.lowercaseHex, u = t.indent.repeat(t.indentLevel),
    c = "", p = t.__inline1__, g = t.__inline2__, P = o ? "" : `
`, A, C = !0, _ = t.numbers == "binary", k = t.numbers == "octal", O = t.numbers == "decimal", M = t.numbers == "hexadecimal";
    if (n && e && XB(e.toJSON) && (e = e.toJSON()), !WB(e)) {
      if (JB(e))
        return e.size == 0 ? "new Map()" : (o || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + ur(Array.from(e), t) + ")");
      if ($B(e))
        return e.size == 0 ? "new Set()" : "new Set(" + ur(Array.from(e), t) + ")";
      if (UB(e))
        return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + ur(Array.from(e), t) + ")";
      if (VB(e))
        return A = [], t.wrap = !0, p && (t.__inline1__ = !1, t.__inline2__ = !0), g || r(), qB(e, (K) => {
          C = !1, g && (t.__inline2__ = !1), A.push(
            (o || g ? "" : u) + ur(K, t)
          );
        }), C ? "[]" : g ? "[" + A.join(", ") + "]" : "[" + P + A.join("," + P) + P + (o ? "" : c) + "]";
      if (YB(e)) {
        if (n)
          return JSON.stringify(e);
        if (O)
          return String(e);
        if (M) {
          let K = e.toString(16);
          return l || (K = K.toUpperCase()), "0x" + K;
        }
        if (_)
          return "0b" + e.toString(2);
        if (k)
          return "0o" + e.toString(8);
      } else return KB(e) ? (A = [], t.wrap = !0, r(), Hh(e, (K, oe) => {
        C = !1, A.push(
          (o ? "" : u) + ur(K, t) + ":" + (o ? "" : " ") + ur(oe, t)
        );
      }), C ? "{}" : "{" + P + A.join("," + P) + P + (o ? "" : c) + "}") : n ? JSON.stringify(e) || "null" : String(e);
    }
    let F = e, G = -1, $ = F.length;
    for (A = ""; ++G < $; ) {
      let K = F.charAt(G);
      if (t.es6) {
        let Lt = F.charCodeAt(G);
        if (
          // check if its the start of a surrogate pair
          Lt >= 55296 && Lt <= 56319 && // high surrogate
          $ > G + 1
        ) {
          let rr = F.charCodeAt(G + 1);
          if (rr >= 56320 && rr <= 57343) {
            let Mt = ((Lt - 55296) * 1024 + rr - 56320 + 65536).toString(16);
            l || (Mt = Mt.toUpperCase()), A += "\\u{" + Mt + "}", ++G;
            continue;
          }
        }
      }
      if (!t.escapeEverything) {
        if (QB.test(K)) {
          A += K;
          continue;
        }
        if (K == '"') {
          A += a == K ? '\\"' : K;
          continue;
        }
        if (K == "`") {
          A += a == K ? "\\`" : K;
          continue;
        }
        if (K == "'") {
          A += a == K ? "\\'" : K;
          continue;
        }
      }
      if (K == "\0" && !n && !zB.test(F.charAt(G + 1))) {
        A += "\\0";
        continue;
      }
      if (GB.test(K)) {
        A += HB[K];
        continue;
      }
      let oe = K.charCodeAt(0);
      if (t.minimal && oe != 8232 && oe != 8233) {
        A += K;
        continue;
      }
      let Oe = oe.toString(16);
      l || (Oe = Oe.toUpperCase());
      let Ne = Oe.length > 2 || n, $e = "\\" + (Ne ? "u" : "x") + ("0000" + Oe).slice(Ne ? -4 : -2);
      A += $e;
    }
    return t.wrap && (A = a + A + a), a == "`" && (A = A.replace(/\$\{/g, "\\${")), t.isScriptContext ? A.replace(/<\/(script|style)/gi, "<\\\
/$1").replace(/<!--/g, n ? "\\u003C!--" : "\\x3C!--") : A;
  }, "jsesc");
  ur.version = "2.5.2";
  Gh.exports = ur;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var Nl = v((Fe) => {
  "use strict";
  Object.defineProperty(Fe, "__esModule", {
    value: !0
  });
  Fe.ArgumentPlaceholder = rj;
  Fe.ArrayPattern = Fe.ArrayExpression = oj;
  Fe.BigIntLiteral = mj;
  Fe.BooleanLiteral = pj;
  Fe.DecimalLiteral = yj;
  Fe.Identifier = tj;
  Fe.NullLiteral = fj;
  Fe.NumericLiteral = hj;
  Fe.ObjectPattern = Fe.ObjectExpression = sj;
  Fe.ObjectMethod = nj;
  Fe.ObjectProperty = aj;
  Fe.PipelineBareFunction = bj;
  Fe.PipelinePrimaryTopicReference = Sj;
  Fe.PipelineTopicExpression = gj;
  Fe.RecordExpression = lj;
  Fe.RegExpLiteral = cj;
  Fe.SpreadElement = Fe.RestElement = ij;
  Fe.StringLiteral = dj;
  Fe.TopicReference = Tj;
  Fe.TupleExpression = uj;
  var ZB = le(), Zh = zh(), {
    isAssignmentPattern: ej,
    isIdentifier: Ol
  } = ZB;
  function tj(e) {
    var t;
    this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(e.name);
  }
  s(tj, "Identifier");
  function rj() {
    this.tokenChar(63);
  }
  s(rj, "ArgumentPlaceholder");
  function ij(e) {
    this.token("..."), this.print(e.argument, e);
  }
  s(ij, "RestElement");
  function sj(e) {
    let t = e.properties;
    this.tokenChar(123), t.length && (this.space(), this.printList(t, e, {
      indent: !0,
      statement: !0
    }), this.space()), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
  }
  s(sj, "ObjectExpression");
  function nj(e) {
    this.printJoin(e.decorators, e), this._methodHead(e), this.space(), this.print(e.body, e);
  }
  s(nj, "ObjectMethod");
  function aj(e) {
    if (this.printJoin(e.decorators, e), e.computed)
      this.tokenChar(91), this.print(e.key, e), this.tokenChar(93);
    else {
      if (ej(e.value) && Ol(e.key) && e.key.name === e.value.left.name) {
        this.print(e.value, e);
        return;
      }
      if (this.print(e.key, e), e.shorthand && Ol(e.key) && Ol(e.value) && e.key.name === e.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(e.value, e);
  }
  s(aj, "ObjectProperty");
  function oj(e) {
    let t = e.elements, r = t.length;
    this.tokenChar(91);
    for (let i = 0; i < t.length; i++) {
      let n = t[i];
      n ? (i > 0 && this.space(), this.print(n, e), i < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }
  s(oj, "ArrayExpression");
  function lj(e) {
    let t = e.properties, r, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", i = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", i = "}";
    }
    this.token(r), t.length && (this.space(), this.printList(t, e, {
      indent: !0,
      statement: !0
    }), this.space()), this.token(i);
  }
  s(lj, "RecordExpression");
  function uj(e) {
    let t = e.elements, r = t.length, i, n;
    if (this.format.recordAndTupleSyntaxType === "bar")
      i = "[|", n = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      i = "#[", n = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(i);
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      o && (a > 0 && this.space(), this.print(o, e), a < r - 1 && this.tokenChar(44));
    }
    this.token(n);
  }
  s(uj, "TupleExpression");
  function cj(e) {
    this.word(`/${e.pattern}/${e.flags}`);
  }
  s(cj, "RegExpLiteral");
  function pj(e) {
    this.word(e.value ? "true" : "false");
  }
  s(pj, "BooleanLiteral");
  function fj() {
    this.word("null");
  }
  s(fj, "NullLiteral");
  function hj(e) {
    let t = this.getPossibleRaw(e), r = this.format.jsescOption, i = e.value, n = i + "";
    r.numbers ? this.number(Zh(i, r), i) : t == null ? this.number(n, i) : this.format.minified ? this.number(t.length < n.length ? t : n, i) :
    this.number(t, i);
  }
  s(hj, "NumericLiteral");
  function dj(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let r = Zh(e.value, this.format.jsescOption);
    this.token(r);
  }
  s(dj, "StringLiteral");
  function mj(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "n");
  }
  s(mj, "BigIntLiteral");
  function yj(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "m");
  }
  s(yj, "DecimalLiteral");
  var Qh = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function Tj() {
    let {
      topicToken: e
    } = this.format;
    if (Qh.has(e))
      this.token(e);
    else {
      let t = JSON.stringify(e), r = Array.from(Qh, (i) => JSON.stringify(i));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
    }
  }
  s(Tj, "TopicReference");
  function gj(e) {
    this.print(e.expression, e);
  }
  s(gj, "PipelineTopicExpression");
  function bj(e) {
    this.print(e.callee, e);
  }
  s(bj, "PipelineBareFunction");
  function Sj() {
    this.tokenChar(35);
  }
  s(Sj, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var td = v((X) => {
  "use strict";
  Object.defineProperty(X, "__esModule", {
    value: !0
  });
  X.AnyTypeAnnotation = Aj;
  X.ArrayTypeAnnotation = vj;
  X.BooleanLiteralTypeAnnotation = Ij;
  X.BooleanTypeAnnotation = Cj;
  X.DeclareClass = Oj;
  X.DeclareExportAllDeclaration = qj;
  X.DeclareExportDeclaration = Rj;
  X.DeclareFunction = Nj;
  X.DeclareInterface = kj;
  X.DeclareModule = Lj;
  X.DeclareModuleExports = Mj;
  X.DeclareOpaqueType = Bj;
  X.DeclareTypeAlias = Fj;
  X.DeclareVariable = jj;
  X.DeclaredPredicate = Dj;
  X.EmptyTypeAnnotation = lR;
  X.EnumBooleanBody = Uj;
  X.EnumBooleanMember = Jj;
  X.EnumDeclaration = Vj;
  X.EnumDefaultedMember = Xj;
  X.EnumNumberBody = Kj;
  X.EnumNumberMember = $j;
  X.EnumStringBody = Wj;
  X.EnumStringMember = Hj;
  X.EnumSymbolBody = Yj;
  X.ExistsTypeAnnotation = zj;
  X.FunctionTypeAnnotation = Qj;
  X.FunctionTypeParam = Zj;
  X.IndexedAccessType = kR;
  X.InferredPredicate = _j;
  X.InterfaceDeclaration = iR;
  X.GenericTypeAnnotation = X.ClassImplements = X.InterfaceExtends = eR;
  X.InterfaceTypeAnnotation = nR;
  X.IntersectionTypeAnnotation = aR;
  X.MixedTypeAnnotation = oR;
  X.NullLiteralTypeAnnotation = wj;
  X.NullableTypeAnnotation = uR;
  Object.defineProperty(X, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ed.NumericLiteral;
    }, "get")
  });
  X.NumberTypeAnnotation = cR;
  X.ObjectTypeAnnotation = SR;
  X.ObjectTypeCallProperty = ER;
  X.ObjectTypeIndexer = PR;
  X.ObjectTypeInternalSlot = xR;
  X.ObjectTypeProperty = AR;
  X.ObjectTypeSpreadProperty = vR;
  X.OpaqueType = bR;
  X.OptionalIndexedAccessType = LR;
  X.QualifiedTypeIdentifier = CR;
  Object.defineProperty(X, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ed.StringLiteral;
    }, "get")
  });
  X.StringTypeAnnotation = pR;
  X.SymbolTypeAnnotation = IR;
  X.ThisTypeAnnotation = fR;
  X.TupleTypeAnnotation = hR;
  X.TypeAlias = mR;
  X.TypeAnnotation = yR;
  X.TypeCastExpression = NR;
  X.TypeParameter = gR;
  X.TypeParameterDeclaration = X.TypeParameterInstantiation = TR;
  X.TypeofTypeAnnotation = dR;
  X.UnionTypeAnnotation = OR;
  X.Variance = _R;
  X.VoidTypeAnnotation = DR;
  X._interfaceish = tR;
  X._variance = rR;
  var xj = le(), Ej = wl(), ed = Nl(), {
    isDeclareExportDeclaration: dn,
    isStatement: Pj
  } = xj;
  function Aj() {
    this.word("any");
  }
  s(Aj, "AnyTypeAnnotation");
  function vj(e) {
    this.print(e.elementType, e, !0), this.tokenChar(91), this.tokenChar(93);
  }
  s(vj, "ArrayTypeAnnotation");
  function Cj() {
    this.word("boolean");
  }
  s(Cj, "BooleanTypeAnnotation");
  function Ij(e) {
    this.word(e.value ? "true" : "false");
  }
  s(Ij, "BooleanLiteralTypeAnnotation");
  function wj() {
    this.word("null");
  }
  s(wj, "NullLiteralTypeAnnotation");
  function Oj(e, t) {
    dn(t) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e);
  }
  s(Oj, "DeclareClass");
  function Nj(e, t) {
    dn(t) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e.id, e), this.print(e.id.typeAnnotation.
    typeAnnotation, e), e.predicate && (this.space(), this.print(e.predicate, e)), this.semicolon();
  }
  s(Nj, "DeclareFunction");
  function _j() {
    this.tokenChar(37), this.word("checks");
  }
  s(_j, "InferredPredicate");
  function Dj(e) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e.value, e), this.tokenChar(41);
  }
  s(Dj, "DeclaredPredicate");
  function kj(e) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(e);
  }
  s(kj, "DeclareInterface");
  function Lj(e) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e.id, e), this.space(), this.print(e.body, e);
  }
  s(Lj, "DeclareModule");
  function Mj(e) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e.typeAnnotation, e);
  }
  s(Mj, "DeclareModuleExports");
  function Fj(e) {
    this.word("declare"), this.space(), this.TypeAlias(e);
  }
  s(Fj, "DeclareTypeAlias");
  function Bj(e, t) {
    dn(t) || (this.word("declare"), this.space()), this.OpaqueType(e);
  }
  s(Bj, "DeclareOpaqueType");
  function jj(e, t) {
    dn(t) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e.id, e), this.print(e.id.typeAnnotation, e), this.
    semicolon();
  }
  s(jj, "DeclareVariable");
  function Rj(e) {
    this.word("declare"), this.space(), this.word("export"), this.space(), e.default && (this.word("default"), this.space()), Gj.call(this, e);
  }
  s(Rj, "DeclareExportDeclaration");
  function qj(e) {
    this.word("declare"), this.space(), Ej.ExportAllDeclaration.call(this, e);
  }
  s(qj, "DeclareExportAllDeclaration");
  function Vj(e) {
    let {
      id: t,
      body: r
    } = e;
    this.word("enum"), this.space(), this.print(t, e), this.print(r, e);
  }
  s(Vj, "EnumDeclaration");
  function mn(e, t, r) {
    r && (e.space(), e.word("of"), e.space(), e.word(t)), e.space();
  }
  s(mn, "enumExplicitType");
  function yn(e, t) {
    let {
      members: r
    } = t;
    e.token("{"), e.indent(), e.newline();
    for (let i of r)
      e.print(i, t), e.newline();
    t.hasUnknownMembers && (e.token("..."), e.newline()), e.dedent(), e.token("}");
  }
  s(yn, "enumBody");
  function Uj(e) {
    let {
      explicitType: t
    } = e;
    mn(this, "boolean", t), yn(this, e);
  }
  s(Uj, "EnumBooleanBody");
  function Kj(e) {
    let {
      explicitType: t
    } = e;
    mn(this, "number", t), yn(this, e);
  }
  s(Kj, "EnumNumberBody");
  function Wj(e) {
    let {
      explicitType: t
    } = e;
    mn(this, "string", t), yn(this, e);
  }
  s(Wj, "EnumStringBody");
  function Yj(e) {
    mn(this, "symbol", !0), yn(this, e);
  }
  s(Yj, "EnumSymbolBody");
  function Xj(e) {
    let {
      id: t
    } = e;
    this.print(t, e), this.tokenChar(44);
  }
  s(Xj, "EnumDefaultedMember");
  function _l(e, t) {
    let {
      id: r,
      init: i
    } = t;
    e.print(r, t), e.space(), e.token("="), e.space(), e.print(i, t), e.token(",");
  }
  s(_l, "enumInitializedMember");
  function Jj(e) {
    _l(this, e);
  }
  s(Jj, "EnumBooleanMember");
  function $j(e) {
    _l(this, e);
  }
  s($j, "EnumNumberMember");
  function Hj(e) {
    _l(this, e);
  }
  s(Hj, "EnumStringMember");
  function Gj(e) {
    if (e.declaration) {
      let t = e.declaration;
      this.print(t, e), Pj(t) || this.semicolon();
    } else
      this.tokenChar(123), e.specifiers.length && (this.space(), this.printList(e.specifiers, e), this.space()), this.tokenChar(125), e.source &&
      (this.space(), this.word("from"), this.space(), this.print(e.source, e)), this.semicolon();
  }
  s(Gj, "FlowExportDeclaration");
  function zj() {
    this.tokenChar(42);
  }
  s(zj, "ExistsTypeAnnotation");
  function Qj(e, t) {
    this.print(e.typeParameters, e), this.tokenChar(40), e.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e.this.typeAnnotation,
    e), (e.params.length || e.rest) && (this.tokenChar(44), this.space())), this.printList(e.params, e), e.rest && (e.params.length && (this.
    tokenChar(44), this.space()), this.token("..."), this.print(e.rest, e)), this.tokenChar(41);
    let r = t?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    t.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e.returnType, e);
  }
  s(Qj, "FunctionTypeAnnotation");
  function Zj(e) {
    this.print(e.name, e), e.optional && this.tokenChar(63), e.name && (this.tokenChar(58), this.space()), this.print(e.typeAnnotation, e);
  }
  s(Zj, "FunctionTypeParam");
  function eR(e) {
    this.print(e.id, e), this.print(e.typeParameters, e, !0);
  }
  s(eR, "InterfaceExtends");
  function tR(e) {
    var t;
    if (this.print(e.id, e), this.print(e.typeParameters, e), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.
    space(), this.printList(e.extends, e)), e.type === "DeclareClass") {
      var r, i;
      (r = e.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(e.mixins, e)), (i = e.implements) !=
      null && i.length && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e));
    }
    this.space(), this.print(e.body, e);
  }
  s(tR, "_interfaceish");
  function rR(e) {
    var t;
    let r = (t = e.variance) == null ? void 0 : t.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  s(rR, "_variance");
  function iR(e) {
    this.word("interface"), this.space(), this._interfaceish(e);
  }
  s(iR, "InterfaceDeclaration");
  function sR() {
    this.space(), this.tokenChar(38), this.space();
  }
  s(sR, "andSeparator");
  function nR(e) {
    var t;
    this.word("interface"), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e.extends,
    e)), this.space(), this.print(e.body, e);
  }
  s(nR, "InterfaceTypeAnnotation");
  function aR(e) {
    this.printJoin(e.types, e, {
      separator: sR
    });
  }
  s(aR, "IntersectionTypeAnnotation");
  function oR() {
    this.word("mixed");
  }
  s(oR, "MixedTypeAnnotation");
  function lR() {
    this.word("empty");
  }
  s(lR, "EmptyTypeAnnotation");
  function uR(e) {
    this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(uR, "NullableTypeAnnotation");
  function cR() {
    this.word("number");
  }
  s(cR, "NumberTypeAnnotation");
  function pR() {
    this.word("string");
  }
  s(pR, "StringTypeAnnotation");
  function fR() {
    this.word("this");
  }
  s(fR, "ThisTypeAnnotation");
  function hR(e) {
    this.tokenChar(91), this.printList(e.types, e), this.tokenChar(93);
  }
  s(hR, "TupleTypeAnnotation");
  function dR(e) {
    this.word("typeof"), this.space(), this.print(e.argument, e);
  }
  s(dR, "TypeofTypeAnnotation");
  function mR(e) {
    this.word("type"), this.space(), this.print(e.id, e), this.print(e.typeParameters, e), this.space(), this.tokenChar(61), this.space(), this.
    print(e.right, e), this.semicolon();
  }
  s(mR, "TypeAlias");
  function yR(e) {
    this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(yR, "TypeAnnotation");
  function TR(e) {
    this.tokenChar(60), this.printList(e.params, e, {}), this.tokenChar(62);
  }
  s(TR, "TypeParameterInstantiation");
  function gR(e) {
    this._variance(e), this.word(e.name), e.bound && this.print(e.bound, e), e.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(e.default, e));
  }
  s(gR, "TypeParameter");
  function bR(e) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e.id, e), this.print(e.typeParameters, e), e.supertype &&
    (this.tokenChar(58), this.space(), this.print(e.supertype, e)), e.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(
    e.impltype, e)), this.semicolon();
  }
  s(bR, "OpaqueType");
  function SR(e) {
    e.exact ? this.token("{|") : this.tokenChar(123);
    let t = [...e.properties, ...e.callProperties || [], ...e.indexers || [], ...e.internalSlots || []];
    t.length && (this.newline(), this.space(), this.printJoin(t, e, {
      addNewlines(r) {
        if (r && !t[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: /* @__PURE__ */ s(() => {
        (t.length !== 1 || e.inexact) && (this.tokenChar(44), this.space());
      }, "iterator")
    }), this.space()), e.inexact && (this.indent(), this.token("..."), t.length && this.newline(), this.dedent()), e.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  s(SR, "ObjectTypeAnnotation");
  function xR(e) {
    e.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e.id, e), this.tokenChar(93), this.tokenChar(
    93), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58), this.space()), this.print(e.value, e);
  }
  s(xR, "ObjectTypeInternalSlot");
  function ER(e) {
    e.static && (this.word("static"), this.space()), this.print(e.value, e);
  }
  s(ER, "ObjectTypeCallProperty");
  function PR(e) {
    e.static && (this.word("static"), this.space()), this._variance(e), this.tokenChar(91), e.id && (this.print(e.id, e), this.tokenChar(58),
    this.space()), this.print(e.key, e), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e.value, e);
  }
  s(PR, "ObjectTypeIndexer");
  function AR(e) {
    e.proto && (this.word("proto"), this.space()), e.static && (this.word("static"), this.space()), (e.kind === "get" || e.kind === "set") &&
    (this.word(e.kind), this.space()), this._variance(e), this.print(e.key, e), e.optional && this.tokenChar(63), e.method || (this.tokenChar(
    58), this.space()), this.print(e.value, e);
  }
  s(AR, "ObjectTypeProperty");
  function vR(e) {
    this.token("..."), this.print(e.argument, e);
  }
  s(vR, "ObjectTypeSpreadProperty");
  function CR(e) {
    this.print(e.qualification, e), this.tokenChar(46), this.print(e.id, e);
  }
  s(CR, "QualifiedTypeIdentifier");
  function IR() {
    this.word("symbol");
  }
  s(IR, "SymbolTypeAnnotation");
  function wR() {
    this.space(), this.tokenChar(124), this.space();
  }
  s(wR, "orSeparator");
  function OR(e) {
    this.printJoin(e.types, e, {
      separator: wR
    });
  }
  s(OR, "UnionTypeAnnotation");
  function NR(e) {
    this.tokenChar(40), this.print(e.expression, e), this.print(e.typeAnnotation, e), this.tokenChar(41);
  }
  s(NR, "TypeCastExpression");
  function _R(e) {
    e.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  s(_R, "Variance");
  function DR() {
    this.word("void");
  }
  s(DR, "VoidTypeAnnotation");
  function kR(e) {
    this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  s(kR, "IndexedAccessType");
  function LR(e) {
    this.print(e.objectType, e), e.optional && this.token("?."), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  s(LR, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var rd = v((Xt) => {
  "use strict";
  Object.defineProperty(Xt, "__esModule", {
    value: !0
  });
  Xt.BlockStatement = BR;
  Xt.Directive = jR;
  Xt.DirectiveLiteral = VR;
  Xt.File = MR;
  Xt.InterpreterDirective = UR;
  Xt.Placeholder = KR;
  Xt.Program = FR;
  function MR(e) {
    e.program && this.print(e.program.interpreter, e), this.print(e.program, e);
  }
  s(MR, "File");
  function FR(e) {
    var t;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var i;
      let n = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, {
        trailingCommentsLineOffset: n
      }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(n);
    }
    this.printSequence(e.body, e);
  }
  s(FR, "Program");
  function BR(e) {
    var t;
    this.tokenChar(123);
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var i;
      let n = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, {
        indent: !0,
        trailingCommentsLineOffset: n
      }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(n);
    }
    this.printSequence(e.body, e, {
      indent: !0
    }), this.rightBrace(e);
  }
  s(BR, "BlockStatement");
  function jR(e) {
    this.print(e.value, e), this.semicolon();
  }
  s(jR, "Directive");
  var RR = /(?:^|[^\\])(?:\\\\)*'/, qR = /(?:^|[^\\])(?:\\\\)*"/;
  function VR(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let {
      value: r
    } = e;
    if (!qR.test(r))
      this.token(`"${r}"`);
    else if (!RR.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  s(VR, "DirectiveLiteral");
  function UR(e) {
    this.token(`#!${e.value}`), this.newline(1, !0);
  }
  s(UR, "InterpreterDirective");
  function KR(e) {
    this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
  }
  s(KR, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var id = v((Qe) => {
  "use strict";
  Object.defineProperty(Qe, "__esModule", {
    value: !0
  });
  Qe.JSXAttribute = WR;
  Qe.JSXClosingElement = t5;
  Qe.JSXClosingFragment = n5;
  Qe.JSXElement = QR;
  Qe.JSXEmptyExpression = r5;
  Qe.JSXExpressionContainer = HR;
  Qe.JSXFragment = i5;
  Qe.JSXIdentifier = YR;
  Qe.JSXMemberExpression = JR;
  Qe.JSXNamespacedName = XR;
  Qe.JSXOpeningElement = e5;
  Qe.JSXOpeningFragment = s5;
  Qe.JSXSpreadAttribute = $R;
  Qe.JSXSpreadChild = GR;
  Qe.JSXText = zR;
  function WR(e) {
    this.print(e.name, e), e.value && (this.tokenChar(61), this.print(e.value, e));
  }
  s(WR, "JSXAttribute");
  function YR(e) {
    this.word(e.name);
  }
  s(YR, "JSXIdentifier");
  function XR(e) {
    this.print(e.namespace, e), this.tokenChar(58), this.print(e.name, e);
  }
  s(XR, "JSXNamespacedName");
  function JR(e) {
    this.print(e.object, e), this.tokenChar(46), this.print(e.property, e);
  }
  s(JR, "JSXMemberExpression");
  function $R(e) {
    this.tokenChar(123), this.token("..."), this.print(e.argument, e), this.tokenChar(125);
  }
  s($R, "JSXSpreadAttribute");
  function HR(e) {
    this.tokenChar(123), this.print(e.expression, e), this.tokenChar(125);
  }
  s(HR, "JSXExpressionContainer");
  function GR(e) {
    this.tokenChar(123), this.token("..."), this.print(e.expression, e), this.tokenChar(125);
  }
  s(GR, "JSXSpreadChild");
  function zR(e) {
    let t = this.getPossibleRaw(e);
    t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
  }
  s(zR, "JSXText");
  function QR(e) {
    let t = e.openingElement;
    if (this.print(t, e), !t.selfClosing) {
      this.indent();
      for (let r of e.children)
        this.print(r, e);
      this.dedent(), this.print(e.closingElement, e);
    }
  }
  s(QR, "JSXElement");
  function ZR() {
    this.space();
  }
  s(ZR, "spaceSeparator");
  function e5(e) {
    this.tokenChar(60), this.print(e.name, e), this.print(e.typeParameters, e), e.attributes.length > 0 && (this.space(), this.printJoin(e.attributes,
    e, {
      separator: ZR
    })), e.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }
  s(e5, "JSXOpeningElement");
  function t5(e) {
    this.token("</"), this.print(e.name, e), this.tokenChar(62);
  }
  s(t5, "JSXClosingElement");
  function r5() {
    this.printInnerComments();
  }
  s(r5, "JSXEmptyExpression");
  function i5(e) {
    this.print(e.openingFragment, e), this.indent();
    for (let t of e.children)
      this.print(t, e);
    this.dedent(), this.print(e.closingFragment, e);
  }
  s(i5, "JSXFragment");
  function s5() {
    this.tokenChar(60), this.tokenChar(62);
  }
  s(s5, "JSXOpeningFragment");
  function n5() {
    this.token("</"), this.tokenChar(62);
  }
  s(n5, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var ad = v((Y) => {
  "use strict";
  Object.defineProperty(Y, "__esModule", {
    value: !0
  });
  Y.TSAnyKeyword = b5;
  Y.TSArrayType = V5;
  Y.TSSatisfiesExpression = Y.TSAsExpression = n4;
  Y.TSBigIntKeyword = S5;
  Y.TSBooleanKeyword = A5;
  Y.TSCallSignatureDeclaration = h5;
  Y.TSConditionalType = $5;
  Y.TSConstructSignatureDeclaration = d5;
  Y.TSConstructorType = L5;
  Y.TSDeclareFunction = c5;
  Y.TSDeclareMethod = p5;
  Y.TSEnumDeclaration = l4;
  Y.TSEnumMember = u4;
  Y.TSExportAssignment = y4;
  Y.TSExpressionWithTypeArguments = t4;
  Y.TSExternalModuleReference = d4;
  Y.TSFunctionType = k5;
  Y.TSImportEqualsDeclaration = h4;
  Y.TSImportType = f4;
  Y.TSIndexSignature = g5;
  Y.TSIndexedAccessType = Q5;
  Y.TSInferType = H5;
  Y.TSInstantiationExpression = o4;
  Y.TSInterfaceBody = i4;
  Y.TSInterfaceDeclaration = r4;
  Y.TSIntersectionType = J5;
  Y.TSIntrinsicKeyword = _5;
  Y.TSLiteralType = e4;
  Y.TSMappedType = Z5;
  Y.TSMethodSignature = T5;
  Y.TSModuleBlock = p4;
  Y.TSModuleDeclaration = c4;
  Y.TSNamedTupleMember = Y5;
  Y.TSNamespaceExportDeclaration = T4;
  Y.TSNeverKeyword = N5;
  Y.TSNonNullExpression = m4;
  Y.TSNullKeyword = O5;
  Y.TSNumberKeyword = E5;
  Y.TSObjectKeyword = P5;
  Y.TSOptionalType = K5;
  Y.TSParameterProperty = u5;
  Y.TSParenthesizedType = G5;
  Y.TSPropertySignature = m5;
  Y.TSQualifiedName = f5;
  Y.TSRestType = W5;
  Y.TSStringKeyword = v5;
  Y.TSSymbolKeyword = C5;
  Y.TSThisType = D5;
  Y.TSTupleType = U5;
  Y.TSTypeAliasDeclaration = s4;
  Y.TSTypeAnnotation = a5;
  Y.TSTypeAssertion = a4;
  Y.TSTypeLiteral = R5;
  Y.TSTypeOperator = z5;
  Y.TSTypeParameter = l5;
  Y.TSTypeParameterDeclaration = Y.TSTypeParameterInstantiation = o5;
  Y.TSTypePredicate = B5;
  Y.TSTypeQuery = j5;
  Y.TSTypeReference = F5;
  Y.TSUndefinedKeyword = w5;
  Y.TSUnionType = X5;
  Y.TSUnknownKeyword = x5;
  Y.TSVoidKeyword = I5;
  Y.tsPrintClassMemberModifiers = b4;
  Y.tsPrintFunctionOrConstructorType = M5;
  Y.tsPrintPropertyOrMethodName = y5;
  Y.tsPrintSignatureDeclarationBase = g4;
  Y.tsPrintTypeLiteralOrInterfaceBody = q5;
  function a5(e) {
    this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  s(a5, "TSTypeAnnotation");
  function o5(e, t) {
    this.tokenChar(60), this.printList(e.params, e, {}), t.type === "ArrowFunctionExpression" && e.params.length === 1 && this.tokenChar(44),
    this.tokenChar(62);
  }
  s(o5, "TSTypeParameterInstantiation");
  function l5(e) {
    e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(e.constraint, e)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.
    default, e));
  }
  s(l5, "TSTypeParameter");
  function u5(e) {
    e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
  }
  s(u5, "TSParameterProperty");
  function c5(e, t) {
    e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.tokenChar(59);
  }
  s(c5, "TSDeclareFunction");
  function p5(e) {
    this._classMethodHead(e), this.tokenChar(59);
  }
  s(p5, "TSDeclareMethod");
  function f5(e) {
    this.print(e.left, e), this.tokenChar(46), this.print(e.right, e);
  }
  s(f5, "TSQualifiedName");
  function h5(e) {
    this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
  }
  s(h5, "TSCallSignatureDeclaration");
  function d5(e) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
  }
  s(d5, "TSConstructSignatureDeclaration");
  function m5(e) {
    let {
      readonly: t
    } = e;
    t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation, e), this.tokenChar(59);
  }
  s(m5, "TSPropertySignature");
  function y5(e) {
    e.computed && this.tokenChar(91), this.print(e.key, e), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
  }
  s(y5, "tsPrintPropertyOrMethodName");
  function T5(e) {
    let {
      kind: t
    } = e;
    (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(
    e), this.tokenChar(59);
  }
  s(T5, "TSMethodSignature");
  function g5(e) {
    let {
      readonly: t,
      static: r
    } = e;
    r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters,
    e), this.tokenChar(93), this.print(e.typeAnnotation, e), this.tokenChar(59);
  }
  s(g5, "TSIndexSignature");
  function b5() {
    this.word("any");
  }
  s(b5, "TSAnyKeyword");
  function S5() {
    this.word("bigint");
  }
  s(S5, "TSBigIntKeyword");
  function x5() {
    this.word("unknown");
  }
  s(x5, "TSUnknownKeyword");
  function E5() {
    this.word("number");
  }
  s(E5, "TSNumberKeyword");
  function P5() {
    this.word("object");
  }
  s(P5, "TSObjectKeyword");
  function A5() {
    this.word("boolean");
  }
  s(A5, "TSBooleanKeyword");
  function v5() {
    this.word("string");
  }
  s(v5, "TSStringKeyword");
  function C5() {
    this.word("symbol");
  }
  s(C5, "TSSymbolKeyword");
  function I5() {
    this.word("void");
  }
  s(I5, "TSVoidKeyword");
  function w5() {
    this.word("undefined");
  }
  s(w5, "TSUndefinedKeyword");
  function O5() {
    this.word("null");
  }
  s(O5, "TSNullKeyword");
  function N5() {
    this.word("never");
  }
  s(N5, "TSNeverKeyword");
  function _5() {
    this.word("intrinsic");
  }
  s(_5, "TSIntrinsicKeyword");
  function D5() {
    this.word("this");
  }
  s(D5, "TSThisType");
  function k5(e) {
    this.tsPrintFunctionOrConstructorType(e);
  }
  s(k5, "TSFunctionType");
  function L5(e) {
    e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
  }
  s(L5, "TSConstructorType");
  function M5(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    let i = e.typeAnnotation;
    this.print(i.typeAnnotation, e);
  }
  s(M5, "tsPrintFunctionOrConstructorType");
  function F5(e) {
    this.print(e.typeName, e, !0), this.print(e.typeParameters, e, !0);
  }
  s(F5, "TSTypeReference");
  function B5(e) {
    e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(e.typeAnnotation.typeAnnotation));
  }
  s(B5, "TSTypePredicate");
  function j5(e) {
    this.word("typeof"), this.space(), this.print(e.exprName), e.typeParameters && this.print(e.typeParameters, e);
  }
  s(j5, "TSTypeQuery");
  function R5(e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
  }
  s(R5, "TSTypeLiteral");
  function q5(e, t) {
    Dl(this, e, t);
  }
  s(q5, "tsPrintTypeLiteralOrInterfaceBody");
  function Dl(e, t, r) {
    if (e.token("{"), t.length) {
      e.indent(), e.newline();
      for (let i of t)
        e.print(i, r), e.newline();
      e.dedent();
    }
    e.rightBrace(r);
  }
  s(Dl, "tsPrintBraced");
  function V5(e) {
    this.print(e.elementType, e, !0), this.token("[]");
  }
  s(V5, "TSArrayType");
  function U5(e) {
    this.tokenChar(91), this.printList(e.elementTypes, e), this.tokenChar(93);
  }
  s(U5, "TSTupleType");
  function K5(e) {
    this.print(e.typeAnnotation, e), this.tokenChar(63);
  }
  s(K5, "TSOptionalType");
  function W5(e) {
    this.token("..."), this.print(e.typeAnnotation, e);
  }
  s(W5, "TSRestType");
  function Y5(e) {
    this.print(e.label, e), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType, e);
  }
  s(Y5, "TSNamedTupleMember");
  function X5(e) {
    nd(this, e, "|");
  }
  s(X5, "TSUnionType");
  function J5(e) {
    nd(this, e, "&");
  }
  s(J5, "TSIntersectionType");
  function nd(e, t, r) {
    e.printJoin(t.types, t, {
      separator() {
        this.space(), this.token(r), this.space();
      }
    });
  }
  s(nd, "tsPrintUnionOrIntersectionType");
  function $5(e) {
    this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
  }
  s($5, "TSConditionalType");
  function H5(e) {
    this.token("infer"), this.space(), this.print(e.typeParameter);
  }
  s(H5, "TSInferType");
  function G5(e) {
    this.tokenChar(40), this.print(e.typeAnnotation, e), this.tokenChar(41);
  }
  s(G5, "TSParenthesizedType");
  function z5(e) {
    this.word(e.operator), this.space(), this.print(e.typeAnnotation, e);
  }
  s(z5, "TSTypeOperator");
  function Q5(e) {
    this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  s(Q5, "TSIndexedAccessType");
  function Z5(e) {
    let {
      nameType: t,
      optional: r,
      readonly: i,
      typeParameter: n,
      typeAnnotation: a
    } = e;
    this.tokenChar(123), this.space(), i && (sd(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(n.name), this.
    space(), this.word("in"), this.space(), this.print(n.constraint, n), t && (this.space(), this.word("as"), this.space(), this.print(t, e)),
    this.tokenChar(93), r && (sd(this, r), this.tokenChar(63)), a && (this.tokenChar(58), this.space(), this.print(a, e)), this.space(), this.
    tokenChar(125);
  }
  s(Z5, "TSMappedType");
  function sd(e, t) {
    t !== !0 && e.token(t);
  }
  s(sd, "tokenIfPlusMinus");
  function e4(e) {
    this.print(e.literal, e);
  }
  s(e4, "TSLiteralType");
  function t4(e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }
  s(t4, "TSExpressionWithTypeArguments");
  function r4(e) {
    let {
      declare: t,
      id: r,
      typeParameters: i,
      extends: n,
      body: a
    } = e;
    t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, e), this.print(i, e), n != null && n.length &&
    (this.space(), this.word("extends"), this.space(), this.printList(n, e)), this.space(), this.print(a, e);
  }
  s(r4, "TSInterfaceDeclaration");
  function i4(e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
  }
  s(i4, "TSInterfaceBody");
  function s4(e) {
    let {
      declare: t,
      id: r,
      typeParameters: i,
      typeAnnotation: n
    } = e;
    t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, e), this.print(i, e), this.space(), this.tokenChar(
    61), this.space(), this.print(n, e), this.tokenChar(59);
  }
  s(s4, "TSTypeAliasDeclaration");
  function n4(e) {
    var t;
    let {
      type: r,
      expression: i,
      typeAnnotation: n
    } = e, a = !!((t = i.trailingComments) != null && t.length);
    this.print(i, e, !0, void 0, a), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(n, e);
  }
  s(n4, "TSTypeExpression");
  function a4(e) {
    let {
      typeAnnotation: t,
      expression: r
    } = e;
    this.tokenChar(60), this.print(t, e), this.tokenChar(62), this.space(), this.print(r, e);
  }
  s(a4, "TSTypeAssertion");
  function o4(e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }
  s(o4, "TSInstantiationExpression");
  function l4(e) {
    let {
      declare: t,
      const: r,
      id: i,
      members: n
    } = e;
    t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i, e), this.
    space(), Dl(this, n, e);
  }
  s(l4, "TSEnumDeclaration");
  function u4(e) {
    let {
      id: t,
      initializer: r
    } = e;
    this.print(t, e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e)), this.tokenChar(44);
  }
  s(u4, "TSEnumMember");
  function c4(e) {
    let {
      declare: t,
      id: r
    } = e;
    if (t && (this.word("declare"), this.space()), e.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.
    print(r, e), !e.body) {
      this.tokenChar(59);
      return;
    }
    let i = e.body;
    for (; i.type === "TSModuleDeclaration"; )
      this.tokenChar(46), this.print(i.id, i), i = i.body;
    this.space(), this.print(i, e);
  }
  s(c4, "TSModuleDeclaration");
  function p4(e) {
    Dl(this, e.body, e);
  }
  s(p4, "TSModuleBlock");
  function f4(e) {
    let {
      argument: t,
      qualifier: r,
      typeParameters: i
    } = e;
    this.word("import"), this.tokenChar(40), this.print(t, e), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, e)), i && this.print(
    i, e);
  }
  s(f4, "TSImportType");
  function h4(e) {
    let {
      isExport: t,
      id: r,
      moduleReference: i
    } = e;
    t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, e), this.space(), this.tokenChar(61), this.space(),
    this.print(i, e), this.tokenChar(59);
  }
  s(h4, "TSImportEqualsDeclaration");
  function d4(e) {
    this.token("require("), this.print(e.expression, e), this.tokenChar(41);
  }
  s(d4, "TSExternalModuleReference");
  function m4(e) {
    this.print(e.expression, e), this.tokenChar(33);
  }
  s(m4, "TSNonNullExpression");
  function y4(e) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression, e), this.tokenChar(59);
  }
  s(y4, "TSExportAssignment");
  function T4(e) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id, e);
  }
  s(T4, "TSNamespaceExportDeclaration");
  function g4(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41);
    let i = e.typeAnnotation;
    this.print(i, e);
  }
  s(g4, "tsPrintSignatureDeclarationBase");
  function b4(e) {
    let t = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
    t && e.declare && (this.word("declare"), this.space()), e.accessibility && (this.word(e.accessibility), this.space()), e.static && (this.
    word("static"), this.space()), e.override && (this.word("override"), this.space()), e.abstract && (this.word("abstract"), this.space()),
    t && e.readonly && (this.word("readonly"), this.space());
  }
  s(b4, "tsPrintClassMemberModifiers");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var od = v((ye) => {
  "use strict";
  Object.defineProperty(ye, "__esModule", {
    value: !0
  });
  var kl = Mh();
  Object.keys(kl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === kl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return kl[e];
      }, "get")
    });
  });
  var Ll = jh();
  Object.keys(Ll).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Ll[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ll[e];
      }, "get")
    });
  });
  var Ml = Uh();
  Object.keys(Ml).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Ml[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ml[e];
      }, "get")
    });
  });
  var Fl = Kh();
  Object.keys(Fl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Fl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Fl[e];
      }, "get")
    });
  });
  var Bl = Wh();
  Object.keys(Bl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Bl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Bl[e];
      }, "get")
    });
  });
  var jl = wl();
  Object.keys(jl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === jl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return jl[e];
      }, "get")
    });
  });
  var Rl = Nl();
  Object.keys(Rl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Rl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Rl[e];
      }, "get")
    });
  });
  var ql = td();
  Object.keys(ql).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === ql[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return ql[e];
      }, "get")
    });
  });
  var Vl = rd();
  Object.keys(Vl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Vl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Vl[e];
      }, "get")
    });
  });
  var Ul = id();
  Object.keys(Ul).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Ul[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Ul[e];
      }, "get")
    });
  });
  var Kl = ad();
  Object.keys(Kl).forEach(function(e) {
    e === "default" || e === "__esModule" || e in ye && ye[e] === Kl[e] || Object.defineProperty(ye, e, {
      enumerable: !0,
      get: /* @__PURE__ */ s(function() {
        return Kl[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/printer.js
var ud = v((Tn) => {
  "use strict";
  Object.defineProperty(Tn, "__esModule", {
    value: !0
  });
  Tn.default = void 0;
  var S4 = Eh(), x4 = Cl(), E4 = le(), P4 = od(), {
    isFunction: A4,
    isStatement: v4,
    isClassBody: C4,
    isTSInterfaceBody: I4,
    isTSEnumDeclaration: w4
  } = E4, O4 = /e/i, N4 = /\.0+$/, ld = /[\n\r\u2028\u2029]/, _4 = /[\n\r\u2028\u2029]|\*\//, {
    needsParens: D4
  } = x4, zi = class {
    static {
      s(this, "Printer");
    }
    constructor(t, r) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState =
      null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger =
      !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = t, this.
      _indentRepeat = t.indent.style.length, this._inputMap = r?._inputMap, this._buf = new S4.default(r, t.indent.style[0]);
    }
    generate(t) {
      return this.print(t), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(t = !1) {
      this._maybeAddAuxComment(), t ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(t) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
    }
    rightParens(t) {
      this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
    }
    space(t = !1) {
      if (!this.format.compact) {
        if (t)
          this._space();
        else if (this._buf.hasContent()) {
          let r = this.getLastChar();
          r !== 32 && r !== 10 && this._space();
        }
      }
    }
    word(t, r = !1) {
      this._maybePrintInnerComments(), (this._endsWithWord || t.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(),
      this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(t, r) {
      function i(n) {
        if (n.length > 2 && n.charCodeAt(0) === 48) {
          let a = n.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      s(i, "isNonDecimalLiteral"), this.word(t), this._endsWithInteger = Number.isInteger(r) && !i(t) && !O4.test(t) && !N4.test(t) && t.charCodeAt(
      t.length - 1) !== 46;
    }
    token(t, r = !1) {
      this._maybePrintInnerComments();
      let i = this.getLastChar(), n = t.charCodeAt(0);
      (i === 33 && (t === "--" || n === 61) || n === 43 && i === 43 || n === 45 && i === 45 || n === 46 && this._endsWithInteger) && this._space(),
      this._maybeAddAuxComment(), this._append(t, r), this._noLineTerminator = !1;
    }
    tokenChar(t) {
      this._maybePrintInnerComments();
      let r = this.getLastChar();
      (t === 43 && r === 43 || t === 45 && r === 45 || t === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this.
      _appendChar(t), this._noLineTerminator = !1;
    }
    newline(t = 1, r) {
      if (!(t <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        t > 2 && (t = 2), t -= this._buf.getNewlineCount();
        for (let i = 0; i < t; i++)
          this._newline();
      }
    }
    endsWith(t) {
      return this.getLastChar() === t;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(t, r) {
      if (!t) {
        r();
        return;
      }
      this._catchUp("start", t), this._buf.exactSource(t, r);
    }
    source(t, r) {
      r && (this._catchUp(t, r), this._buf.source(t, r));
    }
    sourceWithOffset(t, r, i) {
      r && (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, i));
    }
    withSource(t, r, i) {
      if (!r) {
        i();
        return;
      }
      this._catchUp(t, r), this._buf.withSource(t, r, i);
    }
    sourceIdentifierName(t, r) {
      if (!this._buf._canMarkIdName) return;
      let i = this._buf._sourcePosition;
      i.identifierNamePos = r, i.identifierName = t;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(t, r) {
      this._maybeAddParen(t), this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _appendChar(t) {
      this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _queue(t) {
      this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(t) {
      this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(t) {
      if (this._indent && t !== 10 && this.endsWith(10))
        return !0;
    }
    _maybeAddParenChar(t) {
      let r = this._parenPushNewlineState;
      if (r && t !== 32) {
        if (t !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40), this.indent(), r.printed = !0;
      }
    }
    _maybeAddParen(t) {
      let r = this._parenPushNewlineState;
      if (!r) return;
      let i = t.length, n;
      for (n = 0; n < i && t.charCodeAt(n) === 32; n++) ;
      if (n === i)
        return;
      let a = t.charCodeAt(n);
      if (a !== 10) {
        if (a !== 47 || n + 1 === i) {
          this._parenPushNewlineState = null;
          return;
        }
        let o = t.charCodeAt(n + 1);
        if (o === 42)
          return;
        if (o !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
    catchUp(t) {
      if (!this.format.retainLines) return;
      let r = t - this._buf.getCurrentLine();
      for (let i = 0; i < r; i++)
        this._newline();
    }
    _catchUp(t, r) {
      var i;
      if (!this.format.retainLines) return;
      let n = r == null || (i = r[t]) == null ? void 0 : i.line;
      if (n != null) {
        let a = n - this._buf.getCurrentLine();
        for (let o = 0; o < a; o++)
          this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(t, r, i) {
      if (i)
        this._noLineTerminator = !0, this.print(t, r);
      else {
        let n = {
          printed: !1
        };
        this._parenPushNewlineState = n, this.print(t, r), n.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(t, r, i, n, a) {
      var o, l;
      if (!t) return;
      this._endsWithInnerRaw = !1;
      let u = t.type, c = this.format, p = c.concise;
      t._compact && (c.concise = !0);
      let g = this[u];
      if (g === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(t.constructor.name)}`);
      this._printStack.push(t);
      let P = this._insideAux;
      this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !P);
      let A = (o = t.extra) == null ? void 0 : o.parenthesized, C = a || A && c.retainFunctionParens && u === "FunctionExpression" || D4(t, r,
      this._printStack);
      if (!C && A && (l = t.leadingComments) != null && l.length && t.leadingComments[0].type === "CommentBlock")
        switch (r?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (r.callee !== t) break;
          default:
            C = !0;
        }
      C && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(t, r);
      let _ = u === "Program" || u === "File" ? null : t.loc;
      this.exactSource(_, g.bind(this, t, r)), C ? (this._printTrailingComments(t, r), this.tokenChar(41), this._noLineTerminator = i) : i &&
      !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(t, r)) : this._printTrailingComments(t, r, n), this.
      _printStack.pop(), c.concise = p, this._insideAux = P, this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(t) {
      t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let t = this.format.auxiliaryCommentBefore;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let t = this.format.auxiliaryCommentAfter;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    getPossibleRaw(t) {
      let r = t.extra;
      if (r?.raw != null && r.rawValue != null && t.value === r.rawValue)
        return r.raw;
    }
    printJoin(t, r, i = {}) {
      if (!(t != null && t.length)) return;
      let {
        indent: n
      } = i;
      if (n == null && this.format.retainLines) {
        var a;
        let g = (a = t[0].loc) == null ? void 0 : a.start.line;
        g != null && g !== this._buf.getCurrentLine() && (n = !0);
      }
      n && this.indent();
      let o = {
        addNewlines: i.addNewlines,
        nextNodeStartLine: 0
      }, l = i.separator ? i.separator.bind(this) : null, u = t.length;
      for (let g = 0; g < u; g++) {
        let P = t[g];
        if (P && (i.statement && this._printNewline(g === 0, o), this.print(P, r, void 0, i.trailingCommentsLineOffset || 0), i.iterator == null ||
        i.iterator(P, g), g < u - 1 && l?.(), i.statement)) {
          var c;
          if ((c = P.trailingComments) != null && c.length || (this._lastCommentLine = 0), g + 1 === u)
            this.newline(1);
          else {
            var p;
            let A = t[g + 1];
            o.nextNodeStartLine = ((p = A.loc) == null ? void 0 : p.start.line) || 0, this._printNewline(!0, o);
          }
        }
      }
      n && this.dedent();
    }
    printAndIndentOnComments(t, r) {
      let i = t.leadingComments && t.leadingComments.length > 0;
      i && this.indent(), this.print(t, r), i && this.dedent();
    }
    printBlock(t) {
      let r = t.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r, t);
    }
    _printTrailingComments(t, r, i) {
      let {
        innerComments: n,
        trailingComments: a
      } = t;
      n != null && n.length && this._printComments(2, n, t, r, i), a != null && a.length && this._printComments(2, a, t, r, i);
    }
    _printLeadingComments(t, r) {
      let i = t.leadingComments;
      i != null && i.length && this._printComments(0, i, t, r);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments() {
      let t = this._printStack[this._printStack.length - 1], r = t.innerComments;
      if (!(r != null && r.length)) return;
      let i = this.endsWith(32), n = this._indentInnerComments, a = this._printedComments.size;
      n && this.indent(), this._printComments(1, r, t), i && a !== this._printedComments.size && this.space(), n && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(t, r, i = {}) {
      var n;
      i.statement = !0, (n = i.indent) != null || (i.indent = !1), this.printJoin(t, r, i);
    }
    printList(t, r, i = {}) {
      i.separator == null && (i.separator = k4), this.printJoin(t, r, i);
    }
    _printNewline(t, r) {
      let i = this.format;
      if (i.retainLines || i.compact) return;
      if (i.concise) {
        this.space();
        return;
      }
      if (!t)
        return;
      let n = r.nextNodeStartLine, a = this._lastCommentLine;
      if (n > 0 && a > 0) {
        let o = n - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(t) {
      return t.ignore || this._printedComments.has(t) ? 0 : this._noLineTerminator && _4.test(t.value) ? 2 : (this._printedComments.add(t), this.
      format.shouldPrintComment(t.value) ? 1 : 0);
    }
    _printComment(t, r) {
      let i = this._noLineTerminator, n = t.type === "CommentBlock", a = n && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && this.space();
      let l;
      if (n) {
        let {
          _parenPushNewlineState: c
        } = this;
        if (c?.printed === !1 && ld.test(t.value) && (this.tokenChar(40), this.indent(), c.printed = !0), l = `/*${t.value}*/`, this.format.
        indent.adjustMultilineComment) {
          var u;
          let p = (u = t.loc) == null ? void 0 : u.start.column;
          if (p) {
            let g = new RegExp("\\n\\s{1," + p + "}", "g");
            l = l.replace(g, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let g = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (g += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(g)}`);
          }
        }
      } else i ? l = `/*${t.value}*/` : l = `//${t.value}`;
      this.endsWith(47) && this._space(), this.source("start", t.loc), this._append(l, n), !n && !i && this.newline(1, !0), a && r !== 3 && this.
      newline(1);
    }
    _printComments(t, r, i, n, a = 0) {
      let o = i.loc, l = r.length, u = !!o, c = u ? o.start.line : 0, p = u ? o.end.line : 0, g = 0, P = 0, A = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let C = 0; C < l; C++) {
        let _ = r[C], k = this._shouldPrintComment(_);
        if (k === 2) {
          u = !1;
          break;
        }
        if (u && _.loc && k === 1) {
          let O = _.loc.start.line, M = _.loc.end.line;
          if (t === 0) {
            let F = 0;
            C === 0 ? this._buf.hasContent() && (_.type === "CommentLine" || O != M) && (F = P = 1) : F = O - g, g = M, A(F), this._printComment(
            _, 1), C + 1 === l && (A(Math.max(c - g, P)), g = c);
          } else if (t === 1) {
            let F = O - (C === 0 ? c : g);
            g = M, A(F), this._printComment(_, 1), C + 1 === l && (A(Math.min(1, p - g)), g = p);
          } else {
            let F = O - (C === 0 ? p - a : g);
            g = M, A(F), this._printComment(_, 1);
          }
        } else {
          if (u = !1, k !== 1)
            continue;
          if (l === 1) {
            let O = _.loc ? _.loc.start.line === _.loc.end.line : !ld.test(_.value), M = O && !v4(i) && !C4(n) && !I4(n) && !w4(n);
            t === 0 ? this._printComment(_, M && i.type !== "ObjectExpression" || O && A4(n, {
              body: i
            }) ? 1 : 0) : M && t === 2 ? this._printComment(_, 1) : this._printComment(_, 0);
          } else t === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterface\
Body" ? this._printComment(_, C === 0 ? 2 : C === l - 1 ? 3 : 0) : this._printComment(_, 0);
        }
      }
      t === 2 && u && g && (this._lastCommentLine = g);
    }
  };
  Object.assign(zi.prototype, P4);
  zi.prototype.Noop = /* @__PURE__ */ s(function() {
  }, "Noop");
  var KQ = Tn.default = zi;
  function k4() {
    this.tokenChar(44), this.space();
  }
  s(k4, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var ii = v((gn) => {
  "use strict";
  Object.defineProperty(gn, "__esModule", {
    value: !0
  });
  gn.default = L4;
  var cd = xh(), pd = ud();
  function fd(e, t) {
    var r;
    let i = {
      auxiliaryCommentBefore: t.auxiliaryCommentBefore,
      auxiliaryCommentAfter: t.auxiliaryCommentAfter,
      shouldPrintComment: t.shouldPrintComment,
      retainLines: t.retainLines,
      retainFunctionParens: t.retainFunctionParens,
      comments: t.comments == null || t.comments,
      compact: t.compact,
      minified: t.minified,
      concise: t.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, t.jsescOption),
      recordAndTupleSyntaxType: (r = t.recordAndTupleSyntaxType) != null ? r : "hash",
      topicToken: t.topicToken,
      importAttributesKeyword: t.importAttributesKeyword
    };
    i.decoratorsBeforeExport = t.decoratorsBeforeExport, i.jsescOption.json = t.jsonCompatibleStrings, i.minified ? (i.compact = !0, i.shouldPrintComment =
    i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment || ((l) => i.comments || l.includes("@license") ||
    l.includes("@preserve")), i.compact === "auto" && (i.compact = typeof e == "string" && e.length > 5e5, i.compact && console.error(`[BABE\
L] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)), i.compact && (i.indent.adjustMultilineComment =
    !1);
    let {
      auxiliaryCommentBefore: n,
      auxiliaryCommentAfter: a,
      shouldPrintComment: o
    } = i;
    return n && !o(n) && (i.auxiliaryCommentBefore = void 0), a && !o(a) && (i.auxiliaryCommentAfter = void 0), i;
  }
  s(fd, "normalizeOptions");
  gn.CodeGenerator = class {
    static {
      s(this, "CodeGenerator");
    }
    constructor(t, r = {}, i) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = fd(i, r), this._map = r.sourceMaps ? new cd.
      default(r, i) : null;
    }
    generate() {
      return new pd.default(this._format, this._map).generate(this._ast);
    }
  };
  function L4(e, t = {}, r) {
    let i = fd(r, t), n = t.sourceMaps ? new cd.default(t, r) : null;
    return new pd.default(i, n).generate(e);
  }
  s(L4, "generate");
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var Wl = v((de) => {
  "use strict";
  Object.defineProperty(de, "__esModule", {
    value: !0
  });
  de.Var = de.User = de.Statement = de.SpreadProperty = de.Scope = de.RestProperty = de.ReferencedMemberExpression = de.ReferencedIdentifier =
  de.Referenced = de.Pure = de.NumericLiteralTypeAnnotation = de.Generated = de.ForAwaitStatement = de.Flow = de.Expression = de.ExistentialTypeParam =
  de.BlockScoped = de.BindingIdentifier = void 0;
  var HQ = de.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], GQ = de.ReferencedMemberExpression = ["MemberExpression"], zQ = de.BindingIdentifier =
  ["Identifier"], QQ = de.Statement = ["Statement"], ZQ = de.Expression = ["Expression"], eZ = de.Scope = ["Scopable", "Pattern"], tZ = de.Referenced =
  null, rZ = de.BlockScoped = null, iZ = de.Var = ["VariableDeclaration"], sZ = de.User = null, nZ = de.Generated = null, aZ = de.Pure = null,
  oZ = de.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], lZ = de.RestProperty = ["RestElement"], uZ = de.SpreadProperty =
  ["RestElement"], cZ = de.ExistentialTypeParam = ["ExistsTypeAnnotation"], pZ = de.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnota\
tion"], fZ = de.ForAwaitStatement = ["ForOfStatement"];
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var Xl = v((Ye) => {
  "use strict";
  Object.defineProperty(Ye, "__esModule", {
    value: !0
  });
  Ye.isBindingIdentifier = i6;
  Ye.isBlockScoped = l6;
  Ye.isExpression = n6;
  Ye.isFlow = h6;
  Ye.isForAwaitStatement = y6;
  Ye.isGenerated = p6;
  Ye.isPure = f6;
  Ye.isReferenced = o6;
  Ye.isReferencedIdentifier = t6;
  Ye.isReferencedMemberExpression = r6;
  Ye.isRestProperty = d6;
  Ye.isScope = a6;
  Ye.isSpreadProperty = m6;
  Ye.isStatement = s6;
  Ye.isUser = c6;
  Ye.isVar = u6;
  var M4 = le(), {
    isBinding: F4,
    isBlockScoped: B4,
    isExportDeclaration: j4,
    isExpression: R4,
    isFlow: q4,
    isForStatement: V4,
    isForXStatement: U4,
    isIdentifier: hd,
    isImportDeclaration: K4,
    isImportSpecifier: W4,
    isJSXIdentifier: Y4,
    isJSXMemberExpression: X4,
    isMemberExpression: J4,
    isRestElement: dd,
    isReferenced: Yl,
    isScope: $4,
    isStatement: H4,
    isVar: G4,
    isVariableDeclaration: z4,
    react: Q4,
    isForOfStatement: Z4
  } = M4, {
    isCompatTag: e6
  } = Q4;
  function t6(e) {
    let {
      node: t,
      parent: r
    } = this;
    if (!hd(t, e) && !X4(r, e))
      if (Y4(t, e)) {
        if (e6(t.name)) return !1;
      } else
        return !1;
    return Yl(t, r, this.parentPath.parent);
  }
  s(t6, "isReferencedIdentifier");
  function r6() {
    let {
      node: e,
      parent: t
    } = this;
    return J4(e) && Yl(e, t);
  }
  s(r6, "isReferencedMemberExpression");
  function i6() {
    let {
      node: e,
      parent: t
    } = this, r = this.parentPath.parent;
    return hd(e) && F4(e, t, r);
  }
  s(i6, "isBindingIdentifier");
  function s6() {
    let {
      node: e,
      parent: t
    } = this;
    return H4(e) ? !(z4(e) && (U4(t, {
      left: e
    }) || V4(t, {
      init: e
    }))) : !1;
  }
  s(s6, "isStatement");
  function n6() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : R4(this.node);
  }
  s(n6, "isExpression");
  function a6() {
    return $4(this.node, this.parent);
  }
  s(a6, "isScope");
  function o6() {
    return Yl(this.node, this.parent);
  }
  s(o6, "isReferenced");
  function l6() {
    return B4(this.node);
  }
  s(l6, "isBlockScoped");
  function u6() {
    return G4(this.node);
  }
  s(u6, "isVar");
  function c6() {
    return this.node && !!this.node.loc;
  }
  s(c6, "isUser");
  function p6() {
    return !this.isUser();
  }
  s(p6, "isGenerated");
  function f6(e) {
    return this.scope.isPure(this.node, e);
  }
  s(f6, "isPure");
  function h6() {
    let {
      node: e
    } = this;
    return q4(e) ? !0 : K4(e) ? e.importKind === "type" || e.importKind === "typeof" : j4(e) ? e.exportKind === "type" : W4(e) ? e.importKind ===
    "type" || e.importKind === "typeof" : !1;
  }
  s(h6, "isFlow");
  function d6() {
    return dd(this.node) && this.parentPath && this.parentPath.isObjectPattern();
  }
  s(d6, "isRestProperty");
  function m6() {
    return dd(this.node) && this.parentPath && this.parentPath.isObjectExpression();
  }
  s(m6, "isSpreadProperty");
  function y6() {
    return Z4(this.node, {
      await: !0
    });
  }
  s(y6, "isForAwaitStatement");
  Ye.isExistentialTypeParam = /* @__PURE__ */ s(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), Ye.isNumericLiteralTypeAnnotation = /* @__PURE__ */ s(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/traverse/lib/visitors.js
var Zi = v((si) => {
  "use strict";
  Object.defineProperty(si, "__esModule", {
    value: !0
  });
  si.explode = Ad;
  si.isExplodedVisitor = Pd;
  si.merge = x6;
  si.verify = vd;
  var Ed = Wl(), T6 = Xl(), g6 = le(), {
    DEPRECATED_KEYS: md,
    DEPRECATED_ALIASES: yd,
    FLIPPED_ALIAS_KEYS: Td,
    TYPES: b6,
    __internal__deprecationWarning: gd
  } = g6;
  function S6(e) {
    return e in Ed;
  }
  s(S6, "isVirtualType");
  function Pd(e) {
    return e?._exploded;
  }
  s(Pd, "isExplodedVisitor");
  function Ad(e) {
    if (Pd(e)) return e;
    e._exploded = !0;
    for (let t of Object.keys(e)) {
      if (kr(t)) continue;
      let r = t.split("|");
      if (r.length === 1) continue;
      let i = e[t];
      delete e[t];
      for (let n of r)
        e[n] = i;
    }
    vd(e), delete e.__esModule, E6(e), xd(e);
    for (let t of Object.keys(e)) {
      if (kr(t) || !S6(t)) continue;
      let r = e[t];
      for (let n of Object.keys(r))
        r[n] = P6(t, r[n]);
      delete e[t];
      let i = Ed[t];
      if (i !== null)
        for (let n of i)
          e[n] ? Qi(e[n], r) : e[n] = r;
      else
        Qi(e, r);
    }
    for (let t of Object.keys(e)) {
      if (kr(t)) continue;
      let r = Td[t];
      if (t in md) {
        let n = md[t];
        gd(t, n, "Visitor "), r = [n];
      } else if (t in yd) {
        let n = yd[t];
        gd(t, n, "Visitor "), r = Td[n];
      }
      if (!r) continue;
      let i = e[t];
      delete e[t];
      for (let n of r) {
        let a = e[n];
        a ? Qi(a, i) : e[n] = Object.assign({}, i);
      }
    }
    for (let t of Object.keys(e))
      kr(t) || xd(e[t]);
    return e;
  }
  s(Ad, "explode");
  function vd(e) {
    if (!e._verified) {
      if (typeof e == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let t of Object.keys(e)) {
        if ((t === "enter" || t === "exit") && bd(t, e[t]), kr(t)) continue;
        if (b6.indexOf(t) < 0)
          throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);
        let r = e[t];
        if (typeof r == "object")
          for (let i of Object.keys(r))
            if (i === "enter" || i === "exit")
              bd(`${t}.${i}`, r[i]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${i}`);
      }
      e._verified = !0;
    }
  }
  s(vd, "verify");
  function bd(e, t) {
    let r = [].concat(t);
    for (let i of r)
      if (typeof i != "function")
        throw new TypeError(`Non-function found defined in ${e} with type ${typeof i}`);
  }
  s(bd, "validateVisitorMethods");
  function x6(e, t = [], r) {
    let i = {};
    for (let n = 0; n < e.length; n++) {
      let a = Ad(e[n]), o = t[n], l = a;
      (o || r) && (l = Sd(l, o, r)), Qi(i, l);
      for (let u of Object.keys(a)) {
        if (kr(u)) continue;
        let c = a[u];
        (o || r) && (c = Sd(c, o, r));
        let p = i[u] || (i[u] = {});
        Qi(p, c);
      }
    }
    return i;
  }
  s(x6, "merge");
  function Sd(e, t, r) {
    let i = {};
    for (let n of ["enter", "exit"]) {
      let a = e[n];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return t && (l = /* @__PURE__ */ s(function(u) {
          o.call(t, u, t);
        }, "newFn")), r && (l = r(t?.key, n, l)), l !== o && (l.toString = () => o.toString()), l;
      }), i[n] = a);
    }
    return i;
  }
  s(Sd, "wrapWithStateOrWrapper");
  function E6(e) {
    for (let t of Object.keys(e)) {
      if (kr(t)) continue;
      let r = e[t];
      typeof r == "function" && (e[t] = {
        enter: r
      });
    }
  }
  s(E6, "ensureEntranceObjects");
  function xd(e) {
    e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
  }
  s(xd, "ensureCallbackArrays");
  function P6(e, t) {
    let r = `is${e}`, i = T6[r], n = /* @__PURE__ */ s(function(a) {
      if (i.call(a))
        return t.apply(this, arguments);
    }, "newFn");
    return n.toString = () => t.toString(), n;
  }
  s(P6, "wrapCheck");
  function kr(e) {
    return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" ||
    e === "blacklist";
  }
  s(kr, "shouldIgnoreKey");
  function Qi(e, t) {
    for (let r of ["enter", "exit"])
      t[r] && (e[r] = [].concat(e[r] || [], t[r]));
  }
  s(Qi, "mergePair");
});

// ../node_modules/@babel/traverse/lib/cache.js
var Lr = v((bt) => {
  "use strict";
  Object.defineProperty(bt, "__esModule", {
    value: !0
  });
  bt.clear = v6;
  bt.clearPath = Cd;
  bt.clearScope = Id;
  bt.getCachedPaths = C6;
  bt.getOrCreateCachedPaths = I6;
  bt.scope = bt.path = void 0;
  var bn = bt.path = /* @__PURE__ */ new WeakMap(), A6 = bt.scope = /* @__PURE__ */ new WeakMap();
  function v6() {
    Cd(), Id();
  }
  s(v6, "clear");
  function Cd() {
    bt.path = bn = /* @__PURE__ */ new WeakMap();
  }
  s(Cd, "clearPath");
  function Id() {
    bt.scope = A6 = /* @__PURE__ */ new WeakMap();
  }
  s(Id, "clearScope");
  var Jl = Object.freeze({});
  function C6(e, t) {
    var r, i;
    return e = null, (r = bn.get((i = e) != null ? i : Jl)) == null ? void 0 : r.get(t);
  }
  s(C6, "getCachedPaths");
  function I6(e, t) {
    var r, i;
    e = null;
    let n = bn.get((r = e) != null ? r : Jl);
    n || bn.set((i = e) != null ? i : Jl, n = /* @__PURE__ */ new WeakMap());
    let a = n.get(t);
    return a || n.set(t, a = /* @__PURE__ */ new Map()), a;
  }
  s(I6, "getOrCreateCachedPaths");
});

// ../node_modules/debug/node_modules/ms/index.js
var Od = v((SZ, wd) => {
  var ni = 1e3, ai = ni * 60, oi = ai * 60, Mr = oi * 24, w6 = Mr * 7, O6 = Mr * 365.25;
  wd.exports = function(e, t) {
    t = t || {};
    var r = typeof e;
    if (r === "string" && e.length > 0)
      return N6(e);
    if (r === "number" && isFinite(e))
      return t.long ? D6(e) : _6(e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(e)
    );
  };
  function N6(e) {
    if (e = String(e), !(e.length > 100)) {
      var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        e
      );
      if (t) {
        var r = parseFloat(t[1]), i = (t[2] || "ms").toLowerCase();
        switch (i) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * O6;
          case "weeks":
          case "week":
          case "w":
            return r * w6;
          case "days":
          case "day":
          case "d":
            return r * Mr;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * oi;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * ai;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * ni;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  s(N6, "parse");
  function _6(e) {
    var t = Math.abs(e);
    return t >= Mr ? Math.round(e / Mr) + "d" : t >= oi ? Math.round(e / oi) + "h" : t >= ai ? Math.round(e / ai) + "m" : t >= ni ? Math.round(
    e / ni) + "s" : e + "ms";
  }
  s(_6, "fmtShort");
  function D6(e) {
    var t = Math.abs(e);
    return t >= Mr ? Sn(e, t, Mr, "day") : t >= oi ? Sn(e, t, oi, "hour") : t >= ai ? Sn(e, t, ai, "minute") : t >= ni ? Sn(e, t, ni, "secon\
d") : e + " ms";
  }
  s(D6, "fmtLong");
  function Sn(e, t, r, i) {
    var n = t >= r * 1.5;
    return Math.round(e / r) + " " + i + (n ? "s" : "");
  }
  s(Sn, "plural");
});

// ../node_modules/debug/src/common.js
var $l = v((EZ, Nd) => {
  function k6(e) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = a, r.enable = n, r.enabled = o, r.humanize = Od(), r.destroy = c, Object.keys(e).forEach(
    (p) => {
      r[p] = e[p];
    }), r.names = [], r.skips = [], r.formatters = {};
    function t(p) {
      let g = 0;
      for (let P = 0; P < p.length; P++)
        g = (g << 5) - g + p.charCodeAt(P), g |= 0;
      return r.colors[Math.abs(g) % r.colors.length];
    }
    s(t, "selectColor"), r.selectColor = t;
    function r(p) {
      let g, P = null, A, C;
      function _(...k) {
        if (!_.enabled)
          return;
        let O = _, M = Number(/* @__PURE__ */ new Date()), F = M - (g || M);
        O.diff = F, O.prev = g, O.curr = M, g = M, k[0] = r.coerce(k[0]), typeof k[0] != "string" && k.unshift("%O");
        let G = 0;
        k[0] = k[0].replace(/%([a-zA-Z%])/g, (K, oe) => {
          if (K === "%%")
            return "%";
          G++;
          let Oe = r.formatters[oe];
          if (typeof Oe == "function") {
            let Ne = k[G];
            K = Oe.call(O, Ne), k.splice(G, 1), G--;
          }
          return K;
        }), r.formatArgs.call(O, k), (O.log || r.log).apply(O, k);
      }
      return s(_, "debug"), _.namespace = p, _.useColors = r.useColors(), _.color = r.selectColor(p), _.extend = i, _.destroy = r.destroy, Object.
      defineProperty(_, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ s(() => P !== null ? P : (A !== r.namespaces && (A = r.namespaces, C = r.enabled(p)), C), "get"),
        set: /* @__PURE__ */ s((k) => {
          P = k;
        }, "set")
      }), typeof r.init == "function" && r.init(_), _;
    }
    s(r, "createDebug");
    function i(p, g) {
      let P = r(this.namespace + (typeof g > "u" ? ":" : g) + p);
      return P.log = this.log, P;
    }
    s(i, "extend");
    function n(p) {
      r.save(p), r.namespaces = p, r.names = [], r.skips = [];
      let g, P = (typeof p == "string" ? p : "").split(/[\s,]+/), A = P.length;
      for (g = 0; g < A; g++)
        P[g] && (p = P[g].replace(/\*/g, ".*?"), p[0] === "-" ? r.skips.push(new RegExp("^" + p.slice(1) + "$")) : r.names.push(new RegExp("\
^" + p + "$")));
    }
    s(n, "enable");
    function a() {
      let p = [
        ...r.names.map(l),
        ...r.skips.map(l).map((g) => "-" + g)
      ].join(",");
      return r.enable(""), p;
    }
    s(a, "disable");
    function o(p) {
      if (p[p.length - 1] === "*")
        return !0;
      let g, P;
      for (g = 0, P = r.skips.length; g < P; g++)
        if (r.skips[g].test(p))
          return !1;
      for (g = 0, P = r.names.length; g < P; g++)
        if (r.names[g].test(p))
          return !0;
      return !1;
    }
    s(o, "enabled");
    function l(p) {
      return p.toString().substring(2, p.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    s(l, "toNamespace");
    function u(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    s(u, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return s(c, "destroy"), r.enable(r.load()), r;
  }
  s(k6, "setup");
  Nd.exports = k6;
});

// ../node_modules/debug/src/browser.js
var _d = v((St, xn) => {
  St.formatArgs = M6;
  St.save = F6;
  St.load = B6;
  St.useColors = L6;
  St.storage = j6();
  St.destroy = /* @__PURE__ */ (() => {
    let e = !1;
    return () => {
      e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  St.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function L6() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "\
u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement &&
    document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  s(L6, "useColors");
  function M6(e) {
    if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" +
    xn.exports.humanize(this.diff), !this.useColors)
      return;
    let t = "color: " + this.color;
    e.splice(1, 0, t, "color: inherit");
    let r = 0, i = 0;
    e[0].replace(/%[a-zA-Z%]/g, (n) => {
      n !== "%%" && (r++, n === "%c" && (i = r));
    }), e.splice(i, 0, t);
  }
  s(M6, "formatArgs");
  St.log = console.debug || console.log || (() => {
  });
  function F6(e) {
    try {
      e ? St.storage.setItem("debug", e) : St.storage.removeItem("debug");
    } catch {
    }
  }
  s(F6, "save");
  function B6() {
    let e;
    try {
      e = St.storage.getItem("debug");
    } catch {
    }
    return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
  }
  s(B6, "load");
  function j6() {
    try {
      return localStorage;
    } catch {
    }
  }
  s(j6, "localstorage");
  xn.exports = $l()(St);
  var { formatters: R6 } = xn.exports;
  R6.j = function(e) {
    try {
      return JSON.stringify(e);
    } catch (t) {
      return "[UnexpectedJSONParseError]: " + t.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var kd = v((vZ, Dd) => {
  "use strict";
  Dd.exports = (e, t = process.argv) => {
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", i = t.indexOf(r + e), n = t.indexOf("--");
    return i !== -1 && (n === -1 || i < n);
  };
});

// ../node_modules/supports-color/index.js
var Fd = v((CZ, Md) => {
  "use strict";
  var q6 = Gr("os"), Ld = Gr("tty"), At = kd(), { env: ze } = process, cr;
  At("no-color") || At("no-colors") || At("color=false") || At("color=never") ? cr = 0 : (At("color") || At("colors") || At("color=true") ||
  At("color=always")) && (cr = 1);
  "FORCE_COLOR" in ze && (ze.FORCE_COLOR === "true" ? cr = 1 : ze.FORCE_COLOR === "false" ? cr = 0 : cr = ze.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(ze.FORCE_COLOR, 10), 3));
  function Hl(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  s(Hl, "translateLevel");
  function Gl(e, t) {
    if (cr === 0)
      return 0;
    if (At("color=16m") || At("color=full") || At("color=truecolor"))
      return 3;
    if (At("color=256"))
      return 2;
    if (e && !t && cr === void 0)
      return 0;
    let r = cr || 0;
    if (ze.TERM === "dumb")
      return r;
    if (process.platform === "win32") {
      let i = q6.release().split(".");
      return Number(i[0]) >= 10 && Number(i[2]) >= 10586 ? Number(i[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in ze)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((i) => i in ze) || ze.CI_NAME === "codeship" ?
      1 : r;
    if ("TEAMCITY_VERSION" in ze)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(ze.TEAMCITY_VERSION) ? 1 : 0;
    if (ze.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in ze) {
      let i = parseInt((ze.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (ze.TERM_PROGRAM) {
        case "iTerm.app":
          return i >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(ze.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(ze.TERM) || "COLORTERM" in
    ze ? 1 : r;
  }
  s(Gl, "supportsColor");
  function V6(e) {
    let t = Gl(e, e && e.isTTY);
    return Hl(t);
  }
  s(V6, "getSupportLevel");
  Md.exports = {
    supportsColor: V6,
    stdout: Hl(Gl(!0, Ld.isatty(1))),
    stderr: Hl(Gl(!0, Ld.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var jd = v((Ze, Pn) => {
  var U6 = Gr("tty"), En = Gr("util");
  Ze.init = H6;
  Ze.log = X6;
  Ze.formatArgs = W6;
  Ze.save = J6;
  Ze.load = $6;
  Ze.useColors = K6;
  Ze.destroy = En.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  Ze.colors = [6, 2, 3, 4, 5, 1];
  try {
    let e = Fd();
    e && (e.stderr || e).level >= 2 && (Ze.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  Ze.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
    let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (n, a) => a.toUpperCase()), i = process.env[t];
    return /^(yes|on|true|enabled)$/i.test(i) ? i = !0 : /^(no|off|false|disabled)$/i.test(i) ? i = !1 : i === "null" ? i = null : i = Number(
    i), e[r] = i, e;
  }, {});
  function K6() {
    return "colors" in Ze.inspectOpts ? !!Ze.inspectOpts.colors : U6.isatty(process.stderr.fd);
  }
  s(K6, "useColors");
  function W6(e) {
    let { namespace: t, useColors: r } = this;
    if (r) {
      let i = this.color, n = "\x1B[3" + (i < 8 ? i : "8;5;" + i), a = `  ${n};1m${t} \x1B[0m`;
      e[0] = a + e[0].split(`
`).join(`
` + a), e.push(n + "m+" + Pn.exports.humanize(this.diff) + "\x1B[0m");
    } else
      e[0] = Y6() + t + " " + e[0];
  }
  s(W6, "formatArgs");
  function Y6() {
    return Ze.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  s(Y6, "getDate");
  function X6(...e) {
    return process.stderr.write(En.format(...e) + `
`);
  }
  s(X6, "log");
  function J6(e) {
    e ? process.env.DEBUG = e : delete process.env.DEBUG;
  }
  s(J6, "save");
  function $6() {
    return process.env.DEBUG;
  }
  s($6, "load");
  function H6(e) {
    e.inspectOpts = {};
    let t = Object.keys(Ze.inspectOpts);
    for (let r = 0; r < t.length; r++)
      e.inspectOpts[t[r]] = Ze.inspectOpts[t[r]];
  }
  s(H6, "init");
  Pn.exports = $l()(Ze);
  var { formatters: Bd } = Pn.exports;
  Bd.o = function(e) {
    return this.inspectOpts.colors = this.useColors, En.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
  };
  Bd.O = function(e) {
    return this.inspectOpts.colors = this.useColors, En.inspect(e, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var Rd = v((OZ, zl) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? zl.exports = _d() : zl.exports = jd();
});

// ../node_modules/@babel/helper-split-export-declaration/lib/index.js
var Ud = v((eu) => {
  "use strict";
  Object.defineProperty(eu, "__esModule", {
    value: !0
  });
  eu.default = Z6;
  var G6 = le(), {
    cloneNode: Ql,
    exportNamedDeclaration: qd,
    exportSpecifier: Vd,
    identifier: Zl,
    variableDeclaration: z6,
    variableDeclarator: Q6
  } = G6;
  function Z6(e) {
    if (!e.isExportDeclaration() || e.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (e.isExportDefaultDeclaration()) {
      let a = e.get("declaration"), o = a.isFunctionDeclaration() || a.isClassDeclaration(), l = a.isFunctionExpression() || a.isClassExpression(),
      u = a.isScope() ? a.scope.parent : a.scope, c = a.node.id, p = !1;
      c ? l && u.hasBinding(c.name) && (p = !0, c = u.generateUidIdentifier(c.name)) : (p = !0, c = u.generateUidIdentifier("default"), (o ||
      l) && (a.node.id = Ql(c)));
      let g = o ? a.node : z6("var", [Q6(Ql(c), a.node)]), P = qd(null, [Vd(Ql(c), Zl("default"))]);
      return e.insertAfter(P), e.replaceWith(g), p && u.registerDeclaration(e), e;
    } else if (e.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let t = e.get("declaration"), r = t.getOuterBindingIdentifiers(), i = Object.keys(r).map((a) => Vd(Zl(a), Zl(a))), n = qd(null, i);
    return e.insertAfter(n), e.replaceWith(t.node), e;
  }
  s(Z6, "splitExportDeclaration");
});

// ../node_modules/@babel/helper-environment-visitor/lib/index.js
var ru = v((li) => {
  "use strict";
  Object.defineProperty(li, "__esModule", {
    value: !0
  });
  li.default = void 0;
  li.requeueComputedKeyAndDecorators = tu;
  li.skipAllButComputedKey = /* @__PURE__ */ s(function(t) {
    t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
  }, "skipAllButComputedKey");
  function tu(e) {
    let {
      context: t,
      node: r
    } = e;
    if (r.computed && t.maybeQueue(e.get("key")), r.decorators)
      for (let i of e.get("decorators"))
        t.maybeQueue(i);
  }
  s(tu, "requeueComputedKeyAndDecorators");
  var e8 = {
    FunctionParent(e) {
      e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && tu(e));
    },
    Property(e) {
      e.isObjectProperty() || (e.skip(), tu(e));
    }
  }, t8 = e8;
  li.default = t8;
});

// ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var Kd = v((An) => {
  "use strict";
  Object.defineProperty(An, "__esModule", {
    value: !0
  });
  An.default = void 0;
  var r8 = Ud(), i8 = le(), s8 = ru(), n8 = vn(), a8 = Zi(), o8 = {
    ReferencedIdentifier({
      node: e
    }, t) {
      e.name === t.oldName && (e.name = t.newName);
    },
    Scope(e, t) {
      e.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier) || (e.skip(), e.isMethod() && (0, s8.requeueComputedKeyAndDecorators)(
      e));
    },
    ObjectProperty({
      node: e,
      scope: t
    }, r) {
      let {
        name: i
      } = e.key;
      if (e.shorthand && (i === r.oldName || i === r.newName) && t.getBindingIdentifier(i) === r.binding.identifier) {
        var n;
        e.shorthand = !1, (n = e.extra) != null && n.shorthand && (e.extra.shorthand = !1);
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(e, t) {
      if (e.isVariableDeclaration()) return;
      let r = e.getOuterBindingIdentifiers();
      for (let i in r)
        i === t.oldName && (r[i].name = t.newName);
    }
  }, iu = class {
    static {
      s(this, "Renamer");
    }
    constructor(t, r, i) {
      this.newName = i, this.oldName = r, this.binding = t;
    }
    maybeConvertFromExportDeclaration(t) {
      let r = t.parentPath;
      if (r.isExportDeclaration()) {
        if (r.isExportDefaultDeclaration()) {
          let {
            declaration: i
          } = r.node;
          if (i8.isDeclaration(i) && !i.id)
            return;
        }
        r.isExportAllDeclaration() || (0, r8.default)(r);
      }
    }
    maybeConvertFromClassFunctionDeclaration(t) {
      return t;
    }
    maybeConvertFromClassFunctionExpression(t) {
      return t;
    }
    rename() {
      let {
        binding: t,
        oldName: r,
        newName: i
      } = this, {
        scope: n,
        path: a
      } = t, o = a.find((u) => u.isDeclaration() || u.isFunctionExpression() || u.isClassExpression());
      o && o.getOuterBindingIdentifiers()[r] === t.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || n.block;
      (0, n8.traverseNode)(l, (0, a8.explode)(o8), n, this, n.path, {
        discriminant: !0
      }), arguments[0] || (n.removeOwnBinding(r), n.bindings[i] = t, this.binding.identifier.name = i), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  An.default = iu;
});

// ../node_modules/@babel/traverse/lib/scope/binding.js
var Wd = v((Cn) => {
  "use strict";
  Object.defineProperty(Cn, "__esModule", {
    value: !0
  });
  Cn.default = void 0;
  var su = class {
    static {
      s(this, "Binding");
    }
    constructor({
      identifier: t,
      scope: r,
      path: i,
      kind: n
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = i, this.kind = n,
      (n === "var" || n === "hoisted") && l8(i) && this.reassign(i), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(t) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(t) {
      this.constant = !1, this.constantViolations.indexOf(t) === -1 && this.constantViolations.push(t);
    }
    reference(t) {
      this.referencePaths.indexOf(t) === -1 && (this.referenced = !0, this.references++, this.referencePaths.push(t));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  Cn.default = su;
  function l8(e) {
    for (let {
      parentPath: t,
      key: r
    } = e; t; {
      parentPath: t,
      key: r
    } = t) {
      if (t.isFunctionParent()) return !1;
      if (t.isWhile() || t.isForXStatement() || t.isForStatement() && r === "body")
        return !0;
    }
    return !1;
  }
  s(l8, "isDeclaredInLoop");
});

// ../node_modules/@babel/traverse/node_modules/globals/globals.json
var Yd = v((jZ, u8) => {
  u8.exports = {
    builtin: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      BigInt: !1,
      BigInt64Array: !1,
      BigUint64Array: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      globalThis: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es5: {
      Array: !1,
      Boolean: !1,
      constructor: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      propertyIsEnumerable: !1,
      RangeError: !1,
      ReferenceError: !1,
      RegExp: !1,
      String: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1
    },
    es2015: {
      Array: !1,
      ArrayBuffer: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es2017: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    browser: {
      AbortController: !1,
      AbortSignal: !1,
      addEventListener: !1,
      alert: !1,
      AnalyserNode: !1,
      Animation: !1,
      AnimationEffectReadOnly: !1,
      AnimationEffectTiming: !1,
      AnimationEffectTimingReadOnly: !1,
      AnimationEvent: !1,
      AnimationPlaybackEvent: !1,
      AnimationTimeline: !1,
      applicationCache: !1,
      ApplicationCache: !1,
      ApplicationCacheErrorEvent: !1,
      atob: !1,
      Attr: !1,
      Audio: !1,
      AudioBuffer: !1,
      AudioBufferSourceNode: !1,
      AudioContext: !1,
      AudioDestinationNode: !1,
      AudioListener: !1,
      AudioNode: !1,
      AudioParam: !1,
      AudioProcessingEvent: !1,
      AudioScheduledSourceNode: !1,
      "AudioWorkletGlobalScope ": !1,
      AudioWorkletNode: !1,
      AudioWorkletProcessor: !1,
      BarProp: !1,
      BaseAudioContext: !1,
      BatteryManager: !1,
      BeforeUnloadEvent: !1,
      BiquadFilterNode: !1,
      Blob: !1,
      BlobEvent: !1,
      blur: !1,
      BroadcastChannel: !1,
      btoa: !1,
      BudgetService: !1,
      ByteLengthQueuingStrategy: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      cancelAnimationFrame: !1,
      cancelIdleCallback: !1,
      CanvasCaptureMediaStreamTrack: !1,
      CanvasGradient: !1,
      CanvasPattern: !1,
      CanvasRenderingContext2D: !1,
      ChannelMergerNode: !1,
      ChannelSplitterNode: !1,
      CharacterData: !1,
      clearInterval: !1,
      clearTimeout: !1,
      clientInformation: !1,
      ClipboardEvent: !1,
      close: !1,
      closed: !1,
      CloseEvent: !1,
      Comment: !1,
      CompositionEvent: !1,
      confirm: !1,
      console: !1,
      ConstantSourceNode: !1,
      ConvolverNode: !1,
      CountQueuingStrategy: !1,
      createImageBitmap: !1,
      Credential: !1,
      CredentialsContainer: !1,
      crypto: !1,
      Crypto: !1,
      CryptoKey: !1,
      CSS: !1,
      CSSConditionRule: !1,
      CSSFontFaceRule: !1,
      CSSGroupingRule: !1,
      CSSImportRule: !1,
      CSSKeyframeRule: !1,
      CSSKeyframesRule: !1,
      CSSMediaRule: !1,
      CSSNamespaceRule: !1,
      CSSPageRule: !1,
      CSSRule: !1,
      CSSRuleList: !1,
      CSSStyleDeclaration: !1,
      CSSStyleRule: !1,
      CSSStyleSheet: !1,
      CSSSupportsRule: !1,
      CustomElementRegistry: !1,
      customElements: !1,
      CustomEvent: !1,
      DataTransfer: !1,
      DataTransferItem: !1,
      DataTransferItemList: !1,
      defaultstatus: !1,
      defaultStatus: !1,
      DelayNode: !1,
      DeviceMotionEvent: !1,
      DeviceOrientationEvent: !1,
      devicePixelRatio: !1,
      dispatchEvent: !1,
      document: !1,
      Document: !1,
      DocumentFragment: !1,
      DocumentType: !1,
      DOMError: !1,
      DOMException: !1,
      DOMImplementation: !1,
      DOMMatrix: !1,
      DOMMatrixReadOnly: !1,
      DOMParser: !1,
      DOMPoint: !1,
      DOMPointReadOnly: !1,
      DOMQuad: !1,
      DOMRect: !1,
      DOMRectReadOnly: !1,
      DOMStringList: !1,
      DOMStringMap: !1,
      DOMTokenList: !1,
      DragEvent: !1,
      DynamicsCompressorNode: !1,
      Element: !1,
      ErrorEvent: !1,
      event: !1,
      Event: !1,
      EventSource: !1,
      EventTarget: !1,
      external: !1,
      fetch: !1,
      File: !1,
      FileList: !1,
      FileReader: !1,
      find: !1,
      focus: !1,
      FocusEvent: !1,
      FontFace: !1,
      FontFaceSetLoadEvent: !1,
      FormData: !1,
      frameElement: !1,
      frames: !1,
      GainNode: !1,
      Gamepad: !1,
      GamepadButton: !1,
      GamepadEvent: !1,
      getComputedStyle: !1,
      getSelection: !1,
      HashChangeEvent: !1,
      Headers: !1,
      history: !1,
      History: !1,
      HTMLAllCollection: !1,
      HTMLAnchorElement: !1,
      HTMLAreaElement: !1,
      HTMLAudioElement: !1,
      HTMLBaseElement: !1,
      HTMLBodyElement: !1,
      HTMLBRElement: !1,
      HTMLButtonElement: !1,
      HTMLCanvasElement: !1,
      HTMLCollection: !1,
      HTMLContentElement: !1,
      HTMLDataElement: !1,
      HTMLDataListElement: !1,
      HTMLDetailsElement: !1,
      HTMLDialogElement: !1,
      HTMLDirectoryElement: !1,
      HTMLDivElement: !1,
      HTMLDListElement: !1,
      HTMLDocument: !1,
      HTMLElement: !1,
      HTMLEmbedElement: !1,
      HTMLFieldSetElement: !1,
      HTMLFontElement: !1,
      HTMLFormControlsCollection: !1,
      HTMLFormElement: !1,
      HTMLFrameElement: !1,
      HTMLFrameSetElement: !1,
      HTMLHeadElement: !1,
      HTMLHeadingElement: !1,
      HTMLHRElement: !1,
      HTMLHtmlElement: !1,
      HTMLIFrameElement: !1,
      HTMLImageElement: !1,
      HTMLInputElement: !1,
      HTMLLabelElement: !1,
      HTMLLegendElement: !1,
      HTMLLIElement: !1,
      HTMLLinkElement: !1,
      HTMLMapElement: !1,
      HTMLMarqueeElement: !1,
      HTMLMediaElement: !1,
      HTMLMenuElement: !1,
      HTMLMetaElement: !1,
      HTMLMeterElement: !1,
      HTMLModElement: !1,
      HTMLObjectElement: !1,
      HTMLOListElement: !1,
      HTMLOptGroupElement: !1,
      HTMLOptionElement: !1,
      HTMLOptionsCollection: !1,
      HTMLOutputElement: !1,
      HTMLParagraphElement: !1,
      HTMLParamElement: !1,
      HTMLPictureElement: !1,
      HTMLPreElement: !1,
      HTMLProgressElement: !1,
      HTMLQuoteElement: !1,
      HTMLScriptElement: !1,
      HTMLSelectElement: !1,
      HTMLShadowElement: !1,
      HTMLSlotElement: !1,
      HTMLSourceElement: !1,
      HTMLSpanElement: !1,
      HTMLStyleElement: !1,
      HTMLTableCaptionElement: !1,
      HTMLTableCellElement: !1,
      HTMLTableColElement: !1,
      HTMLTableElement: !1,
      HTMLTableRowElement: !1,
      HTMLTableSectionElement: !1,
      HTMLTemplateElement: !1,
      HTMLTextAreaElement: !1,
      HTMLTimeElement: !1,
      HTMLTitleElement: !1,
      HTMLTrackElement: !1,
      HTMLUListElement: !1,
      HTMLUnknownElement: !1,
      HTMLVideoElement: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      IdleDeadline: !1,
      IIRFilterNode: !1,
      Image: !1,
      ImageBitmap: !1,
      ImageBitmapRenderingContext: !1,
      ImageCapture: !1,
      ImageData: !1,
      indexedDB: !1,
      innerHeight: !1,
      innerWidth: !1,
      InputEvent: !1,
      IntersectionObserver: !1,
      IntersectionObserverEntry: !1,
      Intl: !1,
      isSecureContext: !1,
      KeyboardEvent: !1,
      KeyframeEffect: !1,
      KeyframeEffectReadOnly: !1,
      length: !1,
      localStorage: !1,
      location: !0,
      Location: !1,
      locationbar: !1,
      matchMedia: !1,
      MediaDeviceInfo: !1,
      MediaDevices: !1,
      MediaElementAudioSourceNode: !1,
      MediaEncryptedEvent: !1,
      MediaError: !1,
      MediaKeyMessageEvent: !1,
      MediaKeySession: !1,
      MediaKeyStatusMap: !1,
      MediaKeySystemAccess: !1,
      MediaList: !1,
      MediaQueryList: !1,
      MediaQueryListEvent: !1,
      MediaRecorder: !1,
      MediaSettingsRange: !1,
      MediaSource: !1,
      MediaStream: !1,
      MediaStreamAudioDestinationNode: !1,
      MediaStreamAudioSourceNode: !1,
      MediaStreamEvent: !1,
      MediaStreamTrack: !1,
      MediaStreamTrackEvent: !1,
      menubar: !1,
      MessageChannel: !1,
      MessageEvent: !1,
      MessagePort: !1,
      MIDIAccess: !1,
      MIDIConnectionEvent: !1,
      MIDIInput: !1,
      MIDIInputMap: !1,
      MIDIMessageEvent: !1,
      MIDIOutput: !1,
      MIDIOutputMap: !1,
      MIDIPort: !1,
      MimeType: !1,
      MimeTypeArray: !1,
      MouseEvent: !1,
      moveBy: !1,
      moveTo: !1,
      MutationEvent: !1,
      MutationObserver: !1,
      MutationRecord: !1,
      name: !1,
      NamedNodeMap: !1,
      NavigationPreloadManager: !1,
      navigator: !1,
      Navigator: !1,
      NetworkInformation: !1,
      Node: !1,
      NodeFilter: !1,
      NodeIterator: !1,
      NodeList: !1,
      Notification: !1,
      OfflineAudioCompletionEvent: !1,
      OfflineAudioContext: !1,
      offscreenBuffering: !1,
      OffscreenCanvas: !0,
      onabort: !0,
      onafterprint: !0,
      onanimationend: !0,
      onanimationiteration: !0,
      onanimationstart: !0,
      onappinstalled: !0,
      onauxclick: !0,
      onbeforeinstallprompt: !0,
      onbeforeprint: !0,
      onbeforeunload: !0,
      onblur: !0,
      oncancel: !0,
      oncanplay: !0,
      oncanplaythrough: !0,
      onchange: !0,
      onclick: !0,
      onclose: !0,
      oncontextmenu: !0,
      oncuechange: !0,
      ondblclick: !0,
      ondevicemotion: !0,
      ondeviceorientation: !0,
      ondeviceorientationabsolute: !0,
      ondrag: !0,
      ondragend: !0,
      ondragenter: !0,
      ondragleave: !0,
      ondragover: !0,
      ondragstart: !0,
      ondrop: !0,
      ondurationchange: !0,
      onemptied: !0,
      onended: !0,
      onerror: !0,
      onfocus: !0,
      ongotpointercapture: !0,
      onhashchange: !0,
      oninput: !0,
      oninvalid: !0,
      onkeydown: !0,
      onkeypress: !0,
      onkeyup: !0,
      onlanguagechange: !0,
      onload: !0,
      onloadeddata: !0,
      onloadedmetadata: !0,
      onloadstart: !0,
      onlostpointercapture: !0,
      onmessage: !0,
      onmessageerror: !0,
      onmousedown: !0,
      onmouseenter: !0,
      onmouseleave: !0,
      onmousemove: !0,
      onmouseout: !0,
      onmouseover: !0,
      onmouseup: !0,
      onmousewheel: !0,
      onoffline: !0,
      ononline: !0,
      onpagehide: !0,
      onpageshow: !0,
      onpause: !0,
      onplay: !0,
      onplaying: !0,
      onpointercancel: !0,
      onpointerdown: !0,
      onpointerenter: !0,
      onpointerleave: !0,
      onpointermove: !0,
      onpointerout: !0,
      onpointerover: !0,
      onpointerup: !0,
      onpopstate: !0,
      onprogress: !0,
      onratechange: !0,
      onrejectionhandled: !0,
      onreset: !0,
      onresize: !0,
      onscroll: !0,
      onsearch: !0,
      onseeked: !0,
      onseeking: !0,
      onselect: !0,
      onstalled: !0,
      onstorage: !0,
      onsubmit: !0,
      onsuspend: !0,
      ontimeupdate: !0,
      ontoggle: !0,
      ontransitionend: !0,
      onunhandledrejection: !0,
      onunload: !0,
      onvolumechange: !0,
      onwaiting: !0,
      onwheel: !0,
      open: !1,
      openDatabase: !1,
      opener: !1,
      Option: !1,
      origin: !1,
      OscillatorNode: !1,
      outerHeight: !1,
      outerWidth: !1,
      PageTransitionEvent: !1,
      pageXOffset: !1,
      pageYOffset: !1,
      PannerNode: !1,
      parent: !1,
      Path2D: !1,
      PaymentAddress: !1,
      PaymentRequest: !1,
      PaymentRequestUpdateEvent: !1,
      PaymentResponse: !1,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceLongTaskTiming: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceNavigationTiming: !1,
      PerformanceObserver: !1,
      PerformanceObserverEntryList: !1,
      PerformancePaintTiming: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      PeriodicWave: !1,
      Permissions: !1,
      PermissionStatus: !1,
      personalbar: !1,
      PhotoCapabilities: !1,
      Plugin: !1,
      PluginArray: !1,
      PointerEvent: !1,
      PopStateEvent: !1,
      postMessage: !1,
      Presentation: !1,
      PresentationAvailability: !1,
      PresentationConnection: !1,
      PresentationConnectionAvailableEvent: !1,
      PresentationConnectionCloseEvent: !1,
      PresentationConnectionList: !1,
      PresentationReceiver: !1,
      PresentationRequest: !1,
      print: !1,
      ProcessingInstruction: !1,
      ProgressEvent: !1,
      PromiseRejectionEvent: !1,
      prompt: !1,
      PushManager: !1,
      PushSubscription: !1,
      PushSubscriptionOptions: !1,
      queueMicrotask: !1,
      RadioNodeList: !1,
      Range: !1,
      ReadableStream: !1,
      registerProcessor: !1,
      RemotePlayback: !1,
      removeEventListener: !1,
      Request: !1,
      requestAnimationFrame: !1,
      requestIdleCallback: !1,
      resizeBy: !1,
      ResizeObserver: !1,
      ResizeObserverEntry: !1,
      resizeTo: !1,
      Response: !1,
      RTCCertificate: !1,
      RTCDataChannel: !1,
      RTCDataChannelEvent: !1,
      RTCDtlsTransport: !1,
      RTCIceCandidate: !1,
      RTCIceGatherer: !1,
      RTCIceTransport: !1,
      RTCPeerConnection: !1,
      RTCPeerConnectionIceEvent: !1,
      RTCRtpContributingSource: !1,
      RTCRtpReceiver: !1,
      RTCRtpSender: !1,
      RTCSctpTransport: !1,
      RTCSessionDescription: !1,
      RTCStatsReport: !1,
      RTCTrackEvent: !1,
      screen: !1,
      Screen: !1,
      screenLeft: !1,
      ScreenOrientation: !1,
      screenTop: !1,
      screenX: !1,
      screenY: !1,
      ScriptProcessorNode: !1,
      scroll: !1,
      scrollbars: !1,
      scrollBy: !1,
      scrollTo: !1,
      scrollX: !1,
      scrollY: !1,
      SecurityPolicyViolationEvent: !1,
      Selection: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerRegistration: !1,
      sessionStorage: !1,
      setInterval: !1,
      setTimeout: !1,
      ShadowRoot: !1,
      SharedWorker: !1,
      SourceBuffer: !1,
      SourceBufferList: !1,
      speechSynthesis: !1,
      SpeechSynthesisEvent: !1,
      SpeechSynthesisUtterance: !1,
      StaticRange: !1,
      status: !1,
      statusbar: !1,
      StereoPannerNode: !1,
      stop: !1,
      Storage: !1,
      StorageEvent: !1,
      StorageManager: !1,
      styleMedia: !1,
      StyleSheet: !1,
      StyleSheetList: !1,
      SubtleCrypto: !1,
      SVGAElement: !1,
      SVGAngle: !1,
      SVGAnimatedAngle: !1,
      SVGAnimatedBoolean: !1,
      SVGAnimatedEnumeration: !1,
      SVGAnimatedInteger: !1,
      SVGAnimatedLength: !1,
      SVGAnimatedLengthList: !1,
      SVGAnimatedNumber: !1,
      SVGAnimatedNumberList: !1,
      SVGAnimatedPreserveAspectRatio: !1,
      SVGAnimatedRect: !1,
      SVGAnimatedString: !1,
      SVGAnimatedTransformList: !1,
      SVGAnimateElement: !1,
      SVGAnimateMotionElement: !1,
      SVGAnimateTransformElement: !1,
      SVGAnimationElement: !1,
      SVGCircleElement: !1,
      SVGClipPathElement: !1,
      SVGComponentTransferFunctionElement: !1,
      SVGDefsElement: !1,
      SVGDescElement: !1,
      SVGDiscardElement: !1,
      SVGElement: !1,
      SVGEllipseElement: !1,
      SVGFEBlendElement: !1,
      SVGFEColorMatrixElement: !1,
      SVGFEComponentTransferElement: !1,
      SVGFECompositeElement: !1,
      SVGFEConvolveMatrixElement: !1,
      SVGFEDiffuseLightingElement: !1,
      SVGFEDisplacementMapElement: !1,
      SVGFEDistantLightElement: !1,
      SVGFEDropShadowElement: !1,
      SVGFEFloodElement: !1,
      SVGFEFuncAElement: !1,
      SVGFEFuncBElement: !1,
      SVGFEFuncGElement: !1,
      SVGFEFuncRElement: !1,
      SVGFEGaussianBlurElement: !1,
      SVGFEImageElement: !1,
      SVGFEMergeElement: !1,
      SVGFEMergeNodeElement: !1,
      SVGFEMorphologyElement: !1,
      SVGFEOffsetElement: !1,
      SVGFEPointLightElement: !1,
      SVGFESpecularLightingElement: !1,
      SVGFESpotLightElement: !1,
      SVGFETileElement: !1,
      SVGFETurbulenceElement: !1,
      SVGFilterElement: !1,
      SVGForeignObjectElement: !1,
      SVGGElement: !1,
      SVGGeometryElement: !1,
      SVGGradientElement: !1,
      SVGGraphicsElement: !1,
      SVGImageElement: !1,
      SVGLength: !1,
      SVGLengthList: !1,
      SVGLinearGradientElement: !1,
      SVGLineElement: !1,
      SVGMarkerElement: !1,
      SVGMaskElement: !1,
      SVGMatrix: !1,
      SVGMetadataElement: !1,
      SVGMPathElement: !1,
      SVGNumber: !1,
      SVGNumberList: !1,
      SVGPathElement: !1,
      SVGPatternElement: !1,
      SVGPoint: !1,
      SVGPointList: !1,
      SVGPolygonElement: !1,
      SVGPolylineElement: !1,
      SVGPreserveAspectRatio: !1,
      SVGRadialGradientElement: !1,
      SVGRect: !1,
      SVGRectElement: !1,
      SVGScriptElement: !1,
      SVGSetElement: !1,
      SVGStopElement: !1,
      SVGStringList: !1,
      SVGStyleElement: !1,
      SVGSVGElement: !1,
      SVGSwitchElement: !1,
      SVGSymbolElement: !1,
      SVGTextContentElement: !1,
      SVGTextElement: !1,
      SVGTextPathElement: !1,
      SVGTextPositioningElement: !1,
      SVGTitleElement: !1,
      SVGTransform: !1,
      SVGTransformList: !1,
      SVGTSpanElement: !1,
      SVGUnitTypes: !1,
      SVGUseElement: !1,
      SVGViewElement: !1,
      TaskAttributionTiming: !1,
      Text: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      TextEvent: !1,
      TextMetrics: !1,
      TextTrack: !1,
      TextTrackCue: !1,
      TextTrackCueList: !1,
      TextTrackList: !1,
      TimeRanges: !1,
      toolbar: !1,
      top: !1,
      Touch: !1,
      TouchEvent: !1,
      TouchList: !1,
      TrackEvent: !1,
      TransitionEvent: !1,
      TreeWalker: !1,
      UIEvent: !1,
      URL: !1,
      URLSearchParams: !1,
      ValidityState: !1,
      visualViewport: !1,
      VisualViewport: !1,
      VTTCue: !1,
      WaveShaperNode: !1,
      WebAssembly: !1,
      WebGL2RenderingContext: !1,
      WebGLActiveInfo: !1,
      WebGLBuffer: !1,
      WebGLContextEvent: !1,
      WebGLFramebuffer: !1,
      WebGLProgram: !1,
      WebGLQuery: !1,
      WebGLRenderbuffer: !1,
      WebGLRenderingContext: !1,
      WebGLSampler: !1,
      WebGLShader: !1,
      WebGLShaderPrecisionFormat: !1,
      WebGLSync: !1,
      WebGLTexture: !1,
      WebGLTransformFeedback: !1,
      WebGLUniformLocation: !1,
      WebGLVertexArrayObject: !1,
      WebSocket: !1,
      WheelEvent: !1,
      window: !1,
      Window: !1,
      Worker: !1,
      WritableStream: !1,
      XMLDocument: !1,
      XMLHttpRequest: !1,
      XMLHttpRequestEventTarget: !1,
      XMLHttpRequestUpload: !1,
      XMLSerializer: !1,
      XPathEvaluator: !1,
      XPathExpression: !1,
      XPathResult: !1,
      XSLTProcessor: !1
    },
    worker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      clearInterval: !1,
      clearTimeout: !1,
      close: !0,
      console: !1,
      fetch: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !0,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onoffline: !0,
      ononline: !0,
      onrejectionhandled: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !0,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    node: {
      __dirname: !1,
      __filename: !1,
      Buffer: !1,
      clearImmediate: !1,
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      exports: !0,
      global: !1,
      Intl: !1,
      module: !1,
      process: !1,
      queueMicrotask: !1,
      require: !1,
      setImmediate: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1
    },
    commonjs: {
      exports: !0,
      global: !1,
      module: !1,
      require: !1
    },
    amd: {
      define: !1,
      require: !1
    },
    mocha: {
      after: !1,
      afterEach: !1,
      before: !1,
      beforeEach: !1,
      context: !1,
      describe: !1,
      it: !1,
      mocha: !1,
      run: !1,
      setup: !1,
      specify: !1,
      suite: !1,
      suiteSetup: !1,
      suiteTeardown: !1,
      teardown: !1,
      test: !1,
      xcontext: !1,
      xdescribe: !1,
      xit: !1,
      xspecify: !1
    },
    jasmine: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fail: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jasmine: !1,
      pending: !1,
      runs: !1,
      spyOn: !1,
      spyOnProperty: !1,
      waits: !1,
      waitsFor: !1,
      xdescribe: !1,
      xit: !1
    },
    jest: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jest: !1,
      pit: !1,
      require: !1,
      test: !1,
      xdescribe: !1,
      xit: !1,
      xtest: !1
    },
    qunit: {
      asyncTest: !1,
      deepEqual: !1,
      equal: !1,
      expect: !1,
      module: !1,
      notDeepEqual: !1,
      notEqual: !1,
      notOk: !1,
      notPropEqual: !1,
      notStrictEqual: !1,
      ok: !1,
      propEqual: !1,
      QUnit: !1,
      raises: !1,
      start: !1,
      stop: !1,
      strictEqual: !1,
      test: !1,
      throws: !1
    },
    phantomjs: {
      console: !0,
      exports: !0,
      phantom: !0,
      require: !0,
      WebPage: !0
    },
    couch: {
      emit: !1,
      exports: !1,
      getRow: !1,
      log: !1,
      module: !1,
      provides: !1,
      require: !1,
      respond: !1,
      send: !1,
      start: !1,
      sum: !1
    },
    rhino: {
      defineClass: !1,
      deserialize: !1,
      gc: !1,
      help: !1,
      importClass: !1,
      importPackage: !1,
      java: !1,
      load: !1,
      loadClass: !1,
      Packages: !1,
      print: !1,
      quit: !1,
      readFile: !1,
      readUrl: !1,
      runCommand: !1,
      seal: !1,
      serialize: !1,
      spawn: !1,
      sync: !1,
      toint32: !1,
      version: !1
    },
    nashorn: {
      __DIR__: !1,
      __FILE__: !1,
      __LINE__: !1,
      com: !1,
      edu: !1,
      exit: !1,
      java: !1,
      Java: !1,
      javafx: !1,
      JavaImporter: !1,
      javax: !1,
      JSAdapter: !1,
      load: !1,
      loadWithNewGlobal: !1,
      org: !1,
      Packages: !1,
      print: !1,
      quit: !1
    },
    wsh: {
      ActiveXObject: !0,
      Enumerator: !0,
      GetObject: !0,
      ScriptEngine: !0,
      ScriptEngineBuildVersion: !0,
      ScriptEngineMajorVersion: !0,
      ScriptEngineMinorVersion: !0,
      VBArray: !0,
      WScript: !0,
      WSH: !0,
      XDomainRequest: !0
    },
    jquery: {
      $: !1,
      jQuery: !1
    },
    yui: {
      YAHOO: !1,
      YAHOO_config: !1,
      YUI: !1,
      YUI_config: !1
    },
    shelljs: {
      cat: !1,
      cd: !1,
      chmod: !1,
      config: !1,
      cp: !1,
      dirs: !1,
      echo: !1,
      env: !1,
      error: !1,
      exec: !1,
      exit: !1,
      find: !1,
      grep: !1,
      ln: !1,
      ls: !1,
      mkdir: !1,
      mv: !1,
      popd: !1,
      pushd: !1,
      pwd: !1,
      rm: !1,
      sed: !1,
      set: !1,
      target: !1,
      tempdir: !1,
      test: !1,
      touch: !1,
      which: !1
    },
    prototypejs: {
      $: !1,
      $$: !1,
      $A: !1,
      $break: !1,
      $continue: !1,
      $F: !1,
      $H: !1,
      $R: !1,
      $w: !1,
      Abstract: !1,
      Ajax: !1,
      Autocompleter: !1,
      Builder: !1,
      Class: !1,
      Control: !1,
      Draggable: !1,
      Draggables: !1,
      Droppables: !1,
      Effect: !1,
      Element: !1,
      Enumerable: !1,
      Event: !1,
      Field: !1,
      Form: !1,
      Hash: !1,
      Insertion: !1,
      ObjectRange: !1,
      PeriodicalExecuter: !1,
      Position: !1,
      Prototype: !1,
      Scriptaculous: !1,
      Selector: !1,
      Sortable: !1,
      SortableObserver: !1,
      Sound: !1,
      Template: !1,
      Toggle: !1,
      Try: !1
    },
    meteor: {
      _: !1,
      $: !1,
      Accounts: !1,
      AccountsClient: !1,
      AccountsCommon: !1,
      AccountsServer: !1,
      App: !1,
      Assets: !1,
      Blaze: !1,
      check: !1,
      Cordova: !1,
      DDP: !1,
      DDPRateLimiter: !1,
      DDPServer: !1,
      Deps: !1,
      EJSON: !1,
      Email: !1,
      HTTP: !1,
      Log: !1,
      Match: !1,
      Meteor: !1,
      Mongo: !1,
      MongoInternals: !1,
      Npm: !1,
      Package: !1,
      Plugin: !1,
      process: !1,
      Random: !1,
      ReactiveDict: !1,
      ReactiveVar: !1,
      Router: !1,
      ServiceConfiguration: !1,
      Session: !1,
      share: !1,
      Spacebars: !1,
      Template: !1,
      Tinytest: !1,
      Tracker: !1,
      UI: !1,
      Utils: !1,
      WebApp: !1,
      WebAppInternals: !1
    },
    mongo: {
      _isWindows: !1,
      _rand: !1,
      BulkWriteResult: !1,
      cat: !1,
      cd: !1,
      connect: !1,
      db: !1,
      getHostName: !1,
      getMemInfo: !1,
      hostname: !1,
      ISODate: !1,
      listFiles: !1,
      load: !1,
      ls: !1,
      md5sumFile: !1,
      mkdir: !1,
      Mongo: !1,
      NumberInt: !1,
      NumberLong: !1,
      ObjectId: !1,
      PlanCache: !1,
      print: !1,
      printjson: !1,
      pwd: !1,
      quit: !1,
      removeFile: !1,
      rs: !1,
      sh: !1,
      UUID: !1,
      version: !1,
      WriteResult: !1
    },
    applescript: {
      $: !1,
      Application: !1,
      Automation: !1,
      console: !1,
      delay: !1,
      Library: !1,
      ObjC: !1,
      ObjectSpecifier: !1,
      Path: !1,
      Progress: !1,
      Ref: !1
    },
    serviceworker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      clearInterval: !1,
      clearTimeout: !1,
      Client: !1,
      clients: !1,
      Clients: !1,
      close: !0,
      console: !1,
      ExtendableEvent: !1,
      ExtendableMessageEvent: !1,
      fetch: !1,
      FetchEvent: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !1,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onfetch: !0,
      oninstall: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onmessageerror: !0,
      onnotificationclick: !0,
      onnotificationclose: !0,
      onoffline: !0,
      ononline: !0,
      onpush: !0,
      onpushsubscriptionchange: !0,
      onrejectionhandled: !0,
      onsync: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      registration: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerGlobalScope: !1,
      ServiceWorkerMessageEvent: !1,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      skipWaiting: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      WindowClient: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    atomtest: {
      advanceClock: !1,
      fakeClearInterval: !1,
      fakeClearTimeout: !1,
      fakeSetInterval: !1,
      fakeSetTimeout: !1,
      resetTimeouts: !1,
      waitsForPromise: !1
    },
    embertest: {
      andThen: !1,
      click: !1,
      currentPath: !1,
      currentRouteName: !1,
      currentURL: !1,
      fillIn: !1,
      find: !1,
      findAll: !1,
      findWithAssert: !1,
      keyEvent: !1,
      pauseTest: !1,
      resumeTest: !1,
      triggerEvent: !1,
      visit: !1,
      wait: !1
    },
    protractor: {
      $: !1,
      $$: !1,
      browser: !1,
      by: !1,
      By: !1,
      DartObject: !1,
      element: !1,
      protractor: !1
    },
    "shared-node-browser": {
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      setInterval: !1,
      setTimeout: !1,
      URL: !1,
      URLSearchParams: !1
    },
    webextensions: {
      browser: !1,
      chrome: !1,
      opr: !1
    },
    greasemonkey: {
      cloneInto: !1,
      createObjectIn: !1,
      exportFunction: !1,
      GM: !1,
      GM_addStyle: !1,
      GM_deleteValue: !1,
      GM_getResourceText: !1,
      GM_getResourceURL: !1,
      GM_getValue: !1,
      GM_info: !1,
      GM_listValues: !1,
      GM_log: !1,
      GM_openInTab: !1,
      GM_registerMenuCommand: !1,
      GM_setClipboard: !1,
      GM_setValue: !1,
      GM_xmlhttpRequest: !1,
      unsafeWindow: !1
    },
    devtools: {
      $: !1,
      $_: !1,
      $$: !1,
      $0: !1,
      $1: !1,
      $2: !1,
      $3: !1,
      $4: !1,
      $x: !1,
      chrome: !1,
      clear: !1,
      copy: !1,
      debug: !1,
      dir: !1,
      dirxml: !1,
      getEventListeners: !1,
      inspect: !1,
      keys: !1,
      monitor: !1,
      monitorEvents: !1,
      profile: !1,
      profileEnd: !1,
      queryObjects: !1,
      table: !1,
      undebug: !1,
      unmonitor: !1,
      unmonitorEvents: !1,
      values: !1
    }
  };
});

// ../node_modules/@babel/traverse/node_modules/globals/index.js
var Jd = v((RZ, Xd) => {
  "use strict";
  Xd.exports = Yd();
});

// ../node_modules/@babel/traverse/lib/scope/index.js
var lu = v((wn) => {
  "use strict";
  Object.defineProperty(wn, "__esModule", {
    value: !0
  });
  wn.default = void 0;
  var c8 = Kd(), p8 = Br(), f8 = Wd(), h8 = Jd(), im = le(), d8 = im, $d = Lr(), m8 = Zi(), {
    NOT_LOCAL_BINDING: Hd,
    callExpression: Gd,
    cloneNode: zd,
    getBindingIdentifiers: y8,
    identifier: ui,
    isArrayExpression: Qd,
    isBinary: T8,
    isCallExpression: Zd,
    isClass: g8,
    isClassBody: b8,
    isClassDeclaration: S8,
    isExportAllDeclaration: sm,
    isExportDefaultDeclaration: x8,
    isExportNamedDeclaration: nu,
    isFunctionDeclaration: E8,
    isIdentifier: Fr,
    isImportDeclaration: au,
    isLiteral: P8,
    isMemberExpression: A8,
    isMethod: v8,
    isModuleSpecifier: C8,
    isNullLiteral: I8,
    isObjectExpression: w8,
    isProperty: O8,
    isPureish: N8,
    isRegExpLiteral: _8,
    isSuper: D8,
    isTaggedTemplateExpression: k8,
    isTemplateLiteral: nm,
    isThisExpression: em,
    isUnaryExpression: L8,
    isVariableDeclaration: M8,
    matchesPattern: tm,
    memberExpression: ou,
    numericLiteral: F8,
    toIdentifier: B8,
    variableDeclaration: j8,
    variableDeclarator: R8,
    isRecordExpression: q8,
    isTupleExpression: V8,
    isObjectProperty: U8,
    isTopicReference: rm,
    isMetaProperty: K8,
    isPrivateName: W8,
    isExportDeclaration: Y8,
    buildUndefinedNode: X8
  } = im;
  function Le(e, t) {
    switch (e?.type) {
      default:
        if (au(e) || Y8(e)) {
          var r;
          if ((sm(e) || nu(e) || au(e)) && e.source)
            Le(e.source, t);
          else if ((nu(e) || au(e)) && (r = e.specifiers) != null && r.length)
            for (let i of e.specifiers) Le(i, t);
          else (x8(e) || nu(e)) && e.declaration && Le(e.declaration, t);
        } else C8(e) ? Le(e.local, t) : P8(e) && !I8(e) && !_8(e) && !nm(e) && t.push(e.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        Le(e.object, t), Le(e.property, t);
        break;
      case "Identifier":
      case "JSXIdentifier":
        t.push(e.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        Le(e.callee, t);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let i of e.properties)
          Le(i, t);
        break;
      case "SpreadElement":
      case "RestElement":
        Le(e.argument, t);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        Le(e.key, t);
        break;
      case "ThisExpression":
        t.push("this");
        break;
      case "Super":
        t.push("super");
        break;
      case "Import":
        t.push("import");
        break;
      case "DoExpression":
        t.push("do");
        break;
      case "YieldExpression":
        t.push("yield"), Le(e.argument, t);
        break;
      case "AwaitExpression":
        t.push("await"), Le(e.argument, t);
        break;
      case "AssignmentExpression":
        Le(e.left, t);
        break;
      case "VariableDeclarator":
        Le(e.id, t);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        Le(e.id, t);
        break;
      case "PrivateName":
        Le(e.id, t);
        break;
      case "ParenthesizedExpression":
        Le(e.expression, t);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        Le(e.argument, t);
        break;
      case "MetaProperty":
        Le(e.meta, t), Le(e.property, t);
        break;
      case "JSXElement":
        Le(e.openingElement, t);
        break;
      case "JSXOpeningElement":
        Le(e.name, t);
        break;
      case "JSXFragment":
        Le(e.openingFragment, t);
        break;
      case "JSXOpeningFragment":
        t.push("Fragment");
        break;
      case "JSXNamespacedName":
        Le(e.namespace, t), Le(e.name, t);
        break;
    }
  }
  s(Le, "gatherNodeParts");
  var In = {
    ForStatement(e) {
      let t = e.get("init");
      if (t.isVar()) {
        let {
          scope: r
        } = e;
        (r.getFunctionParent() || r.getProgramParent()).registerBinding("var", t);
      }
    },
    Declaration(e) {
      if (e.isBlockScoped() || e.isImportDeclaration() || e.isExportDeclaration()) return;
      (e.scope.getFunctionParent() || e.scope.getProgramParent()).registerDeclaration(e);
    },
    ImportDeclaration(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    ReferencedIdentifier(e, t) {
      t.references.push(e);
    },
    ForXStatement(e, t) {
      let r = e.get("left");
      if (r.isPattern() || r.isIdentifier())
        t.constantViolations.push(e);
      else if (r.isVar()) {
        let {
          scope: i
        } = e;
        (i.getFunctionParent() || i.getProgramParent()).registerBinding("var", r);
      }
    },
    ExportDeclaration: {
      exit(e) {
        let {
          node: t,
          scope: r
        } = e;
        if (sm(t)) return;
        let i = t.declaration;
        if (S8(i) || E8(i)) {
          let n = i.id;
          if (!n) return;
          let a = r.getBinding(n.name);
          a?.reference(e);
        } else if (M8(i))
          for (let n of i.declarations)
            for (let a of Object.keys(y8(n))) {
              let o = r.getBinding(a);
              o?.reference(e);
            }
      }
    },
    LabeledStatement(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    AssignmentExpression(e, t) {
      t.assignments.push(e);
    },
    UpdateExpression(e, t) {
      t.constantViolations.push(e);
    },
    UnaryExpression(e, t) {
      e.node.operator === "delete" && t.constantViolations.push(e);
    },
    BlockScoped(e) {
      let t = e.scope;
      if (t.path === e && (t = t.parent), t.getBlockParent().registerDeclaration(e), e.isClassDeclaration() && e.node.id) {
        let n = e.node.id.name;
        e.scope.bindings[n] = e.scope.parent.getBinding(n);
      }
    },
    CatchClause(e) {
      e.scope.registerBinding("let", e);
    },
    Function(e) {
      let t = e.get("params");
      for (let r of t)
        e.scope.registerBinding("param", r);
      e.isFunctionExpression() && e.has("id") && !e.get("id").node[Hd] && e.scope.registerBinding("local", e.get("id"), e);
    },
    ClassExpression(e) {
      e.has("id") && !e.get("id").node[Hd] && e.scope.registerBinding("local", e);
    }
  }, J8 = 0, es = class e {
    static {
      s(this, "Scope");
    }
    constructor(t) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references =
      void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: r
      } = t, i = $d.scope.get(r);
      if (i?.path === t)
        return i;
      $d.scope.set(r, this), this.uid = J8++, this.block = r, this.path = t, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var t;
      let r, i = this.path;
      do {
        let n = i.key === "key" || i.listKey === "decorators";
        i = i.parentPath, n && i.isMethod() && (i = i.parentPath), i && i.isScope() && (r = i);
      } while (i && !r);
      return (t = r) == null ? void 0 : t.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(t, r, i) {
      (0, p8.default)(t, r, this, i, this.path);
    }
    generateDeclaredUidIdentifier(t) {
      let r = this.generateUidIdentifier(t);
      return this.push({
        id: r
      }), zd(r);
    }
    generateUidIdentifier(t) {
      return ui(this.generateUid(t));
    }
    generateUid(t = "temp") {
      t = B8(t).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let r, i = 1;
      do
        r = this._generateUid(t, i), i++;
      while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r));
      let n = this.getProgramParent();
      return n.references[r] = !0, n.uids[r] = !0, r;
    }
    _generateUid(t, r) {
      let i = t;
      return r > 1 && (i += r), `_${i}`;
    }
    generateUidBasedOnNode(t, r) {
      let i = [];
      Le(t, i);
      let n = i.join("$");
      return n = n.replace(/^_/, "") || r || "ref", this.generateUid(n.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(t, r) {
      return ui(this.generateUidBasedOnNode(t, r));
    }
    isStatic(t) {
      if (em(t) || D8(t) || rm(t))
        return !0;
      if (Fr(t)) {
        let r = this.getBinding(t.name);
        return r ? r.constant : this.hasBinding(t.name);
      }
      return !1;
    }
    maybeGenerateMemoised(t, r) {
      if (this.isStatic(t))
        return null;
      {
        let i = this.generateUidIdentifierBasedOnNode(t);
        return r ? i : (this.push({
          id: i
        }), zd(i));
      }
    }
    checkBlockScopedCollisions(t, r, i, n) {
      if (r === "param" || t.kind === "local") return;
      if (r === "let" || t.kind === "let" || t.kind === "const" || t.kind === "module" || t.kind === "param" && r === "const")
        throw this.hub.buildError(n, `Duplicate declaration "${i}"`, TypeError);
    }
    rename(t, r) {
      let i = this.getBinding(t);
      i && (r || (r = this.generateUidIdentifier(t).name), new c8.default(i, t, r).rename(arguments[2]));
    }
    _renameFromMap(t, r, i, n) {
      t[r] && (t[i] = n, t[r] = null);
    }
    dump() {
      let t = "-".repeat(60);
      console.log(t);
      let r = this;
      do {
        console.log("#", r.block.type);
        for (let i of Object.keys(r.bindings)) {
          let n = r.bindings[i];
          console.log(" -", i, {
            constant: n.constant,
            references: n.references,
            violations: n.constantViolations.length,
            kind: n.kind
          });
        }
      } while (r = r.parent);
      console.log(t);
    }
    toArray(t, r, i) {
      if (Fr(t)) {
        let o = this.getBinding(t.name);
        if (o != null && o.constant && o.path.isGenericType("Array"))
          return t;
      }
      if (Qd(t))
        return t;
      if (Fr(t, {
        name: "arguments"
      }))
        return Gd(ou(ou(ou(ui("Array"), ui("prototype")), ui("slice")), ui("call")), [t]);
      let n, a = [t];
      return r === !0 ? n = "toConsumableArray" : typeof r == "number" ? (a.push(F8(r)), n = "slicedToArray") : n = "toArray", i && (a.unshift(
      this.hub.addHelper(n)), n = "maybeArrayLike"), Gd(this.hub.addHelper(n), a);
    }
    hasLabel(t) {
      return !!this.getLabel(t);
    }
    getLabel(t) {
      return this.labels.get(t);
    }
    registerLabel(t) {
      this.labels.set(t.node.label.name, t);
    }
    registerDeclaration(t) {
      if (t.isLabeledStatement())
        this.registerLabel(t);
      else if (t.isFunctionDeclaration())
        this.registerBinding("hoisted", t.get("id"), t);
      else if (t.isVariableDeclaration()) {
        let r = t.get("declarations"), {
          kind: i
        } = t.node;
        for (let n of r)
          this.registerBinding(i === "using" || i === "await using" ? "const" : i, n);
      } else if (t.isClassDeclaration()) {
        if (t.node.declare) return;
        this.registerBinding("let", t);
      } else if (t.isImportDeclaration()) {
        let r = t.node.importKind === "type" || t.node.importKind === "typeof", i = t.get("specifiers");
        for (let n of i) {
          let a = r || n.isImportSpecifier() && (n.node.importKind === "type" || n.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", n);
        }
      } else if (t.isExportDeclaration()) {
        let r = t.get("declaration");
        (r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) && this.registerDeclaration(r);
      } else
        this.registerBinding("unknown", t);
    }
    buildUndefinedNode() {
      return X8();
    }
    registerConstantViolation(t) {
      let r = t.getBindingIdentifiers();
      for (let n of Object.keys(r)) {
        var i;
        (i = this.getBinding(n)) == null || i.reassign(t);
      }
    }
    registerBinding(t, r, i = r) {
      if (!t) throw new ReferenceError("no `kind`");
      if (r.isVariableDeclaration()) {
        let o = r.get("declarations");
        for (let l of o)
          this.registerBinding(t, l);
        return;
      }
      let n = this.getProgramParent(), a = r.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        n.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, t, o, l);
          }
          u ? this.registerConstantViolation(i) : this.bindings[o] = new f8.default({
            identifier: l,
            scope: this,
            path: i,
            kind: t
          });
        }
      }
    }
    addGlobal(t) {
      this.globals[t.name] = t;
    }
    hasUid(t) {
      let r = this;
      do
        if (r.uids[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasGlobal(t) {
      let r = this;
      do
        if (r.globals[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasReference(t) {
      return !!this.getProgramParent().references[t];
    }
    isPure(t, r) {
      if (Fr(t)) {
        let o = this.getBinding(t.name);
        return o ? r ? o.constant : !0 : !1;
      } else {
        if (em(t) || K8(t) || rm(t) || W8(t))
          return !0;
        if (g8(t)) {
          var i;
          return t.superClass && !this.isPure(t.superClass, r) || ((i = t.decorators) == null ? void 0 : i.length) > 0 ? !1 : this.isPure(t.
          body, r);
        } else if (b8(t)) {
          for (let o of t.body)
            if (!this.isPure(o, r)) return !1;
          return !0;
        } else {
          if (T8(t))
            return this.isPure(t.left, r) && this.isPure(t.right, r);
          if (Qd(t) || V8(t)) {
            for (let o of t.elements)
              if (o !== null && !this.isPure(o, r)) return !1;
            return !0;
          } else if (w8(t) || q8(t)) {
            for (let o of t.properties)
              if (!this.isPure(o, r)) return !1;
            return !0;
          } else if (v8(t)) {
            var n;
            return !(t.computed && !this.isPure(t.key, r) || ((n = t.decorators) == null ? void 0 : n.length) > 0);
          } else if (O8(t)) {
            var a;
            return !(t.computed && !this.isPure(t.key, r) || ((a = t.decorators) == null ? void 0 : a.length) > 0 || (U8(t) || t.static) && t.
            value !== null && !this.isPure(t.value, r));
          } else {
            if (L8(t))
              return this.isPure(t.argument, r);
            if (nm(t)) {
              for (let o of t.expressions)
                if (!this.isPure(o, r)) return !1;
              return !0;
            } else return k8(t) ? tm(t.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(t.quasi, r) : A8(t) ? !t.computed && Fr(t.object) && t.object.name === "Symbol" && Fr(t.property) && t.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : Zd(t) ? tm(t.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && t.arguments.length === 1 && d8.isStringLiteral(t.arguments[0]) : N8(t);
          }
        }
      }
    }
    setData(t, r) {
      return this.data[t] = r;
    }
    getData(t) {
      let r = this;
      do {
        let i = r.data[t];
        if (i != null) return i;
      } while (r = r.parent);
    }
    removeData(t) {
      let r = this;
      do
        r.data[t] != null && (r.data[t] = null);
      while (r = r.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let t = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.
      create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      let r = this.getProgramParent();
      if (r.crawling) return;
      let i = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, t.type !== "Program" && (0, m8.isExplodedVisitor)(In)) {
        for (let a of In.enter)
          a.call(i, t, i);
        let n = In[t.type];
        if (n)
          for (let a of n.enter)
            a.call(i, t, i);
      }
      t.traverse(In, i), this.crawling = !1;
      for (let n of i.assignments) {
        let a = n.getBindingIdentifiers();
        for (let o of Object.keys(a))
          n.scope.getBinding(o) || r.addGlobal(a[o]);
        n.scope.registerConstantViolation(n);
      }
      for (let n of i.references) {
        let a = n.scope.getBinding(n.node.name);
        a ? a.reference(n) : r.addGlobal(n.node);
      }
      for (let n of i.constantViolations)
        n.scope.registerConstantViolation(n);
    }
    push(t) {
      let r = this.path;
      r.isPattern() ? r = this.getPatternParent().path : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path), r.isSwitchStatement() &&
      (r = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: i,
        unique: n,
        kind: a = "var",
        id: o
      } = t;
      if (!i && !n && (a === "var" || a === "let") && r.isFunction() && !r.node.name && Zd(r.parent, {
        callee: r.node
      }) && r.parent.arguments.length <= r.node.params.length && Fr(o)) {
        r.pushContainer("params", o), r.scope.registerBinding("param", r.get("params")[r.node.params.length - 1]);
        return;
      }
      (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), r = r.get("body"));
      let l = t._blockHoist == null ? 2 : t._blockHoist, u = `declaration:${a}:${l}`, c = !n && r.getData(u);
      if (!c) {
        let P = j8(a, []);
        P._blockHoist = l, [c] = r.unshiftContainer("body", [P]), n || r.setData(u, c);
      }
      let p = R8(o, i), g = c.node.declarations.push(p);
      r.scope.registerBinding(a, c.get("declarations")[g - 1]);
    }
    getProgramParent() {
      let t = this;
      do
        if (t.path.isProgram())
          return t;
      while (t = t.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let t = this;
      do
        if (t.path.isFunctionParent())
          return t;
      while (t = t.parent);
      return null;
    }
    getBlockParent() {
      let t = this;
      do
        if (t.path.isBlockParent())
          return t;
      while (t = t.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let t = this;
      do
        if (!t.path.isPattern())
          return t.getBlockParent();
      while (t = t.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let t = /* @__PURE__ */ Object.create(null), r = this;
      do {
        for (let i of Object.keys(r.bindings))
          i in t || (t[i] = r.bindings[i]);
        r = r.parent;
      } while (r);
      return t;
    }
    getAllBindingsOfKind(...t) {
      let r = /* @__PURE__ */ Object.create(null);
      for (let i of t) {
        let n = this;
        do {
          for (let a of Object.keys(n.bindings)) {
            let o = n.bindings[a];
            o.kind === i && (r[a] = o);
          }
          n = n.parent;
        } while (n);
      }
      return r;
    }
    bindingIdentifierEquals(t, r) {
      return this.getBindingIdentifier(t) === r;
    }
    getBinding(t) {
      let r = this, i;
      do {
        let a = r.getOwnBinding(t);
        if (a) {
          var n;
          if (!((n = i) != null && n.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && t === "arguments" && r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
        i = r.path;
      } while (r = r.parent);
    }
    getOwnBinding(t) {
      return this.bindings[t];
    }
    getBindingIdentifier(t) {
      var r;
      return (r = this.getBinding(t)) == null ? void 0 : r.identifier;
    }
    getOwnBindingIdentifier(t) {
      let r = this.bindings[t];
      return r?.identifier;
    }
    hasOwnBinding(t) {
      return !!this.getOwnBinding(t);
    }
    hasBinding(t, r) {
      var i, n, a;
      return t ? !!(this.hasOwnBinding(t) || (typeof r == "boolean" && (r = {
        noGlobals: r
      }), this.parentHasBinding(t, r)) || !((i = r) != null && i.noUids) && this.hasUid(t) || !((n = r) != null && n.noGlobals) && e.globals.
      includes(t) || !((a = r) != null && a.noGlobals) && e.contextVariables.includes(t)) : !1;
    }
    parentHasBinding(t, r) {
      var i;
      return (i = this.parent) == null ? void 0 : i.hasBinding(t, r);
    }
    moveBindingTo(t, r) {
      let i = this.getBinding(t);
      i && (i.scope.removeOwnBinding(t), i.scope = r, r.bindings[t] = i);
    }
    removeOwnBinding(t) {
      delete this.bindings[t];
    }
    removeBinding(t) {
      var r;
      (r = this.getBinding(t)) == null || r.scope.removeOwnBinding(t);
      let i = this;
      do
        i.uids[t] && (i.uids[t] = !1);
      while (i = i.parent);
    }
  };
  wn.default = es;
  es.globals = Object.keys(h8.builtin);
  es.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
});

// ../node_modules/@babel/traverse/lib/path/ancestry.js
var am = v((vt) => {
  "use strict";
  Object.defineProperty(vt, "__esModule", {
    value: !0
  });
  vt.find = z8;
  vt.findParent = G8;
  vt.getAncestry = r9;
  vt.getDeepestCommonAncestorFrom = t9;
  vt.getEarliestCommonAncestorFrom = e9;
  vt.getFunctionParent = Q8;
  vt.getStatementParent = Z8;
  vt.inType = n9;
  vt.isAncestor = i9;
  vt.isDescendant = s9;
  var $8 = le(), {
    VISITOR_KEYS: H8
  } = $8;
  function G8(e) {
    let t = this;
    for (; t = t.parentPath; )
      if (e(t)) return t;
    return null;
  }
  s(G8, "findParent");
  function z8(e) {
    let t = this;
    do
      if (e(t)) return t;
    while (t = t.parentPath);
    return null;
  }
  s(z8, "find");
  function Q8() {
    return this.findParent((e) => e.isFunction());
  }
  s(Q8, "getFunctionParent");
  function Z8() {
    let e = this;
    do {
      if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
        break;
      e = e.parentPath;
    } while (e);
    if (e && (e.isProgram() || e.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return e;
  }
  s(Z8, "getStatementParent");
  function e9(e) {
    return this.getDeepestCommonAncestorFrom(e, function(t, r, i) {
      let n, a = H8[t.type];
      for (let o of i) {
        let l = o[r + 1];
        if (!n) {
          n = l;
          continue;
        }
        if (l.listKey && n.listKey === l.listKey && l.key < n.key) {
          n = l;
          continue;
        }
        let u = a.indexOf(n.parentKey), c = a.indexOf(l.parentKey);
        u > c && (n = l);
      }
      return n;
    });
  }
  s(e9, "getEarliestCommonAncestorFrom");
  function t9(e, t) {
    if (!e.length)
      return this;
    if (e.length === 1)
      return e[0];
    let r = 1 / 0, i, n, a = e.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < r && (r = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < r; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      i = l, n = u;
    }
    if (n)
      return t ? t(n, i, a) : n;
    throw new Error("Couldn't find intersection");
  }
  s(t9, "getDeepestCommonAncestorFrom");
  function r9() {
    let e = this, t = [];
    do
      t.push(e);
    while (e = e.parentPath);
    return t;
  }
  s(r9, "getAncestry");
  function i9(e) {
    return e.isDescendant(this);
  }
  s(i9, "isAncestor");
  function s9(e) {
    return !!this.findParent((t) => t === e);
  }
  s(s9, "isDescendant");
  function n9(...e) {
    let t = this;
    for (; t; ) {
      for (let r of e)
        if (t.node.type === r) return !0;
      t = t.parentPath;
    }
    return !1;
  }
  s(n9, "inType");
});

// ../node_modules/@babel/traverse/lib/path/inference/util.js
var cu = v((uu) => {
  "use strict";
  Object.defineProperty(uu, "__esModule", {
    value: !0
  });
  uu.createUnionType = c9;
  var a9 = le(), {
    createFlowUnionType: om,
    createTSUnionType: lm,
    createUnionTypeAnnotation: o9,
    isFlowType: l9,
    isTSType: u9
  } = a9;
  function c9(e) {
    {
      if (e.every((t) => l9(t)))
        return om ? om(e) : o9(e);
      if (e.every((t) => u9(t)) && lm)
        return lm(e);
    }
  }
  s(c9, "createUnionType");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var hm = v((pu) => {
  "use strict";
  Object.defineProperty(pu, "__esModule", {
    value: !0
  });
  pu.default = m9;
  var p9 = le(), cm = cu(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: f9,
    createTypeAnnotationBasedOnTypeof: h9,
    numberTypeAnnotation: pm,
    voidTypeAnnotation: d9
  } = p9;
  function m9(e) {
    if (!this.isReferenced()) return;
    let t = this.scope.getBinding(e.name);
    if (t)
      return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : y9(t, this, e.name);
    if (e.name === "undefined")
      return d9();
    if (e.name === "NaN" || e.name === "Infinity")
      return pm();
    e.name;
  }
  s(m9, "_default");
  function y9(e, t, r) {
    let i = [], n = [], a = um(e, t, n), o = fm(e, t, r);
    if (o) {
      let l = um(e, o.ifStatement);
      a = a.filter((u) => l.indexOf(u) < 0), i.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...n);
      for (let l of a)
        i.push(l.getTypeAnnotation());
    }
    if (i.length)
      return (0, cm.createUnionType)(i);
  }
  s(y9, "getTypeAnnotationBindingConstantViolations");
  function um(e, t, r) {
    let i = e.constantViolations.slice();
    return i.unshift(e.path), i.filter((n) => {
      n = n.resolve();
      let a = n._guessExecutionStatusRelativeTo(t);
      return r && a === "unknown" && r.push(n), a === "before";
    });
  }
  s(um, "getConstantViolationsBefore");
  function T9(e, t) {
    let r = t.node.operator, i = t.get("right").resolve(), n = t.get("left").resolve(), a;
    if (n.isIdentifier({
      name: e
    }) ? a = i : i.isIdentifier({
      name: e
    }) && (a = n), a)
      return r === "===" ? a.getTypeAnnotation() : f9.indexOf(r) >= 0 ? pm() : void 0;
    if (r !== "===" && r !== "==") return;
    let o, l;
    if (n.isUnaryExpression({
      operator: "typeof"
    }) ? (o = n, l = i) : i.isUnaryExpression({
      operator: "typeof"
    }) && (o = i, l = n), !o || !o.get("argument").isIdentifier({
      name: e
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return h9(u);
  }
  s(T9, "inferAnnotationFromBinaryExpression");
  function g9(e, t, r) {
    let i;
    for (; i = t.parentPath; ) {
      if (i.isIfStatement() || i.isConditionalExpression())
        return t.key === "test" ? void 0 : i;
      if (i.isFunction() && i.parentPath.scope.getBinding(r) !== e)
        return;
      t = i;
    }
  }
  s(g9, "getParentConditionalPath");
  function fm(e, t, r) {
    let i = g9(e, t, r);
    if (!i) return;
    let a = [i.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = T9(r, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, cm.createUnionType)(o),
      ifStatement: i
    } : fm(e, i, r);
  }
  s(fm, "getConditionalAnnotation");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferers.js
var xm = v((Ae) => {
  "use strict";
  Object.defineProperty(Ae, "__esModule", {
    value: !0
  });
  Ae.ArrayExpression = gm;
  Ae.AssignmentExpression = V9;
  Ae.BinaryExpression = F9;
  Ae.BooleanLiteral = Y9;
  Ae.CallExpression = e7;
  Ae.ConditionalExpression = j9;
  Ae.ClassDeclaration = Ae.ClassExpression = Ae.FunctionDeclaration = Ae.ArrowFunctionExpression = Ae.FunctionExpression = H9;
  Object.defineProperty(Ae, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return S9.default;
    }, "get")
  });
  Ae.LogicalExpression = B9;
  Ae.NewExpression = k9;
  Ae.NullLiteral = X9;
  Ae.NumericLiteral = W9;
  Ae.ObjectExpression = $9;
  Ae.ParenthesizedExpression = q9;
  Ae.RegExpLiteral = J9;
  Ae.RestElement = bm;
  Ae.SequenceExpression = R9;
  Ae.StringLiteral = K9;
  Ae.TSAsExpression = Tm;
  Ae.TSNonNullExpression = D9;
  Ae.TaggedTemplateExpression = t7;
  Ae.TemplateLiteral = L9;
  Ae.TypeCastExpression = ym;
  Ae.UnaryExpression = M9;
  Ae.UpdateExpression = U9;
  Ae.VariableDeclarator = _9;
  var b9 = le(), S9 = hm(), mm = cu(), {
    BOOLEAN_BINARY_OPERATORS: x9,
    BOOLEAN_UNARY_OPERATORS: E9,
    NUMBER_BINARY_OPERATORS: P9,
    NUMBER_UNARY_OPERATORS: A9,
    STRING_UNARY_OPERATORS: v9,
    anyTypeAnnotation: dm,
    arrayTypeAnnotation: fu,
    booleanTypeAnnotation: hu,
    buildMatchMemberExpression: On,
    genericTypeAnnotation: pr,
    identifier: jr,
    nullLiteralTypeAnnotation: C9,
    numberTypeAnnotation: ci,
    stringTypeAnnotation: Rr,
    tupleTypeAnnotation: I9,
    unionTypeAnnotation: w9,
    voidTypeAnnotation: O9,
    isIdentifier: N9
  } = b9;
  function _9() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  s(_9, "VariableDeclarator");
  function ym(e) {
    return e.typeAnnotation;
  }
  s(ym, "TypeCastExpression");
  ym.validParent = !0;
  function Tm(e) {
    return e.typeAnnotation;
  }
  s(Tm, "TSAsExpression");
  Tm.validParent = !0;
  function D9() {
    return this.get("expression").getTypeAnnotation();
  }
  s(D9, "TSNonNullExpression");
  function k9(e) {
    if (e.callee.type === "Identifier")
      return pr(e.callee);
  }
  s(k9, "NewExpression");
  function L9() {
    return Rr();
  }
  s(L9, "TemplateLiteral");
  function M9(e) {
    let t = e.operator;
    if (t === "void")
      return O9();
    if (A9.indexOf(t) >= 0)
      return ci();
    if (v9.indexOf(t) >= 0)
      return Rr();
    if (E9.indexOf(t) >= 0)
      return hu();
  }
  s(M9, "UnaryExpression");
  function F9(e) {
    let t = e.operator;
    if (P9.indexOf(t) >= 0)
      return ci();
    if (x9.indexOf(t) >= 0)
      return hu();
    if (t === "+") {
      let r = this.get("right"), i = this.get("left");
      return i.isBaseType("number") && r.isBaseType("number") ? ci() : i.isBaseType("string") || r.isBaseType("string") ? Rr() : w9([Rr(), ci()]);
    }
  }
  s(F9, "BinaryExpression");
  function B9() {
    let e = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, mm.createUnionType)(e);
  }
  s(B9, "LogicalExpression");
  function j9() {
    let e = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, mm.createUnionType)(e);
  }
  s(j9, "ConditionalExpression");
  function R9() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  s(R9, "SequenceExpression");
  function q9() {
    return this.get("expression").getTypeAnnotation();
  }
  s(q9, "ParenthesizedExpression");
  function V9() {
    return this.get("right").getTypeAnnotation();
  }
  s(V9, "AssignmentExpression");
  function U9(e) {
    let t = e.operator;
    if (t === "++" || t === "--")
      return ci();
  }
  s(U9, "UpdateExpression");
  function K9() {
    return Rr();
  }
  s(K9, "StringLiteral");
  function W9() {
    return ci();
  }
  s(W9, "NumericLiteral");
  function Y9() {
    return hu();
  }
  s(Y9, "BooleanLiteral");
  function X9() {
    return C9();
  }
  s(X9, "NullLiteral");
  function J9() {
    return pr(jr("RegExp"));
  }
  s(J9, "RegExpLiteral");
  function $9() {
    return pr(jr("Object"));
  }
  s($9, "ObjectExpression");
  function gm() {
    return pr(jr("Array"));
  }
  s(gm, "ArrayExpression");
  function bm() {
    return gm();
  }
  s(bm, "RestElement");
  bm.validParent = !0;
  function H9() {
    return pr(jr("Function"));
  }
  s(H9, "Func");
  var G9 = On("Array.from"), z9 = On("Object.keys"), Q9 = On("Object.values"), Z9 = On("Object.entries");
  function e7() {
    let {
      callee: e
    } = this.node;
    return z9(e) ? fu(Rr()) : G9(e) || Q9(e) || N9(e, {
      name: "Array"
    }) ? fu(dm()) : Z9(e) ? fu(I9([Rr(), dm()])) : Sm(this.get("callee"));
  }
  s(e7, "CallExpression");
  function t7() {
    return Sm(this.get("tag"));
  }
  s(t7, "TaggedTemplateExpression");
  function Sm(e) {
    if (e = e.resolve(), e.isFunction()) {
      let {
        node: t
      } = e;
      if (t.async)
        return t.generator ? pr(jr("AsyncIterator")) : pr(jr("Promise"));
      if (t.generator)
        return pr(jr("Iterator"));
      if (e.node.returnType)
        return e.node.returnType;
    }
  }
  s(Sm, "resolveCall");
});

// ../node_modules/@babel/traverse/lib/path/inference/index.js
var vm = v((fr) => {
  "use strict";
  Object.defineProperty(fr, "__esModule", {
    value: !0
  });
  fr._getTypeAnnotation = x7;
  fr.baseTypeStrictlyMatches = A7;
  fr.couldBeBaseType = P7;
  fr.getTypeAnnotation = S7;
  fr.isBaseType = E7;
  fr.isGenericType = v7;
  var Em = xm(), r7 = le(), {
    anyTypeAnnotation: Am,
    isAnyTypeAnnotation: Nn,
    isArrayTypeAnnotation: i7,
    isBooleanTypeAnnotation: s7,
    isEmptyTypeAnnotation: n7,
    isFlowBaseAnnotation: a7,
    isGenericTypeAnnotation: o7,
    isIdentifier: Pm,
    isMixedTypeAnnotation: l7,
    isNumberTypeAnnotation: u7,
    isStringTypeAnnotation: c7,
    isTSArrayType: p7,
    isTSTypeAnnotation: f7,
    isTSTypeReference: h7,
    isTupleTypeAnnotation: d7,
    isTypeAnnotation: m7,
    isUnionTypeAnnotation: y7,
    isVoidTypeAnnotation: T7,
    stringTypeAnnotation: g7,
    voidTypeAnnotation: b7
  } = r7;
  function S7() {
    let e = this.getData("typeAnnotation");
    return e != null || (e = this._getTypeAnnotation() || Am(), (m7(e) || f7(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)),
    e;
  }
  s(S7, "getTypeAnnotation");
  var du = /* @__PURE__ */ new WeakSet();
  function x7() {
    let e = this.node;
    if (!e)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let r = this.parentPath.parentPath, i = r.parentPath;
        return r.key === "left" && i.isForInStatement() ? g7() : r.key === "left" && i.isForOfStatement() ? Am() : b7();
      } else
        return;
    if (e.typeAnnotation)
      return e.typeAnnotation;
    if (!du.has(e)) {
      du.add(e);
      try {
        var t;
        let r = Em[e.type];
        if (r)
          return r.call(this, e);
        if (r = Em[this.parentPath.type], (t = r) != null && t.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        du.delete(e);
      }
    }
  }
  s(x7, "_getTypeAnnotation");
  function E7(e, t) {
    return mu(e, this.getTypeAnnotation(), t);
  }
  s(E7, "isBaseType");
  function mu(e, t, r) {
    if (e === "string")
      return c7(t);
    if (e === "number")
      return u7(t);
    if (e === "boolean")
      return s7(t);
    if (e === "any")
      return Nn(t);
    if (e === "mixed")
      return l7(t);
    if (e === "empty")
      return n7(t);
    if (e === "void")
      return T7(t);
    if (r)
      return !1;
    throw new Error(`Unknown base type ${e}`);
  }
  s(mu, "_isBaseType");
  function P7(e) {
    let t = this.getTypeAnnotation();
    if (Nn(t)) return !0;
    if (y7(t)) {
      for (let r of t.types)
        if (Nn(r) || mu(e, r, !0))
          return !0;
      return !1;
    } else
      return mu(e, t, !0);
  }
  s(P7, "couldBeBaseType");
  function A7(e) {
    let t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
    return !Nn(t) && a7(t) ? r.type === t.type : !1;
  }
  s(A7, "baseTypeStrictlyMatches");
  function v7(e) {
    let t = this.getTypeAnnotation();
    return e === "Array" && (p7(t) || i7(t) || d7(t)) ? !0 : o7(t) && Pm(t.id, {
      name: e
    }) || h7(t) && Pm(t.typeName, {
      name: e
    });
  }
  s(v7, "isGenericType");
});

// ../node_modules/js-tokens/index.js
var Cm = v((_n) => {
  Object.defineProperty(_n, "__esModule", {
    value: !0
  });
  _n.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  _n.matchToToken = function(e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) :
    e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "white\
space"), t;
  };
});

// ../node_modules/picocolors/picocolors.js
var Tu = v((ZZ, yu) => {
  var C7 = Gr("tty"), I7 = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.
  includes("--color") || process.platform === "win32" || C7.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env), je = /* @__PURE__ */ s(
  (e, t, r = e) => (i) => {
    let n = "" + i, a = n.indexOf(t, e.length);
    return ~a ? e + Im(n, t, r, a) + t : e + n + t;
  }, "formatter"), Im = /* @__PURE__ */ s((e, t, r, i) => {
    let n = e.substring(0, i) + r, a = e.substring(i + t.length), o = a.indexOf(t);
    return ~o ? n + Im(a, t, r, o) : n + a;
  }, "replaceClose"), wm = /* @__PURE__ */ s((e = I7) => ({
    isColorSupported: e,
    reset: e ? (t) => `\x1B[0m${t}\x1B[0m` : String,
    bold: e ? je("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
    dim: e ? je("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
    italic: e ? je("\x1B[3m", "\x1B[23m") : String,
    underline: e ? je("\x1B[4m", "\x1B[24m") : String,
    inverse: e ? je("\x1B[7m", "\x1B[27m") : String,
    hidden: e ? je("\x1B[8m", "\x1B[28m") : String,
    strikethrough: e ? je("\x1B[9m", "\x1B[29m") : String,
    black: e ? je("\x1B[30m", "\x1B[39m") : String,
    red: e ? je("\x1B[31m", "\x1B[39m") : String,
    green: e ? je("\x1B[32m", "\x1B[39m") : String,
    yellow: e ? je("\x1B[33m", "\x1B[39m") : String,
    blue: e ? je("\x1B[34m", "\x1B[39m") : String,
    magenta: e ? je("\x1B[35m", "\x1B[39m") : String,
    cyan: e ? je("\x1B[36m", "\x1B[39m") : String,
    white: e ? je("\x1B[37m", "\x1B[39m") : String,
    gray: e ? je("\x1B[90m", "\x1B[39m") : String,
    bgBlack: e ? je("\x1B[40m", "\x1B[49m") : String,
    bgRed: e ? je("\x1B[41m", "\x1B[49m") : String,
    bgGreen: e ? je("\x1B[42m", "\x1B[49m") : String,
    bgYellow: e ? je("\x1B[43m", "\x1B[49m") : String,
    bgBlue: e ? je("\x1B[44m", "\x1B[49m") : String,
    bgMagenta: e ? je("\x1B[45m", "\x1B[49m") : String,
    bgCyan: e ? je("\x1B[46m", "\x1B[49m") : String,
    bgWhite: e ? je("\x1B[47m", "\x1B[49m") : String
  }), "createColors");
  yu.exports = wm();
  yu.exports.createColors = wm;
});

// ../node_modules/escape-string-regexp/index.js
var Nm = v((tee, Om) => {
  "use strict";
  var w7 = /[|\\{}()[\]^$+*?.]/g;
  Om.exports = function(e) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return e.replace(w7, "\\$&");
  };
});

// ../node_modules/@babel/highlight/node_modules/color-name/index.js
var Dm = v((ree, _m) => {
  "use strict";
  _m.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var gu = v((iee, Fm) => {
  var qr = Dm(), Mm = {};
  for (Dn in qr)
    qr.hasOwnProperty(Dn) && (Mm[qr[Dn]] = Dn);
  var Dn, z = Fm.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (pt in z)
    if (z.hasOwnProperty(pt)) {
      if (!("channels" in z[pt]))
        throw new Error("missing channels property: " + pt);
      if (!("labels" in z[pt]))
        throw new Error("missing channel labels property: " + pt);
      if (z[pt].labels.length !== z[pt].channels)
        throw new Error("channel and label counts mismatch: " + pt);
      km = z[pt].channels, Lm = z[pt].labels, delete z[pt].channels, delete z[pt].labels, Object.defineProperty(z[pt], "channels", { value: km }),
      Object.defineProperty(z[pt], "labels", { value: Lm });
    }
  var km, Lm, pt;
  z.rgb.hsl = function(e) {
    var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255, n = Math.min(t, r, i), a = Math.max(t, r, i), o = a - n, l, u, c;
    return a === n ? l = 0 : t === a ? l = (r - i) / o : r === a ? l = 2 + (i - t) / o : i === a && (l = 4 + (t - r) / o), l = Math.min(l * 60,
    360), l < 0 && (l += 360), c = (n + a) / 2, a === n ? u = 0 : c <= 0.5 ? u = o / (a + n) : u = o / (2 - a - n), [l, u * 100, c * 100];
  };
  z.rgb.hsv = function(e) {
    var t, r, i, n, a, o = e[0] / 255, l = e[1] / 255, u = e[2] / 255, c = Math.max(o, l, u), p = c - Math.min(o, l, u), g = /* @__PURE__ */ s(
    function(P) {
      return (c - P) / 6 / p + 1 / 2;
    }, "diffc");
    return p === 0 ? n = a = 0 : (a = p / c, t = g(o), r = g(l), i = g(u), o === c ? n = i - r : l === c ? n = 1 / 3 + t - i : u === c && (n =
    2 / 3 + r - t), n < 0 ? n += 1 : n > 1 && (n -= 1)), [
      n * 360,
      a * 100,
      c * 100
    ];
  };
  z.rgb.hwb = function(e) {
    var t = e[0], r = e[1], i = e[2], n = z.rgb.hsl(e)[0], a = 1 / 255 * Math.min(t, Math.min(r, i));
    return i = 1 - 1 / 255 * Math.max(t, Math.max(r, i)), [n, a * 100, i * 100];
  };
  z.rgb.cmyk = function(e) {
    var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255, n, a, o, l;
    return l = Math.min(1 - t, 1 - r, 1 - i), n = (1 - t - l) / (1 - l) || 0, a = (1 - r - l) / (1 - l) || 0, o = (1 - i - l) / (1 - l) || 0,
    [n * 100, a * 100, o * 100, l * 100];
  };
  function O7(e, t) {
    return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2);
  }
  s(O7, "comparativeDistance");
  z.rgb.keyword = function(e) {
    var t = Mm[e];
    if (t)
      return t;
    var r = 1 / 0, i;
    for (var n in qr)
      if (qr.hasOwnProperty(n)) {
        var a = qr[n], o = O7(e, a);
        o < r && (r = o, i = n);
      }
    return i;
  };
  z.keyword.rgb = function(e) {
    return qr[e];
  };
  z.rgb.xyz = function(e) {
    var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255;
    t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, i = i >
    0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92;
    var n = t * 0.4124 + r * 0.3576 + i * 0.1805, a = t * 0.2126 + r * 0.7152 + i * 0.0722, o = t * 0.0193 + r * 0.1192 + i * 0.9505;
    return [n * 100, a * 100, o * 100];
  };
  z.rgb.lab = function(e) {
    var t = z.rgb.xyz(e), r = t[0], i = t[1], n = t[2], a, o, l;
    return r /= 95.047, i /= 100, n /= 108.883, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 /
    3) : 7.787 * i + 16 / 116, n = n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, a = 116 * i - 16, o = 500 * (r - i), l = 200 * (i -
    n), [a, o, l];
  };
  z.hsl.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, i = e[2] / 100, n, a, o, l, u;
    if (r === 0)
      return u = i * 255, [u, u, u];
    i < 0.5 ? a = i * (1 + r) : a = i + r - i * r, n = 2 * i - a, l = [0, 0, 0];
    for (var c = 0; c < 3; c++)
      o = t + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? u = n + (a - n) * 6 * o : 2 * o < 1 ? u = a : 3 * o < 2 ? u = n + (a -
      n) * (2 / 3 - o) * 6 : u = n, l[c] = u * 255;
    return l;
  };
  z.hsl.hsv = function(e) {
    var t = e[0], r = e[1] / 100, i = e[2] / 100, n = r, a = Math.max(i, 0.01), o, l;
    return i *= 2, r *= i <= 1 ? i : 2 - i, n *= a <= 1 ? a : 2 - a, l = (i + r) / 2, o = i === 0 ? 2 * n / (a + n) : 2 * r / (i + r), [t, o *
    100, l * 100];
  };
  z.hsv.rgb = function(e) {
    var t = e[0] / 60, r = e[1] / 100, i = e[2] / 100, n = Math.floor(t) % 6, a = t - Math.floor(t), o = 255 * i * (1 - r), l = 255 * i * (1 -
    r * a), u = 255 * i * (1 - r * (1 - a));
    switch (i *= 255, n) {
      case 0:
        return [i, u, o];
      case 1:
        return [l, i, o];
      case 2:
        return [o, i, u];
      case 3:
        return [o, l, i];
      case 4:
        return [u, o, i];
      case 5:
        return [i, o, l];
    }
  };
  z.hsv.hsl = function(e) {
    var t = e[0], r = e[1] / 100, i = e[2] / 100, n = Math.max(i, 0.01), a, o, l;
    return l = (2 - r) * i, a = (2 - r) * n, o = r * n, o /= a <= 1 ? a : 2 - a, o = o || 0, l /= 2, [t, o * 100, l * 100];
  };
  z.hwb.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, i = e[2] / 100, n = r + i, a, o, l, u;
    n > 1 && (r /= n, i /= n), a = Math.floor(6 * t), o = 1 - i, l = 6 * t - a, a & 1 && (l = 1 - l), u = r + l * (o - r);
    var c, p, g;
    switch (a) {
      default:
      case 6:
      case 0:
        c = o, p = u, g = r;
        break;
      case 1:
        c = u, p = o, g = r;
        break;
      case 2:
        c = r, p = o, g = u;
        break;
      case 3:
        c = r, p = u, g = o;
        break;
      case 4:
        c = u, p = r, g = o;
        break;
      case 5:
        c = o, p = r, g = u;
        break;
    }
    return [c * 255, p * 255, g * 255];
  };
  z.cmyk.rgb = function(e) {
    var t = e[0] / 100, r = e[1] / 100, i = e[2] / 100, n = e[3] / 100, a, o, l;
    return a = 1 - Math.min(1, t * (1 - n) + n), o = 1 - Math.min(1, r * (1 - n) + n), l = 1 - Math.min(1, i * (1 - n) + n), [a * 255, o * 255,
    l * 255];
  };
  z.xyz.rgb = function(e) {
    var t = e[0] / 100, r = e[1] / 100, i = e[2] / 100, n, a, o;
    return n = t * 3.2406 + r * -1.5372 + i * -0.4986, a = t * -0.9689 + r * 1.8758 + i * 0.0415, o = t * 0.0557 + r * -0.204 + i * 1.057, n =
    n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92, o =
    o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, n = Math.min(Math.max(0, n), 1), a = Math.min(Math.max(0, a), 1), o = Math.
    min(Math.max(0, o), 1), [n * 255, a * 255, o * 255];
  };
  z.xyz.lab = function(e) {
    var t = e[0], r = e[1], i = e[2], n, a, o;
    return t /= 95.047, r /= 100, i /= 108.883, t = t > 8856e-6 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 /
    3) : 7.787 * r + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, n = 116 * r - 16, a = 500 * (t - r), o = 200 * (r -
    i), [n, a, o];
  };
  z.lab.xyz = function(e) {
    var t = e[0], r = e[1], i = e[2], n, a, o;
    a = (t + 16) / 116, n = r / 500 + a, o = a - i / 200;
    var l = Math.pow(a, 3), u = Math.pow(n, 3), c = Math.pow(o, 3);
    return a = l > 8856e-6 ? l : (a - 16 / 116) / 7.787, n = u > 8856e-6 ? u : (n - 16 / 116) / 7.787, o = c > 8856e-6 ? c : (o - 16 / 116) /
    7.787, n *= 95.047, a *= 100, o *= 108.883, [n, a, o];
  };
  z.lab.lch = function(e) {
    var t = e[0], r = e[1], i = e[2], n, a, o;
    return n = Math.atan2(i, r), a = n * 360 / 2 / Math.PI, a < 0 && (a += 360), o = Math.sqrt(r * r + i * i), [t, o, a];
  };
  z.lch.lab = function(e) {
    var t = e[0], r = e[1], i = e[2], n, a, o;
    return o = i / 360 * 2 * Math.PI, n = r * Math.cos(o), a = r * Math.sin(o), [t, n, a];
  };
  z.rgb.ansi16 = function(e) {
    var t = e[0], r = e[1], i = e[2], n = 1 in arguments ? arguments[1] : z.rgb.hsv(e)[2];
    if (n = Math.round(n / 50), n === 0)
      return 30;
    var a = 30 + (Math.round(i / 255) << 2 | Math.round(r / 255) << 1 | Math.round(t / 255));
    return n === 2 && (a += 60), a;
  };
  z.hsv.ansi16 = function(e) {
    return z.rgb.ansi16(z.hsv.rgb(e), e[2]);
  };
  z.rgb.ansi256 = function(e) {
    var t = e[0], r = e[1], i = e[2];
    if (t === r && r === i)
      return t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232;
    var n = 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(i / 255 * 5);
    return n;
  };
  z.ansi16.rgb = function(e) {
    var t = e % 10;
    if (t === 0 || t === 7)
      return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
    var r = (~~(e > 50) + 1) * 0.5, i = (t & 1) * r * 255, n = (t >> 1 & 1) * r * 255, a = (t >> 2 & 1) * r * 255;
    return [i, n, a];
  };
  z.ansi256.rgb = function(e) {
    if (e >= 232) {
      var t = (e - 232) * 10 + 8;
      return [t, t, t];
    }
    e -= 16;
    var r, i = Math.floor(e / 36) / 5 * 255, n = Math.floor((r = e % 36) / 6) / 5 * 255, a = r % 6 / 5 * 255;
    return [i, n, a];
  };
  z.rgb.hex = function(e) {
    var t = ((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255), r = t.toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  };
  z.hex.rgb = function(e) {
    var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t)
      return [0, 0, 0];
    var r = t[0];
    t[0].length === 3 && (r = r.split("").map(function(l) {
      return l + l;
    }).join(""));
    var i = parseInt(r, 16), n = i >> 16 & 255, a = i >> 8 & 255, o = i & 255;
    return [n, a, o];
  };
  z.rgb.hcg = function(e) {
    var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255, n = Math.max(Math.max(t, r), i), a = Math.min(Math.min(t, r), i), o = n - a, l, u;
    return o < 1 ? l = a / (1 - o) : l = 0, o <= 0 ? u = 0 : n === t ? u = (r - i) / o % 6 : n === r ? u = 2 + (i - t) / o : u = 4 + (t - r) /
    o + 4, u /= 6, u %= 1, [u * 360, o * 100, l * 100];
  };
  z.hsl.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = 1, n = 0;
    return r < 0.5 ? i = 2 * t * r : i = 2 * t * (1 - r), i < 1 && (n = (r - 0.5 * i) / (1 - i)), [e[0], i * 100, n * 100];
  };
  z.hsv.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = t * r, n = 0;
    return i < 1 && (n = (r - i) / (1 - i)), [e[0], i * 100, n * 100];
  };
  z.hcg.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, i = e[2] / 100;
    if (r === 0)
      return [i * 255, i * 255, i * 255];
    var n = [0, 0, 0], a = t % 1 * 6, o = a % 1, l = 1 - o, u = 0;
    switch (Math.floor(a)) {
      case 0:
        n[0] = 1, n[1] = o, n[2] = 0;
        break;
      case 1:
        n[0] = l, n[1] = 1, n[2] = 0;
        break;
      case 2:
        n[0] = 0, n[1] = 1, n[2] = o;
        break;
      case 3:
        n[0] = 0, n[1] = l, n[2] = 1;
        break;
      case 4:
        n[0] = o, n[1] = 0, n[2] = 1;
        break;
      default:
        n[0] = 1, n[1] = 0, n[2] = l;
    }
    return u = (1 - r) * i, [
      (r * n[0] + u) * 255,
      (r * n[1] + u) * 255,
      (r * n[2] + u) * 255
    ];
  };
  z.hcg.hsv = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = t + r * (1 - t), n = 0;
    return i > 0 && (n = t / i), [e[0], n * 100, i * 100];
  };
  z.hcg.hsl = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = r * (1 - t) + 0.5 * t, n = 0;
    return i > 0 && i < 0.5 ? n = t / (2 * i) : i >= 0.5 && i < 1 && (n = t / (2 * (1 - i))), [e[0], n * 100, i * 100];
  };
  z.hcg.hwb = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = t + r * (1 - t);
    return [e[0], (i - t) * 100, (1 - i) * 100];
  };
  z.hwb.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, i = 1 - r, n = i - t, a = 0;
    return n < 1 && (a = (i - n) / (1 - n)), [e[0], n * 100, a * 100];
  };
  z.apple.rgb = function(e) {
    return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
  };
  z.rgb.apple = function(e) {
    return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
  };
  z.gray.rgb = function(e) {
    return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
  };
  z.gray.hsl = z.gray.hsv = function(e) {
    return [0, 0, e[0]];
  };
  z.gray.hwb = function(e) {
    return [0, 100, e[0]];
  };
  z.gray.cmyk = function(e) {
    return [0, 0, 0, e[0]];
  };
  z.gray.lab = function(e) {
    return [e[0], 0, 0];
  };
  z.gray.hex = function(e) {
    var t = Math.round(e[0] / 100 * 255) & 255, r = (t << 16) + (t << 8) + t, i = r.toString(16).toUpperCase();
    return "000000".substring(i.length) + i;
  };
  z.rgb.gray = function(e) {
    var t = (e[0] + e[1] + e[2]) / 3;
    return [t / 255 * 100];
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/route.js
var jm = v((nee, Bm) => {
  var kn = gu();
  function N7() {
    for (var e = {}, t = Object.keys(kn), r = t.length, i = 0; i < r; i++)
      e[t[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return e;
  }
  s(N7, "buildGraph");
  function _7(e) {
    var t = N7(), r = [e];
    for (t[e].distance = 0; r.length; )
      for (var i = r.pop(), n = Object.keys(kn[i]), a = n.length, o = 0; o < a; o++) {
        var l = n[o], u = t[l];
        u.distance === -1 && (u.distance = t[i].distance + 1, u.parent = i, r.unshift(l));
      }
    return t;
  }
  s(_7, "deriveBFS");
  function D7(e, t) {
    return function(r) {
      return t(e(r));
    };
  }
  s(D7, "link");
  function k7(e, t) {
    for (var r = [t[e].parent, e], i = kn[t[e].parent][e], n = t[e].parent; t[n].parent; )
      r.unshift(t[n].parent), i = D7(kn[t[n].parent][n], i), n = t[n].parent;
    return i.conversion = r, i;
  }
  s(k7, "wrapConversion");
  Bm.exports = function(e) {
    for (var t = _7(e), r = {}, i = Object.keys(t), n = i.length, a = 0; a < n; a++) {
      var o = i[a], l = t[o];
      l.parent !== null && (r[o] = k7(o, t));
    }
    return r;
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/index.js
var qm = v((oee, Rm) => {
  var bu = gu(), L7 = jm(), pi = {}, M7 = Object.keys(bu);
  function F7(e) {
    var t = /* @__PURE__ */ s(function(r) {
      return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), e(r));
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  s(F7, "wrapRaw");
  function B7(e) {
    var t = /* @__PURE__ */ s(function(r) {
      if (r == null)
        return r;
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
      var i = e(r);
      if (typeof i == "object")
        for (var n = i.length, a = 0; a < n; a++)
          i[a] = Math.round(i[a]);
      return i;
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  s(B7, "wrapRounded");
  M7.forEach(function(e) {
    pi[e] = {}, Object.defineProperty(pi[e], "channels", { value: bu[e].channels }), Object.defineProperty(pi[e], "labels", { value: bu[e].labels });
    var t = L7(e), r = Object.keys(t);
    r.forEach(function(i) {
      var n = t[i];
      pi[e][i] = B7(n), pi[e][i].raw = F7(n);
    });
  });
  Rm.exports = pi;
});

// ../node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var Um = v((uee, Vm) => {
  "use strict";
  var fi = qm(), Ln = /* @__PURE__ */ s((e, t) => function() {
    return `\x1B[${e.apply(fi, arguments) + t}m`;
  }, "wrapAnsi16"), Mn = /* @__PURE__ */ s((e, t) => function() {
    let r = e.apply(fi, arguments);
    return `\x1B[${38 + t};5;${r}m`;
  }, "wrapAnsi256"), Fn = /* @__PURE__ */ s((e, t) => function() {
    let r = e.apply(fi, arguments);
    return `\x1B[${38 + t};2;${r[0]};${r[1]};${r[2]}m`;
  }, "wrapAnsi16m");
  function j7() {
    let e = /* @__PURE__ */ new Map(), t = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    t.color.grey = t.color.gray;
    for (let n of Object.keys(t)) {
      let a = t[n];
      for (let o of Object.keys(a)) {
        let l = a[o];
        t[o] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, a[o] = t[o], e.set(l[0], l[1]);
      }
      Object.defineProperty(t, n, {
        value: a,
        enumerable: !1
      }), Object.defineProperty(t, "codes", {
        value: e,
        enumerable: !1
      });
    }
    let r = /* @__PURE__ */ s((n) => n, "ansi2ansi"), i = /* @__PURE__ */ s((n, a, o) => [n, a, o], "rgb2rgb");
    t.color.close = "\x1B[39m", t.bgColor.close = "\x1B[49m", t.color.ansi = {
      ansi: Ln(r, 0)
    }, t.color.ansi256 = {
      ansi256: Mn(r, 0)
    }, t.color.ansi16m = {
      rgb: Fn(i, 0)
    }, t.bgColor.ansi = {
      ansi: Ln(r, 10)
    }, t.bgColor.ansi256 = {
      ansi256: Mn(r, 10)
    }, t.bgColor.ansi16m = {
      rgb: Fn(i, 10)
    };
    for (let n of Object.keys(fi)) {
      if (typeof fi[n] != "object")
        continue;
      let a = fi[n];
      n === "ansi16" && (n = "ansi"), "ansi16" in a && (t.color.ansi[n] = Ln(a.ansi16, 0), t.bgColor.ansi[n] = Ln(a.ansi16, 10)), "ansi256" in
      a && (t.color.ansi256[n] = Mn(a.ansi256, 0), t.bgColor.ansi256[n] = Mn(a.ansi256, 10)), "rgb" in a && (t.color.ansi16m[n] = Fn(a.rgb, 0),
      t.bgColor.ansi16m[n] = Fn(a.rgb, 10));
    }
    return t;
  }
  s(j7, "assembleStyles");
  Object.defineProperty(Vm, "exports", {
    enumerable: !0,
    get: j7
  });
});

// ../node_modules/@babel/highlight/node_modules/has-flag/index.js
var Wm = v((pee, Km) => {
  "use strict";
  Km.exports = (e, t) => {
    t = t || process.argv;
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", i = t.indexOf(r + e), n = t.indexOf("--");
    return i !== -1 && (n === -1 ? !0 : i < n);
  };
});

// ../node_modules/@babel/highlight/node_modules/supports-color/index.js
var Xm = v((fee, Ym) => {
  "use strict";
  var R7 = Gr("os"), _t = Wm(), it = process.env, hi;
  _t("no-color") || _t("no-colors") || _t("color=false") ? hi = !1 : (_t("color") || _t("colors") || _t("color=true") || _t("color=always")) &&
  (hi = !0);
  "FORCE_COLOR" in it && (hi = it.FORCE_COLOR.length === 0 || parseInt(it.FORCE_COLOR, 10) !== 0);
  function q7(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  s(q7, "translateLevel");
  function V7(e) {
    if (hi === !1)
      return 0;
    if (_t("color=16m") || _t("color=full") || _t("color=truecolor"))
      return 3;
    if (_t("color=256"))
      return 2;
    if (e && !e.isTTY && hi !== !0)
      return 0;
    let t = hi ? 1 : 0;
    if (process.platform === "win32") {
      let r = R7.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 :
      1;
    }
    if ("CI" in it)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((r) => r in it) || it.CI_NAME === "codeship" ? 1 : t;
    if ("TEAMCITY_VERSION" in it)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(it.TEAMCITY_VERSION) ? 1 : 0;
    if (it.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in it) {
      let r = parseInt((it.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (it.TERM_PROGRAM) {
        case "iTerm.app":
          return r >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(it.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(it.TERM) || "COLORTERM" in
    it ? 1 : (it.TERM === "dumb", t);
  }
  s(V7, "supportsColor");
  function Su(e) {
    let t = V7(e);
    return q7(t);
  }
  s(Su, "getSupportLevel");
  Ym.exports = {
    supportsColor: Su,
    stdout: Su(process.stdout),
    stderr: Su(process.stderr)
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/templates.js
var zm = v((dee, Gm) => {
  "use strict";
  var U7 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
  Jm = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, K7 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, W7 = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Y7 = /* @__PURE__ */ new Map(
  [
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function Hm(e) {
    return e[0] === "u" && e.length === 5 || e[0] === "x" && e.length === 3 ? String.fromCharCode(parseInt(e.slice(1), 16)) : Y7.get(e) || e;
  }
  s(Hm, "unescape");
  function X7(e, t) {
    let r = [], i = t.trim().split(/\s*,\s*/g), n;
    for (let a of i)
      if (!isNaN(a))
        r.push(Number(a));
      else if (n = a.match(K7))
        r.push(n[2].replace(W7, (o, l, u) => l ? Hm(l) : u));
      else
        throw new Error(`Invalid Chalk template style argument: ${a} (in style '${e}')`);
    return r;
  }
  s(X7, "parseArguments");
  function J7(e) {
    Jm.lastIndex = 0;
    let t = [], r;
    for (; (r = Jm.exec(e)) !== null; ) {
      let i = r[1];
      if (r[2]) {
        let n = X7(i, r[2]);
        t.push([i].concat(n));
      } else
        t.push([i]);
    }
    return t;
  }
  s(J7, "parseStyle");
  function $m(e, t) {
    let r = {};
    for (let n of t)
      for (let a of n.styles)
        r[a[0]] = n.inverse ? null : a.slice(1);
    let i = e;
    for (let n of Object.keys(r))
      if (Array.isArray(r[n])) {
        if (!(n in i))
          throw new Error(`Unknown Chalk style: ${n}`);
        r[n].length > 0 ? i = i[n].apply(i, r[n]) : i = i[n];
      }
    return i;
  }
  s($m, "buildStyle");
  Gm.exports = (e, t) => {
    let r = [], i = [], n = [];
    if (t.replace(U7, (a, o, l, u, c, p) => {
      if (o)
        n.push(Hm(o));
      else if (u) {
        let g = n.join("");
        n = [], i.push(r.length === 0 ? g : $m(e, r)(g)), r.push({ inverse: l, styles: J7(u) });
      } else if (c) {
        if (r.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        i.push($m(e, r)(n.join(""))), n = [], r.pop();
      } else
        n.push(p);
    }), i.push(n.join("")), r.length > 0) {
      let a = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(a);
    }
    return i.join("");
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/index.js
var ry = v((yee, rs) => {
  "use strict";
  var Eu = Nm(), Xe = Um(), xu = Xm().stdout, $7 = zm(), Zm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith(
  "xterm"), ey = ["ansi", "ansi", "ansi256", "ansi16m"], ty = /* @__PURE__ */ new Set(["gray"]), di = /* @__PURE__ */ Object.create(null);
  function Qm(e, t) {
    t = t || {};
    let r = xu ? xu.level : 0;
    e.level = t.level === void 0 ? r : t.level, e.enabled = "enabled" in t ? t.enabled : e.level > 0;
  }
  s(Qm, "applyOptions");
  function ts(e) {
    if (!this || !(this instanceof ts) || this.template) {
      let t = {};
      return Qm(t, e), t.template = function() {
        let r = [].slice.call(arguments);
        return z7.apply(null, [t.template].concat(r));
      }, Object.setPrototypeOf(t, ts.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = ts, t.template;
    }
    Qm(this, e);
  }
  s(ts, "Chalk");
  Zm && (Xe.blue.open = "\x1B[94m");
  for (let e of Object.keys(Xe))
    Xe[e].closeRe = new RegExp(Eu(Xe[e].close), "g"), di[e] = {
      get() {
        let t = Xe[e];
        return Bn.call(this, this._styles ? this._styles.concat(t) : [t], this._empty, e);
      }
    };
  di.visible = {
    get() {
      return Bn.call(this, this._styles || [], !0, "visible");
    }
  };
  Xe.color.closeRe = new RegExp(Eu(Xe.color.close), "g");
  for (let e of Object.keys(Xe.color.ansi))
    ty.has(e) || (di[e] = {
      get() {
        let t = this.level;
        return function() {
          let i = {
            open: Xe.color[ey[t]][e].apply(null, arguments),
            close: Xe.color.close,
            closeRe: Xe.color.closeRe
          };
          return Bn.call(this, this._styles ? this._styles.concat(i) : [i], this._empty, e);
        };
      }
    });
  Xe.bgColor.closeRe = new RegExp(Eu(Xe.bgColor.close), "g");
  for (let e of Object.keys(Xe.bgColor.ansi)) {
    if (ty.has(e))
      continue;
    let t = "bg" + e[0].toUpperCase() + e.slice(1);
    di[t] = {
      get() {
        let r = this.level;
        return function() {
          let n = {
            open: Xe.bgColor[ey[r]][e].apply(null, arguments),
            close: Xe.bgColor.close,
            closeRe: Xe.bgColor.closeRe
          };
          return Bn.call(this, this._styles ? this._styles.concat(n) : [n], this._empty, e);
        };
      }
    };
  }
  var H7 = Object.defineProperties(() => {
  }, di);
  function Bn(e, t, r) {
    let i = /* @__PURE__ */ s(function() {
      return G7.apply(i, arguments);
    }, "builder");
    i._styles = e, i._empty = t;
    let n = this;
    return Object.defineProperty(i, "level", {
      enumerable: !0,
      get() {
        return n.level;
      },
      set(a) {
        n.level = a;
      }
    }), Object.defineProperty(i, "enabled", {
      enumerable: !0,
      get() {
        return n.enabled;
      },
      set(a) {
        n.enabled = a;
      }
    }), i.hasGrey = this.hasGrey || r === "gray" || r === "grey", i.__proto__ = H7, i;
  }
  s(Bn, "build");
  function G7() {
    let e = arguments, t = e.length, r = String(arguments[0]);
    if (t === 0)
      return "";
    if (t > 1)
      for (let n = 1; n < t; n++)
        r += " " + e[n];
    if (!this.enabled || this.level <= 0 || !r)
      return this._empty ? "" : r;
    let i = Xe.dim.open;
    Zm && this.hasGrey && (Xe.dim.open = "");
    for (let n of this._styles.slice().reverse())
      r = n.open + r.replace(n.closeRe, n.open) + n.close, r = r.replace(/\r?\n/g, `${n.close}$&${n.open}`);
    return Xe.dim.open = i, r;
  }
  s(G7, "applyStyle");
  function z7(e, t) {
    if (!Array.isArray(t))
      return [].slice.call(arguments, 1).join(" ");
    let r = [].slice.call(arguments, 2), i = [t.raw[0]];
    for (let n = 1; n < t.length; n++)
      i.push(String(r[n - 1]).replace(/[{}\\]/g, "\\$&")), i.push(String(t.raw[n]));
    return $7(e, i.join(""));
  }
  s(z7, "chalkTag");
  Object.defineProperties(ts.prototype, di);
  rs.exports = ts();
  rs.exports.supportsColor = xu;
  rs.exports.default = rs.exports;
});

// ../node_modules/@babel/highlight/lib/index.js
var cy = v((is) => {
  "use strict";
  Object.defineProperty(is, "__esModule", {
    value: !0
  });
  is.default = nq;
  is.shouldHighlight = uy;
  var iy = Cm(), sy = Fi(), Au = Q7(Tu(), !0);
  function ay(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (ay = /* @__PURE__ */ s(function(i) {
      return i ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  s(ay, "_getRequireWildcardCache");
  function Q7(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = ay(t);
    if (r && r.has(e)) return r.get(e);
    var i = { __proto__: null }, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var o = n ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(i, a, o) : i[a] = e[a];
    }
    return i.default = e, r && r.set(e, i), i;
  }
  s(Q7, "_interopRequireWildcard");
  var oy = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Au.createColors)(!1) :
  Au.default, ny = /* @__PURE__ */ s((e, t) => (r) => e(t(r)), "compose"), Z7 = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of",
  "set"]);
  function eq(e) {
    return {
      keyword: e.cyan,
      capitalized: e.yellow,
      jsxIdentifier: e.yellow,
      punctuator: e.yellow,
      number: e.magenta,
      string: e.green,
      regex: e.magenta,
      comment: e.gray,
      invalid: ny(ny(e.white, e.bgRed), e.bold)
    };
  }
  s(eq, "getDefs");
  var tq = /\r\n|[\n\r\u2028\u2029]/, rq = /^[()[\]{}]$/, ly;
  {
    let e = /^[a-z][\w-]*$/i, t = /* @__PURE__ */ s(function(r, i, n) {
      if (r.type === "name") {
        if ((0, sy.isKeyword)(r.value) || (0, sy.isStrictReservedWord)(r.value, !0) || Z7.has(r.value))
          return "keyword";
        if (e.test(r.value) && (n[i - 1] === "<" || n.slice(i - 2, i) == "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && rq.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punct\
uator" : r.type;
    }, "getTokenType");
    ly = /* @__PURE__ */ s(function* (r) {
      let i;
      for (; i = iy.default.exec(r); ) {
        let n = iy.matchToToken(i);
        yield {
          type: t(n, i.index, r),
          value: n.value
        };
      }
    }, "tokenize");
  }
  function iq(e, t) {
    let r = "";
    for (let {
      type: i,
      value: n
    } of ly(t)) {
      let a = e[i];
      a ? r += n.split(tq).map((o) => a(o)).join(`
`) : r += n;
    }
    return r;
  }
  s(iq, "highlightTokens");
  function uy(e) {
    return oy.isColorSupported || e.forceColor;
  }
  s(uy, "shouldHighlight");
  var Pu;
  function sq(e) {
    if (e) {
      var t;
      return (t = Pu) != null || (Pu = (0, Au.createColors)(!0)), Pu;
    }
    return oy;
  }
  s(sq, "getColors");
  function nq(e, t = {}) {
    if (e !== "" && uy(t)) {
      let r = eq(sq(t.forceColor));
      return iq(r, e);
    } else
      return e;
  }
  s(nq, "highlight");
  {
    let e, t;
    is.getChalk = ({
      forceColor: r
    }) => {
      var i;
      if ((i = e) != null || (e = ry()), r) {
        var n;
        return (n = t) != null || (t = new e.constructor({
          enabled: !0,
          level: 1
        })), t;
      }
      return e;
    };
  }
});

// ../node_modules/@babel/code-frame/lib/index.js
var Iu = v((jn) => {
  "use strict";
  Object.defineProperty(jn, "__esModule", {
    value: !0
  });
  jn.codeFrameColumns = yy;
  jn.default = pq;
  var py = cy(), Cu = aq(Tu(), !0);
  function my(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (my = /* @__PURE__ */ s(function(i) {
      return i ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  s(my, "_getRequireWildcardCache");
  function aq(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = my(t);
    if (r && r.has(e)) return r.get(e);
    var i = { __proto__: null }, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var o = n ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(i, a, o) : i[a] = e[a];
    }
    return i.default = e, r && r.set(e, i), i;
  }
  s(aq, "_interopRequireWildcard");
  var oq = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Cu.createColors)(!1) :
  Cu.default, fy = /* @__PURE__ */ s((e, t) => (r) => e(t(r)), "compose"), vu;
  function lq(e) {
    if (e) {
      var t;
      return (t = vu) != null || (vu = (0, Cu.createColors)(!0)), vu;
    }
    return oq;
  }
  s(lq, "getColors");
  var hy = !1;
  function uq(e) {
    return {
      gutter: e.gray,
      marker: fy(e.red, e.bold),
      message: fy(e.red, e.bold)
    };
  }
  s(uq, "getDefs");
  var dy = /\r\n|[\n\r\u2028\u2029]/;
  function cq(e, t, r) {
    let i = Object.assign({
      column: 0,
      line: -1
    }, e.start), n = Object.assign({}, i, e.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, l = i.line, u = i.column, c = n.line, p = n.column, g = Math.max(l - (a + 1), 0), P = Math.min(t.length, c + o);
    l === -1 && (g = 0), c === -1 && (P = t.length);
    let A = c - l, C = {};
    if (A)
      for (let _ = 0; _ <= A; _++) {
        let k = _ + l;
        if (!u)
          C[k] = !0;
        else if (_ === 0) {
          let O = t[k - 1].length;
          C[k] = [u, O - u + 1];
        } else if (_ === A)
          C[k] = [0, p];
        else {
          let O = t[k - _].length;
          C[k] = [0, O];
        }
      }
    else
      u === p ? u ? C[l] = [u, 0] : C[l] = !0 : C[l] = [u, p - u];
    return {
      start: g,
      end: P,
      markerLines: C
    };
  }
  s(cq, "getMarkerLines");
  function yy(e, t, r = {}) {
    let i = (r.highlightCode || r.forceColor) && (0, py.shouldHighlight)(r), n = lq(r.forceColor), a = uq(n), o = /* @__PURE__ */ s((_, k) => i ?
    _(k) : k, "maybeHighlight"), l = e.split(dy), {
      start: u,
      end: c,
      markerLines: p
    } = cq(t, l, r), g = t.start && typeof t.start.column == "number", P = String(c).length, C = (i ? (0, py.default)(e, r) : e).split(dy, c).
    slice(u, c).map((_, k) => {
      let O = u + 1 + k, F = ` ${` ${O}`.slice(-P)} |`, G = p[O], $ = !p[O + 1];
      if (G) {
        let K = "";
        if (Array.isArray(G)) {
          let oe = _.slice(0, Math.max(G[0] - 1, 0)).replace(/[^\t]/g, " "), Oe = G[1] || 1;
          K = [`
 `, o(a.gutter, F.replace(/\d/g, " ")), " ", oe, o(a.marker, "^").repeat(Oe)].join(""), $ && r.message && (K += " " + o(a.message, r.message));
        }
        return [o(a.marker, ">"), o(a.gutter, F), _.length > 0 ? ` ${_}` : "", K].join("");
      } else
        return ` ${o(a.gutter, F)}${_.length > 0 ? ` ${_}` : ""}`;
    }).join(`
`);
    return r.message && !g && (C = `${" ".repeat(P + 1)}${r.message}
${C}`), i ? n.reset(C) : C;
  }
  s(yy, "codeFrameColumns");
  function pq(e, t, r, i = {}) {
    if (!hy) {
      hy = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), yy(e, {
      start: {
        column: r,
        line: t
      }
    }, i);
  }
  s(pq, "_default");
});

// ../node_modules/@babel/parser/lib/index.js
var Hn = v((ds) => {
  "use strict";
  Object.defineProperty(ds, "__esModule", {
    value: !0
  });
  function ky(e, t) {
    if (e == null) return {};
    var r = {}, i = Object.keys(e), n, a;
    for (a = 0; a < i.length; a++)
      n = i[a], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
    return r;
  }
  s(ky, "_objectWithoutPropertiesLoose");
  var Rt = class {
    static {
      s(this, "Position");
    }
    constructor(t, r, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = i;
    }
  }, gi = class {
    static {
      s(this, "SourceLocation");
    }
    constructor(t, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
    }
  };
  function ht(e, t) {
    let {
      line: r,
      column: i,
      index: n
    } = e;
    return new Rt(r, i + t, n + t);
  }
  s(ht, "createPositionWithColumnOffset");
  var Ty = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", fq = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: Ty
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: Ty
    }
  }, gy = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Vn = /* @__PURE__ */ s(({
    type: e,
    prefix: t
  }) => e === "UpdateExpression" ? gy.UpdateExpression[String(t)] : gy[e], "toNodeDescription"), hq = {
    AccessorIsGenerator: /* @__PURE__ */ s(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ s(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ s(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ s(({
      phase: e
    }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ s(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ s(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ s(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ s(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ s(({
      maxArgumentCount: e
    }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ s(({
      radix: e
    }) => `Expected number in radix ${e}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ s(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Invalid identifier ${e}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Invalid left-hand side in ${Vn(e)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${Vn(e)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ s(({
      ancestor: e
    }) => `Invalid optional chaining in the left-hand side of ${Vn(e)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ s(({
      unexpected: e
    }) => `Unexpected character '${e}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Private name #${e} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ s(({
      labelName: e
    }) => `Label '${e}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ s(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ s(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ s(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ s(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ s(({
      localName: e
    }) => `Export '${e}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Duplicate private name #${e}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ s(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ s(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ s(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ s(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ s(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, dq = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ s(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ s(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, mq = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), yq = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ s(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${e}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ s(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${Vn({
      type: e
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, Tq = ["toMessage"], gq = ["message"];
  function by(e, t, r) {
    Object.defineProperty(e, t, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  s(by, "defineHidden");
  function bq(e) {
    let {
      toMessage: t
    } = e, r = ky(e, Tq);
    return /* @__PURE__ */ s(function i(n, a) {
      let o = new SyntaxError();
      return Object.assign(o, r, {
        loc: n,
        pos: n.index
      }), "missingPlugin" in a && Object.assign(o, {
        missingPlugin: a.missingPlugin
      }), by(o, "clone", /* @__PURE__ */ s(function(u = {}) {
        var c;
        let {
          line: p,
          column: g,
          index: P
        } = (c = u.loc) != null ? c : n;
        return i(new Rt(p, g, P), Object.assign({}, a, u.details));
      }, "clone")), by(o, "details", a), Object.defineProperty(o, "message", {
        configurable: !0,
        get() {
          let l = `${t(a)} (${n.line}:${n.column})`;
          return this.message = l, l;
        },
        set(l) {
          Object.defineProperty(this, "message", {
            value: l,
            writable: !0
          });
        }
      }), o;
    }, "constructor");
  }
  s(bq, "toParseErrorConstructor");
  function Gt(e, t) {
    if (Array.isArray(e))
      return (i) => Gt(i, e[0]);
    let r = {};
    for (let i of Object.keys(e)) {
      let n = e[i], a = typeof n == "string" ? {
        message: /* @__PURE__ */ s(() => n, "message")
      } : typeof n == "function" ? {
        message: n
      } : n, {
        message: o
      } = a, l = ky(a, gq), u = typeof o == "string" ? () => o : o;
      r[i] = bq(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: u
      }, t ? {
        syntaxPlugin: t
      } : {}, l));
    }
    return r;
  }
  s(Gt, "ParseErrorEnum");
  var x = Object.assign({}, Gt(fq), Gt(hq), Gt(dq), Gt`pipelineOperator`(yq)), {
    defineProperty: Sq
  } = Object, Sy = /* @__PURE__ */ s((e, t) => Sq(e, t, {
    enumerable: !1,
    value: e[t]
  }), "toUnenumerable");
  function ss(e) {
    return e.loc.start && Sy(e.loc.start, "index"), e.loc.end && Sy(e.loc.end, "index"), e;
  }
  s(ss, "toESTreeLocation");
  var xq = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "ESTreeParserMixin");
    }
    parse() {
      let r = ss(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map(ss)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: i
    }) {
      let n = null;
      try {
        n = new RegExp(r, i);
      } catch {
      }
      let a = this.estreeParseLiteral(n);
      return a.regex = {
        pattern: r,
        flags: i
      }, a;
    }
    parseBigIntLiteral(r) {
      let i;
      try {
        i = BigInt(r);
      } catch {
        i = null;
      }
      let n = this.estreeParseLiteral(i);
      return n.bigint = String(n.value || r), n;
    }
    parseDecimalLiteral(r) {
      let n = this.estreeParseLiteral(null);
      return n.decimal = String(n.value || r), n;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let i = r.value;
      delete r.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let n = r;
      return n.type = "ExpressionStatement", n.expression = i, n.directive = i.extra.rawValue, delete i.extra, n;
    }
    initFunction(r, i) {
      super.initFunction(r, i), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var i;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((i = r.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(r, i, n, a, o) {
      super.parseBlockBody(r, i, n, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, i, n, a, o, l) {
      this.parseMethod(i, n, a, o, l, "ClassMethod", !0), i.typeParameters && (i.value.typeParameters = i.typeParameters, delete i.typeParameters),
      r.body.push(i);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let i = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = i, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, i) {
      let n = super.parseLiteral(r, i);
      return n.raw = n.extra.raw, delete n.extra, n;
    }
    parseFunctionBody(r, i, n = !1) {
      super.parseFunctionBody(r, i, n), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, i, n, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, i, n, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    parseClassProperty(...r) {
      let i = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...r) {
      let i = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
    }
    parseObjectMethod(r, i, n, a, o) {
      let l = super.parseObjectMethod(r, i, n, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, i, n, a) {
      let o = super.parseObjectProperty(r, i, n, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, i, n) {
      return r === "Property" ? "value" : super.isValidLVal(r, i, n);
    }
    isAssignable(r, i) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: n,
          value: a
        } = r;
        this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(r, i);
    }
    toAssignableObjectExpressionProp(r, i, n) {
      r.kind === "get" || r.kind === "set" ? this.raise(x.PatternHasAccessor, r.key) : r.method ? this.raise(x.PatternHasMethod, r.key) : super.
      toAssignableObjectExpressionProp(r, i, n);
    }
    finishCallExpression(r, i) {
      let n = super.finishCallExpression(r, i);
      if (n.callee.type === "Import") {
        if (n.type = "ImportExpression", n.source = n.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          n.options = (a = n.arguments[1]) != null ? a : null, n.attributes = (o = n.arguments[1]) != null ? o : null;
        }
        delete n.arguments, delete n.callee;
      }
      return n;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, i) {
      let n = this.state.lastTokStartLoc, a = super.parseExport(r, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, n);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, i, n, a) {
      let o = super.parseSubscript(r, i, n, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.method || r.kind === "get" || r.kind === "set";
    }
    finishNodeAt(r, i, n) {
      return ss(super.finishNodeAt(r, i, n));
    }
    resetStartLocation(r, i) {
      super.resetStartLocation(r, i), ss(r);
    }
    resetEndLocation(r, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, i), ss(r);
    }
  }, "estree"), Ur = class {
    static {
      s(this, "TokContext");
    }
    constructor(t, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
    }
  }, we = {
    brace: new Ur("{"),
    j_oTag: new Ur("<tag"),
    j_cTag: new Ur("</tag"),
    j_expr: new Ur("<tag>...</tag>", !0)
  };
  we.template = new Ur("`", !0);
  var he = !0, U = !0, wu = !0, ns = !0, hr = !0, Eq = !0, Yn = class {
    static {
      s(this, "ExportedTokenType");
    }
    constructor(t, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, Zu = /* @__PURE__ */ new Map();
  function Te(e, t = {}) {
    t.keyword = e;
    let r = Z(e, t);
    return Zu.set(e, r), r;
  }
  s(Te, "createKeyword");
  function ft(e, t) {
    return Z(e, {
      beforeExpr: he,
      binop: t
    });
  }
  s(ft, "createBinop");
  var us = -1, $t = [], ec = [], tc = [], rc = [], ic = [], sc = [];
  function Z(e, t = {}) {
    var r, i, n, a;
    return ++us, ec.push(e), tc.push((r = t.binop) != null ? r : -1), rc.push((i = t.beforeExpr) != null ? i : !1), ic.push((n = t.startsExpr) !=
    null ? n : !1), sc.push((a = t.prefix) != null ? a : !1), $t.push(new Yn(e, t)), us;
  }
  s(Z, "createToken");
  function fe(e, t = {}) {
    var r, i, n, a;
    return ++us, Zu.set(e, us), ec.push(e), tc.push((r = t.binop) != null ? r : -1), rc.push((i = t.beforeExpr) != null ? i : !1), ic.push((n =
    t.startsExpr) != null ? n : !1), sc.push((a = t.prefix) != null ? a : !1), $t.push(new Yn("name", t)), us;
  }
  s(fe, "createKeywordLike");
  var Pq = {
    bracketL: Z("[", {
      beforeExpr: he,
      startsExpr: U
    }),
    bracketHashL: Z("#[", {
      beforeExpr: he,
      startsExpr: U
    }),
    bracketBarL: Z("[|", {
      beforeExpr: he,
      startsExpr: U
    }),
    bracketR: Z("]"),
    bracketBarR: Z("|]"),
    braceL: Z("{", {
      beforeExpr: he,
      startsExpr: U
    }),
    braceBarL: Z("{|", {
      beforeExpr: he,
      startsExpr: U
    }),
    braceHashL: Z("#{", {
      beforeExpr: he,
      startsExpr: U
    }),
    braceR: Z("}"),
    braceBarR: Z("|}"),
    parenL: Z("(", {
      beforeExpr: he,
      startsExpr: U
    }),
    parenR: Z(")"),
    comma: Z(",", {
      beforeExpr: he
    }),
    semi: Z(";", {
      beforeExpr: he
    }),
    colon: Z(":", {
      beforeExpr: he
    }),
    doubleColon: Z("::", {
      beforeExpr: he
    }),
    dot: Z("."),
    question: Z("?", {
      beforeExpr: he
    }),
    questionDot: Z("?."),
    arrow: Z("=>", {
      beforeExpr: he
    }),
    template: Z("template"),
    ellipsis: Z("...", {
      beforeExpr: he
    }),
    backQuote: Z("`", {
      startsExpr: U
    }),
    dollarBraceL: Z("${", {
      beforeExpr: he,
      startsExpr: U
    }),
    templateTail: Z("...`", {
      startsExpr: U
    }),
    templateNonTail: Z("...${", {
      beforeExpr: he,
      startsExpr: U
    }),
    at: Z("@"),
    hash: Z("#", {
      startsExpr: U
    }),
    interpreterDirective: Z("#!..."),
    eq: Z("=", {
      beforeExpr: he,
      isAssign: ns
    }),
    assign: Z("_=", {
      beforeExpr: he,
      isAssign: ns
    }),
    slashAssign: Z("_=", {
      beforeExpr: he,
      isAssign: ns
    }),
    xorAssign: Z("_=", {
      beforeExpr: he,
      isAssign: ns
    }),
    moduloAssign: Z("_=", {
      beforeExpr: he,
      isAssign: ns
    }),
    incDec: Z("++/--", {
      prefix: hr,
      postfix: Eq,
      startsExpr: U
    }),
    bang: Z("!", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    tilde: Z("~", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    doubleCaret: Z("^^", {
      startsExpr: U
    }),
    doubleAt: Z("@@", {
      startsExpr: U
    }),
    pipeline: ft("|>", 0),
    nullishCoalescing: ft("??", 1),
    logicalOR: ft("||", 1),
    logicalAND: ft("&&", 2),
    bitwiseOR: ft("|", 3),
    bitwiseXOR: ft("^", 4),
    bitwiseAND: ft("&", 5),
    equality: ft("==/!=/===/!==", 6),
    lt: ft("</>/<=/>=", 7),
    gt: ft("</>/<=/>=", 7),
    relational: ft("</>/<=/>=", 7),
    bitShift: ft("<</>>/>>>", 8),
    bitShiftL: ft("<</>>/>>>", 8),
    bitShiftR: ft("<</>>/>>>", 8),
    plusMin: Z("+/-", {
      beforeExpr: he,
      binop: 9,
      prefix: hr,
      startsExpr: U
    }),
    modulo: Z("%", {
      binop: 10,
      startsExpr: U
    }),
    star: Z("*", {
      binop: 10
    }),
    slash: ft("/", 10),
    exponent: Z("**", {
      beforeExpr: he,
      binop: 11,
      rightAssociative: !0
    }),
    _in: Te("in", {
      beforeExpr: he,
      binop: 7
    }),
    _instanceof: Te("instanceof", {
      beforeExpr: he,
      binop: 7
    }),
    _break: Te("break"),
    _case: Te("case", {
      beforeExpr: he
    }),
    _catch: Te("catch"),
    _continue: Te("continue"),
    _debugger: Te("debugger"),
    _default: Te("default", {
      beforeExpr: he
    }),
    _else: Te("else", {
      beforeExpr: he
    }),
    _finally: Te("finally"),
    _function: Te("function", {
      startsExpr: U
    }),
    _if: Te("if"),
    _return: Te("return", {
      beforeExpr: he
    }),
    _switch: Te("switch"),
    _throw: Te("throw", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    _try: Te("try"),
    _var: Te("var"),
    _const: Te("const"),
    _with: Te("with"),
    _new: Te("new", {
      beforeExpr: he,
      startsExpr: U
    }),
    _this: Te("this", {
      startsExpr: U
    }),
    _super: Te("super", {
      startsExpr: U
    }),
    _class: Te("class", {
      startsExpr: U
    }),
    _extends: Te("extends", {
      beforeExpr: he
    }),
    _export: Te("export"),
    _import: Te("import", {
      startsExpr: U
    }),
    _null: Te("null", {
      startsExpr: U
    }),
    _true: Te("true", {
      startsExpr: U
    }),
    _false: Te("false", {
      startsExpr: U
    }),
    _typeof: Te("typeof", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    _void: Te("void", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    _delete: Te("delete", {
      beforeExpr: he,
      prefix: hr,
      startsExpr: U
    }),
    _do: Te("do", {
      isLoop: wu,
      beforeExpr: he
    }),
    _for: Te("for", {
      isLoop: wu
    }),
    _while: Te("while", {
      isLoop: wu
    }),
    _as: fe("as", {
      startsExpr: U
    }),
    _assert: fe("assert", {
      startsExpr: U
    }),
    _async: fe("async", {
      startsExpr: U
    }),
    _await: fe("await", {
      startsExpr: U
    }),
    _defer: fe("defer", {
      startsExpr: U
    }),
    _from: fe("from", {
      startsExpr: U
    }),
    _get: fe("get", {
      startsExpr: U
    }),
    _let: fe("let", {
      startsExpr: U
    }),
    _meta: fe("meta", {
      startsExpr: U
    }),
    _of: fe("of", {
      startsExpr: U
    }),
    _sent: fe("sent", {
      startsExpr: U
    }),
    _set: fe("set", {
      startsExpr: U
    }),
    _source: fe("source", {
      startsExpr: U
    }),
    _static: fe("static", {
      startsExpr: U
    }),
    _using: fe("using", {
      startsExpr: U
    }),
    _yield: fe("yield", {
      startsExpr: U
    }),
    _asserts: fe("asserts", {
      startsExpr: U
    }),
    _checks: fe("checks", {
      startsExpr: U
    }),
    _exports: fe("exports", {
      startsExpr: U
    }),
    _global: fe("global", {
      startsExpr: U
    }),
    _implements: fe("implements", {
      startsExpr: U
    }),
    _intrinsic: fe("intrinsic", {
      startsExpr: U
    }),
    _infer: fe("infer", {
      startsExpr: U
    }),
    _is: fe("is", {
      startsExpr: U
    }),
    _mixins: fe("mixins", {
      startsExpr: U
    }),
    _proto: fe("proto", {
      startsExpr: U
    }),
    _require: fe("require", {
      startsExpr: U
    }),
    _satisfies: fe("satisfies", {
      startsExpr: U
    }),
    _keyof: fe("keyof", {
      startsExpr: U
    }),
    _readonly: fe("readonly", {
      startsExpr: U
    }),
    _unique: fe("unique", {
      startsExpr: U
    }),
    _abstract: fe("abstract", {
      startsExpr: U
    }),
    _declare: fe("declare", {
      startsExpr: U
    }),
    _enum: fe("enum", {
      startsExpr: U
    }),
    _module: fe("module", {
      startsExpr: U
    }),
    _namespace: fe("namespace", {
      startsExpr: U
    }),
    _interface: fe("interface", {
      startsExpr: U
    }),
    _type: fe("type", {
      startsExpr: U
    }),
    _opaque: fe("opaque", {
      startsExpr: U
    }),
    name: Z("name", {
      startsExpr: U
    }),
    string: Z("string", {
      startsExpr: U
    }),
    num: Z("num", {
      startsExpr: U
    }),
    bigint: Z("bigint", {
      startsExpr: U
    }),
    decimal: Z("decimal", {
      startsExpr: U
    }),
    regexp: Z("regexp", {
      startsExpr: U
    }),
    privateName: Z("#name", {
      startsExpr: U
    }),
    eof: Z("eof"),
    jsxName: Z("jsxName"),
    jsxText: Z("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: Z("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: Z("jsxTagEnd"),
    placeholder: Z("%%", {
      startsExpr: !0
    })
  };
  function ve(e) {
    return e >= 93 && e <= 132;
  }
  s(ve, "tokenIsIdentifier");
  function Aq(e) {
    return e <= 92;
  }
  s(Aq, "tokenKeywordOrIdentifierIsKeyword");
  function Dt(e) {
    return e >= 58 && e <= 132;
  }
  s(Dt, "tokenIsKeywordOrIdentifier");
  function Ly(e) {
    return e >= 58 && e <= 136;
  }
  s(Ly, "tokenIsLiteralPropertyName");
  function vq(e) {
    return rc[e];
  }
  s(vq, "tokenComesBeforeExpression");
  function ku(e) {
    return ic[e];
  }
  s(ku, "tokenCanStartExpression");
  function Cq(e) {
    return e >= 29 && e <= 33;
  }
  s(Cq, "tokenIsAssignment");
  function xy(e) {
    return e >= 129 && e <= 131;
  }
  s(xy, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function Iq(e) {
    return e >= 90 && e <= 92;
  }
  s(Iq, "tokenIsLoop");
  function nc(e) {
    return e >= 58 && e <= 92;
  }
  s(nc, "tokenIsKeyword");
  function wq(e) {
    return e >= 39 && e <= 59;
  }
  s(wq, "tokenIsOperator");
  function Oq(e) {
    return e === 34;
  }
  s(Oq, "tokenIsPostfix");
  function Nq(e) {
    return sc[e];
  }
  s(Nq, "tokenIsPrefix");
  function _q(e) {
    return e >= 121 && e <= 123;
  }
  s(_q, "tokenIsTSTypeOperator");
  function Dq(e) {
    return e >= 124 && e <= 130;
  }
  s(Dq, "tokenIsTSDeclarationStart");
  function yr(e) {
    return ec[e];
  }
  s(yr, "tokenLabelName");
  function Un(e) {
    return tc[e];
  }
  s(Un, "tokenOperatorPrecedence");
  function kq(e) {
    return e === 57;
  }
  s(kq, "tokenIsRightAssociative");
  function Xn(e) {
    return e >= 24 && e <= 25;
  }
  s(Xn, "tokenIsTemplate");
  function Jt(e) {
    return $t[e];
  }
  s(Jt, "getExportedToken");
  $t[8].updateContext = (e) => {
    e.pop();
  }, $t[5].updateContext = $t[7].updateContext = $t[23].updateContext = (e) => {
    e.push(we.brace);
  }, $t[22].updateContext = (e) => {
    e[e.length - 1] === we.template ? e.pop() : e.push(we.template);
  }, $t[142].updateContext = (e) => {
    e.push(we.j_expr, we.j_oTag);
  };
  var ac = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  My = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", Lq = new RegExp("[" + ac + "]"), Mq = new RegExp("[" + ac + My + "]");
  ac = My = null;
  var Fy = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Fq = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2,
  5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6,
  1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Lu(e, t) {
    let r = 65536;
    for (let i = 0, n = t.length; i < n; i += 2) {
      if (r += t[i], r > e) return !1;
      if (r += t[i + 1], r >= e) return !0;
    }
    return !1;
  }
  s(Lu, "isInAstralSet");
  function Ht(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && Lq.test(String.fromCharCode(e)) :
    Lu(e, Fy);
  }
  s(Ht, "isIdentifierStart");
  function yi(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && Mq.test(
    String.fromCharCode(e)) : Lu(e, Fy) || Lu(e, Fq);
  }
  s(yi, "isIdentifierChar");
  var oc = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, Bq = new Set(oc.keyword), jq = new Set(oc.strict), Rq = new Set(oc.strictBind);
  function By(e, t) {
    return t && e === "await" || e === "enum";
  }
  s(By, "isReservedWord");
  function jy(e, t) {
    return By(e, t) || jq.has(e);
  }
  s(jy, "isStrictReservedWord");
  function Ry(e) {
    return Rq.has(e);
  }
  s(Ry, "isStrictBindOnlyReservedWord");
  function qy(e, t) {
    return jy(e, t) || Ry(e);
  }
  s(qy, "isStrictBindReservedWord");
  function qq(e) {
    return Bq.has(e);
  }
  s(qq, "isKeyword");
  function Vq(e, t, r) {
    return e === 64 && t === 64 && Ht(r);
  }
  s(Vq, "isIteratorStart");
  var Uq = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Kq(e) {
    return Uq.has(e);
  }
  s(Kq, "canBeReservedWord");
  var ps = class {
    static {
      s(this, "Scope");
    }
    constructor(t) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
    }
  }, fs = class {
    static {
      s(this, "ScopeHandler");
    }
    constructor(t, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let t = this.currentThisScopeFlags();
      return (t & 64) > 0 && (t & 2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new ps(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
    }
    declareName(t, r, i) {
      let n = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(n, t, r, i);
        let a = n.names.get(t) || 0;
        r & 16 ? a = a | 4 : (n.firstLexicalName || (n.firstLexicalName = t), a = a | 2), n.names.set(t, a), r & 8 && this.maybeExportDefined(
        n, t);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (n = this.scopeStack[a], this.checkRedeclarationInScope(n, t, r, i), n.names.set(
        t, (n.names.get(t) || 0) | 1), this.maybeExportDefined(n, t), !(n.flags & 387)); --a)
          ;
      this.parser.inModule && n.flags & 1 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, r) {
      this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(t, r, i, n) {
      this.isRedeclaredInScope(t, r, i) && this.parser.raise(x.VarRedeclaration, n, {
        identifierName: r
      });
    }
    isRedeclaredInScope(t, r, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return t.names.has(r);
      let n = t.names.get(r);
      return i & 16 ? (n & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (n & 1) > 0 : (n & 2) > 0 && !(t.flags & 8 && t.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(t) && (n & 4) > 0;
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, Mu = class extends ps {
    static {
      s(this, "FlowScope");
    }
    constructor(...t) {
      super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, Fu = class extends fs {
    static {
      s(this, "FlowScopeHandler");
    }
    createScope(t) {
      return new Mu(t);
    }
    declareName(t, r, i) {
      let n = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(n, t, r, i), this.maybeExportDefined(n, t), n.declareFunctions.add(t);
        return;
      }
      super.declareName(t, r, i);
    }
    isRedeclaredInScope(t, r, i) {
      if (super.isRedeclaredInScope(t, r, i)) return !0;
      if (i & 2048 && !t.declareFunctions.has(r)) {
        let n = t.names.get(r);
        return (n & 4) > 0 || (n & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }, Bu = class {
    static {
      s(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        let [r, i] = t;
        if (!this.hasPlugin(r))
          return !1;
        let n = this.plugins.get(r);
        for (let a of Object.keys(i))
          if (n?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(t, r) {
      var i;
      return (i = this.plugins.get(t)) == null ? void 0 : i[r];
    }
  };
  function Vy(e, t) {
    e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
  }
  s(Vy, "setTrailingComments");
  function Wq(e, t) {
    e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
  }
  s(Wq, "setLeadingComments");
  function hs(e, t) {
    e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
  }
  s(hs, "setInnerComments");
  function as(e, t, r) {
    let i = null, n = t.length;
    for (; i === null && n > 0; )
      i = t[--n];
    i === null || i.start > r.start ? hs(e, r.comments) : Vy(i, r.comments);
  }
  s(as, "adjustInnerComments");
  var ju = class extends Bu {
    static {
      s(this, "CommentsParser");
    }
    addComment(t) {
      this.filename && (t.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length != r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
    }
    processComment(t) {
      let {
        commentStack: r
      } = this.state, i = r.length;
      if (i === 0) return;
      let n = i - 1, a = r[n];
      a.start === t.end && (a.leadingNode = t, n--);
      let {
        start: o
      } = t;
      for (; n >= 0; n--) {
        let l = r[n], u = l.end;
        if (u > o)
          l.containingNode = t, this.finalizeComment(l), r.splice(n, 1);
        else {
          u === o && (l.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      let {
        comments: r
      } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && Vy(t.leadingNode, r), t.trailingNode !== null && Wq(t.trailingNode, r);
      else {
        let {
          containingNode: i,
          start: n
        } = t;
        if (this.input.charCodeAt(n - 1) === 44)
          switch (i.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              as(i, i.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              as(i, i.arguments, t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              as(i, i.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              as(i, i.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              as(i, i.specifiers, t);
              break;
            default:
              hs(i, r);
          }
        else
          hs(i, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: t
      } = this.state;
      for (let r = t.length - 1; r >= 0; r--)
        this.finalizeComment(t[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      if (i === 0) return;
      let n = r[i - 1];
      n.leadingNode === t && (n.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      i !== 0 && (r[i - 1].trailingNode === t ? r[i - 1].trailingNode = null : i >= 2 && r[i - 2].trailingNode === t && (r[i - 2].trailingNode =
      null));
    }
    takeSurroundingComments(t, r, i) {
      let {
        commentStack: n
      } = this.state, a = n.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = n[o], u = l.end;
        if (l.start === i)
          l.leadingNode = t;
        else if (u === r)
          l.trailingNode = t;
        else if (u < r)
          break;
      }
    }
  }, Uy = /\r\n?|[\n\u2028\u2029]/, Rn = new RegExp(Uy.source, "g");
  function cs(e) {
    switch (e) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  s(cs, "isNewLine");
  var Ou = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Kn = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Ey = new RegExp("(?=(" + Kn.source + "))\\\
1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Yq(e) {
    switch (e) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  s(Yq, "isWhitespace");
  var Ru = class e {
    static {
      s(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [we.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(t) {
      t ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: t,
      sourceType: r,
      startLine: i,
      startColumn: n
    }) {
      this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.curLine = i, this.lineStart = -n, this.startLoc = this.endLoc = new Rt(
      i, n, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(t) {
      t ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(t) {
      t ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(t) {
      t ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(t) {
      t ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(t) {
      t ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(t) {
      t ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(t) {
      t ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(t) {
      t ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(t) {
      t ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(t) {
      t ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(t) {
      t ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new Rt(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let t = new e();
      return t.flags = this.flags, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc,
      t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen,
      t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.
      end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
    }
  }, Xq = /* @__PURE__ */ s(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), Py = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, qn = {
    bin: /* @__PURE__ */ s((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ s((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ s((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ s((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function Ay(e, t, r, i, n, a) {
    let o = r, l = i, u = n, c = "", p = null, g = r, {
      length: P
    } = t;
    for (; ; ) {
      if (r >= P) {
        a.unterminated(o, l, u), c += t.slice(g, r);
        break;
      }
      let A = t.charCodeAt(r);
      if (Jq(e, A, t, r)) {
        c += t.slice(g, r);
        break;
      }
      if (A === 92) {
        c += t.slice(g, r);
        let C = $q(t, r, i, n, e === "template", a);
        C.ch === null && !p ? p = {
          pos: r,
          lineStart: i,
          curLine: n
        } : c += C.ch, {
          pos: r,
          lineStart: i,
          curLine: n
        } = C, g = r;
      } else A === 8232 || A === 8233 ? (++r, ++n, i = r) : A === 10 || A === 13 ? e === "template" ? (c += t.slice(g, r) + `
`, ++r, A === 13 && t.charCodeAt(r) === 10 && ++r, ++n, g = i = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: n,
      containsInvalid: !!p
    };
  }
  s(Ay, "readStringContents");
  function Jq(e, t, r, i) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  s(Jq, "isStringEnd");
  function $q(e, t, r, i, n, a) {
    let o = !n;
    t++;
    let l = /* @__PURE__ */ s((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: i
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = qu(e, t, r, i, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = Wy(e, t, r, i, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(t - 1, r, i);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, g = e.slice(c, t + 2).match(/^[0-7]+/)[0], P = parseInt(g, 8);
          P > 255 && (g = g.slice(0, -1), P = parseInt(g, 8)), t += g.length - 1;
          let A = e.charCodeAt(t);
          if (g !== "0" || A === 56 || A === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(c, r, i);
          }
          return l(String.fromCharCode(P));
        }
        return l(String.fromCharCode(u));
    }
  }
  s($q, "readEscapedChar");
  function qu(e, t, r, i, n, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = Ky(e, t, r, i, 16, n, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, i) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  s(qu, "readHexChar");
  function Ky(e, t, r, i, n, a, o, l, u, c) {
    let p = t, g = n === 16 ? Py.hex : Py.decBinOct, P = n === 16 ? qn.hex : n === 10 ? qn.dec : n === 8 ? qn.oct : qn.bin, A = !1, C = 0;
    for (let _ = 0, k = a ?? 1 / 0; _ < k; ++_) {
      let O = e.charCodeAt(t), M;
      if (O === 95 && l !== "bail") {
        let F = e.charCodeAt(t - 1), G = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(G) || !P(G) || g.has(F) || g.has(G)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, i);
        }
        ++t;
        continue;
      }
      if (O >= 97 ? M = O - 97 + 10 : O >= 65 ? M = O - 65 + 10 : Xq(O) ? M = O - 48 : M = 1 / 0, M >= n) {
        if (M <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (M <= 9 && u.invalidDigit(t, r, i, n))
          M = 0;
        else if (o)
          M = 0, A = !0;
        else
          break;
      }
      ++t, C = C * n + M;
    }
    return t === p || a != null && t - p !== a || A ? {
      n: null,
      pos: t
    } : {
      n: C,
      pos: t
    };
  }
  s(Ky, "readInt");
  function Wy(e, t, r, i, n, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = qu(e, t, r, i, e.indexOf("}", t) - t, !0, n, a), ++t, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(t, r, i);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = qu(e, t, r, i, 4, !1, n, a));
    return {
      code: l,
      pos: t
    };
  }
  s(Wy, "readCodePoint");
  function os(e, t, r) {
    return new Rt(r, e - t, e);
  }
  s(os, "buildPosition");
  var Hq = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), jt = class {
    static {
      s(this, "Token");
    }
    constructor(t) {
      this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new gi(t.startLoc, t.endLoc);
    }
  }, Vu = class extends ju {
    static {
      s(this, "Tokenizer");
    }
    constructor(t, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ s((i, n, a, o) => this.options.errorRecovery ? (this.raise(x.InvalidDigit, os(i, n, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(x.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(x.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(x.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(x.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ s((i, n, a) => {
          this.recordStrictModeErrors(x.StrictNumericEscape, os(i, n, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(x.UnterminatedString, os(i - 1, n, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(x.StrictNumericEscape),
        unterminated: /* @__PURE__ */ s((i, n, a) => {
          throw this.raise(x.UnterminatedTemplate, os(i, n, a));
        }, "unterminated")
      }), this.state = new Ru(), this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new jt(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), !0) : !1;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return {
        pos: t.pos,
        value: null,
        type: t.type,
        start: t.start,
        end: t.end,
        context: [this.curContext()],
        inType: t.inType,
        startLoc: t.startLoc,
        lastTokEndLoc: t.lastTokEndLoc,
        curLine: t.curLine,
        lineStart: t.lineStart,
        curPosition: t.curPosition
      };
    }
    lookahead() {
      let t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = t, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return Ou.lastIndex = t, Ou.test(this.input) ? Ou.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(t) {
      return Kn.lastIndex = t, Kn.test(this.input) ? Kn.lastIndex : t;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(t) {
      let r = this.input.charCodeAt(t);
      if ((r & 64512) === 55296 && ++t < this.input.length) {
        let i = this.input.charCodeAt(t);
        (i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023));
      }
      return r;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(t) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let i = this.state.pos, n = this.input.indexOf(t, i + 2);
      if (n === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = n + t.length, Rn.lastIndex = i + 2; Rn.test(this.input) && Rn.lastIndex <= n; )
        ++this.state.curLine, this.state.lineStart = Rn.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, n),
        start: i,
        end: n + t.length,
        loc: new gi(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(t) {
      let r = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let n = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !cs(n) && ++this.state.pos < this.length; )
          n = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + t, a),
        start: r,
        end: a,
        loc: new gi(i, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let t = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let n = this.skipBlockComment("*/");
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
                break;
              }
              case 47: {
                let n = this.skipLineComment(2);
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Yq(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.options.annexB) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 45 && this.input.charCodeAt(n + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.options.annexB) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 33 && this.input.charCodeAt(n + 2) === 45 && this.input.charCodeAt(n + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let i = this.state.pos, n = {
          start: t,
          end: i,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(n);
      }
    }
    finishToken(t, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(i);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let t = this.state.pos + 1, r = this.codePointAtPos(t);
      if (r >= 48 && r <= 57)
        throw this.raise(x.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? x.RecordExpressionHashIncorrectStartSyntaxType : x.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else Ht(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(!0);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !cs(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(t) {
      let r = t === 42 ? 55 : 54, i = 1, n = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && n === 42 && (i++, n = this.input.charCodeAt(this.state.pos + 2), r = 57), n === 61 && !this.state.inType && (i++, r = t ===
      37 ? 33 : 30), this.finishOp(r, i);
    }
    readToken_pipe_amp(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 62) {
        let i = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Ht(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(x.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(t)
      });
    }
    finishOp(t, r) {
      let i = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(t, i);
    }
    readRegexp() {
      let t = this.state.startLoc, r = this.state.start + 1, i, n, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(x.UnterminatedRegExp, ht(t, 1));
        let c = this.input.charCodeAt(a);
        if (cs(c))
          throw this.raise(x.UnterminatedRegExp, ht(t, 1));
        if (i)
          i = !1;
        else {
          if (c === 91)
            n = !0;
          else if (c === 93 && n)
            n = !1;
          else if (c === 47 && !n)
            break;
          i = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ s(() => ht(t, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (Hq.has(c))
          c === 118 ? l.includes("u") && this.raise(x.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(x.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(x.DuplicateRegExpFlags, u());
        else if (yi(c) || c === 92)
          this.raise(x.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(t, r, i = !1, n = !0) {
      let {
        n: a,
        pos: o
      } = Ky(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, i, n, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(t) {
      let r = this.state.curPosition(), i = !1;
      this.state.pos += 2;
      let n = this.readInt(t);
      n == null && this.raise(x.InvalidDigit, ht(r, 2), {
        radix: t
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, i = !0;
      else if (a === 109)
        throw this.raise(x.InvalidDecimal, r);
      if (Ht(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      if (i) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, n);
    }
    readNumber(t) {
      let r = this.state.pos, i = this.state.curPosition(), n = !1, a = !1, o = !1, l = !1, u = !1;
      !t && this.readInt(10) === null && this.raise(x.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let A = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(x.StrictOctalLiteral, i), !this.state.strict) {
          let C = A.indexOf("_");
          C > 0 && this.raise(x.ZeroDigitNumericSeparator, ht(i, C));
        }
        u = c && !/[89]/.test(A);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !u && (++this.state.pos, this.readInt(10), n = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !u && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      x.InvalidOrMissingExponent, i), n = !0, l = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((n || c) && this.raise(x.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), p === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(x.InvalidDecimal,
      i), ++this.state.pos, o = !0), Ht(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      let g = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, g);
        return;
      }
      if (o) {
        this.finishToken(136, g);
        return;
      }
      let P = u ? parseInt(g, 8) : parseFloat(g);
      this.finishToken(134, P);
    }
    readCodePoint(t) {
      let {
        code: r,
        pos: i
      } = Wy(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
      return this.state.pos = i, r;
    }
    readString(t) {
      let {
        str: r,
        pos: i,
        curLine: n,
        lineStart: a
      } = Ay(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = n, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let t = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: i,
        pos: n,
        curLine: a,
        lineStart: o
      } = Ay("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = n + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new Rt(i.curLine,
      i.pos - i.lineStart, i.pos)), this.input.codePointAt(n) === 96 ? this.finishToken(24, i ? null : t + r + "`") : (this.state.pos++, this.
      finishToken(25, i ? null : t + r + "${"));
    }
    recordStrictModeErrors(t, r) {
      let i = r.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(t, r) : this.state.strictErrors.set(i, [t, r]);
    }
    readWord1(t) {
      this.state.containsEsc = !1;
      let r = "", i = this.state.pos, n = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (yi(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(n, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === i ? Ht : yi;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(x.MissingUnicodeEscape, this.state.curPosition()), n = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(x.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), n = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(n, this.state.pos);
    }
    readWord(t) {
      let r = this.readWord1(t), i = Zu.get(r);
      i !== void 0 ? this.finishToken(i, yr(i)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: t
      } = this.state;
      nc(t) && this.state.containsEsc && this.raise(x.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: yr(t)
      });
    }
    raise(t, r, i = {}) {
      let n = r instanceof Rt ? r : r.loc.start, a = t(n, i);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(t, r, i = {}) {
      let n = r instanceof Rt ? r : r.loc.start, a = n.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = t(n, i);
        if (u.loc.index < a) break;
      }
      return this.raise(t, r, i);
    }
    updateContext(t) {
    }
    unexpected(t, r) {
      throw this.raise(x.UnexpectedToken, t ?? this.state.startLoc, {
        expected: r ? yr(r) : null
      });
    }
    expectPlugin(t, r) {
      if (this.hasPlugin(t))
        return !0;
      throw this.raise(x.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [t]
      });
    }
    expectOnePlugin(t) {
      if (!t.some((r) => this.hasPlugin(r)))
        throw this.raise(x.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: t
        });
    }
    errorBuilder(t) {
      return (r, i, n) => {
        this.raise(t, os(r, i, n));
      };
    }
  }, Uu = class {
    static {
      s(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, Ku = class {
    static {
      s(this, "ClassScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Uu());
    }
    exit() {
      let t = this.stack.pop(), r = this.current();
      for (let [i, n] of Array.from(t.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, n) : this.parser.raise(x.InvalidPrivateFieldResolution, n, {
          identifierName: i
        });
    }
    declarePrivateName(t, r, i) {
      let {
        privateNames: n,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = n.has(t);
      if (r & 3) {
        let u = l && a.get(t);
        if (u) {
          let c = u & 4, p = r & 4, g = u & 3, P = r & 3;
          l = g === P || c !== p, l || a.delete(t);
        } else l || a.set(t, r);
      }
      l && this.parser.raise(x.PrivateNameRedeclaration, i, {
        identifierName: t
      }), n.add(t), o.delete(t);
    }
    usePrivateName(t, r) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(t)) return;
      i ? i.undefinedPrivateNames.set(t, r) : this.parser.raise(x.InvalidPrivateFieldResolution, r, {
        identifierName: t
      });
    }
  }, bi = class {
    static {
      s(this, "ExpressionScope");
    }
    constructor(t = 0) {
      this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Jn = class extends bi {
    static {
      s(this, "ArrowHeadParsingScope");
    }
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, r) {
      let i = r.index;
      this.declarationErrors.set(i, [t, r]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }, Wu = class {
    static {
      s(this, "ExpressionScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [new bi()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, r) {
      let i = r.loc.start, {
        stack: n
      } = this, a = n.length - 1, o = n[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(t, i);
        else
          return;
        o = n[--a];
      }
      this.parser.raise(t, i);
    }
    recordArrowParameterBindingError(t, r) {
      let {
        stack: i
      } = this, n = i[i.length - 1], a = r.loc.start;
      if (n.isCertainlyParameterDeclaration())
        this.parser.raise(t, a);
      else if (n.canBeArrowParameterDeclaration())
        n.recordDeclarationError(t, a);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      let {
        stack: r
      } = this, i = r.length - 1, n = r[i];
      for (; n.canBeArrowParameterDeclaration(); )
        n.type === 2 && n.recordDeclarationError(x.AwaitBindingIdentifier, t), n = r[--i];
    }
    validateAsPattern() {
      let {
        stack: t
      } = this, r = t[t.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([i, n]) => {
        this.parser.raise(i, n);
        let a = t.length - 2, o = t[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(n.index), o = t[--a];
      });
    }
  };
  function Gq() {
    return new bi(3);
  }
  s(Gq, "newParameterDeclarationScope");
  function zq() {
    return new Jn(1);
  }
  s(zq, "newArrowHeadScope");
  function Qq() {
    return new Jn(2);
  }
  s(Qq, "newAsyncArrowScope");
  function Yy() {
    return new bi();
  }
  s(Yy, "newExpressionScope");
  var Yu = class {
    static {
      s(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Wn(e, t) {
    return (e ? 2 : 0) | (t ? 1 : 0);
  }
  s(Wn, "functionFlags");
  var Xu = class extends Vu {
    static {
      s(this, "UtilParser");
    }
    addExtra(t, r, i, n = !0) {
      if (!t) return;
      let a = t.extra = t.extra || {};
      n ? a[r] = i : Object.defineProperty(a, r, {
        enumerable: n,
        value: i
      });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, r) {
      let i = t + r.length;
      if (this.input.slice(t, i) === r) {
        let n = this.input.charCodeAt(i);
        return !(yi(n) || (n & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(t) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), !0) : !1;
    }
    expectContextual(t, r) {
      if (!this.eatContextual(t)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, t);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Uy.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return Ey.lastIndex = this.state.end, Ey.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(t = !0) {
      (t ? this.isLineTerminator() : this.eat(13)) || this.raise(x.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(t, r) {
      this.eat(t) || this.unexpected(r, t);
    }
    tryParse(t, r = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let n = t((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: n,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: n,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (n) {
        let a = this.state;
        if (this.state = r, n instanceof SyntaxError)
          return {
            node: null,
            error: n,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (n === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw n;
      }
    }
    checkExpressionErrors(t, r) {
      if (!t) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: n,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = t, l = !!i || !!n || !!o || !!a;
      if (!r)
        return l;
      i != null && this.raise(x.InvalidCoverInitializedName, i), n != null && this.raise(x.DuplicateProto, n), a != null && this.raise(x.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return Ly(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes(t = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let n = this.inModule;
      this.inModule = t;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, t);
      let l = this.prodParam;
      this.prodParam = new Yu();
      let u = this.classScope;
      this.classScope = new Ku(this);
      let c = this.expressionScope;
      return this.expressionScope = new Wu(this), () => {
        this.state.labels = r, this.exportedIdentifiers = i, this.inModule = n, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let t = 0;
      this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
    }
    checkDestructuringPrivate(t) {
      let {
        privateKeyLoc: r
      } = t;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, Ti = class {
    static {
      s(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Si = class {
    static {
      s(this, "Node");
    }
    constructor(t, r, i) {
      this.type = "", this.start = r, this.end = 0, this.loc = new gi(i), t != null && t.options.ranges && (this.range = [r, 0]), t != null &&
      t.filename && (this.loc.filename = t.filename);
    }
  }, lc = Si.prototype;
  lc.__clone = function() {
    let e = new Si(void 0, this.start, this.loc.start), t = Object.keys(this);
    for (let r = 0, i = t.length; r < i; r++) {
      let n = t[r];
      n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments" && (e[n] = this[n]);
    }
    return e;
  };
  function Zq(e) {
    return zt(e);
  }
  s(Zq, "clonePlaceholder");
  function zt(e) {
    let {
      type: t,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o,
      name: l
    } = e, u = Object.create(lc);
    return u.type = t, u.start = r, u.end = i, u.loc = n, u.range = a, u.extra = o, u.name = l, t === "Placeholder" && (u.expectedNode = e.expectedNode),
    u;
  }
  s(zt, "cloneIdentifier");
  function eV(e) {
    let {
      type: t,
      start: r,
      end: i,
      loc: n,
      range: a,
      extra: o
    } = e;
    if (t === "Placeholder")
      return Zq(e);
    let l = Object.create(lc);
    return l.type = t, l.start = r, l.end = i, l.loc = n, l.range = a, e.raw !== void 0 ? l.raw = e.raw : l.extra = o, l.value = e.value, l;
  }
  s(eV, "cloneStringLiteral");
  var Ju = class extends Xu {
    static {
      s(this, "NodeUtils");
    }
    startNode() {
      let t = this.state.startLoc;
      return new Si(this, t.index, t);
    }
    startNodeAt(t) {
      return new Si(this, t.index, t);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.loc.start);
    }
    finishNode(t, r) {
      return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, r, i) {
      return t.type = r, t.end = i.index, t.loc.end = i, this.options.ranges && (t.range[1] = i.index), this.options.attachComment && this.processComment(
      t), t;
    }
    resetStartLocation(t, r) {
      t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
    }
    resetEndLocation(t, r = this.state.lastTokEndLoc) {
      t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
    }
    resetStartLocationFromNode(t, r) {
      this.resetStartLocation(t, r.loc.start);
    }
  }, tV = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "stat\
ic", "string", "true", "typeof", "void"]), re = Gt`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ s(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ s(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ s(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ s(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ s(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ s(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ s(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ s(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ s(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ s(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function rV(e) {
    return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "T\
ypeAlias" && e.declaration.type !== "InterfaceDeclaration");
  }
  s(rV, "isEsModuleType");
  function vy(e) {
    return e.importKind === "type" || e.importKind === "typeof";
  }
  s(vy, "hasTypeImportKind");
  var iV = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function sV(e, t) {
    let r = [], i = [];
    for (let n = 0; n < e.length; n++)
      (t(e[n], n, e) ? r : i).push(e[n]);
    return [r, i];
  }
  s(sV, "partition");
  var nV = /\*?\s*@((?:no)?flow)\b/, aV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Fu;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, i) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, i);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let i = nV.exec(r.value);
        if (i) if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let i = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let n = this.flowParseType();
      return this.state.inType = i, n;
    }
    flowParsePredicate() {
      let r = this.startNode(), i = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(re.UnexpectedSpaceBetweenModuloChecks,
      i), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let i = null, n = null;
      return this.match(54) ? (this.state.inType = r, n = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = r, this.
      match(54) && (n = this.flowParsePredicate())), [i, n];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let i = r.id = this.parseIdentifier(), n = this.startNode(), a = this.startNode();
      this.match(47) ? n.typeParameters = this.flowParseTypeParameterDeclaration() : n.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return n.params = o.params, n.rest = o.rest, n.this = o._this, this.expect(11), [n.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(n, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      i), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, i) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (i && this.raise(re.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, i);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let i = r.body = this.startNode(), n = i.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(re.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, re.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), n.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
      let a = null, o = !1;
      return n.forEach((l) => {
        rV(l) ? (a === "CommonJS" && this.raise(re.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(re.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(re.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, i) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
        let n = this.state.value;
        throw this.raise(re.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: n,
          suggestion: iV[n]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let i = this.flowParseTypeAlias(r);
      return i.type = "DeclareTypeAlias", i;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let i = this.flowParseOpaqueType(r, !0);
      return i.type = "DeclareOpaqueType", i;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, i) {
      if (r.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(r.id.name, i ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!i && this.eat(12));
      if (i) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: i,
        allowExact: !1,
        allowSpread: !1,
        allowProto: i,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(re.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, i, n) {
      tV.has(r) && this.raise(n ? re.AssignReservedType : re.UnexpectedReservedType, i, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, i) {
      return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, i) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, i || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let i = this.state.startLoc, n = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return n.name = o.name, n.variance = a, n.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), n.default = this.flowParseType()) :
      r && this.raise(re.MissingTypeParamDefault, i), this.finishNode(n, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, i = this.startNode();
      i.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let n = !1;
      do {
        let a = this.flowParseTypeParameter(n);
        i.params.push(a), a.default && (n = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(i, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), i = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let n = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = n, this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), i = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, i, n) {
      return r.static = i, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = n, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, i) {
      return r.static = i, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, i) {
      let n = this.startNode();
      return r.static = i, r.value = this.flowParseObjectTypeMethodish(n), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: i,
      allowSpread: n,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, g = !1;
      for (i && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let A = !1, C = null, _ = null, k = this.startNode();
        if (a && this.isContextual(118)) {
          let M = this.lookahead();
          M.type !== 14 && M.type !== 17 && (this.next(), C = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let M = this.lookahead();
          M.type !== 14 && M.type !== 17 && (this.next(), A = !0);
        }
        let O = this.flowParseVariance();
        if (this.eat(0))
          C != null && this.unexpected(C), this.eat(0) ? (O && this.unexpected(O.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          k, A))) : u.indexers.push(this.flowParseObjectTypeIndexer(k, A, O));
        else if (this.match(10) || this.match(47))
          C != null && this.unexpected(C), O && this.unexpected(O.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(k, A));
        else {
          let M = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let G = this.lookahead();
            Ly(G.type) && (M = this.state.value, this.next());
          }
          let F = this.flowParseObjectTypeProperty(k, A, C, O, M, n, o ?? !p);
          F === null ? (g = !0, _ = this.state.lastTokStartLoc) : u.properties.push(F);
        }
        this.flowObjectTypeSemicolon(), _ && !this.match(8) && !this.match(9) && this.raise(re.UnexpectedExplicitInexactInObject, _);
      }
      this.expect(c), n && (u.inexact = g);
      let P = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, P;
    }
    flowParseObjectTypeProperty(r, i, n, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(re.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(re.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(re.InexactVariance, a), null) : (l || this.raise(
        re.UnexpectedSpreadType, this.state.lastTokStartLoc), n != null && this.unexpected(n), a && this.raise(re.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = i, r.proto = n != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, n != null && this.unexpected(n), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(re.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let i = r.kind === "get" ? 0 : 1, n = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? re.GetterMayNotHaveThisParam : re.SetterMayNotHaveThisParam, r.value.this), n !== i && this.
      raise(r.kind === "get" ? x.BadGetterArity : x.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(x.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, i) {
      var n;
      (n = r) != null || (r = this.state.startLoc);
      let a = i || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, i) {
      let n = this.startNodeAt(r);
      return n.typeParameters = null, n.id = this.flowParseQualifiedTypeIdentifier(r, i), this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(n, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let i = null, n = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(re.ThisParamMustBeFirst, o), i = this.parseIdentifier(u), this.eat(17) &&
      (n = !0, u && this.raise(re.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = i,
      o.optional = n, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let i = this.startNodeAt(r.loc.start);
      return i.name = null, i.optional = !1, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let i = null, n = null;
      for (this.match(78) && (n = this.flowParseFunctionTypeParam(!0), n.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: i,
        _this: n
      };
    }
    flowIdentToTypeAnnotation(r, i, n) {
      switch (n.name) {
        case "any":
          return this.finishNode(i, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(i, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(i, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(i, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(i, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(i, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(i, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(n.name), this.flowParseGenericType(r, n);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, i = this.startNode(), n, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47:
          return i.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), n = this.flowParseFunctionTypeParams(), i.params =
          n.params, i.rest = n.rest, i.this = n._this, this.expect(11), this.expect(19), i.returnType = this.flowParseType(), this.finishNode(
          i, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (ve(this.state.type) || this.match(78)) {
              let u = this.lookahead().type;
              o = u !== 17 && u !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? n = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : n = this.flowParseFunctionTypeParams(),
          i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), this.expect(19), i.returnType = this.flowParseType(), i.typeParameters =
          null, this.finishNode(i, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
            throw this.raise(re.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(i, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(i, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (nc(this.state.type)) {
            let u = yr(this.state.type);
            return this.next(), super.createIdentifier(i, u);
          } else if (ve(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, i, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, i = this.flowParsePrimaryType(), n = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        n = n || o, this.expect(0), !o && this.match(3) ? (a.elementType = i, this.next(), i = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = i, a.indexType = this.flowParseType(), this.expect(3), n ? (a.optional = o, i = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : i = this.finishNode(a, "IndexedAccessType"));
      }
      return i;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let i = this.startNodeAt(r.loc.start);
        return i.params = [this.reinterpretTypeAsFunctionTypeParam(r)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.
        typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let i = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [i]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? i : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let i = this.flowParseIntersectionType();
      for (r.types = [i]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? i : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let i = this.flowParseUnionType();
      return this.state.inType = r, i;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, i = this.parseIdentifier();
        return this.flowParseGenericType(r, i);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let i = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, i, n = !1) {
      if (i) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, n));
        return;
      }
      super.parseFunctionBody(r, !1, n);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, i, n);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let n = this.lookahead();
        if (Dt(n.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let n = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(n);
      }
      let i = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
    }
    parseExpressionStatement(r, i, n) {
      if (i.type === "Identifier") {
        if (i.name === "declare") {
          if (this.match(80) || ve(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (ve(this.state.type)) {
          if (i.name === "interface")
            return this.flowParseInterface(r);
          if (i.name === "type")
            return this.flowParseTypeAlias(r);
          if (i.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return xy(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return xy(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, i, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let P = this.lookaheadCharCode();
        if (P === 44 || P === 61 || P === 58 || P === 41)
          return this.setOptionalParametersError(n), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(i), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, g] = this.getArrowLikeExpressions(u);
      if (c || g.length > 0) {
        let P = [...o];
        if (g.length > 0) {
          this.state = a, this.state.noArrowAt = P;
          for (let A = 0; A < g.length; A++)
            P.push(g[A].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, g] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(re.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, P.push(p[0].start),
        this.state.noArrowAt = P, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), i = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: i
      };
    }
    getArrowLikeExpressions(r, i) {
      let n = [r], a = [];
      for (; n.length !== 0; ) {
        let o = n.pop();
        o.type === "ArrowFunctionExpression" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(o) : a.push(o), n.push(o.body)) :
        o.type === "ConditionalExpression" && (n.push(o.consequent), n.push(o.alternate));
      }
      return i ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : sV(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var i;
      this.toAssignableList(r.params, (i = r.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, i) {
      let n;
      return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), n =
      i(), this.state.noArrowParamsConversionAt.pop()) : n = i(), n;
    }
    parseParenItem(r, i) {
      if (r = super.parseParenItem(r, i), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let n = this.startNodeAt(i);
        return n.expression = r, n.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n, "TypeCastExpression");
      }
      return r;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        i);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseOpaqueType(i, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseInterface(i);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: i
      } = this.state, n = super.maybeParseExportNamespaceSpecifier(r);
      return n && r.exportKind === "type" && this.unexpected(i), n;
    }
    parseClassId(r, i, n) {
      super.parseClassId(r, i, n), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, i, n) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, i))
          return;
        i.declare = !0;
      }
      super.parseClassMember(r, i, n), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "Property\
Definition" ? this.raise(re.DeclareClassElement, a) : i.value && this.raise(re.DeclareClassFieldInitializer, i.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), i = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(x.InvalidIdentifier, this.state.curPosition(), {
        identifierName: i
      }), this.finishToken(132, i);
    }
    getTokenFromCode(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : Vq(r, i, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, i) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      !i && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, i);
    }
    toAssignableList(r, i, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, i, n);
    }
    toReferencedList(r, i) {
      for (let a = 0; a < r.length; a++) {
        var n;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((n = o.extra) != null && n.parenthesized) && (r.length > 1 || !i) && this.raise(re.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return i && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, i, n) {
      return r === "TypeCastExpression" || super.isValidLVal(r, i, n);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, i, n, a, o, l) {
      if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, i, n, a, o, l), i.params && o) {
        let u = i.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(re.ThisParamBannedInConstructor, i);
      } else if (i.type === "MethodDefinition" && o && i.value.params) {
        let u = i.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(re.ThisParamBannedInConstructor, i);
      }
    }
    pushClassPrivateMethod(r, i, n, a) {
      i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, i, n, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let i = r.implements = [];
        do {
          let n = this.startNode();
          n.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? n.typeParameters = this.flowParseTypeParameterInstantiation() : n.
          typeParameters = null, i.push(this.finishNode(n, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let i = this.getObjectOrClassMethodParams(r);
      if (i.length > 0) {
        let n = i[0];
        this.isThisParam(n) && r.kind === "get" ? this.raise(re.GetterMayNotHaveThisParam, n) : this.isThisParam(n) && this.raise(re.SetterMayNotHaveThisParam,
        n);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, i, n, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, i, n, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(re.PatternIsOptional, r), this.isThisParam(r) && this.raise(re.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(re.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(re.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(re.TypeBeforeInitializer,
      n.typeAnnotation), n;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(re.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, i, n) {
      i.local = vy(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(i,
      n));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let i = this.lookaheadCharCode();
        return i === 123 || i === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      if (super.applyImportPhase(r, i, n, a), i) {
        if (!n && this.match(65))
          return;
        r.exportKind = n === "type" ? n : "value";
      } else
        n === "type" && this.match(55) && this.unexpected(), r.importKind = n === "type" || n === "typeof" ? n : "value";
    }
    parseImportSpecifier(r, i, n, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let g = this.parseIdentifier(!0);
        u !== null && !Dt(this.state.type) ? (r.imported = g, r.importKind = u, r.local = zt(g)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && Dt(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (i)
            throw this.raise(x.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = zt(r.imported));
      }
      let p = vy(r);
      return n && p && this.raise(re.ImportTypeShorthandOnlyInPureImport, r), (n || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !n && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, i) {
      let n = r.kind;
      n !== "get" && n !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      if (this.match(14)) {
        let n = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = n;
      }
      return super.parseAsyncArrowFromCallExpression(r, i);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, i) {
      var n;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, i), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === we.j_oTag || p === we.j_expr) && c.pop();
      }
      if ((n = o) != null && n.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((P) => {
          var A;
          c = this.flowParseTypeParameterDeclaration();
          let C = this.forwardNoArrowParamsConversionAt(c, () => {
            let k = super.parseMaybeAssign(r, i);
            return this.resetStartLocationFromNode(k, c), k;
          });
          (A = C.extra) != null && A.parenthesized && P();
          let _ = this.maybeUnwrapTypeCastExpression(C);
          return _.type !== "ArrowFunctionExpression" && P(), _.typeParameters = c, this.resetStartLocationFromNode(_, c), C;
        }, a), g = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(re.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          g = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (g)
          return this.state = p.failState, g;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(re.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse(() => {
          let n = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = n, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (i.thrown) return null;
        i.error && (this.state = i.failState), r.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, i) {
      this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = i : super.setArrowFunctionParameters(r, i);
    }
    checkParams(r, i, n, a = !0) {
      if (!(n && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(re.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, i, n, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(r, i, n) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(i.index) !== -1) {
        this.next();
        let a = this.startNodeAt(i);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(i) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, i, n), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, i, n);
    }
    parseSubscript(r, i, n, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, n)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(i);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!n && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(i);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let i = null;
      this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      i;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let i = this.startNodeAt(r);
      if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
        return super.parseArrowExpression(i, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && i === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && i === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, i) {
      let n = super.parseTopLevel(r, i);
      return this.state.hasFlowComment && this.raise(re.UnterminatedFlowComment, this.state.curPosition()), n;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(re.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, i = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + i)); )
        i++;
      let n = this.input.charCodeAt(i + r), a = this.input.charCodeAt(i + r + 1);
      return n === 58 && a === 58 ? i + 2 : this.input.slice(i + r, i + r + 12) === "flow-include" ? i + 12 : n === 58 && a !== 58 ? i : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: i,
      memberName: n
    }) {
      this.raise(re.EnumBooleanMemberNotInitialized, r, {
        memberName: n,
        enumName: i
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, i) {
      return this.raise(i.explicitType ? i.explicitType === "symbol" ? re.EnumInvalidMemberInitializerSymbolType : re.EnumInvalidMemberInitializerPrimaryType :
      re.EnumInvalidMemberInitializerUnknownType, r, i);
    }
    flowEnumErrorNumberMemberNotInitialized(r, i) {
      this.raise(re.EnumNumberMemberNotInitialized, r, i);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, i) {
      this.raise(re.EnumStringMemberInconsistentlyInitialized, r, i);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, i = /* @__PURE__ */ s(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let n = this.parseNumericLiteral(this.state.value);
          return i() ? {
            type: "number",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let n = this.parseStringLiteral(this.state.value);
          return i() ? {
            type: "string",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let n = this.parseBooleanLiteral(this.match(85));
          return i() ? {
            type: "boolean",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, i = this.parseIdentifier(!0), n = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: i,
        init: n
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, i, n) {
      let {
        explicitType: a
      } = i;
      a !== null && a !== n && this.flowEnumErrorInvalidMemberInitializer(r, i);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: i
    }) {
      let n = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(re.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), n.has(p) && this.raise(re.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: r
        }), n.add(p);
        let g = {
          enumName: r,
          explicitType: i,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, g, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, g, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, g, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, g);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, g);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, g);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, i, {
      enumName: n
    }) {
      if (r.length === 0)
        return i;
      if (i.length === 0)
        return r;
      if (i.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return i;
      } else {
        for (let a of i)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!ve(this.state.type))
        throw this.raise(re.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: i
      } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(re.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: i
      }), i;
    }
    flowEnumBody(r, i) {
      let n = i.name, a = i.loc.start, o = this.flowEnumParseExplicitType({
        enumName: n
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: n,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: n
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ s(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = l.booleanMembers.length, g = l.numberMembers.length, P = l.stringMembers.length, A = l.defaultedMembers.length;
          if (!p && !g && !P && !A)
            return c();
          if (!p && !g)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: n
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!g && !P && p >= A) {
            for (let C of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(C.loc.start, {
                enumName: n,
                memberName: C.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !P && g >= A) {
            for (let C of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(C.loc.start, {
                enumName: n,
                memberName: C.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(re.EnumInconsistentMemberValues, a, {
              enumName: n
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let i = this.parseIdentifier();
      return r.id = i, r.body = this.flowEnumBody(this.startNode(), i), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let i = this.input.charCodeAt(r + 1);
        return i !== 60 && i !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), oV = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Vr = Gt`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ s(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ s(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function dr(e) {
    return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
  }
  s(dr, "isFragment");
  function mi(e) {
    if (e.type === "JSXIdentifier")
      return e.name;
    if (e.type === "JSXNamespacedName")
      return e.namespace.name + ":" + e.name.name;
    if (e.type === "JSXMemberExpression")
      return mi(e.object) + "." + mi(e.property);
    throw new Error("Node had unexpected type: " + e.type);
  }
  s(mi, "getQualifiedJSXName");
  var lV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", i = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Vr.UnterminatedJsxContent, this.state.startLoc);
        let n = this.input.charCodeAt(this.state.pos);
        switch (n) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              n === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(n);
              return;
            }
            r += this.input.slice(i, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(i, this.state.pos), r += this.jsxReadEntity(), i = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            cs(n) ? (r += this.input.slice(i, this.state.pos), r += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let i = this.input.charCodeAt(this.state.pos), n;
      return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, n = r ? `
` : `\r
`) : n = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, n;
    }
    jsxReadString(r) {
      let i = "", n = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(x.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (i += this.input.slice(n, this.state.pos), i += this.jsxReadEntity(), n = this.state.pos) : cs(a) ? (i += this.input.slice(
        n, this.state.pos), i += this.jsxReadNewLine(!1), n = this.state.pos) : ++this.state.pos;
      }
      i += this.input.slice(n, this.state.pos++), this.finishToken(133, i);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let i = 10;
        this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
        let n = this.readInt(i, void 0, !1, "bail");
        if (n !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(n);
      } else {
        let i = 0, n = !1;
        for (; i++ < 10 && this.state.pos < this.length && !(n = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (n) {
          let a = this.input.slice(r, this.state.pos), o = oV[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, i = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (yi(r) || r === 45);
      this.finishToken(140, this.input.slice(i, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : nc(this.state.type) ? r.name = yr(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, i = this.jsxParseIdentifier();
      if (!this.eat(14)) return i;
      let n = this.startNodeAt(r);
      return n.namespace = i, n.name = this.jsxParseIdentifier(), this.finishNode(n, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, i = this.jsxParseNamespacedName();
      if (i.type === "JSXNamespacedName")
        return i;
      for (; this.eat(16); ) {
        let n = this.startNodeAt(r);
        n.object = i, n.property = this.jsxParseIdentifier(), i = this.finishNode(n, "JSXMemberExpression");
      }
      return i;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(we.brace), this.next(), r = this.jsxParseExpressionContainer(r, we.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(Vr.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(Vr.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(we.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, i) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let n = this.parseExpression();
        r.expression = n;
      }
      return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(we.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      we.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      i));
    }
    jsxParseOpeningElementAfterName(r) {
      let i = [];
      for (; !this.match(56) && !this.match(143); )
        i.push(this.jsxParseAttribute());
      return r.attributes = i, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      i, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let i = this.startNodeAt(r), n = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              n.push(this.jsxParseElementAt(r));
              break;
            case 141:
              n.push(this.parseExprAtom());
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(we.brace), this.next(), this.match(21) ? n.push(this.jsxParseSpreadChild(l)) : n.push(this.jsxParseExpressionContainer(
              l, we.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        dr(a) && !dr(o) && o !== null ? this.raise(Vr.MissingClosingTagFragment, o) : !dr(a) && dr(o) ? this.raise(Vr.MissingClosingTagElement,
        o, {
          openingTagName: mi(a.name)
        }) : !dr(a) && !dr(o) && mi(o.name) !== mi(a.name) && this.raise(Vr.MissingClosingTagElement, o, {
          openingTagName: mi(a.name)
        });
      }
      if (dr(a) ? (i.openingFragment = a, i.closingFragment = o) : (i.openingElement = a, i.closingElement = o), i.children = n, this.match(
      47))
        throw this.raise(Vr.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return dr(a) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: i
      } = this.state;
      i[i.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) &&
      this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let i = this.curContext();
      if (i === we.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (i === we.j_oTag || i === we.j_cTag) {
        if (Ht(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && i === we.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: i,
        type: n
      } = this.state;
      if (n === 56 && r === 142)
        i.splice(-2, 2, we.j_cTag), this.state.canStartJSXElement = !1;
      else if (n === 142)
        i.push(we.j_oTag);
      else if (n === 143) {
        let a = i[i.length - 1];
        a === we.j_oTag && r === 56 || a === we.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === we.j_expr) : (this.setContext(
        we.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = vq(n);
    }
  }, "jsx"), $u = class extends ps {
    static {
      s(this, "TypeScriptScope");
    }
    constructor(...t) {
      super(...t), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, Hu = class extends fs {
    static {
      s(this, "TypeScriptScopeHandler");
    }
    constructor(...t) {
      super(...t), this.importsStack = [];
    }
    createScope(t) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new $u(t);
    }
    enter(t) {
      t == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
    }
    exit() {
      let t = super.exit();
      return t == 256 && this.importsStack.pop(), t;
    }
    hasImport(t, r) {
      let i = this.importsStack.length;
      if (this.importsStack[i - 1].has(t))
        return !0;
      if (!r && i > 1) {
        for (let n = 0; n < i - 1; n++)
          if (this.importsStack[n].has(t)) return !0;
      }
      return !1;
    }
    declareName(t, r, i) {
      if (r & 4096) {
        this.hasImport(t, !0) && this.parser.raise(x.VarRedeclaration, i, {
          identifierName: t
        }), this.importsStack[this.importsStack.length - 1].add(t);
        return;
      }
      let n = this.currentScope(), a = n.tsNames.get(t) || 0;
      if (r & 1024) {
        this.maybeExportDefined(n, t), n.tsNames.set(t, a | 16);
        return;
      }
      super.declareName(t, r, i), r & 2 && (r & 1 || (this.checkRedeclarationInScope(n, t, r, i), this.maybeExportDefined(n, t)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && n.tsNames.set(t, a);
    }
    isRedeclaredInScope(t, r, i) {
      let n = t.tsNames.get(r);
      if ((n & 2) > 0) {
        if (i & 256) {
          let a = !!(i & 512), o = (n & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return i & 128 && (n & 8) > 0 ? t.names.get(r) & 2 ? !!(i & 1) : !1 : i & 2 && (n & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, i);
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      if (this.hasImport(r)) return;
      let i = this.scopeStack.length;
      for (let n = i - 1; n >= 0; n--) {
        let o = this.scopeStack[n].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(t);
    }
  }, uV = /* @__PURE__ */ s((e, t) => hasOwnProperty.call(e, t) && e[t], "getOwn$1"), Xy = /* @__PURE__ */ s((e) => e.type === "Parenthesize\
dExpression" ? Xy(e.expression) : e, "unwrapParenthesizedExpression"), Gu = class extends Ju {
    static {
      s(this, "LValParser");
    }
    toAssignable(t, r = !1) {
      var i, n;
      let a;
      switch ((t.type === "ParenthesizedExpression" || (i = t.extra) != null && i.parenthesized) && (a = Xy(t), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(x.InvalidParenthesizedAssignment, t) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(x.InvalidParenthesizedAssignment, t) : this.raise(x.InvalidParenthesizedAssignment, t)), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          t.type = "ObjectPattern";
          for (let l = 0, u = t.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = t.properties[l], g = l === c;
            this.toAssignableObjectExpressionProp(p, g, r), g && p.type === "RestElement" && (o = t.extra) != null && o.trailingCommaLoc && this.
            raise(x.RestTrailingComma, t.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = t;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          t.type = "ArrayPattern", this.toAssignableList(t.elements, (n = t.extra) == null ? void 0 : n.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(x.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(
          t.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, r, i) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? x.PatternHasAccessor : x.PatternHasMethod, t.key);
      else if (t.type === "SpreadElement") {
        t.type = "RestElement";
        let n = t.argument;
        this.checkToRestConversion(n, !1), this.toAssignable(n, i), r || this.raise(x.RestTrailingComma, t);
      } else
        this.toAssignable(t, i);
    }
    toAssignableList(t, r, i) {
      let n = t.length - 1;
      for (let a = 0; a <= n; a++) {
        let o = t[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, i);
          } else
            this.toAssignable(o, i);
          o.type === "RestElement" && (a < n ? this.raise(x.RestTrailingComma, o) : r && this.raise(x.RestTrailingComma, r));
        }
      }
    }
    isAssignable(t, r) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let i = t.properties.length - 1;
          return t.properties.every((n, a) => n.type !== "ObjectMethod" && (a === i || n.type !== "SpreadElement") && this.isAssignable(n));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((i) => i === null || this.isAssignable(i));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(t, r) {
      return t;
    }
    toReferencedListDeep(t, r) {
      this.toReferencedList(t, r);
      for (let i of t)
        i?.type === "ArrayExpression" && this.toReferencedListDeep(i.elements);
    }
    parseSpread(t) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let t = this.startNode();
      return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, r, i) {
      let n = i & 1, a = [], o = !0;
      for (; !this.eat(t); )
        if (o ? o = !1 : this.expect(12), n && this.match(12))
          a.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), i)), !this.checkCommaAfterRest(r)) {
              this.expect(t);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(x.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(i, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(t) {
      return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      let t = this.startNode(), {
        type: r,
        startLoc: i
      } = this.state;
      return r === 21 ? this.parseBindingRestProperty(t) : (r === 138 ? (this.expectPlugin("destructuringPrivate", i), this.classScope.usePrivateName(
      this.state.value, i), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = !1, this.parseObjPropValue(t, i, !1, !1,
      !0, !1));
    }
    parseAssignableListItem(t, r) {
      let i = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(i, t);
      let n = this.parseMaybeDefault(i.loc.start, i);
      return r.length && (i.decorators = r), n;
    }
    parseAssignableListItemTypes(t, r) {
      return t;
    }
    parseMaybeDefault(t, r) {
      var i, n;
      if ((i = t) != null || (t = this.state.startLoc), r = (n = r) != null ? n : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(t);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(t, r, i) {
      return uV({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, t);
    }
    isOptionalMemberExpression(t) {
      return t.type === "OptionalMemberExpression";
    }
    checkLVal(t, {
      in: r,
      binding: i = 64,
      checkClashes: n = !1,
      strictModeChanged: a = !1,
      hasParenthesizedAncestor: o = !1
    }) {
      var l;
      let u = t.type;
      if (this.isObjectMethod(t)) return;
      let c = this.isOptionalMemberExpression(t);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(x.InvalidLhsOptionalChaining,
        t, {
          ancestor: r
        })), i !== 64 && this.raise(x.InvalidPropertyBindingPattern, t);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(t, i, a);
        let {
          name: C
        } = t;
        n && (n.has(C) ? this.raise(x.ParamDupe, t) : n.add(C));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = t.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", i);
      if (p === !0) return;
      if (p === !1) {
        let C = i === 64 ? x.InvalidLhs : x.InvalidLhsBinding;
        this.raise(C, t, {
          ancestor: r
        });
        return;
      }
      let [g, P] = Array.isArray(p) ? p : [p, u === "ParenthesizedExpression"], A = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r;
      for (let C of [].concat(t[g]))
        C && this.checkLVal(C, {
          in: A,
          binding: i,
          checkClashes: n,
          strictModeChanged: a,
          hasParenthesizedAncestor: P
        });
    }
    checkIdentifier(t, r, i = !1) {
      this.state.strict && (i ? qy(t.name, this.inModule) : Ry(t.name)) && (r === 64 ? this.raise(x.StrictEvalArguments, t, {
        referenceName: t.name
      }) : this.raise(x.StrictEvalArgumentsBinding, t, {
        bindingName: t.name
      })), r & 8192 && t.name === "let" && this.raise(x.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
    }
    declareNameFromIdentifier(t, r) {
      this.scope.declareName(t.name, r, t.loc.start);
    }
    checkToRestConversion(t, r) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(x.InvalidRestAssignmentPattern, t);
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? x.RestTrailingComma : x.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, cV = /* @__PURE__ */ s((e, t) => hasOwnProperty.call(e, t) && e[t], "getOwn");
  function pV(e) {
    if (e == null)
      throw new Error(`Unexpected ${e} value.`);
    return e;
  }
  s(pV, "nonNull");
  function Cy(e) {
    if (!e)
      throw new Error("Assert fail");
  }
  s(Cy, "assert");
  var J = Gt`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ s(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ s(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ s(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ s(({
      modifier: e
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ s(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ s(({
      token: e
    }) => `'${e}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ s(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ s(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ s(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ s(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ s(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ s(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ s(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`, "UnsupportedSignatureParameterKind")
  });
  function fV(e) {
    switch (e) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  s(fV, "keywordTypeFromName");
  function Iy(e) {
    return e === "private" || e === "public" || e === "protected";
  }
  s(Iy, "tsIsAccessModifier");
  function hV(e) {
    return e === "in" || e === "out";
  }
  s(hV, "tsIsVarianceAnnotations");
  var dV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: J.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: J.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: J.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return Hu;
    }
    tsIsIdentifier() {
      return ve(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, i) {
      if (!ve(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let n = this.state.value;
      if (r.indexOf(n) !== -1) {
        if (i && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return n;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: i,
      stopOnStartOfClassStaticBlock: n,
      errorTemplate: a = J.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ s((c, p, g, P) => {
        p === g && o[P] && this.raise(J.InvalidModifiersOrder, c, {
          orderedModifiers: [g, P]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ s((c, p, g, P) => {
        (o[g] && p === P || o[P] && p === g) && this.raise(J.IncompatibleModifiers, c, {
          modifiers: [g, P]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(i ?? []), n);
        if (!p) break;
        Iy(p) ? o.accessibility ? this.raise(J.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : hV(p) ? (o[p] && this.raise(J.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(J.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), i != null && i.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, i) {
      let n = [];
      for (; !this.tsIsListTerminator(r); )
        n.push(i());
      return n;
    }
    tsParseDelimitedList(r, i, n) {
      return pV(this.tsParseDelimitedListWorker(r, i, !0, n));
    }
    tsParseDelimitedListWorker(r, i, n, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = i();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        n && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, i, n, a, o) {
      a || (n ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, i, o);
      return n ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(J.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let i = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let n = this.startNodeAtNode(i);
        n.left = i, n.right = this.parseIdentifier(r), i = this.finishNode(n, "TSQualifiedName");
      }
      return i;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let i = this.startNodeAtNode(r);
      return i.parameterName = r, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let i = this.startNode();
      return r(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(
      29), this.finishNode(i, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let i = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let n = {
        value: -1
      };
      return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, n), i.params.
      length === 0 && this.raise(J.EmptyTypeParameters, i), n.value !== -1 && this.addExtra(i, "trailingComma", n.value), this.finishNode(i,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, i) {
      let n = r === 19, a = "parameters", o = "typeAnnotation";
      i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[a] = this.tsParseBindingListForSignature(),
      n ? i[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (i[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let i of r) {
        let {
          type: n
        } = i;
        (n === "AssignmentPattern" || n === "TSParameterProperty") && this.raise(J.UnsupportedSignatureParameterKind, i, {
          type: n
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, i) {
      return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), ve(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let i = this.parseIdentifier();
      i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), r.parameters = [i];
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, i) {
      this.eat(17) && (r.optional = !0);
      let n = r;
      if (this.match(10) || this.match(47)) {
        i && this.raise(J.ReadonlyForMethodSignature, r);
        let a = n;
        a.kind && this.match(47) && this.raise(J.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(x.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(J.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(x.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(J.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.optional &&
            this.raise(J.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(J.SetAccesorCannotHaveRestParameter,
            this.state.curPosition());
          }
          a[l] && this.raise(J.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = n;
        i && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let n = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(n, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let i = this.tsTryParseIndexSignature(r);
      return i || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let i = !1;
      return r.elementTypes.forEach((n) => {
        let {
          type: a
        } = n;
        i && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && n.optional) && this.raise(J.OptionalTypeBeforeRequired,
        n), i || (i = a === "TSNamedTupleMember" && n.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, i = this.eat(21), n, a, o, l, c = Dt(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        n = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let p = this.state.startLoc, g = this.state.value, P = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (n = !0, a = this.createIdentifier(this.startNodeAt(p), g), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (n = !1, l = P, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), n = this.eat(14);
      if (n) {
        let p;
        a ? (p = this.startNodeAtNode(a), p.optional = o, p.label = a, p.elementType = l, this.eat(17) && (p.optional = !0, this.raise(J.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (p = this.startNodeAtNode(l), p.optional = o, this.raise(J.InvalidTupleMemberLabel, l), p.label = l,
        p.elementType = this.tsParseType()), l = this.finishNode(p, "TSNamedTupleMember");
      } else if (o) {
        let p = this.startNodeAtNode(l);
        p.typeAnnotation = l, l = this.finishNode(p, "TSOptionalType");
      }
      if (i) {
        let p = this.startNodeAt(r);
        p.typeAnnotation = l, l = this.finishNode(p, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, i) {
      let n = this.startNode();
      return r === "TSConstructorType" && (n.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, n)), this.finishNode(n, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), i = this.lookahead();
            return i.type !== 134 && i.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (ve(r) || r === 88 || r === 84) {
            let i = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : fV(this.state.value);
            if (i !== void 0 && this.lookaheadCharCode() !== 46) {
              let n = this.startNode();
              return this.next(), this.finishNode(n, i);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let i = this.startNodeAtNode(r);
          i.elementType = r, this.expect(3), r = this.finishNode(i, "TSArrayType");
        } else {
          let i = this.startNodeAtNode(r);
          i.objectType = r, i.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(i, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), i = this.state.value;
      return this.next(), r.operator = i, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(J.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let i = this.startNode();
      return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(i, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return _q(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, i, n) {
      let a = this.startNode(), o = this.eat(n), l = [];
      do
        l.push(i());
      while (this.eat(n));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (ve(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === i;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === i;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let i = this.startNode();
        this.expect(r);
        let n = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (n.parameterName = u, n.asserts = !0, n.typeAnnotation = null, u = this.finishNode(n, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, n), u.asserts = !0), i.typeAnnotation = u, this.finishNode(i, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (n.parameterName = this.parseIdentifier(), n.asserts = a, n.typeAnnotation = null, i.typeAnnotation = this.finishNode(n,
          "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
        let l = this.tsParseTypeAnnotation(!1);
        return n.parameterName = o, n.typeAnnotation = l, n.asserts = a, i.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(
        i, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !ve(this.state.type) && !this.match(78) ? !1 : (r && this.raise(x.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, i = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), i.typeAnnotation = this.tsParseType();
      }), this.finishNode(i, "TSTypeAnnotation");
    }
    tsParseType() {
      Cy(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let i = this.startNodeAtNode(r);
      return i.checkType = r, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(i, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(J.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let i = this.state.startLoc, n = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return n.length || this.raise(J.EmptyHeritageClauseType, i, {
        token: r
      }), n;
    }
    tsParseInterfaceDeclaration(r, i = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), i.declare && (r.declare = !0), ve(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(J.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let n = this.startNode();
      return n.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(n, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let i = this.startNode();
          return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let i = this.state.context;
      this.state.context = [i[0]];
      try {
        return r();
      } finally {
        this.state.context = i;
      }
    }
    tsInType(r) {
      let i = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = i;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, i = {}) {
      return i.const && (r.const = !0), i.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, i = !1) {
      if (r.id = this.parseIdentifier(), i || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let n = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(n, !0), r.body = n;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, i, n) {
      r.isExport = n || !1, r.id = i || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(J.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let i = this.state.clone(), n = r();
      return this.state = i, n;
    }
    tsTryParseAndCatch(r) {
      let i = this.tryParse((n) => r() || n());
      if (!(i.aborted || !i.node))
        return i.error && (this.state = i.failState), i.node;
    }
    tsTryParse(r) {
      let i = this.state.clone(), n = r();
      if (n !== void 0 && n !== !1)
        return n;
      this.state = i;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let i = this.state.type, n;
      return this.isContextual(100) && (i = 74, n = "let"), this.tsInAmbientContext(() => {
        switch (i) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, n || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (ve(i))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, i, n) {
      switch (i.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = i, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, i.name, !1, n);
      }
    }
    tsParseDeclaration(r, i, n, a) {
      switch (i) {
        case "abstract":
          if (this.tsCheckLineTerminator(n) && (this.match(80) || ve(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(n)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (ve(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(n) && ve(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(n) && ve(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let i = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let n = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = i, !!n)
        return super.parseArrowExpression(n, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(J.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      we.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Dq(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, i) {
      let n = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(J.UnexpectedParameterModifier, n);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let g = this.startNodeAt(n);
        return i.length && (g.decorators = i), o && (g.accessibility = o), u && (g.readonly = u), l && (g.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(J.UnsupportedParameterPropertyKind, g), g.parameter = p, this.finishNode(g, "TSParamete\
rProperty");
      }
      return i.length && (c.decorators = i), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let i of r.params)
        i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(J.PatternIsOptional, i);
    }
    setArrowFunctionParameters(r, i, n) {
      super.setArrowFunctionParameters(r, i, n), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, i, n = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(J.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, n) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, i, n));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((i) => {
        i?.type === "TSTypeCastExpression" && this.raise(J.UnexpectedTypeAnnotation, i.typeAnnotation);
      });
    }
    toReferencedList(r, i) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, i, n, a) {
      let o = super.parseArrayLike(r, i, n, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, i, n, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(i);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (n)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!n && this.atPossibleAsyncArrow(r)) {
            let P = this.tsTryParseGenericAsyncArrowFunction(i);
            if (P)
              return P;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (Xn(this.state.type)) {
            let P = super.parseTaggedTemplateExpression(r, i, a);
            return P.typeParameters = c, P;
          }
          if (!n && this.eat(10)) {
            let P = this.startNodeAt(i);
            return P.callee = r, P.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(P.arguments), P.typeParameters =
            c, a.optionalChainMember && (P.optional = o), this.finishCallExpression(P, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && ku(p) && !this.hasPrecedingLineBreak())
            return;
          let g = this.startNodeAt(i);
          return g.expression = r, g.typeParameters = c, this.finishNode(g, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          J.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, i, n, a);
    }
    parseNewCallee(r) {
      var i;
      super.parseNewCallee(r);
      let {
        callee: n
      } = r;
      n.type === "TSInstantiationExpression" && !((i = n.extra) != null && i.parenthesized) && (r.typeParameters = n.typeParameters, r.callee =
      n.expression);
    }
    parseExprOp(r, i, n) {
      let a;
      if (Un(58) > n && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(i);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(x.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, i, n);
      }
      return super.parseExprOp(r, i, n);
    }
    checkReservedWord(r, i, n, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, i, n, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(J.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let i = this.lookaheadCharCode();
        return r ? i === 123 || i === 42 : i !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, n, a) {
      super.applyImportPhase(r, i, n, a), i ? r.exportKind = n === "type" ? "type" : "value" : r.importKind = n === "type" || n === "typeof" ?
      n : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let i;
      if (ve(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let n = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, n);
        i = super.parseImportSpecifiersAndAfter(r, n);
      } else
        i = super.parseImport(r);
      return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(J.TypeImportCannotSpecifyDefaultAndNamed,
      i), i;
    }
    parseExport(r, i) {
      if (this.match(83)) {
        this.next();
        let n = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? n = this.parseMaybeImportPhase(r, !1) : r.importKind = "value", this.
        tsParseImportEqualsDeclaration(r, n, !0);
      } else if (this.eat(29)) {
        let n = r;
        return n.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(n, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let n = r;
        return this.expectContextual(128), n.id = this.parseIdentifier(), this.semicolon(), this.finishNode(n, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, i);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, i, n = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, i, n || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (i !== "const" || l.typeAnnotation ? this.raise(J.InitializerNotAllowedInAmbientContext, u) : yV(u, this.hasPlugin("estree")) ||
        this.raise(J.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, i) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let n = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(n, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let n = this.tsParseInterfaceDeclaration(this.startNode());
        if (n) return n;
      }
      return super.parseStatementContent(r, i);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, i) {
      return i.some((n) => Iy(n) ? r.accessibility === n : !!r[n]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, i, n) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: J.InvalidModifierOnTypeParameterPositions
      }, i);
      let o = /* @__PURE__ */ s(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, a) && this.raise(J.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, i)) : this.parseClassMemberWithIsStatic(r, i, n, !!i.static);
      }, "callParseClassMemberWithIsStatic");
      i.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, i, n, a) {
      let o = this.tsTryParseIndexSignature(i);
      if (o) {
        r.body.push(o), i.abstract && this.raise(J.IndexSignatureHasAbstract, i), i.accessibility && this.raise(J.IndexSignatureHasAccessibility,
        i, {
          modifier: i.accessibility
        }), i.declare && this.raise(J.IndexSignatureHasDeclare, i), i.override && this.raise(J.IndexSignatureHasOverride, i);
        return;
      }
      !this.state.inAbstractClass && i.abstract && this.raise(J.NonAbstractClassHasAbstractMethod, i), i.override && (n.hadSuperClass || this.
      raise(J.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(r, i, n, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(J.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(J.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, i, n) {
      return (i.type === "Identifier" ? this.tsParseExpressionStatement(r, i, n) : void 0) || super.parseExpressionStatement(r, i, n);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, i, n) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, i, n);
      let a = this.tryParse(() => super.parseConditional(r, i));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(n, a.error), r);
    }
    parseParenItem(r, i) {
      if (r = super.parseParenItem(r, i), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let n = this.startNodeAt(i);
        return n.expression = r, n.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let i = this.state.startLoc, n = this.eatContextual(125);
      if (n && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(J.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = ve(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || n) && (r.exportKind = "type"), n && (this.resetStartLocation(
      o, i), o.declare = !0), o) : null;
    }
    parseClassId(r, i, n, a) {
      if ((!i || n) && this.isContextual(113))
        return;
      super.parseClassId(r, i, n, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let i = this.tsTryParseTypeAnnotation();
      i && (r.typeAnnotation = i);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(J.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: i
        } = r;
        this.raise(J.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: i.type === "Identifier" && !r.computed ? i.name : `[${this.input.slice(i.start, i.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(J.PrivateElementHasAbstract, r), r.accessibility && this.raise(J.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(J.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, i, n, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(J.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = i;
      c && (p === "get" || p === "set") && this.raise(J.DeclareAccessor, i, {
        kind: p
      }), u && (i.typeParameters = u), super.pushClassMethod(r, i, n, a, o, l);
    }
    pushClassPrivateMethod(r, i, n, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (i.typeParameters = o), super.pushClassPrivateMethod(r, i, n, a);
    }
    declareClassPrivateMethodInScope(r, i) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !r.value.body || super.declareClassPrivateMethodInScope(r, i));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, i, n, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, i, n, a, o, l, u);
    }
    parseFunctionParams(r, i) {
      let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      n && (r.typeParameters = n), super.parseFunctionParams(r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let n = this.tsTryParseTypeAnnotation();
      n && (r.id.typeAnnotation = n, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, i);
    }
    parseMaybeAssign(r, i) {
      var n, a, o, l, u;
      let c, p, g;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, i), c), !p.error) return p.node;
        let {
          context: C
        } = this.state, _ = C[C.length - 1];
        (_ === we.j_oTag || _ === we.j_expr) && C.pop();
      }
      if (!((n = p) != null && n.error) && !this.match(47))
        return super.parseMaybeAssign(r, i);
      (!c || c === this.state) && (c = this.state.clone());
      let P, A = this.tryParse((C) => {
        var _, k;
        P = this.tsParseTypeParameters(this.tsParseConstModifier);
        let O = super.parseMaybeAssign(r, i);
        return (O.type !== "ArrowFunctionExpression" || (_ = O.extra) != null && _.parenthesized) && C(), ((k = P) == null ? void 0 : k.params.
        length) !== 0 && this.resetStartLocationFromNode(O, P), O.typeParameters = P, O;
      }, c);
      if (!A.error && !A.aborted)
        return P && this.reportReservedArrowTypeParam(P), A.node;
      if (!p && (Cy(!this.hasPlugin("jsx")), g = this.tryParse(() => super.parseMaybeAssign(r, i), c), !g.error))
        return g.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (A.node)
        return this.state = A.failState, P && this.reportReservedArrowTypeParam(P), A.node;
      if ((o = g) != null && o.node)
        return this.state = g.failState, g.node;
      throw ((l = p) == null ? void 0 : l.error) || A.error || ((u = g) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var i;
      r.params.length === 1 && !r.params[0].constraint && !((i = r.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(J.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, i) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse((n) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && n(), a;
        });
        if (i.aborted) return;
        i.thrown || (i.error && (this.state = i.failState), r.returnType = i.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, i) {
      if (!(i & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.resetEndLocation(r), r;
    }
    isAssignable(r, i) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, i);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, i);
      }
    }
    toAssignable(r, i = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, i);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          i ? this.expressionScope.recordArrowParameterBindingError(J.UnexpectedTypeCastInParameter, r) : this.raise(J.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, i);
          break;
        case "AssignmentExpression":
          !i && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, i);
      }
    }
    toAssignableParenthesizedExpression(r, i) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, i);
          break;
        default:
          super.toAssignable(r, i);
      }
    }
    checkToRestConversion(r, i) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, i);
      }
    }
    isValidLVal(r, i, n) {
      return cV({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (n !== 64 || !i) && ["expression", !0],
        TSSatisfiesExpression: (n !== 64 || !i) && ["expression", !0],
        TSTypeAssertion: (n !== 64 || !i) && ["expression", !0]
      }, r) || super.isValidLVal(r, i, n);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let n = super.parseMaybeDecoratorArguments(r);
          return n.typeParameters = i, n;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, i) {
      let n = super.parseMaybeDefault(r, i);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(J.TypeAnnotationAfterAssign,
      n.typeAnnotation), n;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, i, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, i, n);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        i && (r.typeParameters = i);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let i = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? i + 1 : i;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let i = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = i;
      }
    }
    parseClass(r, i, n) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, i, n);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, i) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(J.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, i, n, a, o, l, u) {
      let c = super.parseMethod(r, i, n, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: g
        } = c;
        this.raise(J.AbstractMethodHasImplementation, c, {
          methodName: g.type === "Identifier" && !c.computed ? g.name : `[${this.input.slice(g.start, g.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, i, n, a) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, n), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, i, n, a));
    }
    parseImportSpecifier(r, i, n, a, o) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, n), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, i, n, a, n ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, i, n) {
      let a = i ? "imported" : "local", o = i ? "local" : "exported", l = r[a], u, c = !1, p = !0, g = l.loc.start;
      if (this.isContextual(93)) {
        let A = this.parseIdentifier();
        if (this.isContextual(93)) {
          let C = this.parseIdentifier();
          Dt(this.state.type) ? (c = !0, l = A, u = i ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = C, p = !1);
        } else Dt(this.state.type) ? (p = !1, u = i ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = A);
      } else Dt(this.state.type) && (c = !0, i ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && n && this.raise(i ? J.TypeModifierIsUsedInTypeImports : J.TypeModifierIsUsedInTypeExports, g), r[a] = l, r[o] = u;
      let P = i ? "importKind" : "exportKind";
      r[P] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = i ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = zt(r[a])), i && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function mV(e) {
    if (e.type !== "MemberExpression") return !1;
    let {
      computed: t,
      property: r
    } = e;
    return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : $y(e.object);
  }
  s(mV, "isPossiblyLiteralEnum");
  function yV(e, t) {
    var r;
    let {
      type: i
    } = e;
    if ((r = e.extra) != null && r.parenthesized)
      return !1;
    if (t) {
      if (i === "Literal") {
        let {
          value: n
        } = e;
        if (typeof n == "string" || typeof n == "boolean")
          return !0;
      }
    } else if (i === "StringLiteral" || i === "BooleanLiteral")
      return !0;
    return !!(Jy(e, t) || TV(e, t) || i === "TemplateLiteral" && e.expressions.length === 0 || mV(e));
  }
  s(yV, "isValidAmbientConstInitializer");
  function Jy(e, t) {
    return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLite\
ral";
  }
  s(Jy, "isNumber");
  function TV(e, t) {
    if (e.type === "UnaryExpression") {
      let {
        operator: r,
        argument: i
      } = e;
      if (r === "-" && Jy(i, t))
        return !0;
    }
    return !1;
  }
  s(TV, "isNegativeNumber");
  function $y(e) {
    return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : $y(e.object);
  }
  s($y, "isUncomputedMemberExpressionChain");
  var wy = Gt`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), gV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let i = this.startNode();
        return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        i, r);
      }
    }
    finishPlaceholder(r, i) {
      let n = !!(r.expectedNode && r.type === "Placeholder");
      return r.expectedNode = i, n ? r : this.finishNode(r, "Placeholder");
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, i, n, a) {
      r !== void 0 && super.checkReservedWord(r, i, n, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, i, n) {
      return r === "Placeholder" || super.isValidLVal(r, i, n);
    }
    toAssignable(r, i) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, i);
    }
    chStartsBindingIdentifier(r, i) {
      return !!(super.chStartsBindingIdentifier(r, i) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, i) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, i);
    }
    parseExpressionStatement(r, i) {
      var n;
      if (i.type !== "Placeholder" || (n = i.extra) != null && n.parenthesized)
        return super.parseExpressionStatement(r, i);
      if (this.match(14)) {
        let a = r;
        return a.label = this.finishPlaceholder(i, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(a, "LabeledStatement");
      }
      return this.semicolon(), r.name = i.name, this.finishPlaceholder(r, "Statement");
    }
    parseBlock(r, i, n) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, i, n);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, i, n) {
      let a = i ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (n || !i)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(wy.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, i, n);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, i) {
      let n = this.parsePlaceholder("Identifier");
      if (!n) return super.parseExport(r, i);
      if (!this.isContextual(98) && !this.match(12))
        return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(n, "Declaration"), this.finishNode(r, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let a = this.startNode();
      return a.exported = n, r.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(r, i);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(yr(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, i) {
      var n;
      return (n = r.specifiers) != null && n.length ? !0 : super.maybeParseExportDefaultSpecifier(r, i);
    }
    checkExport(r) {
      let {
        specifiers: i
      } = r;
      i != null && i.length && (r.specifiers = i.filter((n) => n.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = i;
    }
    parseImport(r) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let n = this.startNodeAtNode(i);
      return n.local = i, r.specifiers.push(this.finishNode(n, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(wy.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), bV = /* @__PURE__ */ s((e) => class extends e {
    static {
      s(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, i = this.startNode();
        if (this.next(), ve(this.state.type)) {
          let n = this.parseIdentifierName(), a = this.createIdentifier(i, n);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic");
  function Je(e, t) {
    let [r, i] = typeof t == "string" ? [t, {}] : t, n = Object.keys(i), a = n.length === 0;
    return e.some((o) => {
      if (typeof o == "string")
        return a && o === r;
      {
        let [l, u] = o;
        if (l !== r)
          return !1;
        for (let c of n)
          if (u[c] !== i[c])
            return !1;
        return !0;
      }
    });
  }
  s(Je, "hasPlugin");
  function mr(e, t, r) {
    let i = e.find((n) => Array.isArray(n) ? n[0] === t : n === t);
    return i && Array.isArray(i) && i.length > 1 ? i[1][r] : null;
  }
  s(mr, "getPluginOption");
  var Oy = ["minimal", "fsharp", "hack", "smart"], Ny = ["^^", "@@", "^", "%", "#"], _y = ["hash", "bar"];
  function SV(e) {
    if (Je(e, "decorators")) {
      if (Je(e, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let t = mr(e, "decorators", "decoratorsBeforeExport");
      if (t != null && typeof t != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let r = mr(e, "decorators", "allowCallParenthesized");
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Je(e, "flow") && Je(e, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Je(e, "placeholders") && Je(e, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Je(e, "pipelineOperator")) {
      let t = mr(e, "pipelineOperator", "proposal");
      if (!Oy.includes(t)) {
        let i = Oy.map((n) => `"${n}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
      }
      let r = Je(e, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (t === "hack") {
        if (Je(e, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Je(e, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let i = mr(e, "pipelineOperator", "topicToken");
        if (!Ny.includes(i)) {
          let n = Ny.map((a) => `"${a}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}\
.`);
        }
        if (i === "#" && r)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { s\
yntaxType: "hash"}]`.');
      } else if (t === "smart" && r)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}\
]`.');
    }
    if (Je(e, "moduleAttributes")) {
      if (Je(e, "importAssertions") || Je(e, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (mr(e, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (Je(e, "importAssertions") && Je(e, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Je(e, "recordAndTuple") && mr(e, "recordAndTuple", "syntaxType") != null && !_y.includes(mr(e, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + _y.map((t) => `'${t}'`).join(", "));
    if (Je(e, "asyncDoExpressions") && !Je(e, "doExpressions")) {
      let t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw t.missingPlugins = "doExpressions", t;
    }
    if (Je(e, "optionalChainingAssign") && mr(e, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  s(SV, "validatePlugins");
  var Hy = {
    estree: xq,
    jsx: lV,
    flow: aV,
    typescript: dV,
    v8intrinsic: bV,
    placeholders: gV
  }, xV = Object.keys(Hy), Nu = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function EV(e) {
    if (e == null)
      return Object.assign({}, Nu);
    if (e.annexB != null && e.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let t = {};
    for (let i of Object.keys(Nu)) {
      var r;
      t[i] = (r = e[i]) != null ? r : Nu[i];
    }
    return t;
  }
  s(EV, "getOptions");
  var zu = class extends Gu {
    static {
      s(this, "ExpressionParser");
    }
    checkProto(t, r, i, n) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return;
      let a = t.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(x.RecordNoProto, a);
          return;
        }
        i.used && (n ? n.doubleProtoLoc === null && (n.doubleProtoLoc = a.loc.start) : this.raise(x.DuplicateProto, a)), i.used = !0;
      }
    }
    shouldExitDescending(t, r) {
      return t.type === "ArrowFunctionExpression" && t.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let t = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors,
      this.options.tokens && (t.tokens = this.tokens), t;
    }
    parseExpression(t, r) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(t) {
      let r = this.state.startLoc, i = this.parseMaybeAssign(t);
      if (this.match(12)) {
        let n = this.startNodeAt(r);
        for (n.expressions = [i]; this.eat(12); )
          n.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(n.expressions), this.finishNode(n, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(t, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
    }
    parseMaybeAssignAllowIn(t, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, r));
    }
    setOptionalParametersError(t, r) {
      var i;
      t.optionalParametersLoc = (i = r?.loc) != null ? i : this.state.startLoc;
    }
    parseMaybeAssign(t, r) {
      let i = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, i)), l;
      }
      let n;
      t ? n = !1 : (t = new Ti(), n = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || ve(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(t);
      if (r && (o = r.call(this, o, i)), Cq(this.state.type)) {
        let l = this.startNodeAt(i), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = i.index;
          t.doubleProtoLoc != null && t.doubleProtoLoc.index >= c && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.
          index >= c && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          t), t.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, {
          in: this.finishNode(l, "AssignmentExpression")
        }), l;
      } else n && this.checkExpressionErrors(t, !0);
      return o;
    }
    parseMaybeConditional(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprOps(t);
      return this.shouldExitDescending(n, i) ? n : this.parseConditional(n, r, t);
    }
    parseConditional(t, r, i) {
      if (this.eat(17)) {
        let n = this.startNodeAt(r);
        return n.test = t, n.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), n.alternate = this.parseMaybeAssign(), this.finishNode(
        n, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(n, i) ? n : this.parseExprOp(n, r, -1);
    }
    parseExprOp(t, r, i) {
      if (this.isPrivateName(t)) {
        let a = this.getPrivateNameSV(t);
        (i >= Un(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(x.PrivateInExpectedIn, t, {
          identifierName: a
        }), this.classScope.usePrivateName(a, t.loc.start);
      }
      let n = this.state.type;
      if (wq(n) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Un(n);
        if (a > i) {
          if (n === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, r);
          }
          let o = this.startNodeAt(r);
          o.left = t, o.operator = this.state.value;
          let l = n === 41 || n === 42, u = n === 40;
          if (u && (a = Un(42)), this.next(), n === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(x.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(n, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(x.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, i);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, r) {
      let i = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(x.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), i);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(t, r);
      }
    }
    parseExprOpBaseRightExpr(t, r) {
      let i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, kq(t) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var t;
      let {
        startLoc: r
      } = this.state, i = this.parseMaybeAssign();
      return mq.has(i.type) && !((t = i.extra) != null && t.parenthesized) && this.raise(x.PipeUnparenthesizedBody, r, {
        type: i.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipeTopicUnused, r), i;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(x.UnexpectedTokenUnaryExponentiation, t.argument);
    }
    parseMaybeUnary(t, r) {
      let i = this.state.startLoc, n = this.isContextual(96);
      if (n && this.isAwaitAllowed()) {
        this.next();
        let u = this.parseAwait(i);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (Nq(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(x.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(x.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, t);
      if (n) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? ku(u) : ku(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(x.AwaitNotInAsyncContext, i), this.parseAwait(i);
      }
      return l;
    }
    parseUpdate(t, r, i) {
      if (r) {
        let o = t;
        return this.checkLVal(o.argument, {
          in: this.finishNode(o, "UpdateExpression")
        }), t;
      }
      let n = this.state.startLoc, a = this.parseExprSubscripts(i);
      if (this.checkExpressionErrors(i, !1)) return a;
      for (; Oq(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(n);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, {
          in: a = this.finishNode(o, "UpdateExpression")
        });
      }
      return a;
    }
    parseExprSubscripts(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, n = this.parseExprAtom(t);
      return this.shouldExitDescending(n, i) ? n : this.parseSubscripts(n, r);
    }
    parseSubscripts(t, r, i) {
      let n = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(t),
        stop: !1
      };
      do
        t = this.parseSubscript(t, r, i, n), n.maybeAsyncArrow = !1;
      while (!n.stop);
      return t;
    }
    parseSubscript(t, r, i, n) {
      let {
        type: a
      } = this.state;
      if (!i && a === 15)
        return this.parseBind(t, r, i, n);
      if (Xn(a))
        return this.parseTaggedTemplateExpression(t, r, n);
      let o = !1;
      if (a === 18) {
        if (i && (this.raise(x.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return n.stop = !0, t;
        n.optionalChainMember = o = !0, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, r, n, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(t, r, n, l, o) : (n.stop = !0, t);
      }
    }
    parseMember(t, r, i, n, a) {
      let o = this.startNodeAt(r);
      return o.object = t, o.computed = n, n ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t.type === "Super" &&
      this.raise(x.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), i.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(t, r, i, n) {
      let a = this.startNodeAt(r);
      return a.object = t, this.next(), a.callee = this.parseNoCallExpr(), n.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, i);
    }
    parseCoverCallAndAsyncArrowHead(t, r, i, n) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = t;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = i;
      u && (this.expressionScope.enter(Qq()), o = new Ti()), c && (l.optional = n), n ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !n ? (i.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(t, r) {
      this.toReferencedListDeep(t.arguments, r);
    }
    parseTaggedTemplateExpression(t, r, i) {
      let n = this.startNodeAt(r);
      return n.tag = t, n.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(x.OptionalChainingNoTemplate, r), this.finishNode(
      n, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end -
      t.start === 5 && t.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(t, r) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 ||
        t.arguments.length > 2)
          this.raise(x.ImportCallArity, t, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let i of t.arguments)
            i.type === "SpreadElement" && this.raise(x.ImportCallSpreadArgument, i);
      return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, r, i, n, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(t)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          x.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, i));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, r) {
      var i;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (i = r.extra) == null ?
      void 0 : i.trailingCommaLoc), r.innerComments && hs(t, r.innerComments), r.callee.trailingComments && hs(t, r.callee.trailingComments),
      t;
    }
    parseNoCallExpr() {
      let t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, !0);
    }
    parseExprAtom(t) {
      let r, i = null, {
        type: n
      } = this.state;
      switch (n) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(x.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, t);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          i = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(x.UnsupportedBind, a);
        }
        case 138:
          return this.raise(x.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          Ht(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (ve(n)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (ve(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, r) {
      let i = this.getPluginOption("pipelineOperator", "proposal");
      if (i)
        return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = ht(this.state.endLoc, -1),
        this.parseTopicReference(i);
      this.unexpected();
    }
    parseTopicReference(t) {
      let r = this.startNode(), i = this.state.startLoc, n = this.state.type;
      return this.next(), this.finishTopicReference(r, i, t, n);
    }
    finishTopicReference(t, r, i, n) {
      if (this.testTopicReferenceConfiguration(i, r, n)) {
        let a = i === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(i === "smart" ? x.PrimaryTopicNotAllowed : x.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(t, a);
      } else
        throw this.raise(x.PipeTopicUnconfiguredToken, r, {
          token: yr(n)
        });
    }
    testTopicReferenceConfiguration(t, r, i) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: yr(i)
          }]);
        case "smart":
          return i === 27;
        default:
          throw this.raise(x.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(Wn(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(x.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(t, r, !0);
    }
    parseDo(t, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
      let i = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(),
      this.state.labels = i, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      let t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(x.SuperNotAllowed,
      t) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(x.UnexpectedSuper, t), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(x.UnsupportedSuper, t), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      let t = this.startNode(), r = this.startNodeAt(ht(this.state.startLoc, 1)), i = this.state.value;
      return this.next(), t.id = this.createIdentifier(r, i), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(t, r, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, r, i) {
      t.meta = r;
      let n = this.state.containsEsc;
      return t.property = this.parseIdentifier(!0), (t.property.name !== i || n) && this.raise(x.UnsupportedMetaProperty, t.property, {
        target: r.name,
        onlyValidPropertyName: i
      }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaProperty(t) {
      let r = this.createIdentifier(this.startNodeAtNode(t), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(x.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let i = this.isContextual(105);
        if (i || this.unexpected(), this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(x.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), t.phase = i ? "source" : "defer", this.parseImportCall(t);
      }
      return this.parseMetaProperty(t, r, "meta");
    }
    parseLiteralAtNode(t, r, i) {
      return this.addExtra(i, "rawValue", t), this.addExtra(i, "raw", this.input.slice(i.start, this.state.end)), i.value = t, this.next(), this.
      finishNode(i, r);
    }
    parseLiteral(t, r) {
      let i = this.startNode();
      return this.parseLiteralAtNode(t, r, i);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      let r = this.parseLiteral(t.value, "RegExpLiteral");
      return r.pattern = t.pattern, r.flags = t.flags, r;
    }
    parseBooleanLiteral(t) {
      let r = this.startNode();
      return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      let r = this.state.startLoc, i;
      this.next(), this.expressionScope.enter(zq());
      let n = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new Ti(), c = !0, p, g;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          g = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let C = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), C)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let P = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = n, this.state.inFSharpPipelineDirectBody = a;
      let A = this.startNodeAt(r);
      return t && this.shouldParseArrow(l) && (A = this.parseArrow(A)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(A, l, !1), A) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), g && this.unexpected(g), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (i = this.startNodeAt(o), i.expressions = l, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i,
      P)) : i = l[0], this.wrapParenthesis(r, i));
    }
    wrapParenthesis(t, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.
        state.lastTokEndLoc.index), r;
      let i = this.startNodeAt(t);
      return i.expression = r, this.finishNode(i, "ParenthesizedExpression");
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, r) {
      return t;
    }
    parseNewOrNewTarget() {
      let t = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        let i = this.parseMetaProperty(t, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(x.UnexpectedNewTarget,
        i), i;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), t.arguments = r;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      let r = this.match(83), i = this.parseNoCallExpr();
      t.callee = i, r && (i.type === "Import" || i.type === "ImportExpression") && this.raise(x.ImportCallNotNewExpression, i);
    }
    parseTemplateElement(t) {
      let {
        start: r,
        startLoc: i,
        end: n,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(ht(i, 1));
      a === null && (t || this.raise(x.InvalidEscapeSequenceTemplate, ht(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = n + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let g = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(g, ht(this.state.lastTokEndLoc, c)), g;
    }
    parseTemplate(t) {
      let r = this.startNode();
      r.expressions = [];
      let i = this.parseTemplateElement(t);
      for (r.quasis = [i]; !i.tail; )
        r.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.quasis.push(i = this.parseTemplateElement(t));
      return this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(t); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(n), this.checkProto(p, i, o, n)), i && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(x.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : i && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(x.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let i = this.startNode(), n = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (i.decorators = r, r = []), i.method = !1, t && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(i);
      let u = this.state.containsEsc, c = this.parsePropertyName(i, t);
      if (!l && !u && this.maybeAsyncOrAccessorProp(i)) {
        let p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (n = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        i)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), i.kind = p, this.match(55) && (l = !0, this.
        raise(x.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(i));
      }
      return this.parseObjPropValue(i, o, l, n, !1, a, t);
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var r;
      let i = this.getGetterSetterExpectedParamCount(t), n = this.getObjectOrClassMethodParams(t);
      n.length !== i && this.raise(t.kind === "get" ? x.BadGetterArity : x.BadSetterArity, t), t.kind === "set" && ((r = n[n.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(x.BadSetterRestParameter, t);
    }
    parseObjectMethod(t, r, i, n, a) {
      if (a) {
        let o = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (i || r || this.match(10))
        return n && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, i, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(t, r, i, n) {
      if (t.shorthand = !1, this.eat(14))
        return t.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n), this.finishNode(t, "ObjectProper\
ty");
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), i)
          t.value = this.parseMaybeDefault(r, zt(t.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          n != null ? n.shorthandAssignLoc === null && (n.shorthandAssignLoc = a) : this.raise(x.InvalidCoverInitializedName, a), t.value = this.
          parseMaybeDefault(r, zt(t.key));
        } else
          t.value = zt(t.key);
        return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
      }
    }
    parseObjPropValue(t, r, i, n, a, o, l) {
      let u = this.parseObjectMethod(t, i, n, a, o) || this.parseObjectProperty(t, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(t, r) {
      if (this.eat(0))
        t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: i,
          value: n
        } = this.state, a;
        if (Dt(i))
          a = this.parseIdentifier(!0);
        else
          switch (i) {
            case 134:
              a = this.parseNumericLiteral(n);
              break;
            case 133:
              a = this.parseStringLiteral(n);
              break;
            case 135:
              a = this.parseBigIntLiteral(n);
              break;
            case 136:
              a = this.parseDecimalLiteral(n);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(x.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        t.key = a, i !== 138 && (t.computed = !1);
      }
      return t.key;
    }
    initFunction(t, r) {
      t.id = null, t.generator = !1, t.async = r;
    }
    parseMethod(t, r, i, n, a, o, l = !1) {
      this.initFunction(t, i), t.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(Wn(i, t.generator)),
      this.parseFunctionParams(t, n);
      let u = this.parseFunctionBodyAndFinish(t, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(t, r, i, n) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(t, !i, n, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, i ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, r, i, n) {
      this.scope.enter(6);
      let a = Wn(i, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(t, i);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, n)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(t, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(t, r, i) {
      this.toAssignableList(r, i, !1), t.params = r;
    }
    parseFunctionBodyAndFinish(t, r, i = !1) {
      return this.parseFunctionBody(t, !1, i), this.finishNode(t, r);
    }
    parseFunctionBody(t, r, i = !1) {
      let n = r && !this.match(5);
      if (this.expressionScope.enter(Yy()), n)
        t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(t.params);
          l && u && this.raise(x.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
          let c = !a && this.state.strict;
          this.checkParams(t, !this.state.strict && !r && !i && !u, r, c), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let r = 0, i = t.length; r < i; r++)
        if (!this.isSimpleParameter(t[r])) return !1;
      return !0;
    }
    checkParams(t, r, i, n = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of t.params)
        this.checkLVal(l, {
          in: o,
          binding: 5,
          checkClashes: a,
          strictModeChanged: n
        });
    }
    parseExprList(t, r, i, n) {
      let a = [], o = !0;
      for (; !this.eat(t); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(t)) {
          n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, i));
      }
      return a;
    }
    parseExprListItem(t, r, i) {
      let n;
      if (this.match(12))
        t || this.raise(x.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), n = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        n = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), i || this.raise(x.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), n = this.finishNode(a, "ArgumentPlaceholder");
      } else
        n = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return n;
    }
    parseIdentifier(t) {
      let r = this.startNode(), i = this.parseIdentifierName(t);
      return this.createIdentifier(r, i);
    }
    createIdentifier(t, r) {
      return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
    }
    parseIdentifierName(t) {
      let r, {
        startLoc: i,
        type: n
      } = this.state;
      Dt(n) ? r = this.state.value : this.unexpected();
      let a = Aq(n);
      return t ? a && this.replaceToken(132) : this.checkReservedWord(r, i, a, !1), this.next(), r;
    }
    checkReservedWord(t, r, i, n) {
      if (t.length > 10 || !Kq(t))
        return;
      if (i && qq(t)) {
        this.raise(x.UnexpectedKeyword, r, {
          keyword: t
        });
        return;
      }
      if ((this.state.strict ? n ? qy : jy : By)(t, this.inModule)) {
        this.raise(x.UnexpectedReservedWord, r, {
          reservedWord: t
        });
        return;
      } else if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(x.YieldBindingIdentifier, r);
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(x.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(x.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(x.ArgumentsInClass, r);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(t) {
      let r = this.startNodeAt(t);
      return this.expressionScope.recordParameterInitializerError(x.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(x.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: t
      } = this.state;
      return t === 53 || t === 10 || t === 0 || Xn(t) || t === 102 && !this.state.containsEsc || t === 137 || t === 56 || this.hasPlugin("v8\
intrinsic") && t === 54;
    }
    parseYield() {
      let t = this.startNode();
      this.expressionScope.recordParameterInitializerError(x.YieldInParameter, t), this.next();
      let r = !1, i = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            i = this.parseMaybeAssign();
        }
      return t.delegate = r, t.argument = i, this.finishNode(t, "YieldExpression");
    }
    parseImportCall(t) {
      return this.next(), t.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(t, "ImportExpression");
    }
    checkPipelineAtInfixOperator(t, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && t.type === "SequenceExpression" && this.raise(x.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(t, r) {
      if (this.isSimpleReference(t)) {
        let i = this.startNodeAt(r);
        return i.callee = t, this.finishNode(i, "PipelineBareFunction");
      } else {
        let i = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = t, this.finishNode(i, "PipelineTopicExpression");
      }
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(x.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipelineTopicUnused, t);
    }
    withTopicBindingContext(t) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return t();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return t();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
      return this.state.inFSharpPipelineDirectBody = i, n;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let t = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let i = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        t.body = this.parseProgram(r, 8, "module");
      } finally {
        i();
      }
      return this.finishNode(t, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }, _u = {
    kind: 1
  }, PV = {
    kind: 2
  }, AV = /[\uD800-\uDFFF]/u, Du = /in(?:stanceof)?/y;
  function vV(e, t) {
    for (let r = 0; r < e.length; r++) {
      let i = e[r], {
        type: n
      } = i;
      if (typeof n == "number") {
        {
          if (n === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = i, c = o + 1, p = ht(a.start, 1);
            e.splice(r, 1, new jt({
              type: Jt(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }), new jt({
              type: Jt(132),
              value: l,
              start: c,
              end: u,
              startLoc: p,
              endLoc: a.end
            })), r++;
            continue;
          }
          if (Xn(n)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = i, c = o + 1, p = ht(a.start, 1), g;
            t.charCodeAt(o) === 96 ? g = new jt({
              type: Jt(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }) : g = new jt({
              type: Jt(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            });
            let P, A, C, _;
            n === 24 ? (A = u - 1, C = ht(a.end, -1), P = l === null ? null : l.slice(1, -1), _ = new jt({
              type: Jt(22),
              value: "`",
              start: A,
              end: u,
              startLoc: C,
              endLoc: a.end
            })) : (A = u - 2, C = ht(a.end, -2), P = l === null ? null : l.slice(1, -2), _ = new jt({
              type: Jt(23),
              value: "${",
              start: A,
              end: u,
              startLoc: C,
              endLoc: a.end
            })), e.splice(r, 1, g, new jt({
              type: Jt(20),
              value: P,
              start: c,
              end: A,
              startLoc: p,
              endLoc: C
            }), _), r += 2;
            continue;
          }
        }
        i.type = Jt(n);
      }
    }
    return e;
  }
  s(vV, "babel7CompatTokens");
  var Qu = class extends zu {
    static {
      s(this, "StatementParser");
    }
    parseTopLevel(t, r) {
      return t.program = this.parseProgram(r), t.comments = this.comments, this.options.tokens && (t.tokens = vV(this.tokens, this.input)), this.
      finishNode(t, "File");
    }
    parseProgram(t, r = 139, i = this.options.sourceType) {
      if (t.sourceType = i, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule && !this.options.
      allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [a, o] of Array.from(this.scope.undefinedExports))
          this.raise(x.ModuleExportUndefined, o, {
            localName: a
          });
      let n;
      return r === 139 ? n = this.finishNode(t, "Program") : n = this.finishNodeAt(t, "Program", ht(this.state.startLoc, -1)), n;
    }
    stmtToDirective(t) {
      let r = t;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let i = r.value, n = i.value, a = this.input.slice(i.start, i.end), o = i.value = a.slice(1, -1);
      return this.addExtra(i, "raw", a), this.addExtra(i, "rawValue", o), this.addExtra(i, "expressionValue", n), i.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(t, r) {
      if (Ht(t)) {
        if (Du.lastIndex = r, Du.test(this.input)) {
          let i = this.codePointAtPos(Du.lastIndex);
          if (!yi(i) && i !== 92)
            return !1;
        }
        return !0;
      } else return t === 92;
    }
    chStartsBindingPattern(t) {
      return t === 91 || t === 123;
    }
    hasFollowingBindingAtom() {
      let t = this.nextTokenStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
    }
    hasInLineFollowingBindingIdentifier() {
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingIdentifier(r, t);
    }
    startsUsingForOf() {
      let {
        type: t,
        containsEsc: r
      } = this.lookahead();
      if (t === 102 && !r)
        return !1;
      if (ve(t) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let t = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(t, "using")) {
        t = this.nextTokenInLineStartSince(t + 5);
        let r = this.codePointAtPos(t);
        if (this.chStartsBindingIdentifier(r, t))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(t) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
    }
    parseStatementContent(t, r) {
      let i = this.state.type, n = this.startNode(), a = !!(t & 2), o = !!(t & 4), l = t & 1;
      switch (i) {
        case 60:
          return this.parseBreakContinueStatement(n, !0);
        case 63:
          return this.parseBreakContinueStatement(n, !1);
        case 64:
          return this.parseDebuggerStatement(n);
        case 90:
          return this.parseDoWhileStatement(n);
        case 91:
          return this.parseForStatement(n);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? x.StrictFunction : this.options.annexB ? x.SloppyFunctionAnnexB : x.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(n, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, n), !0);
        case 69:
          return this.parseIfStatement(n);
        case 70:
          return this.parseReturnStatement(n);
        case 71:
          return this.parseSwitchStatement(n);
        case 72:
          return this.parseThrowStatement(n);
        case 73:
          return this.parseTryStatement(n);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? a || this.raise(x.UnexpectedLexicalDeclaration, n) : this.raise(x.AwaitUsingNotInAsyncContext, n),
            this.next(), this.parseVarStatement(n, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(x.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), g = this.codePointAtPos(p);
          if (g !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(g, p) && g !== 123))
            break;
        }
        case 75:
          a || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(n, p);
        }
        case 92:
          return this.parseWhileStatement(n);
        case 76:
          return this.parseWithStatement(n);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(n);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(x.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return i === 83 ? (p = this.parseImport(n), p.type === "ImportDeclaration" && (!p.importKind || p.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (p = this.parseExport(n, r), (p.type === "ExportNamedDeclaration" && (!p.exportKind || p.exportKind ===
          "value") || p.type === "ExportAllDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(x.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return ve(i) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(n, u, c, t) : this.parseExpressionStatement(n, c,
      r);
    }
    assertModuleNodeAllowed(t) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(x.ImportOutsideModule, t);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(t, r, i) {
      return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(x.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(
      r, t[0]), i && this.resetStartLocationFromNode(i, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(x.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(x.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, i;
        if (this.match(10)) {
          let n = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(n, i);
          let a = this.state.startLoc;
          t.expression = this.parseMaybeDecoratorArguments(i), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !==
          i && this.raise(x.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (i = this.parseIdentifier(!1); this.eat(16); ) {
            let n = this.startNodeAt(r);
            n.object = i, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) :
            n.property = this.parseIdentifier(!0), n.computed = !1, i = this.finishNode(n, "MemberExpression");
          }
          t.expression = this.parseMaybeDecoratorArguments(i);
        }
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(t);
        return r.callee = t, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return t;
    }
    parseBreakContinueStatement(t, r) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, r) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        let n = this.state.labels[i];
        if ((t.label == null || n.name === t.label.name) && (n.kind != null && (r || n.kind === 1) || t.label && r))
          break;
      }
      if (i === this.state.labels.length) {
        let n = r ? "BreakStatement" : "ContinueStatement";
        this.raise(x.IllegalBreakContinue, t, {
          type: n
        });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoWhileStatement(t) {
      return this.next(), this.state.labels.push(_u), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(_u);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(
      13))
        return r !== null && this.unexpected(r), this.parseFor(t, null);
      let i = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = i && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let g = this.startNode(), P;
          u ? (P = "await using", this.isAwaitAllowed() || this.raise(x.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : P =
          this.state.value, this.next(), this.parseVar(g, !0, P);
          let A = this.finishNode(g, "VariableDeclaration"), C = this.match(58);
          return C && c && this.raise(x.ForInUsing, A), (C || this.isContextual(102)) && A.declarations.length === 1 ? this.parseForIn(t, A,
          r) : (r !== null && this.unexpected(r), this.parseFor(t, A));
        }
      }
      let n = this.isContextual(95), a = new Ti(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (i && this.raise(x.ForOfLet, o), r === null && n && o.type === "Identifier" && this.raise(x.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          in: {
            type: u
          }
        }), this.parseForIn(t, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(t, o);
    }
    parseFunctionStatement(t, r, i) {
      return this.next(), this.parseFunction(t, 1 | (i ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(x.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "Ret\
urnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      let r = t.cases = [];
      this.expect(5), this.state.labels.push(PV), this.scope.enter(0);
      let i;
      for (let n; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          i && this.finishNode(i, "SwitchCase"), r.push(i = this.startNode()), i.consequent = [], this.next(), a ? i.test = this.parseExpression() :
          (n && this.raise(x.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), n = !0, i.test = null), this.expect(14);
        } else
          i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchState\
ment");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(x.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let t = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(
        r, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(x.NoCatchOrFinally, t), this.finishNode(
      t, "TryStatement");
    }
    parseVarStatement(t, r, i = !1) {
      return this.next(), this.parseVar(t, !1, r, i), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(_u), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(x.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, r, i, n) {
      for (let o of this.state.labels)
        o.name === r && this.raise(x.LabelRedeclaration, i, {
          labelName: r
        });
      let a = Iq(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === t.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), t.body = n & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label =
      i, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, r, i) {
      return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock(t = !1, r = !0, i) {
      let n = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(n, t, !1, 8, i), r && this.
      scope.exit(), this.finishNode(n, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, r, i, n, a) {
      let o = t.body = [], l = t.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, i, n, a);
    }
    parseBlockOrModuleBlockBody(t, r, i, n, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(n); ) {
        let c = i ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        t.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(t, r) {
      return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, r, i) {
      let n = this.match(58);
      return this.next(), n ? i !== null && this.unexpected(i) : t.await = i !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!n || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(x.ForInOfLoopInitializer, r, {
        type: n ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(x.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), t.left = r, t.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, n ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, r, i, n = !1) {
      let a = t.declarations = [];
      for (t.kind = i; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, i), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !n && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(x.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(x.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: i
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return t;
    }
    parseVarId(t, r) {
      let i = this.parseBindingAtom();
      this.checkLVal(i, {
        in: {
          type: "VariableDeclarator"
        },
        binding: r === "var" ? 5 : 8201
      }), t.id = i;
    }
    parseAsyncFunctionExpression(t) {
      return this.parseFunction(t, 8);
    }
    parseFunction(t, r = 0) {
      let i = r & 2, n = !!(r & 1), a = n && !(r & 4), o = !!(r & 8);
      this.initFunction(t, o), this.match(55) && (i && this.raise(x.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.
      generator = !0), n && (t.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Wn(o, t.generator)), n || (t.id = this.parseFunctionId()),
      this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, n ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), n && !i && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = l, t;
    }
    parseFunctionId(t) {
      return t || ve(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, r) {
      this.expect(10), this.expressionScope.enter(Gq()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, t.id.loc.start);
    }
    parseClass(t, r, i) {
      this.next();
      let n = this.state.strict;
      return this.state.strict = !0, this.parseClassId(t, r, i), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, n), this.
      finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
    }
    parseClassBody(t, r) {
      this.classScope.enter();
      let i = {
        hadConstructor: !1,
        hadSuperClass: t
      }, n = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (n.length > 0)
              throw this.raise(x.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            n.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          n.length && (o.decorators = n, this.resetStartLocationFromNode(o, n[0]), n = []), this.parseClassMember(a, o, i), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(x.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), n.length)
        throw this.raise(x.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(t, r) {
      let i = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let n = r;
        return n.kind = "method", n.computed = !1, n.key = i, n.static = !1, this.pushClassMethod(t, n, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let n = r;
        return n.computed = !1, n.key = i, n.static = !1, t.body.push(this.parseClassProperty(n)), !0;
      }
      return this.resetPreviousNodeTrailingComments(i), !1;
    }
    parseClassMember(t, r, i) {
      let n = this.isContextual(106);
      if (n) {
        if (this.parseClassMemberFromModifier(t, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, r, i, n);
    }
    parseClassMemberWithIsStatic(t, r, i, n) {
      let a = r, o = r, l = r, u = r, c = r, p = a, g = a;
      if (r.static = n, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let k = this.match(138);
        if (this.parseClassElementName(p), k) {
          this.pushClassPrivateMethod(t, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(x.ConstructorIsGenerator, a.key), this.pushClassMethod(t, a, !0, !1, !1, !1);
        return;
      }
      let P = ve(this.state.type) && !this.state.containsEsc, A = this.match(138), C = this.parseClassElementName(r), _ = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(g), this.isClassMethod()) {
        if (p.kind = "method", A) {
          this.pushClassPrivateMethod(t, o, !1, !1);
          return;
        }
        let k = this.isNonstaticConstructor(a), O = !1;
        k && (a.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(x.DuplicateConstructor, C), k && this.
        hasPlugin("typescript") && r.override && this.raise(x.OverrideOnConstructor, C), i.hadConstructor = !0, O = i.hadSuperClass), this.pushClassMethod(
        t, a, !1, !1, k, O);
      } else if (this.isClassProperty())
        A ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l);
      else if (P && C.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(C);
        let k = this.eat(55);
        g.optional && this.unexpected(_), p.kind = "method";
        let O = this.match(138);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(g), O ? this.pushClassPrivateMethod(t, o, k, !0) : (this.isNonstaticConstructor(
        a) && this.raise(x.ConstructorIsAsync, a.key), this.pushClassMethod(t, a, k, !0, !1, !1));
      } else if (P && (C.name === "get" || C.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(C), p.kind = C.name;
        let k = this.match(138);
        this.parseClassElementName(a), k ? this.pushClassPrivateMethod(t, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(x.ConstructorIsAccessor,
        a.key), this.pushClassMethod(t, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (P && C.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(C);
        let k = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(t, c, k);
      } else this.isLineTerminator() ? A ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l) : this.unexpected();
    }
    parseClassElementName(t) {
      let {
        type: r,
        value: i
      } = this.state;
      if ((r === 132 || r === 133) && t.static && i === "prototype" && this.raise(x.StaticPrototype, this.state.startLoc), r === 138) {
        i === "constructor" && this.raise(x.ConstructorClassPrivateField, this.state.startLoc);
        let n = this.parsePrivateName();
        return t.key = n, n;
      }
      return this.parsePropertyName(t);
    }
    parseClassStaticBlock(t, r) {
      var i;
      this.scope.enter(208);
      let n = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n, t.body.push(this.
      finishNode(r, "StaticBlock")), (i = r.decorators) != null && i.length && this.raise(x.DecoratorStaticBlock, r);
    }
    pushClassProperty(t, r) {
      !r.computed && (r.key.name === "constructor" || r.key.value === "constructor") && this.raise(x.ConstructorClassField, r.key), t.body.push(
      this.parseClassProperty(r));
    }
    pushClassPrivateProperty(t, r) {
      let i = this.parseClassPrivateProperty(r);
      t.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassAccessorProperty(t, r, i) {
      if (!i && !r.computed) {
        let a = r.key;
        (a.name === "constructor" || a.value === "constructor") && this.raise(x.ConstructorClassField, a);
      }
      let n = this.parseClassAccessorProperty(r);
      t.body.push(n), i && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
    }
    pushClassMethod(t, r, i, n, a, o) {
      t.body.push(this.parseMethod(r, i, n, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(t, r, i, n) {
      let a = this.parseMethod(r, i, n, !1, !1, "ClassPrivateMethod", !0);
      t.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(t, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(80), this.expressionScope.enter(Yy()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, r, i, n = 8331) {
      if (ve(this.state.type))
        t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, n);
      else if (i || !r)
        t.id = null;
      else
        throw this.raise(x.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t, r) {
      let i = this.parseMaybeImportPhase(t, !0), n = this.maybeParseExportDefaultSpecifier(t, i), a = !n || this.eat(12), o = a && this.eatExportStar(
      t), l = o && this.maybeParseExportNamespaceSpecifier(t), u = a && (!l || this.eat(12)), c = n || o;
      if (o && !l) {
        if (n && this.unexpected(), r)
          throw this.raise(x.UnsupportedDecoratorExport, t);
        return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(t);
      n && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let g;
      if (c || p) {
        if (g = !1, r)
          throw this.raise(x.UnsupportedDecoratorExport, t);
        this.parseExportFrom(t, c);
      } else
        g = this.maybeParseExportDeclaration(t);
      if (c || p || g) {
        var P;
        let A = t;
        if (this.checkExport(A, !0, !1, !!A.source), ((P = A.declaration) == null ? void 0 : P.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, A.declaration, A);
        else if (r)
          throw this.raise(x.UnsupportedDecoratorExport, t);
        return this.finishNode(A, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let A = t, C = this.parseExportDefaultExpression();
        if (A.declaration = C, C.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, C, A);
        else if (r)
          throw this.raise(x.UnsupportedDecoratorExport, t);
        return this.checkExport(A, !0, !0), this.finishNode(A, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let i = r || this.parseIdentifier(!0), n = this.startNodeAtNode(i);
        return n.exported = i, t.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        t.specifiers || (t.specifiers = []);
        let r = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), r.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        t.specifiers || (t.specifiers = []);
        let r = t.exportKind === "type";
        return t.specifiers.push(...this.parseExportSpecifiers(r)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") &&
        (t.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions =
      []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let t = this.nextTokenInLineStart();
      return this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      let t = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(t, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, 13);
      if (this.match(80))
        return this.parseClass(t, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(x.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(t) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: t
      } = this.state;
      if (ve(t)) {
        if (t === 95 && !this.state.containsEsc || t === 100)
          return !1;
        if ((t === 130 || t === 129) && !this.state.containsEsc) {
          let {
            type: n
          } = this.lookahead();
          if (ve(n) && n !== 98 || n === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), i = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || ve(this.state.type) && i)
        return !0;
      if (this.match(65) && i) {
        let n = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return n === 34 || n === 39;
      }
      return !1;
    }
    parseExportFrom(t, r) {
      this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(
      t)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: t
      } = this.state;
      return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), !0) : t === 74 || t === 75 || t ===
      68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, r, i, n) {
      if (r) {
        var a;
        if (i) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = t.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            x.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = t.specifiers) != null && a.length)
          for (let l of t.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !n && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(x.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (t.declaration) {
          if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
            let l = t.declaration.id;
            if (!l) throw new Error("Assertion failure");
            this.checkDuplicateExports(t, l.name);
          } else if (t.declaration.type === "VariableDeclaration")
            for (let l of t.declaration.declarations)
              this.checkDeclaration(l.id);
        }
      }
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (let r of t.properties)
          this.checkDeclaration(r);
      else if (t.type === "ArrayPattern")
        for (let r of t.elements)
          r && this.checkDeclaration(r);
      else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type ===
      "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(x.DuplicateDefaultExport, t) : this.raise(x.DuplicateExport, t, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(t) {
      let r = [], i = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (i)
          i = !1;
        else if (this.expect(12), this.eat(8)) break;
        let n = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, t, n));
      }
      return r;
    }
    parseExportSpecifier(t, r, i, n) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = eV(t.local) : t.exported || (t.exported =
      zt(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let t = this.parseStringLiteral(this.state.value), r = t.value.match(AV);
        return r && this.raise(x.ModuleExportNameHasLoneSurrogate, t, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), t;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(t) {
      return t.assertions != null ? t.assertions.some(({
        key: r,
        value: i
      }) => i.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(t) {
      let {
        specifiers: r
      } = t, i = r.length === 1 ? r[0].type : null;
      if (t.phase === "source")
        i !== "ImportDefaultSpecifier" && this.raise(x.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (t.phase === "defer")
        i !== "ImportNamespaceSpecifier" && this.raise(x.DeferImportRequiresNamespace, r[0].loc.start);
      else if (t.module) {
        var n;
        i !== "ImportDefaultSpecifier" && this.raise(x.ImportReflectionNotBinding, r[0].loc.start), ((n = t.assertions) == null ? void 0 : n.
        length) > 0 && this.raise(x.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(t) {
      if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = t;
        if (r != null) {
          let i = r.find((n) => {
            let a;
            if (n.type === "ExportSpecifier" ? a = n.local : n.type === "ImportSpecifier" && (a = n.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          i !== void 0 && this.raise(x.ImportJSONBindingNotDefault, i.loc.start);
        }
      }
    }
    isPotentialImportPhase(t) {
      return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(t, r, i, n) {
      r || (i === "module" ? (this.expectPlugin("importReflection", n), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1),
      i === "source" ? (this.expectPlugin("sourcePhaseImports", n), t.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", n), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
    }
    parseMaybeImportPhase(t, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(t, r, null), null;
      let i = this.parseIdentifier(!0), {
        type: n
      } = this.state;
      return (Dt(n) ? n !== 98 || this.lookaheadCharCode() === 102 : n !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(
      t, r, i.name, i.loc.start), null) : (this.applyImportPhase(t, r, null), i);
    }
    isPrecedingIdImportPhase(t) {
      let {
        type: r
      } = this.state;
      return ve(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(t) {
      return this.match(133) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
    }
    parseImportSpecifiersAndAfter(t, r) {
      t.specifiers = [];
      let n = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), a = n && this.maybeParseStarImportSpecifier(t);
      return n && !a && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
    }
    parseImportSourceAndAttributes(t) {
      var r;
      return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.
      checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(t, r, i) {
      r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, i));
    }
    finishImportSpecifier(t, r, i = 8201) {
      return this.checkLVal(t.local, {
        in: {
          type: r
        },
        binding: i
      }), this.finishNode(t, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let i = this.startNode(), n = this.state.value;
        if (r.has(n) && this.raise(x.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: n
        }), r.add(n), this.match(133) ? i.key = this.parseStringLiteral(n) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), t;
    }
    parseModuleAttributes() {
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        let i = this.startNode();
        if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(x.ModuleAttributeDifferentFromType, i.key), r.has(i.key.name) &&
        this.raise(x.ModuleAttributesWithDuplicateKeys, i.key, {
          key: i.key.name
        }), r.add(i.key.name), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAttributes(t) {
      let r, i = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), i = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(x.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !i && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
    }
    maybeParseDefaultImportSpecifier(t, r) {
      if (r) {
        let i = this.startNodeAtNode(r);
        return i.local = r, t.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
      } else if (Dt(this.state.type))
        return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(t) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(x.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let i = this.startNode(), n = this.match(133), a = this.isContextual(130);
        i.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(i, n, t.importKind === "type" || t.importKind === "typeof", a, void 0);
        t.specifiers.push(o);
      }
    }
    parseImportSpecifier(t, r, i, n, a) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = t;
        if (r)
          throw this.raise(x.ImportBindingIsString, t, {
            importName: o.value
          });
        this.checkReservedWord(o.name, t.loc.start, !0, !0), t.local || (t.local = zt(o));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier", a);
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }, $n = class extends Qu {
    static {
      s(this, "Parser");
    }
    constructor(t, r) {
      t = EV(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = CV(this.options.plugins), this.filename = t.sourceFilename;
    }
    getScopeHandler() {
      return fs;
    }
    parse() {
      this.enterInitialScopes();
      let t = this.startNode(), r = this.startNode();
      return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t.comments.length = this.state.commentsLen,
      t;
    }
  };
  function CV(e) {
    let t = /* @__PURE__ */ new Map();
    for (let r of e) {
      let [i, n] = Array.isArray(r) ? r : [r, {}];
      t.has(i) || t.set(i, n || {});
    }
    return t;
  }
  s(CV, "pluginsMap");
  function IV(e, t) {
    var r;
    if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
      t = Object.assign({}, t);
      try {
        t.sourceType = "module";
        let i = ls(t, e), n = i.parse();
        if (i.sawUnambiguousESM)
          return n;
        if (i.ambiguousScriptDifferentAst)
          try {
            return t.sourceType = "script", ls(t, e).parse();
          } catch {
          }
        else
          n.program.sourceType = "script";
        return n;
      } catch (i) {
        try {
          return t.sourceType = "script", ls(t, e).parse();
        } catch {
        }
        throw i;
      }
    } else
      return ls(t, e).parse();
  }
  s(IV, "parse");
  function wV(e, t) {
    let r = ls(t, e);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  s(wV, "parseExpression");
  function OV(e) {
    let t = {};
    for (let r of Object.keys(e))
      t[r] = Jt(e[r]);
    return t;
  }
  s(OV, "generateExportedTokenTypes");
  var NV = OV(Pq);
  function ls(e, t) {
    let r = $n;
    return e != null && e.plugins && (SV(e.plugins), r = _V(e.plugins)), new r(e, t);
  }
  s(ls, "getParser");
  var Dy = {};
  function _V(e) {
    let t = xV.filter((n) => Je(e, n)), r = t.join("/"), i = Dy[r];
    if (!i) {
      i = $n;
      for (let n of t)
        i = Hy[n](i);
      Dy[r] = i;
    }
    return i;
  }
  s(_V, "getParserClass");
  ds.parse = IV;
  ds.parseExpression = wV;
  ds.tokTypes = NV;
});

// ../node_modules/@babel/helper-hoist-variables/lib/index.js
var Gy = v((uc) => {
  "use strict";
  Object.defineProperty(uc, "__esModule", {
    value: !0
  });
  uc.default = BV;
  var DV = le(), {
    assignmentExpression: kV,
    expressionStatement: LV,
    identifier: MV
  } = DV, FV = {
    Scope(e, t) {
      t.kind === "let" && e.skip();
    },
    FunctionParent(e) {
      e.skip();
    },
    VariableDeclaration(e, t) {
      if (t.kind && e.node.kind !== t.kind) return;
      let r = [], i = e.get("declarations"), n;
      for (let a of i) {
        n = a.node.id, a.node.init && r.push(LV(kV("=", a.node.id, a.node.init)));
        for (let o of Object.keys(a.getBindingIdentifiers()))
          t.emit(MV(o), o, a.node.init !== null);
      }
      e.parentPath.isFor({
        left: e.node
      }) ? e.replaceWith(n) : e.replaceWithMultiple(r);
    }
  };
  function BV(e, t, r = "var") {
    e.traverse(FV, {
      kind: r,
      emit: t
    });
  }
  s(BV, "hoistVariables");
});

// ../node_modules/@babel/traverse/lib/path/replacement.js
var sT = v((Tr) => {
  "use strict";
  Object.defineProperty(Tr, "__esModule", {
    value: !0
  });
  Tr._replaceWith = fU;
  Tr.replaceExpressionWithStatements = hU;
  Tr.replaceInline = dU;
  Tr.replaceWith = pU;
  Tr.replaceWithMultiple = uU;
  Tr.replaceWithSourceString = cU;
  var jV = Iu(), pc = Br(), RV = gr(), tT = Lr(), qV = Hn(), VV = le(), UV = Gy(), {
    FUNCTION_TYPES: zy,
    arrowFunctionExpression: KV,
    assignmentExpression: rT,
    awaitExpression: WV,
    blockStatement: YV,
    buildUndefinedNode: cc,
    callExpression: XV,
    cloneNode: fc,
    conditionalExpression: JV,
    expressionStatement: $V,
    getBindingIdentifiers: HV,
    identifier: GV,
    inheritLeadingComments: zV,
    inheritTrailingComments: QV,
    inheritsComments: ZV,
    isBlockStatement: eU,
    isEmptyStatement: Qy,
    isExpression: iT,
    isExpressionStatement: tU,
    isIfStatement: rU,
    isProgram: iU,
    isStatement: sU,
    isVariableDeclaration: nU,
    removeComments: aU,
    returnStatement: Zy,
    sequenceExpression: oU,
    validate: eT,
    yieldExpression: lU
  } = VV;
  function uU(e) {
    var t;
    this.resync(), e = this._verifyNodeList(e), zV(e[0], this.node), QV(e[e.length - 1], this.node), (t = (0, tT.getCachedPaths)(this.hub, this.
    parent)) == null || t.delete(this.node), this.node = this.container[this.key] = null;
    let r = this.insertAfter(e);
    return this.node ? this.requeue() : this.remove(), r;
  }
  s(uU, "replaceWithMultiple");
  function cU(e) {
    this.resync();
    let t;
    try {
      e = `(${e})`, t = (0, qV.parse)(e);
    } catch (i) {
      let n = i.loc;
      throw n && (i.message += ` - make sure this is an expression.
` + (0, jV.codeFrameColumns)(e, {
        start: {
          line: n.line,
          column: n.column + 1
        }
      }), i.code = "BABEL_REPLACE_SOURCE_ERROR"), i;
    }
    let r = t.program.body[0].expression;
    return pc.default.removeProperties(r), this.replaceWith(r);
  }
  s(cU, "replaceWithSourceString");
  function pU(e) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let t = e instanceof RV.default ? e.node : e;
    if (!t)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === t)
      return [this];
    if (this.isProgram() && !iU(t))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(t))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof t == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r = "";
    if (this.isNodeType("Statement") && iT(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    t) && !this.parentPath.isExportDefaultDeclaration() && (t = $V(t), r = "expression"), this.isNodeType("Expression") && sU(t) && !this.canHaveVariableDeclarationOrExpression() &&
    !this.canSwapBetweenExpressionAndStatement(t))
      return this.replaceExpressionWithStatements([t]);
    let i = this.node;
    return i && (ZV(t, i), aU(i)), this._replaceWith(t), this.type = t.type, this.setScope(), this.requeue(), [r ? this.get(r) : this];
  }
  s(pU, "replaceWith");
  function fU(e) {
    var t;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? eT(this.parent, this.key, [e]) : eT(this.parent, this.key, e), this.debug(`Replace with ${e?.type}`), (t = (0, tT.getCachedPaths)(
    this.hub, this.parent)) == null || t.set(e, this).delete(this.node), this.node = this.container[this.key] = e;
  }
  s(fU, "_replaceWith");
  function hU(e) {
    this.resync();
    let t = [], r = Gn(e, t);
    if (r) {
      for (let P of t) this.scope.push({
        id: P
      });
      return this.replaceWith(r)[0].get("expressions");
    }
    let i = this.getFunctionParent(), n = i?.is("async"), a = i?.is("generator"), o = KV([], YV(e));
    this.replaceWith(XV(o, []));
    let l = this.get("callee");
    (0, UV.default)(l.get("body"), (P) => {
      this.scope.push({
        id: P
      });
    }, "var");
    let u = this.get("callee").getCompletionRecords();
    for (let P of u) {
      if (!P.isExpressionStatement()) continue;
      let A = P.findParent((C) => C.isLoop());
      if (A) {
        let C = A.getData("expressionReplacementReturnUid");
        C ? C = GV(C.name) : (C = l.scope.generateDeclaredUidIdentifier("ret"), l.get("body").pushContainer("body", Zy(fc(C))), A.setData("e\
xpressionReplacementReturnUid", C)), P.get("expression").replaceWith(rT("=", fc(C), P.node.expression));
      } else
        P.replaceWith(Zy(P.node.expression));
    }
    l.arrowFunctionToExpression();
    let c = l, p = n && pc.default.hasType(this.get("callee.body").node, "AwaitExpression", zy), g = a && pc.default.hasType(this.get("calle\
e.body").node, "YieldExpression", zy);
    return p && (c.set("async", !0), g || this.replaceWith(WV(this.node))), g && (c.set("generator", !0), this.replaceWith(lU(this.node, !0))),
    c.get("body.body");
  }
  s(hU, "replaceExpressionWithStatements");
  function Gn(e, t) {
    let r = [], i = !0;
    for (let n of e)
      if (Qy(n) || (i = !1), iT(n))
        r.push(n);
      else if (tU(n))
        r.push(n.expression);
      else if (nU(n)) {
        if (n.kind !== "var") return;
        for (let a of n.declarations) {
          let o = HV(a);
          for (let l of Object.keys(o))
            t.push(fc(o[l]));
          a.init && r.push(rT("=", a.id, a.init));
        }
        i = !0;
      } else if (rU(n)) {
        let a = n.consequent ? Gn([n.consequent], t) : cc(), o = n.alternate ? Gn([n.alternate], t) : cc();
        if (!a || !o) return;
        r.push(JV(n.test, a, o));
      } else if (eU(n)) {
        let a = Gn(n.body, t);
        if (!a) return;
        r.push(a);
      } else if (Qy(n))
        e.indexOf(n) === 0 && (i = !0);
      else
        return;
    return i && r.push(cc()), r.length === 1 ? r[0] : oU(r);
  }
  s(Gn, "gatherSequenceExpressions");
  function dU(e) {
    if (this.resync(), Array.isArray(e))
      if (Array.isArray(this.container)) {
        e = this._verifyNodeList(e);
        let t = this._containerInsertAfter(e);
        return this.remove(), t;
      } else
        return this.replaceWithMultiple(e);
    else
      return this.replaceWith(e);
  }
  s(dU, "replaceInline");
});

// ../node_modules/@babel/traverse/lib/path/evaluation.js
var lT = v((zn) => {
  "use strict";
  Object.defineProperty(zn, "__esModule", {
    value: !0
  });
  zn.evaluate = EU;
  zn.evaluateTruthy = SU;
  var mU = ["Number", "String", "Math"], yU = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI",
  "encodeURIComponent", null, null], TU = ["random"];
  function nT(e) {
    return mU.includes(e);
  }
  s(nT, "isValidObjectCallee");
  function gU(e) {
    return yU.includes(e);
  }
  s(gU, "isValidIdentifierCallee");
  function bU(e) {
    return TU.includes(e);
  }
  s(bU, "isInvalidMethod");
  function SU() {
    let e = this.evaluate();
    if (e.confident) return !!e.value;
  }
  s(SU, "evaluateTruthy");
  function Qt(e, t) {
    t.confident && (t.deoptPath = e, t.confident = !1);
  }
  s(Qt, "deopt");
  var aT = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function dt(e, t) {
    let {
      node: r
    } = e, {
      seen: i
    } = t;
    if (i.has(r)) {
      let n = i.get(r);
      if (n.resolved)
        return n.value;
      Qt(e, t);
      return;
    } else {
      let n = {
        resolved: !1
      };
      i.set(r, n);
      let a = xU(e, t);
      return t.confident && (n.resolved = !0, n.value = a), a;
    }
  }
  s(dt, "evaluateCached");
  function xU(e, t) {
    if (t.confident) {
      if (e.isSequenceExpression()) {
        let r = e.get("expressions");
        return dt(r[r.length - 1], t);
      }
      if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
        return e.node.value;
      if (e.isNullLiteral())
        return null;
      if (e.isTemplateLiteral())
        return oT(e, e.node.quasis, t);
      if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
        let r = e.get("tag.object"), {
          node: {
            name: i
          }
        } = r, n = e.get("tag.property");
        if (r.isIdentifier() && i === "String" && !e.scope.getBinding(i) && n.isIdentifier() && n.node.name === "raw")
          return oT(e, e.node.quasi.quasis, t, !0);
      }
      if (e.isConditionalExpression()) {
        let r = dt(e.get("test"), t);
        return t.confident ? dt(r ? e.get("consequent") : e.get("alternate"), t) : void 0;
      }
      if (e.isExpressionWrapper())
        return dt(e.get("expression"), t);
      if (e.isMemberExpression() && !e.parentPath.isCallExpression({
        callee: e.node
      })) {
        let r = e.get("property"), i = e.get("object");
        if (i.isLiteral()) {
          let n = i.node.value, a = typeof n, o = null;
          if (e.node.computed) {
            if (o = dt(r, t), !t.confident) return;
          } else r.isIdentifier() && (o = r.node.name);
          if ((a === "number" || a === "string") && o != null && (typeof o == "number" || typeof o == "string"))
            return n[o];
        }
      }
      if (e.isReferencedIdentifier()) {
        let r = e.scope.getBinding(e.node.name);
        if (r) {
          if (r.constantViolations.length > 0 || e.node.start < r.path.node.end) {
            Qt(r.path, t);
            return;
          }
          if (r.hasValue)
            return r.value;
        }
        let i = e.node.name;
        if (aT.has(i)) {
          if (!r)
            return aT.get(i);
          Qt(r.path, t);
          return;
        }
        let n = e.resolve();
        if (n === e) {
          Qt(e, t);
          return;
        } else
          return dt(n, t);
      }
      if (e.isUnaryExpression({
        prefix: !0
      })) {
        if (e.node.operator === "void")
          return;
        let r = e.get("argument");
        if (e.node.operator === "typeof" && (r.isFunction() || r.isClass()))
          return "function";
        let i = dt(r, t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "!":
            return !i;
          case "+":
            return +i;
          case "-":
            return -i;
          case "~":
            return ~i;
          case "typeof":
            return typeof i;
        }
      }
      if (e.isArrayExpression()) {
        let r = [], i = e.get("elements");
        for (let n of i) {
          let a = n.evaluate();
          if (a.confident)
            r.push(a.value);
          else {
            Qt(a.deopt, t);
            return;
          }
        }
        return r;
      }
      if (e.isObjectExpression()) {
        let r = {}, i = e.get("properties");
        for (let n of i) {
          if (n.isObjectMethod() || n.isSpreadElement()) {
            Qt(n, t);
            return;
          }
          let a = n.get("key"), o;
          if (n.node.computed) {
            if (o = a.evaluate(), !o.confident) {
              Qt(o.deopt, t);
              return;
            }
            o = o.value;
          } else a.isIdentifier() ? o = a.node.name : o = a.node.value;
          let u = n.get("value").evaluate();
          if (!u.confident) {
            Qt(u.deopt, t);
            return;
          }
          u = u.value, r[o] = u;
        }
        return r;
      }
      if (e.isLogicalExpression()) {
        let r = t.confident, i = dt(e.get("left"), t), n = t.confident;
        t.confident = r;
        let a = dt(e.get("right"), t), o = t.confident;
        switch (e.node.operator) {
          case "||":
            return t.confident = n && (!!i || o), t.confident ? i || a : void 0;
          case "&&":
            return t.confident = n && (!i || o), t.confident ? i && a : void 0;
          case "??":
            return t.confident = n && (i != null || o), t.confident ? i ?? a : void 0;
        }
      }
      if (e.isBinaryExpression()) {
        let r = dt(e.get("left"), t);
        if (!t.confident) return;
        let i = dt(e.get("right"), t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "-":
            return r - i;
          case "+":
            return r + i;
          case "/":
            return r / i;
          case "*":
            return r * i;
          case "%":
            return r % i;
          case "**":
            return Math.pow(r, i);
          case "<":
            return r < i;
          case ">":
            return r > i;
          case "<=":
            return r <= i;
          case ">=":
            return r >= i;
          case "==":
            return r == i;
          case "!=":
            return r != i;
          case "===":
            return r === i;
          case "!==":
            return r !== i;
          case "|":
            return r | i;
          case "&":
            return r & i;
          case "^":
            return r ^ i;
          case "<<":
            return r << i;
          case ">>":
            return r >> i;
          case ">>>":
            return r >>> i;
        }
      }
      if (e.isCallExpression()) {
        let r = e.get("callee"), i, n;
        if (r.isIdentifier() && !e.scope.getBinding(r.node.name) && (nT(r.node.name) || gU(r.node.name)) && (n = global[r.node.name]), r.isMemberExpression()) {
          let a = r.get("object"), o = r.get("property");
          if (a.isIdentifier() && o.isIdentifier() && nT(a.node.name) && !bU(o.node.name)) {
            i = global[a.node.name];
            let l = o.node.name;
            hasOwnProperty.call(i, l) && (n = i[l]);
          }
          if (a.isLiteral() && o.isIdentifier()) {
            let l = typeof a.node.value;
            (l === "string" || l === "number") && (i = a.node.value, n = i[o.node.name]);
          }
        }
        if (n) {
          let a = e.get("arguments").map((o) => dt(o, t));
          return t.confident ? n.apply(i, a) : void 0;
        }
      }
      Qt(e, t);
    }
  }
  s(xU, "_evaluate");
  function oT(e, t, r, i = !1) {
    let n = "", a = 0, o = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
    for (let l of t) {
      if (!r.confident) break;
      n += i ? l.value.raw : l.value.cooked;
      let u = o[a++];
      u && (n += String(dt(u, r)));
    }
    if (r.confident)
      return n;
  }
  s(oT, "evaluateQuasis");
  function EU() {
    let e = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, t = dt(this, e);
    return e.confident || (t = void 0), {
      confident: e.confident,
      deopt: e.deoptPath,
      value: t
    };
  }
  s(EU, "evaluate");
});

// ../node_modules/@babel/template/lib/formatters.js
var uT = v((Ct) => {
  "use strict";
  Object.defineProperty(Ct, "__esModule", {
    value: !0
  });
  Ct.statements = Ct.statement = Ct.smart = Ct.program = Ct.expression = void 0;
  var PU = le(), {
    assertExpressionStatement: AU
  } = PU;
  function hc(e) {
    return {
      code: /* @__PURE__ */ s((t) => `/* @babel/template */;
${t}`, "code"),
      validate: /* @__PURE__ */ s(() => {
      }, "validate"),
      unwrap: /* @__PURE__ */ s((t) => e(t.program.body.slice(1)), "unwrap")
    };
  }
  s(hc, "makeStatementFormatter");
  var Fee = Ct.smart = hc((e) => e.length > 1 ? e : e[0]), Bee = Ct.statements = hc((e) => e), jee = Ct.statement = hc((e) => {
    if (e.length === 0)
      throw new Error("Found nothing to return.");
    if (e.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return e[0];
  }), vU = Ct.expression = {
    code: /* @__PURE__ */ s((e) => `(
${e}
)`, "code"),
    validate: /* @__PURE__ */ s((e) => {
      if (e.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (vU.unwrap(e).start === 0)
        throw new Error("Parse result included parens.");
    }, "validate"),
    unwrap: /* @__PURE__ */ s(({
      program: e
    }) => {
      let [t] = e.body;
      return AU(t), t.expression;
    }, "unwrap")
  }, Ree = Ct.program = {
    code: /* @__PURE__ */ s((e) => e, "code"),
    validate: /* @__PURE__ */ s(() => {
    }, "validate"),
    unwrap: /* @__PURE__ */ s((e) => e.program, "unwrap")
  };
});

// ../node_modules/@babel/template/lib/options.js
var Qn = v((ms) => {
  "use strict";
  Object.defineProperty(ms, "__esModule", {
    value: !0
  });
  ms.merge = wU;
  ms.normalizeReplacements = NU;
  ms.validate = OU;
  var CU = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function IU(e, t) {
    if (e == null) return {};
    var r = {}, i = Object.keys(e), n, a;
    for (a = 0; a < i.length; a++)
      n = i[a], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
    return r;
  }
  s(IU, "_objectWithoutPropertiesLoose");
  function wU(e, t) {
    let {
      placeholderWhitelist: r = e.placeholderWhitelist,
      placeholderPattern: i = e.placeholderPattern,
      preserveComments: n = e.preserveComments,
      syntacticPlaceholders: a = e.syntacticPlaceholders
    } = t;
    return {
      parser: Object.assign({}, e.parser, t.parser),
      placeholderWhitelist: r,
      placeholderPattern: i,
      preserveComments: n,
      syntacticPlaceholders: a
    };
  }
  s(wU, "merge");
  function OU(e) {
    if (e != null && typeof e != "object")
      throw new Error("Unknown template options.");
    let t = e || {}, {
      placeholderWhitelist: r,
      placeholderPattern: i,
      preserveComments: n,
      syntacticPlaceholders: a
    } = t, o = IU(t, CU);
    if (r != null && !(r instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (i != null && !(i instanceof RegExp) && i !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (n != null && typeof n != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (a != null && typeof a != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (a === !0 && (r != null || i != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: o,
      placeholderWhitelist: r || void 0,
      placeholderPattern: i ?? void 0,
      preserveComments: n ?? void 0,
      syntacticPlaceholders: a ?? void 0
    };
  }
  s(OU, "validate");
  function NU(e) {
    if (Array.isArray(e))
      return e.reduce((t, r, i) => (t["$" + i] = r, t), {});
    if (typeof e == "object" || e == null)
      return e || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  s(NU, "normalizeReplacements");
});

// ../node_modules/@babel/template/lib/parse.js
var mc = v((dc) => {
  "use strict";
  Object.defineProperty(dc, "__esModule", {
    value: !0
  });
  dc.default = WU;
  var _U = le(), DU = Hn(), kU = Iu(), {
    isCallExpression: LU,
    isExpressionStatement: MU,
    isFunction: FU,
    isIdentifier: BU,
    isJSXIdentifier: jU,
    isNewExpression: RU,
    isPlaceholder: Zn,
    isStatement: qU,
    isStringLiteral: cT,
    removePropertiesDeep: VU,
    traverse: UU
  } = _U, KU = /^[_$A-Z0-9]+$/;
  function WU(e, t, r) {
    let {
      placeholderWhitelist: i,
      placeholderPattern: n,
      preserveComments: a,
      syntacticPlaceholders: o
    } = r, l = JU(t, r.parser, o);
    VU(l, {
      preserveComments: a
    }), e.validate(l);
    let u = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: i,
      placeholderPattern: n,
      syntacticPlaceholders: o
    };
    return UU(l, YU, u), Object.assign({
      ast: l
    }, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
  }
  s(WU, "parseAndBuildMetadata");
  function YU(e, t, r) {
    var i;
    let n, a = r.syntactic.placeholders.length > 0;
    if (Zn(e)) {
      if (r.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      n = e.name.name, a = !0;
    } else {
      if (a || r.syntacticPlaceholders)
        return;
      if (BU(e) || jU(e))
        n = e.name;
      else if (cT(e))
        n = e.value;
      else
        return;
    }
    if (a && (r.placeholderPattern != null || r.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!a && (r.placeholderPattern === !1 || !(r.placeholderPattern || KU).test(n)) && !((i = r.placeholderWhitelist) != null && i.has(n)))
      return;
    t = t.slice();
    let {
      node: o,
      key: l
    } = t[t.length - 1], u;
    cT(e) || Zn(e, {
      expectedNode: "StringLiteral"
    }) ? u = "string" : RU(o) && l === "arguments" || LU(o) && l === "arguments" || FU(o) && l === "params" ? u = "param" : MU(o) && !Zn(e) ?
    (u = "statement", t = t.slice(0, -1)) : qU(e) && Zn(e) ? u = "statement" : u = "other";
    let {
      placeholders: c,
      placeholderNames: p
    } = a ? r.syntactic : r.legacy;
    c.push({
      name: n,
      type: u,
      resolve: /* @__PURE__ */ s((g) => XU(g, t), "resolve"),
      isDuplicate: p.has(n)
    }), p.add(n);
  }
  s(YU, "placeholderVisitorHandler");
  function XU(e, t) {
    let r = e;
    for (let a = 0; a < t.length - 1; a++) {
      let {
        key: o,
        index: l
      } = t[a];
      l === void 0 ? r = r[o] : r = r[o][l];
    }
    let {
      key: i,
      index: n
    } = t[t.length - 1];
    return {
      parent: r,
      key: i,
      index: n
    };
  }
  s(XU, "resolveAncestors");
  function JU(e, t, r) {
    let i = (t.plugins || []).slice();
    r !== !1 && i.push("placeholders"), t = Object.assign({
      allowReturnOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      sourceType: "module"
    }, t, {
      plugins: i
    });
    try {
      return (0, DU.parse)(e, t);
    } catch (n) {
      let a = n.loc;
      throw a && (n.message += `
` + (0, kU.codeFrameColumns)(e, {
        start: a
      }), n.code = "BABEL_TEMPLATE_PARSE_ERROR"), n;
    }
  }
  s(JU, "parseWithCodeFrame");
});

// ../node_modules/@babel/template/lib/populate.js
var bc = v((gc) => {
  "use strict";
  Object.defineProperty(gc, "__esModule", {
    value: !0
  });
  gc.default = ZU;
  var $U = le(), {
    blockStatement: HU,
    cloneNode: Tc,
    emptyStatement: GU,
    expressionStatement: yc,
    identifier: ea,
    isStatement: pT,
    isStringLiteral: zU,
    stringLiteral: QU,
    validate: fT
  } = $U;
  function ZU(e, t) {
    let r = Tc(e.ast);
    return t && (e.placeholders.forEach((i) => {
      if (!hasOwnProperty.call(t, i.name)) {
        let n = i.name;
        throw new Error(`Error: No substitution given for "${n}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${n}'])}
            - { placeholderPattern: /^${n}$/ }`);
      }
    }), Object.keys(t).forEach((i) => {
      if (!e.placeholderNames.has(i))
        throw new Error(`Unknown substitution "${i}" given`);
    })), e.placeholders.slice().reverse().forEach((i) => {
      try {
        eK(i, r, t && t[i.name] || null);
      } catch (n) {
        throw n.message = `@babel/template placeholder "${i.name}": ${n.message}`, n;
      }
    }), r;
  }
  s(ZU, "populatePlaceholders");
  function eK(e, t, r) {
    e.isDuplicate && (Array.isArray(r) ? r = r.map((o) => Tc(o)) : typeof r == "object" && (r = Tc(r)));
    let {
      parent: i,
      key: n,
      index: a
    } = e.resolve(t);
    if (e.type === "string") {
      if (typeof r == "string" && (r = QU(r)), !r || !zU(r))
        throw new Error("Expected string substitution");
    } else if (e.type === "statement")
      a === void 0 ? r ? Array.isArray(r) ? r = HU(r) : typeof r == "string" ? r = yc(ea(r)) : pT(r) || (r = yc(r)) : r = GU() : r && !Array.
      isArray(r) && (typeof r == "string" && (r = ea(r)), pT(r) || (r = yc(r)));
    else if (e.type === "param") {
      if (typeof r == "string" && (r = ea(r)), a === void 0) throw new Error("Assertion failure.");
    } else if (typeof r == "string" && (r = ea(r)), Array.isArray(r))
      throw new Error("Cannot replace single expression with an array.");
    if (a === void 0)
      fT(i, n, r), i[n] = r;
    else {
      let o = i[n].slice();
      e.type === "statement" || e.type === "param" ? r == null ? o.splice(a, 1) : Array.isArray(r) ? o.splice(a, 1, ...r) : o[a] = r : o[a] =
      r, fT(i, n, o), i[n] = o;
    }
  }
  s(eK, "applyReplacement");
});

// ../node_modules/@babel/template/lib/string.js
var hT = v((Sc) => {
  "use strict";
  Object.defineProperty(Sc, "__esModule", {
    value: !0
  });
  Sc.default = sK;
  var tK = Qn(), rK = mc(), iK = bc();
  function sK(e, t, r) {
    t = e.code(t);
    let i;
    return (n) => {
      let a = (0, tK.normalizeReplacements)(n);
      return i || (i = (0, rK.default)(e, t, r)), e.unwrap((0, iK.default)(i, a));
    };
  }
  s(sK, "stringTemplate");
});

// ../node_modules/@babel/template/lib/literal.js
var dT = v((xc) => {
  "use strict";
  Object.defineProperty(xc, "__esModule", {
    value: !0
  });
  xc.default = lK;
  var nK = Qn(), aK = mc(), oK = bc();
  function lK(e, t, r) {
    let {
      metadata: i,
      names: n
    } = uK(e, t, r);
    return (a) => {
      let o = {};
      return a.forEach((l, u) => {
        o[n[u]] = l;
      }), (l) => {
        let u = (0, nK.normalizeReplacements)(l);
        return u && Object.keys(u).forEach((c) => {
          if (hasOwnProperty.call(o, c))
            throw new Error("Unexpected replacement overlap.");
        }), e.unwrap((0, oK.default)(i, u ? Object.assign(u, o) : o));
      };
    };
  }
  s(lK, "literalTemplate");
  function uK(e, t, r) {
    let i = "BABEL_TPL$", n = t.join("");
    do
      i = "$$" + i;
    while (n.includes(i));
    let {
      names: a,
      code: o
    } = cK(t, i);
    return {
      metadata: (0, aK.default)(e, e.code(o), {
        parser: r.parser,
        placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
        placeholderPattern: r.placeholderPattern,
        preserveComments: r.preserveComments,
        syntacticPlaceholders: r.syntacticPlaceholders
      }),
      names: a
    };
  }
  s(uK, "buildLiteralData");
  function cK(e, t) {
    let r = [], i = e[0];
    for (let n = 1; n < e.length; n++) {
      let a = `${t}${n - 1}`;
      r.push(a), i += a + e[n];
    }
    return {
      names: r,
      code: i
    };
  }
  s(cK, "buildTemplateCode");
});

// ../node_modules/@babel/template/lib/builder.js
var ST = v((Ec) => {
  "use strict";
  Object.defineProperty(Ec, "__esModule", {
    value: !0
  });
  Ec.default = bT;
  var qt = Qn(), mT = hT(), yT = dT(), TT = (0, qt.validate)({
    placeholderPattern: !1
  });
  function bT(e, t) {
    let r = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), n = t || (0, qt.validate)(null);
    return Object.assign((a, ...o) => {
      if (typeof a == "string") {
        if (o.length > 1) throw new Error("Unexpected extra params.");
        return gT((0, mT.default)(e, a, (0, qt.merge)(n, (0, qt.validate)(o[0]))));
      } else if (Array.isArray(a)) {
        let l = r.get(a);
        return l || (l = (0, yT.default)(e, a, n), r.set(a, l)), gT(l(o));
      } else if (typeof a == "object" && a) {
        if (o.length > 0) throw new Error("Unexpected extra params.");
        return bT(e, (0, qt.merge)(n, (0, qt.validate)(a)));
      }
      throw new Error(`Unexpected template param ${typeof a}`);
    }, {
      ast: /* @__PURE__ */ s((a, ...o) => {
        if (typeof a == "string") {
          if (o.length > 1) throw new Error("Unexpected extra params.");
          return (0, mT.default)(e, a, (0, qt.merge)((0, qt.merge)(n, (0, qt.validate)(o[0])), TT))();
        } else if (Array.isArray(a)) {
          let l = i.get(a);
          return l || (l = (0, yT.default)(e, a, (0, qt.merge)(n, TT)), i.set(a, l)), l(o)();
        }
        throw new Error(`Unexpected template param ${typeof a}`);
      }, "ast")
    });
  }
  s(bT, "createTemplateBuilder");
  function gT(e) {
    let t = "";
    try {
      throw new Error();
    } catch (r) {
      r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
    }
    return (r) => {
      try {
        return e(r);
      } catch (i) {
        throw i.stack += `
    =============
${t}`, i;
      }
    };
  }
  s(gT, "extendedTrace");
});

// ../node_modules/@babel/template/lib/index.js
var xT = v((gt) => {
  "use strict";
  Object.defineProperty(gt, "__esModule", {
    value: !0
  });
  gt.statements = gt.statement = gt.smart = gt.program = gt.expression = gt.default = void 0;
  var ys = uT(), Ts = ST(), Pc = gt.smart = (0, Ts.default)(ys.smart), pK = gt.statement = (0, Ts.default)(ys.statement), fK = gt.statements =
  (0, Ts.default)(ys.statements), hK = gt.expression = (0, Ts.default)(ys.expression), dK = gt.program = (0, Ts.default)(ys.program), ete = gt.
  default = Object.assign(Pc.bind(void 0), {
    smart: Pc,
    statement: pK,
    statements: fK,
    expression: hK,
    program: dK,
    ast: Pc.ast
  });
});

// ../node_modules/@babel/helper-function-name/lib/index.js
var IT = v((Ac) => {
  "use strict";
  Object.defineProperty(Ac, "__esModule", {
    value: !0
  });
  Ac.default = MK;
  var vT = xT(), mK = le(), {
    NOT_LOCAL_BINDING: ET,
    cloneNode: yK,
    identifier: TK,
    isAssignmentExpression: gK,
    isAssignmentPattern: bK,
    isFunction: CT,
    isIdentifier: PT,
    isLiteral: AT,
    isNullLiteral: SK,
    isObjectMethod: xK,
    isObjectProperty: EK,
    isRegExpLiteral: PK,
    isRestElement: AK,
    isTemplateLiteral: vK,
    isVariableDeclarator: CK,
    toBindingIdentifierName: IK
  } = mK;
  function wK(e) {
    let t = e.params.findIndex((r) => bK(r) || AK(r));
    return t === -1 ? e.params.length : t;
  }
  s(wK, "getFunctionArity");
  var OK = vT.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), NK = vT.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), _K = {
    "ReferencedIdentifier|BindingIdentifier"(e, t) {
      e.node.name !== t.name || e.scope.getBindingIdentifier(t.name) !== t.outerDeclar || (t.selfReference = !0, e.stop());
    }
  };
  function DK(e) {
    return SK(e) ? "null" : PK(e) ? `_${e.pattern}_${e.flags}` : vK(e) ? e.quasis.map((t) => t.value.raw).join("") : e.value !== void 0 ? e.
    value + "" : "";
  }
  s(DK, "getNameFromLiteralId");
  function kK(e, t, r, i) {
    if (e.selfReference)
      if (i.hasBinding(r.name) && !i.hasGlobal(r.name))
        i.rename(r.name);
      else {
        if (!CT(t)) return;
        let n = OK;
        t.generator && (n = NK);
        let a = n({
          FUNCTION: t,
          FUNCTION_ID: r,
          FUNCTION_KEY: i.generateUidIdentifier(r.name)
        }).expression, o = a.callee.body.body[0].params;
        for (let l = 0, u = wK(t); l < u; l++)
          o.push(i.generateUidIdentifier("x"));
        return a;
      }
    t.id = r, i.getProgramParent().references[r.name] = !0;
  }
  s(kK, "wrap");
  function LK(e, t, r) {
    let i = {
      selfAssignment: !1,
      selfReference: !1,
      outerDeclar: r.getBindingIdentifier(t),
      name: t
    }, n = r.getOwnBinding(t);
    return n ? n.kind === "param" && (i.selfReference = !0) : (i.outerDeclar || r.hasGlobal(t)) && r.traverse(e, _K, i), i;
  }
  s(LK, "visit");
  function MK({
    node: e,
    parent: t,
    scope: r,
    id: i
  }, n = !1, a = !1) {
    if (e.id) return;
    if ((EK(t) || xK(t, {
      kind: "method"
    })) && (!t.computed || AT(t.key)))
      i = t.key;
    else if (CK(t)) {
      if (i = t.id, PT(i) && !n) {
        let c = r.parent.getBinding(i.name);
        if (c && c.constant && r.getBinding(i.name) === c) {
          e.id = yK(i), e.id[ET] = !0;
          return;
        }
      }
    } else if (gK(t, {
      operator: "="
    }))
      i = t.left;
    else if (!i)
      return;
    let o;
    if (i && AT(i) ? o = DK(i) : i && PT(i) && (o = i.name), o === void 0 || !a && CT(e) && /[\uD800-\uDFFF]/.test(o))
      return;
    o = IK(o);
    let l = TK(o);
    l[ET] = !0;
    let u = LK(e, o, r);
    return kK(u, e, l, r) || e;
  }
  s(MK, "_default");
});

// ../node_modules/@babel/traverse/lib/path/conversion.js
var DT = v((Wr) => {
  "use strict";
  Object.defineProperty(Wr, "__esModule", {
    value: !0
  });
  Wr.arrowFunctionToExpression = iW;
  Wr.ensureBlock = eW;
  Wr.toComputedKey = ZK;
  Wr.unwrapFunctionEnvironment = tW;
  var FK = le(), Ic = ru(), BK = IT(), wc = Zi(), {
    arrowFunctionExpression: Oc,
    assignmentExpression: Kr,
    binaryExpression: vc,
    blockStatement: jK,
    callExpression: xi,
    conditionalExpression: RK,
    expressionStatement: wT,
    identifier: Be,
    isIdentifier: qK,
    jsxIdentifier: VK,
    logicalExpression: UK,
    LOGICAL_OPERATORS: KK,
    memberExpression: kt,
    metaProperty: WK,
    numericLiteral: YK,
    objectExpression: XK,
    restElement: JK,
    returnStatement: $K,
    sequenceExpression: HK,
    spreadElement: GK,
    stringLiteral: OT,
    super: Cc,
    thisExpression: gs,
    toExpression: zK,
    unaryExpression: QK
  } = FK;
  function ZK() {
    let e;
    if (this.isMemberExpression())
      e = this.node.property;
    else if (this.isProperty() || this.isMethod())
      e = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || qK(e) && (e = OT(e.name)), e;
  }
  s(ZK, "toComputedKey");
  function eW() {
    let e = this.get("body"), t = e.node;
    if (Array.isArray(e))
      throw new Error("Can't convert array path to a block statement");
    if (!t)
      throw new Error("Can't convert node without a body");
    if (e.isBlockStatement())
      return t;
    let r = [], i = "body", n, a;
    e.isStatement() ? (a = "body", n = 0, r.push(e.node)) : (i += ".body.0", this.isFunction() ? (n = "argument", r.push($K(e.node))) : (n =
    "expression", r.push(wT(e.node)))), this.node.body = jK(r);
    let o = this.get(i);
    return e.setup(o, a ? o.node[a] : o.node, a, n), this.node;
  }
  s(eW, "ensureBlock");
  Wr.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function tW() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    NT(this);
  }
  s(tW, "unwrapFunctionEnvironment");
  function rW(e, t) {
    e.node.type = t;
  }
  s(rW, "setType");
  function iW({
    allowInsertArrow: e = !0,
    allowInsertArrowWithRest: t = e,
    noNewArrows: r = !((i) => (i = arguments[0]) == null ? void 0 : i.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let {
      thisBinding: i,
      fnPath: n
    } = NT(this, r, e, t);
    if (n.ensureBlock(), rW(n, "FunctionExpression"), !r) {
      let a = i ? null : n.scope.generateUidIdentifier("arrowCheckId");
      return a && n.parentPath.scope.push({
        id: a,
        init: XK([])
      }), n.get("body").unshiftContainer("body", wT(xi(this.hub.addHelper("newArrowCheck"), [gs(), Be(a ? a.name : i)]))), n.replaceWith(xi(
      kt((0, BK.default)(this, !0) || n.node, Be("bind")), [a ? Be(a.name) : gs()])), n.get("callee.object");
    }
    return n;
  }
  s(iW, "arrowFunctionToExpression");
  var sW = (0, wc.merge)([{
    CallExpression(e, {
      allSuperCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    }
  }, Ic.default]);
  function NT(e, t = !0, r = !0, i = !0) {
    let n, a = e.findParent((A) => {
      if (A.isArrowFunctionExpression()) {
        var C;
        return (C = n) != null || (n = A), !1;
      }
      return A.isFunction() || A.isProgram() || A.isClassProperty({
        static: !1
      }) || A.isClassPrivateProperty({
        static: !1
      });
    }), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (n)
        a = n;
      else if (r)
        e.replaceWith(xi(Oc([], zK(e.node)), [])), a = e.get("callee"), e = a.get("body");
      else
        throw e.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: l,
      argumentsPaths: u,
      newTargetPaths: c,
      superProps: p,
      superCalls: g
    } = fW(e);
    if (o && g.length > 0) {
      if (!r)
        throw g[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!i)
        throw g[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let A = [];
      a.traverse(sW, {
        allSuperCalls: A
      });
      let C = uW(a);
      A.forEach((_) => {
        let k = Be(C);
        k.loc = _.node.callee.loc, _.get("callee").replaceWith(k);
      });
    }
    if (u.length > 0) {
      let A = bs(a, "arguments", () => {
        let C = /* @__PURE__ */ s(() => Be("arguments"), "args");
        return a.scope.path.isProgram() ? RK(vc("===", QK("typeof", C()), OT("undefined")), a.scope.buildUndefinedNode(), C()) : C();
      });
      u.forEach((C) => {
        let _ = Be(A);
        _.loc = C.node.loc, C.replaceWith(_);
      });
    }
    if (c.length > 0) {
      let A = bs(a, "newtarget", () => WK(Be("new"), Be("target")));
      c.forEach((C) => {
        let _ = Be(A);
        _.loc = C.node.loc, C.replaceWith(_);
      });
    }
    if (p.length > 0) {
      if (!r)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      p.reduce((C, _) => C.concat(aW(_)), []).forEach((C) => {
        let _ = C.node.computed ? "" : C.get("property").node.name, k = C.parentPath, O = k.isAssignmentExpression({
          left: C.node
        }), M = k.isCallExpression({
          callee: C.node
        }), F = k.isTaggedTemplateExpression({
          tag: C.node
        }), G = cW(a, O, _), $ = [];
        if (C.node.computed && $.push(C.get("property").node), O) {
          let oe = k.node.right;
          $.push(oe);
        }
        let K = xi(Be(G), $);
        M ? (k.unshiftContainer("arguments", gs()), C.replaceWith(kt(K, Be("call"))), l.push(k.get("arguments.0"))) : O ? k.replaceWith(K) :
        F ? (C.replaceWith(xi(kt(K, Be("bind"), !1), [gs()])), l.push(C.get("arguments.0"))) : C.replaceWith(K);
      });
    }
    let P;
    return (l.length > 0 || !t) && (P = lW(a, o), (t || o && _T(a)) && (l.forEach((A) => {
      let C = A.isJSX() ? VK(P) : Be(P);
      C.loc = A.node.loc, A.replaceWith(C);
    }), t || (P = null))), {
      thisBinding: P,
      fnPath: e
    };
  }
  s(NT, "hoistFunctionEnvironment");
  function nW(e) {
    return KK.includes(e);
  }
  s(nW, "isLogicalOp");
  function aW(e) {
    if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
      let r = e.parentPath, i = r.node.operator.slice(0, -1), n = r.node.right, a = nW(i);
      if (e.node.computed) {
        let o = e.scope.generateDeclaredUidIdentifier("tmp"), l = e.node.object, u = e.node.property;
        r.get("left").replaceWith(kt(l, Kr("=", o, u), !0)), r.get("right").replaceWith(t(a ? "=" : i, kt(l, Be(o.name), !0), n));
      } else {
        let o = e.node.object, l = e.node.property;
        r.get("left").replaceWith(kt(o, l)), r.get("right").replaceWith(t(a ? "=" : i, kt(o, Be(l.name)), n));
      }
      return a ? r.replaceWith(UK(i, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
    } else if (e.parentPath.isUpdateExpression()) {
      let r = e.parentPath, i = e.scope.generateDeclaredUidIdentifier("tmp"), n = e.node.computed ? e.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [Kr("=", i, kt(e.node.object, n ? Kr("=", n, e.node.property) : e.node.property, e.node.computed)), Kr("=", kt(e.node.object,
      n ? Be(n.name) : e.node.property, e.node.computed), vc(e.parentPath.node.operator[0], Be(i.name), YK(1)))];
      e.parentPath.node.prefix || a.push(Be(i.name)), r.replaceWith(HK(a));
      let o = r.get("expressions.0.right"), l = r.get("expressions.1.left");
      return [o, l];
    }
    return [e];
    function t(r, i, n) {
      return r === "=" ? Kr("=", i, n) : vc(r, i, n);
    }
  }
  s(aW, "standardizeSuperProperty");
  function _T(e) {
    return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
  }
  s(_T, "hasSuperClass");
  var oW = (0, wc.merge)([{
    CallExpression(e, {
      supers: t,
      thisBinding: r
    }) {
      e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, Kr("=", Be(r), Be("this"))])));
    }
  }, Ic.default]);
  function lW(e, t) {
    return bs(e, "this", (r) => {
      if (!t || !_T(e)) return gs();
      e.traverse(oW, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: r
      });
    });
  }
  s(lW, "getThisBinding");
  function uW(e) {
    return bs(e, "supercall", () => {
      let t = e.scope.generateUidIdentifier("args");
      return Oc([JK(t)], xi(Cc(), [GK(Be(t.name))]));
    });
  }
  s(uW, "getSuperBinding");
  function cW(e, t, r) {
    return bs(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
      let n = [], a;
      if (r)
        a = kt(Cc(), Be(r));
      else {
        let o = e.scope.generateUidIdentifier("prop");
        n.unshift(o), a = kt(Cc(), Be(o.name), !0);
      }
      if (t) {
        let o = e.scope.generateUidIdentifier("value");
        n.push(o), a = Kr("=", a, Be(o.name));
      }
      return Oc(n, a);
    });
  }
  s(cW, "getSuperPropBinding");
  function bs(e, t, r) {
    let i = "binding:" + t, n = e.getData(i);
    if (!n) {
      let a = e.scope.generateUidIdentifier(t);
      n = a.name, e.setData(i, n), e.scope.push({
        id: a,
        init: r(n)
      });
    }
    return n;
  }
  s(bs, "getBinding");
  var pW = (0, wc.merge)([{
    ThisExpression(e, {
      thisPaths: t
    }) {
      t.push(e);
    },
    JSXIdentifier(e, {
      thisPaths: t
    }) {
      e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
        object: e.node
      }) && !e.parentPath.isJSXOpeningElement({
        name: e.node
      }) || t.push(e));
    },
    CallExpression(e, {
      superCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    },
    MemberExpression(e, {
      superProps: t
    }) {
      e.get("object").isSuper() && t.push(e);
    },
    Identifier(e, {
      argumentsPaths: t
    }) {
      if (!e.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let r = e.scope;
      do {
        if (r.hasOwnBinding("arguments")) {
          r.rename("arguments");
          return;
        }
        if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
      } while (r = r.parent);
      t.push(e);
    },
    MetaProperty(e, {
      newTargetPaths: t
    }) {
      e.get("meta").isIdentifier({
        name: "new"
      }) && e.get("property").isIdentifier({
        name: "target"
      }) && t.push(e);
    }
  }, Ic.default]);
  function fW(e) {
    let t = [], r = [], i = [], n = [], a = [];
    return e.traverse(pW, {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: i,
      superProps: n,
      superCalls: a
    }), {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: i,
      superProps: n,
      superCalls: a
    };
  }
  s(fW, "getScopeInformation");
});

// ../node_modules/@babel/traverse/lib/path/introspection.js
var jT = v((Ue) => {
  "use strict";
  Object.defineProperty(Ue, "__esModule", {
    value: !0
  });
  Ue._guessExecutionStatusRelativeTo = MW;
  Ue._resolve = RW;
  Ue.canHaveVariableDeclarationOrExpression = IW;
  Ue.canSwapBetweenExpressionAndStatement = wW;
  Ue.equals = vW;
  Ue.getSource = DW;
  Ue.has = BT;
  Ue.is = void 0;
  Ue.isCompletionRecord = OW;
  Ue.isConstantExpression = qW;
  Ue.isInStrictMode = VW;
  Ue.isNodeType = CW;
  Ue.isStatementOrBlock = NW;
  Ue.isStatic = PW;
  Ue.isnt = AW;
  Ue.matchesPattern = EW;
  Ue.referencesImport = _W;
  Ue.resolve = jW;
  Ue.willIMaybeExecuteBefore = kW;
  var hW = le(), {
    STATEMENT_OR_BLOCK_KEYS: dW,
    VISITOR_KEYS: mW,
    isBlockStatement: FT,
    isExpression: yW,
    isIdentifier: TW,
    isLiteral: gW,
    isStringLiteral: bW,
    isType: SW,
    matchesPattern: xW
  } = hW;
  function EW(e, t) {
    return xW(this.node, e, t);
  }
  s(EW, "matchesPattern");
  function BT(e) {
    let t = this.node && this.node[e];
    return t && Array.isArray(t) ? !!t.length : !!t;
  }
  s(BT, "has");
  function PW() {
    return this.scope.isStatic(this.node);
  }
  s(PW, "isStatic");
  var ate = Ue.is = BT;
  function AW(e) {
    return !this.has(e);
  }
  s(AW, "isnt");
  function vW(e, t) {
    return this.node[e] === t;
  }
  s(vW, "equals");
  function CW(e) {
    return SW(this.type, e);
  }
  s(CW, "isNodeType");
  function IW() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  s(IW, "canHaveVariableDeclarationOrExpression");
  function wW(e) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? FT(e) : this.isBlockStatement() ?
    yW(e) : !1;
  }
  s(wW, "canSwapBetweenExpressionAndStatement");
  function OW(e) {
    let t = this, r = !0;
    do {
      let {
        type: i,
        container: n
      } = t;
      if (!r && (t.isFunction() || i === "StaticBlock"))
        return !!e;
      if (r = !1, Array.isArray(n) && t.key !== n.length - 1)
        return !1;
    } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
    return !0;
  }
  s(OW, "isCompletionRecord");
  function NW() {
    return this.parentPath.isLabeledStatement() || FT(this.container) ? !1 : dW.includes(this.key);
  }
  s(NW, "isStatementOrBlock");
  function _W(e, t) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? bW(this.node.property, {
        value: t
      }) : this.node.property.name === t)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(e, "*");
      }
      return !1;
    }
    let r = this.scope.getBinding(this.node.name);
    if (!r || r.kind !== "module") return !1;
    let i = r.path, n = i.parentPath;
    if (!n.isImportDeclaration()) return !1;
    if (n.node.source.value === e) {
      if (!t) return !0;
    } else
      return !1;
    return !!(i.isImportDefaultSpecifier() && t === "default" || i.isImportNamespaceSpecifier() && t === "*" || i.isImportSpecifier() && TW(
    i.node.imported, {
      name: t
    }));
  }
  s(_W, "referencesImport");
  function DW() {
    let e = this.node;
    if (e.end) {
      let t = this.hub.getCode();
      if (t) return t.slice(e.start, e.end);
    }
    return "";
  }
  s(DW, "getSource");
  function kW(e) {
    return this._guessExecutionStatusRelativeTo(e) !== "after";
  }
  s(kW, "willIMaybeExecuteBefore");
  function kT(e) {
    return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
  }
  s(kT, "getOuterFunction");
  function LW(e, t) {
    switch (e) {
      case "LogicalExpression":
        return t === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return t === "consequent" || t === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return t === "body";
      case "ForStatement":
        return t === "body" || t === "update";
      case "SwitchStatement":
        return t === "cases";
      case "TryStatement":
        return t === "handler";
      case "AssignmentPattern":
        return t === "right";
      case "OptionalMemberExpression":
        return t === "property";
      case "OptionalCallExpression":
        return t === "arguments";
      default:
        return !1;
    }
  }
  s(LW, "isExecutionUncertain");
  function LT(e, t) {
    for (let r = 0; r < t; r++) {
      let i = e[r];
      if (LW(i.parent.type, i.parentKey))
        return !0;
    }
    return !1;
  }
  s(LT, "isExecutionUncertainInList");
  var MT = Symbol();
  function MW(e) {
    return Nc(this, e, /* @__PURE__ */ new Map());
  }
  s(MW, "_guessExecutionStatusRelativeTo");
  function Nc(e, t, r) {
    let i = {
      this: kT(e),
      target: kT(t)
    };
    if (i.target.node !== i.this.node)
      return BW(e, i.target, r);
    let n = {
      target: t.getAncestry(),
      this: e.getAncestry()
    };
    if (n.target.indexOf(e) >= 0) return "after";
    if (n.this.indexOf(t) >= 0) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < n.this.length; ) {
      let p = n.this[o.this];
      o.target = n.target.indexOf(p), o.target >= 0 ? a = p : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (LT(n.this, o.this - 1) || LT(n.target, o.target - 1))
      return "unknown";
    let l = {
      this: n.this[o.this - 1],
      target: n.target[o.target - 1]
    };
    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container)
      return l.target.key > l.this.key ? "before" : "after";
    let u = mW[a.type], c = {
      this: u.indexOf(l.this.parentKey),
      target: u.indexOf(l.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  s(Nc, "_guessExecutionStatusRelativeToCached");
  function FW(e, t, r) {
    if (t.isFunctionDeclaration()) {
      if (t.parentPath.isExportDeclaration())
        return "unknown";
    } else return Nc(e, t, r) === "before" ? "before" : "unknown";
    let i = t.scope.getBinding(t.node.id.name);
    if (!i.references) return "before";
    let n = i.referencePaths, a;
    for (let o of n) {
      if (!!o.find((c) => c.node === t.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let u = Nc(e, o, r);
      if (a && a !== u)
        return "unknown";
      a = u;
    }
    return a;
  }
  s(FW, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function BW(e, t, r) {
    let i = r.get(e.node), n;
    if (!i)
      r.set(e.node, i = /* @__PURE__ */ new Map());
    else if (n = i.get(t.node))
      return n === MT ? "unknown" : n;
    i.set(t.node, MT);
    let a = FW(e, t, r);
    return i.set(t.node, a), a;
  }
  s(BW, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function jW(e, t) {
    return this._resolve(e, t) || this;
  }
  s(jW, "resolve");
  function RW(e, t) {
    if (!(t && t.indexOf(this) >= 0))
      if (t = t || [], t.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(e, t);
      } else if (this.isReferencedIdentifier()) {
        let r = this.scope.getBinding(this.node.name);
        if (!r || !r.constant || r.kind === "module") return;
        if (r.path !== this) {
          let i = r.path.resolve(e, t);
          return this.find((n) => n.node === i.node) ? void 0 : i;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(e, t);
        if (e && this.isMemberExpression()) {
          let r = this.toComputedKey();
          if (!gW(r)) return;
          let i = r.value, n = this.get("object").resolve(e, t);
          if (n.isObjectExpression()) {
            let a = n.get("properties");
            for (let o of a) {
              if (!o.isProperty()) continue;
              let l = o.get("key"), u = o.isnt("computed") && l.isIdentifier({
                name: i
              });
              if (u = u || l.isLiteral({
                value: i
              }), u) return o.get("value").resolve(e, t);
            }
          } else if (n.isArrayExpression() && !isNaN(+i)) {
            let o = n.get("elements")[i];
            if (o) return o.resolve(e, t);
          }
        }
      }
  }
  s(RW, "_resolve");
  function qW() {
    if (this.isIdentifier()) {
      let e = this.scope.getBinding(this.node.name);
      return e ? e.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: e
      } = this.node;
      return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  s(qW, "isConstantExpression");
  function VW() {
    return !!(this.isProgram() ? this : this.parentPath).find((r) => {
      if (r.isProgram({
        sourceType: "module"
      }) || r.isClass()) return !0;
      if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
        return !1;
      let i;
      if (r.isFunction())
        i = r.node.body;
      else if (r.isProgram())
        i = r.node;
      else
        return !1;
      for (let n of i.directives)
        if (n.value.value === "use strict")
          return !0;
    });
  }
  s(VW, "isInStrictMode");
});

// ../node_modules/@babel/traverse/lib/path/context.js
var VT = v((qe) => {
  "use strict";
  Object.defineProperty(qe, "__esModule", {
    value: !0
  });
  qe._call = WW;
  qe._getQueueContexts = lY;
  qe._resyncKey = eY;
  qe._resyncList = tY;
  qe._resyncParent = ZW;
  qe._resyncRemoved = rY;
  qe.call = KW;
  qe.isBlacklisted = qe.isDenylisted = YW;
  qe.popContext = iY;
  qe.pushContext = sY;
  qe.requeue = oY;
  qe.resync = QW;
  qe.setContext = zW;
  qe.setKey = aY;
  qe.setScope = GW;
  qe.setup = nY;
  qe.skip = JW;
  qe.skipKey = $W;
  qe.stop = HW;
  qe.visit = XW;
  var UW = vn(), RT = gr();
  function KW(e) {
    let t = this.opts;
    if (this.debug(e), this.node && this._call(t[e]))
      return !0;
    if (this.node) {
      var r;
      return this._call((r = t[this.node.type]) == null ? void 0 : r[e]);
    }
    return !1;
  }
  s(KW, "call");
  function WW(e) {
    if (!e) return !1;
    for (let t of e) {
      if (!t) continue;
      let r = this.node;
      if (!r) return !0;
      let i = t.call(this.state, this, this.state);
      if (i && typeof i == "object" && typeof i.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (i)
        throw new Error(`Unexpected return value from visitor method ${t}`);
      if (this.node !== r || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  s(WW, "_call");
  function YW() {
    var e;
    let t = (e = this.opts.denylist) != null ? e : this.opts.blacklist;
    return t && t.indexOf(this.node.type) > -1;
  }
  s(YW, "isDenylisted");
  function qT(e, t) {
    e.context !== t && (e.context = t, e.state = t.state, e.opts = t.opts);
  }
  s(qT, "restoreContext");
  function XW() {
    var e, t;
    if (!this.node || this.isDenylisted() || (e = (t = this.opts).shouldSkip) != null && e.call(t, this))
      return !1;
    let r = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (qT(this, r), this.debug("Recursing into..."),
    this.shouldStop = (0, UW.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), qT(this, r), this.call("exit"),
    this.shouldStop);
  }
  s(XW, "visit");
  function JW() {
    this.shouldSkip = !0;
  }
  s(JW, "skip");
  function $W(e) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[e] = !0;
  }
  s($W, "skipKey");
  function HW() {
    this._traverseFlags |= RT.SHOULD_SKIP | RT.SHOULD_STOP;
  }
  s(HW, "stop");
  function GW() {
    var e, t;
    if ((e = this.opts) != null && e.noScope) return;
    let r = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) && (r = r.
    parentPath);
    let i;
    for (; r && !i; ) {
      var n;
      if ((n = r.opts) != null && n.noScope) return;
      i = r.scope, r = r.parentPath;
    }
    this.scope = this.getScope(i), (t = this.scope) == null || t.init();
  }
  s(GW, "setScope");
  function zW(e) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, e && (this.context = e, this.state = e.state, this.opts =
    e.opts), this.setScope(), this;
  }
  s(zW, "setContext");
  function QW() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }
  s(QW, "resync");
  function ZW() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  s(ZW, "_resyncParent");
  function eY() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let e = 0; e < this.container.length; e++)
          if (this.container[e] === this.node) {
            this.setKey(e);
            return;
          }
      } else
        for (let e of Object.keys(this.container))
          if (this.container[e] === this.node) {
            this.setKey(e);
            return;
          }
      this.key = null;
    }
  }
  s(eY, "_resyncKey");
  function tY() {
    if (!this.parent || !this.inList) return;
    let e = this.parent[this.listKey];
    this.container !== e && (this.container = e || null);
  }
  s(tY, "_resyncList");
  function rY() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && this._markRemoved();
  }
  s(rY, "_resyncRemoved");
  function iY() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  s(iY, "popContext");
  function sY(e) {
    this.contexts.push(e), this.setContext(e);
  }
  s(sY, "pushContext");
  function nY(e, t, r, i) {
    this.listKey = r, this.container = t, this.parentPath = e || this.parentPath, this.setKey(i);
  }
  s(nY, "setup");
  function aY(e) {
    var t;
    this.key = e, this.node = this.container[this.key], this.type = (t = this.node) == null ? void 0 : t.type;
  }
  s(aY, "setKey");
  function oY(e = this) {
    if (e.removed) return;
    let t = this.contexts;
    for (let r of t)
      r.maybeQueue(e);
  }
  s(oY, "requeue");
  function lY() {
    let e = this, t = this.contexts;
    for (; !t.length && (e = e.parentPath, !!e); )
      t = e.contexts;
    return t;
  }
  s(lY, "_getQueueContexts");
});

// ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var UT = v((ta) => {
  "use strict";
  Object.defineProperty(ta, "__esModule", {
    value: !0
  });
  ta.hooks = void 0;
  var pte = ta.hooks = [function(e, t) {
    if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.
    isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expr\
ession" && t.isExpressionStatement())
      return t.remove(), !0;
  }, function(e, t) {
    if (t.isSequenceExpression() && t.node.expressions.length === 1)
      return t.replaceWith(t.node.expressions[0]), !0;
  }, function(e, t) {
    if (t.isBinary())
      return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
  }, function(e, t) {
    if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
      return e.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/traverse/lib/path/removal.js
var WT = v((br) => {
  "use strict";
  Object.defineProperty(br, "__esModule", {
    value: !0
  });
  br._assertUnremoved = gY;
  br._callRemovalHooks = mY;
  br._markRemoved = TY;
  br._remove = yY;
  br._removeFromScope = dY;
  br.remove = hY;
  var uY = UT(), cY = Lr(), KT = gr(), pY = le(), {
    getBindingIdentifiers: fY
  } = pY;
  function hY() {
    var e;
    if (this._assertUnremoved(), this.resync(), (e = this.opts) != null && e.noScope || this._removeFromScope(), this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
  }
  s(hY, "remove");
  function dY() {
    let e = fY(this.node, !1, !1, !0);
    Object.keys(e).forEach((t) => this.scope.removeBinding(t));
  }
  s(dY, "_removeFromScope");
  function mY() {
    if (this.parentPath) {
      for (let e of uY.hooks)
        if (e(this, this.parentPath)) return !0;
    }
  }
  s(mY, "_callRemovalHooks");
  function yY() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }
  s(yY, "_remove");
  function TY() {
    this._traverseFlags |= KT.SHOULD_SKIP | KT.REMOVED, this.parent && (0, cY.getCachedPaths)(this.hub, this.parent).delete(this.node), this.
    node = null;
  }
  s(TY, "_markRemoved");
  function gY() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  s(gY, "_assertUnremoved");
});

// ../node_modules/@babel/traverse/lib/path/lib/hoister.js
var XT = v((ra) => {
  "use strict";
  Object.defineProperty(ra, "__esModule", {
    value: !0
  });
  ra.default = void 0;
  var YT = le(), bY = YT, {
    react: SY
  } = YT, {
    cloneNode: xY,
    jsxExpressionContainer: EY,
    variableDeclaration: PY,
    variableDeclarator: AY
  } = bY, vY = {
    ReferencedIdentifier(e, t) {
      if (e.isJSXIdentifier() && SY.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
        return;
      if (e.node.name === "this") {
        let i = e.scope;
        do
          if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
            break;
        while (i = i.parent);
        i && t.breakOnScopePaths.push(i.path);
      }
      let r = e.scope.getBinding(e.node.name);
      if (r) {
        for (let i of r.constantViolations)
          if (i.scope !== r.path.scope) {
            t.mutableBinding = !0, e.stop();
            return;
          }
        r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
      }
    }
  }, _c = class {
    static {
      s(this, "PathHoister");
    }
    constructor(t, r) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = r, this.path = t, this.attachAfter = !1;
    }
    isCompatibleScope(t) {
      for (let r of Object.keys(this.bindings)) {
        let i = this.bindings[r];
        if (!t.bindingIdentifierEquals(r, i.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let t = this.path.scope;
      do {
        if (this.isCompatibleScope(t))
          this.scopes.push(t);
        else
          break;
        if (this.breakOnScopePaths.indexOf(t.path) >= 0)
          break;
      } while (t = t.parent);
    }
    getAttachmentPath() {
      let t = this._getAttachmentPath();
      if (!t) return;
      let r = t.scope;
      if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction())
        for (let i of Object.keys(this.bindings)) {
          if (!r.hasOwnBinding(i)) continue;
          let n = this.bindings[i];
          if (n.kind === "param" || n.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(n.path).key >= t.key) {
            this.attachAfter = !0, t = n.path;
            for (let o of n.constantViolations)
              this.getAttachmentParentForPath(o).key > t.key && (t = o);
          }
        }
      return t;
    }
    _getAttachmentPath() {
      let r = this.scopes.pop();
      if (r) {
        if (r.path.isFunction())
          if (this.hasOwnParamBindings(r)) {
            if (this.scope === r) return;
            let i = r.path.get("body").get("body");
            for (let n = 0; n < i.length; n++)
              if (!i[n].node._blockHoist)
                return i[n];
          } else
            return this.getNextScopeAttachmentParent();
        else if (r.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let t = this.scopes.pop();
      if (t) return this.getAttachmentParentForPath(t.path);
    }
    getAttachmentParentForPath(t) {
      do
        if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
          return t;
      while (t = t.parentPath);
    }
    hasOwnParamBindings(t) {
      for (let r of Object.keys(this.bindings)) {
        if (!t.hasOwnBinding(r)) continue;
        let i = this.bindings[r];
        if (i.kind === "param" && i.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(vY, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let t = this.getAttachmentPath();
      if (!t || t.getFunctionParent() === this.path.getFunctionParent()) return;
      let r = t.scope.generateUidIdentifier("ref"), i = AY(r, this.path.node), n = this.attachAfter ? "insertAfter" : "insertBefore", [a] = t[n](
      [t.isVariableDeclarator() ? i : PY("var", [i])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (r = EY(r)), this.path.replaceWith(xY(r)), t.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  ra.default = _c;
});

// ../node_modules/@babel/traverse/lib/path/modification.js
var zT = v((It) => {
  "use strict";
  Object.defineProperty(It, "__esModule", {
    value: !0
  });
  It._containerInsert = VY;
  It._containerInsertAfter = KY;
  It._containerInsertBefore = UY;
  It._verifyNodeList = JY;
  It.hoist = GY;
  It.insertAfter = YY;
  It.insertBefore = qY;
  It.pushContainer = HY;
  It.unshiftContainer = $Y;
  It.updateSiblingKeys = XY;
  var CY = Lr(), IY = XT(), Lc = gr(), wY = le(), {
    arrowFunctionExpression: OY,
    assertExpression: NY,
    assignmentExpression: _Y,
    blockStatement: JT,
    callExpression: DY,
    cloneNode: Dc,
    expressionStatement: kc,
    isAssignmentExpression: kY,
    isCallExpression: LY,
    isExportNamedDeclaration: $T,
    isExpression: MY,
    isIdentifier: FY,
    isSequenceExpression: BY,
    isSuper: jY,
    thisExpression: RY
  } = wY;
  function qY(e) {
    this._assertUnremoved();
    let t = this._verifyNodeList(e), {
      parentPath: r,
      parent: i
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || $T(i) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertBefore(t);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init")
      return this.node && t.push(this.node), this.replaceExpressionWithStatements(t);
    if (Array.isArray(this.container))
      return this._containerInsertBefore(t);
    if (this.isStatementOrBlock()) {
      let n = this.node, a = n && (!this.isExpressionStatement() || n.expression != null);
      return this.replaceWith(JT(a ? [n] : [])), this.unshiftContainer("body", t);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  s(qY, "insertBefore");
  function VY(e, t) {
    this.updateSiblingKeys(e, t.length);
    let r = [];
    this.container.splice(e, 0, ...t);
    for (let a = 0; a < t.length; a++) {
      var i;
      let o = e + a, l = this.getSibling(o);
      r.push(l), (i = this.context) != null && i.queue && l.pushContext(this.context);
    }
    let n = this._getQueueContexts();
    for (let a of r) {
      a.setScope(), a.debug("Inserted.");
      for (let o of n)
        o.maybeQueue(a, !0);
    }
    return r;
  }
  s(VY, "_containerInsert");
  function UY(e) {
    return this._containerInsert(this.key, e);
  }
  s(UY, "_containerInsertBefore");
  function KY(e) {
    return this._containerInsert(this.key + 1, e);
  }
  s(KY, "_containerInsertAfter");
  var HT = /* @__PURE__ */ s((e) => e[e.length - 1], "last");
  function GT(e) {
    return BY(e.parent) && (HT(e.parent.expressions) !== e.node || GT(e.parentPath));
  }
  s(GT, "isHiddenInSequenceExpression");
  function WY(e, t) {
    if (!kY(e) || !FY(e.left))
      return !1;
    let r = t.getBlockParent();
    return r.hasOwnBinding(e.left.name) && r.getOwnBinding(e.left.name).constantViolations.length <= 1;
  }
  s(WY, "isAlmostConstantAssignment");
  function YY(e) {
    if (this._assertUnremoved(), this.isSequenceExpression())
      return HT(this.get("expressions")).insertAfter(e);
    let t = this._verifyNodeList(e), {
      parentPath: r,
      parent: i
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || $T(i) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertAfter(t.map((n) => MY(n) ? kc(n) : n));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
      if (this.node) {
        let n = this.node, {
          scope: a
        } = this;
        if (a.path.isPattern())
          return NY(n), this.replaceWith(DY(OY([], n), [])), this.get("callee.body").insertAfter(t), [this];
        if (GT(this))
          t.unshift(n);
        else if (LY(n) && jY(n.callee))
          t.unshift(n), t.push(RY());
        else if (WY(n, a))
          t.unshift(n), t.push(Dc(n.left));
        else if (a.isPure(n, !0))
          t.push(n);
        else {
          r.isMethod({
            computed: !0,
            key: n
          }) && (a = a.parent);
          let o = a.generateDeclaredUidIdentifier();
          t.unshift(kc(_Y("=", Dc(o), n))), t.push(kc(Dc(o)));
        }
      }
      return this.replaceExpressionWithStatements(t);
    } else {
      if (Array.isArray(this.container))
        return this._containerInsertAfter(t);
      if (this.isStatementOrBlock()) {
        let n = this.node, a = n && (!this.isExpressionStatement() || n.expression != null);
        return this.replaceWith(JT(a ? [n] : [])), this.pushContainer("body", t);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  s(YY, "insertAfter");
  function XY(e, t) {
    if (!this.parent) return;
    let r = (0, CY.getCachedPaths)(this.hub, this.parent) || [];
    for (let [, i] of r)
      typeof i.key == "number" && i.key >= e && (i.key += t);
  }
  s(XY, "updateSiblingKeys");
  function JY(e) {
    if (!e)
      return [];
    Array.isArray(e) || (e = [e]);
    for (let t = 0; t < e.length; t++) {
      let r = e[t], i;
      if (r ? typeof r != "object" ? i = "contains a non-object node" : r.type ? r instanceof Lc.default && (i = "has a NodePath when it exp\
ected a raw object") : i = "without a type" : i = "has falsy node", i) {
        let n = Array.isArray(r) ? "array" : typeof r;
        throw new Error(`Node list ${i} with the index of ${t} and type of ${n}`);
      }
    }
    return e;
  }
  s(JY, "_verifyNodeList");
  function $Y(e, t) {
    return this._assertUnremoved(), t = this._verifyNodeList(t), Lc.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[e],
      listKey: e,
      key: 0
    }).setContext(this.context)._containerInsertBefore(t);
  }
  s($Y, "unshiftContainer");
  function HY(e, t) {
    this._assertUnremoved();
    let r = this._verifyNodeList(t), i = this.node[e];
    return Lc.default.get({
      parentPath: this,
      parent: this.node,
      container: i,
      listKey: e,
      key: i.length
    }).setContext(this.context).replaceWithMultiple(r);
  }
  s(HY, "pushContainer");
  function GY(e = this.scope) {
    return new IY.default(this, e).run();
  }
  s(GY, "hoist");
});

// ../node_modules/@babel/traverse/lib/path/family.js
var e0 = v((st) => {
  "use strict";
  Object.defineProperty(st, "__esModule", {
    value: !0
  });
  st._getKey = dX;
  st._getPattern = mX;
  st.get = hX;
  st.getAllNextSiblings = pX;
  st.getAllPrevSiblings = fX;
  st.getBindingIdentifierPaths = gX;
  st.getBindingIdentifiers = yX;
  st.getCompletionRecords = oX;
  st.getNextSibling = cX;
  st.getOpposite = sX;
  st.getOuterBindingIdentifierPaths = bX;
  st.getOuterBindingIdentifiers = TX;
  st.getPrevSibling = uX;
  st.getSibling = lX;
  var Fc = gr(), zY = le(), {
    getBindingIdentifiers: ZT,
    getOuterBindingIdentifiers: QY,
    isDeclaration: ZY,
    numericLiteral: eX,
    unaryExpression: tX
  } = zY, Bc = 0, Ss = 1;
  function rX(e) {
    return {
      type: Bc,
      path: e
    };
  }
  s(rX, "NormalCompletion");
  function iX(e) {
    return {
      type: Ss,
      path: e
    };
  }
  s(iX, "BreakCompletion");
  function sX() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  s(sX, "getOpposite");
  function Ei(e, t, r) {
    return e && t.push(...Pi(e, r)), t;
  }
  s(Ei, "addCompletionRecords");
  function nX(e, t, r) {
    let i = [];
    for (let n = 0; n < e.length; n++) {
      let a = e[n], o = Pi(a, r), l = [], u = [];
      for (let c of o)
        c.type === Bc && l.push(c), c.type === Ss && u.push(c);
      l.length && (i = l), t.push(...u);
    }
    return t.push(...i), t;
  }
  s(nX, "completionRecordForSwitch");
  function aX(e) {
    e.forEach((t) => {
      t.type = Ss;
    });
  }
  s(aX, "normalCompletionToBreak");
  function Mc(e, t) {
    e.forEach((r) => {
      r.path.isBreakStatement({
        label: null
      }) && (t ? r.path.replaceWith(tX("void", eX(0))) : r.path.remove());
    });
  }
  s(Mc, "replaceBreakStatementInBreakCompletion");
  function QT(e, t) {
    let r = [];
    if (t.canHaveBreak) {
      let i = [];
      for (let n = 0; n < e.length; n++) {
        let a = e[n], o = Object.assign({}, t, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let l = Pi(a, o);
        if (l.length > 0 && l.every((u) => u.type === Ss)) {
          i.length > 0 && l.every((u) => u.path.isBreakStatement({
            label: null
          })) ? (aX(i), r.push(...i), i.some((u) => u.path.isDeclaration()) && (r.push(...l), Mc(l, !0)), Mc(l, !1)) : (r.push(...l), t.shouldPopulateBreak ||
          Mc(l, !0));
          break;
        }
        if (n === e.length - 1)
          r.push(...l);
        else {
          i = [];
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c.type === Ss && r.push(c), c.type === Bc && i.push(c);
          }
        }
      }
    } else if (e.length)
      for (let i = e.length - 1; i >= 0; i--) {
        let n = Pi(e[i], t);
        if (n.length > 1 || n.length === 1 && !n[0].path.isVariableDeclaration()) {
          r.push(...n);
          break;
        }
      }
    return r;
  }
  s(QT, "getStatementListCompletion");
  function Pi(e, t) {
    let r = [];
    if (e.isIfStatement())
      r = Ei(e.get("consequent"), r, t), r = Ei(e.get("alternate"), r, t);
    else {
      if (e.isDoExpression() || e.isFor() || e.isWhile() || e.isLabeledStatement())
        return Ei(e.get("body"), r, t);
      if (e.isProgram() || e.isBlockStatement())
        return QT(e.get("body"), t);
      if (e.isFunction())
        return Pi(e.get("body"), t);
      if (e.isTryStatement())
        r = Ei(e.get("block"), r, t), r = Ei(e.get("handler"), r, t);
      else {
        if (e.isCatchClause())
          return Ei(e.get("body"), r, t);
        if (e.isSwitchStatement())
          return nX(e.get("cases"), r, t);
        if (e.isSwitchCase())
          return QT(e.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        e.isBreakStatement() ? r.push(iX(e)) : r.push(rX(e));
      }
    }
    return r;
  }
  s(Pi, "_getCompletionRecords");
  function oX() {
    return Pi(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((t) => t.path);
  }
  s(oX, "getCompletionRecords");
  function lX(e) {
    return Fc.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: e
    }).setContext(this.context);
  }
  s(lX, "getSibling");
  function uX() {
    return this.getSibling(this.key - 1);
  }
  s(uX, "getPrevSibling");
  function cX() {
    return this.getSibling(this.key + 1);
  }
  s(cX, "getNextSibling");
  function pX() {
    let e = this.key, t = this.getSibling(++e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(++e);
    return r;
  }
  s(pX, "getAllNextSiblings");
  function fX() {
    let e = this.key, t = this.getSibling(--e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(--e);
    return r;
  }
  s(fX, "getAllPrevSiblings");
  function hX(e, t = !0) {
    t === !0 && (t = this.context);
    let r = e.split(".");
    return r.length === 1 ? this._getKey(e, t) : this._getPattern(r, t);
  }
  s(hX, "get");
  function dX(e, t) {
    let r = this.node, i = r[e];
    return Array.isArray(i) ? i.map((n, a) => Fc.default.get({
      listKey: e,
      parentPath: this,
      parent: r,
      container: i,
      key: a
    }).setContext(t)) : Fc.default.get({
      parentPath: this,
      parent: r,
      container: r,
      key: e
    }).setContext(t);
  }
  s(dX, "_getKey");
  function mX(e, t) {
    let r = this;
    for (let i of e)
      i === "." ? r = r.parentPath : Array.isArray(r) ? r = r[i] : r = r.get(i, t);
    return r;
  }
  s(mX, "_getPattern");
  function yX(e) {
    return ZT(this.node, e);
  }
  s(yX, "getBindingIdentifiers");
  function TX(e) {
    return QY(this.node, e);
  }
  s(TX, "getOuterBindingIdentifiers");
  function gX(e = !1, t = !1) {
    let i = [this], n = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let a = i.shift();
      if (!a || !a.node) continue;
      let o = ZT.keys[a.node.type];
      if (a.isIdentifier()) {
        e ? (n[a.node.name] = n[a.node.name] || []).push(a) : n[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let l = a.get("declaration");
        ZY(l) && i.push(l);
        continue;
      }
      if (t) {
        if (a.isFunctionDeclaration()) {
          i.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let l = 0; l < o.length; l++) {
          let u = o[l], c = a.get(u);
          Array.isArray(c) ? i.push(...c) : c.node && i.push(c);
        }
    }
    return n;
  }
  s(gX, "getBindingIdentifierPaths");
  function bX(e = !1) {
    return this.getBindingIdentifierPaths(e, !0);
  }
  s(bX, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/traverse/lib/path/comments.js
var r0 = v((xs) => {
  "use strict";
  Object.defineProperty(xs, "__esModule", {
    value: !0
  });
  xs.addComment = AX;
  xs.addComments = vX;
  xs.shareCommentsWithSiblings = PX;
  var SX = le(), {
    addComment: xX,
    addComments: EX
  } = SX;
  function PX() {
    if (typeof this.key == "string") return;
    let e = this.node;
    if (!e) return;
    let t = e.trailingComments, r = e.leadingComments;
    if (!t && !r) return;
    let i = this.getSibling(this.key - 1), n = this.getSibling(this.key + 1), a = !!i.node, o = !!n.node;
    a && (r && i.addComments("trailing", t0(r, i.node.trailingComments)), t && !o && i.addComments("trailing", t)), o && (t && n.addComments(
    "leading", t0(t, n.node.leadingComments)), r && !a && n.addComments("leading", r));
  }
  s(PX, "shareCommentsWithSiblings");
  function t0(e, t) {
    if (!(t != null && t.length)) return e;
    let r = new Set(t);
    return e.filter((i) => !r.has(i));
  }
  s(t0, "removeIfExisting");
  function AX(e, t, r) {
    xX(this.node, e, t, r);
  }
  s(AX, "addComment");
  function vX(e, t) {
    EX(this.node, e, t);
  }
  s(vX, "addComments");
});

// ../node_modules/@babel/traverse/lib/path/index.js
var gr = v((Vt) => {
  "use strict";
  Object.defineProperty(Vt, "__esModule", {
    value: !0
  });
  Vt.default = Vt.SHOULD_STOP = Vt.SHOULD_SKIP = Vt.REMOVED = void 0;
  var CX = Wl(), IX = Rd(), wX = Br(), OX = lu(), s0 = le(), ia = s0, NX = Lr(), _X = ii(), DX = am(), kX = vm(), LX = sT(), MX = lT(), FX = DT(),
  n0 = jT(), BX = VT(), jX = WT(), RX = zT(), qX = e0(), VX = r0(), UX = Xl(), {
    validate: KX
  } = s0, i0 = IX("babel"), jc = Vt.REMOVED = 1, Rc = Vt.SHOULD_STOP = 2, qc = Vt.SHOULD_SKIP = 4, Sr = class e {
    static {
      s(this, "NodePath");
    }
    constructor(t, r) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container =
      null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = r, this.hub = t, this.data = null, this.
      context = null, this.scope = null;
    }
    static get({
      hub: t,
      parentPath: r,
      parent: i,
      container: n,
      listKey: a,
      key: o
    }) {
      if (!t && r && (t = r.hub), !i)
        throw new Error("To get a node path the parent needs to exist");
      let l = n[o], u = NX.getOrCreateCachedPaths(t, i), c = u.get(l);
      return c || (c = new e(t, i), l && u.set(l, c)), c.setup(r, n, a, o), c;
    }
    getScope(t) {
      return this.isScope() ? new OX.default(this) : t;
    }
    setData(t, r) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[t] = r;
    }
    getData(t, r) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let i = this.data[t];
      return i === void 0 && r !== void 0 && (i = this.data[t] = r), i;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(t, r = SyntaxError) {
      return this.hub.buildError(this.node, t, r);
    }
    traverse(t, r) {
      (0, wX.default)(this.node, t, this.scope, r, this);
    }
    set(t, r) {
      KX(this.node, t, r), this.node[t] = r;
    }
    getPathLocation() {
      let t = [], r = this;
      do {
        let i = r.key;
        r.inList && (i = `${r.listKey}[${i}]`), t.unshift(i);
      } while (r = r.parentPath);
      return t.join(".");
    }
    debug(t) {
      i0.enabled && i0(`${this.getPathLocation()} ${this.type}: ${t}`);
    }
    toString() {
      return (0, _X.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(t) {
      t || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & qc);
    }
    set shouldSkip(t) {
      t ? this._traverseFlags |= qc : this._traverseFlags &= ~qc;
    }
    get shouldStop() {
      return !!(this._traverseFlags & Rc);
    }
    set shouldStop(t) {
      t ? this._traverseFlags |= Rc : this._traverseFlags &= ~Rc;
    }
    get removed() {
      return !!(this._traverseFlags & jc);
    }
    set removed(t) {
      t ? this._traverseFlags |= jc : this._traverseFlags &= ~jc;
    }
  };
  Object.assign(Sr.prototype, DX, kX, LX, MX, FX, n0, BX, jX, RX, qX, VX);
  Sr.prototype._guessExecutionStatusRelativeToDifferentFunctions = n0._guessExecutionStatusRelativeTo;
  for (let e of ia.TYPES) {
    let t = `is${e}`, r = ia[t];
    Sr.prototype[t] = function(i) {
      return r(this.node, i);
    }, Sr.prototype[`assert${e}`] = function(i) {
      if (!r(this.node, i))
        throw new TypeError(`Expected node path of type ${e}`);
    };
  }
  Object.assign(Sr.prototype, UX);
  for (let e of Object.keys(CX))
    e[0] !== "_" && (ia.TYPES.includes(e) || ia.TYPES.push(e));
  var Pte = Vt.default = Sr;
});

// ../node_modules/@babel/traverse/lib/context.js
var a0 = v((sa) => {
  "use strict";
  Object.defineProperty(sa, "__esModule", {
    value: !0
  });
  sa.default = void 0;
  var WX = gr(), YX = le(), {
    VISITOR_KEYS: XX
  } = YX, Vc = class {
    static {
      s(this, "TraversalContext");
    }
    constructor(t, r, i, n) {
      this.queue = null, this.priorityQueue = null, this.parentPath = n, this.scope = t, this.state = i, this.opts = r;
    }
    shouldVisit(t) {
      let r = this.opts;
      if (r.enter || r.exit || r[t.type]) return !0;
      let i = XX[t.type];
      if (!(i != null && i.length)) return !1;
      for (let n of i)
        if (t[n])
          return !0;
      return !1;
    }
    create(t, r, i, n) {
      return WX.default.get({
        parentPath: this.parentPath,
        parent: t,
        container: r,
        key: i,
        listKey: n
      });
    }
    maybeQueue(t, r) {
      this.queue && (r ? this.queue.push(t) : this.priorityQueue.push(t));
    }
    visitMultiple(t, r, i) {
      if (t.length === 0) return !1;
      let n = [];
      for (let a = 0; a < t.length; a++) {
        let o = t[a];
        o && this.shouldVisit(o) && n.push(this.create(r, t, a, i));
      }
      return this.visitQueue(n);
    }
    visitSingle(t, r) {
      return this.shouldVisit(t[r]) ? this.visitQueue([this.create(t, t, r)]) : !1;
    }
    visitQueue(t) {
      this.queue = t, this.priorityQueue = [];
      let r = /* @__PURE__ */ new WeakSet(), i = !1, n = 0;
      for (; n < t.length; ) {
        let a = t[n];
        if (n++, a.resync(), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && a.pushContext(this), a.key === null)
         continue;
        let {
          node: o
        } = a;
        if (!r.has(o)) {
          if (o && r.add(o), a.visit()) {
            i = !0;
            break;
          }
          if (this.priorityQueue.length && (i = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = t, i))
            break;
        }
      }
      for (let a = 0; a < n; a++)
        t[a].popContext();
      return this.queue = null, i;
    }
    visit(t, r) {
      let i = t[r];
      return i ? Array.isArray(i) ? this.visitMultiple(i, t, r) : this.visitSingle(t, r) : !1;
    }
  };
  sa.default = Vc;
});

// ../node_modules/@babel/traverse/lib/traverse-node.js
var vn = v((Uc) => {
  "use strict";
  Object.defineProperty(Uc, "__esModule", {
    value: !0
  });
  Uc.traverseNode = GX;
  var JX = a0(), $X = le(), {
    VISITOR_KEYS: HX
  } = $X;
  function GX(e, t, r, i, n, a, o) {
    let l = HX[e.type];
    if (!l) return !1;
    let u = new JX.default(r, t, i, n);
    if (o)
      return a != null && a[n.parentKey] ? !1 : u.visitQueue([n]);
    for (let c of l)
      if (!(a != null && a[c]) && u.visit(e, c))
        return !0;
    return !1;
  }
  s(GX, "traverseNode");
});

// ../node_modules/@babel/traverse/lib/hub.js
var o0 = v((na) => {
  "use strict";
  Object.defineProperty(na, "__esModule", {
    value: !0
  });
  na.default = void 0;
  var Kc = class {
    static {
      s(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(t, r, i = TypeError) {
      return new i(r);
    }
  };
  na.default = Kc;
});

// ../node_modules/@babel/traverse/lib/index.js
var Br = v((Zt) => {
  "use strict";
  Object.defineProperty(Zt, "__esModule", {
    value: !0
  });
  Object.defineProperty(Zt, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return tJ.default;
    }, "get")
  });
  Object.defineProperty(Zt, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return ZX.default;
    }, "get")
  });
  Object.defineProperty(Zt, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ s(function() {
      return eJ.default;
    }, "get")
  });
  Zt.visitors = Zt.default = void 0;
  var Es = Zi();
  Zt.visitors = Es;
  var zX = le(), QX = Lr(), l0 = vn(), ZX = gr(), eJ = lu(), tJ = o0(), {
    VISITOR_KEYS: rJ,
    removeProperties: iJ,
    traverseFast: u0
  } = zX;
  function wt(e, t = {}, r, i, n, a) {
    if (e) {
      if (!t.noScope && !r && e.type !== "Program" && e.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e.
        type} node without passing scope and parentPath.`);
      if (!n && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      rJ[e.type] && (Es.explode(t), (0, l0.traverseNode)(e, t, r, i, n, null, a));
    }
  }
  s(wt, "traverse");
  var Dte = Zt.default = wt;
  wt.visitors = Es;
  wt.verify = Es.verify;
  wt.explode = Es.explode;
  wt.cheap = function(e, t) {
    u0(e, t);
  };
  wt.node = function(e, t, r, i, n, a) {
    (0, l0.traverseNode)(e, t, r, i, n, a);
  };
  wt.clearNode = function(e, t) {
    iJ(e, t);
  };
  wt.removeProperties = function(e, t) {
    return u0(e, wt.clearNode, t), e;
  };
  function sJ(e, t) {
    e.node.type === t.type && (t.has = !0, e.stop());
  }
  s(sJ, "hasDenylistedType");
  wt.hasType = function(e, t, r) {
    if (r != null && r.includes(e.type)) return !1;
    if (e.type === t) return !0;
    let i = {
      has: !1,
      type: t
    };
    return wt(e, {
      noScope: !0,
      denylist: r,
      enter: sJ
    }, null, i), i.has;
  };
  wt.cache = QX;
});

// src/csf-tools/CsfFile.ts
var Ps = tt(Ds(), 1), j = tt(le(), 1), Wc = tt(ii(), 1), Yc = tt(Br(), 1);
import { readFile as aJ, writeFile as oJ } from "node:fs/promises";
import * as $c from "recast";
import { toId as lJ, isExportStory as p0, storyNameFromExport as f0 } from "@storybook/csf";

// src/csf-tools/babelParse.ts
var aa = tt(Hn(), 1);
import * as oa from "recast";
function nJ(e, t) {
  let n = /^\s*\/\/\s*@flow/.test(e) ? ["flow"] : ["typescript"], a = {
    ...t,
    plugins: [...t.plugins ?? [], ...n]
  };
  return aa.parse(e, a);
}
s(nJ, "parseWithFlowOrTypescript");
var c0 = {
  sourceType: "module",
  // FIXME: we should get this from the project config somehow?
  plugins: ["jsx", "decorators-legacy", "classProperties"],
  tokens: !0
}, Yr = /* @__PURE__ */ s((e) => oa.parse(e, {
  parser: {
    parse(t) {
      return nJ(t, c0);
    }
  }
}), "babelParse"), Mte = /* @__PURE__ */ s((e) => oa.print(e, {
  quote: "single",
  trailingComma: !0,
  tabWidth: 2,
  wrapColumn: 80,
  arrowParensAlways: !0
}).code, "babelPrint"), Fte = /* @__PURE__ */ s((e) => aa.parseExpression(e, c0), "babelParseExpression");

// src/csf-tools/findVarInitialization.ts
var er = tt(le(), 1);
var tr = /* @__PURE__ */ s((e, t) => {
  let r = null, i = null;
  return t.body.find((n) => (er.isVariableDeclaration(n) ? i = n.declarations : er.isExportNamedDeclaration(n) && er.isVariableDeclaration(n.
  declaration) && (i = n.declaration.declarations), i && i.find((a) => er.isVariableDeclarator(a) && er.isIdentifier(a.id) && a.id.name === e ?
  (r = a.init, !0) : !1))), r;
}, "findVarInitialization");

// src/csf-tools/CsfFile.ts
var uJ = Yc.default.default || Yc.default, cJ = Wc.default.default || Wc.default, h0 = console;
function pJ(e) {
  if (j.isArrayExpression(e))
    return e.elements.map((t) => {
      if (j.isStringLiteral(t)) return t.value;
      throw new Error(`Expected string literal: ${t}`);
    });
  if (j.isStringLiteral(e)) return new RegExp(e.value);
  if (j.isRegExpLiteral(e)) return new RegExp(e.pattern, e.flags);
  throw new Error(`Unknown include/exclude: ${e}`);
}
s(pJ, "parseIncludeExclude");
function d0(e) {
  if (!j.isArrayExpression(e))
    throw new Error("CSF: Expected tags array");
  return e.elements.map((t) => {
    if (j.isStringLiteral(t)) return t.value;
    throw new Error("CSF: Expected tag to be string literal");
  });
}
s(d0, "parseTags");
var Xc = /* @__PURE__ */ s((e, t) => {
  let { line: r, column: i } = e.loc?.start || {};
  return `${t || ""} (line ${r}, col ${i})`.trim();
}, "formatLocation"), m0 = /* @__PURE__ */ s((e, t, r) => {
  let i = e;
  if (j.isCallExpression(e)) {
    let { callee: n, arguments: a } = e;
    if (j.isProgram(t) && j.isMemberExpression(n) && j.isIdentifier(n.object) && j.isIdentifier(n.property) && n.property.name === "bind" &&
    (a.length === 0 || a.length === 1 && j.isObjectExpression(a[0]) && a[0].properties.length === 0)) {
      let o = n.object.name, l = tr(o, t);
      l && (r._templates[o] = l, i = l);
    }
  }
  return j.isArrowFunctionExpression(i) || j.isFunctionDeclaration(i) ? i.params.length > 0 : !1;
}, "isArgsStory"), fJ = /* @__PURE__ */ s((e) => {
  if (j.isArrayExpression(e))
    return e.elements.map((t) => {
      if (j.isStringLiteral(t))
        return t.value;
      throw new Error(`Expected string literal named export: ${t}`);
    });
  throw new Error(`Expected array of string literals: ${e}`);
}, "parseExportsOrder"), y0 = /* @__PURE__ */ s((e, t) => t.reduce(
  (r, i) => {
    let n = e[i];
    return n && (r[i] = n), r;
  },
  {}
), "sortExports"), la = class extends Error {
  static {
    s(this, "NoMetaError");
  }
  constructor(t, r, i) {
    super(Ps.dedent`
      CSF: ${t} ${Xc(r, i)}

      More info: https://storybook.js.org/docs/react/writing-stories#default-export
    `), this.name = this.constructor.name;
  }
}, Jc = class {
  static {
    s(this, "CsfFile");
  }
  _ast;
  _fileName;
  _rawComponentPath;
  _makeTitle;
  _meta;
  _stories = {};
  _metaAnnotations = {};
  _storyExports = {};
  _metaStatement;
  _metaNode;
  _storyStatements = {};
  _storyAnnotations = {};
  _templates = {};
  _namedExportsOrder;
  imports;
  constructor(t, { fileName: r, makeTitle: i }) {
    this._ast = t, this._fileName = r, this.imports = [], this._makeTitle = i;
  }
  _parseTitle(t) {
    let r = j.isIdentifier(t) ? tr(t.name, this._ast.program) : t;
    if (j.isStringLiteral(r))
      return r.value;
    if (j.isTSSatisfiesExpression(r) && j.isStringLiteral(r.expression))
      return r.expression.value;
    throw new Error(Ps.dedent`
      CSF: unexpected dynamic title ${Xc(r, this._fileName)}

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#string-literal-titles
    `);
  }
  _parseMeta(t, r) {
    let i = {};
    t.properties.forEach((n) => {
      if (j.isIdentifier(n.key)) {
        if (this._metaAnnotations[n.key.name] = n.value, n.key.name === "title")
          i.title = this._parseTitle(n.value);
        else if (["includeStories", "excludeStories"].includes(n.key.name))
          i[n.key.name] = pJ(n.value);
        else if (n.key.name === "component") {
          let a = n.value;
          if (j.isIdentifier(a)) {
            let l = a.name, u = r.body.find(
              (c) => j.isImportDeclaration(c) && c.specifiers.find((p) => p.local.name === l)
            );
            if (u) {
              let { source: c } = u;
              j.isStringLiteral(c) && (this._rawComponentPath = c.value);
            }
          }
          let { code: o } = $c.print(n.value, {});
          i.component = o;
        } else if (n.key.name === "tags") {
          let a = n.value;
          j.isIdentifier(a) && (a = tr(a.name, this._ast.program)), i.tags = d0(a);
        } else if (n.key.name === "id")
          if (j.isStringLiteral(n.value))
            i.id = n.value.value;
          else
            throw new Error(`Unexpected component id: ${n.value}`);
      }
    }), this._meta = i;
  }
  getStoryExport(t) {
    let r = this._storyExports[t];
    if (r = j.isVariableDeclarator(r) ? r.init : r, j.isCallExpression(r)) {
      let { callee: i, arguments: n } = r;
      if (j.isMemberExpression(i) && j.isIdentifier(i.object) && j.isIdentifier(i.property) && i.property.name === "bind" && (n.length === 0 ||
      n.length === 1 && j.isObjectExpression(n[0]) && n[0].properties.length === 0)) {
        let { name: a } = i.object;
        r = this._templates[a];
      }
    }
    return r;
  }
  parse() {
    let t = this;
    if (uJ(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node: i, parent: n }) {
          let a, o = j.isIdentifier(i.declaration) && j.isProgram(n), l;
          if (o) {
            let u = i.declaration.name, c = /* @__PURE__ */ s((p) => j.isIdentifier(p.id) && p.id.name === u, "isVariableDeclarator");
            t._metaStatement = t._ast.program.body.find(
              (p) => j.isVariableDeclaration(p) && p.declarations.find(c)
            ), l = (t?._metaStatement?.declarations || []).find(
              c
            )?.init;
          } else
            t._metaStatement = i, l = i.declaration;
          if (j.isObjectExpression(l) ? a = l : (
            // export default { ... } as Meta<...>
            (j.isTSAsExpression(l) || j.isTSSatisfiesExpression(l)) && j.isObjectExpression(l.expression) && (a = l.expression)
          ), !t._meta && a && j.isProgram(n) && (t._metaNode = a, t._parseMeta(a, n)), t._metaStatement && !t._metaNode)
            throw new la(
              "default export must be an object",
              t._metaStatement,
              t._fileName
            );
        }
      },
      ExportNamedDeclaration: {
        enter({ node: i, parent: n }) {
          let a;
          j.isVariableDeclaration(i.declaration) ? a = i.declaration.declarations.filter((o) => j.isVariableDeclarator(o)) : j.isFunctionDeclaration(
          i.declaration) && (a = [i.declaration]), a ? a.forEach((o) => {
            if (j.isIdentifier(o.id)) {
              let { name: l } = o.id;
              if (l === "__namedExportsOrder" && j.isVariableDeclarator(o)) {
                t._namedExportsOrder = fJ(o.init);
                return;
              }
              t._storyExports[l] = o, t._storyStatements[l] = i;
              let u = f0(l);
              t._storyAnnotations[l] ? h0.warn(
                `Unexpected annotations for "${l}" before story declaration`
              ) : t._storyAnnotations[l] = {};
              let c;
              j.isVariableDeclarator(o) ? c = j.isTSAsExpression(o.init) || j.isTSSatisfiesExpression(o.init) ? o.init.expression : o.init :
              c = o;
              let p = {};
              j.isObjectExpression(c) ? (p.__isArgsStory = !0, c.properties.forEach((g) => {
                if (j.isIdentifier(g.key)) {
                  if (g.key.name === "render")
                    p.__isArgsStory = m0(
                      g.value,
                      n,
                      t
                    );
                  else if (g.key.name === "name" && j.isStringLiteral(g.value))
                    u = g.value.value;
                  else if (g.key.name === "storyName" && j.isStringLiteral(g.value))
                    h0.warn(
                      `Unexpected usage of "storyName" in "${l}". Please use "name" instead.`
                    );
                  else if (g.key.name === "parameters" && j.isObjectExpression(g.value)) {
                    let P = g.value.properties.find(
                      (A) => j.isObjectProperty(A) && j.isIdentifier(A.key) && A.key.name === "__id"
                    );
                    P && (p.__id = P.value.value);
                  }
                  t._storyAnnotations[l][g.key.name] = g.value;
                }
              })) : p.__isArgsStory = m0(c, n, t), t._stories[l] = {
                id: "FIXME",
                name: u,
                parameters: p
              };
            }
          }) : i.specifiers.length > 0 && i.specifiers.forEach((o) => {
            if (j.isExportSpecifier(o) && j.isIdentifier(o.exported)) {
              let { name: l } = o.exported;
              if (l === "default") {
                let u, c = j.isProgram(n) ? tr(o.local.name, n) : o.local;
                j.isObjectExpression(c) ? u = c : (
                  // export default { ... } as Meta<...>
                  j.isTSAsExpression(c) && j.isObjectExpression(c.expression) && (u = c.expression)
                ), !t._meta && u && j.isProgram(n) && t._parseMeta(u, n);
              } else
                t._storyAnnotations[l] = {}, t._stories[l] = { id: "FIXME", name: l, parameters: {} };
            }
          });
        }
      },
      ExpressionStatement: {
        enter({ node: i, parent: n }) {
          let { expression: a } = i;
          if (j.isProgram(n) && j.isAssignmentExpression(a) && j.isMemberExpression(a.left) && j.isIdentifier(a.left.object) && j.isIdentifier(
          a.left.property)) {
            let o = a.left.object.name, l = a.left.property.name, u = a.right;
            if (t._storyAnnotations[o] && (l === "story" && j.isObjectExpression(u) ? u.properties.forEach((c) => {
              j.isIdentifier(c.key) && (t._storyAnnotations[o][c.key.name] = c.value);
            }) : t._storyAnnotations[o][l] = u), l === "storyName" && j.isStringLiteral(u)) {
              let c = u.value, p = t._stories[o];
              if (!p) return;
              p.name = c;
            }
          }
        }
      },
      CallExpression: {
        enter({ node: i }) {
          let { callee: n } = i;
          if (j.isIdentifier(n) && n.name === "storiesOf")
            throw new Error(Ps.dedent`
              Unexpected \`storiesOf\` usage: ${Xc(i, t._fileName)}.

              SB8 does not support \`storiesOf\`. 
            `);
        }
      },
      ImportDeclaration: {
        enter({ node: i }) {
          let { source: n } = i;
          if (j.isStringLiteral(n))
            t.imports.push(n.value);
          else
            throw new Error("CSF: unexpected import source");
        }
      }
    }), !t._meta)
      throw new la("missing default export", t._ast, t._fileName);
    let r = Object.entries(t._stories);
    if (t._meta.title = this._makeTitle(t._meta?.title), t._metaAnnotations.play && (t._meta.tags = [...t._meta.tags || [], "play-fn"]), t._stories =
    r.reduce(
      (i, [n, a]) => {
        if (!p0(n, t._meta))
          return i;
        let o = a.parameters?.__id ?? lJ(t._meta?.id || t._meta?.title, f0(n)), l = { ...a.parameters, __id: o }, { includeStories: u } = t.
        _meta || {};
        n === "__page" && (r.length === 1 || Array.isArray(u) && u.length === 1) && (l.docsOnly = !0), i[n] = { ...a, id: o, parameters: l };
        let { tags: c, play: p } = t._storyAnnotations[n];
        if (c) {
          let g = j.isIdentifier(c) ? tr(c.name, this._ast.program) : c;
          i[n].tags = d0(g);
        }
        return p && (i[n].tags = [...i[n].tags || [], "play-fn"]), i;
      },
      {}
    ), Object.keys(t._storyExports).forEach((i) => {
      p0(i, t._meta) || (delete t._storyExports[i], delete t._storyAnnotations[i]);
    }), t._namedExportsOrder) {
      let i = Object.keys(t._storyExports);
      t._storyExports = y0(t._storyExports, t._namedExportsOrder), t._stories = y0(t._stories, t._namedExportsOrder);
      let n = Object.keys(t._storyExports);
      if (i.length !== n.length)
        throw new Error(
          `Missing exports after sort: ${i.filter(
            (a) => !n.includes(a)
          )}`
        );
    }
    return t;
  }
  get meta() {
    return this._meta;
  }
  get stories() {
    return Object.values(this._stories);
  }
  get indexInputs() {
    if (!this._fileName)
      throw new Error(
        Ps.dedent`Cannot automatically create index inputs with CsfFile.indexInputs because the CsfFile instance was created without a the fileName option.
        Either add the fileName option when creating the CsfFile instance, or create the index inputs manually.`
      );
    return Object.entries(this._stories).map(([t, r]) => {
      let i = [...this._meta?.tags ?? [], ...r.tags ?? []];
      return {
        type: "story",
        importPath: this._fileName,
        rawComponentPath: this._rawComponentPath,
        exportName: t,
        name: r.name,
        title: this.meta?.title,
        metaId: this.meta?.id,
        tags: i,
        __id: r.id
      };
    });
  }
}, hJ = /* @__PURE__ */ s((e, t) => {
  let r = Yr(e);
  return new Jc(r, t);
}, "loadCsf"), Yte = /* @__PURE__ */ s((e, t = { sourceMaps: !1 }, r) => {
  let i = cJ(e._ast, t, r);
  return t.sourceMaps ? i : i.code;
}, "formatCsf"), dJ = /* @__PURE__ */ s((e, t = {}) => $c.print(e._ast, t), "printCsf"), Xte = /* @__PURE__ */ s(async (e, t) => {
  let r = (await aJ(e, "utf-8")).toString();
  return hJ(r, { ...t, fileName: e });
}, "readCsf"), Jte = /* @__PURE__ */ s(async (e, t) => {
  if (!(t || e._fileName)) throw new Error("Please specify a fileName for writeCsf");
  await oJ(t, dJ(e).code);
}, "writeCsf");

// src/csf-tools/ConfigFile.ts
var b0 = tt(Ds(), 1), w = tt(le(), 1), zc = tt(ii(), 1), Qc = tt(Br(), 1);
import { readFile as mJ, writeFile as yJ } from "node:fs/promises";
import * as S0 from "recast";
var T0 = Qc.default.default || Qc.default, g0 = zc.default.default || zc.default, Hc = console, Gc = /* @__PURE__ */ s(({
  expectedType: e,
  foundType: t,
  node: r
}) => {
  let i = "";
  if (r)
    try {
      i = JSON.stringify(r);
    } catch {
    }
  return b0.dedent`
      CSF Parsing error: Expected '${e}' but found '${t}' instead in '${r?.type}'.
      ${i}
    `;
}, "getCsfParsingErrorMessage"), As = /* @__PURE__ */ s((e) => w.isIdentifier(e.key) ? e.key.name : w.isStringLiteral(e.key) ? e.key.value :
null, "propKey"), x0 = /* @__PURE__ */ s((e, t) => {
  if (e.length === 0)
    return t;
  if (w.isObjectExpression(t)) {
    let [r, ...i] = e, n = t.properties.find((a) => As(a) === r);
    if (n)
      return x0(i, n.value);
  }
}, "_getPath"), E0 = /* @__PURE__ */ s((e, t) => {
  if (e.length === 0) {
    if (w.isObjectExpression(t))
      return t.properties;
    throw new Error("Expected object expression");
  }
  if (w.isObjectExpression(t)) {
    let [r, ...i] = e, n = t.properties.find((a) => As(a) === r);
    if (n)
      return i.length === 0 ? t.properties : E0(i, n.value);
  }
}, "_getPathProperties"), P0 = /* @__PURE__ */ s((e, t) => {
  let r = null, i = null;
  return t.body.find((n) => (w.isVariableDeclaration(n) ? i = n.declarations : w.isExportNamedDeclaration(n) && w.isVariableDeclaration(n.declaration) &&
  (i = n.declaration.declarations), i && i.find((a) => w.isVariableDeclarator(a) && w.isIdentifier(a.id) && a.id.name === e ? (r = a, !0) : !1))),
  r;
}, "_findVarDeclarator"), Ai = /* @__PURE__ */ s((e, t) => P0(e, t)?.init, "_findVarInitialization"), vs = /* @__PURE__ */ s((e, t) => {
  if (e.length === 0) return t;
  let [r, ...i] = e, n = vs(i, t);
  return w.objectExpression([w.objectProperty(w.identifier(r), n)]);
}, "_makeObjectExpression"), Zc = /* @__PURE__ */ s((e, t, r) => {
  let [i, ...n] = e, a = r.properties.find(
    (o) => As(o) === i
  );
  a ? w.isObjectExpression(a.value) && n.length > 0 ? Zc(n, t, a.value) : a.value = vs(n, t) : r.properties.push(
    w.objectProperty(w.identifier(i), vs(n, t))
  );
}, "_updateExportNode"), ep = class {
  static {
    s(this, "ConfigFile");
  }
  _ast;
  _code;
  _exports = {};
  // FIXME: this is a hack. this is only used in the case where the user is
  // modifying a named export that's a scalar. The _exports map is not suitable
  // for that. But rather than refactor the whole thing, we just use this as a stopgap.
  _exportDecls = {};
  _exportsObject;
  _quotes;
  fileName;
  hasDefaultExport = !1;
  constructor(t, r, i) {
    this._ast = t, this._code = r, this.fileName = i;
  }
  parse() {
    let t = this;
    return T0(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node: r, parent: i }) {
          t.hasDefaultExport = !0;
          let n = w.isIdentifier(r.declaration) && w.isProgram(i) ? Ai(r.declaration.name, i) : r.declaration;
          (w.isTSAsExpression(n) || w.isTSSatisfiesExpression(n)) && (n = n.expression), w.isObjectExpression(n) ? (t._exportsObject = n, n.
          properties.forEach((a) => {
            let o = As(a);
            if (o) {
              let l = a.value;
              w.isIdentifier(l) && (l = Ai(l.name, i)), t._exports[o] = l;
            }
          })) : Hc.warn(
            Gc({
              expectedType: "ObjectExpression",
              foundType: n?.type,
              node: n || r.declaration
            })
          );
        }
      },
      ExportNamedDeclaration: {
        enter({ node: r, parent: i }) {
          w.isVariableDeclaration(r.declaration) ? r.declaration.declarations.forEach((n) => {
            if (w.isVariableDeclarator(n) && w.isIdentifier(n.id)) {
              let { name: a } = n.id, o = n.init;
              w.isIdentifier(o) && (o = Ai(o.name, i)), t._exports[a] = o, t._exportDecls[a] = n;
            }
          }) : r.specifiers ? r.specifiers.forEach((n) => {
            if (w.isExportSpecifier(n) && w.isIdentifier(n.local) && w.isIdentifier(n.exported)) {
              let { name: a } = n.local, { name: o } = n.exported, l = P0(a, i);
              t._exports[o] = l.init, t._exportDecls[o] = l;
            }
          }) : Hc.warn(
            Gc({
              expectedType: "VariableDeclaration",
              foundType: r.declaration?.type,
              node: r.declaration
            })
          );
        }
      },
      ExpressionStatement: {
        enter({ node: r, parent: i }) {
          if (w.isAssignmentExpression(r.expression) && r.expression.operator === "=") {
            let { left: n, right: a } = r.expression;
            if (w.isMemberExpression(n) && w.isIdentifier(n.object) && n.object.name === "module" && w.isIdentifier(n.property) && n.property.
            name === "exports") {
              let o = a;
              w.isIdentifier(a) && (o = Ai(a.name, i)), (w.isTSAsExpression(o) || w.isTSSatisfiesExpression(o)) && (o = o.expression), w.isObjectExpression(
              o) ? (t._exportsObject = o, o.properties.forEach((l) => {
                let u = As(l);
                if (u) {
                  let c = l.value;
                  w.isIdentifier(c) && (c = Ai(
                    c.name,
                    i
                  )), t._exports[u] = c;
                }
              })) : Hc.warn(
                Gc({
                  expectedType: "ObjectExpression",
                  foundType: o?.type,
                  node: o
                })
              );
            }
          }
        }
      }
    }), t;
  }
  getFieldNode(t) {
    let [r, ...i] = t, n = this._exports[r];
    if (n)
      return x0(i, n);
  }
  getFieldProperties(t) {
    let [r, ...i] = t, n = this._exports[r];
    if (n)
      return E0(i, n);
  }
  getFieldValue(t) {
    let r = this.getFieldNode(t);
    if (r) {
      let { code: i } = g0(r, {});
      return (0, eval)(`(() => (${i}))()`);
    }
  }
  getSafeFieldValue(t) {
    try {
      return this.getFieldValue(t);
    } catch {
    }
  }
  setFieldNode(t, r) {
    let [i, ...n] = t, a = this._exports[i];
    if (this._exportsObject)
      Zc(t, r, this._exportsObject), this._exports[t[0]] = r;
    else if (a && w.isObjectExpression(a) && n.length > 0)
      Zc(n, r, a);
    else if (a && n.length === 0 && this._exportDecls[t[0]]) {
      let o = this._exportDecls[t[0]];
      o.init = vs([], r);
    } else {
      if (this.hasDefaultExport)
        throw new Error(
          `Could not set the "${t.join(
            "."
          )}" field as the default export is not an object in this file.`
        );
      {
        let o = vs(n, r), l = w.exportNamedDeclaration(
          w.variableDeclaration("const", [w.variableDeclarator(w.identifier(i), o)])
        );
        this._exports[i] = o, this._ast.program.body.push(l);
      }
    }
  }
  /**
   * Returns the name of a node in a given path, supporting the following formats:
   * 1. { framework: 'value' }
   * 2. { framework: { name: 'value', options: {} } }
   */
  /**
   * Returns the name of a node in a given path, supporting the following formats:
   * @example
   * // 1. { framework: 'framework-name' }
   * // 2. { framework: { name: 'framework-name', options: {} }
   * getNameFromPath(['framework']) // => 'framework-name'
   */
  getNameFromPath(t) {
    let r = this.getFieldNode(t);
    if (r)
      return this._getPresetValue(r, "name");
  }
  /**
   * Returns an array of names of a node in a given path, supporting the following formats:
   * @example
   * const config = {
   *   addons: [
   *     'first-addon',
   *     { name: 'second-addon', options: {} }
   *   ]
   * }
   * // => ['first-addon', 'second-addon']
   * getNamesFromPath(['addons'])
   *
   */
  getNamesFromPath(t) {
    let r = this.getFieldNode(t);
    if (!r)
      return;
    let i = [];
    return w.isArrayExpression(r) && r.elements.forEach((n) => {
      i.push(this._getPresetValue(n, "name"));
    }), i;
  }
  _getPnpWrappedValue(t) {
    if (w.isCallExpression(t)) {
      let r = t.arguments[0];
      if (w.isStringLiteral(r))
        return r.value;
    }
  }
  /**
   * Given a node and a fallback property, returns a **non-evaluated** string value of the node.
   * 1. { node: 'value' }
   * 2. { node: { fallbackProperty: 'value' } }
   */
  _getPresetValue(t, r) {
    let i;
    if (w.isStringLiteral(t) ? i = t.value : w.isObjectExpression(t) && t.properties.forEach((n) => {
      w.isObjectProperty(n) && w.isIdentifier(n.key) && n.key.name === r && (w.isStringLiteral(n.value) ? i = n.value.value : i = this._getPnpWrappedValue(
      n.value)), w.isObjectProperty(n) && w.isStringLiteral(n.key) && n.key.value === "name" && w.isStringLiteral(n.value) && (i = n.value.value);
    }), !i)
      throw new Error(
        `The given node must be a string literal or an object expression with a "${r}" property that is a string literal.`
      );
    return i;
  }
  removeField(t) {
    let r = /* @__PURE__ */ s((n, a) => {
      let o = n.findIndex(
        (l) => w.isIdentifier(l.key) && l.key.name === a || w.isStringLiteral(l.key) && l.key.value === a
      );
      o >= 0 && n.splice(o, 1);
    }, "removeProperty");
    if (t.length === 1) {
      let n = !1;
      if (this._ast.program.body.forEach((a) => {
        if (w.isExportNamedDeclaration(a) && w.isVariableDeclaration(a.declaration)) {
          let o = a.declaration.declarations[0];
          w.isIdentifier(o.id) && o.id.name === t[0] && (this._ast.program.body.splice(this._ast.program.body.indexOf(a), 1), n = !0);
        }
        if (w.isExportDefaultDeclaration(a)) {
          let o = a.declaration;
          if (w.isIdentifier(o) && (o = Ai(o.name, this._ast.program)), (w.isTSAsExpression(o) || w.isTSSatisfiesExpression(o)) && (o = o.expression),
          w.isObjectExpression(o)) {
            let l = o.properties;
            r(l, t[0]), n = !0;
          }
        }
        if (w.isExpressionStatement(a) && w.isAssignmentExpression(a.expression) && w.isMemberExpression(a.expression.left) && w.isIdentifier(
        a.expression.left.object) && a.expression.left.object.name === "module" && w.isIdentifier(a.expression.left.property) && a.expression.
        left.property.name === "exports" && w.isObjectExpression(a.expression.right)) {
          let o = a.expression.right.properties;
          r(o, t[0]), n = !0;
        }
      }), n) return;
    }
    let i = this.getFieldProperties(t);
    if (i) {
      let n = t.at(-1);
      r(i, n);
    }
  }
  appendValueToArray(t, r) {
    let i = this.valueToNode(r);
    i && this.appendNodeToArray(t, i);
  }
  appendNodeToArray(t, r) {
    let i = this.getFieldNode(t);
    if (!i)
      this.setFieldNode(t, w.arrayExpression([r]));
    else if (w.isArrayExpression(i))
      i.elements.push(r);
    else
      throw new Error(`Expected array at '${t.join(".")}', got '${i.type}'`);
  }
  /**
   * Specialized helper to remove addons or other array entries
   * that can either be strings or objects with a name property.
   */
  removeEntryFromArray(t, r) {
    let i = this.getFieldNode(t);
    if (i)
      if (w.isArrayExpression(i)) {
        let n = i.elements.findIndex((a) => w.isStringLiteral(a) ? a.value === r : w.isObjectExpression(a) ? this._getPresetValue(a, "name") ===
        r : this._getPnpWrappedValue(a) === r);
        if (n >= 0)
          i.elements.splice(n, 1);
        else
          throw new Error(`Could not find '${r}' in array at '${t.join(".")}'`);
      } else
        throw new Error(`Expected array at '${t.join(".")}', got '${i.type}'`);
  }
  _inferQuotes() {
    if (!this._quotes) {
      let t = (this._ast.tokens || []).slice(0, 500).reduce(
        (r, i) => (i.type.label === "string" && (r[this._code[i.start]] += 1), r),
        { "'": 0, '"': 0 }
      );
      this._quotes = t["'"] > t['"'] ? "single" : "double";
    }
    return this._quotes;
  }
  valueToNode(t) {
    let r = this._inferQuotes(), i;
    if (r === "single") {
      let { code: n } = g0(w.valueToNode(t), { jsescOption: { quotes: r } }), a = Yr(`const __x = ${n}`);
      T0(a, {
        VariableDeclaration: {
          enter({ node: o }) {
            o.declarations.length === 1 && w.isVariableDeclarator(o.declarations[0]) && w.isIdentifier(o.declarations[0].id) && o.declarations[0].
            id.name === "__x" && (i = o.declarations[0].init);
          }
        }
      });
    } else
      i = w.valueToNode(t);
    return i;
  }
  setFieldValue(t, r) {
    let i = this.valueToNode(r);
    if (!i)
      throw new Error(`Unexpected value ${JSON.stringify(r)}`);
    this.setFieldNode(t, i);
  }
  getBodyDeclarations() {
    return this._ast.program.body;
  }
  setBodyDeclaration(t) {
    this._ast.program.body.push(t);
  }
  /**
   * Import specifiers for a specific require import
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   * @example
   * // const { foo } = require('bar');
   * setRequireImport(['foo'], 'bar');
   *
   * // const foo = require('bar');
   * setRequireImport('foo', 'bar');
   *
   */
  setRequireImport(t, r) {
    let i = this._ast.program.body.find(
      (o) => w.isVariableDeclaration(o) && o.declarations.length === 1 && w.isVariableDeclarator(o.declarations[0]) && w.isCallExpression(o.
      declarations[0].init) && w.isIdentifier(o.declarations[0].init.callee) && o.declarations[0].init.callee.name === "require" && w.isStringLiteral(
      o.declarations[0].init.arguments[0]) && o.declarations[0].init.arguments[0].value === r
    ), n = /* @__PURE__ */ s((o) => w.isObjectPattern(i?.declarations[0].id) && i?.declarations[0].id.properties.find(
      (l) => w.isObjectProperty(l) && w.isIdentifier(l.key) && l.key.name === o
    ), "hasRequireSpecifier"), a = /* @__PURE__ */ s((o, l) => o.declarations.length === 1 && w.isVariableDeclarator(o.declarations[0]) && w.isIdentifier(
    o.declarations[0].id) && o.declarations[0].id.name === l, "hasDefaultRequireSpecifier");
    if (typeof t == "string") {
      let o = /* @__PURE__ */ s(() => {
        this._ast.program.body.unshift(
          w.variableDeclaration("const", [
            w.variableDeclarator(
              w.identifier(t),
              w.callExpression(w.identifier("require"), [w.stringLiteral(r)])
            )
          ])
        );
      }, "addDefaultRequireSpecifier");
      i && a(i, t) || o();
    } else i ? t.forEach((o) => {
      n(o) || i.declarations[0].id.properties.push(
        w.objectProperty(w.identifier(o), w.identifier(o), void 0, !0)
      );
    }) : this._ast.program.body.unshift(
      w.variableDeclaration("const", [
        w.variableDeclarator(
          w.objectPattern(
            t.map(
              (o) => w.objectProperty(w.identifier(o), w.identifier(o), void 0, !0)
            )
          ),
          w.callExpression(w.identifier("require"), [w.stringLiteral(r)])
        )
      ])
    );
  }
  /**
   * Set import specifiers for a given import statement.
   * @description Does not support setting type imports (yet)
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   * @example
   * // import { foo } from 'bar';
   * setImport(['foo'], 'bar');
   *
   * // import foo from 'bar';
   * setImport('foo', 'bar');
   *
   */
  setImport(t, r) {
    let i = /* @__PURE__ */ s((l) => w.importSpecifier(w.identifier(l), w.identifier(l)), "getNewImportSpecifier"), n = /* @__PURE__ */ s((l, u) => l.
    specifiers.find(
      (c) => w.isImportSpecifier(c) && w.isIdentifier(c.imported) && c.imported.name === u
    ), "hasImportSpecifier"), a = /* @__PURE__ */ s((l, u) => l.specifiers.find((c) => w.isImportDefaultSpecifier(c)), "hasDefaultImportSpec\
ifier"), o = this._ast.program.body.find(
      (l) => w.isImportDeclaration(l) && l.source.value === r
    );
    typeof t == "string" ? o ? a(o, t) || o.specifiers.push(
      w.importDefaultSpecifier(w.identifier(t))
    ) : this._ast.program.body.unshift(
      w.importDeclaration(
        [w.importDefaultSpecifier(w.identifier(t))],
        w.stringLiteral(r)
      )
    ) : o ? t.forEach((l) => {
      n(o, l) || o.specifiers.push(i(l));
    }) : this._ast.program.body.unshift(
      w.importDeclaration(
        t.map(
          (l) => w.importSpecifier(w.identifier(l), w.identifier(l))
        ),
        w.stringLiteral(r)
      )
    );
  }
}, TJ = /* @__PURE__ */ s((e, t) => {
  let r = Yr(e);
  return new ep(r, e, t);
}, "loadConfig"), gJ = /* @__PURE__ */ s((e) => bJ(e).code, "formatConfig"), bJ = /* @__PURE__ */ s((e, t = {}) => S0.print(e._ast, t), "pri\
ntConfig"), Qte = /* @__PURE__ */ s(async (e) => {
  let t = (await mJ(e, "utf-8")).toString();
  return TJ(t, e).parse();
}, "readConfig"), Zte = /* @__PURE__ */ s(async (e, t) => {
  let r = t || e.fileName;
  if (!r) throw new Error("Please specify a fileName for writeConfig");
  await yJ(r, gJ(e));
}, "writeConfig");

// src/csf-tools/getStorySortParameter.ts
var xe = tt(le(), 1), tp = tt(Br(), 1), rp = tt(ii(), 1), v0 = tt(Ds(), 1);
var SJ = tp.default.default || tp.default, A0 = rp.default.default || rp.default, xJ = console, ip = /* @__PURE__ */ s((e, t) => {
  let r;
  return e.properties.forEach((i) => {
    xe.isIdentifier(i.key) && i.key.name === t && (r = i.value);
  }), r;
}, "getValue"), sp = /* @__PURE__ */ s((e) => {
  let t = Cs(e);
  if (xe.isArrayExpression(t))
    return t.elements.map((r) => sp(r));
  if (xe.isObjectExpression(t))
    return t.properties.reduce((r, i) => (xe.isIdentifier(i.key) && (r[i.key.name] = sp(i.value)), r), {});
  if (xe.isLiteral(t))
    return t.value;
  if (xe.isIdentifier(t))
    return vi(t.name, !0);
  throw new Error(`Unknown node type ${t.type}`);
}, "parseValue"), vi = /* @__PURE__ */ s((e, t) => {
  let r = v0.dedent`
    Unexpected '${e}'. Parameter 'options.storySort' should be defined inline e.g.:

    export default {
      parameters: {
        options: {
          storySort: <array | object | function>
        },
      },
    };
  `;
  if (t)
    throw new Error(r);
  xJ.info(r);
}, "unsupported"), Cs = /* @__PURE__ */ s((e) => xe.isTSAsExpression(e) || xe.isTSSatisfiesExpression(e) ? e.expression : e, "stripTSModifie\
rs"), C0 = /* @__PURE__ */ s((e) => {
  let t = Cs(e);
  if (xe.isObjectExpression(t)) {
    let r = ip(t, "options");
    if (r) {
      if (xe.isObjectExpression(r))
        return ip(r, "storySort");
      vi("options", !0);
    }
  }
}, "parseParameters"), EJ = /* @__PURE__ */ s((e, t) => {
  let r = Cs(e);
  if (xe.isObjectExpression(r)) {
    let i = ip(r, "parameters");
    if (xe.isIdentifier(i) && (i = tr(i.name, t)), i)
      return C0(i);
  } else
    vi("default", !0);
}, "parseDefault"), sre = /* @__PURE__ */ s((e) => {
  if (!e.includes("storySort")) return;
  let t, r = Yr(e);
  if (SJ(r, {
    ExportNamedDeclaration: {
      enter({ node: i }) {
        xe.isVariableDeclaration(i.declaration) ? i.declaration.declarations.forEach((n) => {
          if (xe.isVariableDeclarator(n) && xe.isIdentifier(n.id)) {
            let { name: a } = n.id;
            if (a === "parameters" && n.init) {
              let o = Cs(n.init);
              t = C0(o);
            }
          }
        }) : i.specifiers.forEach((n) => {
          xe.isIdentifier(n.exported) && n.exported.name === "parameters" && vi("parameters", !1);
        });
      }
    },
    ExportDefaultDeclaration: {
      enter({ node: i }) {
        let n = i.declaration;
        xe.isIdentifier(n) && (n = tr(n.name, r.program)), n = Cs(n), xe.isObjectExpression(n) ? t = EJ(n, r.program) : vi("default", !1);
      }
    }
  }), !!t) {
    if (xe.isArrowFunctionExpression(t)) {
      let { code: i } = A0(t, {});
      return (0, eval)(i);
    }
    if (xe.isFunctionExpression(t)) {
      let { code: i } = A0(t, {}), n = t.id?.name, a = `(a, b) => {
      ${i};
      return ${n}(a, b)
    }`;
      return (0, eval)(a);
    }
    return xe.isLiteral(t) || xe.isArrayExpression(t) || xe.isObjectExpression(t) ? sp(t) : vi("storySort", !0);
  }
}, "getStorySortParameter");

// src/csf-tools/enrichCsf.ts
var ee = tt(le(), 1), np = tt(ii(), 1);
var PJ = np.default.default || np.default, AJ = /* @__PURE__ */ s((e, t, r, i) => {
  let n = t.getStoryExport(r), a = !i?.disableSource && CJ(n), o = !i?.disableDescription && w0(t._storyStatements[r]), l = [], u = ee.memberExpression(
  ee.identifier(r), ee.identifier("parameters"));
  l.push(ee.spreadElement(u));
  let c = ee.optionalMemberExpression(
    u,
    ee.identifier("docs"),
    !1,
    !0
  ), p = [];
  if (a) {
    let g = ee.optionalMemberExpression(
      c,
      ee.identifier("source"),
      !1,
      !0
    );
    p.push(
      ee.objectProperty(
        ee.identifier("source"),
        ee.objectExpression([
          ee.objectProperty(ee.identifier("originalSource"), ee.stringLiteral(a)),
          ee.spreadElement(g)
        ])
      )
    );
  }
  if (o) {
    let g = ee.optionalMemberExpression(
      c,
      ee.identifier("description"),
      !1,
      !0
    );
    p.push(
      ee.objectProperty(
        ee.identifier("description"),
        ee.objectExpression([
          ee.objectProperty(ee.identifier("story"), ee.stringLiteral(o)),
          ee.spreadElement(g)
        ])
      )
    );
  }
  if (p.length > 0) {
    l.push(
      ee.objectProperty(
        ee.identifier("docs"),
        ee.objectExpression([ee.spreadElement(c), ...p])
      )
    );
    let g = ee.expressionStatement(
      ee.assignmentExpression("=", u, ee.objectExpression(l))
    );
    e._ast.program.body.push(g);
  }
}, "enrichCsfStory"), I0 = /* @__PURE__ */ s((e, t, r) => {
  if (!t.length) {
    e.properties.find(
      (u) => ee.isObjectProperty(u) && ee.isIdentifier(u.key) && u.key.name === "component"
    ) || e.properties.unshift(r);
    return;
  }
  let [i, ...n] = t, a = e.properties.find(
    (l) => ee.isObjectProperty(l) && ee.isIdentifier(l.key) && l.key.name === i && ee.isObjectExpression(l.value)
  ), o;
  a ? o = a.value : (o = ee.objectExpression([]), e.properties.push(ee.objectProperty(ee.identifier(i), o))), I0(o, n, r);
}, "addComponentDescription"), vJ = /* @__PURE__ */ s((e, t, r) => {
  let i = !r?.disableDescription && w0(t._metaStatement);
  if (i) {
    let n = e._metaNode;
    n && ee.isObjectExpression(n) && I0(
      n,
      ["parameters", "docs", "description"],
      ee.objectProperty(ee.identifier("component"), ee.stringLiteral(i))
    );
  }
}, "enrichCsfMeta"), ore = /* @__PURE__ */ s((e, t, r) => {
  vJ(e, t, r), Object.keys(e._storyExports).forEach((i) => {
    AJ(e, t, i, r);
  });
}, "enrichCsf"), CJ = /* @__PURE__ */ s((e) => {
  let t = ee.isVariableDeclarator(e) ? e.init : e, { code: r } = PJ(t, {});
  return r;
}, "extractSource"), w0 = /* @__PURE__ */ s((e) => e?.leadingComments ? e.leadingComments.map((r) => r.type === "CommentLine" || !r.value.startsWith(
"*") ? null : r.value.split(`
`).map((i) => i.replace(/^(\s+)?(\*+)?(\s)?/, "")).join(`
`).trim()).filter(Boolean).join(`
`) : "", "extractDescription");
export {
  ep as ConfigFile,
  Jc as CsfFile,
  la as NoMetaError,
  Yr as babelParse,
  Fte as babelParseExpression,
  Mte as babelPrint,
  ore as enrichCsf,
  vJ as enrichCsfMeta,
  AJ as enrichCsfStory,
  w0 as extractDescription,
  CJ as extractSource,
  gJ as formatConfig,
  Yte as formatCsf,
  sre as getStorySortParameter,
  TJ as loadConfig,
  hJ as loadCsf,
  c0 as parserOptions,
  bJ as printConfig,
  dJ as printCsf,
  Qte as readConfig,
  Xte as readCsf,
  Zte as writeConfig,
  Jte as writeCsf
};
