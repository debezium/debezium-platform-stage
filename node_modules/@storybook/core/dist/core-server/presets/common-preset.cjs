"use strict";
var WW = Object.create;
var Au = Object.defineProperty;
var HW = Object.getOwnPropertyDescriptor;
var GW = Object.getOwnPropertyNames;
var KW = Object.getPrototypeOf, YW = Object.prototype.hasOwnProperty;
var i = (e, t) => Au(e, "name", { value: t, configurable: !0 });
var ei = (e, t) => () => (e && (t = e(e = 0)), t);
var y = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), S0 = (e, t) => {
  for (var r in t)
    Au(e, r, { get: t[r], enumerable: !0 });
}, hD = (e, t, r, s) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of GW(t))
      !YW.call(e, n) && n !== r && Au(e, n, { get: () => t[n], enumerable: !(s = HW(t, n)) || s.enumerable });
  return e;
};
var Ve = (e, t, r) => (r = e != null ? WW(KW(e)) : {}, hD(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? Au(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), XW = (e) => hD(Au({}, "__esModule", { value: !0 }), e);

// ../node_modules/universalify/index.js
var xr = y((T0) => {
  "use strict";
  T0.fromCallback = function(e) {
    return Object.defineProperty(function(...t) {
      if (typeof t[t.length - 1] == "function") e.apply(this, t);
      else
        return new Promise((r, s) => {
          e.call(
            this,
            ...t,
            (n, a) => n != null ? s(n) : r(a)
          );
        });
    }, "name", { value: e.name });
  };
  T0.fromPromise = function(e) {
    return Object.defineProperty(function(...t) {
      let r = t[t.length - 1];
      if (typeof r != "function") return e.apply(this, t);
      e.apply(this, t.slice(0, -1)).then((s) => r(null, s), r);
    }, "name", { value: e.name });
  };
});

// ../node_modules/graceful-fs/polyfills.js
var yD = y((EWe, mD) => {
  var Ui = require("constants"), zW = process.cwd, ip = null, JW = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return ip || (ip = zW.call(process)), ip;
  };
  try {
    process.cwd();
  } catch {
  }
  typeof process.chdir == "function" && (x0 = process.chdir, process.chdir = function(e) {
    ip = null, x0.call(process, e);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, x0));
  var x0;
  mD.exports = QW;
  function QW(e) {
    Ui.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && t(e), e.lutimes || r(e), e.chown = a(e.chown), e.fchown =
    a(e.fchown), e.lchown = a(e.lchown), e.chmod = s(e.chmod), e.fchmod = s(e.fchmod), e.lchmod = s(e.lchmod), e.chownSync = o(e.chownSync),
    e.fchownSync = o(e.fchownSync), e.lchownSync = o(e.lchownSync), e.chmodSync = n(e.chmodSync), e.fchmodSync = n(e.fchmodSync), e.lchmodSync =
    n(e.lchmodSync), e.stat = l(e.stat), e.fstat = l(e.fstat), e.lstat = l(e.lstat), e.statSync = u(e.statSync), e.fstatSync = u(e.fstatSync),
    e.lstatSync = u(e.lstatSync), e.chmod && !e.lchmod && (e.lchmod = function(f, p, d) {
      d && process.nextTick(d);
    }, e.lchmodSync = function() {
    }), e.chown && !e.lchown && (e.lchown = function(f, p, d, m) {
      m && process.nextTick(m);
    }, e.lchownSync = function() {
    }), JW === "win32" && (e.rename = typeof e.rename != "function" ? e.rename : function(f) {
      function p(d, m, b) {
        var h = Date.now(), g = 0;
        f(d, m, /* @__PURE__ */ i(function E(D) {
          if (D && (D.code === "EACCES" || D.code === "EPERM" || D.code === "EBUSY") && Date.now() - h < 6e4) {
            setTimeout(function() {
              e.stat(m, function(C, N) {
                C && C.code === "ENOENT" ? f(d, m, E) : b(D);
              });
            }, g), g < 100 && (g += 10);
            return;
          }
          b && b(D);
        }, "CB"));
      }
      return i(p, "rename"), Object.setPrototypeOf && Object.setPrototypeOf(p, f), p;
    }(e.rename)), e.read = typeof e.read != "function" ? e.read : function(f) {
      function p(d, m, b, h, g, E) {
        var D;
        if (E && typeof E == "function") {
          var C = 0;
          D = /* @__PURE__ */ i(function(N, I, M) {
            if (N && N.code === "EAGAIN" && C < 10)
              return C++, f.call(e, d, m, b, h, g, D);
            E.apply(this, arguments);
          }, "callback");
        }
        return f.call(e, d, m, b, h, g, D);
      }
      return i(p, "read"), Object.setPrototypeOf && Object.setPrototypeOf(p, f), p;
    }(e.read), e.readSync = typeof e.readSync != "function" ? e.readSync : /* @__PURE__ */ function(f) {
      return function(p, d, m, b, h) {
        for (var g = 0; ; )
          try {
            return f.call(e, p, d, m, b, h);
          } catch (E) {
            if (E.code === "EAGAIN" && g < 10) {
              g++;
              continue;
            }
            throw E;
          }
      };
    }(e.readSync);
    function t(f) {
      f.lchmod = function(p, d, m) {
        f.open(
          p,
          Ui.O_WRONLY | Ui.O_SYMLINK,
          d,
          function(b, h) {
            if (b) {
              m && m(b);
              return;
            }
            f.fchmod(h, d, function(g) {
              f.close(h, function(E) {
                m && m(g || E);
              });
            });
          }
        );
      }, f.lchmodSync = function(p, d) {
        var m = f.openSync(p, Ui.O_WRONLY | Ui.O_SYMLINK, d), b = !0, h;
        try {
          h = f.fchmodSync(m, d), b = !1;
        } finally {
          if (b)
            try {
              f.closeSync(m);
            } catch {
            }
          else
            f.closeSync(m);
        }
        return h;
      };
    }
    i(t, "patchLchmod");
    function r(f) {
      Ui.hasOwnProperty("O_SYMLINK") && f.futimes ? (f.lutimes = function(p, d, m, b) {
        f.open(p, Ui.O_SYMLINK, function(h, g) {
          if (h) {
            b && b(h);
            return;
          }
          f.futimes(g, d, m, function(E) {
            f.close(g, function(D) {
              b && b(E || D);
            });
          });
        });
      }, f.lutimesSync = function(p, d, m) {
        var b = f.openSync(p, Ui.O_SYMLINK), h, g = !0;
        try {
          h = f.futimesSync(b, d, m), g = !1;
        } finally {
          if (g)
            try {
              f.closeSync(b);
            } catch {
            }
          else
            f.closeSync(b);
        }
        return h;
      }) : f.futimes && (f.lutimes = function(p, d, m, b) {
        b && process.nextTick(b);
      }, f.lutimesSync = function() {
      });
    }
    i(r, "patchLutimes");
    function s(f) {
      return f && function(p, d, m) {
        return f.call(e, p, d, function(b) {
          c(b) && (b = null), m && m.apply(this, arguments);
        });
      };
    }
    i(s, "chmodFix");
    function n(f) {
      return f && function(p, d) {
        try {
          return f.call(e, p, d);
        } catch (m) {
          if (!c(m)) throw m;
        }
      };
    }
    i(n, "chmodFixSync");
    function a(f) {
      return f && function(p, d, m, b) {
        return f.call(e, p, d, m, function(h) {
          c(h) && (h = null), b && b.apply(this, arguments);
        });
      };
    }
    i(a, "chownFix");
    function o(f) {
      return f && function(p, d, m) {
        try {
          return f.call(e, p, d, m);
        } catch (b) {
          if (!c(b)) throw b;
        }
      };
    }
    i(o, "chownFixSync");
    function l(f) {
      return f && function(p, d, m) {
        typeof d == "function" && (m = d, d = null);
        function b(h, g) {
          g && (g.uid < 0 && (g.uid += 4294967296), g.gid < 0 && (g.gid += 4294967296)), m && m.apply(this, arguments);
        }
        return i(b, "callback"), d ? f.call(e, p, d, b) : f.call(e, p, b);
      };
    }
    i(l, "statFix");
    function u(f) {
      return f && function(p, d) {
        var m = d ? f.call(e, p, d) : f.call(e, p);
        return m && (m.uid < 0 && (m.uid += 4294967296), m.gid < 0 && (m.gid += 4294967296)), m;
      };
    }
    i(u, "statFixSync");
    function c(f) {
      if (!f || f.code === "ENOSYS")
        return !0;
      var p = !process.getuid || process.getuid() !== 0;
      return !!(p && (f.code === "EINVAL" || f.code === "EPERM"));
    }
    i(c, "chownErOk");
  }
  i(QW, "patch");
});

// ../node_modules/graceful-fs/legacy-streams.js
var ED = y((SWe, bD) => {
  var gD = require("stream").Stream;
  bD.exports = ZW;
  function ZW(e) {
    return {
      ReadStream: t,
      WriteStream: r
    };
    function t(s, n) {
      if (!(this instanceof t)) return new t(s, n);
      gD.call(this);
      var a = this;
      this.path = s, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, n =
      n || {};
      for (var o = Object.keys(n), l = 0, u = o.length; l < u; l++) {
        var c = o[l];
        this[c] = n[c];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          a._read();
        });
        return;
      }
      e.open(this.path, this.flags, this.mode, function(f, p) {
        if (f) {
          a.emit("error", f), a.readable = !1;
          return;
        }
        a.fd = p, a.emit("open", p), a._read();
      });
    }
    function r(s, n) {
      if (!(this instanceof r)) return new r(s, n);
      gD.call(this), this.path = s, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten =
      0, n = n || {};
      for (var a = Object.keys(n), o = 0, l = a.length; o < l; o++) {
        var u = a[o];
        this[u] = n[u];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = e.open, this._queue.push([this._open, this.path, this.flags, this.
      mode, void 0]), this.flush());
    }
  }
  i(ZW, "legacy");
});

// ../node_modules/graceful-fs/clone.js
var SD = y((xWe, vD) => {
  "use strict";
  vD.exports = tH;
  var eH = Object.getPrototypeOf || function(e) {
    return e.__proto__;
  };
  function tH(e) {
    if (e === null || typeof e != "object")
      return e;
    if (e instanceof Object)
      var t = { __proto__: eH(e) };
    else
      var t = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(e).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
    }), t;
  }
  i(tH, "clone");
});

// ../node_modules/graceful-fs/graceful-fs.js
var Uo = y((AWe, C0) => {
  var er = require("fs"), rH = yD(), sH = ED(), nH = SD(), ap = require("util"), Or, lp;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (Or = Symbol.for("graceful-fs.queue"), lp = Symbol.for("graceful-fs.previ\
ous")) : (Or = "___graceful-fs.queue", lp = "___graceful-fs.previous");
  function iH() {
  }
  i(iH, "noop");
  function PD(e, t) {
    Object.defineProperty(e, Or, {
      get: /* @__PURE__ */ i(function() {
        return t;
      }, "get")
    });
  }
  i(PD, "publishQueue");
  var qa = iH;
  ap.debuglog ? qa = ap.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (qa = /* @__PURE__ */ i(function() {
    var e = ap.format.apply(ap, arguments);
    e = "GFS4: " + e.split(/\n/).join(`
GFS4: `), console.error(e);
  }, "debug"));
  er[Or] || (TD = global[Or] || [], PD(er, TD), er.close = function(e) {
    function t(r, s) {
      return e.call(er, r, function(n) {
        n || xD(), typeof s == "function" && s.apply(this, arguments);
      });
    }
    return i(t, "close"), Object.defineProperty(t, lp, {
      value: e
    }), t;
  }(er.close), er.closeSync = function(e) {
    function t(r) {
      e.apply(er, arguments), xD();
    }
    return i(t, "closeSync"), Object.defineProperty(t, lp, {
      value: e
    }), t;
  }(er.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    qa(er[Or]), require("assert").equal(er[Or].length, 0);
  }));
  var TD;
  global[Or] || PD(global, er[Or]);
  C0.exports = P0(nH(er));
  process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !er.__patched && (C0.exports = P0(er), er.__patched = !0);
  function P0(e) {
    rH(e), e.gracefulify = P0, e.createReadStream = I, e.createWriteStream = M;
    var t = e.readFile;
    e.readFile = r;
    function r(W, Y, j) {
      return typeof Y == "function" && (j = Y, Y = null), ie(W, Y, j);
      function ie(fe, De, F, L) {
        return t(fe, De, function(re) {
          re && (re.code === "EMFILE" || re.code === "ENFILE") ? $o([ie, [fe, De, F], re, L || Date.now(), Date.now()]) : typeof F == "funct\
ion" && F.apply(this, arguments);
        });
      }
      i(ie, "go$readFile");
    }
    i(r, "readFile");
    var s = e.writeFile;
    e.writeFile = n;
    function n(W, Y, j, ie) {
      return typeof j == "function" && (ie = j, j = null), fe(W, Y, j, ie);
      function fe(De, F, L, re, se) {
        return s(De, F, L, function(be) {
          be && (be.code === "EMFILE" || be.code === "ENFILE") ? $o([fe, [De, F, L, re], be, se || Date.now(), Date.now()]) : typeof re == "\
function" && re.apply(this, arguments);
        });
      }
      i(fe, "go$writeFile");
    }
    i(n, "writeFile");
    var a = e.appendFile;
    a && (e.appendFile = o);
    function o(W, Y, j, ie) {
      return typeof j == "function" && (ie = j, j = null), fe(W, Y, j, ie);
      function fe(De, F, L, re, se) {
        return a(De, F, L, function(be) {
          be && (be.code === "EMFILE" || be.code === "ENFILE") ? $o([fe, [De, F, L, re], be, se || Date.now(), Date.now()]) : typeof re == "\
function" && re.apply(this, arguments);
        });
      }
      i(fe, "go$appendFile");
    }
    i(o, "appendFile");
    var l = e.copyFile;
    l && (e.copyFile = u);
    function u(W, Y, j, ie) {
      return typeof j == "function" && (ie = j, j = 0), fe(W, Y, j, ie);
      function fe(De, F, L, re, se) {
        return l(De, F, L, function(be) {
          be && (be.code === "EMFILE" || be.code === "ENFILE") ? $o([fe, [De, F, L, re], be, se || Date.now(), Date.now()]) : typeof re == "\
function" && re.apply(this, arguments);
        });
      }
      i(fe, "go$copyFile");
    }
    i(u, "copyFile");
    var c = e.readdir;
    e.readdir = p;
    var f = /^v[0-5]\./;
    function p(W, Y, j) {
      typeof Y == "function" && (j = Y, Y = null);
      var ie = f.test(process.version) ? /* @__PURE__ */ i(function(F, L, re, se) {
        return c(F, fe(
          F,
          L,
          re,
          se
        ));
      }, "go$readdir") : /* @__PURE__ */ i(function(F, L, re, se) {
        return c(F, L, fe(
          F,
          L,
          re,
          se
        ));
      }, "go$readdir");
      return ie(W, Y, j);
      function fe(De, F, L, re) {
        return function(se, be) {
          se && (se.code === "EMFILE" || se.code === "ENFILE") ? $o([
            ie,
            [De, F, L],
            se,
            re || Date.now(),
            Date.now()
          ]) : (be && be.sort && be.sort(), typeof L == "function" && L.call(this, se, be));
        };
      }
    }
    if (i(p, "readdir"), process.version.substr(0, 4) === "v0.8") {
      var d = sH(e);
      E = d.ReadStream, C = d.WriteStream;
    }
    var m = e.ReadStream;
    m && (E.prototype = Object.create(m.prototype), E.prototype.open = D);
    var b = e.WriteStream;
    b && (C.prototype = Object.create(b.prototype), C.prototype.open = N), Object.defineProperty(e, "ReadStream", {
      get: /* @__PURE__ */ i(function() {
        return E;
      }, "get"),
      set: /* @__PURE__ */ i(function(W) {
        E = W;
      }, "set"),
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e, "WriteStream", {
      get: /* @__PURE__ */ i(function() {
        return C;
      }, "get"),
      set: /* @__PURE__ */ i(function(W) {
        C = W;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var h = E;
    Object.defineProperty(e, "FileReadStream", {
      get: /* @__PURE__ */ i(function() {
        return h;
      }, "get"),
      set: /* @__PURE__ */ i(function(W) {
        h = W;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var g = C;
    Object.defineProperty(e, "FileWriteStream", {
      get: /* @__PURE__ */ i(function() {
        return g;
      }, "get"),
      set: /* @__PURE__ */ i(function(W) {
        g = W;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    function E(W, Y) {
      return this instanceof E ? (m.apply(this, arguments), this) : E.apply(Object.create(E.prototype), arguments);
    }
    i(E, "ReadStream");
    function D() {
      var W = this;
      V(W.path, W.flags, W.mode, function(Y, j) {
        Y ? (W.autoClose && W.destroy(), W.emit("error", Y)) : (W.fd = j, W.emit("open", j), W.read());
      });
    }
    i(D, "ReadStream$open");
    function C(W, Y) {
      return this instanceof C ? (b.apply(this, arguments), this) : C.apply(Object.create(C.prototype), arguments);
    }
    i(C, "WriteStream");
    function N() {
      var W = this;
      V(W.path, W.flags, W.mode, function(Y, j) {
        Y ? (W.destroy(), W.emit("error", Y)) : (W.fd = j, W.emit("open", j));
      });
    }
    i(N, "WriteStream$open");
    function I(W, Y) {
      return new e.ReadStream(W, Y);
    }
    i(I, "createReadStream");
    function M(W, Y) {
      return new e.WriteStream(W, Y);
    }
    i(M, "createWriteStream");
    var q = e.open;
    e.open = V;
    function V(W, Y, j, ie) {
      return typeof j == "function" && (ie = j, j = null), fe(W, Y, j, ie);
      function fe(De, F, L, re, se) {
        return q(De, F, L, function(be, je) {
          be && (be.code === "EMFILE" || be.code === "ENFILE") ? $o([fe, [De, F, L, re], be, se || Date.now(), Date.now()]) : typeof re == "\
function" && re.apply(this, arguments);
        });
      }
      i(fe, "go$open");
    }
    return i(V, "open"), e;
  }
  i(P0, "patch");
  function $o(e) {
    qa("ENQUEUE", e[0].name, e[1]), er[Or].push(e), A0();
  }
  i($o, "enqueue");
  var op;
  function xD() {
    for (var e = Date.now(), t = 0; t < er[Or].length; ++t)
      er[Or][t].length > 2 && (er[Or][t][3] = e, er[Or][t][4] = e);
    A0();
  }
  i(xD, "resetQueue");
  function A0() {
    if (clearTimeout(op), op = void 0, er[Or].length !== 0) {
      var e = er[Or].shift(), t = e[0], r = e[1], s = e[2], n = e[3], a = e[4];
      if (n === void 0)
        qa("RETRY", t.name, r), t.apply(null, r);
      else if (Date.now() - n >= 6e4) {
        qa("TIMEOUT", t.name, r);
        var o = r.pop();
        typeof o == "function" && o.call(null, s);
      } else {
        var l = Date.now() - a, u = Math.max(a - n, 1), c = Math.min(u * 1.2, 100);
        l >= c ? (qa("RETRY", t.name, r), t.apply(null, r.concat([n]))) : er[Or].push(e);
      }
      op === void 0 && (op = setTimeout(A0, 0));
    }
  }
  i(A0, "retry");
});

// ../node_modules/fs-extra/lib/fs/index.js
var Qr = y((ti) => {
  "use strict";
  var AD = xr().fromCallback, Jr = Uo(), aH = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((e) => typeof Jr[e] == "function");
  Object.assign(ti, Jr);
  aH.forEach((e) => {
    ti[e] = AD(Jr[e]);
  });
  ti.exists = function(e, t) {
    return typeof t == "function" ? Jr.exists(e, t) : new Promise((r) => Jr.exists(e, r));
  };
  ti.read = function(e, t, r, s, n, a) {
    return typeof a == "function" ? Jr.read(e, t, r, s, n, a) : new Promise((o, l) => {
      Jr.read(e, t, r, s, n, (u, c, f) => {
        if (u) return l(u);
        o({ bytesRead: c, buffer: f });
      });
    });
  };
  ti.write = function(e, t, ...r) {
    return typeof r[r.length - 1] == "function" ? Jr.write(e, t, ...r) : new Promise((s, n) => {
      Jr.write(e, t, ...r, (a, o, l) => {
        if (a) return n(a);
        s({ bytesWritten: o, buffer: l });
      });
    });
  };
  ti.readv = function(e, t, ...r) {
    return typeof r[r.length - 1] == "function" ? Jr.readv(e, t, ...r) : new Promise((s, n) => {
      Jr.readv(e, t, ...r, (a, o, l) => {
        if (a) return n(a);
        s({ bytesRead: o, buffers: l });
      });
    });
  };
  ti.writev = function(e, t, ...r) {
    return typeof r[r.length - 1] == "function" ? Jr.writev(e, t, ...r) : new Promise((s, n) => {
      Jr.writev(e, t, ...r, (a, o, l) => {
        if (a) return n(a);
        s({ bytesWritten: o, buffers: l });
      });
    });
  };
  typeof Jr.realpath.native == "function" ? ti.realpath.native = AD(Jr.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
});

// ../node_modules/fs-extra/lib/mkdirs/utils.js
var wD = y((DWe, CD) => {
  "use strict";
  var oH = require("path");
  CD.exports.checkPath = /* @__PURE__ */ i(function(t) {
    if (process.platform === "win32" && /[<>:"|?*]/.test(t.replace(oH.parse(t).root, ""))) {
      let s = new Error(`Path contains invalid characters: ${t}`);
      throw s.code = "EINVAL", s;
    }
  }, "checkPath");
});

// ../node_modules/fs-extra/lib/mkdirs/make-dir.js
var OD = y((_We, w0) => {
  "use strict";
  var DD = Qr(), { checkPath: ID } = wD(), _D = /* @__PURE__ */ i((e) => {
    let t = { mode: 511 };
    return typeof e == "number" ? e : { ...t, ...e }.mode;
  }, "getMode");
  w0.exports.makeDir = async (e, t) => (ID(e), DD.mkdir(e, {
    mode: _D(t),
    recursive: !0
  }));
  w0.exports.makeDirSync = (e, t) => (ID(e), DD.mkdirSync(e, {
    mode: _D(t),
    recursive: !0
  }));
});

// ../node_modules/fs-extra/lib/mkdirs/index.js
var nn = y((NWe, ND) => {
  "use strict";
  var lH = xr().fromPromise, { makeDir: uH, makeDirSync: D0 } = OD(), I0 = lH(uH);
  ND.exports = {
    mkdirs: I0,
    mkdirsSync: D0,
    // alias
    mkdirp: I0,
    mkdirpSync: D0,
    ensureDir: I0,
    ensureDirSync: D0
  };
});

// ../node_modules/fs-extra/lib/path-exists/index.js
var Vi = y((RWe, kD) => {
  "use strict";
  var cH = xr().fromPromise, RD = Qr();
  function fH(e) {
    return RD.access(e).then(() => !0).catch(() => !1);
  }
  i(fH, "pathExists");
  kD.exports = {
    pathExists: cH(fH),
    pathExistsSync: RD.existsSync
  };
});

// ../node_modules/fs-extra/lib/util/utimes.js
var _0 = y((FWe, FD) => {
  "use strict";
  var Vo = Qr(), pH = xr().fromPromise;
  async function dH(e, t, r) {
    let s = await Vo.open(e, "r+"), n = null;
    try {
      await Vo.futimes(s, t, r);
    } finally {
      try {
        await Vo.close(s);
      } catch (a) {
        n = a;
      }
    }
    if (n)
      throw n;
  }
  i(dH, "utimesMillis");
  function hH(e, t, r) {
    let s = Vo.openSync(e, "r+");
    return Vo.futimesSync(s, t, r), Vo.closeSync(s);
  }
  i(hH, "utimesMillisSync");
  FD.exports = {
    utimesMillis: pH(dH),
    utimesMillisSync: hH
  };
});

// ../node_modules/fs-extra/lib/util/stat.js
var $a = y((BWe, jD) => {
  "use strict";
  var Wo = Qr(), Pr = require("path"), LD = xr().fromPromise;
  function mH(e, t, r) {
    let s = r.dereference ? (n) => Wo.stat(n, { bigint: !0 }) : (n) => Wo.lstat(n, { bigint: !0 });
    return Promise.all([
      s(e),
      s(t).catch((n) => {
        if (n.code === "ENOENT") return null;
        throw n;
      })
    ]).then(([n, a]) => ({ srcStat: n, destStat: a }));
  }
  i(mH, "getStats");
  function yH(e, t, r) {
    let s, n = r.dereference ? (o) => Wo.statSync(o, { bigint: !0 }) : (o) => Wo.lstatSync(o, { bigint: !0 }), a = n(e);
    try {
      s = n(t);
    } catch (o) {
      if (o.code === "ENOENT") return { srcStat: a, destStat: null };
      throw o;
    }
    return { srcStat: a, destStat: s };
  }
  i(yH, "getStatsSync");
  async function gH(e, t, r, s) {
    let { srcStat: n, destStat: a } = await mH(e, t, s);
    if (a) {
      if (Cu(n, a)) {
        let o = Pr.basename(e), l = Pr.basename(t);
        if (r === "move" && o !== l && o.toLowerCase() === l.toLowerCase())
          return { srcStat: n, destStat: a, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (n.isDirectory() && !a.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);
      if (!n.isDirectory() && a.isDirectory())
        throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`);
    }
    if (n.isDirectory() && O0(e, t))
      throw new Error(up(e, t, r));
    return { srcStat: n, destStat: a };
  }
  i(gH, "checkPaths");
  function bH(e, t, r, s) {
    let { srcStat: n, destStat: a } = yH(e, t, s);
    if (a) {
      if (Cu(n, a)) {
        let o = Pr.basename(e), l = Pr.basename(t);
        if (r === "move" && o !== l && o.toLowerCase() === l.toLowerCase())
          return { srcStat: n, destStat: a, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (n.isDirectory() && !a.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);
      if (!n.isDirectory() && a.isDirectory())
        throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`);
    }
    if (n.isDirectory() && O0(e, t))
      throw new Error(up(e, t, r));
    return { srcStat: n, destStat: a };
  }
  i(bH, "checkPathsSync");
  async function BD(e, t, r, s) {
    let n = Pr.resolve(Pr.dirname(e)), a = Pr.resolve(Pr.dirname(r));
    if (a === n || a === Pr.parse(a).root) return;
    let o;
    try {
      o = await Wo.stat(a, { bigint: !0 });
    } catch (l) {
      if (l.code === "ENOENT") return;
      throw l;
    }
    if (Cu(t, o))
      throw new Error(up(e, r, s));
    return BD(e, t, a, s);
  }
  i(BD, "checkParentPaths");
  function MD(e, t, r, s) {
    let n = Pr.resolve(Pr.dirname(e)), a = Pr.resolve(Pr.dirname(r));
    if (a === n || a === Pr.parse(a).root) return;
    let o;
    try {
      o = Wo.statSync(a, { bigint: !0 });
    } catch (l) {
      if (l.code === "ENOENT") return;
      throw l;
    }
    if (Cu(t, o))
      throw new Error(up(e, r, s));
    return MD(e, t, a, s);
  }
  i(MD, "checkParentPathsSync");
  function Cu(e, t) {
    return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
  }
  i(Cu, "areIdentical");
  function O0(e, t) {
    let r = Pr.resolve(e).split(Pr.sep).filter((n) => n), s = Pr.resolve(t).split(Pr.sep).filter((n) => n);
    return r.every((n, a) => s[a] === n);
  }
  i(O0, "isSrcSubdir");
  function up(e, t, r) {
    return `Cannot ${r} '${e}' to a subdirectory of itself, '${t}'.`;
  }
  i(up, "errMsg");
  jD.exports = {
    // checkPaths
    checkPaths: LD(gH),
    checkPathsSync: bH,
    // checkParent
    checkParentPaths: LD(BD),
    checkParentPathsSync: MD,
    // Misc
    isSrcSubdir: O0,
    areIdentical: Cu
  };
});

// ../node_modules/fs-extra/lib/copy/copy.js
var WD = y((jWe, VD) => {
  "use strict";
  var Lr = Qr(), wu = require("path"), { mkdirs: EH } = nn(), { pathExists: vH } = Vi(), { utimesMillis: SH } = _0(), Du = $a();
  async function TH(e, t, r = {}) {
    typeof r == "function" && (r = { filter: r }), r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite :
    r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0001"
    );
    let { srcStat: s, destStat: n } = await Du.checkPaths(e, t, "copy", r);
    if (await Du.checkParentPaths(e, s, t, "copy"), !await $D(e, t, r)) return;
    let o = wu.dirname(t);
    await vH(o) || await EH(o), await UD(n, e, t, r);
  }
  i(TH, "copy");
  async function $D(e, t, r) {
    return r.filter ? r.filter(e, t) : !0;
  }
  i($D, "runFilter");
  async function UD(e, t, r, s) {
    let a = await (s.dereference ? Lr.stat : Lr.lstat)(t);
    if (a.isDirectory()) return CH(a, e, t, r, s);
    if (a.isFile() || a.isCharacterDevice() || a.isBlockDevice()) return xH(a, e, t, r, s);
    if (a.isSymbolicLink()) return wH(e, t, r, s);
    throw a.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : a.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(
    `Unknown file: ${t}`);
  }
  i(UD, "getStatsAndPerformCopy");
  async function xH(e, t, r, s, n) {
    if (!t) return qD(e, r, s, n);
    if (n.overwrite)
      return await Lr.unlink(s), qD(e, r, s, n);
    if (n.errorOnExist)
      throw new Error(`'${s}' already exists`);
  }
  i(xH, "onFile");
  async function qD(e, t, r, s) {
    if (await Lr.copyFile(t, r), s.preserveTimestamps) {
      PH(e.mode) && await AH(r, e.mode);
      let n = await Lr.stat(t);
      await SH(r, n.atime, n.mtime);
    }
    return Lr.chmod(r, e.mode);
  }
  i(qD, "copyFile");
  function PH(e) {
    return (e & 128) === 0;
  }
  i(PH, "fileIsNotWritable");
  function AH(e, t) {
    return Lr.chmod(e, t | 128);
  }
  i(AH, "makeFileWritable");
  async function CH(e, t, r, s, n) {
    t || await Lr.mkdir(s);
    let a = await Lr.readdir(r);
    await Promise.all(a.map(async (o) => {
      let l = wu.join(r, o), u = wu.join(s, o);
      if (!await $D(l, u, n)) return;
      let { destStat: f } = await Du.checkPaths(l, u, "copy", n);
      return UD(f, l, u, n);
    })), t || await Lr.chmod(s, e.mode);
  }
  i(CH, "onDir");
  async function wH(e, t, r, s) {
    let n = await Lr.readlink(t);
    if (s.dereference && (n = wu.resolve(process.cwd(), n)), !e)
      return Lr.symlink(n, r);
    let a = null;
    try {
      a = await Lr.readlink(r);
    } catch (o) {
      if (o.code === "EINVAL" || o.code === "UNKNOWN") return Lr.symlink(n, r);
      throw o;
    }
    if (s.dereference && (a = wu.resolve(process.cwd(), a)), Du.isSrcSubdir(n, a))
      throw new Error(`Cannot copy '${n}' to a subdirectory of itself, '${a}'.`);
    if (Du.isSrcSubdir(a, n))
      throw new Error(`Cannot overwrite '${a}' with '${n}'.`);
    return await Lr.unlink(r), Lr.symlink(n, r);
  }
  i(wH, "onLink");
  VD.exports = TH;
});

// ../node_modules/fs-extra/lib/copy/copy-sync.js
var XD = y(($We, YD) => {
  "use strict";
  var Zr = Uo(), Iu = require("path"), DH = nn().mkdirsSync, IH = _0().utimesMillisSync, _u = $a();
  function _H(e, t, r) {
    typeof r == "function" && (r = { filter: r }), r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ?
    !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0002"
    );
    let { srcStat: s, destStat: n } = _u.checkPathsSync(e, t, "copy", r);
    if (_u.checkParentPathsSync(e, s, t, "copy"), r.filter && !r.filter(e, t)) return;
    let a = Iu.dirname(t);
    return Zr.existsSync(a) || DH(a), HD(n, e, t, r);
  }
  i(_H, "copySync");
  function HD(e, t, r, s) {
    let a = (s.dereference ? Zr.statSync : Zr.lstatSync)(t);
    if (a.isDirectory()) return BH(a, e, t, r, s);
    if (a.isFile() || a.isCharacterDevice() || a.isBlockDevice()) return OH(a, e, t, r, s);
    if (a.isSymbolicLink()) return qH(e, t, r, s);
    throw a.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : a.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(
    `Unknown file: ${t}`);
  }
  i(HD, "getStats");
  function OH(e, t, r, s, n) {
    return t ? NH(e, r, s, n) : GD(e, r, s, n);
  }
  i(OH, "onFile");
  function NH(e, t, r, s) {
    if (s.overwrite)
      return Zr.unlinkSync(r), GD(e, t, r, s);
    if (s.errorOnExist)
      throw new Error(`'${r}' already exists`);
  }
  i(NH, "mayCopyFile");
  function GD(e, t, r, s) {
    return Zr.copyFileSync(t, r), s.preserveTimestamps && RH(e.mode, t, r), N0(r, e.mode);
  }
  i(GD, "copyFile");
  function RH(e, t, r) {
    return kH(e) && FH(r, e), LH(t, r);
  }
  i(RH, "handleTimestamps");
  function kH(e) {
    return (e & 128) === 0;
  }
  i(kH, "fileIsNotWritable");
  function FH(e, t) {
    return N0(e, t | 128);
  }
  i(FH, "makeFileWritable");
  function N0(e, t) {
    return Zr.chmodSync(e, t);
  }
  i(N0, "setDestMode");
  function LH(e, t) {
    let r = Zr.statSync(e);
    return IH(t, r.atime, r.mtime);
  }
  i(LH, "setDestTimestamps");
  function BH(e, t, r, s, n) {
    return t ? KD(r, s, n) : MH(e.mode, r, s, n);
  }
  i(BH, "onDir");
  function MH(e, t, r, s) {
    return Zr.mkdirSync(r), KD(t, r, s), N0(r, e);
  }
  i(MH, "mkDirAndCopy");
  function KD(e, t, r) {
    Zr.readdirSync(e).forEach((s) => jH(s, e, t, r));
  }
  i(KD, "copyDir");
  function jH(e, t, r, s) {
    let n = Iu.join(t, e), a = Iu.join(r, e);
    if (s.filter && !s.filter(n, a)) return;
    let { destStat: o } = _u.checkPathsSync(n, a, "copy", s);
    return HD(o, n, a, s);
  }
  i(jH, "copyDirItem");
  function qH(e, t, r, s) {
    let n = Zr.readlinkSync(t);
    if (s.dereference && (n = Iu.resolve(process.cwd(), n)), e) {
      let a;
      try {
        a = Zr.readlinkSync(r);
      } catch (o) {
        if (o.code === "EINVAL" || o.code === "UNKNOWN") return Zr.symlinkSync(n, r);
        throw o;
      }
      if (s.dereference && (a = Iu.resolve(process.cwd(), a)), _u.isSrcSubdir(n, a))
        throw new Error(`Cannot copy '${n}' to a subdirectory of itself, '${a}'.`);
      if (_u.isSrcSubdir(a, n))
        throw new Error(`Cannot overwrite '${a}' with '${n}'.`);
      return $H(n, r);
    } else
      return Zr.symlinkSync(n, r);
  }
  i(qH, "onLink");
  function $H(e, t) {
    return Zr.unlinkSync(t), Zr.symlinkSync(e, t);
  }
  i($H, "copyLink");
  YD.exports = _H;
});

// ../node_modules/fs-extra/lib/copy/index.js
var cp = y((VWe, zD) => {
  "use strict";
  var UH = xr().fromPromise;
  zD.exports = {
    copy: UH(WD()),
    copySync: XD()
  };
});

// ../node_modules/fs-extra/lib/remove/index.js
var Ou = y((WWe, QD) => {
  "use strict";
  var JD = Uo(), VH = xr().fromCallback;
  function WH(e, t) {
    JD.rm(e, { recursive: !0, force: !0 }, t);
  }
  i(WH, "remove");
  function HH(e) {
    JD.rmSync(e, { recursive: !0, force: !0 });
  }
  i(HH, "removeSync");
  QD.exports = {
    remove: VH(WH),
    removeSync: HH
  };
});

// ../node_modules/fs-extra/lib/empty/index.js
var a2 = y((GWe, i2) => {
  "use strict";
  var GH = xr().fromPromise, t2 = Qr(), r2 = require("path"), s2 = nn(), n2 = Ou(), ZD = GH(/* @__PURE__ */ i(async function(t) {
    let r;
    try {
      r = await t2.readdir(t);
    } catch {
      return s2.mkdirs(t);
    }
    return Promise.all(r.map((s) => n2.remove(r2.join(t, s))));
  }, "emptyDir"));
  function e2(e) {
    let t;
    try {
      t = t2.readdirSync(e);
    } catch {
      return s2.mkdirsSync(e);
    }
    t.forEach((r) => {
      r = r2.join(e, r), n2.removeSync(r);
    });
  }
  i(e2, "emptyDirSync");
  i2.exports = {
    emptyDirSync: e2,
    emptydirSync: e2,
    emptyDir: ZD,
    emptydir: ZD
  };
});

// ../node_modules/fs-extra/lib/ensure/file.js
var c2 = y((YWe, u2) => {
  "use strict";
  var KH = xr().fromPromise, o2 = require("path"), ri = Qr(), l2 = nn();
  async function YH(e) {
    let t;
    try {
      t = await ri.stat(e);
    } catch {
    }
    if (t && t.isFile()) return;
    let r = o2.dirname(e), s = null;
    try {
      s = await ri.stat(r);
    } catch (n) {
      if (n.code === "ENOENT") {
        await l2.mkdirs(r), await ri.writeFile(e, "");
        return;
      } else
        throw n;
    }
    s.isDirectory() ? await ri.writeFile(e, "") : await ri.readdir(r);
  }
  i(YH, "createFile");
  function XH(e) {
    let t;
    try {
      t = ri.statSync(e);
    } catch {
    }
    if (t && t.isFile()) return;
    let r = o2.dirname(e);
    try {
      ri.statSync(r).isDirectory() || ri.readdirSync(r);
    } catch (s) {
      if (s && s.code === "ENOENT") l2.mkdirsSync(r);
      else throw s;
    }
    ri.writeFileSync(e, "");
  }
  i(XH, "createFileSync");
  u2.exports = {
    createFile: KH(YH),
    createFileSync: XH
  };
});

// ../node_modules/fs-extra/lib/ensure/link.js
var m2 = y((zWe, h2) => {
  "use strict";
  var zH = xr().fromPromise, f2 = require("path"), Wi = Qr(), p2 = nn(), { pathExists: JH } = Vi(), { areIdentical: d2 } = $a();
  async function QH(e, t) {
    let r;
    try {
      r = await Wi.lstat(t);
    } catch {
    }
    let s;
    try {
      s = await Wi.lstat(e);
    } catch (o) {
      throw o.message = o.message.replace("lstat", "ensureLink"), o;
    }
    if (r && d2(s, r)) return;
    let n = f2.dirname(t);
    await JH(n) || await p2.mkdirs(n), await Wi.link(e, t);
  }
  i(QH, "createLink");
  function ZH(e, t) {
    let r;
    try {
      r = Wi.lstatSync(t);
    } catch {
    }
    try {
      let a = Wi.lstatSync(e);
      if (r && d2(a, r)) return;
    } catch (a) {
      throw a.message = a.message.replace("lstat", "ensureLink"), a;
    }
    let s = f2.dirname(t);
    return Wi.existsSync(s) || p2.mkdirsSync(s), Wi.linkSync(e, t);
  }
  i(ZH, "createLinkSync");
  h2.exports = {
    createLink: zH(QH),
    createLinkSync: ZH
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink-paths.js
var g2 = y((QWe, y2) => {
  "use strict";
  var Hi = require("path"), Nu = Qr(), { pathExists: eG } = Vi(), tG = xr().fromPromise;
  async function rG(e, t) {
    if (Hi.isAbsolute(e)) {
      try {
        await Nu.lstat(e);
      } catch (a) {
        throw a.message = a.message.replace("lstat", "ensureSymlink"), a;
      }
      return {
        toCwd: e,
        toDst: e
      };
    }
    let r = Hi.dirname(t), s = Hi.join(r, e);
    if (await eG(s))
      return {
        toCwd: s,
        toDst: e
      };
    try {
      await Nu.lstat(e);
    } catch (a) {
      throw a.message = a.message.replace("lstat", "ensureSymlink"), a;
    }
    return {
      toCwd: e,
      toDst: Hi.relative(r, e)
    };
  }
  i(rG, "symlinkPaths");
  function sG(e, t) {
    if (Hi.isAbsolute(e)) {
      if (!Nu.existsSync(e)) throw new Error("absolute srcpath does not exist");
      return {
        toCwd: e,
        toDst: e
      };
    }
    let r = Hi.dirname(t), s = Hi.join(r, e);
    if (Nu.existsSync(s))
      return {
        toCwd: s,
        toDst: e
      };
    if (!Nu.existsSync(e)) throw new Error("relative srcpath does not exist");
    return {
      toCwd: e,
      toDst: Hi.relative(r, e)
    };
  }
  i(sG, "symlinkPathsSync");
  y2.exports = {
    symlinkPaths: tG(rG),
    symlinkPathsSync: sG
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink-type.js
var v2 = y((eHe, E2) => {
  "use strict";
  var b2 = Qr(), nG = xr().fromPromise;
  async function iG(e, t) {
    if (t) return t;
    let r;
    try {
      r = await b2.lstat(e);
    } catch {
      return "file";
    }
    return r && r.isDirectory() ? "dir" : "file";
  }
  i(iG, "symlinkType");
  function aG(e, t) {
    if (t) return t;
    let r;
    try {
      r = b2.lstatSync(e);
    } catch {
      return "file";
    }
    return r && r.isDirectory() ? "dir" : "file";
  }
  i(aG, "symlinkTypeSync");
  E2.exports = {
    symlinkType: nG(iG),
    symlinkTypeSync: aG
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink.js
var P2 = y((rHe, x2) => {
  "use strict";
  var oG = xr().fromPromise, S2 = require("path"), In = Qr(), { mkdirs: lG, mkdirsSync: uG } = nn(), { symlinkPaths: cG, symlinkPathsSync: fG } = g2(),
  { symlinkType: pG, symlinkTypeSync: dG } = v2(), { pathExists: hG } = Vi(), { areIdentical: T2 } = $a();
  async function mG(e, t, r) {
    let s;
    try {
      s = await In.lstat(t);
    } catch {
    }
    if (s && s.isSymbolicLink()) {
      let [l, u] = await Promise.all([
        In.stat(e),
        In.stat(t)
      ]);
      if (T2(l, u)) return;
    }
    let n = await cG(e, t);
    e = n.toDst;
    let a = await pG(n.toCwd, r), o = S2.dirname(t);
    return await hG(o) || await lG(o), In.symlink(e, t, a);
  }
  i(mG, "createSymlink");
  function yG(e, t, r) {
    let s;
    try {
      s = In.lstatSync(t);
    } catch {
    }
    if (s && s.isSymbolicLink()) {
      let l = In.statSync(e), u = In.statSync(t);
      if (T2(l, u)) return;
    }
    let n = fG(e, t);
    e = n.toDst, r = dG(n.toCwd, r);
    let a = S2.dirname(t);
    return In.existsSync(a) || uG(a), In.symlinkSync(e, t, r);
  }
  i(yG, "createSymlinkSync");
  x2.exports = {
    createSymlink: oG(mG),
    createSymlinkSync: yG
  };
});

// ../node_modules/fs-extra/lib/ensure/index.js
var N2 = y((nHe, O2) => {
  "use strict";
  var { createFile: A2, createFileSync: C2 } = c2(), { createLink: w2, createLinkSync: D2 } = m2(), { createSymlink: I2, createSymlinkSync: _2 } = P2();
  O2.exports = {
    // file
    createFile: A2,
    createFileSync: C2,
    ensureFile: A2,
    ensureFileSync: C2,
    // link
    createLink: w2,
    createLinkSync: D2,
    ensureLink: w2,
    ensureLinkSync: D2,
    // symlink
    createSymlink: I2,
    createSymlinkSync: _2,
    ensureSymlink: I2,
    ensureSymlinkSync: _2
  };
});

// ../node_modules/jsonfile/utils.js
var fp = y((iHe, R2) => {
  function gG(e, { EOL: t = `
`, finalEOL: r = !0, replacer: s = null, spaces: n } = {}) {
    let a = r ? t : "";
    return JSON.stringify(e, s, n).replace(/\n/g, t) + a;
  }
  i(gG, "stringify");
  function bG(e) {
    return Buffer.isBuffer(e) && (e = e.toString("utf8")), e.replace(/^\uFEFF/, "");
  }
  i(bG, "stripBom");
  R2.exports = { stringify: gG, stripBom: bG };
});

// ../node_modules/jsonfile/index.js
var B2 = y((oHe, L2) => {
  var Ho;
  try {
    Ho = Uo();
  } catch {
    Ho = require("fs");
  }
  var pp = xr(), { stringify: k2, stripBom: F2 } = fp();
  async function EG(e, t = {}) {
    typeof t == "string" && (t = { encoding: t });
    let r = t.fs || Ho, s = "throws" in t ? t.throws : !0, n = await pp.fromCallback(r.readFile)(e, t);
    n = F2(n);
    let a;
    try {
      a = JSON.parse(n, t ? t.reviver : null);
    } catch (o) {
      if (s)
        throw o.message = `${e}: ${o.message}`, o;
      return null;
    }
    return a;
  }
  i(EG, "_readFile");
  var vG = pp.fromPromise(EG);
  function SG(e, t = {}) {
    typeof t == "string" && (t = { encoding: t });
    let r = t.fs || Ho, s = "throws" in t ? t.throws : !0;
    try {
      let n = r.readFileSync(e, t);
      return n = F2(n), JSON.parse(n, t.reviver);
    } catch (n) {
      if (s)
        throw n.message = `${e}: ${n.message}`, n;
      return null;
    }
  }
  i(SG, "readFileSync");
  async function TG(e, t, r = {}) {
    let s = r.fs || Ho, n = k2(t, r);
    await pp.fromCallback(s.writeFile)(e, n, r);
  }
  i(TG, "_writeFile");
  var xG = pp.fromPromise(TG);
  function PG(e, t, r = {}) {
    let s = r.fs || Ho, n = k2(t, r);
    return s.writeFileSync(e, n, r);
  }
  i(PG, "writeFileSync");
  var AG = {
    readFile: vG,
    readFileSync: SG,
    writeFile: xG,
    writeFileSync: PG
  };
  L2.exports = AG;
});

// ../node_modules/fs-extra/lib/json/jsonfile.js
var j2 = y((uHe, M2) => {
  "use strict";
  var dp = B2();
  M2.exports = {
    // jsonfile exports
    readJson: dp.readFile,
    readJsonSync: dp.readFileSync,
    writeJson: dp.writeFile,
    writeJsonSync: dp.writeFileSync
  };
});

// ../node_modules/fs-extra/lib/output-file/index.js
var hp = y((cHe, U2) => {
  "use strict";
  var CG = xr().fromPromise, R0 = Qr(), q2 = require("path"), $2 = nn(), wG = Vi().pathExists;
  async function DG(e, t, r = "utf-8") {
    let s = q2.dirname(e);
    return await wG(s) || await $2.mkdirs(s), R0.writeFile(e, t, r);
  }
  i(DG, "outputFile");
  function IG(e, ...t) {
    let r = q2.dirname(e);
    R0.existsSync(r) || $2.mkdirsSync(r), R0.writeFileSync(e, ...t);
  }
  i(IG, "outputFileSync");
  U2.exports = {
    outputFile: CG(DG),
    outputFileSync: IG
  };
});

// ../node_modules/fs-extra/lib/json/output-json.js
var W2 = y((pHe, V2) => {
  "use strict";
  var { stringify: _G } = fp(), { outputFile: OG } = hp();
  async function NG(e, t, r = {}) {
    let s = _G(t, r);
    await OG(e, s, r);
  }
  i(NG, "outputJson");
  V2.exports = NG;
});

// ../node_modules/fs-extra/lib/json/output-json-sync.js
var G2 = y((hHe, H2) => {
  "use strict";
  var { stringify: RG } = fp(), { outputFileSync: kG } = hp();
  function FG(e, t, r) {
    let s = RG(t, r);
    kG(e, s, r);
  }
  i(FG, "outputJsonSync");
  H2.exports = FG;
});

// ../node_modules/fs-extra/lib/json/index.js
var Y2 = y((yHe, K2) => {
  "use strict";
  var LG = xr().fromPromise, es = j2();
  es.outputJson = LG(W2());
  es.outputJsonSync = G2();
  es.outputJSON = es.outputJson;
  es.outputJSONSync = es.outputJsonSync;
  es.writeJSON = es.writeJson;
  es.writeJSONSync = es.writeJsonSync;
  es.readJSON = es.readJson;
  es.readJSONSync = es.readJsonSync;
  K2.exports = es;
});

// ../node_modules/fs-extra/lib/move/move.js
var Z2 = y((gHe, Q2) => {
  "use strict";
  var BG = Qr(), X2 = require("path"), { copy: MG } = cp(), { remove: J2 } = Ou(), { mkdirp: jG } = nn(), { pathExists: qG } = Vi(), z2 = $a();
  async function $G(e, t, r = {}) {
    let s = r.overwrite || r.clobber || !1, { srcStat: n, isChangingCase: a = !1 } = await z2.checkPaths(e, t, "move", r);
    await z2.checkParentPaths(e, n, t, "move");
    let o = X2.dirname(t);
    return X2.parse(o).root !== o && await jG(o), UG(e, t, s, a);
  }
  i($G, "move");
  async function UG(e, t, r, s) {
    if (!s) {
      if (r)
        await J2(t);
      else if (await qG(t))
        throw new Error("dest already exists.");
    }
    try {
      await BG.rename(e, t);
    } catch (n) {
      if (n.code !== "EXDEV")
        throw n;
      await VG(e, t, r);
    }
  }
  i(UG, "doRename");
  async function VG(e, t, r) {
    return await MG(e, t, {
      overwrite: r,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), J2(e);
  }
  i(VG, "moveAcrossDevice");
  Q2.exports = $G;
});

// ../node_modules/fs-extra/lib/move/move-sync.js
var nI = y((EHe, sI) => {
  "use strict";
  var tI = Uo(), F0 = require("path"), WG = cp().copySync, rI = Ou().removeSync, HG = nn().mkdirpSync, eI = $a();
  function GG(e, t, r) {
    r = r || {};
    let s = r.overwrite || r.clobber || !1, { srcStat: n, isChangingCase: a = !1 } = eI.checkPathsSync(e, t, "move", r);
    return eI.checkParentPathsSync(e, n, t, "move"), KG(t) || HG(F0.dirname(t)), YG(e, t, s, a);
  }
  i(GG, "moveSync");
  function KG(e) {
    let t = F0.dirname(e);
    return F0.parse(t).root === t;
  }
  i(KG, "isParentRoot");
  function YG(e, t, r, s) {
    if (s) return k0(e, t, r);
    if (r)
      return rI(t), k0(e, t, r);
    if (tI.existsSync(t)) throw new Error("dest already exists.");
    return k0(e, t, r);
  }
  i(YG, "doRename");
  function k0(e, t, r) {
    try {
      tI.renameSync(e, t);
    } catch (s) {
      if (s.code !== "EXDEV") throw s;
      return XG(e, t, r);
    }
  }
  i(k0, "rename");
  function XG(e, t, r) {
    return WG(e, t, {
      overwrite: r,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), rI(e);
  }
  i(XG, "moveAcrossDevice");
  sI.exports = GG;
});

// ../node_modules/fs-extra/lib/move/index.js
var aI = y((SHe, iI) => {
  "use strict";
  var zG = xr().fromPromise;
  iI.exports = {
    move: zG(Z2()),
    moveSync: nI()
  };
});

// ../node_modules/fs-extra/lib/index.js
var mp = y((THe, oI) => {
  "use strict";
  oI.exports = {
    // Export promiseified graceful-fs:
    ...Qr(),
    // Export extra methods:
    ...cp(),
    ...a2(),
    ...N2(),
    ...Y2(),
    ...nn(),
    ...aI(),
    ...hp(),
    ...Vi(),
    ...Ou()
  };
});

// ../node_modules/ts-dedent/dist/index.js
var Go = y((Ru) => {
  "use strict";
  Object.defineProperty(Ru, "__esModule", { value: !0 });
  Ru.dedent = void 0;
  function lI(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    var s = Array.from(typeof e == "string" ? [e] : e);
    s[s.length - 1] = s[s.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var n = s.reduce(function(l, u) {
      var c = u.match(/\n([\t ]+|(?!\s).)/g);
      return c ? l.concat(c.map(function(f) {
        var p, d;
        return (d = (p = f.match(/[\t ]/g)) === null || p === void 0 ? void 0 : p.length) !== null && d !== void 0 ? d : 0;
      })) : l;
    }, []);
    if (n.length) {
      var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, n) + "}", "g");
      s = s.map(function(l) {
        return l.replace(a, `
`);
      });
    }
    s[0] = s[0].replace(/^\r?\n/, "");
    var o = s[0];
    return t.forEach(function(l, u) {
      var c = o.match(/(?:^|\n)( *)$/), f = c ? c[1] : "", p = l;
      typeof l == "string" && l.includes(`
`) && (p = String(l).split(`
`).map(function(d, m) {
        return m === 0 ? d : "" + f + d;
      }).join(`
`)), o += p + s[u + 1];
    }), o;
  }
  i(lI, "dedent");
  Ru.dedent = lI;
  Ru.default = lI;
});

// ../node_modules/prompts/node_modules/kleur/index.js
var rr = y((HHe, CI) => {
  "use strict";
  var { FORCE_COLOR: mK, NODE_DISABLE_COLORS: yK, TERM: gK } = process.env, Ft = {
    enabled: !yK && gK !== "dumb" && mK !== "0",
    // modifiers
    reset: $t(0, 0),
    bold: $t(1, 22),
    dim: $t(2, 22),
    italic: $t(3, 23),
    underline: $t(4, 24),
    inverse: $t(7, 27),
    hidden: $t(8, 28),
    strikethrough: $t(9, 29),
    // colors
    black: $t(30, 39),
    red: $t(31, 39),
    green: $t(32, 39),
    yellow: $t(33, 39),
    blue: $t(34, 39),
    magenta: $t(35, 39),
    cyan: $t(36, 39),
    white: $t(37, 39),
    gray: $t(90, 39),
    grey: $t(90, 39),
    // background colors
    bgBlack: $t(40, 49),
    bgRed: $t(41, 49),
    bgGreen: $t(42, 49),
    bgYellow: $t(43, 49),
    bgBlue: $t(44, 49),
    bgMagenta: $t(45, 49),
    bgCyan: $t(46, 49),
    bgWhite: $t(47, 49)
  };
  function AI(e, t) {
    let r = 0, s, n = "", a = "";
    for (; r < e.length; r++)
      s = e[r], n += s.open, a += s.close, t.includes(s.close) && (t = t.replace(s.rgx, s.close + s.open));
    return n + t + a;
  }
  i(AI, "run");
  function bK(e, t) {
    let r = { has: e, keys: t };
    return r.reset = Ft.reset.bind(r), r.bold = Ft.bold.bind(r), r.dim = Ft.dim.bind(r), r.italic = Ft.italic.bind(r), r.underline = Ft.underline.
    bind(r), r.inverse = Ft.inverse.bind(r), r.hidden = Ft.hidden.bind(r), r.strikethrough = Ft.strikethrough.bind(r), r.black = Ft.black.bind(
    r), r.red = Ft.red.bind(r), r.green = Ft.green.bind(r), r.yellow = Ft.yellow.bind(r), r.blue = Ft.blue.bind(r), r.magenta = Ft.magenta.bind(
    r), r.cyan = Ft.cyan.bind(r), r.white = Ft.white.bind(r), r.gray = Ft.gray.bind(r), r.grey = Ft.grey.bind(r), r.bgBlack = Ft.bgBlack.bind(
    r), r.bgRed = Ft.bgRed.bind(r), r.bgGreen = Ft.bgGreen.bind(r), r.bgYellow = Ft.bgYellow.bind(r), r.bgBlue = Ft.bgBlue.bind(r), r.bgMagenta =
    Ft.bgMagenta.bind(r), r.bgCyan = Ft.bgCyan.bind(r), r.bgWhite = Ft.bgWhite.bind(r), r;
  }
  i(bK, "chain");
  function $t(e, t) {
    let r = {
      open: `\x1B[${e}m`,
      close: `\x1B[${t}m`,
      rgx: new RegExp(`\\x1b\\[${t}m`, "g")
    };
    return function(s) {
      return this !== void 0 && this.has !== void 0 ? (this.has.includes(e) || (this.has.push(e), this.keys.push(r)), s === void 0 ? this : Ft.
      enabled ? AI(this.keys, s + "") : s + "") : s === void 0 ? bK([e], [r]) : Ft.enabled ? AI([r], s + "") : s + "";
    };
  }
  i($t, "init");
  CI.exports = Ft;
});

// ../node_modules/prompts/dist/util/action.js
var DI = y((KHe, wI) => {
  "use strict";
  wI.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/dist/util/strip.js
var vp = y((YHe, II) => {
  "use strict";
  II.exports = (e) => {
    let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/sisteransi/src/index.js
var nr = y((XHe, _I) => {
  "use strict";
  var U0 = "\x1B", sr = `${U0}[`, EK = "\x07", V0 = {
    to(e, t) {
      return t ? `${sr}${t + 1};${e + 1}H` : `${sr}${e + 1}G`;
    },
    move(e, t) {
      let r = "";
      return e < 0 ? r += `${sr}${-e}D` : e > 0 && (r += `${sr}${e}C`), t < 0 ? r += `${sr}${-t}A` : t > 0 && (r += `${sr}${t}B`), r;
    },
    up: /* @__PURE__ */ i((e = 1) => `${sr}${e}A`, "up"),
    down: /* @__PURE__ */ i((e = 1) => `${sr}${e}B`, "down"),
    forward: /* @__PURE__ */ i((e = 1) => `${sr}${e}C`, "forward"),
    backward: /* @__PURE__ */ i((e = 1) => `${sr}${e}D`, "backward"),
    nextLine: /* @__PURE__ */ i((e = 1) => `${sr}E`.repeat(e), "nextLine"),
    prevLine: /* @__PURE__ */ i((e = 1) => `${sr}F`.repeat(e), "prevLine"),
    left: `${sr}G`,
    hide: `${sr}?25l`,
    show: `${sr}?25h`,
    save: `${U0}7`,
    restore: `${U0}8`
  }, vK = {
    up: /* @__PURE__ */ i((e = 1) => `${sr}S`.repeat(e), "up"),
    down: /* @__PURE__ */ i((e = 1) => `${sr}T`.repeat(e), "down")
  }, SK = {
    screen: `${sr}2J`,
    up: /* @__PURE__ */ i((e = 1) => `${sr}1J`.repeat(e), "up"),
    down: /* @__PURE__ */ i((e = 1) => `${sr}J`.repeat(e), "down"),
    line: `${sr}2K`,
    lineEnd: `${sr}K`,
    lineStart: `${sr}1K`,
    lines(e) {
      let t = "";
      for (let r = 0; r < e; r++)
        t += this.line + (r < e - 1 ? V0.up() : "");
      return e && (t += V0.left), t;
    }
  };
  _I.exports = { cursor: V0, scroll: vK, erase: SK, beep: EK };
});

// ../node_modules/prompts/dist/util/clear.js
var FI = y((JHe, kI) => {
  "use strict";
  function TK(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = xK(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var s = 0, n = /* @__PURE__ */ i(function() {
        }, "F");
        return { s: n, n: /* @__PURE__ */ i(function() {
          return s >= e.length ? { done: !0 } : { done: !1, value: e[s++] };
        }, "n"), e: /* @__PURE__ */ i(function(c) {
          throw c;
        }, "e"), f: n };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var a = !0, o = !1, l;
    return { s: /* @__PURE__ */ i(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ i(function() {
      var c = r.next();
      return a = c.done, c;
    }, "n"), e: /* @__PURE__ */ i(function(c) {
      o = !0, l = c;
    }, "e"), f: /* @__PURE__ */ i(function() {
      try {
        !a && r.return != null && r.return();
      } finally {
        if (o) throw l;
      }
    }, "f") };
  }
  i(TK, "_createForOfIteratorHelper");
  function xK(e, t) {
    if (e) {
      if (typeof e == "string") return OI(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return OI(e, t);
    }
  }
  i(xK, "_unsupportedIterableToArray");
  function OI(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, s = new Array(t); r < t; r++) s[r] = e[r];
    return s;
  }
  i(OI, "_arrayLikeToArray");
  var PK = vp(), RI = nr(), NI = RI.erase, AK = RI.cursor, CK = /* @__PURE__ */ i((e) => [...PK(e)].length, "width");
  kI.exports = function(e, t) {
    if (!t) return NI.line + AK.to(0);
    let r = 0, s = e.split(/\r?\n/);
    var n = TK(s), a;
    try {
      for (n.s(); !(a = n.n()).done; ) {
        let o = a.value;
        r += 1 + Math.floor(Math.max(CK(o) - 1, 0) / t);
      }
    } catch (o) {
      n.e(o);
    } finally {
      n.f();
    }
    return NI.lines(r);
  };
});

// ../node_modules/prompts/dist/util/figures.js
var W0 = y((ZHe, LI) => {
  "use strict";
  var Lu = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, wK = {
    arrowUp: Lu.arrowUp,
    arrowDown: Lu.arrowDown,
    arrowLeft: Lu.arrowLeft,
    arrowRight: Lu.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, DK = process.platform === "win32" ? wK : Lu;
  LI.exports = DK;
});

// ../node_modules/prompts/dist/util/style.js
var MI = y((eGe, BI) => {
  "use strict";
  var Xo = rr(), Ua = W0(), H0 = Object.freeze({
    password: {
      scale: 1,
      render: /* @__PURE__ */ i((e) => "*".repeat(e.length), "render")
    },
    emoji: {
      scale: 2,
      render: /* @__PURE__ */ i((e) => "\u{1F603}".repeat(e.length), "render")
    },
    invisible: {
      scale: 0,
      render: /* @__PURE__ */ i((e) => "", "render")
    },
    default: {
      scale: 1,
      render: /* @__PURE__ */ i((e) => `${e}`, "render")
    }
  }), IK = /* @__PURE__ */ i((e) => H0[e] || H0.default, "render"), Bu = Object.freeze({
    aborted: Xo.red(Ua.cross),
    done: Xo.green(Ua.tick),
    exited: Xo.yellow(Ua.cross),
    default: Xo.cyan("?")
  }), _K = /* @__PURE__ */ i((e, t, r) => t ? Bu.aborted : r ? Bu.exited : e ? Bu.done : Bu.default, "symbol"), OK = /* @__PURE__ */ i((e) => Xo.
  gray(e ? Ua.ellipsis : Ua.pointerSmall), "delimiter"), NK = /* @__PURE__ */ i((e, t) => Xo.gray(e ? t ? Ua.pointerSmall : "+" : Ua.line), "\
item");
  BI.exports = {
    styles: H0,
    render: IK,
    symbols: Bu,
    symbol: _K,
    delimiter: OK,
    item: NK
  };
});

// ../node_modules/prompts/dist/util/lines.js
var qI = y((rGe, jI) => {
  "use strict";
  var RK = vp();
  jI.exports = function(e, t) {
    let r = String(RK(e) || "").split(/\r?\n/);
    return t ? r.map((s) => Math.ceil(s.length / t)).reduce((s, n) => s + n) : r.length;
  };
});

// ../node_modules/prompts/dist/util/wrap.js
var UI = y((sGe, $I) => {
  "use strict";
  $I.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", s = t.width;
    return (e || "").split(/\r?\n/g).map((n) => n.split(/\s+/g).reduce((a, o) => (o.length + r.length >= s || a[a.length - 1].length + o.length +
    1 < s ? a[a.length - 1] += ` ${o}` : a.push(`${r}${o}`), a), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/dist/util/entriesToDisplay.js
var WI = y((nGe, VI) => {
  "use strict";
  VI.exports = (e, t, r) => {
    r = r || t;
    let s = Math.min(t - r, e - Math.floor(r / 2));
    s < 0 && (s = 0);
    let n = Math.min(s + r, t);
    return {
      startIndex: s,
      endIndex: n
    };
  };
});

// ../node_modules/prompts/dist/util/index.js
var on = y((iGe, HI) => {
  "use strict";
  HI.exports = {
    action: DI(),
    clear: FI(),
    style: MI(),
    strip: vp(),
    figures: W0(),
    lines: qI(),
    wrap: UI(),
    entriesToDisplay: WI()
  };
});

// ../node_modules/prompts/dist/elements/prompt.js
var si = y((aGe, YI) => {
  "use strict";
  var GI = require("readline"), kK = on(), FK = kK.action, LK = require("events"), KI = nr(), BK = KI.beep, MK = KI.cursor, jK = rr(), G0 = class extends LK {
    static {
      i(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = GI.createInterface({
        input: this.in,
        escapeCodeTimeout: 50
      });
      GI.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let s = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, n = /* @__PURE__ */ i((a, o) => {
        let l = FK(o, s);
        l === !1 ? this._ && this._(a, o) : typeof this[l] == "function" ? this[l](o) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(MK.show), this.in.removeListener("keypress", n), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", n);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(BK);
    }
    render() {
      this.onRender(jK), this.firstRender && (this.firstRender = !1);
    }
  };
  YI.exports = G0;
});

// ../node_modules/prompts/dist/elements/text.js
var ZI = y((lGe, QI) => {
  "use strict";
  function XI(e, t, r, s, n, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      r(c);
      return;
    }
    l.done ? t(u) : Promise.resolve(u).then(s, n);
  }
  i(XI, "asyncGeneratorStep");
  function zI(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(s, n) {
        var a = e.apply(t, r);
        function o(u) {
          XI(a, s, n, o, l, "next", u);
        }
        i(o, "_next");
        function l(u) {
          XI(a, s, n, o, l, "throw", u);
        }
        i(l, "_throw"), o(void 0);
      });
    };
  }
  i(zI, "_asyncToGenerator");
  var Sp = rr(), qK = si(), JI = nr(), $K = JI.erase, Mu = JI.cursor, Tp = on(), K0 = Tp.style, Y0 = Tp.clear, UK = Tp.lines, VK = Tp.figures,
  X0 = class extends qK {
    static {
      i(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = K0.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = Y0("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = Sp.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return zI(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return zI(function* () {
        if (t.value = t.value || t.initial, t.cursorOffset = 0, t.cursor = t.rendered.length, yield t.validate(), t.error) {
          t.red = !0, t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let s = this.value.slice(0, this.cursor), n = this.value.slice(this.cursor);
      this.value = `${s}${t}${n}`, this.red = !1, this.cursor = this.placeholder ? 0 : s.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Mu.down(UK(this.outputError, this.out.columns) - 1) + Y0(this.
      outputError, this.out.columns)), this.out.write(Y0(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [K0.symbol(this.done, this.aborted), Sp.bold(this.msg), K0.delimiter(this.done), this.red ? Sp.red(this.rendered) : this.rendered].join(
      " "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, s) => t + `
${s ? " " : VK.pointerSmall} ${Sp.red().italic(r)}`, "")), this.out.write($K.line + Mu.to(0) + this.outputText + Mu.save + this.outputError +
      Mu.restore + Mu.move(this.cursorOffset, 0)));
    }
  };
  QI.exports = X0;
});

// ../node_modules/prompts/dist/elements/select.js
var s_ = y((cGe, r_) => {
  "use strict";
  var ni = rr(), WK = si(), ju = on(), e_ = ju.style, t_ = ju.clear, xp = ju.figures, HK = ju.wrap, GK = ju.entriesToDisplay, KK = nr(), YK = KK.
  cursor, z0 = class extends WK {
    static {
      i(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, s) => (typeof r == "string" && (r = {
        title: r,
        value: s
      }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? s : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = t_("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(YK.hide) : this.out.write(t_(this.outputText, this.out.columns)), super.render();
      let t = GK(this.cursor, this.choices.length, this.optionsPerPage), r = t.startIndex, s = t.endIndex;
      if (this.outputText = [e_.symbol(this.done, this.aborted), ni.bold(this.msg), e_.delimiter(!1), this.done ? this.selection.title : this.
      selection.disabled ? ni.yellow(this.warn) : ni.gray(this.hint)].join(" "), !this.done) {
        this.outputText += `
`;
        for (let n = r; n < s; n++) {
          let a, o, l = "", u = this.choices[n];
          n === r && r > 0 ? o = xp.arrowUp : n === s - 1 && s < this.choices.length ? o = xp.arrowDown : o = " ", u.disabled ? (a = this.cursor ===
          n ? ni.gray().underline(u.title) : ni.strikethrough().gray(u.title), o = (this.cursor === n ? ni.bold().gray(xp.pointer) + " " : "\
  ") + o) : (a = this.cursor === n ? ni.cyan().underline(u.title) : u.title, o = (this.cursor === n ? ni.cyan(xp.pointer) + " " : "  ") + o,
          u.description && this.cursor === n && (l = ` - ${u.description}`, (o.length + a.length + l.length >= this.out.columns || u.description.
          split(/\r?\n/).length > 1) && (l = `
` + HK(u.description, {
            margin: 3,
            width: this.out.columns
          })))), this.outputText += `${o} ${a}${ni.gray(l)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  r_.exports = z0;
});

// ../node_modules/prompts/dist/elements/toggle.js
var u_ = y((pGe, l_) => {
  "use strict";
  var Pp = rr(), XK = si(), a_ = on(), n_ = a_.style, zK = a_.clear, o_ = nr(), i_ = o_.cursor, JK = o_.erase, J0 = class extends XK {
    static {
      i(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(i_.hide) : this.out.write(zK(this.outputText, this.out.columns)), super.render(), this.
      outputText = [n_.symbol(this.done, this.aborted), Pp.bold(this.msg), n_.delimiter(this.done), this.value ? this.inactive : Pp.cyan().underline(
      this.inactive), Pp.gray("/"), this.value ? Pp.cyan().underline(this.active) : this.active].join(" "), this.out.write(JK.line + i_.to(0) +
      this.outputText));
    }
  };
  l_.exports = J0;
});

// ../node_modules/prompts/dist/dateparts/datepart.js
var _n = y((hGe, c_) => {
  "use strict";
  var Q0 = class e {
    static {
      i(this, "DatePart");
    }
    constructor({
      token: t,
      date: r,
      parts: s,
      locales: n
    }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = s || [this], this.locales = n || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, s) => s > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((s, n) => n > r && s instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  c_.exports = Q0;
});

// ../node_modules/prompts/dist/dateparts/meridiem.js
var p_ = y((yGe, f_) => {
  "use strict";
  var QK = _n(), Z0 = class extends QK {
    static {
      i(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  f_.exports = Z0;
});

// ../node_modules/prompts/dist/dateparts/day.js
var h_ = y((bGe, d_) => {
  "use strict";
  var ZK = _n(), eY = /* @__PURE__ */ i((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), eg = class extends ZK {
    static {
      i(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + eY(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  d_.exports = eg;
});

// ../node_modules/prompts/dist/dateparts/hours.js
var y_ = y((vGe, m_) => {
  "use strict";
  var tY = _n(), tg = class extends tY {
    static {
      i(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  m_.exports = tg;
});

// ../node_modules/prompts/dist/dateparts/milliseconds.js
var b_ = y((TGe, g_) => {
  "use strict";
  var rY = _n(), rg = class extends rY {
    static {
      i(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  g_.exports = rg;
});

// ../node_modules/prompts/dist/dateparts/minutes.js
var v_ = y((PGe, E_) => {
  "use strict";
  var sY = _n(), sg = class extends sY {
    static {
      i(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  E_.exports = sg;
});

// ../node_modules/prompts/dist/dateparts/month.js
var T_ = y((CGe, S_) => {
  "use strict";
  var nY = _n(), ng = class extends nY {
    static {
      i(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  S_.exports = ng;
});

// ../node_modules/prompts/dist/dateparts/seconds.js
var P_ = y((DGe, x_) => {
  "use strict";
  var iY = _n(), ig = class extends iY {
    static {
      i(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  x_.exports = ig;
});

// ../node_modules/prompts/dist/dateparts/year.js
var C_ = y((_Ge, A_) => {
  "use strict";
  var aY = _n(), ag = class extends aY {
    static {
      i(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  A_.exports = ag;
});

// ../node_modules/prompts/dist/dateparts/index.js
var D_ = y((NGe, w_) => {
  "use strict";
  w_.exports = {
    DatePart: _n(),
    Meridiem: p_(),
    Day: h_(),
    Hours: y_(),
    Milliseconds: b_(),
    Minutes: v_(),
    Month: T_(),
    Seconds: P_(),
    Year: C_()
  };
});

// ../node_modules/prompts/dist/elements/date.js
var M_ = y((RGe, B_) => {
  "use strict";
  function I_(e, t, r, s, n, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      r(c);
      return;
    }
    l.done ? t(u) : Promise.resolve(u).then(s, n);
  }
  i(I_, "asyncGeneratorStep");
  function __(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(s, n) {
        var a = e.apply(t, r);
        function o(u) {
          I_(a, s, n, o, l, "next", u);
        }
        i(o, "_next");
        function l(u) {
          I_(a, s, n, o, l, "throw", u);
        }
        i(l, "_throw"), o(void 0);
      });
    };
  }
  i(__, "_asyncToGenerator");
  var og = rr(), oY = si(), ug = on(), O_ = ug.style, N_ = ug.clear, lY = ug.figures, L_ = nr(), uY = L_.erase, R_ = L_.cursor, ii = D_(), k_ = ii.
  DatePart, cY = ii.Meridiem, fY = ii.Day, pY = ii.Hours, dY = ii.Milliseconds, hY = ii.Minutes, mY = ii.Month, yY = ii.Seconds, gY = ii.Year,
  bY = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g, F_ = {
    1: ({
      token: e
    }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new fY(e),
    // Day // TODO
    3: (e) => new mY(e),
    // Month
    4: (e) => new gY(e),
    // Year
    5: (e) => new cY(e),
    // AM/PM // TODO (special)
    6: (e) => new pY(e),
    // Hours
    7: (e) => new hY(e),
    // Minutes
    8: (e) => new yY(e),
    // Seconds
    9: (e) => new dY(e)
    // Fractional seconds
  }, EY = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, lg = class extends oY {
    static {
      i(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(EY, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = N_("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = bY.exec(t); ) {
        let n = r.shift(), a = r.findIndex((o) => o != null);
        this.parts.push(a in F_ ? F_[a]({
          token: r[a] || n,
          date: this.date,
          parts: this.parts,
          locales: this.locales
        }) : r[a] || n);
      }
      let s = this.parts.reduce((n, a) => (typeof a == "string" && typeof n[n.length - 1] == "string" ? n[n.length - 1] += a : n.push(a), n),
      []);
      this.parts.splice(0), this.parts.push(...s), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof k_)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return __(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return __(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof k_)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(R_.hide) : this.out.write(N_(this.outputText, this.out.columns)), super.render(), this.
      outputText = [O_.symbol(this.done, this.aborted), og.bold(this.msg), O_.delimiter(!1), this.parts.reduce((t, r, s) => t.concat(s === this.
      cursor && !this.done ? og.cyan().underline(r.toString()) : r), []).join("")].join(" "), this.error && (this.outputText += this.errorMsg.
      split(`
`).reduce((t, r, s) => t + `
${s ? " " : lY.pointerSmall} ${og.red().italic(r)}`, "")), this.out.write(uY.line + R_.to(0) + this.outputText));
    }
  };
  B_.exports = lg;
});

// ../node_modules/prompts/dist/elements/number.js
var H_ = y((FGe, W_) => {
  "use strict";
  function j_(e, t, r, s, n, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      r(c);
      return;
    }
    l.done ? t(u) : Promise.resolve(u).then(s, n);
  }
  i(j_, "asyncGeneratorStep");
  function q_(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(s, n) {
        var a = e.apply(t, r);
        function o(u) {
          j_(a, s, n, o, l, "next", u);
        }
        i(o, "_next");
        function l(u) {
          j_(a, s, n, o, l, "throw", u);
        }
        i(l, "_throw"), o(void 0);
      });
    };
  }
  i(q_, "_asyncToGenerator");
  var Ap = rr(), vY = si(), V_ = nr(), Cp = V_.cursor, SY = V_.erase, wp = on(), cg = wp.style, TY = wp.figures, $_ = wp.clear, xY = wp.lines,
  PY = /[0-9]/, fg = /* @__PURE__ */ i((e) => e !== void 0, "isDef"), U_ = /* @__PURE__ */ i((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), pg = class extends vY {
    static {
      i(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = cg.render(t.style), this.msg = t.message, this.initial = fg(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = fg(t.min) ? t.min : -1 / 0, this.max = fg(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = Ap.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${U_(t, this.round)}`), this._value = U_(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || PY.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    validate() {
      var t = this;
      return q_(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return q_(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        let r = t.value;
        t.value = r !== "" ? r : t.initial, t.done = !0, t.aborted = !1, t.error = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let s = Date.now();
      if (s - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = s, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Cp.down(xY(this.outputError, this.out.columns) - 1) + $_(this.
      outputError, this.out.columns)), this.out.write($_(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [cg.symbol(this.done, this.aborted), Ap.bold(this.msg), cg.delimiter(this.done), !this.done || !this.done && !this.placeholder ? Ap[this.
      color]().underline(this.rendered) : this.rendered].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, s) => t + `
${s ? " " : TY.pointerSmall} ${Ap.red().italic(r)}`, "")), this.out.write(SY.line + Cp.to(0) + this.outputText + Cp.save + this.outputError +
      Cp.restore));
    }
  };
  W_.exports = pg;
});

// ../node_modules/prompts/dist/elements/multiselect.js
var hg = y((BGe, Y_) => {
  "use strict";
  var On = rr(), AY = nr(), CY = AY.cursor, wY = si(), qu = on(), G_ = qu.clear, Ki = qu.figures, K_ = qu.style, DY = qu.wrap, IY = qu.entriesToDisplay,
  dg = class extends wY {
    static {
      i(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, s) => (typeof r == "string" && (r = {
        title: r,
        value: s
      }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? s : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = G_("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Ki.arrowUp}/${Ki.arrowDown}: Highlight option
    ${Ki.arrowLeft}/${Ki.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, s, n) {
      let a = (r.selected ? On.green(Ki.radioOn) : Ki.radioOff) + " " + n + " ", o, l;
      return r.disabled ? o = t === s ? On.gray().underline(r.title) : On.strikethrough().gray(r.title) : (o = t === s ? On.cyan().underline(
      r.title) : r.title, t === s && r.description && (l = ` - ${r.description}`, (a.length + o.length + l.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (l = `
` + DY(r.description, {
        margin: a.length,
        width: this.out.columns
      })))), a + o + On.gray(l || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return On.red("No matches for this query.");
      let r = IY(this.cursor, t.length, this.optionsPerPage), s = r.startIndex, n = r.endIndex, a, o = [];
      for (let l = s; l < n; l++)
        l === s && s > 0 ? a = Ki.arrowUp : l === n - 1 && n < t.length ? a = Ki.arrowDown : a = " ", o.push(this.renderOption(this.cursor, t[l],
        l, a));
      return `
` + o.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [On.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(On.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(CY.hide), super.render();
      let t = [K_.symbol(this.done, this.aborted), On.bold(this.msg), K_.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += On.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = G_(t, this.out.columns);
    }
  };
  Y_.exports = dg;
});

// ../node_modules/prompts/dist/elements/autocomplete.js
var tO = y((jGe, eO) => {
  "use strict";
  function X_(e, t, r, s, n, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      r(c);
      return;
    }
    l.done ? t(u) : Promise.resolve(u).then(s, n);
  }
  i(X_, "asyncGeneratorStep");
  function _Y(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(s, n) {
        var a = e.apply(t, r);
        function o(u) {
          X_(a, s, n, o, l, "next", u);
        }
        i(o, "_next");
        function l(u) {
          X_(a, s, n, o, l, "throw", u);
        }
        i(l, "_throw"), o(void 0);
      });
    };
  }
  i(_Y, "_asyncToGenerator");
  var $u = rr(), OY = si(), Z_ = nr(), NY = Z_.erase, z_ = Z_.cursor, Uu = on(), mg = Uu.style, J_ = Uu.clear, yg = Uu.figures, RY = Uu.wrap,
  kY = Uu.entriesToDisplay, Q_ = /* @__PURE__ */ i((e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), FY = /* @__PURE__ */ i((e, t) => e[t] &&
  (e[t].title || e[t].value || e[t]), "getTitle"), LY = /* @__PURE__ */ i((e, t) => {
    let r = e.findIndex((s) => s.value === t || s.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), gg = class extends OY {
    static {
      i(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      LY(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = {
        noMatches: t.noMatches || "no matches found"
      }, this.fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit =
      t.limit || 10, this.cursor = 0, this.transform = mg.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(
      this), this.complete = this.complete.bind(this), this.clear = J_("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = {
        title: this._fb
      }), t || this._fb || {
        title: this.i18n.noMatches
      };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = Q_(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    complete(t) {
      var r = this;
      return _Y(function* () {
        let s = r.completing = r.suggest(r.input, r.choices), n = yield s;
        if (r.completing !== s) return;
        r.suggestions = n.map((o, l, u) => ({
          title: FY(u, l),
          value: Q_(u, l),
          description: o.description
        })), r.completing = !1;
        let a = Math.max(n.length - 1, 0);
        r.moveSelect(Math.min(a, r.select)), t && t();
      })();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let s = this.input.slice(0, this.cursor), n = this.input.slice(this.cursor);
      this.input = `${s}${t}${n}`, this.cursor = s.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, s, n) {
      let a, o = s ? yg.arrowUp : n ? yg.arrowDown : " ", l = r ? $u.cyan().underline(t.title) : t.title;
      return o = (r ? $u.cyan(yg.pointer) + " " : "  ") + o, t.description && (a = ` - ${t.description}`, (o.length + l.length + a.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (a = `
` + RY(t.description, {
        margin: 3,
        width: this.out.columns
      }))), o + " " + l + $u.gray(a || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(z_.hide) : this.out.write(J_(this.outputText, this.out.columns)), super.render();
      let t = kY(this.select, this.choices.length, this.limit), r = t.startIndex, s = t.endIndex;
      if (this.outputText = [mg.symbol(this.done, this.aborted, this.exited), $u.bold(this.msg), mg.delimiter(this.completing), this.done &&
      this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" "), !this.
      done) {
        let n = this.suggestions.slice(r, s).map((a, o) => this.renderOption(a, this.select === o + r, o === 0 && r > 0, o + r === s - 1 && s <
        this.choices.length)).join(`
`);
        this.outputText += `
` + (n || $u.gray(this.fallback.title));
      }
      this.out.write(NY.line + z_.to(0) + this.outputText);
    }
  };
  eO.exports = gg;
});

// ../node_modules/prompts/dist/elements/autocompleteMultiselect.js
var iO = y(($Ge, nO) => {
  "use strict";
  var ai = rr(), BY = nr(), MY = BY.cursor, jY = hg(), Eg = on(), rO = Eg.clear, sO = Eg.style, zo = Eg.figures, bg = class extends jY {
    static {
      i(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = rO("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((s) => this.inputValue ? !!(typeof s.title == "string" && s.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof s.value == "string" && s.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((s) => s === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${zo.arrowUp}/${zo.arrowDown}: Highlight option
    ${zo.arrowLeft}/${zo.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : ai.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, s) {
      let n;
      return r.disabled ? n = t === s ? ai.gray().underline(r.title) : ai.strikethrough().gray(r.title) : n = t === s ? ai.cyan().underline(
      r.title) : r.title, (r.selected ? ai.green(zo.radioOn) : zo.radioOff) + "  " + n;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [ai.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(ai.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(MY.hide), super.render();
      let t = [sO.symbol(this.done, this.aborted), ai.bold(this.msg), sO.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += ai.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = rO(t, this.out.columns);
    }
  };
  nO.exports = bg;
});

// ../node_modules/prompts/dist/elements/confirm.js
var pO = y((VGe, fO) => {
  "use strict";
  var aO = rr(), qY = si(), uO = on(), oO = uO.style, $Y = uO.clear, cO = nr(), UY = cO.erase, lO = cO.cursor, vg = class extends qY {
    static {
      i(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(lO.hide) : this.out.write($Y(this.outputText, this.out.columns)), super.render(), this.
      outputText = [oO.symbol(this.done, this.aborted), aO.bold(this.msg), oO.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.
      noMsg : aO.gray(this.initialValue ? this.yesOption : this.noOption)].join(" "), this.out.write(UY.line + lO.to(0) + this.outputText));
    }
  };
  fO.exports = vg;
});

// ../node_modules/prompts/dist/elements/index.js
var hO = y((HGe, dO) => {
  "use strict";
  dO.exports = {
    TextPrompt: ZI(),
    SelectPrompt: s_(),
    TogglePrompt: u_(),
    DatePrompt: M_(),
    NumberPrompt: H_(),
    MultiselectPrompt: hg(),
    AutocompletePrompt: tO(),
    AutocompleteMultiselectPrompt: iO(),
    ConfirmPrompt: pO()
  };
});

// ../node_modules/prompts/dist/prompts.js
var yO = y((mO) => {
  "use strict";
  var hs = mO, VY = hO(), Dp = /* @__PURE__ */ i((e) => e, "noop");
  function Nn(e, t, r = {}) {
    return new Promise((s, n) => {
      let a = new VY[e](t), o = r.onAbort || Dp, l = r.onSubmit || Dp, u = r.onExit || Dp;
      a.on("state", t.onState || Dp), a.on("submit", (c) => s(l(c))), a.on("exit", (c) => s(u(c))), a.on("abort", (c) => n(o(c)));
    });
  }
  i(Nn, "toPrompt");
  hs.text = (e) => Nn("TextPrompt", e);
  hs.password = (e) => (e.style = "password", hs.text(e));
  hs.invisible = (e) => (e.style = "invisible", hs.text(e));
  hs.number = (e) => Nn("NumberPrompt", e);
  hs.date = (e) => Nn("DatePrompt", e);
  hs.confirm = (e) => Nn("ConfirmPrompt", e);
  hs.list = (e) => {
    let t = e.separator || ",";
    return Nn("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ i((r) => r.split(t).map((s) => s.trim()), "onSubmit")
    });
  };
  hs.toggle = (e) => Nn("TogglePrompt", e);
  hs.select = (e) => Nn("SelectPrompt", e);
  hs.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ i((r) => r.filter((s) => s.selected).map((s) => s.value), "toSelected");
    return Nn("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  hs.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ i((r) => r.filter((s) => s.selected).map((s) => s.value), "toSelected");
    return Nn("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var WY = /* @__PURE__ */ i((e, t) => Promise.resolve(t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())), "byTi\
tle");
  hs.autocomplete = (e) => (e.suggest = e.suggest || WY, e.choices = [].concat(e.choices || []), Nn("AutocompletePrompt", e));
});

// ../node_modules/prompts/dist/index.js
var PO = y((YGe, xO) => {
  "use strict";
  function gO(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      t && (s = s.filter(function(n) {
        return Object.getOwnPropertyDescriptor(e, n).enumerable;
      })), r.push.apply(r, s);
    }
    return r;
  }
  i(gO, "ownKeys");
  function bO(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? gO(Object(r), !0).forEach(function(s) {
        HY(e, s, r[s]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : gO(Object(r)).forEach(function(s) {
        Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(r, s));
      });
    }
    return e;
  }
  i(bO, "_objectSpread");
  function HY(e, t, r) {
    return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  i(HY, "_defineProperty");
  function GY(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = KY(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var s = 0, n = /* @__PURE__ */ i(function() {
        }, "F");
        return { s: n, n: /* @__PURE__ */ i(function() {
          return s >= e.length ? { done: !0 } : { done: !1, value: e[s++] };
        }, "n"), e: /* @__PURE__ */ i(function(c) {
          throw c;
        }, "e"), f: n };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var a = !0, o = !1, l;
    return { s: /* @__PURE__ */ i(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ i(function() {
      var c = r.next();
      return a = c.done, c;
    }, "n"), e: /* @__PURE__ */ i(function(c) {
      o = !0, l = c;
    }, "e"), f: /* @__PURE__ */ i(function() {
      try {
        !a && r.return != null && r.return();
      } finally {
        if (o) throw l;
      }
    }, "f") };
  }
  i(GY, "_createForOfIteratorHelper");
  function KY(e, t) {
    if (e) {
      if (typeof e == "string") return EO(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return EO(e, t);
    }
  }
  i(KY, "_unsupportedIterableToArray");
  function EO(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, s = new Array(t); r < t; r++) s[r] = e[r];
    return s;
  }
  i(EO, "_arrayLikeToArray");
  function vO(e, t, r, s, n, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      r(c);
      return;
    }
    l.done ? t(u) : Promise.resolve(u).then(s, n);
  }
  i(vO, "asyncGeneratorStep");
  function SO(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(s, n) {
        var a = e.apply(t, r);
        function o(u) {
          vO(a, s, n, o, l, "next", u);
        }
        i(o, "_next");
        function l(u) {
          vO(a, s, n, o, l, "throw", u);
        }
        i(l, "_throw"), o(void 0);
      });
    };
  }
  i(SO, "_asyncToGenerator");
  var Sg = yO(), YY = ["suggest", "format", "onState", "validate", "onRender", "type"], TO = /* @__PURE__ */ i(() => {
  }, "noop");
  function Yi() {
    return Tg.apply(this, arguments);
  }
  i(Yi, "prompt");
  function Tg() {
    return Tg = SO(function* (e = [], {
      onSubmit: t = TO,
      onCancel: r = TO
    } = {}) {
      let s = {}, n = Yi._override || {};
      e = [].concat(e);
      let a, o, l, u, c, f, p = /* @__PURE__ */ function() {
        var g = SO(function* (E, D, C = !1) {
          if (!(!C && E.validate && E.validate(D) !== !0))
            return E.format ? yield E.format(D, s) : D;
        });
        return /* @__PURE__ */ i(function(D, C) {
          return g.apply(this, arguments);
        }, "getFormattedAnswer");
      }();
      var d = GY(e), m;
      try {
        for (d.s(); !(m = d.n()).done; ) {
          o = m.value;
          var b = o;
          if (u = b.name, c = b.type, typeof c == "function" && (c = yield c(a, bO({}, s), o), o.type = c), !!c) {
            for (let g in o) {
              if (YY.includes(g)) continue;
              let E = o[g];
              o[g] = typeof E == "function" ? yield E(a, bO({}, s), f) : E;
            }
            if (f = o, typeof o.message != "string")
              throw new Error("prompt message is required");
            var h = o;
            if (u = h.name, c = h.type, Sg[c] === void 0)
              throw new Error(`prompt type (${c}) is not defined`);
            if (n[o.name] !== void 0 && (a = yield p(o, n[o.name]), a !== void 0)) {
              s[u] = a;
              continue;
            }
            try {
              a = Yi._injected ? XY(Yi._injected, o.initial) : yield Sg[c](o), s[u] = a = yield p(o, a, !0), l = yield t(o, a, s);
            } catch {
              l = !(yield r(o, s));
            }
            if (l) return s;
          }
        }
      } catch (g) {
        d.e(g);
      } finally {
        d.f();
      }
      return s;
    }), Tg.apply(this, arguments);
  }
  i(Tg, "_prompt");
  function XY(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  i(XY, "getInjectedAnswer");
  function zY(e) {
    Yi._injected = (Yi._injected || []).concat(e);
  }
  i(zY, "inject");
  function JY(e) {
    Yi._override = Object.assign({}, e);
  }
  i(JY, "override");
  xO.exports = Object.assign(Yi, {
    prompt: Yi,
    prompts: Sg,
    inject: zY,
    override: JY
  });
});

// ../node_modules/prompts/lib/util/action.js
var CO = y((zGe, AO) => {
  "use strict";
  AO.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/lib/util/strip.js
var Ip = y((JGe, wO) => {
  "use strict";
  wO.exports = (e) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/prompts/lib/util/clear.js
var _O = y((QGe, IO) => {
  "use strict";
  var QY = Ip(), { erase: DO, cursor: ZY } = nr(), eX = /* @__PURE__ */ i((e) => [...QY(e)].length, "width");
  IO.exports = function(e, t) {
    if (!t) return DO.line + ZY.to(0);
    let r = 0, s = e.split(/\r?\n/);
    for (let n of s)
      r += 1 + Math.floor(Math.max(eX(n) - 1, 0) / t);
    return DO.lines(r);
  };
});

// ../node_modules/prompts/lib/util/figures.js
var xg = y((eKe, OO) => {
  "use strict";
  var Vu = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, tX = {
    arrowUp: Vu.arrowUp,
    arrowDown: Vu.arrowDown,
    arrowLeft: Vu.arrowLeft,
    arrowRight: Vu.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, rX = process.platform === "win32" ? tX : Vu;
  OO.exports = rX;
});

// ../node_modules/prompts/lib/util/style.js
var RO = y((tKe, NO) => {
  "use strict";
  var Jo = rr(), Va = xg(), Pg = Object.freeze({
    password: { scale: 1, render: /* @__PURE__ */ i((e) => "*".repeat(e.length), "render") },
    emoji: { scale: 2, render: /* @__PURE__ */ i((e) => "\u{1F603}".repeat(e.length), "render") },
    invisible: { scale: 0, render: /* @__PURE__ */ i((e) => "", "render") },
    default: { scale: 1, render: /* @__PURE__ */ i((e) => `${e}`, "render") }
  }), sX = /* @__PURE__ */ i((e) => Pg[e] || Pg.default, "render"), Wu = Object.freeze({
    aborted: Jo.red(Va.cross),
    done: Jo.green(Va.tick),
    exited: Jo.yellow(Va.cross),
    default: Jo.cyan("?")
  }), nX = /* @__PURE__ */ i((e, t, r) => t ? Wu.aborted : r ? Wu.exited : e ? Wu.done : Wu.default, "symbol"), iX = /* @__PURE__ */ i((e) => Jo.
  gray(e ? Va.ellipsis : Va.pointerSmall), "delimiter"), aX = /* @__PURE__ */ i((e, t) => Jo.gray(e ? t ? Va.pointerSmall : "+" : Va.line), "\
item");
  NO.exports = {
    styles: Pg,
    render: sX,
    symbols: Wu,
    symbol: nX,
    delimiter: iX,
    item: aX
  };
});

// ../node_modules/prompts/lib/util/lines.js
var FO = y((sKe, kO) => {
  "use strict";
  var oX = Ip();
  kO.exports = function(e, t) {
    let r = String(oX(e) || "").split(/\r?\n/);
    return t ? r.map((s) => Math.ceil(s.length / t)).reduce((s, n) => s + n) : r.length;
  };
});

// ../node_modules/prompts/lib/util/wrap.js
var BO = y((nKe, LO) => {
  "use strict";
  LO.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", s = t.width;
    return (e || "").split(/\r?\n/g).map((n) => n.split(/\s+/g).reduce((a, o) => (o.length + r.length >= s || a[a.length - 1].length + o.length +
    1 < s ? a[a.length - 1] += ` ${o}` : a.push(`${r}${o}`), a), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/lib/util/entriesToDisplay.js
var jO = y((iKe, MO) => {
  "use strict";
  MO.exports = (e, t, r) => {
    r = r || t;
    let s = Math.min(t - r, e - Math.floor(r / 2));
    s < 0 && (s = 0);
    let n = Math.min(s + r, t);
    return { startIndex: s, endIndex: n };
  };
});

// ../node_modules/prompts/lib/util/index.js
var ln = y((aKe, qO) => {
  "use strict";
  qO.exports = {
    action: CO(),
    clear: _O(),
    style: RO(),
    strip: Ip(),
    figures: xg(),
    lines: FO(),
    wrap: BO(),
    entriesToDisplay: jO()
  };
});

// ../node_modules/prompts/lib/elements/prompt.js
var oi = y((oKe, UO) => {
  "use strict";
  var $O = require("readline"), { action: lX } = ln(), uX = require("events"), { beep: cX, cursor: fX } = nr(), pX = rr(), Ag = class extends uX {
    static {
      i(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = $O.createInterface({ input: this.in, escapeCodeTimeout: 50 });
      $O.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let s = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, n = /* @__PURE__ */ i((a, o) => {
        let l = lX(o, s);
        l === !1 ? this._ && this._(a, o) : typeof this[l] == "function" ? this[l](o) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(fX.show), this.in.removeListener("keypress", n), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", n);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(cX);
    }
    render() {
      this.onRender(pX), this.firstRender && (this.firstRender = !1);
    }
  };
  UO.exports = Ag;
});

// ../node_modules/prompts/lib/elements/text.js
var WO = y((uKe, VO) => {
  var _p = rr(), dX = oi(), { erase: hX, cursor: Hu } = nr(), { style: Cg, clear: wg, lines: mX, figures: yX } = ln(), Dg = class extends dX {
    static {
      i(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = Cg.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = wg("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = _p.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (this.value = this.value || this.initial, this.cursorOffset = 0, this.cursor = this.rendered.length, await this.validate(), this.error) {
        this.red = !0, this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let s = this.value.slice(0, this.cursor), n = this.value.slice(this.cursor);
      this.value = `${s}${t}${n}`, this.red = !1, this.cursor = this.placeholder ? 0 : s.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Hu.down(mX(this.outputError, this.out.columns) - 1) + wg(this.
      outputError, this.out.columns)), this.out.write(wg(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        Cg.symbol(this.done, this.aborted),
        _p.bold(this.msg),
        Cg.delimiter(this.done),
        this.red ? _p.red(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, s) => t + `
${s ? " " : yX.pointerSmall} ${_p.red().italic(r)}`, "")), this.out.write(hX.line + Hu.to(0) + this.outputText + Hu.save + this.outputError +
      Hu.restore + Hu.move(this.cursorOffset, 0)));
    }
  };
  VO.exports = Dg;
});

// ../node_modules/prompts/lib/elements/select.js
var YO = y((fKe, KO) => {
  "use strict";
  var li = rr(), gX = oi(), { style: HO, clear: GO, figures: Op, wrap: bX, entriesToDisplay: EX } = ln(), { cursor: vX } = nr(), Ig = class extends gX {
    static {
      i(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, s) => (typeof r == "string" && (r = { title: r, value: s }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? s : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = GO("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(vX.hide) : this.out.write(GO(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = EX(this.cursor, this.choices.length, this.optionsPerPage);
      if (this.outputText = [
        HO.symbol(this.done, this.aborted),
        li.bold(this.msg),
        HO.delimiter(!1),
        this.done ? this.selection.title : this.selection.disabled ? li.yellow(this.warn) : li.gray(this.hint)
      ].join(" "), !this.done) {
        this.outputText += `
`;
        for (let s = t; s < r; s++) {
          let n, a, o = "", l = this.choices[s];
          s === t && t > 0 ? a = Op.arrowUp : s === r - 1 && r < this.choices.length ? a = Op.arrowDown : a = " ", l.disabled ? (n = this.cursor ===
          s ? li.gray().underline(l.title) : li.strikethrough().gray(l.title), a = (this.cursor === s ? li.bold().gray(Op.pointer) + " " : "\
  ") + a) : (n = this.cursor === s ? li.cyan().underline(l.title) : l.title, a = (this.cursor === s ? li.cyan(Op.pointer) + " " : "  ") + a,
          l.description && this.cursor === s && (o = ` - ${l.description}`, (a.length + n.length + o.length >= this.out.columns || l.description.
          split(/\r?\n/).length > 1) && (o = `
` + bX(l.description, { margin: 3, width: this.out.columns })))), this.outputText += `${a} ${n}${li.gray(o)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  KO.exports = Ig;
});

// ../node_modules/prompts/lib/elements/toggle.js
var QO = y((dKe, JO) => {
  var Np = rr(), SX = oi(), { style: XO, clear: TX } = ln(), { cursor: zO, erase: xX } = nr(), _g = class extends SX {
    static {
      i(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(zO.hide) : this.out.write(TX(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        XO.symbol(this.done, this.aborted),
        Np.bold(this.msg),
        XO.delimiter(this.done),
        this.value ? this.inactive : Np.cyan().underline(this.inactive),
        Np.gray("/"),
        this.value ? Np.cyan().underline(this.active) : this.active
      ].join(" "), this.out.write(xX.line + zO.to(0) + this.outputText));
    }
  };
  JO.exports = _g;
});

// ../node_modules/prompts/lib/dateparts/datepart.js
var Rn = y((mKe, ZO) => {
  "use strict";
  var Og = class e {
    static {
      i(this, "DatePart");
    }
    constructor({ token: t, date: r, parts: s, locales: n }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = s || [this], this.locales = n || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, s) => s > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((s, n) => n > r && s instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  ZO.exports = Og;
});

// ../node_modules/prompts/lib/dateparts/meridiem.js
var tN = y((gKe, eN) => {
  "use strict";
  var PX = Rn(), Ng = class extends PX {
    static {
      i(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  eN.exports = Ng;
});

// ../node_modules/prompts/lib/dateparts/day.js
var sN = y((EKe, rN) => {
  "use strict";
  var AX = Rn(), CX = /* @__PURE__ */ i((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), Rg = class extends AX {
    static {
      i(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + CX(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  rN.exports = Rg;
});

// ../node_modules/prompts/lib/dateparts/hours.js
var iN = y((SKe, nN) => {
  "use strict";
  var wX = Rn(), kg = class extends wX {
    static {
      i(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  nN.exports = kg;
});

// ../node_modules/prompts/lib/dateparts/milliseconds.js
var oN = y((xKe, aN) => {
  "use strict";
  var DX = Rn(), Fg = class extends DX {
    static {
      i(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  aN.exports = Fg;
});

// ../node_modules/prompts/lib/dateparts/minutes.js
var uN = y((AKe, lN) => {
  "use strict";
  var IX = Rn(), Lg = class extends IX {
    static {
      i(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  lN.exports = Lg;
});

// ../node_modules/prompts/lib/dateparts/month.js
var fN = y((wKe, cN) => {
  "use strict";
  var _X = Rn(), Bg = class extends _X {
    static {
      i(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  cN.exports = Bg;
});

// ../node_modules/prompts/lib/dateparts/seconds.js
var dN = y((IKe, pN) => {
  "use strict";
  var OX = Rn(), Mg = class extends OX {
    static {
      i(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  pN.exports = Mg;
});

// ../node_modules/prompts/lib/dateparts/year.js
var mN = y((OKe, hN) => {
  "use strict";
  var NX = Rn(), jg = class extends NX {
    static {
      i(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  hN.exports = jg;
});

// ../node_modules/prompts/lib/dateparts/index.js
var gN = y((RKe, yN) => {
  "use strict";
  yN.exports = {
    DatePart: Rn(),
    Meridiem: tN(),
    Day: sN(),
    Hours: iN(),
    Milliseconds: oN(),
    Minutes: uN(),
    Month: fN(),
    Seconds: dN(),
    Year: mN()
  };
});

// ../node_modules/prompts/lib/elements/date.js
var PN = y((kKe, xN) => {
  "use strict";
  var qg = rr(), RX = oi(), { style: bN, clear: EN, figures: kX } = ln(), { erase: FX, cursor: vN } = nr(), { DatePart: SN, Meridiem: LX, Day: BX,
  Hours: MX, Milliseconds: jX, Minutes: qX, Month: $X, Seconds: UX, Year: VX } = gN(), WX = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g,
  TN = {
    1: ({ token: e }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new BX(e),
    // Day // TODO
    3: (e) => new $X(e),
    // Month
    4: (e) => new VX(e),
    // Year
    5: (e) => new LX(e),
    // AM/PM // TODO (special)
    6: (e) => new MX(e),
    // Hours
    7: (e) => new qX(e),
    // Minutes
    8: (e) => new UX(e),
    // Seconds
    9: (e) => new jX(e)
    // Fractional seconds
  }, HX = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, $g = class extends RX {
    static {
      i(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(HX, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = EN("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = WX.exec(t); ) {
        let n = r.shift(), a = r.findIndex((o) => o != null);
        this.parts.push(a in TN ? TN[a]({ token: r[a] || n, date: this.date, parts: this.parts, locales: this.locales }) : r[a] || n);
      }
      let s = this.parts.reduce((n, a) => (typeof a == "string" && typeof n[n.length - 1] == "string" ? n[n.length - 1] += a : n.push(a), n),
      []);
      this.parts.splice(0), this.parts.push(...s), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof SN)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof SN)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(vN.hide) : this.out.write(EN(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        bN.symbol(this.done, this.aborted),
        qg.bold(this.msg),
        bN.delimiter(!1),
        this.parts.reduce((t, r, s) => t.concat(s === this.cursor && !this.done ? qg.cyan().underline(r.toString()) : r), []).join("")
      ].join(" "), this.error && (this.outputText += this.errorMsg.split(`
`).reduce(
        (t, r, s) => t + `
${s ? " " : kX.pointerSmall} ${qg.red().italic(r)}`,
        ""
      )), this.out.write(FX.line + vN.to(0) + this.outputText));
    }
  };
  xN.exports = $g;
});

// ../node_modules/prompts/lib/elements/number.js
var DN = y((LKe, wN) => {
  var Rp = rr(), GX = oi(), { cursor: kp, erase: KX } = nr(), { style: Ug, figures: YX, clear: AN, lines: XX } = ln(), zX = /[0-9]/, Vg = /* @__PURE__ */ i(
  (e) => e !== void 0, "isDef"), CN = /* @__PURE__ */ i((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), Wg = class extends GX {
    static {
      i(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = Ug.render(t.style), this.msg = t.message, this.initial = Vg(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = Vg(t.min) ? t.min : -1 / 0, this.max = Vg(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = Rp.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${CN(t, this.round)}`), this._value = CN(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || zX.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = !0, this.aborted = !1, this.error = !1, this.fire(), this.render(), this.out.write(
      `
`), this.close();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let s = Date.now();
      if (s - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = s, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(kp.down(XX(this.outputError, this.out.columns) - 1) + AN(this.
      outputError, this.out.columns)), this.out.write(AN(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        Ug.symbol(this.done, this.aborted),
        Rp.bold(this.msg),
        Ug.delimiter(this.done),
        !this.done || !this.done && !this.placeholder ? Rp[this.color]().underline(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, s) => t + `
${s ? " " : YX.pointerSmall} ${Rp.red().italic(r)}`, "")), this.out.write(KX.line + kp.to(0) + this.outputText + kp.save + this.outputError +
      kp.restore));
    }
  };
  wN.exports = Wg;
});

// ../node_modules/prompts/lib/elements/multiselect.js
var Gg = y((MKe, ON) => {
  "use strict";
  var kn = rr(), { cursor: JX } = nr(), QX = oi(), { clear: IN, figures: Xi, style: _N, wrap: ZX, entriesToDisplay: ez } = ln(), Hg = class extends QX {
    static {
      i(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, s) => (typeof r == "string" && (r = { title: r,
      value: s }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? s : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = IN("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Xi.arrowUp}/${Xi.arrowDown}: Highlight option
    ${Xi.arrowLeft}/${Xi.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, s, n) {
      let a = (r.selected ? kn.green(Xi.radioOn) : Xi.radioOff) + " " + n + " ", o, l;
      return r.disabled ? o = t === s ? kn.gray().underline(r.title) : kn.strikethrough().gray(r.title) : (o = t === s ? kn.cyan().underline(
      r.title) : r.title, t === s && r.description && (l = ` - ${r.description}`, (a.length + o.length + l.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (l = `
` + ZX(r.description, { margin: a.length, width: this.out.columns })))), a + o + kn.gray(l || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return kn.red("No matches for this query.");
      let { startIndex: r, endIndex: s } = ez(this.cursor, t.length, this.optionsPerPage), n, a = [];
      for (let o = r; o < s; o++)
        o === r && r > 0 ? n = Xi.arrowUp : o === s - 1 && s < t.length ? n = Xi.arrowDown : n = " ", a.push(this.renderOption(this.cursor, t[o],
        o, n));
      return `
` + a.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [kn.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(kn.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(JX.hide), super.render();
      let t = [
        _N.symbol(this.done, this.aborted),
        kn.bold(this.msg),
        _N.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += kn.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = IN(t, this.out.columns);
    }
  };
  ON.exports = Hg;
});

// ../node_modules/prompts/lib/elements/autocomplete.js
var LN = y((qKe, FN) => {
  "use strict";
  var Gu = rr(), tz = oi(), { erase: rz, cursor: NN } = nr(), { style: Kg, clear: RN, figures: Yg, wrap: sz, entriesToDisplay: nz } = ln(), kN = /* @__PURE__ */ i(
  (e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), iz = /* @__PURE__ */ i((e, t) => e[t] && (e[t].title || e[t].value || e[t]),
  "getTitle"), az = /* @__PURE__ */ i((e, t) => {
    let r = e.findIndex((s) => s.value === t || s.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), Xg = class extends tz {
    static {
      i(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      az(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = { noMatches: t.noMatches || "no matches found" }, this.
      fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit = t.limit ||
      10, this.cursor = 0, this.transform = Kg.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(this), this.
      complete = this.complete.bind(this), this.clear = RN("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = { title: this._fb }), t || this.
      _fb || { title: this.i18n.noMatches };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = kN(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    async complete(t) {
      let r = this.completing = this.suggest(this.input, this.choices), s = await r;
      if (this.completing !== r) return;
      this.suggestions = s.map((a, o, l) => ({ title: iz(l, o), value: kN(l, o), description: a.description })), this.completing = !1;
      let n = Math.max(s.length - 1, 0);
      this.moveSelect(Math.min(n, this.select)), t && t();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let s = this.input.slice(0, this.cursor), n = this.input.slice(this.cursor);
      this.input = `${s}${t}${n}`, this.cursor = s.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, s, n) {
      let a, o = s ? Yg.arrowUp : n ? Yg.arrowDown : " ", l = r ? Gu.cyan().underline(t.title) : t.title;
      return o = (r ? Gu.cyan(Yg.pointer) + " " : "  ") + o, t.description && (a = ` - ${t.description}`, (o.length + l.length + a.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (a = `
` + sz(t.description, { margin: 3, width: this.out.columns }))), o + " " + l + Gu.gray(a || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(NN.hide) : this.out.write(RN(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = nz(this.select, this.choices.length, this.limit);
      if (this.outputText = [
        Kg.symbol(this.done, this.aborted, this.exited),
        Gu.bold(this.msg),
        Kg.delimiter(this.completing),
        this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
      ].join(" "), !this.done) {
        let s = this.suggestions.slice(t, r).map((n, a) => this.renderOption(
          n,
          this.select === a + t,
          a === 0 && t > 0,
          a + t === r - 1 && r < this.choices.length
        )).join(`
`);
        this.outputText += `
` + (s || Gu.gray(this.fallback.title));
      }
      this.out.write(rz.line + NN.to(0) + this.outputText);
    }
  };
  FN.exports = Xg;
});

// ../node_modules/prompts/lib/elements/autocompleteMultiselect.js
var qN = y((UKe, jN) => {
  "use strict";
  var ui = rr(), { cursor: oz } = nr(), lz = Gg(), { clear: BN, style: MN, figures: Qo } = ln(), zg = class extends lz {
    static {
      i(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = BN("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((s) => this.inputValue ? !!(typeof s.title == "string" && s.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof s.value == "string" && s.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((s) => s === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Qo.arrowUp}/${Qo.arrowDown}: Highlight option
    ${Qo.arrowLeft}/${Qo.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : ui.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, s) {
      let n;
      return r.disabled ? n = t === s ? ui.gray().underline(r.title) : ui.strikethrough().gray(r.title) : n = t === s ? ui.cyan().underline(
      r.title) : r.title, (r.selected ? ui.green(Qo.radioOn) : Qo.radioOff) + "  " + n;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [ui.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(ui.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(oz.hide), super.render();
      let t = [
        MN.symbol(this.done, this.aborted),
        ui.bold(this.msg),
        MN.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += ui.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = BN(t, this.out.columns);
    }
  };
  jN.exports = zg;
});

// ../node_modules/prompts/lib/elements/confirm.js
var HN = y((WKe, WN) => {
  var $N = rr(), uz = oi(), { style: UN, clear: cz } = ln(), { erase: fz, cursor: VN } = nr(), Jg = class extends uz {
    static {
      i(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(VN.hide) : this.out.write(cz(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        UN.symbol(this.done, this.aborted),
        $N.bold(this.msg),
        UN.delimiter(this.done),
        this.done ? this.value ? this.yesMsg : this.noMsg : $N.gray(this.initialValue ? this.yesOption : this.noOption)
      ].join(" "), this.out.write(fz.line + VN.to(0) + this.outputText));
    }
  };
  WN.exports = Jg;
});

// ../node_modules/prompts/lib/elements/index.js
var KN = y((GKe, GN) => {
  "use strict";
  GN.exports = {
    TextPrompt: WO(),
    SelectPrompt: YO(),
    TogglePrompt: QO(),
    DatePrompt: PN(),
    NumberPrompt: DN(),
    MultiselectPrompt: Gg(),
    AutocompletePrompt: LN(),
    AutocompleteMultiselectPrompt: qN(),
    ConfirmPrompt: HN()
  };
});

// ../node_modules/prompts/lib/prompts.js
var XN = y((YN) => {
  "use strict";
  var ms = YN, pz = KN(), Fp = /* @__PURE__ */ i((e) => e, "noop");
  function Fn(e, t, r = {}) {
    return new Promise((s, n) => {
      let a = new pz[e](t), o = r.onAbort || Fp, l = r.onSubmit || Fp, u = r.onExit || Fp;
      a.on("state", t.onState || Fp), a.on("submit", (c) => s(l(c))), a.on("exit", (c) => s(u(c))), a.on("abort", (c) => n(o(c)));
    });
  }
  i(Fn, "toPrompt");
  ms.text = (e) => Fn("TextPrompt", e);
  ms.password = (e) => (e.style = "password", ms.text(e));
  ms.invisible = (e) => (e.style = "invisible", ms.text(e));
  ms.number = (e) => Fn("NumberPrompt", e);
  ms.date = (e) => Fn("DatePrompt", e);
  ms.confirm = (e) => Fn("ConfirmPrompt", e);
  ms.list = (e) => {
    let t = e.separator || ",";
    return Fn("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ i((r) => r.split(t).map((s) => s.trim()), "onSubmit")
    });
  };
  ms.toggle = (e) => Fn("TogglePrompt", e);
  ms.select = (e) => Fn("SelectPrompt", e);
  ms.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ i((r) => r.filter((s) => s.selected).map((s) => s.value), "toSelected");
    return Fn("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  ms.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ i((r) => r.filter((s) => s.selected).map((s) => s.value), "toSelected");
    return Fn("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var dz = /* @__PURE__ */ i((e, t) => Promise.resolve(
    t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())
  ), "byTitle");
  ms.autocomplete = (e) => (e.suggest = e.suggest || dz, e.choices = [].concat(e.choices || []), Fn("AutocompletePrompt", e));
});

// ../node_modules/prompts/lib/index.js
var QN = y((XKe, JN) => {
  "use strict";
  var Qg = XN(), hz = ["suggest", "format", "onState", "validate", "onRender", "type"], zN = /* @__PURE__ */ i(() => {
  }, "noop");
  async function zi(e = [], { onSubmit: t = zN, onCancel: r = zN } = {}) {
    let s = {}, n = zi._override || {};
    e = [].concat(e);
    let a, o, l, u, c, f, p = /* @__PURE__ */ i(async (d, m, b = !1) => {
      if (!(!b && d.validate && d.validate(m) !== !0))
        return d.format ? await d.format(m, s) : m;
    }, "getFormattedAnswer");
    for (o of e)
      if ({ name: u, type: c } = o, typeof c == "function" && (c = await c(a, { ...s }, o), o.type = c), !!c) {
        for (let d in o) {
          if (hz.includes(d)) continue;
          let m = o[d];
          o[d] = typeof m == "function" ? await m(a, { ...s }, f) : m;
        }
        if (f = o, typeof o.message != "string")
          throw new Error("prompt message is required");
        if ({ name: u, type: c } = o, Qg[c] === void 0)
          throw new Error(`prompt type (${c}) is not defined`);
        if (n[o.name] !== void 0 && (a = await p(o, n[o.name]), a !== void 0)) {
          s[u] = a;
          continue;
        }
        try {
          a = zi._injected ? mz(zi._injected, o.initial) : await Qg[c](o), s[u] = a = await p(o, a, !0), l = await t(o, a, s);
        } catch {
          l = !await r(o, s);
        }
        if (l) return s;
      }
    return s;
  }
  i(zi, "prompt");
  function mz(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  i(mz, "getInjectedAnswer");
  function yz(e) {
    zi._injected = (zi._injected || []).concat(e);
  }
  i(yz, "inject");
  function gz(e) {
    zi._override = Object.assign({}, e);
  }
  i(gz, "override");
  JN.exports = Object.assign(zi, { prompt: zi, prompts: Qg, inject: yz, override: gz });
});

// ../node_modules/prompts/index.js
var eR = y((JKe, ZN) => {
  function bz(e) {
    e = (Array.isArray(e) ? e : e.split(".")).map(Number);
    let t = 0, r = process.versions.node.split(".").map(Number);
    for (; t < e.length; t++) {
      if (r[t] > e[t]) return !1;
      if (e[t] > r[t]) return !0;
    }
    return !1;
  }
  i(bz, "isNodeLT");
  ZN.exports = bz("8.6.0") ? PO() : QN();
});

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var Lp = y((sb) => {
  "use strict";
  Object.defineProperty(sb, "__esModule", {
    value: !0
  });
  sb.default = xz;
  function xz(e, t) {
    let r = Object.keys(t);
    for (let s of r)
      if (e[s] !== t[s])
        return !1;
    return !0;
  }
  i(xz, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var Yu = y((nb) => {
  "use strict";
  Object.defineProperty(nb, "__esModule", {
    value: !0
  });
  nb.default = Pz;
  var iR = /* @__PURE__ */ new Set();
  function Pz(e, t, r = "") {
    if (iR.has(e)) return;
    iR.add(e);
    let {
      internal: s,
      trace: n
    } = Az(1, 2);
    s || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${n}`);
  }
  i(Pz, "deprecationWarning");
  function Az(e, t) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: s
    } = Error, n;
    if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(o, l) {
      n = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = s, !n) return {
      internal: !1,
      trace: ""
    };
    let a = n.slice(1 + e, 1 + e + t);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  i(Az, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var hr = y((T) => {
  "use strict";
  Object.defineProperty(T, "__esModule", {
    value: !0
  });
  T.isAccessor = jte;
  T.isAnyTypeAnnotation = aQ;
  T.isArgumentPlaceholder = FZ;
  T.isArrayExpression = Cz;
  T.isArrayPattern = PJ;
  T.isArrayTypeAnnotation = oQ;
  T.isArrowFunctionExpression = AJ;
  T.isAssignmentExpression = wz;
  T.isAssignmentPattern = xJ;
  T.isAwaitExpression = YJ;
  T.isBigIntLiteral = zJ;
  T.isBinary = lte;
  T.isBinaryExpression = Dz;
  T.isBindExpression = LZ;
  T.isBlock = fte;
  T.isBlockParent = cte;
  T.isBlockStatement = Nz;
  T.isBooleanLiteral = Zz;
  T.isBooleanLiteralTypeAnnotation = uQ;
  T.isBooleanTypeAnnotation = lQ;
  T.isBreakStatement = Rz;
  T.isCallExpression = kz;
  T.isCatchClause = Fz;
  T.isClass = Lte;
  T.isClassAccessorProperty = tQ;
  T.isClassBody = CJ;
  T.isClassDeclaration = DJ;
  T.isClassExpression = wJ;
  T.isClassImplements = fQ;
  T.isClassMethod = qJ;
  T.isClassPrivateMethod = sQ;
  T.isClassPrivateProperty = rQ;
  T.isClassProperty = eQ;
  T.isCompletionStatement = hte;
  T.isConditional = mte;
  T.isConditionalExpression = Lz;
  T.isContinueStatement = Bz;
  T.isDebuggerStatement = Mz;
  T.isDecimalLiteral = VZ;
  T.isDeclaration = Pte;
  T.isDeclareClass = pQ;
  T.isDeclareExportAllDeclaration = SQ;
  T.isDeclareExportDeclaration = vQ;
  T.isDeclareFunction = dQ;
  T.isDeclareInterface = hQ;
  T.isDeclareModule = mQ;
  T.isDeclareModuleExports = yQ;
  T.isDeclareOpaqueType = bQ;
  T.isDeclareTypeAlias = gQ;
  T.isDeclareVariable = EQ;
  T.isDeclaredPredicate = TQ;
  T.isDecorator = MZ;
  T.isDirective = _z;
  T.isDirectiveLiteral = Oz;
  T.isDoExpression = jZ;
  T.isDoWhileStatement = jz;
  T.isEmptyStatement = qz;
  T.isEmptyTypeAnnotation = RQ;
  T.isEnumBody = Gte;
  T.isEnumBooleanBody = oZ;
  T.isEnumBooleanMember = fZ;
  T.isEnumDeclaration = aZ;
  T.isEnumDefaultedMember = hZ;
  T.isEnumMember = Kte;
  T.isEnumNumberBody = lZ;
  T.isEnumNumberMember = pZ;
  T.isEnumStringBody = uZ;
  T.isEnumStringMember = dZ;
  T.isEnumSymbolBody = cZ;
  T.isExistsTypeAnnotation = xQ;
  T.isExportAllDeclaration = IJ;
  T.isExportDeclaration = Bte;
  T.isExportDefaultDeclaration = _J;
  T.isExportDefaultSpecifier = qZ;
  T.isExportNamedDeclaration = OJ;
  T.isExportNamespaceSpecifier = JJ;
  T.isExportSpecifier = NJ;
  T.isExpression = ote;
  T.isExpressionStatement = $z;
  T.isExpressionWrapper = bte;
  T.isFile = Uz;
  T.isFlow = $te;
  T.isFlowBaseAnnotation = Vte;
  T.isFlowDeclaration = Wte;
  T.isFlowPredicate = Hte;
  T.isFlowType = Ute;
  T.isFor = Ete;
  T.isForInStatement = Vz;
  T.isForOfStatement = RJ;
  T.isForStatement = Wz;
  T.isForXStatement = vte;
  T.isFunction = Ste;
  T.isFunctionDeclaration = Hz;
  T.isFunctionExpression = Gz;
  T.isFunctionParent = Tte;
  T.isFunctionTypeAnnotation = PQ;
  T.isFunctionTypeParam = AQ;
  T.isGenericTypeAnnotation = CQ;
  T.isIdentifier = Kz;
  T.isIfStatement = Yz;
  T.isImmutable = Ite;
  T.isImport = XJ;
  T.isImportAttribute = BZ;
  T.isImportDeclaration = kJ;
  T.isImportDefaultSpecifier = FJ;
  T.isImportExpression = MJ;
  T.isImportNamespaceSpecifier = LJ;
  T.isImportOrExportDeclaration = aR;
  T.isImportSpecifier = BJ;
  T.isIndexedAccessType = mZ;
  T.isInferredPredicate = wQ;
  T.isInterfaceDeclaration = IQ;
  T.isInterfaceExtends = DQ;
  T.isInterfaceTypeAnnotation = _Q;
  T.isInterpreterDirective = Iz;
  T.isIntersectionTypeAnnotation = OQ;
  T.isJSX = Yte;
  T.isJSXAttribute = gZ;
  T.isJSXClosingElement = bZ;
  T.isJSXClosingFragment = OZ;
  T.isJSXElement = EZ;
  T.isJSXEmptyExpression = vZ;
  T.isJSXExpressionContainer = SZ;
  T.isJSXFragment = IZ;
  T.isJSXIdentifier = xZ;
  T.isJSXMemberExpression = PZ;
  T.isJSXNamespacedName = AZ;
  T.isJSXOpeningElement = CZ;
  T.isJSXOpeningFragment = _Z;
  T.isJSXSpreadAttribute = wZ;
  T.isJSXSpreadChild = TZ;
  T.isJSXText = DZ;
  T.isLVal = Cte;
  T.isLabeledStatement = Xz;
  T.isLiteral = Dte;
  T.isLogicalExpression = tJ;
  T.isLoop = yte;
  T.isMemberExpression = rJ;
  T.isMetaProperty = jJ;
  T.isMethod = Ote;
  T.isMiscellaneous = Xte;
  T.isMixedTypeAnnotation = NQ;
  T.isModuleDeclaration = nre;
  T.isModuleExpression = WZ;
  T.isModuleSpecifier = Mte;
  T.isNewExpression = sJ;
  T.isNoop = NZ;
  T.isNullLiteral = Qz;
  T.isNullLiteralTypeAnnotation = cQ;
  T.isNullableTypeAnnotation = kQ;
  T.isNumberLiteral = ere;
  T.isNumberLiteralTypeAnnotation = FQ;
  T.isNumberTypeAnnotation = LQ;
  T.isNumericLiteral = Jz;
  T.isObjectExpression = iJ;
  T.isObjectMember = Nte;
  T.isObjectMethod = aJ;
  T.isObjectPattern = $J;
  T.isObjectProperty = oJ;
  T.isObjectTypeAnnotation = BQ;
  T.isObjectTypeCallProperty = jQ;
  T.isObjectTypeIndexer = qQ;
  T.isObjectTypeInternalSlot = MQ;
  T.isObjectTypeProperty = $Q;
  T.isObjectTypeSpreadProperty = UQ;
  T.isOpaqueType = VQ;
  T.isOptionalCallExpression = ZJ;
  T.isOptionalIndexedAccessType = yZ;
  T.isOptionalMemberExpression = QJ;
  T.isParenthesizedExpression = fJ;
  T.isPattern = Fte;
  T.isPatternLike = Ate;
  T.isPipelineBareFunction = KZ;
  T.isPipelinePrimaryTopicReference = YZ;
  T.isPipelineTopicExpression = GZ;
  T.isPlaceholder = RZ;
  T.isPrivate = qte;
  T.isPrivateName = nQ;
  T.isProgram = nJ;
  T.isProperty = Rte;
  T.isPureish = xte;
  T.isQualifiedTypeIdentifier = WQ;
  T.isRecordExpression = $Z;
  T.isRegExpLiteral = eJ;
  T.isRegexLiteral = tre;
  T.isRestElement = lJ;
  T.isRestProperty = rre;
  T.isReturnStatement = uJ;
  T.isScopable = ute;
  T.isSequenceExpression = cJ;
  T.isSpreadElement = UJ;
  T.isSpreadProperty = sre;
  T.isStandardized = ate;
  T.isStatement = pte;
  T.isStaticBlock = iQ;
  T.isStringLiteral = zz;
  T.isStringLiteralTypeAnnotation = HQ;
  T.isStringTypeAnnotation = GQ;
  T.isSuper = VJ;
  T.isSwitchCase = pJ;
  T.isSwitchStatement = dJ;
  T.isSymbolTypeAnnotation = KQ;
  T.isTSAnyKeyword = nee;
  T.isTSArrayType = Pee;
  T.isTSAsExpression = Vee;
  T.isTSBaseType = Zte;
  T.isTSBigIntKeyword = aee;
  T.isTSBooleanKeyword = iee;
  T.isTSCallSignatureDeclaration = ZZ;
  T.isTSConditionalType = Oee;
  T.isTSConstructSignatureDeclaration = eee;
  T.isTSConstructorType = Eee;
  T.isTSDeclareFunction = zZ;
  T.isTSDeclareMethod = JZ;
  T.isTSEntityName = wte;
  T.isTSEnumDeclaration = Gee;
  T.isTSEnumMember = Kee;
  T.isTSExportAssignment = ete;
  T.isTSExpressionWithTypeArguments = Mee;
  T.isTSExternalModuleReference = Qee;
  T.isTSFunctionType = bee;
  T.isTSImportEqualsDeclaration = Jee;
  T.isTSImportType = zee;
  T.isTSIndexSignature = see;
  T.isTSIndexedAccessType = Fee;
  T.isTSInferType = Nee;
  T.isTSInstantiationExpression = Uee;
  T.isTSInterfaceBody = qee;
  T.isTSInterfaceDeclaration = jee;
  T.isTSIntersectionType = _ee;
  T.isTSIntrinsicKeyword = oee;
  T.isTSLiteralType = Bee;
  T.isTSMappedType = Lee;
  T.isTSMethodSignature = ree;
  T.isTSModuleBlock = Xee;
  T.isTSModuleDeclaration = Yee;
  T.isTSNamedTupleMember = Dee;
  T.isTSNamespaceExportDeclaration = tte;
  T.isTSNeverKeyword = lee;
  T.isTSNonNullExpression = Zee;
  T.isTSNullKeyword = uee;
  T.isTSNumberKeyword = cee;
  T.isTSObjectKeyword = fee;
  T.isTSOptionalType = Cee;
  T.isTSParameterProperty = XZ;
  T.isTSParenthesizedType = Ree;
  T.isTSPropertySignature = tee;
  T.isTSQualifiedName = QZ;
  T.isTSRestType = wee;
  T.isTSSatisfiesExpression = Wee;
  T.isTSStringKeyword = pee;
  T.isTSSymbolKeyword = dee;
  T.isTSThisType = gee;
  T.isTSTupleType = Aee;
  T.isTSType = Qte;
  T.isTSTypeAliasDeclaration = $ee;
  T.isTSTypeAnnotation = rte;
  T.isTSTypeAssertion = Hee;
  T.isTSTypeElement = Jte;
  T.isTSTypeLiteral = xee;
  T.isTSTypeOperator = kee;
  T.isTSTypeParameter = ite;
  T.isTSTypeParameterDeclaration = nte;
  T.isTSTypeParameterInstantiation = ste;
  T.isTSTypePredicate = See;
  T.isTSTypeQuery = Tee;
  T.isTSTypeReference = vee;
  T.isTSUndefinedKeyword = hee;
  T.isTSUnionType = Iee;
  T.isTSUnknownKeyword = mee;
  T.isTSVoidKeyword = yee;
  T.isTaggedTemplateExpression = WJ;
  T.isTemplateElement = HJ;
  T.isTemplateLiteral = GJ;
  T.isTerminatorless = dte;
  T.isThisExpression = hJ;
  T.isThisTypeAnnotation = YQ;
  T.isThrowStatement = mJ;
  T.isTopicReference = HZ;
  T.isTryStatement = yJ;
  T.isTupleExpression = UZ;
  T.isTupleTypeAnnotation = XQ;
  T.isTypeAlias = JQ;
  T.isTypeAnnotation = QQ;
  T.isTypeCastExpression = ZQ;
  T.isTypeParameter = eZ;
  T.isTypeParameterDeclaration = tZ;
  T.isTypeParameterInstantiation = rZ;
  T.isTypeScript = zte;
  T.isTypeofTypeAnnotation = zQ;
  T.isUnaryExpression = gJ;
  T.isUnaryLike = kte;
  T.isUnionTypeAnnotation = sZ;
  T.isUpdateExpression = bJ;
  T.isUserWhitespacable = _te;
  T.isV8IntrinsicIdentifier = kZ;
  T.isVariableDeclaration = EJ;
  T.isVariableDeclarator = vJ;
  T.isVariance = nZ;
  T.isVoidTypeAnnotation = iZ;
  T.isWhile = gte;
  T.isWhileStatement = SJ;
  T.isWithStatement = TJ;
  T.isYieldExpression = KJ;
  var A = Lp(), Xu = Yu();
  function Cz(e, t) {
    return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Cz, "isArrayExpression");
  function wz(e, t) {
    return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(wz, "isAssignmentExpression");
  function Dz(e, t) {
    return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Dz, "isBinaryExpression");
  function Iz(e, t) {
    return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Iz, "isInterpreterDirective");
  function _z(e, t) {
    return !e || e.type !== "Directive" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(_z, "isDirective");
  function Oz(e, t) {
    return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Oz, "isDirectiveLiteral");
  function Nz(e, t) {
    return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Nz, "isBlockStatement");
  function Rz(e, t) {
    return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Rz, "isBreakStatement");
  function kz(e, t) {
    return !e || e.type !== "CallExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(kz, "isCallExpression");
  function Fz(e, t) {
    return !e || e.type !== "CatchClause" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Fz, "isCatchClause");
  function Lz(e, t) {
    return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Lz, "isConditionalExpression");
  function Bz(e, t) {
    return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Bz, "isContinueStatement");
  function Mz(e, t) {
    return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Mz, "isDebuggerStatement");
  function jz(e, t) {
    return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(jz, "isDoWhileStatement");
  function qz(e, t) {
    return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(qz, "isEmptyStatement");
  function $z(e, t) {
    return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i($z, "isExpressionStatement");
  function Uz(e, t) {
    return !e || e.type !== "File" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Uz, "isFile");
  function Vz(e, t) {
    return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Vz, "isForInStatement");
  function Wz(e, t) {
    return !e || e.type !== "ForStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Wz, "isForStatement");
  function Hz(e, t) {
    return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Hz, "isFunctionDeclaration");
  function Gz(e, t) {
    return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Gz, "isFunctionExpression");
  function Kz(e, t) {
    return !e || e.type !== "Identifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Kz, "isIdentifier");
  function Yz(e, t) {
    return !e || e.type !== "IfStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Yz, "isIfStatement");
  function Xz(e, t) {
    return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Xz, "isLabeledStatement");
  function zz(e, t) {
    return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(zz, "isStringLiteral");
  function Jz(e, t) {
    return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Jz, "isNumericLiteral");
  function Qz(e, t) {
    return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Qz, "isNullLiteral");
  function Zz(e, t) {
    return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Zz, "isBooleanLiteral");
  function eJ(e, t) {
    return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(eJ, "isRegExpLiteral");
  function tJ(e, t) {
    return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(tJ, "isLogicalExpression");
  function rJ(e, t) {
    return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(rJ, "isMemberExpression");
  function sJ(e, t) {
    return !e || e.type !== "NewExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(sJ, "isNewExpression");
  function nJ(e, t) {
    return !e || e.type !== "Program" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(nJ, "isProgram");
  function iJ(e, t) {
    return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(iJ, "isObjectExpression");
  function aJ(e, t) {
    return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(aJ, "isObjectMethod");
  function oJ(e, t) {
    return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(oJ, "isObjectProperty");
  function lJ(e, t) {
    return !e || e.type !== "RestElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(lJ, "isRestElement");
  function uJ(e, t) {
    return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(uJ, "isReturnStatement");
  function cJ(e, t) {
    return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(cJ, "isSequenceExpression");
  function fJ(e, t) {
    return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(fJ, "isParenthesizedExpression");
  function pJ(e, t) {
    return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(pJ, "isSwitchCase");
  function dJ(e, t) {
    return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(dJ, "isSwitchStatement");
  function hJ(e, t) {
    return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(hJ, "isThisExpression");
  function mJ(e, t) {
    return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(mJ, "isThrowStatement");
  function yJ(e, t) {
    return !e || e.type !== "TryStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(yJ, "isTryStatement");
  function gJ(e, t) {
    return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(gJ, "isUnaryExpression");
  function bJ(e, t) {
    return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(bJ, "isUpdateExpression");
  function EJ(e, t) {
    return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(EJ, "isVariableDeclaration");
  function vJ(e, t) {
    return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(vJ, "isVariableDeclarator");
  function SJ(e, t) {
    return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(SJ, "isWhileStatement");
  function TJ(e, t) {
    return !e || e.type !== "WithStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(TJ, "isWithStatement");
  function xJ(e, t) {
    return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(xJ, "isAssignmentPattern");
  function PJ(e, t) {
    return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(PJ, "isArrayPattern");
  function AJ(e, t) {
    return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(AJ, "isArrowFunctionExpression");
  function CJ(e, t) {
    return !e || e.type !== "ClassBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(CJ, "isClassBody");
  function wJ(e, t) {
    return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(wJ, "isClassExpression");
  function DJ(e, t) {
    return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(DJ, "isClassDeclaration");
  function IJ(e, t) {
    return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(IJ, "isExportAllDeclaration");
  function _J(e, t) {
    return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(_J, "isExportDefaultDeclaration");
  function OJ(e, t) {
    return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(OJ, "isExportNamedDeclaration");
  function NJ(e, t) {
    return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(NJ, "isExportSpecifier");
  function RJ(e, t) {
    return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(RJ, "isForOfStatement");
  function kJ(e, t) {
    return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(kJ, "isImportDeclaration");
  function FJ(e, t) {
    return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(FJ, "isImportDefaultSpecifier");
  function LJ(e, t) {
    return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(LJ, "isImportNamespaceSpecifier");
  function BJ(e, t) {
    return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(BJ, "isImportSpecifier");
  function MJ(e, t) {
    return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(MJ, "isImportExpression");
  function jJ(e, t) {
    return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(jJ, "isMetaProperty");
  function qJ(e, t) {
    return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(qJ, "isClassMethod");
  function $J(e, t) {
    return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  i($J, "isObjectPattern");
  function UJ(e, t) {
    return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(UJ, "isSpreadElement");
  function VJ(e, t) {
    return !e || e.type !== "Super" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(VJ, "isSuper");
  function WJ(e, t) {
    return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(WJ, "isTaggedTemplateExpression");
  function HJ(e, t) {
    return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(HJ, "isTemplateElement");
  function GJ(e, t) {
    return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(GJ, "isTemplateLiteral");
  function KJ(e, t) {
    return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(KJ, "isYieldExpression");
  function YJ(e, t) {
    return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(YJ, "isAwaitExpression");
  function XJ(e, t) {
    return !e || e.type !== "Import" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(XJ, "isImport");
  function zJ(e, t) {
    return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(zJ, "isBigIntLiteral");
  function JJ(e, t) {
    return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(JJ, "isExportNamespaceSpecifier");
  function QJ(e, t) {
    return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(QJ, "isOptionalMemberExpression");
  function ZJ(e, t) {
    return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(ZJ, "isOptionalCallExpression");
  function eQ(e, t) {
    return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(eQ, "isClassProperty");
  function tQ(e, t) {
    return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(tQ, "isClassAccessorProperty");
  function rQ(e, t) {
    return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(rQ, "isClassPrivateProperty");
  function sQ(e, t) {
    return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(sQ, "isClassPrivateMethod");
  function nQ(e, t) {
    return !e || e.type !== "PrivateName" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(nQ, "isPrivateName");
  function iQ(e, t) {
    return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(iQ, "isStaticBlock");
  function aQ(e, t) {
    return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(aQ, "isAnyTypeAnnotation");
  function oQ(e, t) {
    return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(oQ, "isArrayTypeAnnotation");
  function lQ(e, t) {
    return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(lQ, "isBooleanTypeAnnotation");
  function uQ(e, t) {
    return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(uQ, "isBooleanLiteralTypeAnnotation");
  function cQ(e, t) {
    return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(cQ, "isNullLiteralTypeAnnotation");
  function fQ(e, t) {
    return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(fQ, "isClassImplements");
  function pQ(e, t) {
    return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(pQ, "isDeclareClass");
  function dQ(e, t) {
    return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(dQ, "isDeclareFunction");
  function hQ(e, t) {
    return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(hQ, "isDeclareInterface");
  function mQ(e, t) {
    return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(mQ, "isDeclareModule");
  function yQ(e, t) {
    return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(yQ, "isDeclareModuleExports");
  function gQ(e, t) {
    return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(gQ, "isDeclareTypeAlias");
  function bQ(e, t) {
    return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(bQ, "isDeclareOpaqueType");
  function EQ(e, t) {
    return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(EQ, "isDeclareVariable");
  function vQ(e, t) {
    return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(vQ, "isDeclareExportDeclaration");
  function SQ(e, t) {
    return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(SQ, "isDeclareExportAllDeclaration");
  function TQ(e, t) {
    return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(TQ, "isDeclaredPredicate");
  function xQ(e, t) {
    return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(xQ, "isExistsTypeAnnotation");
  function PQ(e, t) {
    return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(PQ, "isFunctionTypeAnnotation");
  function AQ(e, t) {
    return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(AQ, "isFunctionTypeParam");
  function CQ(e, t) {
    return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(CQ, "isGenericTypeAnnotation");
  function wQ(e, t) {
    return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(wQ, "isInferredPredicate");
  function DQ(e, t) {
    return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(DQ, "isInterfaceExtends");
  function IQ(e, t) {
    return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(IQ, "isInterfaceDeclaration");
  function _Q(e, t) {
    return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(_Q, "isInterfaceTypeAnnotation");
  function OQ(e, t) {
    return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(OQ, "isIntersectionTypeAnnotation");
  function NQ(e, t) {
    return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(NQ, "isMixedTypeAnnotation");
  function RQ(e, t) {
    return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(RQ, "isEmptyTypeAnnotation");
  function kQ(e, t) {
    return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(kQ, "isNullableTypeAnnotation");
  function FQ(e, t) {
    return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(FQ, "isNumberLiteralTypeAnnotation");
  function LQ(e, t) {
    return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(LQ, "isNumberTypeAnnotation");
  function BQ(e, t) {
    return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(BQ, "isObjectTypeAnnotation");
  function MQ(e, t) {
    return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(MQ, "isObjectTypeInternalSlot");
  function jQ(e, t) {
    return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(jQ, "isObjectTypeCallProperty");
  function qQ(e, t) {
    return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(qQ, "isObjectTypeIndexer");
  function $Q(e, t) {
    return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i($Q, "isObjectTypeProperty");
  function UQ(e, t) {
    return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(UQ, "isObjectTypeSpreadProperty");
  function VQ(e, t) {
    return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(VQ, "isOpaqueType");
  function WQ(e, t) {
    return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(WQ, "isQualifiedTypeIdentifier");
  function HQ(e, t) {
    return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(HQ, "isStringLiteralTypeAnnotation");
  function GQ(e, t) {
    return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(GQ, "isStringTypeAnnotation");
  function KQ(e, t) {
    return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(KQ, "isSymbolTypeAnnotation");
  function YQ(e, t) {
    return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(YQ, "isThisTypeAnnotation");
  function XQ(e, t) {
    return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(XQ, "isTupleTypeAnnotation");
  function zQ(e, t) {
    return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(zQ, "isTypeofTypeAnnotation");
  function JQ(e, t) {
    return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(JQ, "isTypeAlias");
  function QQ(e, t) {
    return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(QQ, "isTypeAnnotation");
  function ZQ(e, t) {
    return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(ZQ, "isTypeCastExpression");
  function eZ(e, t) {
    return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(eZ, "isTypeParameter");
  function tZ(e, t) {
    return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(tZ, "isTypeParameterDeclaration");
  function rZ(e, t) {
    return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(rZ, "isTypeParameterInstantiation");
  function sZ(e, t) {
    return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(sZ, "isUnionTypeAnnotation");
  function nZ(e, t) {
    return !e || e.type !== "Variance" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(nZ, "isVariance");
  function iZ(e, t) {
    return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(iZ, "isVoidTypeAnnotation");
  function aZ(e, t) {
    return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(aZ, "isEnumDeclaration");
  function oZ(e, t) {
    return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(oZ, "isEnumBooleanBody");
  function lZ(e, t) {
    return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(lZ, "isEnumNumberBody");
  function uZ(e, t) {
    return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(uZ, "isEnumStringBody");
  function cZ(e, t) {
    return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(cZ, "isEnumSymbolBody");
  function fZ(e, t) {
    return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(fZ, "isEnumBooleanMember");
  function pZ(e, t) {
    return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(pZ, "isEnumNumberMember");
  function dZ(e, t) {
    return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(dZ, "isEnumStringMember");
  function hZ(e, t) {
    return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(hZ, "isEnumDefaultedMember");
  function mZ(e, t) {
    return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(mZ, "isIndexedAccessType");
  function yZ(e, t) {
    return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(yZ, "isOptionalIndexedAccessType");
  function gZ(e, t) {
    return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(gZ, "isJSXAttribute");
  function bZ(e, t) {
    return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(bZ, "isJSXClosingElement");
  function EZ(e, t) {
    return !e || e.type !== "JSXElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(EZ, "isJSXElement");
  function vZ(e, t) {
    return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(vZ, "isJSXEmptyExpression");
  function SZ(e, t) {
    return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(SZ, "isJSXExpressionContainer");
  function TZ(e, t) {
    return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(TZ, "isJSXSpreadChild");
  function xZ(e, t) {
    return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(xZ, "isJSXIdentifier");
  function PZ(e, t) {
    return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(PZ, "isJSXMemberExpression");
  function AZ(e, t) {
    return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(AZ, "isJSXNamespacedName");
  function CZ(e, t) {
    return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(CZ, "isJSXOpeningElement");
  function wZ(e, t) {
    return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(wZ, "isJSXSpreadAttribute");
  function DZ(e, t) {
    return !e || e.type !== "JSXText" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(DZ, "isJSXText");
  function IZ(e, t) {
    return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(IZ, "isJSXFragment");
  function _Z(e, t) {
    return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(_Z, "isJSXOpeningFragment");
  function OZ(e, t) {
    return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(OZ, "isJSXClosingFragment");
  function NZ(e, t) {
    return !e || e.type !== "Noop" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(NZ, "isNoop");
  function RZ(e, t) {
    return !e || e.type !== "Placeholder" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(RZ, "isPlaceholder");
  function kZ(e, t) {
    return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(kZ, "isV8IntrinsicIdentifier");
  function FZ(e, t) {
    return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(FZ, "isArgumentPlaceholder");
  function LZ(e, t) {
    return !e || e.type !== "BindExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(LZ, "isBindExpression");
  function BZ(e, t) {
    return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(BZ, "isImportAttribute");
  function MZ(e, t) {
    return !e || e.type !== "Decorator" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(MZ, "isDecorator");
  function jZ(e, t) {
    return !e || e.type !== "DoExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(jZ, "isDoExpression");
  function qZ(e, t) {
    return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(qZ, "isExportDefaultSpecifier");
  function $Z(e, t) {
    return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i($Z, "isRecordExpression");
  function UZ(e, t) {
    return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(UZ, "isTupleExpression");
  function VZ(e, t) {
    return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(VZ, "isDecimalLiteral");
  function WZ(e, t) {
    return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(WZ, "isModuleExpression");
  function HZ(e, t) {
    return !e || e.type !== "TopicReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(HZ, "isTopicReference");
  function GZ(e, t) {
    return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(GZ, "isPipelineTopicExpression");
  function KZ(e, t) {
    return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(KZ, "isPipelineBareFunction");
  function YZ(e, t) {
    return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(YZ, "isPipelinePrimaryTopicReference");
  function XZ(e, t) {
    return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(XZ, "isTSParameterProperty");
  function zZ(e, t) {
    return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(zZ, "isTSDeclareFunction");
  function JZ(e, t) {
    return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(JZ, "isTSDeclareMethod");
  function QZ(e, t) {
    return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(QZ, "isTSQualifiedName");
  function ZZ(e, t) {
    return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(ZZ, "isTSCallSignatureDeclaration");
  function eee(e, t) {
    return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(eee, "isTSConstructSignatureDeclaration");
  function tee(e, t) {
    return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(tee, "isTSPropertySignature");
  function ree(e, t) {
    return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(ree, "isTSMethodSignature");
  function see(e, t) {
    return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(see, "isTSIndexSignature");
  function nee(e, t) {
    return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(nee, "isTSAnyKeyword");
  function iee(e, t) {
    return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(iee, "isTSBooleanKeyword");
  function aee(e, t) {
    return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(aee, "isTSBigIntKeyword");
  function oee(e, t) {
    return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(oee, "isTSIntrinsicKeyword");
  function lee(e, t) {
    return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(lee, "isTSNeverKeyword");
  function uee(e, t) {
    return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(uee, "isTSNullKeyword");
  function cee(e, t) {
    return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(cee, "isTSNumberKeyword");
  function fee(e, t) {
    return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(fee, "isTSObjectKeyword");
  function pee(e, t) {
    return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(pee, "isTSStringKeyword");
  function dee(e, t) {
    return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(dee, "isTSSymbolKeyword");
  function hee(e, t) {
    return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(hee, "isTSUndefinedKeyword");
  function mee(e, t) {
    return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(mee, "isTSUnknownKeyword");
  function yee(e, t) {
    return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(yee, "isTSVoidKeyword");
  function gee(e, t) {
    return !e || e.type !== "TSThisType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(gee, "isTSThisType");
  function bee(e, t) {
    return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(bee, "isTSFunctionType");
  function Eee(e, t) {
    return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Eee, "isTSConstructorType");
  function vee(e, t) {
    return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(vee, "isTSTypeReference");
  function See(e, t) {
    return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(See, "isTSTypePredicate");
  function Tee(e, t) {
    return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Tee, "isTSTypeQuery");
  function xee(e, t) {
    return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(xee, "isTSTypeLiteral");
  function Pee(e, t) {
    return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Pee, "isTSArrayType");
  function Aee(e, t) {
    return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Aee, "isTSTupleType");
  function Cee(e, t) {
    return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Cee, "isTSOptionalType");
  function wee(e, t) {
    return !e || e.type !== "TSRestType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(wee, "isTSRestType");
  function Dee(e, t) {
    return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Dee, "isTSNamedTupleMember");
  function Iee(e, t) {
    return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Iee, "isTSUnionType");
  function _ee(e, t) {
    return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(_ee, "isTSIntersectionType");
  function Oee(e, t) {
    return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Oee, "isTSConditionalType");
  function Nee(e, t) {
    return !e || e.type !== "TSInferType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Nee, "isTSInferType");
  function Ree(e, t) {
    return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Ree, "isTSParenthesizedType");
  function kee(e, t) {
    return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(kee, "isTSTypeOperator");
  function Fee(e, t) {
    return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Fee, "isTSIndexedAccessType");
  function Lee(e, t) {
    return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Lee, "isTSMappedType");
  function Bee(e, t) {
    return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Bee, "isTSLiteralType");
  function Mee(e, t) {
    return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Mee, "isTSExpressionWithTypeArguments");
  function jee(e, t) {
    return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(jee, "isTSInterfaceDeclaration");
  function qee(e, t) {
    return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(qee, "isTSInterfaceBody");
  function $ee(e, t) {
    return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i($ee, "isTSTypeAliasDeclaration");
  function Uee(e, t) {
    return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Uee, "isTSInstantiationExpression");
  function Vee(e, t) {
    return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Vee, "isTSAsExpression");
  function Wee(e, t) {
    return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Wee, "isTSSatisfiesExpression");
  function Hee(e, t) {
    return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Hee, "isTSTypeAssertion");
  function Gee(e, t) {
    return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Gee, "isTSEnumDeclaration");
  function Kee(e, t) {
    return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Kee, "isTSEnumMember");
  function Yee(e, t) {
    return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Yee, "isTSModuleDeclaration");
  function Xee(e, t) {
    return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Xee, "isTSModuleBlock");
  function zee(e, t) {
    return !e || e.type !== "TSImportType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(zee, "isTSImportType");
  function Jee(e, t) {
    return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Jee, "isTSImportEqualsDeclaration");
  function Qee(e, t) {
    return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Qee, "isTSExternalModuleReference");
  function Zee(e, t) {
    return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Zee, "isTSNonNullExpression");
  function ete(e, t) {
    return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(ete, "isTSExportAssignment");
  function tte(e, t) {
    return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(tte, "isTSNamespaceExportDeclaration");
  function rte(e, t) {
    return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(rte, "isTSTypeAnnotation");
  function ste(e, t) {
    return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(ste, "isTSTypeParameterInstantiation");
  function nte(e, t) {
    return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(nte, "isTSTypeParameterDeclaration");
  function ite(e, t) {
    return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(ite, "isTSTypeParameter");
  function ate(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(ate, "isStandardized");
  function ote(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(ote, "isExpression");
  function lte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(lte, "isBinary");
  function ute(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(ute, "isScopable");
  function cte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(cte, "isBlockParent");
  function fte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(fte, "isBlock");
  function pte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(pte, "isStatement");
  function dte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(dte, "isTerminatorless");
  function hte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(hte, "isCompletionStatement");
  function mte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(mte, "isConditional");
  function yte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(yte, "isLoop");
  function gte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(gte, "isWhile");
  function bte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(bte, "isExpressionWrapper");
  function Ete(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Ete, "isFor");
  function vte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(vte, "isForXStatement");
  function Ste(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Ste, "isFunction");
  function Tte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Tte, "isFunctionParent");
  function xte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(xte, "isPureish");
  function Pte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (e.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Pte, "isDeclaration");
  function Ate(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Ate, "isPatternLike");
  function Cte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Cte, "isLVal");
  function wte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(wte, "isTSEntityName");
  function Dte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Dte, "isLiteral");
  function Ite(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Ite, "isImmutable");
  function _te(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(_te, "isUserWhitespacable");
  function Ote(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Ote, "isMethod");
  function Nte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Nte, "isObjectMember");
  function Rte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Rte, "isProperty");
  function kte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(kte, "isUnaryLike");
  function Fte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Fte, "isPattern");
  function Lte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Lte, "isClass");
  function aR(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(aR, "isImportOrExportDeclaration");
  function Bte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Bte, "isExportDeclaration");
  function Mte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Mte, "isModuleSpecifier");
  function jte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(jte, "isAccessor");
  function qte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(qte, "isPrivate");
  function $te(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i($te, "isFlow");
  function Ute(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Ute, "isFlowType");
  function Vte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Vte, "isFlowBaseAnnotation");
  function Wte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Wte, "isFlowDeclaration");
  function Hte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Hte, "isFlowPredicate");
  function Gte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Gte, "isEnumBody");
  function Kte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Kte, "isEnumMember");
  function Yte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Yte, "isJSX");
  function Xte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Xte, "isMiscellaneous");
  function zte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(zte, "isTypeScript");
  function Jte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Jte, "isTSTypeElement");
  function Qte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Qte, "isTSType");
  function Zte(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Zte, "isTSBaseType");
  function ere(e, t) {
    return (0, Xu.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(ere, "isNumberLiteral");
  function tre(e, t) {
    return (0, Xu.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(tre, "isRegexLiteral");
  function rre(e, t) {
    return (0, Xu.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(rre, "isRestProperty");
  function sre(e, t) {
    return (0, Xu.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(sre, "isSpreadProperty");
  function nre(e, t) {
    return (0, Xu.default)("isModuleDeclaration", "isImportOrExportDeclaration"), aR(e, t);
  }
  i(nre, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var ab = y((ib) => {
  "use strict";
  Object.defineProperty(ib, "__esModule", {
    value: !0
  });
  ib.default = ire;
  var zu = hr();
  function ire(e, t, r) {
    if (!(0, zu.isMemberExpression)(e)) return !1;
    let s = Array.isArray(t) ? t : t.split("."), n = [], a;
    for (a = e; (0, zu.isMemberExpression)(a); a = a.object)
      n.push(a.property);
    if (n.push(a), n.length < s.length || !r && n.length > s.length) return !1;
    for (let o = 0, l = n.length - 1; o < s.length; o++, l--) {
      let u = n[l], c;
      if ((0, zu.isIdentifier)(u))
        c = u.name;
      else if ((0, zu.isStringLiteral)(u))
        c = u.value;
      else if ((0, zu.isThisExpression)(u))
        c = "this";
      else
        return !1;
      if (s[o] !== c) return !1;
    }
    return !0;
  }
  i(ire, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var lb = y((ob) => {
  "use strict";
  Object.defineProperty(ob, "__esModule", {
    value: !0
  });
  ob.default = ore;
  var are = ab();
  function ore(e, t) {
    let r = e.split(".");
    return (s) => (0, are.default)(s, r, t);
  }
  i(ore, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var oR = y((Bp) => {
  "use strict";
  Object.defineProperty(Bp, "__esModule", {
    value: !0
  });
  Bp.default = void 0;
  var lre = lb(), ure = (0, lre.default)("React.Component"), mYe = Bp.default = ure;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var lR = y((ub) => {
  "use strict";
  Object.defineProperty(ub, "__esModule", {
    value: !0
  });
  ub.default = cre;
  function cre(e) {
    return !!e && /^[a-z]/.test(e);
  }
  i(cre, "isCompatTag");
});

// ../node_modules/to-fast-properties/index.js
var cR = y((EYe, uR) => {
  "use strict";
  var Ju = null;
  function Qu(e) {
    if (Ju !== null && typeof Ju.property) {
      let t = Ju;
      return Ju = Qu.prototype = null, t;
    }
    return Ju = Qu.prototype = e ?? /* @__PURE__ */ Object.create(null), new Qu();
  }
  i(Qu, "FastObject");
  Qu();
  uR.exports = /* @__PURE__ */ i(function(t) {
    return Qu(t);
  }, "toFastproperties");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var Mp = y((cb) => {
  "use strict";
  Object.defineProperty(cb, "__esModule", {
    value: !0
  });
  cb.default = fre;
  var fR = Ls();
  function fre(e, t) {
    if (e === t) return !0;
    if (e == null || fR.ALIAS_KEYS[t]) return !1;
    let r = fR.FLIPPED_ALIAS_KEYS[t];
    if (r) {
      if (r[0] === e) return !0;
      for (let s of r)
        if (e === s) return !0;
    }
    return !1;
  }
  i(fre, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var pb = y((fb) => {
  "use strict";
  Object.defineProperty(fb, "__esModule", {
    value: !0
  });
  fb.default = dre;
  var pre = Ls();
  function dre(e, t) {
    if (e === t) return !0;
    let r = pre.PLACEHOLDERS_ALIAS[e];
    if (r) {
      for (let s of r)
        if (t === s) return !0;
    }
    return !1;
  }
  i(dre, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var tl = y((db) => {
  "use strict";
  Object.defineProperty(db, "__esModule", {
    value: !0
  });
  db.default = bre;
  var hre = Lp(), mre = Mp(), yre = pb(), gre = Ls();
  function bre(e, t, r) {
    return t ? (0, mre.default)(t.type, e) ? typeof r > "u" ? !0 : (0, hre.default)(t, r) : !r && t.type === "Placeholder" && e in gre.FLIPPED_ALIAS_KEYS ?
    (0, yre.default)(t.expectedNode, e) : !1 : !1;
  }
  i(bre, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var yR = y((Zu) => {
  "use strict";
  Object.defineProperty(Zu, "__esModule", {
    value: !0
  });
  Zu.isIdentifierChar = mR;
  Zu.isIdentifierName = Tre;
  Zu.isIdentifierStart = hR;
  var mb = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  pR = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", Ere = new RegExp("[" + mb + "]"), vre = new RegExp("[" + mb + pR + "\
]");
  mb = pR = null;
  var dR = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Sre = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function hb(e, t) {
    let r = 65536;
    for (let s = 0, n = t.length; s < n; s += 2) {
      if (r += t[s], r > e) return !1;
      if (r += t[s + 1], r >= e) return !0;
    }
    return !1;
  }
  i(hb, "isInAstralSet");
  function hR(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && Ere.test(String.fromCharCode(e)) :
    hb(e, dR);
  }
  i(hR, "isIdentifierStart");
  function mR(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && vre.test(
    String.fromCharCode(e)) : hb(e, dR) || hb(e, Sre);
  }
  i(mR, "isIdentifierChar");
  function Tre(e) {
    let t = !0;
    for (let r = 0; r < e.length; r++) {
      let s = e.charCodeAt(r);
      if ((s & 64512) === 55296 && r + 1 < e.length) {
        let n = e.charCodeAt(++r);
        (n & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (n & 1023));
      }
      if (t) {
        if (t = !1, !hR(s))
          return !1;
      } else if (!mR(s))
        return !1;
    }
    return !t;
  }
  i(Tre, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var vR = y((Wa) => {
  "use strict";
  Object.defineProperty(Wa, "__esModule", {
    value: !0
  });
  Wa.isKeyword = wre;
  Wa.isReservedWord = gR;
  Wa.isStrictBindOnlyReservedWord = ER;
  Wa.isStrictBindReservedWord = Cre;
  Wa.isStrictReservedWord = bR;
  var yb = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, xre = new Set(yb.keyword), Pre = new Set(yb.strict), Are = new Set(yb.strictBind);
  function gR(e, t) {
    return t && e === "await" || e === "enum";
  }
  i(gR, "isReservedWord");
  function bR(e, t) {
    return gR(e, t) || Pre.has(e);
  }
  i(bR, "isStrictReservedWord");
  function ER(e) {
    return Are.has(e);
  }
  i(ER, "isStrictBindOnlyReservedWord");
  function Cre(e, t) {
    return bR(e, t) || ER(e);
  }
  i(Cre, "isStrictBindReservedWord");
  function wre(e) {
    return xre.has(e);
  }
  i(wre, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var rl = y((Ln) => {
  "use strict";
  Object.defineProperty(Ln, "__esModule", {
    value: !0
  });
  Object.defineProperty(Ln, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return gb.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(Ln, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return gb.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(Ln, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return gb.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(Ln, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return ec.isKeyword;
    }, "get")
  });
  Object.defineProperty(Ln, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return ec.isReservedWord;
    }, "get")
  });
  Object.defineProperty(Ln, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return ec.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(Ln, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return ec.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(Ln, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return ec.isStrictReservedWord;
    }, "get")
  });
  var gb = yR(), ec = vR();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var sl = y((Eb) => {
  "use strict";
  Object.defineProperty(Eb, "__esModule", {
    value: !0
  });
  Eb.default = Dre;
  var bb = rl();
  function Dre(e, t = !0) {
    return typeof e != "string" || t && ((0, bb.isKeyword)(e) || (0, bb.isStrictReservedWord)(e, !0)) ? !1 : (0, bb.isIdentifierName)(e);
  }
  i(Dre, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var PR = y((tc) => {
  "use strict";
  Object.defineProperty(tc, "__esModule", {
    value: !0
  });
  tc.readCodePoint = xR;
  tc.readInt = TR;
  tc.readStringContents = _re;
  var Ire = /* @__PURE__ */ i(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), SR = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, jp = {
    bin: /* @__PURE__ */ i((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ i((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ i((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ i((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function _re(e, t, r, s, n, a) {
    let o = r, l = s, u = n, c = "", f = null, p = r, {
      length: d
    } = t;
    for (; ; ) {
      if (r >= d) {
        a.unterminated(o, l, u), c += t.slice(p, r);
        break;
      }
      let m = t.charCodeAt(r);
      if (Ore(e, m, t, r)) {
        c += t.slice(p, r);
        break;
      }
      if (m === 92) {
        c += t.slice(p, r);
        let b = Nre(t, r, s, n, e === "template", a);
        b.ch === null && !f ? f = {
          pos: r,
          lineStart: s,
          curLine: n
        } : c += b.ch, {
          pos: r,
          lineStart: s,
          curLine: n
        } = b, p = r;
      } else m === 8232 || m === 8233 ? (++r, ++n, s = r) : m === 10 || m === 13 ? e === "template" ? (c += t.slice(p, r) + `
`, ++r, m === 13 && t.charCodeAt(r) === 10 && ++r, ++n, p = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: f,
      lineStart: s,
      curLine: n,
      containsInvalid: !!f
    };
  }
  i(_re, "readStringContents");
  function Ore(e, t, r, s) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(s + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  i(Ore, "isStringEnd");
  function Nre(e, t, r, s, n, a) {
    let o = !n;
    t++;
    let l = /* @__PURE__ */ i((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = vb(e, t, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = xR(e, t, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(t - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, p = e.slice(c, t + 2).match(/^[0-7]+/)[0], d = parseInt(p, 8);
          d > 255 && (p = p.slice(0, -1), d = parseInt(p, 8)), t += p.length - 1;
          let m = e.charCodeAt(t);
          if (p !== "0" || m === 56 || m === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(d));
        }
        return l(String.fromCharCode(u));
    }
  }
  i(Nre, "readEscapedChar");
  function vb(e, t, r, s, n, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = TR(e, t, r, s, 16, n, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  i(vb, "readHexChar");
  function TR(e, t, r, s, n, a, o, l, u, c) {
    let f = t, p = n === 16 ? SR.hex : SR.decBinOct, d = n === 16 ? jp.hex : n === 10 ? jp.dec : n === 8 ? jp.oct : jp.bin, m = !1, b = 0;
    for (let h = 0, g = a ?? 1 / 0; h < g; ++h) {
      let E = e.charCodeAt(t), D;
      if (E === 95 && l !== "bail") {
        let C = e.charCodeAt(t - 1), N = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(N) || !d(N) || p.has(C) || p.has(N)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, s);
        }
        ++t;
        continue;
      }
      if (E >= 97 ? D = E - 97 + 10 : E >= 65 ? D = E - 65 + 10 : Ire(E) ? D = E - 48 : D = 1 / 0, D >= n) {
        if (D <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (D <= 9 && u.invalidDigit(t, r, s, n))
          D = 0;
        else if (o)
          D = 0, m = !0;
        else
          break;
      }
      ++t, b = b * n + D;
    }
    return t === f || a != null && t - f !== a || m ? {
      n: null,
      pos: t
    } : {
      n: b,
      pos: t
    };
  }
  i(TR, "readInt");
  function xR(e, t, r, s, n, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = vb(e, t, r, s, e.indexOf("}", t) - t, !0, n, a), ++t, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(t, r, s);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = vb(e, t, r, s, 4, !1, n, a));
    return {
      code: l,
      pos: t
    };
  }
  i(xR, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var Ji = y((Ye) => {
  "use strict";
  Object.defineProperty(Ye, "__esModule", {
    value: !0
  });
  Ye.UPDATE_OPERATORS = Ye.UNARY_OPERATORS = Ye.STRING_UNARY_OPERATORS = Ye.STATEMENT_OR_BLOCK_KEYS = Ye.NUMBER_UNARY_OPERATORS = Ye.NUMBER_BINARY_OPERATORS =
  Ye.NOT_LOCAL_BINDING = Ye.LOGICAL_OPERATORS = Ye.INHERIT_KEYS = Ye.FOR_INIT_KEYS = Ye.FLATTENABLE_KEYS = Ye.EQUALITY_BINARY_OPERATORS = Ye.
  COMPARISON_BINARY_OPERATORS = Ye.COMMENT_KEYS = Ye.BOOLEAN_UNARY_OPERATORS = Ye.BOOLEAN_NUMBER_BINARY_OPERATORS = Ye.BOOLEAN_BINARY_OPERATORS =
  Ye.BLOCK_SCOPED_SYMBOL = Ye.BINARY_OPERATORS = Ye.ASSIGNMENT_OPERATORS = void 0;
  var BYe = Ye.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], MYe = Ye.FLATTENABLE_KEYS = ["body", "expressions"], jYe = Ye.
  FOR_INIT_KEYS = ["left", "init"], qYe = Ye.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], Rre = Ye.LOGICAL_OPERATORS =
  ["||", "&&", "??"], $Ye = Ye.UPDATE_OPERATORS = ["++", "--"], kre = Ye.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], Fre = Ye.
  EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], Lre = Ye.COMPARISON_BINARY_OPERATORS = [...Fre, "in", "instanceof"], Bre = Ye.BOOLEAN_BINARY_OPERATORS =
  [...Lre, ...kre], AR = Ye.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], UYe = Ye.BINARY_OPERATORS =
  ["+", ...AR, ...Bre, "|>"], VYe = Ye.ASSIGNMENT_OPERATORS = ["=", "+=", ...AR.map((e) => e + "="), ...Rre.map((e) => e + "=")], Mre = Ye.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], jre = Ye.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], qre = Ye.STRING_UNARY_OPERATORS = ["typeof"], WYe = Ye.UNARY_OPERATORS =
  ["void", "throw", ...Mre, ...jre, ...qre], HYe = Ye.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, GYe = Ye.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), KYe = Ye.NOT_LOCAL_BINDING = Symbol.for("should not be consid\
ered a local binding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var ci = y((yt) => {
  "use strict";
  Object.defineProperty(yt, "__esModule", {
    value: !0
  });
  yt.VISITOR_KEYS = yt.NODE_PARENT_VALIDATIONS = yt.NODE_FIELDS = yt.FLIPPED_ALIAS_KEYS = yt.DEPRECATED_KEYS = yt.BUILDER_KEYS = yt.ALIAS_KEYS =
  void 0;
  yt.arrayOf = wR;
  yt.arrayOfType = DR;
  yt.assertEach = IR;
  yt.assertNodeOrValueType = Qre;
  yt.assertNodeType = Tb;
  yt.assertOneOf = Jre;
  yt.assertOptionalChainStart = ese;
  yt.assertShape = Zre;
  yt.assertValueType = Ab;
  yt.chain = _R;
  yt.default = OR;
  yt.defineAliasedType = sse;
  yt.typeIs = Up;
  yt.validate = Pb;
  yt.validateArrayOfType = zre;
  yt.validateOptional = Yre;
  yt.validateOptionalType = Xre;
  yt.validateType = Kre;
  var CR = tl(), $p = Vp(), $re = yt.VISITOR_KEYS = {}, Ure = yt.ALIAS_KEYS = {}, Sb = yt.FLIPPED_ALIAS_KEYS = {}, Vre = yt.NODE_FIELDS = {},
  Wre = yt.BUILDER_KEYS = {}, Hre = yt.DEPRECATED_KEYS = {}, Gre = yt.NODE_PARENT_VALIDATIONS = {};
  function qp(e) {
    return Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
  }
  i(qp, "getType");
  function Pb(e) {
    return {
      validate: e
    };
  }
  i(Pb, "validate");
  function Up(e) {
    return typeof e == "string" ? Tb(e) : Tb(...e);
  }
  i(Up, "typeIs");
  function Kre(e) {
    return Pb(Up(e));
  }
  i(Kre, "validateType");
  function Yre(e) {
    return {
      validate: e,
      optional: !0
    };
  }
  i(Yre, "validateOptional");
  function Xre(e) {
    return {
      validate: Up(e),
      optional: !0
    };
  }
  i(Xre, "validateOptionalType");
  function wR(e) {
    return _R(Ab("array"), IR(e));
  }
  i(wR, "arrayOf");
  function DR(e) {
    return wR(Up(e));
  }
  i(DR, "arrayOfType");
  function zre(e) {
    return Pb(DR(e));
  }
  i(zre, "validateArrayOfType");
  function IR(e) {
    function t(r, s, n) {
      if (Array.isArray(n))
        for (let a = 0; a < n.length; a++) {
          let o = `${s}[${a}]`, l = n[a];
          e(r, o, l), process.env.BABEL_TYPES_8_BREAKING && (0, $p.validateChild)(r, o, l);
        }
    }
    return i(t, "validator"), t.each = e, t;
  }
  i(IR, "assertEach");
  function Jre(...e) {
    function t(r, s, n) {
      if (e.indexOf(n) < 0)
        throw new TypeError(`Property ${s} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(n)}`);
    }
    return i(t, "validate"), t.oneOf = e, t;
  }
  i(Jre, "assertOneOf");
  function Tb(...e) {
    function t(r, s, n) {
      for (let a of e)
        if ((0, CR.default)(a, n)) {
          (0, $p.validateChild)(r, s, n);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return i(t, "validate"), t.oneOfNodeTypes = e, t;
  }
  i(Tb, "assertNodeType");
  function Qre(...e) {
    function t(r, s, n) {
      for (let a of e)
        if (qp(n) === a || (0, CR.default)(a, n)) {
          (0, $p.validateChild)(r, s, n);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return i(t, "validate"), t.oneOfNodeOrValueTypes = e, t;
  }
  i(Qre, "assertNodeOrValueType");
  function Ab(e) {
    function t(r, s, n) {
      if (!(qp(n) === e))
        throw new TypeError(`Property ${s} expected type of ${e} but got ${qp(n)}`);
    }
    return i(t, "validate"), t.type = e, t;
  }
  i(Ab, "assertValueType");
  function Zre(e) {
    function t(r, s, n) {
      let a = [];
      for (let o of Object.keys(e))
        try {
          (0, $p.validateField)(r, o, n[o], e[o]);
        } catch (l) {
          if (l instanceof TypeError) {
            a.push(l.message);
            continue;
          }
          throw l;
        }
      if (a.length)
        throw new TypeError(`Property ${s} of ${r.type} expected to have the following:
${a.join(`
`)}`);
    }
    return i(t, "validate"), t.shapeOf = e, t;
  }
  i(Zre, "assertShape");
  function ese() {
    function e(t) {
      var r;
      let s = t;
      for (; t; ) {
        let {
          type: n
        } = s;
        if (n === "OptionalCallExpression") {
          if (s.optional) return;
          s = s.callee;
          continue;
        }
        if (n === "OptionalMemberExpression") {
          if (s.optional) return;
          s = s.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = s) == null ? void 0 : r.type}`);
    }
    return i(e, "validate"), e;
  }
  i(ese, "assertOptionalChainStart");
  function _R(...e) {
    function t(...r) {
      for (let s of e)
        s(...r);
    }
    if (i(t, "validate"), t.chainOf = e, e.length >= 2 && "type" in e[0] && e[0].type === "array" && !("each" in e[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return t;
  }
  i(_R, "chain");
  var tse = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], rse = ["default", "optional", "deprecate\
d", "validate"], xb = {};
  function sse(...e) {
    return (t, r = {}) => {
      let s = r.aliases;
      if (!s) {
        var n, a;
        r.inherits && (s = (n = xb[r.inherits].aliases) == null ? void 0 : n.slice()), (a = s) != null || (s = []), r.aliases = s;
      }
      let o = e.filter((l) => !s.includes(l));
      s.unshift(...o), OR(t, r);
    };
  }
  i(sse, "defineAliasedType");
  function OR(e, t = {}) {
    let r = t.inherits && xb[t.inherits] || {}, s = t.fields;
    if (!s && (s = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let c = r.fields[u], f = c.default;
        if (Array.isArray(f) ? f.length > 0 : f && typeof f == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        s[u] = {
          default: Array.isArray(f) ? [] : f,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let n = t.visitor || r.visitor || [], a = t.aliases || r.aliases || [], o = t.builder || r.builder || t.visitor || [];
    for (let l of Object.keys(t))
      if (tse.indexOf(l) === -1)
        throw new Error(`Unknown type option "${l}" on ${e}`);
    t.deprecatedAlias && (Hre[t.deprecatedAlias] = e);
    for (let l of n.concat(o))
      s[l] = s[l] || {};
    for (let l of Object.keys(s)) {
      let u = s[l];
      u.default !== void 0 && o.indexOf(l) === -1 && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default !=
      null && (u.validate = Ab(qp(u.default)));
      for (let c of Object.keys(u))
        if (rse.indexOf(c) === -1)
          throw new Error(`Unknown field key "${c}" on ${e}.${l}`);
    }
    $re[e] = t.visitor = n, Wre[e] = t.builder = o, Vre[e] = t.fields = s, Ure[e] = t.aliases = a, a.forEach((l) => {
      Sb[l] = Sb[l] || [], Sb[l].push(e);
    }), t.validate && (Gre[e] = t.validate), xb[e] = t;
  }
  i(OR, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var wb = y((ys) => {
  "use strict";
  Object.defineProperty(ys, "__esModule", {
    value: !0
  });
  ys.patternLikeCommon = ys.functionTypeAnnotationCommon = ys.functionDeclarationCommon = ys.functionCommon = ys.classMethodOrPropertyCommon =
  ys.classMethodOrDeclareMethodCommon = void 0;
  var ts = tl(), nse = sl(), NR = rl(), ise = PR(), rc = Ji(), v = ci(), le = (0, v.defineAliasedType)("Standardized");
  le("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeOrValueType)("null", "Expression", "Spread\
Element"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  le("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, v.assertValueType)("string");
          let e = (0, v.assertOneOf)(...rc.ASSIGNMENT_OPERATORS), t = (0, v.assertOneOf)("=");
          return function(r, s, n) {
            ((0, ts.default)("Pattern", r.left) ? t : e)(r, s, n);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, v.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, v.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, v.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  le("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, v.assertOneOf)(...rc.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let e = (0, v.assertNodeType)("Expression"), t = (0, v.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(s, n, a) {
            (s.operator === "in" ? t : e)(s, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, v.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  le("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, v.assertValueType)("string")
      }
    }
  });
  le("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, v.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  le("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, v.assertValueType)("string")
      }
    }
  });
  le("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  le("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, v.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  le("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, v.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, v.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, v.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, v.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  le("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, v.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, v.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  le("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, v.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, v.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, v.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  le("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, v.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  le("DebuggerStatement", {
    aliases: ["Statement"]
  });
  le("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, v.assertNodeType)("Expression")
      },
      body: {
        validate: (0, v.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  le("EmptyStatement", {
    aliases: ["Statement"]
  });
  le("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, v.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  le("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, v.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, v.assertEach)((0, v.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, v.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  le("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, v.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, v.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, v.assertNodeType)("Expression")
      },
      body: {
        validate: (0, v.assertNodeType)("Statement")
      }
    }
  });
  le("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, v.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, v.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, v.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, v.assertNodeType)("Statement")
      }
    }
  });
  var nl = /* @__PURE__ */ i(() => ({
    params: {
      validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  ys.functionCommon = nl;
  var Ha = /* @__PURE__ */ i(() => ({
    returnType: {
      validate: (0, v.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, v.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  ys.functionTypeAnnotationCommon = Ha;
  var RR = /* @__PURE__ */ i(() => Object.assign({}, nl(), {
    declare: {
      validate: (0, v.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, v.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  ys.functionDeclarationCommon = RR;
  le("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, RR(), Ha(), {
      body: {
        validate: (0, v.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, v.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
      };
      let e = (0, v.assertNodeType)("Identifier");
      return function(t, r, s) {
        (0, ts.default)("ExportDefaultDeclaration", t) || e(s, "id", s.id);
      };
    }()
  });
  le("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, nl(), Ha(), {
      id: {
        validate: (0, v.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, v.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, v.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var il = /* @__PURE__ */ i(() => ({
    typeAnnotation: {
      validate: (0, v.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, v.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "patternLikeCommon");
  ys.patternLikeCommon = il;
  le("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, il(), {
      name: {
        validate: (0, v.chain)((0, v.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, nse.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(e, t, r) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let s = /\.(\w+)$/.exec(t);
      if (!s) return;
      let [, n] = s, a = {
        computed: !1
      };
      if (n === "property") {
        if ((0, ts.default)("MemberExpression", e, a) || (0, ts.default)("OptionalMemberExpression", e, a)) return;
      } else if (n === "key") {
        if ((0, ts.default)("Property", e, a) || (0, ts.default)("Method", e, a)) return;
      } else if (n === "exported") {
        if ((0, ts.default)("ExportSpecifier", e)) return;
      } else if (n === "imported") {
        if ((0, ts.default)("ImportSpecifier", e, {
          imported: r
        })) return;
      } else if (n === "meta" && (0, ts.default)("MetaProperty", e, {
        meta: r
      }))
        return;
      if (((0, NR.isKeyword)(r.name) || (0, NR.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    }
  });
  le("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, v.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, v.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, v.assertNodeType)("Statement")
      }
    }
  });
  le("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, v.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, v.assertNodeType)("Statement")
      }
    }
  });
  le("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, v.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  le("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, v.chain)((0, v.assertValueType)("number"), Object.assign(function(e, t, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let s = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  le("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  le("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, v.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  le("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, v.assertValueType)("string")
      },
      flags: {
        validate: (0, v.chain)((0, v.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s = /[^gimsuy]/.exec(r);
          if (s)
            throw new TypeError(`"${s[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  le("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, v.assertOneOf)(...rc.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, v.assertNodeType)("Expression")
      },
      right: {
        validate: (0, v.assertNodeType)("Expression")
      }
    }
  });
  le("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, v.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let e = (0, v.assertNodeType)("Identifier", "PrivateName"), t = (0, v.assertNodeType)("Expression"), r = /* @__PURE__ */ i(function(s, n, a) {
            (s.computed ? t : e)(s, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, v.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  });
  le("NewExpression", {
    inherits: "CallExpression"
  });
  le("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, v.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, v.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  le("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("ObjectMethod", "ObjectProperty", "S\
preadElement")))
      }
    }
  });
  le("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, nl(), Ha(), {
      kind: Object.assign({
        validate: (0, v.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, v.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, v.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ i(function(s, n, a) {
            (s.computed ? t : e)(s, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, v.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  le("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, v.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t = (0, v.
          assertNodeType)("Expression");
          return Object.assign(function(s, n, a) {
            (s.computed ? t : e)(s, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, v.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, v.chain)((0, v.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !(0, ts.default)("Identifier", e.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      let e = (0, v.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), t = (0, v.assertNodeType)("Expression");
      return function(r, s, n) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, ts.default)("ObjectPattern", r) ? e : t)(n, "value", n.value);
      };
    }()
  });
  le("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, il(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, v.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, v.assertNodeType)("LVal")
      }
    }),
    validate(e, t) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let r = /(\w+)\[(\d+)\]/.exec(t);
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, s, n] = r;
      if (e[s].length > +n + 1)
        throw new TypeError(`RestElement must be last element of ${s}`);
    }
  });
  le("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, v.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  le("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  le("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, v.assertNodeType)("Expression")
      }
    }
  });
  le("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, v.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Statement")))
      }
    }
  });
  le("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, v.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("SwitchCase")))
      }
    }
  });
  le("ThisExpression", {
    aliases: ["Expression"]
  });
  le("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, v.assertNodeType)("Expression")
      }
    }
  });
  le("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, v.chain)((0, v.assertNodeType)("BlockStatement"), Object.assign(function(e) {
          if (process.env.BABEL_TYPES_8_BREAKING && !e.handler && !e.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, v.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, v.assertNodeType)("BlockStatement")
      }
    }
  });
  le("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, v.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, v.assertOneOf)(...rc.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  le("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, v.assertNodeType)("Identifier", "MemberExpression") : (0, v.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, v.assertOneOf)(...rc.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  le("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, v.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(e, t, r) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, ts.default)("ForXStatement", e, {
        left: r
      }) && r.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`);
    }
  });
  le("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, v.assertNodeType)("LVal");
          let e = (0, v.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), t = (0, v.assertNodeType)("Identifier");
          return function(r, s, n) {
            (r.init ? e : t)(r, s, n);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, v.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, v.assertNodeType)("Expression")
      }
    }
  });
  le("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, v.assertNodeType)("Expression")
      },
      body: {
        validate: (0, v.assertNodeType)("Statement")
      }
    }
  });
  le("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, v.assertNodeType)("Expression")
      },
      body: {
        validate: (0, v.assertNodeType)("Statement")
      }
    }
  });
  le("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, il(), {
      left: {
        validate: (0, v.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, v.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  });
  le("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, il(), {
      elements: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  le("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, nl(), Ha(), {
      expression: {
        validate: (0, v.assertValueType)("boolean")
      },
      body: {
        validate: (0, v.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, v.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  le("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("ClassMethod", "ClassPrivateMethod",
        "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  le("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, v.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, v.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, v.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, v.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, v.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, v.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  le("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, v.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, v.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, v.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, v.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, v.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, v.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      let e = (0, v.assertNodeType)("Identifier");
      return function(t, r, s) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, ts.default)("ExportDefaultDeclaration", t) || e(s, "id", s.id));
      };
    }()
  });
  le("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, v.assertNodeType)("StringLiteral")
      },
      exportKind: (0, v.validateOptional)((0, v.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("ImportAttribute")))
      }
    }
  });
  le("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, v.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, v.validateOptional)((0, v.assertOneOf)("value"))
    }
  });
  le("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, v.chain)((0, v.assertNodeType)("Declaration"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && e.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)(function() {
          let e = (0, v.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t = (0, v.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(r, s, n) {
            (r.source ? e : t)(r, s, n);
          } : e;
        }()))
      },
      source: {
        validate: (0, v.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, v.validateOptional)((0, v.assertOneOf)("type", "value"))
    }
  });
  le("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, v.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, v.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, v.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  le("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, v.assertNodeType)("VariableDeclaration", "LVal");
          let e = (0, v.assertNodeType)("VariableDeclaration"), t = (0, v.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(r, s, n) {
            (0, ts.default)("VariableDeclaration", n) ? e(r, s, n) : t(r, s, n);
          };
        }()
      },
      right: {
        validate: (0, v.assertNodeType)("Expression")
      },
      body: {
        validate: (0, v.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  le("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, v.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, v.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("ImportSpecifier", "ImportDefaultSpe\
cifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, v.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, v.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  le("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, v.assertNodeType)("Identifier")
      }
    }
  });
  le("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, v.assertNodeType)("Identifier")
      }
    }
  });
  le("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, v.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, v.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, v.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  le("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, v.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, v.assertNodeType)("Expression")
      },
      options: {
        validate: (0, v.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  le("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, v.chain)((0, v.assertNodeType)("Identifier"), Object.assign(function(e, t, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s;
          switch (r.name) {
            case "function":
              s = "sent";
              break;
            case "new":
              s = "target";
              break;
            case "import":
              s = "meta";
              break;
          }
          if (!(0, ts.default)("Identifier", e.property, {
            name: s
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, v.assertNodeType)("Identifier")
      }
    }
  });
  var Wp = /* @__PURE__ */ i(() => ({
    abstract: {
      validate: (0, v.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, v.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, v.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, v.chain)(function() {
        let e = (0, v.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, v.assertNodeType)("Expressi\
on");
        return function(r, s, n) {
          (r.computed ? t : e)(r, s, n);
        };
      }(), (0, v.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  ys.classMethodOrPropertyCommon = Wp;
  var Cb = /* @__PURE__ */ i(() => Object.assign({}, nl(), Wp(), {
    params: {
      validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Identifier", "Pattern", "RestElement",
      "TSParameterProperty")))
    },
    kind: {
      validate: (0, v.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, v.chain)((0, v.assertValueType)("string"), (0, v.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  ys.classMethodOrDeclareMethodCommon = Cb;
  le("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, Cb(), Ha(), {
      body: {
        validate: (0, v.assertNodeType)("BlockStatement")
      }
    })
  });
  le("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, il(), {
      properties: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  le("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, v.assertNodeType)("Expression")
      }
    }
  });
  le("Super", {
    aliases: ["Expression"]
  });
  le("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, v.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, v.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, v.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  le("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, v.chain)((0, v.assertShape)({
          raw: {
            validate: (0, v.assertValueType)("string")
          },
          cooked: {
            validate: (0, v.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ i(function(t) {
          let r = t.value.raw, s = !1, n = /* @__PURE__ */ i(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, ise.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              s = !0;
            },
            strictNumericEscape: n,
            invalidEscapeSequence: n,
            numericSeparatorInEscapeSequence: n,
            unexpectedNumericSeparator: n,
            invalidDigit: n,
            invalidCodePoint: n
          });
          if (!s) throw new Error("Invalid raw");
          t.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  le("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Expression", "TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  le("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, v.chain)((0, v.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !e.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, v.assertNodeType)("Expression")
      }
    }
  });
  le("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, v.assertNodeType)("Expression")
      }
    }
  });
  le("Import", {
    aliases: ["Expression"]
  });
  le("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, v.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  le("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, v.assertNodeType)("Identifier")
      }
    }
  });
  le("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, v.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let e = (0, v.assertNodeType)("Identifier"), t = (0, v.assertNodeType)("Expression");
          return Object.assign(function(s, n, a) {
            (s.computed ? t : e)(s, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, v.chain)((0, v.assertValueType)("boolean"), (0, v.assertOptionalChainStart)()) : (0, v.
        assertValueType)("boolean")
      }
    }
  });
  le("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, v.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, v.chain)((0, v.assertValueType)("boolean"), (0, v.assertOptionalChainStart)()) : (0, v.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, v.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, v.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  le("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, Wp(), {
      value: {
        validate: (0, v.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, v.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, v.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  le("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, Wp(), {
      key: {
        validate: (0, v.chain)(function() {
          let e = (0, v.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t = (0, v.assertNodeType)(
          "Expression");
          return function(r, s, n) {
            (r.computed ? t : e)(r, s, n);
          };
        }(), (0, v.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, v.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, v.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, v.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  le("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, v.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, v.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, v.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, v.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, v.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, v.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  le("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, Cb(), Ha(), {
      kind: {
        validate: (0, v.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, v.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, v.assertNodeType)("BlockStatement")
      }
    })
  });
  le("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, v.assertNodeType)("Identifier")
      }
    }
  });
  le("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, v.chain)((0, v.assertValueType)("array"), (0, v.assertEach)((0, v.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var kR = y(() => {
  "use strict";
  var $ = ci(), Te = (0, $.defineAliasedType)("Flow"), Db = /* @__PURE__ */ i((e) => {
    let t = e === "DeclareClass";
    Te(e, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...t ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, $.validateType)("Identifier"),
        typeParameters: (0, $.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, $.validateOptional)((0, $.arrayOfType)("InterfaceExtends"))
      }, t ? {
        mixins: (0, $.validateOptional)((0, $.arrayOfType)("InterfaceExtends")),
        implements: (0, $.validateOptional)((0, $.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, $.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  Te("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, $.validateType)("FlowType")
    }
  });
  Te("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, $.validate)((0, $.assertValueType)("boolean"))
    }
  });
  Te("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Db("DeclareClass");
  Te("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      predicate: (0, $.validateOptionalType)("DeclaredPredicate")
    }
  });
  Db("DeclareInterface");
  Te("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, $.validateType)(["Identifier", "StringLiteral"]),
      body: (0, $.validateType)("BlockStatement"),
      kind: (0, $.validateOptional)((0, $.assertOneOf)("CommonJS", "ES"))
    }
  });
  Te("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, $.validateType)("TypeAnnotation")
    }
  });
  Te("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, $.validateType)("FlowType")
    }
  });
  Te("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, $.validateOptionalType)("FlowType"),
      impltype: (0, $.validateOptionalType)("FlowType")
    }
  });
  Te("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, $.validateType)("Identifier")
    }
  });
  Te("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, $.validateOptionalType)("Flow"),
      specifiers: (0, $.validateOptional)((0, $.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, $.validateOptionalType)("StringLiteral"),
      default: (0, $.validateOptional)((0, $.assertValueType)("boolean"))
    }
  });
  Te("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, $.validateType)("StringLiteral"),
      exportKind: (0, $.validateOptional)((0, $.assertOneOf)("type", "value"))
    }
  });
  Te("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, $.validateType)("Flow")
    }
  });
  Te("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  Te("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, $.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, $.validate)((0, $.arrayOfType)("FunctionTypeParam")),
      rest: (0, $.validateOptionalType)("FunctionTypeParam"),
      this: (0, $.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, $.validateType)("FlowType")
    }
  });
  Te("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, $.validateOptionalType)("Identifier"),
      typeAnnotation: (0, $.validateType)("FlowType"),
      optional: (0, $.validateOptional)((0, $.assertValueType)("boolean"))
    }
  });
  Te("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, $.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, $.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Te("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  Te("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, $.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, $.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Db("InterfaceDeclaration");
  Te("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, $.validateOptional)((0, $.arrayOfType)("InterfaceExtends")),
      body: (0, $.validateType)("ObjectTypeAnnotation")
    }
  });
  Te("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, $.validate)((0, $.arrayOfType)("FlowType"))
    }
  });
  Te("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, $.validateType)("FlowType")
    }
  });
  Te("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, $.validate)((0, $.assertValueType)("number"))
    }
  });
  Te("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, $.validate)((0, $.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, $.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, $.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, $.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, $.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, $.validateOptional)((0, $.assertValueType)("boolean"))
    }
  });
  Te("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      value: (0, $.validateType)("FlowType"),
      optional: (0, $.validate)((0, $.assertValueType)("boolean")),
      static: (0, $.validate)((0, $.assertValueType)("boolean")),
      method: (0, $.validate)((0, $.assertValueType)("boolean"))
    }
  });
  Te("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, $.validateType)("FlowType"),
      static: (0, $.validate)((0, $.assertValueType)("boolean"))
    }
  });
  Te("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, $.validateOptionalType)("Identifier"),
      key: (0, $.validateType)("FlowType"),
      value: (0, $.validateType)("FlowType"),
      static: (0, $.validate)((0, $.assertValueType)("boolean")),
      variance: (0, $.validateOptionalType)("Variance")
    }
  });
  Te("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, $.validateType)(["Identifier", "StringLiteral"]),
      value: (0, $.validateType)("FlowType"),
      kind: (0, $.validate)((0, $.assertOneOf)("init", "get", "set")),
      static: (0, $.validate)((0, $.assertValueType)("boolean")),
      proto: (0, $.validate)((0, $.assertValueType)("boolean")),
      optional: (0, $.validate)((0, $.assertValueType)("boolean")),
      variance: (0, $.validateOptionalType)("Variance"),
      method: (0, $.validate)((0, $.assertValueType)("boolean"))
    }
  });
  Te("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, $.validateType)("FlowType")
    }
  });
  Te("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, $.validateOptionalType)("FlowType"),
      impltype: (0, $.validateType)("FlowType")
    }
  });
  Te("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      qualification: (0, $.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  Te("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, $.validate)((0, $.assertValueType)("string"))
    }
  });
  Te("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, $.validate)((0, $.arrayOfType)("FlowType"))
    }
  });
  Te("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, $.validateType)("FlowType")
    }
  });
  Te("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, $.validateType)("FlowType")
    }
  });
  Te("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("FlowType")
    }
  });
  Te("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, $.validateType)("Expression"),
      typeAnnotation: (0, $.validateType)("TypeAnnotation")
    }
  });
  Te("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, $.validate)((0, $.assertValueType)("string")),
      bound: (0, $.validateOptionalType)("TypeAnnotation"),
      default: (0, $.validateOptionalType)("FlowType"),
      variance: (0, $.validateOptionalType)("Variance")
    }
  });
  Te("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, $.validate)((0, $.arrayOfType)("TypeParameter"))
    }
  });
  Te("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, $.validate)((0, $.arrayOfType)("FlowType"))
    }
  });
  Te("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, $.validate)((0, $.arrayOfType)("FlowType"))
    }
  });
  Te("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, $.validate)((0, $.assertOneOf)("minus", "plus"))
    }
  });
  Te("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  Te("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      body: (0, $.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  Te("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, $.validate)((0, $.assertValueType)("boolean")),
      members: (0, $.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, $.validate)((0, $.assertValueType)("boolean"))
    }
  });
  Te("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, $.validate)((0, $.assertValueType)("boolean")),
      members: (0, $.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, $.validate)((0, $.assertValueType)("boolean"))
    }
  });
  Te("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, $.validate)((0, $.assertValueType)("boolean")),
      members: (0, $.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, $.validate)((0, $.assertValueType)("boolean"))
    }
  });
  Te("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, $.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, $.validate)((0, $.assertValueType)("boolean"))
    }
  });
  Te("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      init: (0, $.validateType)("BooleanLiteral")
    }
  });
  Te("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      init: (0, $.validateType)("NumericLiteral")
    }
  });
  Te("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, $.validateType)("Identifier"),
      init: (0, $.validateType)("StringLiteral")
    }
  });
  Te("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, $.validateType)("Identifier")
    }
  });
  Te("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, $.validateType)("FlowType"),
      indexType: (0, $.validateType)("FlowType")
    }
  });
  Te("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, $.validateType)("FlowType"),
      indexType: (0, $.validateType)("FlowType"),
      optional: (0, $.validate)((0, $.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var FR = y(() => {
  "use strict";
  var Et = ci(), rs = (0, Et.defineAliasedType)("JSX");
  rs("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, Et.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, Et.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  rs("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, Et.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  rs("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, Et.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, Et.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, Et.chain)((0, Et.assertValueType)("array"), (0, Et.assertEach)((0, Et.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, Et.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  rs("JSXEmptyExpression", {});
  rs("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, Et.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  rs("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, Et.assertNodeType)("Expression")
      }
    }
  });
  rs("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Et.assertValueType)("string")
      }
    }
  });
  rs("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, Et.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, Et.assertNodeType)("JSXIdentifier")
      }
    }
  });
  rs("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, Et.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, Et.assertNodeType)("JSXIdentifier")
      }
    }
  });
  rs("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, Et.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, Et.chain)((0, Et.assertValueType)("array"), (0, Et.assertEach)((0, Et.assertNodeType)("JSXAttribute", "JSXSpreadAttrib\
ute")))
      },
      typeParameters: {
        validate: (0, Et.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  rs("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, Et.assertNodeType)("Expression")
      }
    }
  });
  rs("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, Et.assertValueType)("string")
      }
    }
  });
  rs("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, Et.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, Et.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, Et.chain)((0, Et.assertValueType)("array"), (0, Et.assertEach)((0, Et.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  rs("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  rs("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Ob = y((Qi) => {
  "use strict";
  Object.defineProperty(Qi, "__esModule", {
    value: !0
  });
  Qi.PLACEHOLDERS_FLIPPED_ALIAS = Qi.PLACEHOLDERS_ALIAS = Qi.PLACEHOLDERS = void 0;
  var ase = ci(), ose = Qi.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "Class\
Body", "Pattern"], _b = Qi.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let e of ose) {
    let t = ase.ALIAS_KEYS[e];
    t != null && t.length && (_b[e] = t);
  }
  var Ib = Qi.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(_b).forEach((e) => {
    _b[e].forEach((t) => {
      hasOwnProperty.call(Ib, t) || (Ib[t] = []), Ib[t].push(e);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var LR = y(() => {
  "use strict";
  var Hp = ci(), lse = Ob(), Nb = (0, Hp.defineAliasedType)("Miscellaneous");
  Nb("Noop", {
    visitor: []
  });
  Nb("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, Hp.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, Hp.assertOneOf)(...lse.PLACEHOLDERS)
      }
    }
  });
  Nb("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Hp.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var BR = y(() => {
  "use strict";
  var gt = ci();
  (0, gt.default)("ArgumentPlaceholder", {});
  (0, gt.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, gt.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, gt.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, gt.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, gt.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, gt.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, gt.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, gt.assertNodeType)("Expression")
      }
    }
  });
  (0, gt.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, gt.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, gt.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, gt.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, gt.assertNodeType)("Identifier")
      }
    }
  });
  (0, gt.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, gt.chain)((0, gt.assertValueType)("array"), (0, gt.assertEach)((0, gt.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, gt.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, gt.chain)((0, gt.assertValueType)("array"), (0, gt.assertEach)((0, gt.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, gt.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, gt.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, gt.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, gt.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, gt.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, gt.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, gt.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, gt.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, gt.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, gt.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var HR = y(() => {
  "use strict";
  var X = ci(), MR = wb(), use = tl(), Le = (0, X.defineAliasedType)("TypeScript"), gs = (0, X.assertValueType)("boolean"), jR = /* @__PURE__ */ i(
  () => ({
    returnType: {
      validate: (0, X.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, X.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  Le("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, X.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, X.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  });
  Le("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, MR.functionDeclarationCommon)(), jR())
  });
  Le("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, MR.classMethodOrDeclareMethodCommon)(), jR())
  });
  Le("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, X.validateType)("TSEntityName"),
      right: (0, X.validateType)("Identifier")
    }
  });
  var Gp = /* @__PURE__ */ i(() => ({
    typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, X.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), qR = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Gp()
  };
  Le("TSCallSignatureDeclaration", qR);
  Le("TSConstructSignatureDeclaration", qR);
  var $R = /* @__PURE__ */ i(() => ({
    key: (0, X.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, X.validateOptional)(gs)
  }), "namedTypeElementCommon");
  Le("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, $R(), {
      readonly: (0, X.validateOptional)(gs),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, X.assertOneOf)("get", "set")
      }
    })
  });
  Le("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Gp(), $R(), {
      kind: {
        validate: (0, X.assertOneOf)("method", "get", "set")
      }
    })
  });
  Le("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, X.validateOptional)(gs),
      static: (0, X.validateOptional)(gs),
      parameters: (0, X.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var cse = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeywor\
d", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let e of cse)
    Le(e, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  Le("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var UR = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  Le("TSFunctionType", Object.assign({}, UR, {
    fields: Gp()
  }));
  Le("TSConstructorType", Object.assign({}, UR, {
    fields: Object.assign({}, Gp(), {
      abstract: (0, X.validateOptional)(gs)
    })
  }));
  Le("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, X.validateType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Le("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, X.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, X.validateOptional)(gs)
    }
  });
  Le("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, X.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Le("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, X.validateArrayOfType)("TSTypeElement")
    }
  });
  Le("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, X.validateType)("TSType")
    }
  });
  Le("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, X.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  Le("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Le("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Le("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, X.validateType)("Identifier"),
      optional: {
        validate: gs,
        default: !1
      },
      elementType: (0, X.validateType)("TSType")
    }
  });
  var VR = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, X.validateArrayOfType)("TSType")
    }
  };
  Le("TSUnionType", VR);
  Le("TSIntersectionType", VR);
  Le("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, X.validateType)("TSType"),
      extendsType: (0, X.validateType)("TSType"),
      trueType: (0, X.validateType)("TSType"),
      falseType: (0, X.validateType)("TSType")
    }
  });
  Le("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, X.validateType)("TSTypeParameter")
    }
  });
  Le("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Le("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, X.validate)((0, X.assertValueType)("string")),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Le("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, X.validateType)("TSType"),
      indexType: (0, X.validateType)("TSType")
    }
  });
  Le("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, X.validateOptional)((0, X.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, X.validateType)("TSTypeParameter"),
      optional: (0, X.validateOptional)((0, X.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, X.validateOptionalType)("TSType"),
      nameType: (0, X.validateOptionalType)("TSType")
    }
  });
  Le("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let e = (0, X.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, X.assertOneOf)("-"), r = (0, X.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function s(n, a, o) {
            (0, use.default)("UnaryExpression", o) ? (t(o, "operator", o.operator), e(o, "argument", o.argument)) : r(n, a, o);
          }
          return i(s, "validator"), s.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], s;
        }()
      }
    }
  });
  Le("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, X.validateType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Le("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, X.validateOptional)(gs),
      id: (0, X.validateType)("Identifier"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, X.validateOptional)((0, X.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, X.validateType)("TSInterfaceBody")
    }
  });
  Le("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, X.validateArrayOfType)("TSTypeElement")
    }
  });
  Le("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, X.validateOptional)(gs),
      id: (0, X.validateType)("Identifier"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Le("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, X.validateType)("Expression"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var WR = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, X.validateType)("Expression"),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  };
  Le("TSAsExpression", WR);
  Le("TSSatisfiesExpression", WR);
  Le("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType"),
      expression: (0, X.validateType)("Expression")
    }
  });
  Le("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, X.validateOptional)(gs),
      const: (0, X.validateOptional)(gs),
      id: (0, X.validateType)("Identifier"),
      members: (0, X.validateArrayOfType)("TSEnumMember"),
      initializer: (0, X.validateOptionalType)("Expression")
    }
  });
  Le("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, X.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, X.validateOptionalType)("Expression")
    }
  });
  Le("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, X.validateOptional)(gs),
      global: (0, X.validateOptional)(gs),
      id: (0, X.validateType)(["Identifier", "StringLiteral"]),
      body: (0, X.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  Le("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, X.validateArrayOfType)("Statement")
    }
  });
  Le("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, X.validateType)("StringLiteral"),
      qualifier: (0, X.validateOptionalType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, X.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  Le("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, X.validate)(gs),
      id: (0, X.validateType)("Identifier"),
      moduleReference: (0, X.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, X.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  Le("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("StringLiteral")
    }
  });
  Le("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("Expression")
    }
  });
  Le("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("Expression")
    }
  });
  Le("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, X.validateType)("Identifier")
    }
  });
  Le("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, X.assertNodeType)("TSType")
      }
    }
  });
  Le("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("TSType")))
      }
    }
  });
  Le("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  Le("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, X.assertValueType)("string")
      },
      in: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, X.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, X.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var GR = y((Kp) => {
  "use strict";
  Object.defineProperty(Kp, "__esModule", {
    value: !0
  });
  Kp.DEPRECATED_ALIASES = void 0;
  var pXe = Kp.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var Ls = y((ss) => {
  "use strict";
  Object.defineProperty(ss, "__esModule", {
    value: !0
  });
  Object.defineProperty(ss, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ar.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(ss, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ar.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(ss, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Rb.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(ss, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ar.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(ss, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ar.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(ss, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ar.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(ss, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ar.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(ss, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return sc.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(ss, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return sc.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(ss, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return sc.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  ss.TYPES = void 0;
  Object.defineProperty(ss, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ar.VISITOR_KEYS;
    }, "get")
  });
  var Zi = cR();
  wb();
  kR();
  FR();
  LR();
  BR();
  HR();
  var Ar = ci(), sc = Ob(), Rb = GR();
  Object.keys(Rb.DEPRECATED_ALIASES).forEach((e) => {
    Ar.FLIPPED_ALIAS_KEYS[e] = Ar.FLIPPED_ALIAS_KEYS[Rb.DEPRECATED_ALIASES[e]];
  });
  Zi(Ar.VISITOR_KEYS);
  Zi(Ar.ALIAS_KEYS);
  Zi(Ar.FLIPPED_ALIAS_KEYS);
  Zi(Ar.NODE_FIELDS);
  Zi(Ar.BUILDER_KEYS);
  Zi(Ar.DEPRECATED_KEYS);
  Zi(sc.PLACEHOLDERS_ALIAS);
  Zi(sc.PLACEHOLDERS_FLIPPED_ALIAS);
  var hXe = ss.TYPES = [].concat(Object.keys(Ar.VISITOR_KEYS), Object.keys(Ar.FLIPPED_ALIAS_KEYS), Object.keys(Ar.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var Vp = y((nc) => {
  "use strict";
  Object.defineProperty(nc, "__esModule", {
    value: !0
  });
  nc.default = fse;
  nc.validateChild = XR;
  nc.validateField = YR;
  var KR = Ls();
  function fse(e, t, r) {
    if (!e) return;
    let s = KR.NODE_FIELDS[e.type];
    if (!s) return;
    let n = s[t];
    YR(e, t, r, n), XR(e, t, r);
  }
  i(fse, "validate");
  function YR(e, t, r, s) {
    s != null && s.validate && (s.optional && r == null || s.validate(e, t, r));
  }
  i(YR, "validateField");
  function XR(e, t, r) {
    if (r == null) return;
    let s = KR.NODE_PARENT_VALIDATIONS[r.type];
    s && s(e, t, r);
  }
  i(XR, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/validateNode.js
var zR = y((kb) => {
  "use strict";
  Object.defineProperty(kb, "__esModule", {
    value: !0
  });
  kb.default = hse;
  var pse = Vp(), dse = Ne();
  function hse(e) {
    let t = dse.BUILDER_KEYS[e.type];
    for (let r of t)
      (0, pse.default)(e, r, e[r]);
    return e;
  }
  i(hse, "validateNode");
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var ns = y((S) => {
  "use strict";
  Object.defineProperty(S, "__esModule", {
    value: !0
  });
  S.anyTypeAnnotation = Hne;
  S.argumentPlaceholder = vae;
  S.arrayExpression = mse;
  S.arrayPattern = cne;
  S.arrayTypeAnnotation = Gne;
  S.arrowFunctionExpression = fne;
  S.assignmentExpression = yse;
  S.assignmentPattern = une;
  S.awaitExpression = Rne;
  S.bigIntLiteral = Fne;
  S.binaryExpression = gse;
  S.bindExpression = Sae;
  S.blockStatement = Sse;
  S.booleanLiteral = $se;
  S.booleanLiteralTypeAnnotation = Yne;
  S.booleanTypeAnnotation = Kne;
  S.breakStatement = Tse;
  S.callExpression = xse;
  S.catchClause = Pse;
  S.classAccessorProperty = qne;
  S.classBody = pne;
  S.classDeclaration = hne;
  S.classExpression = dne;
  S.classImplements = zne;
  S.classMethod = Cne;
  S.classPrivateMethod = Une;
  S.classPrivateProperty = $ne;
  S.classProperty = jne;
  S.conditionalExpression = Ase;
  S.continueStatement = Cse;
  S.debuggerStatement = wse;
  S.decimalLiteral = Dae;
  S.declareClass = Jne;
  S.declareExportAllDeclaration = aie;
  S.declareExportDeclaration = iie;
  S.declareFunction = Qne;
  S.declareInterface = Zne;
  S.declareModule = eie;
  S.declareModuleExports = tie;
  S.declareOpaqueType = sie;
  S.declareTypeAlias = rie;
  S.declareVariable = nie;
  S.declaredPredicate = oie;
  S.decorator = xae;
  S.directive = Ese;
  S.directiveLiteral = vse;
  S.doExpression = Pae;
  S.doWhileStatement = Dse;
  S.emptyStatement = Ise;
  S.emptyTypeAnnotation = bie;
  S.enumBooleanBody = Gie;
  S.enumBooleanMember = zie;
  S.enumDeclaration = Hie;
  S.enumDefaultedMember = Zie;
  S.enumNumberBody = Kie;
  S.enumNumberMember = Jie;
  S.enumStringBody = Yie;
  S.enumStringMember = Qie;
  S.enumSymbolBody = Xie;
  S.existsTypeAnnotation = lie;
  S.exportAllDeclaration = mne;
  S.exportDefaultDeclaration = yne;
  S.exportDefaultSpecifier = Aae;
  S.exportNamedDeclaration = gne;
  S.exportNamespaceSpecifier = Lne;
  S.exportSpecifier = bne;
  S.expressionStatement = _se;
  S.file = Ose;
  S.forInStatement = Nse;
  S.forOfStatement = Ene;
  S.forStatement = Rse;
  S.functionDeclaration = kse;
  S.functionExpression = Fse;
  S.functionTypeAnnotation = uie;
  S.functionTypeParam = cie;
  S.genericTypeAnnotation = fie;
  S.identifier = Lse;
  S.ifStatement = Bse;
  S.import = kne;
  S.importAttribute = Tae;
  S.importDeclaration = vne;
  S.importDefaultSpecifier = Sne;
  S.importExpression = Pne;
  S.importNamespaceSpecifier = Tne;
  S.importSpecifier = xne;
  S.indexedAccessType = eae;
  S.inferredPredicate = pie;
  S.interfaceDeclaration = hie;
  S.interfaceExtends = die;
  S.interfaceTypeAnnotation = mie;
  S.interpreterDirective = bse;
  S.intersectionTypeAnnotation = yie;
  S.jSXAttribute = S.jsxAttribute = rae;
  S.jSXClosingElement = S.jsxClosingElement = sae;
  S.jSXClosingFragment = S.jsxClosingFragment = yae;
  S.jSXElement = S.jsxElement = nae;
  S.jSXEmptyExpression = S.jsxEmptyExpression = iae;
  S.jSXExpressionContainer = S.jsxExpressionContainer = aae;
  S.jSXFragment = S.jsxFragment = hae;
  S.jSXIdentifier = S.jsxIdentifier = lae;
  S.jSXMemberExpression = S.jsxMemberExpression = uae;
  S.jSXNamespacedName = S.jsxNamespacedName = cae;
  S.jSXOpeningElement = S.jsxOpeningElement = fae;
  S.jSXOpeningFragment = S.jsxOpeningFragment = mae;
  S.jSXSpreadAttribute = S.jsxSpreadAttribute = pae;
  S.jSXSpreadChild = S.jsxSpreadChild = oae;
  S.jSXText = S.jsxText = dae;
  S.labeledStatement = Mse;
  S.logicalExpression = Use;
  S.memberExpression = Vse;
  S.metaProperty = Ane;
  S.mixedTypeAnnotation = gie;
  S.moduleExpression = Iae;
  S.newExpression = Wse;
  S.noop = gae;
  S.nullLiteral = qse;
  S.nullLiteralTypeAnnotation = Xne;
  S.nullableTypeAnnotation = Eie;
  S.numberLiteral = Hoe;
  S.numberLiteralTypeAnnotation = vie;
  S.numberTypeAnnotation = Sie;
  S.numericLiteral = JR;
  S.objectExpression = Gse;
  S.objectMethod = Kse;
  S.objectPattern = wne;
  S.objectProperty = Yse;
  S.objectTypeAnnotation = Tie;
  S.objectTypeCallProperty = Pie;
  S.objectTypeIndexer = Aie;
  S.objectTypeInternalSlot = xie;
  S.objectTypeProperty = Cie;
  S.objectTypeSpreadProperty = wie;
  S.opaqueType = Die;
  S.optionalCallExpression = Mne;
  S.optionalIndexedAccessType = tae;
  S.optionalMemberExpression = Bne;
  S.parenthesizedExpression = Jse;
  S.pipelineBareFunction = Nae;
  S.pipelinePrimaryTopicReference = Rae;
  S.pipelineTopicExpression = Oae;
  S.placeholder = bae;
  S.privateName = Vne;
  S.program = Hse;
  S.qualifiedTypeIdentifier = Iie;
  S.recordExpression = Cae;
  S.regExpLiteral = QR;
  S.regexLiteral = Goe;
  S.restElement = ZR;
  S.restProperty = Koe;
  S.returnStatement = Xse;
  S.sequenceExpression = zse;
  S.spreadElement = ek;
  S.spreadProperty = Yoe;
  S.staticBlock = Wne;
  S.stringLiteral = jse;
  S.stringLiteralTypeAnnotation = _ie;
  S.stringTypeAnnotation = Oie;
  S.super = Dne;
  S.switchCase = Qse;
  S.switchStatement = Zse;
  S.symbolTypeAnnotation = Nie;
  S.taggedTemplateExpression = Ine;
  S.templateElement = _ne;
  S.templateLiteral = One;
  S.thisExpression = ene;
  S.thisTypeAnnotation = Rie;
  S.throwStatement = tne;
  S.topicReference = _ae;
  S.tryStatement = rne;
  S.tSAnyKeyword = S.tsAnyKeyword = Vae;
  S.tSArrayType = S.tsArrayType = uoe;
  S.tSAsExpression = S.tsAsExpression = Doe;
  S.tSBigIntKeyword = S.tsBigIntKeyword = Hae;
  S.tSBooleanKeyword = S.tsBooleanKeyword = Wae;
  S.tSCallSignatureDeclaration = S.tsCallSignatureDeclaration = Mae;
  S.tSConditionalType = S.tsConditionalType = yoe;
  S.tSConstructSignatureDeclaration = S.tsConstructSignatureDeclaration = jae;
  S.tSConstructorType = S.tsConstructorType = noe;
  S.tSDeclareFunction = S.tsDeclareFunction = Fae;
  S.tSDeclareMethod = S.tsDeclareMethod = Lae;
  S.tSEnumDeclaration = S.tsEnumDeclaration = Ooe;
  S.tSEnumMember = S.tsEnumMember = Noe;
  S.tSExportAssignment = S.tsExportAssignment = joe;
  S.tSExpressionWithTypeArguments = S.tsExpressionWithTypeArguments = xoe;
  S.tSExternalModuleReference = S.tsExternalModuleReference = Boe;
  S.tSFunctionType = S.tsFunctionType = soe;
  S.tSImportEqualsDeclaration = S.tsImportEqualsDeclaration = Loe;
  S.tSImportType = S.tsImportType = Foe;
  S.tSIndexSignature = S.tsIndexSignature = Uae;
  S.tSIndexedAccessType = S.tsIndexedAccessType = voe;
  S.tSInferType = S.tsInferType = goe;
  S.tSInstantiationExpression = S.tsInstantiationExpression = woe;
  S.tSInterfaceBody = S.tsInterfaceBody = Aoe;
  S.tSInterfaceDeclaration = S.tsInterfaceDeclaration = Poe;
  S.tSIntersectionType = S.tsIntersectionType = moe;
  S.tSIntrinsicKeyword = S.tsIntrinsicKeyword = Gae;
  S.tSLiteralType = S.tsLiteralType = Toe;
  S.tSMappedType = S.tsMappedType = Soe;
  S.tSMethodSignature = S.tsMethodSignature = $ae;
  S.tSModuleBlock = S.tsModuleBlock = koe;
  S.tSModuleDeclaration = S.tsModuleDeclaration = Roe;
  S.tSNamedTupleMember = S.tsNamedTupleMember = doe;
  S.tSNamespaceExportDeclaration = S.tsNamespaceExportDeclaration = qoe;
  S.tSNeverKeyword = S.tsNeverKeyword = Kae;
  S.tSNonNullExpression = S.tsNonNullExpression = Moe;
  S.tSNullKeyword = S.tsNullKeyword = Yae;
  S.tSNumberKeyword = S.tsNumberKeyword = Xae;
  S.tSObjectKeyword = S.tsObjectKeyword = zae;
  S.tSOptionalType = S.tsOptionalType = foe;
  S.tSParameterProperty = S.tsParameterProperty = kae;
  S.tSParenthesizedType = S.tsParenthesizedType = boe;
  S.tSPropertySignature = S.tsPropertySignature = qae;
  S.tSQualifiedName = S.tsQualifiedName = Bae;
  S.tSRestType = S.tsRestType = poe;
  S.tSSatisfiesExpression = S.tsSatisfiesExpression = Ioe;
  S.tSStringKeyword = S.tsStringKeyword = Jae;
  S.tSSymbolKeyword = S.tsSymbolKeyword = Qae;
  S.tSThisType = S.tsThisType = roe;
  S.tSTupleType = S.tsTupleType = coe;
  S.tSTypeAliasDeclaration = S.tsTypeAliasDeclaration = Coe;
  S.tSTypeAnnotation = S.tsTypeAnnotation = $oe;
  S.tSTypeAssertion = S.tsTypeAssertion = _oe;
  S.tSTypeLiteral = S.tsTypeLiteral = loe;
  S.tSTypeOperator = S.tsTypeOperator = Eoe;
  S.tSTypeParameter = S.tsTypeParameter = Woe;
  S.tSTypeParameterDeclaration = S.tsTypeParameterDeclaration = Voe;
  S.tSTypeParameterInstantiation = S.tsTypeParameterInstantiation = Uoe;
  S.tSTypePredicate = S.tsTypePredicate = aoe;
  S.tSTypeQuery = S.tsTypeQuery = ooe;
  S.tSTypeReference = S.tsTypeReference = ioe;
  S.tSUndefinedKeyword = S.tsUndefinedKeyword = Zae;
  S.tSUnionType = S.tsUnionType = hoe;
  S.tSUnknownKeyword = S.tsUnknownKeyword = eoe;
  S.tSVoidKeyword = S.tsVoidKeyword = toe;
  S.tupleExpression = wae;
  S.tupleTypeAnnotation = kie;
  S.typeAlias = Lie;
  S.typeAnnotation = Bie;
  S.typeCastExpression = Mie;
  S.typeParameter = jie;
  S.typeParameterDeclaration = qie;
  S.typeParameterInstantiation = $ie;
  S.typeofTypeAnnotation = Fie;
  S.unaryExpression = sne;
  S.unionTypeAnnotation = Uie;
  S.updateExpression = nne;
  S.v8IntrinsicIdentifier = Eae;
  S.variableDeclaration = ine;
  S.variableDeclarator = ane;
  S.variance = Vie;
  S.voidTypeAnnotation = Wie;
  S.whileStatement = one;
  S.withStatement = lne;
  S.yieldExpression = Nne;
  var B = zR(), Yp = Yu();
  function mse(e = []) {
    return (0, B.default)({
      type: "ArrayExpression",
      elements: e
    });
  }
  i(mse, "arrayExpression");
  function yse(e, t, r) {
    return (0, B.default)({
      type: "AssignmentExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  i(yse, "assignmentExpression");
  function gse(e, t, r) {
    return (0, B.default)({
      type: "BinaryExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  i(gse, "binaryExpression");
  function bse(e) {
    return (0, B.default)({
      type: "InterpreterDirective",
      value: e
    });
  }
  i(bse, "interpreterDirective");
  function Ese(e) {
    return (0, B.default)({
      type: "Directive",
      value: e
    });
  }
  i(Ese, "directive");
  function vse(e) {
    return (0, B.default)({
      type: "DirectiveLiteral",
      value: e
    });
  }
  i(vse, "directiveLiteral");
  function Sse(e, t = []) {
    return (0, B.default)({
      type: "BlockStatement",
      body: e,
      directives: t
    });
  }
  i(Sse, "blockStatement");
  function Tse(e = null) {
    return (0, B.default)({
      type: "BreakStatement",
      label: e
    });
  }
  i(Tse, "breakStatement");
  function xse(e, t) {
    return (0, B.default)({
      type: "CallExpression",
      callee: e,
      arguments: t
    });
  }
  i(xse, "callExpression");
  function Pse(e = null, t) {
    return (0, B.default)({
      type: "CatchClause",
      param: e,
      body: t
    });
  }
  i(Pse, "catchClause");
  function Ase(e, t, r) {
    return (0, B.default)({
      type: "ConditionalExpression",
      test: e,
      consequent: t,
      alternate: r
    });
  }
  i(Ase, "conditionalExpression");
  function Cse(e = null) {
    return (0, B.default)({
      type: "ContinueStatement",
      label: e
    });
  }
  i(Cse, "continueStatement");
  function wse() {
    return {
      type: "DebuggerStatement"
    };
  }
  i(wse, "debuggerStatement");
  function Dse(e, t) {
    return (0, B.default)({
      type: "DoWhileStatement",
      test: e,
      body: t
    });
  }
  i(Dse, "doWhileStatement");
  function Ise() {
    return {
      type: "EmptyStatement"
    };
  }
  i(Ise, "emptyStatement");
  function _se(e) {
    return (0, B.default)({
      type: "ExpressionStatement",
      expression: e
    });
  }
  i(_se, "expressionStatement");
  function Ose(e, t = null, r = null) {
    return (0, B.default)({
      type: "File",
      program: e,
      comments: t,
      tokens: r
    });
  }
  i(Ose, "file");
  function Nse(e, t, r) {
    return (0, B.default)({
      type: "ForInStatement",
      left: e,
      right: t,
      body: r
    });
  }
  i(Nse, "forInStatement");
  function Rse(e = null, t = null, r = null, s) {
    return (0, B.default)({
      type: "ForStatement",
      init: e,
      test: t,
      update: r,
      body: s
    });
  }
  i(Rse, "forStatement");
  function kse(e = null, t, r, s = !1, n = !1) {
    return (0, B.default)({
      type: "FunctionDeclaration",
      id: e,
      params: t,
      body: r,
      generator: s,
      async: n
    });
  }
  i(kse, "functionDeclaration");
  function Fse(e = null, t, r, s = !1, n = !1) {
    return (0, B.default)({
      type: "FunctionExpression",
      id: e,
      params: t,
      body: r,
      generator: s,
      async: n
    });
  }
  i(Fse, "functionExpression");
  function Lse(e) {
    return (0, B.default)({
      type: "Identifier",
      name: e
    });
  }
  i(Lse, "identifier");
  function Bse(e, t, r = null) {
    return (0, B.default)({
      type: "IfStatement",
      test: e,
      consequent: t,
      alternate: r
    });
  }
  i(Bse, "ifStatement");
  function Mse(e, t) {
    return (0, B.default)({
      type: "LabeledStatement",
      label: e,
      body: t
    });
  }
  i(Mse, "labeledStatement");
  function jse(e) {
    return (0, B.default)({
      type: "StringLiteral",
      value: e
    });
  }
  i(jse, "stringLiteral");
  function JR(e) {
    return (0, B.default)({
      type: "NumericLiteral",
      value: e
    });
  }
  i(JR, "numericLiteral");
  function qse() {
    return {
      type: "NullLiteral"
    };
  }
  i(qse, "nullLiteral");
  function $se(e) {
    return (0, B.default)({
      type: "BooleanLiteral",
      value: e
    });
  }
  i($se, "booleanLiteral");
  function QR(e, t = "") {
    return (0, B.default)({
      type: "RegExpLiteral",
      pattern: e,
      flags: t
    });
  }
  i(QR, "regExpLiteral");
  function Use(e, t, r) {
    return (0, B.default)({
      type: "LogicalExpression",
      operator: e,
      left: t,
      right: r
    });
  }
  i(Use, "logicalExpression");
  function Vse(e, t, r = !1, s = null) {
    return (0, B.default)({
      type: "MemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: s
    });
  }
  i(Vse, "memberExpression");
  function Wse(e, t) {
    return (0, B.default)({
      type: "NewExpression",
      callee: e,
      arguments: t
    });
  }
  i(Wse, "newExpression");
  function Hse(e, t = [], r = "script", s = null) {
    return (0, B.default)({
      type: "Program",
      body: e,
      directives: t,
      sourceType: r,
      interpreter: s
    });
  }
  i(Hse, "program");
  function Gse(e) {
    return (0, B.default)({
      type: "ObjectExpression",
      properties: e
    });
  }
  i(Gse, "objectExpression");
  function Kse(e = "method", t, r, s, n = !1, a = !1, o = !1) {
    return (0, B.default)({
      type: "ObjectMethod",
      kind: e,
      key: t,
      params: r,
      body: s,
      computed: n,
      generator: a,
      async: o
    });
  }
  i(Kse, "objectMethod");
  function Yse(e, t, r = !1, s = !1, n = null) {
    return (0, B.default)({
      type: "ObjectProperty",
      key: e,
      value: t,
      computed: r,
      shorthand: s,
      decorators: n
    });
  }
  i(Yse, "objectProperty");
  function ZR(e) {
    return (0, B.default)({
      type: "RestElement",
      argument: e
    });
  }
  i(ZR, "restElement");
  function Xse(e = null) {
    return (0, B.default)({
      type: "ReturnStatement",
      argument: e
    });
  }
  i(Xse, "returnStatement");
  function zse(e) {
    return (0, B.default)({
      type: "SequenceExpression",
      expressions: e
    });
  }
  i(zse, "sequenceExpression");
  function Jse(e) {
    return (0, B.default)({
      type: "ParenthesizedExpression",
      expression: e
    });
  }
  i(Jse, "parenthesizedExpression");
  function Qse(e = null, t) {
    return (0, B.default)({
      type: "SwitchCase",
      test: e,
      consequent: t
    });
  }
  i(Qse, "switchCase");
  function Zse(e, t) {
    return (0, B.default)({
      type: "SwitchStatement",
      discriminant: e,
      cases: t
    });
  }
  i(Zse, "switchStatement");
  function ene() {
    return {
      type: "ThisExpression"
    };
  }
  i(ene, "thisExpression");
  function tne(e) {
    return (0, B.default)({
      type: "ThrowStatement",
      argument: e
    });
  }
  i(tne, "throwStatement");
  function rne(e, t = null, r = null) {
    return (0, B.default)({
      type: "TryStatement",
      block: e,
      handler: t,
      finalizer: r
    });
  }
  i(rne, "tryStatement");
  function sne(e, t, r = !0) {
    return (0, B.default)({
      type: "UnaryExpression",
      operator: e,
      argument: t,
      prefix: r
    });
  }
  i(sne, "unaryExpression");
  function nne(e, t, r = !1) {
    return (0, B.default)({
      type: "UpdateExpression",
      operator: e,
      argument: t,
      prefix: r
    });
  }
  i(nne, "updateExpression");
  function ine(e, t) {
    return (0, B.default)({
      type: "VariableDeclaration",
      kind: e,
      declarations: t
    });
  }
  i(ine, "variableDeclaration");
  function ane(e, t = null) {
    return (0, B.default)({
      type: "VariableDeclarator",
      id: e,
      init: t
    });
  }
  i(ane, "variableDeclarator");
  function one(e, t) {
    return (0, B.default)({
      type: "WhileStatement",
      test: e,
      body: t
    });
  }
  i(one, "whileStatement");
  function lne(e, t) {
    return (0, B.default)({
      type: "WithStatement",
      object: e,
      body: t
    });
  }
  i(lne, "withStatement");
  function une(e, t) {
    return (0, B.default)({
      type: "AssignmentPattern",
      left: e,
      right: t
    });
  }
  i(une, "assignmentPattern");
  function cne(e) {
    return (0, B.default)({
      type: "ArrayPattern",
      elements: e
    });
  }
  i(cne, "arrayPattern");
  function fne(e, t, r = !1) {
    return (0, B.default)({
      type: "ArrowFunctionExpression",
      params: e,
      body: t,
      async: r,
      expression: null
    });
  }
  i(fne, "arrowFunctionExpression");
  function pne(e) {
    return (0, B.default)({
      type: "ClassBody",
      body: e
    });
  }
  i(pne, "classBody");
  function dne(e = null, t = null, r, s = null) {
    return (0, B.default)({
      type: "ClassExpression",
      id: e,
      superClass: t,
      body: r,
      decorators: s
    });
  }
  i(dne, "classExpression");
  function hne(e = null, t = null, r, s = null) {
    return (0, B.default)({
      type: "ClassDeclaration",
      id: e,
      superClass: t,
      body: r,
      decorators: s
    });
  }
  i(hne, "classDeclaration");
  function mne(e) {
    return (0, B.default)({
      type: "ExportAllDeclaration",
      source: e
    });
  }
  i(mne, "exportAllDeclaration");
  function yne(e) {
    return (0, B.default)({
      type: "ExportDefaultDeclaration",
      declaration: e
    });
  }
  i(yne, "exportDefaultDeclaration");
  function gne(e = null, t = [], r = null) {
    return (0, B.default)({
      type: "ExportNamedDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    });
  }
  i(gne, "exportNamedDeclaration");
  function bne(e, t) {
    return (0, B.default)({
      type: "ExportSpecifier",
      local: e,
      exported: t
    });
  }
  i(bne, "exportSpecifier");
  function Ene(e, t, r, s = !1) {
    return (0, B.default)({
      type: "ForOfStatement",
      left: e,
      right: t,
      body: r,
      await: s
    });
  }
  i(Ene, "forOfStatement");
  function vne(e, t) {
    return (0, B.default)({
      type: "ImportDeclaration",
      specifiers: e,
      source: t
    });
  }
  i(vne, "importDeclaration");
  function Sne(e) {
    return (0, B.default)({
      type: "ImportDefaultSpecifier",
      local: e
    });
  }
  i(Sne, "importDefaultSpecifier");
  function Tne(e) {
    return (0, B.default)({
      type: "ImportNamespaceSpecifier",
      local: e
    });
  }
  i(Tne, "importNamespaceSpecifier");
  function xne(e, t) {
    return (0, B.default)({
      type: "ImportSpecifier",
      local: e,
      imported: t
    });
  }
  i(xne, "importSpecifier");
  function Pne(e, t = null) {
    return (0, B.default)({
      type: "ImportExpression",
      source: e,
      options: t
    });
  }
  i(Pne, "importExpression");
  function Ane(e, t) {
    return (0, B.default)({
      type: "MetaProperty",
      meta: e,
      property: t
    });
  }
  i(Ane, "metaProperty");
  function Cne(e = "method", t, r, s, n = !1, a = !1, o = !1, l = !1) {
    return (0, B.default)({
      type: "ClassMethod",
      kind: e,
      key: t,
      params: r,
      body: s,
      computed: n,
      static: a,
      generator: o,
      async: l
    });
  }
  i(Cne, "classMethod");
  function wne(e) {
    return (0, B.default)({
      type: "ObjectPattern",
      properties: e
    });
  }
  i(wne, "objectPattern");
  function ek(e) {
    return (0, B.default)({
      type: "SpreadElement",
      argument: e
    });
  }
  i(ek, "spreadElement");
  function Dne() {
    return {
      type: "Super"
    };
  }
  i(Dne, "_super");
  function Ine(e, t) {
    return (0, B.default)({
      type: "TaggedTemplateExpression",
      tag: e,
      quasi: t
    });
  }
  i(Ine, "taggedTemplateExpression");
  function _ne(e, t = !1) {
    return (0, B.default)({
      type: "TemplateElement",
      value: e,
      tail: t
    });
  }
  i(_ne, "templateElement");
  function One(e, t) {
    return (0, B.default)({
      type: "TemplateLiteral",
      quasis: e,
      expressions: t
    });
  }
  i(One, "templateLiteral");
  function Nne(e = null, t = !1) {
    return (0, B.default)({
      type: "YieldExpression",
      argument: e,
      delegate: t
    });
  }
  i(Nne, "yieldExpression");
  function Rne(e) {
    return (0, B.default)({
      type: "AwaitExpression",
      argument: e
    });
  }
  i(Rne, "awaitExpression");
  function kne() {
    return {
      type: "Import"
    };
  }
  i(kne, "_import");
  function Fne(e) {
    return (0, B.default)({
      type: "BigIntLiteral",
      value: e
    });
  }
  i(Fne, "bigIntLiteral");
  function Lne(e) {
    return (0, B.default)({
      type: "ExportNamespaceSpecifier",
      exported: e
    });
  }
  i(Lne, "exportNamespaceSpecifier");
  function Bne(e, t, r = !1, s) {
    return (0, B.default)({
      type: "OptionalMemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: s
    });
  }
  i(Bne, "optionalMemberExpression");
  function Mne(e, t, r) {
    return (0, B.default)({
      type: "OptionalCallExpression",
      callee: e,
      arguments: t,
      optional: r
    });
  }
  i(Mne, "optionalCallExpression");
  function jne(e, t = null, r = null, s = null, n = !1, a = !1) {
    return (0, B.default)({
      type: "ClassProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: s,
      computed: n,
      static: a
    });
  }
  i(jne, "classProperty");
  function qne(e, t = null, r = null, s = null, n = !1, a = !1) {
    return (0, B.default)({
      type: "ClassAccessorProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: s,
      computed: n,
      static: a
    });
  }
  i(qne, "classAccessorProperty");
  function $ne(e, t = null, r = null, s = !1) {
    return (0, B.default)({
      type: "ClassPrivateProperty",
      key: e,
      value: t,
      decorators: r,
      static: s
    });
  }
  i($ne, "classPrivateProperty");
  function Une(e = "method", t, r, s, n = !1) {
    return (0, B.default)({
      type: "ClassPrivateMethod",
      kind: e,
      key: t,
      params: r,
      body: s,
      static: n
    });
  }
  i(Une, "classPrivateMethod");
  function Vne(e) {
    return (0, B.default)({
      type: "PrivateName",
      id: e
    });
  }
  i(Vne, "privateName");
  function Wne(e) {
    return (0, B.default)({
      type: "StaticBlock",
      body: e
    });
  }
  i(Wne, "staticBlock");
  function Hne() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  i(Hne, "anyTypeAnnotation");
  function Gne(e) {
    return (0, B.default)({
      type: "ArrayTypeAnnotation",
      elementType: e
    });
  }
  i(Gne, "arrayTypeAnnotation");
  function Kne() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  i(Kne, "booleanTypeAnnotation");
  function Yne(e) {
    return (0, B.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: e
    });
  }
  i(Yne, "booleanLiteralTypeAnnotation");
  function Xne() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  i(Xne, "nullLiteralTypeAnnotation");
  function zne(e, t = null) {
    return (0, B.default)({
      type: "ClassImplements",
      id: e,
      typeParameters: t
    });
  }
  i(zne, "classImplements");
  function Jne(e, t = null, r = null, s) {
    return (0, B.default)({
      type: "DeclareClass",
      id: e,
      typeParameters: t,
      extends: r,
      body: s
    });
  }
  i(Jne, "declareClass");
  function Qne(e) {
    return (0, B.default)({
      type: "DeclareFunction",
      id: e
    });
  }
  i(Qne, "declareFunction");
  function Zne(e, t = null, r = null, s) {
    return (0, B.default)({
      type: "DeclareInterface",
      id: e,
      typeParameters: t,
      extends: r,
      body: s
    });
  }
  i(Zne, "declareInterface");
  function eie(e, t, r = null) {
    return (0, B.default)({
      type: "DeclareModule",
      id: e,
      body: t,
      kind: r
    });
  }
  i(eie, "declareModule");
  function tie(e) {
    return (0, B.default)({
      type: "DeclareModuleExports",
      typeAnnotation: e
    });
  }
  i(tie, "declareModuleExports");
  function rie(e, t = null, r) {
    return (0, B.default)({
      type: "DeclareTypeAlias",
      id: e,
      typeParameters: t,
      right: r
    });
  }
  i(rie, "declareTypeAlias");
  function sie(e, t = null, r = null) {
    return (0, B.default)({
      type: "DeclareOpaqueType",
      id: e,
      typeParameters: t,
      supertype: r
    });
  }
  i(sie, "declareOpaqueType");
  function nie(e) {
    return (0, B.default)({
      type: "DeclareVariable",
      id: e
    });
  }
  i(nie, "declareVariable");
  function iie(e = null, t = null, r = null) {
    return (0, B.default)({
      type: "DeclareExportDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    });
  }
  i(iie, "declareExportDeclaration");
  function aie(e) {
    return (0, B.default)({
      type: "DeclareExportAllDeclaration",
      source: e
    });
  }
  i(aie, "declareExportAllDeclaration");
  function oie(e) {
    return (0, B.default)({
      type: "DeclaredPredicate",
      value: e
    });
  }
  i(oie, "declaredPredicate");
  function lie() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  i(lie, "existsTypeAnnotation");
  function uie(e = null, t, r = null, s) {
    return (0, B.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: e,
      params: t,
      rest: r,
      returnType: s
    });
  }
  i(uie, "functionTypeAnnotation");
  function cie(e = null, t) {
    return (0, B.default)({
      type: "FunctionTypeParam",
      name: e,
      typeAnnotation: t
    });
  }
  i(cie, "functionTypeParam");
  function fie(e, t = null) {
    return (0, B.default)({
      type: "GenericTypeAnnotation",
      id: e,
      typeParameters: t
    });
  }
  i(fie, "genericTypeAnnotation");
  function pie() {
    return {
      type: "InferredPredicate"
    };
  }
  i(pie, "inferredPredicate");
  function die(e, t = null) {
    return (0, B.default)({
      type: "InterfaceExtends",
      id: e,
      typeParameters: t
    });
  }
  i(die, "interfaceExtends");
  function hie(e, t = null, r = null, s) {
    return (0, B.default)({
      type: "InterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: s
    });
  }
  i(hie, "interfaceDeclaration");
  function mie(e = null, t) {
    return (0, B.default)({
      type: "InterfaceTypeAnnotation",
      extends: e,
      body: t
    });
  }
  i(mie, "interfaceTypeAnnotation");
  function yie(e) {
    return (0, B.default)({
      type: "IntersectionTypeAnnotation",
      types: e
    });
  }
  i(yie, "intersectionTypeAnnotation");
  function gie() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  i(gie, "mixedTypeAnnotation");
  function bie() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  i(bie, "emptyTypeAnnotation");
  function Eie(e) {
    return (0, B.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: e
    });
  }
  i(Eie, "nullableTypeAnnotation");
  function vie(e) {
    return (0, B.default)({
      type: "NumberLiteralTypeAnnotation",
      value: e
    });
  }
  i(vie, "numberLiteralTypeAnnotation");
  function Sie() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  i(Sie, "numberTypeAnnotation");
  function Tie(e, t = [], r = [], s = [], n = !1) {
    return (0, B.default)({
      type: "ObjectTypeAnnotation",
      properties: e,
      indexers: t,
      callProperties: r,
      internalSlots: s,
      exact: n
    });
  }
  i(Tie, "objectTypeAnnotation");
  function xie(e, t, r, s, n) {
    return (0, B.default)({
      type: "ObjectTypeInternalSlot",
      id: e,
      value: t,
      optional: r,
      static: s,
      method: n
    });
  }
  i(xie, "objectTypeInternalSlot");
  function Pie(e) {
    return (0, B.default)({
      type: "ObjectTypeCallProperty",
      value: e,
      static: null
    });
  }
  i(Pie, "objectTypeCallProperty");
  function Aie(e = null, t, r, s = null) {
    return (0, B.default)({
      type: "ObjectTypeIndexer",
      id: e,
      key: t,
      value: r,
      variance: s,
      static: null
    });
  }
  i(Aie, "objectTypeIndexer");
  function Cie(e, t, r = null) {
    return (0, B.default)({
      type: "ObjectTypeProperty",
      key: e,
      value: t,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  i(Cie, "objectTypeProperty");
  function wie(e) {
    return (0, B.default)({
      type: "ObjectTypeSpreadProperty",
      argument: e
    });
  }
  i(wie, "objectTypeSpreadProperty");
  function Die(e, t = null, r = null, s) {
    return (0, B.default)({
      type: "OpaqueType",
      id: e,
      typeParameters: t,
      supertype: r,
      impltype: s
    });
  }
  i(Die, "opaqueType");
  function Iie(e, t) {
    return (0, B.default)({
      type: "QualifiedTypeIdentifier",
      id: e,
      qualification: t
    });
  }
  i(Iie, "qualifiedTypeIdentifier");
  function _ie(e) {
    return (0, B.default)({
      type: "StringLiteralTypeAnnotation",
      value: e
    });
  }
  i(_ie, "stringLiteralTypeAnnotation");
  function Oie() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  i(Oie, "stringTypeAnnotation");
  function Nie() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  i(Nie, "symbolTypeAnnotation");
  function Rie() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  i(Rie, "thisTypeAnnotation");
  function kie(e) {
    return (0, B.default)({
      type: "TupleTypeAnnotation",
      types: e
    });
  }
  i(kie, "tupleTypeAnnotation");
  function Fie(e) {
    return (0, B.default)({
      type: "TypeofTypeAnnotation",
      argument: e
    });
  }
  i(Fie, "typeofTypeAnnotation");
  function Lie(e, t = null, r) {
    return (0, B.default)({
      type: "TypeAlias",
      id: e,
      typeParameters: t,
      right: r
    });
  }
  i(Lie, "typeAlias");
  function Bie(e) {
    return (0, B.default)({
      type: "TypeAnnotation",
      typeAnnotation: e
    });
  }
  i(Bie, "typeAnnotation");
  function Mie(e, t) {
    return (0, B.default)({
      type: "TypeCastExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  i(Mie, "typeCastExpression");
  function jie(e = null, t = null, r = null) {
    return (0, B.default)({
      type: "TypeParameter",
      bound: e,
      default: t,
      variance: r,
      name: null
    });
  }
  i(jie, "typeParameter");
  function qie(e) {
    return (0, B.default)({
      type: "TypeParameterDeclaration",
      params: e
    });
  }
  i(qie, "typeParameterDeclaration");
  function $ie(e) {
    return (0, B.default)({
      type: "TypeParameterInstantiation",
      params: e
    });
  }
  i($ie, "typeParameterInstantiation");
  function Uie(e) {
    return (0, B.default)({
      type: "UnionTypeAnnotation",
      types: e
    });
  }
  i(Uie, "unionTypeAnnotation");
  function Vie(e) {
    return (0, B.default)({
      type: "Variance",
      kind: e
    });
  }
  i(Vie, "variance");
  function Wie() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  i(Wie, "voidTypeAnnotation");
  function Hie(e, t) {
    return (0, B.default)({
      type: "EnumDeclaration",
      id: e,
      body: t
    });
  }
  i(Hie, "enumDeclaration");
  function Gie(e) {
    return (0, B.default)({
      type: "EnumBooleanBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  i(Gie, "enumBooleanBody");
  function Kie(e) {
    return (0, B.default)({
      type: "EnumNumberBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  i(Kie, "enumNumberBody");
  function Yie(e) {
    return (0, B.default)({
      type: "EnumStringBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  i(Yie, "enumStringBody");
  function Xie(e) {
    return (0, B.default)({
      type: "EnumSymbolBody",
      members: e,
      hasUnknownMembers: null
    });
  }
  i(Xie, "enumSymbolBody");
  function zie(e) {
    return (0, B.default)({
      type: "EnumBooleanMember",
      id: e,
      init: null
    });
  }
  i(zie, "enumBooleanMember");
  function Jie(e, t) {
    return (0, B.default)({
      type: "EnumNumberMember",
      id: e,
      init: t
    });
  }
  i(Jie, "enumNumberMember");
  function Qie(e, t) {
    return (0, B.default)({
      type: "EnumStringMember",
      id: e,
      init: t
    });
  }
  i(Qie, "enumStringMember");
  function Zie(e) {
    return (0, B.default)({
      type: "EnumDefaultedMember",
      id: e
    });
  }
  i(Zie, "enumDefaultedMember");
  function eae(e, t) {
    return (0, B.default)({
      type: "IndexedAccessType",
      objectType: e,
      indexType: t
    });
  }
  i(eae, "indexedAccessType");
  function tae(e, t) {
    return (0, B.default)({
      type: "OptionalIndexedAccessType",
      objectType: e,
      indexType: t,
      optional: null
    });
  }
  i(tae, "optionalIndexedAccessType");
  function rae(e, t = null) {
    return (0, B.default)({
      type: "JSXAttribute",
      name: e,
      value: t
    });
  }
  i(rae, "jsxAttribute");
  function sae(e) {
    return (0, B.default)({
      type: "JSXClosingElement",
      name: e
    });
  }
  i(sae, "jsxClosingElement");
  function nae(e, t = null, r, s = null) {
    return (0, B.default)({
      type: "JSXElement",
      openingElement: e,
      closingElement: t,
      children: r,
      selfClosing: s
    });
  }
  i(nae, "jsxElement");
  function iae() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  i(iae, "jsxEmptyExpression");
  function aae(e) {
    return (0, B.default)({
      type: "JSXExpressionContainer",
      expression: e
    });
  }
  i(aae, "jsxExpressionContainer");
  function oae(e) {
    return (0, B.default)({
      type: "JSXSpreadChild",
      expression: e
    });
  }
  i(oae, "jsxSpreadChild");
  function lae(e) {
    return (0, B.default)({
      type: "JSXIdentifier",
      name: e
    });
  }
  i(lae, "jsxIdentifier");
  function uae(e, t) {
    return (0, B.default)({
      type: "JSXMemberExpression",
      object: e,
      property: t
    });
  }
  i(uae, "jsxMemberExpression");
  function cae(e, t) {
    return (0, B.default)({
      type: "JSXNamespacedName",
      namespace: e,
      name: t
    });
  }
  i(cae, "jsxNamespacedName");
  function fae(e, t, r = !1) {
    return (0, B.default)({
      type: "JSXOpeningElement",
      name: e,
      attributes: t,
      selfClosing: r
    });
  }
  i(fae, "jsxOpeningElement");
  function pae(e) {
    return (0, B.default)({
      type: "JSXSpreadAttribute",
      argument: e
    });
  }
  i(pae, "jsxSpreadAttribute");
  function dae(e) {
    return (0, B.default)({
      type: "JSXText",
      value: e
    });
  }
  i(dae, "jsxText");
  function hae(e, t, r) {
    return (0, B.default)({
      type: "JSXFragment",
      openingFragment: e,
      closingFragment: t,
      children: r
    });
  }
  i(hae, "jsxFragment");
  function mae() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  i(mae, "jsxOpeningFragment");
  function yae() {
    return {
      type: "JSXClosingFragment"
    };
  }
  i(yae, "jsxClosingFragment");
  function gae() {
    return {
      type: "Noop"
    };
  }
  i(gae, "noop");
  function bae(e, t) {
    return (0, B.default)({
      type: "Placeholder",
      expectedNode: e,
      name: t
    });
  }
  i(bae, "placeholder");
  function Eae(e) {
    return (0, B.default)({
      type: "V8IntrinsicIdentifier",
      name: e
    });
  }
  i(Eae, "v8IntrinsicIdentifier");
  function vae() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  i(vae, "argumentPlaceholder");
  function Sae(e, t) {
    return (0, B.default)({
      type: "BindExpression",
      object: e,
      callee: t
    });
  }
  i(Sae, "bindExpression");
  function Tae(e, t) {
    return (0, B.default)({
      type: "ImportAttribute",
      key: e,
      value: t
    });
  }
  i(Tae, "importAttribute");
  function xae(e) {
    return (0, B.default)({
      type: "Decorator",
      expression: e
    });
  }
  i(xae, "decorator");
  function Pae(e, t = !1) {
    return (0, B.default)({
      type: "DoExpression",
      body: e,
      async: t
    });
  }
  i(Pae, "doExpression");
  function Aae(e) {
    return (0, B.default)({
      type: "ExportDefaultSpecifier",
      exported: e
    });
  }
  i(Aae, "exportDefaultSpecifier");
  function Cae(e) {
    return (0, B.default)({
      type: "RecordExpression",
      properties: e
    });
  }
  i(Cae, "recordExpression");
  function wae(e = []) {
    return (0, B.default)({
      type: "TupleExpression",
      elements: e
    });
  }
  i(wae, "tupleExpression");
  function Dae(e) {
    return (0, B.default)({
      type: "DecimalLiteral",
      value: e
    });
  }
  i(Dae, "decimalLiteral");
  function Iae(e) {
    return (0, B.default)({
      type: "ModuleExpression",
      body: e
    });
  }
  i(Iae, "moduleExpression");
  function _ae() {
    return {
      type: "TopicReference"
    };
  }
  i(_ae, "topicReference");
  function Oae(e) {
    return (0, B.default)({
      type: "PipelineTopicExpression",
      expression: e
    });
  }
  i(Oae, "pipelineTopicExpression");
  function Nae(e) {
    return (0, B.default)({
      type: "PipelineBareFunction",
      callee: e
    });
  }
  i(Nae, "pipelineBareFunction");
  function Rae() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  i(Rae, "pipelinePrimaryTopicReference");
  function kae(e) {
    return (0, B.default)({
      type: "TSParameterProperty",
      parameter: e
    });
  }
  i(kae, "tsParameterProperty");
  function Fae(e = null, t = null, r, s = null) {
    return (0, B.default)({
      type: "TSDeclareFunction",
      id: e,
      typeParameters: t,
      params: r,
      returnType: s
    });
  }
  i(Fae, "tsDeclareFunction");
  function Lae(e = null, t, r = null, s, n = null) {
    return (0, B.default)({
      type: "TSDeclareMethod",
      decorators: e,
      key: t,
      typeParameters: r,
      params: s,
      returnType: n
    });
  }
  i(Lae, "tsDeclareMethod");
  function Bae(e, t) {
    return (0, B.default)({
      type: "TSQualifiedName",
      left: e,
      right: t
    });
  }
  i(Bae, "tsQualifiedName");
  function Mae(e = null, t, r = null) {
    return (0, B.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  i(Mae, "tsCallSignatureDeclaration");
  function jae(e = null, t, r = null) {
    return (0, B.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  i(jae, "tsConstructSignatureDeclaration");
  function qae(e, t = null) {
    return (0, B.default)({
      type: "TSPropertySignature",
      key: e,
      typeAnnotation: t,
      kind: null
    });
  }
  i(qae, "tsPropertySignature");
  function $ae(e, t = null, r, s = null) {
    return (0, B.default)({
      type: "TSMethodSignature",
      key: e,
      typeParameters: t,
      parameters: r,
      typeAnnotation: s,
      kind: null
    });
  }
  i($ae, "tsMethodSignature");
  function Uae(e, t = null) {
    return (0, B.default)({
      type: "TSIndexSignature",
      parameters: e,
      typeAnnotation: t
    });
  }
  i(Uae, "tsIndexSignature");
  function Vae() {
    return {
      type: "TSAnyKeyword"
    };
  }
  i(Vae, "tsAnyKeyword");
  function Wae() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  i(Wae, "tsBooleanKeyword");
  function Hae() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  i(Hae, "tsBigIntKeyword");
  function Gae() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  i(Gae, "tsIntrinsicKeyword");
  function Kae() {
    return {
      type: "TSNeverKeyword"
    };
  }
  i(Kae, "tsNeverKeyword");
  function Yae() {
    return {
      type: "TSNullKeyword"
    };
  }
  i(Yae, "tsNullKeyword");
  function Xae() {
    return {
      type: "TSNumberKeyword"
    };
  }
  i(Xae, "tsNumberKeyword");
  function zae() {
    return {
      type: "TSObjectKeyword"
    };
  }
  i(zae, "tsObjectKeyword");
  function Jae() {
    return {
      type: "TSStringKeyword"
    };
  }
  i(Jae, "tsStringKeyword");
  function Qae() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  i(Qae, "tsSymbolKeyword");
  function Zae() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  i(Zae, "tsUndefinedKeyword");
  function eoe() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  i(eoe, "tsUnknownKeyword");
  function toe() {
    return {
      type: "TSVoidKeyword"
    };
  }
  i(toe, "tsVoidKeyword");
  function roe() {
    return {
      type: "TSThisType"
    };
  }
  i(roe, "tsThisType");
  function soe(e = null, t, r = null) {
    return (0, B.default)({
      type: "TSFunctionType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  i(soe, "tsFunctionType");
  function noe(e = null, t, r = null) {
    return (0, B.default)({
      type: "TSConstructorType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    });
  }
  i(noe, "tsConstructorType");
  function ioe(e, t = null) {
    return (0, B.default)({
      type: "TSTypeReference",
      typeName: e,
      typeParameters: t
    });
  }
  i(ioe, "tsTypeReference");
  function aoe(e, t = null, r = null) {
    return (0, B.default)({
      type: "TSTypePredicate",
      parameterName: e,
      typeAnnotation: t,
      asserts: r
    });
  }
  i(aoe, "tsTypePredicate");
  function ooe(e, t = null) {
    return (0, B.default)({
      type: "TSTypeQuery",
      exprName: e,
      typeParameters: t
    });
  }
  i(ooe, "tsTypeQuery");
  function loe(e) {
    return (0, B.default)({
      type: "TSTypeLiteral",
      members: e
    });
  }
  i(loe, "tsTypeLiteral");
  function uoe(e) {
    return (0, B.default)({
      type: "TSArrayType",
      elementType: e
    });
  }
  i(uoe, "tsArrayType");
  function coe(e) {
    return (0, B.default)({
      type: "TSTupleType",
      elementTypes: e
    });
  }
  i(coe, "tsTupleType");
  function foe(e) {
    return (0, B.default)({
      type: "TSOptionalType",
      typeAnnotation: e
    });
  }
  i(foe, "tsOptionalType");
  function poe(e) {
    return (0, B.default)({
      type: "TSRestType",
      typeAnnotation: e
    });
  }
  i(poe, "tsRestType");
  function doe(e, t, r = !1) {
    return (0, B.default)({
      type: "TSNamedTupleMember",
      label: e,
      elementType: t,
      optional: r
    });
  }
  i(doe, "tsNamedTupleMember");
  function hoe(e) {
    return (0, B.default)({
      type: "TSUnionType",
      types: e
    });
  }
  i(hoe, "tsUnionType");
  function moe(e) {
    return (0, B.default)({
      type: "TSIntersectionType",
      types: e
    });
  }
  i(moe, "tsIntersectionType");
  function yoe(e, t, r, s) {
    return (0, B.default)({
      type: "TSConditionalType",
      checkType: e,
      extendsType: t,
      trueType: r,
      falseType: s
    });
  }
  i(yoe, "tsConditionalType");
  function goe(e) {
    return (0, B.default)({
      type: "TSInferType",
      typeParameter: e
    });
  }
  i(goe, "tsInferType");
  function boe(e) {
    return (0, B.default)({
      type: "TSParenthesizedType",
      typeAnnotation: e
    });
  }
  i(boe, "tsParenthesizedType");
  function Eoe(e) {
    return (0, B.default)({
      type: "TSTypeOperator",
      typeAnnotation: e,
      operator: null
    });
  }
  i(Eoe, "tsTypeOperator");
  function voe(e, t) {
    return (0, B.default)({
      type: "TSIndexedAccessType",
      objectType: e,
      indexType: t
    });
  }
  i(voe, "tsIndexedAccessType");
  function Soe(e, t = null, r = null) {
    return (0, B.default)({
      type: "TSMappedType",
      typeParameter: e,
      typeAnnotation: t,
      nameType: r
    });
  }
  i(Soe, "tsMappedType");
  function Toe(e) {
    return (0, B.default)({
      type: "TSLiteralType",
      literal: e
    });
  }
  i(Toe, "tsLiteralType");
  function xoe(e, t = null) {
    return (0, B.default)({
      type: "TSExpressionWithTypeArguments",
      expression: e,
      typeParameters: t
    });
  }
  i(xoe, "tsExpressionWithTypeArguments");
  function Poe(e, t = null, r = null, s) {
    return (0, B.default)({
      type: "TSInterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: s
    });
  }
  i(Poe, "tsInterfaceDeclaration");
  function Aoe(e) {
    return (0, B.default)({
      type: "TSInterfaceBody",
      body: e
    });
  }
  i(Aoe, "tsInterfaceBody");
  function Coe(e, t = null, r) {
    return (0, B.default)({
      type: "TSTypeAliasDeclaration",
      id: e,
      typeParameters: t,
      typeAnnotation: r
    });
  }
  i(Coe, "tsTypeAliasDeclaration");
  function woe(e, t = null) {
    return (0, B.default)({
      type: "TSInstantiationExpression",
      expression: e,
      typeParameters: t
    });
  }
  i(woe, "tsInstantiationExpression");
  function Doe(e, t) {
    return (0, B.default)({
      type: "TSAsExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  i(Doe, "tsAsExpression");
  function Ioe(e, t) {
    return (0, B.default)({
      type: "TSSatisfiesExpression",
      expression: e,
      typeAnnotation: t
    });
  }
  i(Ioe, "tsSatisfiesExpression");
  function _oe(e, t) {
    return (0, B.default)({
      type: "TSTypeAssertion",
      typeAnnotation: e,
      expression: t
    });
  }
  i(_oe, "tsTypeAssertion");
  function Ooe(e, t) {
    return (0, B.default)({
      type: "TSEnumDeclaration",
      id: e,
      members: t
    });
  }
  i(Ooe, "tsEnumDeclaration");
  function Noe(e, t = null) {
    return (0, B.default)({
      type: "TSEnumMember",
      id: e,
      initializer: t
    });
  }
  i(Noe, "tsEnumMember");
  function Roe(e, t) {
    return (0, B.default)({
      type: "TSModuleDeclaration",
      id: e,
      body: t
    });
  }
  i(Roe, "tsModuleDeclaration");
  function koe(e) {
    return (0, B.default)({
      type: "TSModuleBlock",
      body: e
    });
  }
  i(koe, "tsModuleBlock");
  function Foe(e, t = null, r = null) {
    return (0, B.default)({
      type: "TSImportType",
      argument: e,
      qualifier: t,
      typeParameters: r
    });
  }
  i(Foe, "tsImportType");
  function Loe(e, t) {
    return (0, B.default)({
      type: "TSImportEqualsDeclaration",
      id: e,
      moduleReference: t,
      isExport: null
    });
  }
  i(Loe, "tsImportEqualsDeclaration");
  function Boe(e) {
    return (0, B.default)({
      type: "TSExternalModuleReference",
      expression: e
    });
  }
  i(Boe, "tsExternalModuleReference");
  function Moe(e) {
    return (0, B.default)({
      type: "TSNonNullExpression",
      expression: e
    });
  }
  i(Moe, "tsNonNullExpression");
  function joe(e) {
    return (0, B.default)({
      type: "TSExportAssignment",
      expression: e
    });
  }
  i(joe, "tsExportAssignment");
  function qoe(e) {
    return (0, B.default)({
      type: "TSNamespaceExportDeclaration",
      id: e
    });
  }
  i(qoe, "tsNamespaceExportDeclaration");
  function $oe(e) {
    return (0, B.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: e
    });
  }
  i($oe, "tsTypeAnnotation");
  function Uoe(e) {
    return (0, B.default)({
      type: "TSTypeParameterInstantiation",
      params: e
    });
  }
  i(Uoe, "tsTypeParameterInstantiation");
  function Voe(e) {
    return (0, B.default)({
      type: "TSTypeParameterDeclaration",
      params: e
    });
  }
  i(Voe, "tsTypeParameterDeclaration");
  function Woe(e = null, t = null, r) {
    return (0, B.default)({
      type: "TSTypeParameter",
      constraint: e,
      default: t,
      name: r
    });
  }
  i(Woe, "tsTypeParameter");
  function Hoe(e) {
    return (0, Yp.default)("NumberLiteral", "NumericLiteral", "The node type "), JR(e);
  }
  i(Hoe, "NumberLiteral");
  function Goe(e, t = "") {
    return (0, Yp.default)("RegexLiteral", "RegExpLiteral", "The node type "), QR(e, t);
  }
  i(Goe, "RegexLiteral");
  function Koe(e) {
    return (0, Yp.default)("RestProperty", "RestElement", "The node type "), ZR(e);
  }
  i(Koe, "RestProperty");
  function Yoe(e) {
    return (0, Yp.default)("SpreadProperty", "SpreadElement", "The node type "), ek(e);
  }
  i(Yoe, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var tk = y((Fb) => {
  "use strict";
  Object.defineProperty(Fb, "__esModule", {
    value: !0
  });
  Fb.default = Joe;
  var Xoe = ns(), zoe = Ne();
  function Joe(e, t) {
    let r = e.value.split(/\r\n|\n|\r/), s = 0;
    for (let a = 0; a < r.length; a++)
      r[a].match(/[^ \t]/) && (s = a);
    let n = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, c = a === s, f = o.replace(/\t/g, " ");
      l || (f = f.replace(/^[ ]+/, "")), u || (f = f.replace(/[ ]+$/, "")), f && (c || (f += " "), n += f);
    }
    n && t.push((0, zoe.inherits)((0, Xoe.stringLiteral)(n), e));
  }
  i(Joe, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var rk = y((Bb) => {
  "use strict";
  Object.defineProperty(Bb, "__esModule", {
    value: !0
  });
  Bb.default = Zoe;
  var Lb = hr(), Qoe = tk();
  function Zoe(e) {
    let t = [];
    for (let r = 0; r < e.children.length; r++) {
      let s = e.children[r];
      if ((0, Lb.isJSXText)(s)) {
        (0, Qoe.default)(s, t);
        continue;
      }
      (0, Lb.isJSXExpressionContainer)(s) && (s = s.expression), !(0, Lb.isJSXEmptyExpression)(s) && t.push(s);
    }
    return t;
  }
  i(Zoe, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var jb = y((Mb) => {
  "use strict";
  Object.defineProperty(Mb, "__esModule", {
    value: !0
  });
  Mb.default = tle;
  var ele = Ls();
  function tle(e) {
    return !!(e && ele.VISITOR_KEYS[e.type]);
  }
  i(tle, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var sk = y((qb) => {
  "use strict";
  Object.defineProperty(qb, "__esModule", {
    value: !0
  });
  qb.default = sle;
  var rle = jb();
  function sle(e) {
    if (!(0, rle.default)(e)) {
      var t;
      let r = (t = e?.type) != null ? t : JSON.stringify(e);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  i(sle, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var nk = y((x) => {
  "use strict";
  Object.defineProperty(x, "__esModule", {
    value: !0
  });
  x.assertAccessor = Ede;
  x.assertAnyTypeAnnotation = jue;
  x.assertArgumentPlaceholder = hfe;
  x.assertArrayExpression = ile;
  x.assertArrayPattern = sue;
  x.assertArrayTypeAnnotation = que;
  x.assertArrowFunctionExpression = nue;
  x.assertAssignmentExpression = ale;
  x.assertAssignmentPattern = rue;
  x.assertAwaitExpression = wue;
  x.assertBigIntLiteral = Iue;
  x.assertBinary = $pe;
  x.assertBinaryExpression = ole;
  x.assertBindExpression = mfe;
  x.assertBlock = Wpe;
  x.assertBlockParent = Vpe;
  x.assertBlockStatement = fle;
  x.assertBooleanLiteral = Nle;
  x.assertBooleanLiteralTypeAnnotation = Uue;
  x.assertBooleanTypeAnnotation = $ue;
  x.assertBreakStatement = ple;
  x.assertCallExpression = dle;
  x.assertCatchClause = hle;
  x.assertClass = mde;
  x.assertClassAccessorProperty = kue;
  x.assertClassBody = iue;
  x.assertClassDeclaration = oue;
  x.assertClassExpression = aue;
  x.assertClassImplements = Wue;
  x.assertClassMethod = Eue;
  x.assertClassPrivateMethod = Lue;
  x.assertClassPrivateProperty = Fue;
  x.assertClassProperty = Rue;
  x.assertCompletionStatement = Kpe;
  x.assertConditional = Ype;
  x.assertConditionalExpression = mle;
  x.assertContinueStatement = yle;
  x.assertDebuggerStatement = gle;
  x.assertDecimalLiteral = Tfe;
  x.assertDeclaration = sde;
  x.assertDeclareClass = Hue;
  x.assertDeclareExportAllDeclaration = ece;
  x.assertDeclareExportDeclaration = Zue;
  x.assertDeclareFunction = Gue;
  x.assertDeclareInterface = Kue;
  x.assertDeclareModule = Yue;
  x.assertDeclareModuleExports = Xue;
  x.assertDeclareOpaqueType = Jue;
  x.assertDeclareTypeAlias = zue;
  x.assertDeclareVariable = Que;
  x.assertDeclaredPredicate = tce;
  x.assertDecorator = gfe;
  x.assertDirective = ule;
  x.assertDirectiveLiteral = cle;
  x.assertDoExpression = bfe;
  x.assertDoWhileStatement = ble;
  x.assertEmptyStatement = Ele;
  x.assertEmptyTypeAnnotation = pce;
  x.assertEnumBody = Cde;
  x.assertEnumBooleanBody = qce;
  x.assertEnumBooleanMember = Wce;
  x.assertEnumDeclaration = jce;
  x.assertEnumDefaultedMember = Kce;
  x.assertEnumMember = wde;
  x.assertEnumNumberBody = $ce;
  x.assertEnumNumberMember = Hce;
  x.assertEnumStringBody = Uce;
  x.assertEnumStringMember = Gce;
  x.assertEnumSymbolBody = Vce;
  x.assertExistsTypeAnnotation = rce;
  x.assertExportAllDeclaration = lue;
  x.assertExportDeclaration = gde;
  x.assertExportDefaultDeclaration = uue;
  x.assertExportDefaultSpecifier = Efe;
  x.assertExportNamedDeclaration = cue;
  x.assertExportNamespaceSpecifier = _ue;
  x.assertExportSpecifier = fue;
  x.assertExpression = qpe;
  x.assertExpressionStatement = vle;
  x.assertExpressionWrapper = Jpe;
  x.assertFile = Sle;
  x.assertFlow = Sde;
  x.assertFlowBaseAnnotation = xde;
  x.assertFlowDeclaration = Pde;
  x.assertFlowPredicate = Ade;
  x.assertFlowType = Tde;
  x.assertFor = Qpe;
  x.assertForInStatement = Tle;
  x.assertForOfStatement = pue;
  x.assertForStatement = xle;
  x.assertForXStatement = Zpe;
  x.assertFunction = ede;
  x.assertFunctionDeclaration = Ple;
  x.assertFunctionExpression = Ale;
  x.assertFunctionParent = tde;
  x.assertFunctionTypeAnnotation = sce;
  x.assertFunctionTypeParam = nce;
  x.assertGenericTypeAnnotation = ice;
  x.assertIdentifier = Cle;
  x.assertIfStatement = wle;
  x.assertImmutable = lde;
  x.assertImport = Due;
  x.assertImportAttribute = yfe;
  x.assertImportDeclaration = due;
  x.assertImportDefaultSpecifier = hue;
  x.assertImportExpression = gue;
  x.assertImportNamespaceSpecifier = mue;
  x.assertImportOrExportDeclaration = yde;
  x.assertImportSpecifier = yue;
  x.assertIndexedAccessType = Yce;
  x.assertInferredPredicate = ace;
  x.assertInterfaceDeclaration = lce;
  x.assertInterfaceExtends = oce;
  x.assertInterfaceTypeAnnotation = uce;
  x.assertInterpreterDirective = lle;
  x.assertIntersectionTypeAnnotation = cce;
  x.assertJSX = Dde;
  x.assertJSXAttribute = zce;
  x.assertJSXClosingElement = Jce;
  x.assertJSXClosingFragment = cfe;
  x.assertJSXElement = Qce;
  x.assertJSXEmptyExpression = Zce;
  x.assertJSXExpressionContainer = efe;
  x.assertJSXFragment = lfe;
  x.assertJSXIdentifier = rfe;
  x.assertJSXMemberExpression = sfe;
  x.assertJSXNamespacedName = nfe;
  x.assertJSXOpeningElement = ife;
  x.assertJSXOpeningFragment = ufe;
  x.assertJSXSpreadAttribute = afe;
  x.assertJSXSpreadChild = tfe;
  x.assertJSXText = ofe;
  x.assertLVal = ide;
  x.assertLabeledStatement = Dle;
  x.assertLiteral = ode;
  x.assertLogicalExpression = kle;
  x.assertLoop = Xpe;
  x.assertMemberExpression = Fle;
  x.assertMetaProperty = bue;
  x.assertMethod = cde;
  x.assertMiscellaneous = Ide;
  x.assertMixedTypeAnnotation = fce;
  x.assertModuleDeclaration = Mde;
  x.assertModuleExpression = xfe;
  x.assertModuleSpecifier = bde;
  x.assertNewExpression = Lle;
  x.assertNoop = ffe;
  x.assertNullLiteral = Ole;
  x.assertNullLiteralTypeAnnotation = Vue;
  x.assertNullableTypeAnnotation = dce;
  x.assertNumberLiteral = kde;
  x.assertNumberLiteralTypeAnnotation = hce;
  x.assertNumberTypeAnnotation = mce;
  x.assertNumericLiteral = _le;
  x.assertObjectExpression = Mle;
  x.assertObjectMember = fde;
  x.assertObjectMethod = jle;
  x.assertObjectPattern = vue;
  x.assertObjectProperty = qle;
  x.assertObjectTypeAnnotation = yce;
  x.assertObjectTypeCallProperty = bce;
  x.assertObjectTypeIndexer = Ece;
  x.assertObjectTypeInternalSlot = gce;
  x.assertObjectTypeProperty = vce;
  x.assertObjectTypeSpreadProperty = Sce;
  x.assertOpaqueType = Tce;
  x.assertOptionalCallExpression = Nue;
  x.assertOptionalIndexedAccessType = Xce;
  x.assertOptionalMemberExpression = Oue;
  x.assertParenthesizedExpression = Wle;
  x.assertPattern = hde;
  x.assertPatternLike = nde;
  x.assertPipelineBareFunction = Cfe;
  x.assertPipelinePrimaryTopicReference = wfe;
  x.assertPipelineTopicExpression = Afe;
  x.assertPlaceholder = pfe;
  x.assertPrivate = vde;
  x.assertPrivateName = Bue;
  x.assertProgram = Ble;
  x.assertProperty = pde;
  x.assertPureish = rde;
  x.assertQualifiedTypeIdentifier = xce;
  x.assertRecordExpression = vfe;
  x.assertRegExpLiteral = Rle;
  x.assertRegexLiteral = Fde;
  x.assertRestElement = $le;
  x.assertRestProperty = Lde;
  x.assertReturnStatement = Ule;
  x.assertScopable = Upe;
  x.assertSequenceExpression = Vle;
  x.assertSpreadElement = Sue;
  x.assertSpreadProperty = Bde;
  x.assertStandardized = jpe;
  x.assertStatement = Hpe;
  x.assertStaticBlock = Mue;
  x.assertStringLiteral = Ile;
  x.assertStringLiteralTypeAnnotation = Pce;
  x.assertStringTypeAnnotation = Ace;
  x.assertSuper = Tue;
  x.assertSwitchCase = Hle;
  x.assertSwitchStatement = Gle;
  x.assertSymbolTypeAnnotation = Cce;
  x.assertTSAnyKeyword = Bfe;
  x.assertTSArrayType = spe;
  x.assertTSAsExpression = Tpe;
  x.assertTSBaseType = Rde;
  x.assertTSBigIntKeyword = jfe;
  x.assertTSBooleanKeyword = Mfe;
  x.assertTSCallSignatureDeclaration = Nfe;
  x.assertTSConditionalType = cpe;
  x.assertTSConstructSignatureDeclaration = Rfe;
  x.assertTSConstructorType = Qfe;
  x.assertTSDeclareFunction = Ife;
  x.assertTSDeclareMethod = _fe;
  x.assertTSEntityName = ade;
  x.assertTSEnumDeclaration = Ape;
  x.assertTSEnumMember = Cpe;
  x.assertTSExportAssignment = Rpe;
  x.assertTSExpressionWithTypeArguments = gpe;
  x.assertTSExternalModuleReference = Ope;
  x.assertTSFunctionType = Jfe;
  x.assertTSImportEqualsDeclaration = _pe;
  x.assertTSImportType = Ipe;
  x.assertTSIndexSignature = Lfe;
  x.assertTSIndexedAccessType = hpe;
  x.assertTSInferType = fpe;
  x.assertTSInstantiationExpression = Spe;
  x.assertTSInterfaceBody = Epe;
  x.assertTSInterfaceDeclaration = bpe;
  x.assertTSIntersectionType = upe;
  x.assertTSIntrinsicKeyword = qfe;
  x.assertTSLiteralType = ype;
  x.assertTSMappedType = mpe;
  x.assertTSMethodSignature = Ffe;
  x.assertTSModuleBlock = Dpe;
  x.assertTSModuleDeclaration = wpe;
  x.assertTSNamedTupleMember = ope;
  x.assertTSNamespaceExportDeclaration = kpe;
  x.assertTSNeverKeyword = $fe;
  x.assertTSNonNullExpression = Npe;
  x.assertTSNullKeyword = Ufe;
  x.assertTSNumberKeyword = Vfe;
  x.assertTSObjectKeyword = Wfe;
  x.assertTSOptionalType = ipe;
  x.assertTSParameterProperty = Dfe;
  x.assertTSParenthesizedType = ppe;
  x.assertTSPropertySignature = kfe;
  x.assertTSQualifiedName = Ofe;
  x.assertTSRestType = ape;
  x.assertTSSatisfiesExpression = xpe;
  x.assertTSStringKeyword = Hfe;
  x.assertTSSymbolKeyword = Gfe;
  x.assertTSThisType = zfe;
  x.assertTSTupleType = npe;
  x.assertTSType = Nde;
  x.assertTSTypeAliasDeclaration = vpe;
  x.assertTSTypeAnnotation = Fpe;
  x.assertTSTypeAssertion = Ppe;
  x.assertTSTypeElement = Ode;
  x.assertTSTypeLiteral = rpe;
  x.assertTSTypeOperator = dpe;
  x.assertTSTypeParameter = Mpe;
  x.assertTSTypeParameterDeclaration = Bpe;
  x.assertTSTypeParameterInstantiation = Lpe;
  x.assertTSTypePredicate = epe;
  x.assertTSTypeQuery = tpe;
  x.assertTSTypeReference = Zfe;
  x.assertTSUndefinedKeyword = Kfe;
  x.assertTSUnionType = lpe;
  x.assertTSUnknownKeyword = Yfe;
  x.assertTSVoidKeyword = Xfe;
  x.assertTaggedTemplateExpression = xue;
  x.assertTemplateElement = Pue;
  x.assertTemplateLiteral = Aue;
  x.assertTerminatorless = Gpe;
  x.assertThisExpression = Kle;
  x.assertThisTypeAnnotation = wce;
  x.assertThrowStatement = Yle;
  x.assertTopicReference = Pfe;
  x.assertTryStatement = Xle;
  x.assertTupleExpression = Sfe;
  x.assertTupleTypeAnnotation = Dce;
  x.assertTypeAlias = _ce;
  x.assertTypeAnnotation = Oce;
  x.assertTypeCastExpression = Nce;
  x.assertTypeParameter = Rce;
  x.assertTypeParameterDeclaration = kce;
  x.assertTypeParameterInstantiation = Fce;
  x.assertTypeScript = _de;
  x.assertTypeofTypeAnnotation = Ice;
  x.assertUnaryExpression = zle;
  x.assertUnaryLike = dde;
  x.assertUnionTypeAnnotation = Lce;
  x.assertUpdateExpression = Jle;
  x.assertUserWhitespacable = ude;
  x.assertV8IntrinsicIdentifier = dfe;
  x.assertVariableDeclaration = Qle;
  x.assertVariableDeclarator = Zle;
  x.assertVariance = Bce;
  x.assertVoidTypeAnnotation = Mce;
  x.assertWhile = zpe;
  x.assertWhileStatement = eue;
  x.assertWithStatement = tue;
  x.assertYieldExpression = Cue;
  var nle = tl(), ic = Yu();
  function P(e, t, r) {
    if (!(0, nle.default)(e, t, r))
      throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
  }
  i(P, "assert");
  function ile(e, t) {
    P("ArrayExpression", e, t);
  }
  i(ile, "assertArrayExpression");
  function ale(e, t) {
    P("AssignmentExpression", e, t);
  }
  i(ale, "assertAssignmentExpression");
  function ole(e, t) {
    P("BinaryExpression", e, t);
  }
  i(ole, "assertBinaryExpression");
  function lle(e, t) {
    P("InterpreterDirective", e, t);
  }
  i(lle, "assertInterpreterDirective");
  function ule(e, t) {
    P("Directive", e, t);
  }
  i(ule, "assertDirective");
  function cle(e, t) {
    P("DirectiveLiteral", e, t);
  }
  i(cle, "assertDirectiveLiteral");
  function fle(e, t) {
    P("BlockStatement", e, t);
  }
  i(fle, "assertBlockStatement");
  function ple(e, t) {
    P("BreakStatement", e, t);
  }
  i(ple, "assertBreakStatement");
  function dle(e, t) {
    P("CallExpression", e, t);
  }
  i(dle, "assertCallExpression");
  function hle(e, t) {
    P("CatchClause", e, t);
  }
  i(hle, "assertCatchClause");
  function mle(e, t) {
    P("ConditionalExpression", e, t);
  }
  i(mle, "assertConditionalExpression");
  function yle(e, t) {
    P("ContinueStatement", e, t);
  }
  i(yle, "assertContinueStatement");
  function gle(e, t) {
    P("DebuggerStatement", e, t);
  }
  i(gle, "assertDebuggerStatement");
  function ble(e, t) {
    P("DoWhileStatement", e, t);
  }
  i(ble, "assertDoWhileStatement");
  function Ele(e, t) {
    P("EmptyStatement", e, t);
  }
  i(Ele, "assertEmptyStatement");
  function vle(e, t) {
    P("ExpressionStatement", e, t);
  }
  i(vle, "assertExpressionStatement");
  function Sle(e, t) {
    P("File", e, t);
  }
  i(Sle, "assertFile");
  function Tle(e, t) {
    P("ForInStatement", e, t);
  }
  i(Tle, "assertForInStatement");
  function xle(e, t) {
    P("ForStatement", e, t);
  }
  i(xle, "assertForStatement");
  function Ple(e, t) {
    P("FunctionDeclaration", e, t);
  }
  i(Ple, "assertFunctionDeclaration");
  function Ale(e, t) {
    P("FunctionExpression", e, t);
  }
  i(Ale, "assertFunctionExpression");
  function Cle(e, t) {
    P("Identifier", e, t);
  }
  i(Cle, "assertIdentifier");
  function wle(e, t) {
    P("IfStatement", e, t);
  }
  i(wle, "assertIfStatement");
  function Dle(e, t) {
    P("LabeledStatement", e, t);
  }
  i(Dle, "assertLabeledStatement");
  function Ile(e, t) {
    P("StringLiteral", e, t);
  }
  i(Ile, "assertStringLiteral");
  function _le(e, t) {
    P("NumericLiteral", e, t);
  }
  i(_le, "assertNumericLiteral");
  function Ole(e, t) {
    P("NullLiteral", e, t);
  }
  i(Ole, "assertNullLiteral");
  function Nle(e, t) {
    P("BooleanLiteral", e, t);
  }
  i(Nle, "assertBooleanLiteral");
  function Rle(e, t) {
    P("RegExpLiteral", e, t);
  }
  i(Rle, "assertRegExpLiteral");
  function kle(e, t) {
    P("LogicalExpression", e, t);
  }
  i(kle, "assertLogicalExpression");
  function Fle(e, t) {
    P("MemberExpression", e, t);
  }
  i(Fle, "assertMemberExpression");
  function Lle(e, t) {
    P("NewExpression", e, t);
  }
  i(Lle, "assertNewExpression");
  function Ble(e, t) {
    P("Program", e, t);
  }
  i(Ble, "assertProgram");
  function Mle(e, t) {
    P("ObjectExpression", e, t);
  }
  i(Mle, "assertObjectExpression");
  function jle(e, t) {
    P("ObjectMethod", e, t);
  }
  i(jle, "assertObjectMethod");
  function qle(e, t) {
    P("ObjectProperty", e, t);
  }
  i(qle, "assertObjectProperty");
  function $le(e, t) {
    P("RestElement", e, t);
  }
  i($le, "assertRestElement");
  function Ule(e, t) {
    P("ReturnStatement", e, t);
  }
  i(Ule, "assertReturnStatement");
  function Vle(e, t) {
    P("SequenceExpression", e, t);
  }
  i(Vle, "assertSequenceExpression");
  function Wle(e, t) {
    P("ParenthesizedExpression", e, t);
  }
  i(Wle, "assertParenthesizedExpression");
  function Hle(e, t) {
    P("SwitchCase", e, t);
  }
  i(Hle, "assertSwitchCase");
  function Gle(e, t) {
    P("SwitchStatement", e, t);
  }
  i(Gle, "assertSwitchStatement");
  function Kle(e, t) {
    P("ThisExpression", e, t);
  }
  i(Kle, "assertThisExpression");
  function Yle(e, t) {
    P("ThrowStatement", e, t);
  }
  i(Yle, "assertThrowStatement");
  function Xle(e, t) {
    P("TryStatement", e, t);
  }
  i(Xle, "assertTryStatement");
  function zle(e, t) {
    P("UnaryExpression", e, t);
  }
  i(zle, "assertUnaryExpression");
  function Jle(e, t) {
    P("UpdateExpression", e, t);
  }
  i(Jle, "assertUpdateExpression");
  function Qle(e, t) {
    P("VariableDeclaration", e, t);
  }
  i(Qle, "assertVariableDeclaration");
  function Zle(e, t) {
    P("VariableDeclarator", e, t);
  }
  i(Zle, "assertVariableDeclarator");
  function eue(e, t) {
    P("WhileStatement", e, t);
  }
  i(eue, "assertWhileStatement");
  function tue(e, t) {
    P("WithStatement", e, t);
  }
  i(tue, "assertWithStatement");
  function rue(e, t) {
    P("AssignmentPattern", e, t);
  }
  i(rue, "assertAssignmentPattern");
  function sue(e, t) {
    P("ArrayPattern", e, t);
  }
  i(sue, "assertArrayPattern");
  function nue(e, t) {
    P("ArrowFunctionExpression", e, t);
  }
  i(nue, "assertArrowFunctionExpression");
  function iue(e, t) {
    P("ClassBody", e, t);
  }
  i(iue, "assertClassBody");
  function aue(e, t) {
    P("ClassExpression", e, t);
  }
  i(aue, "assertClassExpression");
  function oue(e, t) {
    P("ClassDeclaration", e, t);
  }
  i(oue, "assertClassDeclaration");
  function lue(e, t) {
    P("ExportAllDeclaration", e, t);
  }
  i(lue, "assertExportAllDeclaration");
  function uue(e, t) {
    P("ExportDefaultDeclaration", e, t);
  }
  i(uue, "assertExportDefaultDeclaration");
  function cue(e, t) {
    P("ExportNamedDeclaration", e, t);
  }
  i(cue, "assertExportNamedDeclaration");
  function fue(e, t) {
    P("ExportSpecifier", e, t);
  }
  i(fue, "assertExportSpecifier");
  function pue(e, t) {
    P("ForOfStatement", e, t);
  }
  i(pue, "assertForOfStatement");
  function due(e, t) {
    P("ImportDeclaration", e, t);
  }
  i(due, "assertImportDeclaration");
  function hue(e, t) {
    P("ImportDefaultSpecifier", e, t);
  }
  i(hue, "assertImportDefaultSpecifier");
  function mue(e, t) {
    P("ImportNamespaceSpecifier", e, t);
  }
  i(mue, "assertImportNamespaceSpecifier");
  function yue(e, t) {
    P("ImportSpecifier", e, t);
  }
  i(yue, "assertImportSpecifier");
  function gue(e, t) {
    P("ImportExpression", e, t);
  }
  i(gue, "assertImportExpression");
  function bue(e, t) {
    P("MetaProperty", e, t);
  }
  i(bue, "assertMetaProperty");
  function Eue(e, t) {
    P("ClassMethod", e, t);
  }
  i(Eue, "assertClassMethod");
  function vue(e, t) {
    P("ObjectPattern", e, t);
  }
  i(vue, "assertObjectPattern");
  function Sue(e, t) {
    P("SpreadElement", e, t);
  }
  i(Sue, "assertSpreadElement");
  function Tue(e, t) {
    P("Super", e, t);
  }
  i(Tue, "assertSuper");
  function xue(e, t) {
    P("TaggedTemplateExpression", e, t);
  }
  i(xue, "assertTaggedTemplateExpression");
  function Pue(e, t) {
    P("TemplateElement", e, t);
  }
  i(Pue, "assertTemplateElement");
  function Aue(e, t) {
    P("TemplateLiteral", e, t);
  }
  i(Aue, "assertTemplateLiteral");
  function Cue(e, t) {
    P("YieldExpression", e, t);
  }
  i(Cue, "assertYieldExpression");
  function wue(e, t) {
    P("AwaitExpression", e, t);
  }
  i(wue, "assertAwaitExpression");
  function Due(e, t) {
    P("Import", e, t);
  }
  i(Due, "assertImport");
  function Iue(e, t) {
    P("BigIntLiteral", e, t);
  }
  i(Iue, "assertBigIntLiteral");
  function _ue(e, t) {
    P("ExportNamespaceSpecifier", e, t);
  }
  i(_ue, "assertExportNamespaceSpecifier");
  function Oue(e, t) {
    P("OptionalMemberExpression", e, t);
  }
  i(Oue, "assertOptionalMemberExpression");
  function Nue(e, t) {
    P("OptionalCallExpression", e, t);
  }
  i(Nue, "assertOptionalCallExpression");
  function Rue(e, t) {
    P("ClassProperty", e, t);
  }
  i(Rue, "assertClassProperty");
  function kue(e, t) {
    P("ClassAccessorProperty", e, t);
  }
  i(kue, "assertClassAccessorProperty");
  function Fue(e, t) {
    P("ClassPrivateProperty", e, t);
  }
  i(Fue, "assertClassPrivateProperty");
  function Lue(e, t) {
    P("ClassPrivateMethod", e, t);
  }
  i(Lue, "assertClassPrivateMethod");
  function Bue(e, t) {
    P("PrivateName", e, t);
  }
  i(Bue, "assertPrivateName");
  function Mue(e, t) {
    P("StaticBlock", e, t);
  }
  i(Mue, "assertStaticBlock");
  function jue(e, t) {
    P("AnyTypeAnnotation", e, t);
  }
  i(jue, "assertAnyTypeAnnotation");
  function que(e, t) {
    P("ArrayTypeAnnotation", e, t);
  }
  i(que, "assertArrayTypeAnnotation");
  function $ue(e, t) {
    P("BooleanTypeAnnotation", e, t);
  }
  i($ue, "assertBooleanTypeAnnotation");
  function Uue(e, t) {
    P("BooleanLiteralTypeAnnotation", e, t);
  }
  i(Uue, "assertBooleanLiteralTypeAnnotation");
  function Vue(e, t) {
    P("NullLiteralTypeAnnotation", e, t);
  }
  i(Vue, "assertNullLiteralTypeAnnotation");
  function Wue(e, t) {
    P("ClassImplements", e, t);
  }
  i(Wue, "assertClassImplements");
  function Hue(e, t) {
    P("DeclareClass", e, t);
  }
  i(Hue, "assertDeclareClass");
  function Gue(e, t) {
    P("DeclareFunction", e, t);
  }
  i(Gue, "assertDeclareFunction");
  function Kue(e, t) {
    P("DeclareInterface", e, t);
  }
  i(Kue, "assertDeclareInterface");
  function Yue(e, t) {
    P("DeclareModule", e, t);
  }
  i(Yue, "assertDeclareModule");
  function Xue(e, t) {
    P("DeclareModuleExports", e, t);
  }
  i(Xue, "assertDeclareModuleExports");
  function zue(e, t) {
    P("DeclareTypeAlias", e, t);
  }
  i(zue, "assertDeclareTypeAlias");
  function Jue(e, t) {
    P("DeclareOpaqueType", e, t);
  }
  i(Jue, "assertDeclareOpaqueType");
  function Que(e, t) {
    P("DeclareVariable", e, t);
  }
  i(Que, "assertDeclareVariable");
  function Zue(e, t) {
    P("DeclareExportDeclaration", e, t);
  }
  i(Zue, "assertDeclareExportDeclaration");
  function ece(e, t) {
    P("DeclareExportAllDeclaration", e, t);
  }
  i(ece, "assertDeclareExportAllDeclaration");
  function tce(e, t) {
    P("DeclaredPredicate", e, t);
  }
  i(tce, "assertDeclaredPredicate");
  function rce(e, t) {
    P("ExistsTypeAnnotation", e, t);
  }
  i(rce, "assertExistsTypeAnnotation");
  function sce(e, t) {
    P("FunctionTypeAnnotation", e, t);
  }
  i(sce, "assertFunctionTypeAnnotation");
  function nce(e, t) {
    P("FunctionTypeParam", e, t);
  }
  i(nce, "assertFunctionTypeParam");
  function ice(e, t) {
    P("GenericTypeAnnotation", e, t);
  }
  i(ice, "assertGenericTypeAnnotation");
  function ace(e, t) {
    P("InferredPredicate", e, t);
  }
  i(ace, "assertInferredPredicate");
  function oce(e, t) {
    P("InterfaceExtends", e, t);
  }
  i(oce, "assertInterfaceExtends");
  function lce(e, t) {
    P("InterfaceDeclaration", e, t);
  }
  i(lce, "assertInterfaceDeclaration");
  function uce(e, t) {
    P("InterfaceTypeAnnotation", e, t);
  }
  i(uce, "assertInterfaceTypeAnnotation");
  function cce(e, t) {
    P("IntersectionTypeAnnotation", e, t);
  }
  i(cce, "assertIntersectionTypeAnnotation");
  function fce(e, t) {
    P("MixedTypeAnnotation", e, t);
  }
  i(fce, "assertMixedTypeAnnotation");
  function pce(e, t) {
    P("EmptyTypeAnnotation", e, t);
  }
  i(pce, "assertEmptyTypeAnnotation");
  function dce(e, t) {
    P("NullableTypeAnnotation", e, t);
  }
  i(dce, "assertNullableTypeAnnotation");
  function hce(e, t) {
    P("NumberLiteralTypeAnnotation", e, t);
  }
  i(hce, "assertNumberLiteralTypeAnnotation");
  function mce(e, t) {
    P("NumberTypeAnnotation", e, t);
  }
  i(mce, "assertNumberTypeAnnotation");
  function yce(e, t) {
    P("ObjectTypeAnnotation", e, t);
  }
  i(yce, "assertObjectTypeAnnotation");
  function gce(e, t) {
    P("ObjectTypeInternalSlot", e, t);
  }
  i(gce, "assertObjectTypeInternalSlot");
  function bce(e, t) {
    P("ObjectTypeCallProperty", e, t);
  }
  i(bce, "assertObjectTypeCallProperty");
  function Ece(e, t) {
    P("ObjectTypeIndexer", e, t);
  }
  i(Ece, "assertObjectTypeIndexer");
  function vce(e, t) {
    P("ObjectTypeProperty", e, t);
  }
  i(vce, "assertObjectTypeProperty");
  function Sce(e, t) {
    P("ObjectTypeSpreadProperty", e, t);
  }
  i(Sce, "assertObjectTypeSpreadProperty");
  function Tce(e, t) {
    P("OpaqueType", e, t);
  }
  i(Tce, "assertOpaqueType");
  function xce(e, t) {
    P("QualifiedTypeIdentifier", e, t);
  }
  i(xce, "assertQualifiedTypeIdentifier");
  function Pce(e, t) {
    P("StringLiteralTypeAnnotation", e, t);
  }
  i(Pce, "assertStringLiteralTypeAnnotation");
  function Ace(e, t) {
    P("StringTypeAnnotation", e, t);
  }
  i(Ace, "assertStringTypeAnnotation");
  function Cce(e, t) {
    P("SymbolTypeAnnotation", e, t);
  }
  i(Cce, "assertSymbolTypeAnnotation");
  function wce(e, t) {
    P("ThisTypeAnnotation", e, t);
  }
  i(wce, "assertThisTypeAnnotation");
  function Dce(e, t) {
    P("TupleTypeAnnotation", e, t);
  }
  i(Dce, "assertTupleTypeAnnotation");
  function Ice(e, t) {
    P("TypeofTypeAnnotation", e, t);
  }
  i(Ice, "assertTypeofTypeAnnotation");
  function _ce(e, t) {
    P("TypeAlias", e, t);
  }
  i(_ce, "assertTypeAlias");
  function Oce(e, t) {
    P("TypeAnnotation", e, t);
  }
  i(Oce, "assertTypeAnnotation");
  function Nce(e, t) {
    P("TypeCastExpression", e, t);
  }
  i(Nce, "assertTypeCastExpression");
  function Rce(e, t) {
    P("TypeParameter", e, t);
  }
  i(Rce, "assertTypeParameter");
  function kce(e, t) {
    P("TypeParameterDeclaration", e, t);
  }
  i(kce, "assertTypeParameterDeclaration");
  function Fce(e, t) {
    P("TypeParameterInstantiation", e, t);
  }
  i(Fce, "assertTypeParameterInstantiation");
  function Lce(e, t) {
    P("UnionTypeAnnotation", e, t);
  }
  i(Lce, "assertUnionTypeAnnotation");
  function Bce(e, t) {
    P("Variance", e, t);
  }
  i(Bce, "assertVariance");
  function Mce(e, t) {
    P("VoidTypeAnnotation", e, t);
  }
  i(Mce, "assertVoidTypeAnnotation");
  function jce(e, t) {
    P("EnumDeclaration", e, t);
  }
  i(jce, "assertEnumDeclaration");
  function qce(e, t) {
    P("EnumBooleanBody", e, t);
  }
  i(qce, "assertEnumBooleanBody");
  function $ce(e, t) {
    P("EnumNumberBody", e, t);
  }
  i($ce, "assertEnumNumberBody");
  function Uce(e, t) {
    P("EnumStringBody", e, t);
  }
  i(Uce, "assertEnumStringBody");
  function Vce(e, t) {
    P("EnumSymbolBody", e, t);
  }
  i(Vce, "assertEnumSymbolBody");
  function Wce(e, t) {
    P("EnumBooleanMember", e, t);
  }
  i(Wce, "assertEnumBooleanMember");
  function Hce(e, t) {
    P("EnumNumberMember", e, t);
  }
  i(Hce, "assertEnumNumberMember");
  function Gce(e, t) {
    P("EnumStringMember", e, t);
  }
  i(Gce, "assertEnumStringMember");
  function Kce(e, t) {
    P("EnumDefaultedMember", e, t);
  }
  i(Kce, "assertEnumDefaultedMember");
  function Yce(e, t) {
    P("IndexedAccessType", e, t);
  }
  i(Yce, "assertIndexedAccessType");
  function Xce(e, t) {
    P("OptionalIndexedAccessType", e, t);
  }
  i(Xce, "assertOptionalIndexedAccessType");
  function zce(e, t) {
    P("JSXAttribute", e, t);
  }
  i(zce, "assertJSXAttribute");
  function Jce(e, t) {
    P("JSXClosingElement", e, t);
  }
  i(Jce, "assertJSXClosingElement");
  function Qce(e, t) {
    P("JSXElement", e, t);
  }
  i(Qce, "assertJSXElement");
  function Zce(e, t) {
    P("JSXEmptyExpression", e, t);
  }
  i(Zce, "assertJSXEmptyExpression");
  function efe(e, t) {
    P("JSXExpressionContainer", e, t);
  }
  i(efe, "assertJSXExpressionContainer");
  function tfe(e, t) {
    P("JSXSpreadChild", e, t);
  }
  i(tfe, "assertJSXSpreadChild");
  function rfe(e, t) {
    P("JSXIdentifier", e, t);
  }
  i(rfe, "assertJSXIdentifier");
  function sfe(e, t) {
    P("JSXMemberExpression", e, t);
  }
  i(sfe, "assertJSXMemberExpression");
  function nfe(e, t) {
    P("JSXNamespacedName", e, t);
  }
  i(nfe, "assertJSXNamespacedName");
  function ife(e, t) {
    P("JSXOpeningElement", e, t);
  }
  i(ife, "assertJSXOpeningElement");
  function afe(e, t) {
    P("JSXSpreadAttribute", e, t);
  }
  i(afe, "assertJSXSpreadAttribute");
  function ofe(e, t) {
    P("JSXText", e, t);
  }
  i(ofe, "assertJSXText");
  function lfe(e, t) {
    P("JSXFragment", e, t);
  }
  i(lfe, "assertJSXFragment");
  function ufe(e, t) {
    P("JSXOpeningFragment", e, t);
  }
  i(ufe, "assertJSXOpeningFragment");
  function cfe(e, t) {
    P("JSXClosingFragment", e, t);
  }
  i(cfe, "assertJSXClosingFragment");
  function ffe(e, t) {
    P("Noop", e, t);
  }
  i(ffe, "assertNoop");
  function pfe(e, t) {
    P("Placeholder", e, t);
  }
  i(pfe, "assertPlaceholder");
  function dfe(e, t) {
    P("V8IntrinsicIdentifier", e, t);
  }
  i(dfe, "assertV8IntrinsicIdentifier");
  function hfe(e, t) {
    P("ArgumentPlaceholder", e, t);
  }
  i(hfe, "assertArgumentPlaceholder");
  function mfe(e, t) {
    P("BindExpression", e, t);
  }
  i(mfe, "assertBindExpression");
  function yfe(e, t) {
    P("ImportAttribute", e, t);
  }
  i(yfe, "assertImportAttribute");
  function gfe(e, t) {
    P("Decorator", e, t);
  }
  i(gfe, "assertDecorator");
  function bfe(e, t) {
    P("DoExpression", e, t);
  }
  i(bfe, "assertDoExpression");
  function Efe(e, t) {
    P("ExportDefaultSpecifier", e, t);
  }
  i(Efe, "assertExportDefaultSpecifier");
  function vfe(e, t) {
    P("RecordExpression", e, t);
  }
  i(vfe, "assertRecordExpression");
  function Sfe(e, t) {
    P("TupleExpression", e, t);
  }
  i(Sfe, "assertTupleExpression");
  function Tfe(e, t) {
    P("DecimalLiteral", e, t);
  }
  i(Tfe, "assertDecimalLiteral");
  function xfe(e, t) {
    P("ModuleExpression", e, t);
  }
  i(xfe, "assertModuleExpression");
  function Pfe(e, t) {
    P("TopicReference", e, t);
  }
  i(Pfe, "assertTopicReference");
  function Afe(e, t) {
    P("PipelineTopicExpression", e, t);
  }
  i(Afe, "assertPipelineTopicExpression");
  function Cfe(e, t) {
    P("PipelineBareFunction", e, t);
  }
  i(Cfe, "assertPipelineBareFunction");
  function wfe(e, t) {
    P("PipelinePrimaryTopicReference", e, t);
  }
  i(wfe, "assertPipelinePrimaryTopicReference");
  function Dfe(e, t) {
    P("TSParameterProperty", e, t);
  }
  i(Dfe, "assertTSParameterProperty");
  function Ife(e, t) {
    P("TSDeclareFunction", e, t);
  }
  i(Ife, "assertTSDeclareFunction");
  function _fe(e, t) {
    P("TSDeclareMethod", e, t);
  }
  i(_fe, "assertTSDeclareMethod");
  function Ofe(e, t) {
    P("TSQualifiedName", e, t);
  }
  i(Ofe, "assertTSQualifiedName");
  function Nfe(e, t) {
    P("TSCallSignatureDeclaration", e, t);
  }
  i(Nfe, "assertTSCallSignatureDeclaration");
  function Rfe(e, t) {
    P("TSConstructSignatureDeclaration", e, t);
  }
  i(Rfe, "assertTSConstructSignatureDeclaration");
  function kfe(e, t) {
    P("TSPropertySignature", e, t);
  }
  i(kfe, "assertTSPropertySignature");
  function Ffe(e, t) {
    P("TSMethodSignature", e, t);
  }
  i(Ffe, "assertTSMethodSignature");
  function Lfe(e, t) {
    P("TSIndexSignature", e, t);
  }
  i(Lfe, "assertTSIndexSignature");
  function Bfe(e, t) {
    P("TSAnyKeyword", e, t);
  }
  i(Bfe, "assertTSAnyKeyword");
  function Mfe(e, t) {
    P("TSBooleanKeyword", e, t);
  }
  i(Mfe, "assertTSBooleanKeyword");
  function jfe(e, t) {
    P("TSBigIntKeyword", e, t);
  }
  i(jfe, "assertTSBigIntKeyword");
  function qfe(e, t) {
    P("TSIntrinsicKeyword", e, t);
  }
  i(qfe, "assertTSIntrinsicKeyword");
  function $fe(e, t) {
    P("TSNeverKeyword", e, t);
  }
  i($fe, "assertTSNeverKeyword");
  function Ufe(e, t) {
    P("TSNullKeyword", e, t);
  }
  i(Ufe, "assertTSNullKeyword");
  function Vfe(e, t) {
    P("TSNumberKeyword", e, t);
  }
  i(Vfe, "assertTSNumberKeyword");
  function Wfe(e, t) {
    P("TSObjectKeyword", e, t);
  }
  i(Wfe, "assertTSObjectKeyword");
  function Hfe(e, t) {
    P("TSStringKeyword", e, t);
  }
  i(Hfe, "assertTSStringKeyword");
  function Gfe(e, t) {
    P("TSSymbolKeyword", e, t);
  }
  i(Gfe, "assertTSSymbolKeyword");
  function Kfe(e, t) {
    P("TSUndefinedKeyword", e, t);
  }
  i(Kfe, "assertTSUndefinedKeyword");
  function Yfe(e, t) {
    P("TSUnknownKeyword", e, t);
  }
  i(Yfe, "assertTSUnknownKeyword");
  function Xfe(e, t) {
    P("TSVoidKeyword", e, t);
  }
  i(Xfe, "assertTSVoidKeyword");
  function zfe(e, t) {
    P("TSThisType", e, t);
  }
  i(zfe, "assertTSThisType");
  function Jfe(e, t) {
    P("TSFunctionType", e, t);
  }
  i(Jfe, "assertTSFunctionType");
  function Qfe(e, t) {
    P("TSConstructorType", e, t);
  }
  i(Qfe, "assertTSConstructorType");
  function Zfe(e, t) {
    P("TSTypeReference", e, t);
  }
  i(Zfe, "assertTSTypeReference");
  function epe(e, t) {
    P("TSTypePredicate", e, t);
  }
  i(epe, "assertTSTypePredicate");
  function tpe(e, t) {
    P("TSTypeQuery", e, t);
  }
  i(tpe, "assertTSTypeQuery");
  function rpe(e, t) {
    P("TSTypeLiteral", e, t);
  }
  i(rpe, "assertTSTypeLiteral");
  function spe(e, t) {
    P("TSArrayType", e, t);
  }
  i(spe, "assertTSArrayType");
  function npe(e, t) {
    P("TSTupleType", e, t);
  }
  i(npe, "assertTSTupleType");
  function ipe(e, t) {
    P("TSOptionalType", e, t);
  }
  i(ipe, "assertTSOptionalType");
  function ape(e, t) {
    P("TSRestType", e, t);
  }
  i(ape, "assertTSRestType");
  function ope(e, t) {
    P("TSNamedTupleMember", e, t);
  }
  i(ope, "assertTSNamedTupleMember");
  function lpe(e, t) {
    P("TSUnionType", e, t);
  }
  i(lpe, "assertTSUnionType");
  function upe(e, t) {
    P("TSIntersectionType", e, t);
  }
  i(upe, "assertTSIntersectionType");
  function cpe(e, t) {
    P("TSConditionalType", e, t);
  }
  i(cpe, "assertTSConditionalType");
  function fpe(e, t) {
    P("TSInferType", e, t);
  }
  i(fpe, "assertTSInferType");
  function ppe(e, t) {
    P("TSParenthesizedType", e, t);
  }
  i(ppe, "assertTSParenthesizedType");
  function dpe(e, t) {
    P("TSTypeOperator", e, t);
  }
  i(dpe, "assertTSTypeOperator");
  function hpe(e, t) {
    P("TSIndexedAccessType", e, t);
  }
  i(hpe, "assertTSIndexedAccessType");
  function mpe(e, t) {
    P("TSMappedType", e, t);
  }
  i(mpe, "assertTSMappedType");
  function ype(e, t) {
    P("TSLiteralType", e, t);
  }
  i(ype, "assertTSLiteralType");
  function gpe(e, t) {
    P("TSExpressionWithTypeArguments", e, t);
  }
  i(gpe, "assertTSExpressionWithTypeArguments");
  function bpe(e, t) {
    P("TSInterfaceDeclaration", e, t);
  }
  i(bpe, "assertTSInterfaceDeclaration");
  function Epe(e, t) {
    P("TSInterfaceBody", e, t);
  }
  i(Epe, "assertTSInterfaceBody");
  function vpe(e, t) {
    P("TSTypeAliasDeclaration", e, t);
  }
  i(vpe, "assertTSTypeAliasDeclaration");
  function Spe(e, t) {
    P("TSInstantiationExpression", e, t);
  }
  i(Spe, "assertTSInstantiationExpression");
  function Tpe(e, t) {
    P("TSAsExpression", e, t);
  }
  i(Tpe, "assertTSAsExpression");
  function xpe(e, t) {
    P("TSSatisfiesExpression", e, t);
  }
  i(xpe, "assertTSSatisfiesExpression");
  function Ppe(e, t) {
    P("TSTypeAssertion", e, t);
  }
  i(Ppe, "assertTSTypeAssertion");
  function Ape(e, t) {
    P("TSEnumDeclaration", e, t);
  }
  i(Ape, "assertTSEnumDeclaration");
  function Cpe(e, t) {
    P("TSEnumMember", e, t);
  }
  i(Cpe, "assertTSEnumMember");
  function wpe(e, t) {
    P("TSModuleDeclaration", e, t);
  }
  i(wpe, "assertTSModuleDeclaration");
  function Dpe(e, t) {
    P("TSModuleBlock", e, t);
  }
  i(Dpe, "assertTSModuleBlock");
  function Ipe(e, t) {
    P("TSImportType", e, t);
  }
  i(Ipe, "assertTSImportType");
  function _pe(e, t) {
    P("TSImportEqualsDeclaration", e, t);
  }
  i(_pe, "assertTSImportEqualsDeclaration");
  function Ope(e, t) {
    P("TSExternalModuleReference", e, t);
  }
  i(Ope, "assertTSExternalModuleReference");
  function Npe(e, t) {
    P("TSNonNullExpression", e, t);
  }
  i(Npe, "assertTSNonNullExpression");
  function Rpe(e, t) {
    P("TSExportAssignment", e, t);
  }
  i(Rpe, "assertTSExportAssignment");
  function kpe(e, t) {
    P("TSNamespaceExportDeclaration", e, t);
  }
  i(kpe, "assertTSNamespaceExportDeclaration");
  function Fpe(e, t) {
    P("TSTypeAnnotation", e, t);
  }
  i(Fpe, "assertTSTypeAnnotation");
  function Lpe(e, t) {
    P("TSTypeParameterInstantiation", e, t);
  }
  i(Lpe, "assertTSTypeParameterInstantiation");
  function Bpe(e, t) {
    P("TSTypeParameterDeclaration", e, t);
  }
  i(Bpe, "assertTSTypeParameterDeclaration");
  function Mpe(e, t) {
    P("TSTypeParameter", e, t);
  }
  i(Mpe, "assertTSTypeParameter");
  function jpe(e, t) {
    P("Standardized", e, t);
  }
  i(jpe, "assertStandardized");
  function qpe(e, t) {
    P("Expression", e, t);
  }
  i(qpe, "assertExpression");
  function $pe(e, t) {
    P("Binary", e, t);
  }
  i($pe, "assertBinary");
  function Upe(e, t) {
    P("Scopable", e, t);
  }
  i(Upe, "assertScopable");
  function Vpe(e, t) {
    P("BlockParent", e, t);
  }
  i(Vpe, "assertBlockParent");
  function Wpe(e, t) {
    P("Block", e, t);
  }
  i(Wpe, "assertBlock");
  function Hpe(e, t) {
    P("Statement", e, t);
  }
  i(Hpe, "assertStatement");
  function Gpe(e, t) {
    P("Terminatorless", e, t);
  }
  i(Gpe, "assertTerminatorless");
  function Kpe(e, t) {
    P("CompletionStatement", e, t);
  }
  i(Kpe, "assertCompletionStatement");
  function Ype(e, t) {
    P("Conditional", e, t);
  }
  i(Ype, "assertConditional");
  function Xpe(e, t) {
    P("Loop", e, t);
  }
  i(Xpe, "assertLoop");
  function zpe(e, t) {
    P("While", e, t);
  }
  i(zpe, "assertWhile");
  function Jpe(e, t) {
    P("ExpressionWrapper", e, t);
  }
  i(Jpe, "assertExpressionWrapper");
  function Qpe(e, t) {
    P("For", e, t);
  }
  i(Qpe, "assertFor");
  function Zpe(e, t) {
    P("ForXStatement", e, t);
  }
  i(Zpe, "assertForXStatement");
  function ede(e, t) {
    P("Function", e, t);
  }
  i(ede, "assertFunction");
  function tde(e, t) {
    P("FunctionParent", e, t);
  }
  i(tde, "assertFunctionParent");
  function rde(e, t) {
    P("Pureish", e, t);
  }
  i(rde, "assertPureish");
  function sde(e, t) {
    P("Declaration", e, t);
  }
  i(sde, "assertDeclaration");
  function nde(e, t) {
    P("PatternLike", e, t);
  }
  i(nde, "assertPatternLike");
  function ide(e, t) {
    P("LVal", e, t);
  }
  i(ide, "assertLVal");
  function ade(e, t) {
    P("TSEntityName", e, t);
  }
  i(ade, "assertTSEntityName");
  function ode(e, t) {
    P("Literal", e, t);
  }
  i(ode, "assertLiteral");
  function lde(e, t) {
    P("Immutable", e, t);
  }
  i(lde, "assertImmutable");
  function ude(e, t) {
    P("UserWhitespacable", e, t);
  }
  i(ude, "assertUserWhitespacable");
  function cde(e, t) {
    P("Method", e, t);
  }
  i(cde, "assertMethod");
  function fde(e, t) {
    P("ObjectMember", e, t);
  }
  i(fde, "assertObjectMember");
  function pde(e, t) {
    P("Property", e, t);
  }
  i(pde, "assertProperty");
  function dde(e, t) {
    P("UnaryLike", e, t);
  }
  i(dde, "assertUnaryLike");
  function hde(e, t) {
    P("Pattern", e, t);
  }
  i(hde, "assertPattern");
  function mde(e, t) {
    P("Class", e, t);
  }
  i(mde, "assertClass");
  function yde(e, t) {
    P("ImportOrExportDeclaration", e, t);
  }
  i(yde, "assertImportOrExportDeclaration");
  function gde(e, t) {
    P("ExportDeclaration", e, t);
  }
  i(gde, "assertExportDeclaration");
  function bde(e, t) {
    P("ModuleSpecifier", e, t);
  }
  i(bde, "assertModuleSpecifier");
  function Ede(e, t) {
    P("Accessor", e, t);
  }
  i(Ede, "assertAccessor");
  function vde(e, t) {
    P("Private", e, t);
  }
  i(vde, "assertPrivate");
  function Sde(e, t) {
    P("Flow", e, t);
  }
  i(Sde, "assertFlow");
  function Tde(e, t) {
    P("FlowType", e, t);
  }
  i(Tde, "assertFlowType");
  function xde(e, t) {
    P("FlowBaseAnnotation", e, t);
  }
  i(xde, "assertFlowBaseAnnotation");
  function Pde(e, t) {
    P("FlowDeclaration", e, t);
  }
  i(Pde, "assertFlowDeclaration");
  function Ade(e, t) {
    P("FlowPredicate", e, t);
  }
  i(Ade, "assertFlowPredicate");
  function Cde(e, t) {
    P("EnumBody", e, t);
  }
  i(Cde, "assertEnumBody");
  function wde(e, t) {
    P("EnumMember", e, t);
  }
  i(wde, "assertEnumMember");
  function Dde(e, t) {
    P("JSX", e, t);
  }
  i(Dde, "assertJSX");
  function Ide(e, t) {
    P("Miscellaneous", e, t);
  }
  i(Ide, "assertMiscellaneous");
  function _de(e, t) {
    P("TypeScript", e, t);
  }
  i(_de, "assertTypeScript");
  function Ode(e, t) {
    P("TSTypeElement", e, t);
  }
  i(Ode, "assertTSTypeElement");
  function Nde(e, t) {
    P("TSType", e, t);
  }
  i(Nde, "assertTSType");
  function Rde(e, t) {
    P("TSBaseType", e, t);
  }
  i(Rde, "assertTSBaseType");
  function kde(e, t) {
    (0, ic.default)("assertNumberLiteral", "assertNumericLiteral"), P("NumberLiteral", e, t);
  }
  i(kde, "assertNumberLiteral");
  function Fde(e, t) {
    (0, ic.default)("assertRegexLiteral", "assertRegExpLiteral"), P("RegexLiteral", e, t);
  }
  i(Fde, "assertRegexLiteral");
  function Lde(e, t) {
    (0, ic.default)("assertRestProperty", "assertRestElement"), P("RestProperty", e, t);
  }
  i(Lde, "assertRestProperty");
  function Bde(e, t) {
    (0, ic.default)("assertSpreadProperty", "assertSpreadElement"), P("SpreadProperty", e, t);
  }
  i(Bde, "assertSpreadProperty");
  function Mde(e, t) {
    (0, ic.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), P("ModuleDeclaration", e, t);
  }
  i(Mde, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var ik = y((Xp) => {
  "use strict";
  Object.defineProperty(Xp, "__esModule", {
    value: !0
  });
  Xp.default = void 0;
  var cn = ns(), RXe = Xp.default = jde;
  function jde(e) {
    switch (e) {
      case "string":
        return (0, cn.stringTypeAnnotation)();
      case "number":
        return (0, cn.numberTypeAnnotation)();
      case "undefined":
        return (0, cn.voidTypeAnnotation)();
      case "boolean":
        return (0, cn.booleanTypeAnnotation)();
      case "function":
        return (0, cn.genericTypeAnnotation)((0, cn.identifier)("Function"));
      case "object":
        return (0, cn.genericTypeAnnotation)((0, cn.identifier)("Object"));
      case "symbol":
        return (0, cn.genericTypeAnnotation)((0, cn.identifier)("Symbol"));
      case "bigint":
        return (0, cn.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e);
  }
  i(jde, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var Ub = y(($b) => {
  "use strict";
  Object.defineProperty($b, "__esModule", {
    value: !0
  });
  $b.default = ok;
  var ac = hr();
  function ak(e) {
    return (0, ac.isIdentifier)(e) ? e.name : `${e.id.name}.${ak(e.qualification)}`;
  }
  i(ak, "getQualifiedName");
  function ok(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, ac.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, ac.isFlowBaseAnnotation)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, ac.isUnionTypeAnnotation)(l)) {
          n.has(l.types) || (t.push(...l.types), n.add(l.types));
          continue;
        }
        if ((0, ac.isGenericTypeAnnotation)(l)) {
          let u = ak(l.id);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = ok(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  i(ok, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var lk = y((Vb) => {
  "use strict";
  Object.defineProperty(Vb, "__esModule", {
    value: !0
  });
  Vb.default = Ude;
  var qde = ns(), $de = Ub();
  function Ude(e) {
    let t = (0, $de.default)(e);
    return t.length === 1 ? t[0] : (0, qde.unionTypeAnnotation)(t);
  }
  i(Ude, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var fk = y((Wb) => {
  "use strict";
  Object.defineProperty(Wb, "__esModule", {
    value: !0
  });
  Wb.default = ck;
  var oc = hr();
  function uk(e) {
    return (0, oc.isIdentifier)(e) ? e.name : `${e.right.name}.${uk(e.left)}`;
  }
  i(uk, "getQualifiedName");
  function ck(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, oc.isTSAnyKeyword)(l))
          return [l];
        if ((0, oc.isTSBaseType)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, oc.isTSUnionType)(l)) {
          n.has(l.types) || (t.push(...l.types), n.add(l.types));
          continue;
        }
        if ((0, oc.isTSTypeReference)(l) && l.typeParameters) {
          let u = uk(l.typeName);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = ck(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  i(ck, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var pk = y((Hb) => {
  "use strict";
  Object.defineProperty(Hb, "__esModule", {
    value: !0
  });
  Hb.default = Gde;
  var Vde = ns(), Wde = fk(), Hde = hr();
  function Gde(e) {
    let t = e.map((s) => (0, Hde.isTSTypeAnnotation)(s) ? s.typeAnnotation : s), r = (0, Wde.default)(t);
    return r.length === 1 ? r[0] : (0, Vde.tsUnionType)(r);
  }
  i(Gde, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var dk = y((_) => {
  "use strict";
  Object.defineProperty(_, "__esModule", {
    value: !0
  });
  Object.defineProperty(_, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(_, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.arrayExpression;
    }, "get")
  });
  Object.defineProperty(_, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.arrayPattern;
    }, "get")
  });
  Object.defineProperty(_, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(_, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(_, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(_, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.awaitExpression;
    }, "get")
  });
  Object.defineProperty(_, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(_, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.binaryExpression;
    }, "get")
  });
  Object.defineProperty(_, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.bindExpression;
    }, "get")
  });
  Object.defineProperty(_, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.blockStatement;
    }, "get")
  });
  Object.defineProperty(_, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(_, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.breakStatement;
    }, "get")
  });
  Object.defineProperty(_, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.callExpression;
    }, "get")
  });
  Object.defineProperty(_, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.catchClause;
    }, "get")
  });
  Object.defineProperty(_, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(_, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.classBody;
    }, "get")
  });
  Object.defineProperty(_, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.classDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.classExpression;
    }, "get")
  });
  Object.defineProperty(_, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.classImplements;
    }, "get")
  });
  Object.defineProperty(_, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.classMethod;
    }, "get")
  });
  Object.defineProperty(_, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(_, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(_, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.classProperty;
    }, "get")
  });
  Object.defineProperty(_, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(_, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.continueStatement;
    }, "get")
  });
  Object.defineProperty(_, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(_, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(_, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareClass;
    }, "get")
  });
  Object.defineProperty(_, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareFunction;
    }, "get")
  });
  Object.defineProperty(_, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareInterface;
    }, "get")
  });
  Object.defineProperty(_, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareModule;
    }, "get")
  });
  Object.defineProperty(_, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(_, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(_, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(_, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declareVariable;
    }, "get")
  });
  Object.defineProperty(_, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(_, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.decorator;
    }, "get")
  });
  Object.defineProperty(_, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.directive;
    }, "get")
  });
  Object.defineProperty(_, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(_, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.doExpression;
    }, "get")
  });
  Object.defineProperty(_, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(_, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.emptyStatement;
    }, "get")
  });
  Object.defineProperty(_, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(_, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(_, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(_, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(_, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(_, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.enumStringBody;
    }, "get")
  });
  Object.defineProperty(_, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.enumStringMember;
    }, "get")
  });
  Object.defineProperty(_, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(_, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(_, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(_, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(_, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.expressionStatement;
    }, "get")
  });
  Object.defineProperty(_, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.file;
    }, "get")
  });
  Object.defineProperty(_, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.forInStatement;
    }, "get")
  });
  Object.defineProperty(_, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.forOfStatement;
    }, "get")
  });
  Object.defineProperty(_, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.forStatement;
    }, "get")
  });
  Object.defineProperty(_, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.functionExpression;
    }, "get")
  });
  Object.defineProperty(_, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(_, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.identifier;
    }, "get")
  });
  Object.defineProperty(_, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.ifStatement;
    }, "get")
  });
  Object.defineProperty(_, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.import;
    }, "get")
  });
  Object.defineProperty(_, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.importAttribute;
    }, "get")
  });
  Object.defineProperty(_, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.importDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(_, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.importExpression;
    }, "get")
  });
  Object.defineProperty(_, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(_, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.importSpecifier;
    }, "get")
  });
  Object.defineProperty(_, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(_, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(_, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(_, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(_, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(_, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(_, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(_, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxElement;
    }, "get")
  });
  Object.defineProperty(_, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(_, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(_, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxFragment;
    }, "get")
  });
  Object.defineProperty(_, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(_, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(_, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(_, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(_, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(_, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(_, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(_, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.jsxText;
    }, "get")
  });
  Object.defineProperty(_, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.labeledStatement;
    }, "get")
  });
  Object.defineProperty(_, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.logicalExpression;
    }, "get")
  });
  Object.defineProperty(_, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.memberExpression;
    }, "get")
  });
  Object.defineProperty(_, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.metaProperty;
    }, "get")
  });
  Object.defineProperty(_, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.moduleExpression;
    }, "get")
  });
  Object.defineProperty(_, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.newExpression;
    }, "get")
  });
  Object.defineProperty(_, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.noop;
    }, "get")
  });
  Object.defineProperty(_, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.nullLiteral;
    }, "get")
  });
  Object.defineProperty(_, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.numberLiteral;
    }, "get")
  });
  Object.defineProperty(_, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.numericLiteral;
    }, "get")
  });
  Object.defineProperty(_, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectExpression;
    }, "get")
  });
  Object.defineProperty(_, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectMethod;
    }, "get")
  });
  Object.defineProperty(_, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectPattern;
    }, "get")
  });
  Object.defineProperty(_, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectProperty;
    }, "get")
  });
  Object.defineProperty(_, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(_, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(_, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(_, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(_, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(_, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.opaqueType;
    }, "get")
  });
  Object.defineProperty(_, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(_, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(_, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(_, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(_, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(_, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(_, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(_, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.placeholder;
    }, "get")
  });
  Object.defineProperty(_, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.privateName;
    }, "get")
  });
  Object.defineProperty(_, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.program;
    }, "get")
  });
  Object.defineProperty(_, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(_, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.recordExpression;
    }, "get")
  });
  Object.defineProperty(_, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(_, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.regexLiteral;
    }, "get")
  });
  Object.defineProperty(_, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.restElement;
    }, "get")
  });
  Object.defineProperty(_, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.restProperty;
    }, "get")
  });
  Object.defineProperty(_, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.returnStatement;
    }, "get")
  });
  Object.defineProperty(_, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(_, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.spreadElement;
    }, "get")
  });
  Object.defineProperty(_, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.spreadProperty;
    }, "get")
  });
  Object.defineProperty(_, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.staticBlock;
    }, "get")
  });
  Object.defineProperty(_, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.stringLiteral;
    }, "get")
  });
  Object.defineProperty(_, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.super;
    }, "get")
  });
  Object.defineProperty(_, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.switchCase;
    }, "get")
  });
  Object.defineProperty(_, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.switchStatement;
    }, "get")
  });
  Object.defineProperty(_, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsArrayType;
    }, "get")
  });
  Object.defineProperty(_, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(_, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(_, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(_, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(_, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(_, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(_, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(_, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(_, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(_, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(_, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsImportType;
    }, "get")
  });
  Object.defineProperty(_, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(_, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(_, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsInferType;
    }, "get")
  });
  Object.defineProperty(_, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(_, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(_, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(_, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(_, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsMappedType;
    }, "get")
  });
  Object.defineProperty(_, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(_, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(_, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(_, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(_, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(_, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(_, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(_, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(_, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(_, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsRestType;
    }, "get")
  });
  Object.defineProperty(_, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(_, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsThisType;
    }, "get")
  });
  Object.defineProperty(_, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTupleType;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(_, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(_, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(_, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsUnionType;
    }, "get")
  });
  Object.defineProperty(_, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(_, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(_, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.templateElement;
    }, "get")
  });
  Object.defineProperty(_, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.templateLiteral;
    }, "get")
  });
  Object.defineProperty(_, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.thisExpression;
    }, "get")
  });
  Object.defineProperty(_, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.throwStatement;
    }, "get")
  });
  Object.defineProperty(_, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.topicReference;
    }, "get")
  });
  Object.defineProperty(_, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tryStatement;
    }, "get")
  });
  Object.defineProperty(_, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tupleExpression;
    }, "get")
  });
  Object.defineProperty(_, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.typeAlias;
    }, "get")
  });
  Object.defineProperty(_, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(_, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.typeParameter;
    }, "get")
  });
  Object.defineProperty(_, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(_, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.unaryExpression;
    }, "get")
  });
  Object.defineProperty(_, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.updateExpression;
    }, "get")
  });
  Object.defineProperty(_, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(_, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(_, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(_, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.variance;
    }, "get")
  });
  Object.defineProperty(_, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(_, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.whileStatement;
    }, "get")
  });
  Object.defineProperty(_, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.withStatement;
    }, "get")
  });
  Object.defineProperty(_, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O.yieldExpression;
    }, "get")
  });
  var O = ns();
});

// ../node_modules/@babel/types/lib/builders/productions.js
var mk = y((Gb) => {
  "use strict";
  Object.defineProperty(Gb, "__esModule", {
    value: !0
  });
  Gb.buildUndefinedNode = Kde;
  var hk = ns();
  function Kde() {
    return (0, hk.unaryExpression)("void", (0, hk.numericLiteral)(0), !0);
  }
  i(Kde, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var ea = y((Kb) => {
  "use strict";
  Object.defineProperty(Kb, "__esModule", {
    value: !0
  });
  Kb.default = Yde;
  var yk = Ls(), gk = hr(), {
    hasOwn: fi
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function bk(e, t, r, s) {
    return e && typeof e.type == "string" ? vk(e, t, r, s) : e;
  }
  i(bk, "cloneIfNode");
  function Ek(e, t, r, s) {
    return Array.isArray(e) ? e.map((n) => bk(n, t, r, s)) : bk(e, t, r, s);
  }
  i(Ek, "cloneIfNodeOrArray");
  function Yde(e, t = !0, r = !1) {
    return vk(e, t, r, /* @__PURE__ */ new Map());
  }
  i(Yde, "cloneNode");
  function vk(e, t = !0, r = !1, s) {
    if (!e) return e;
    let {
      type: n
    } = e, a = {
      type: e.type
    };
    if ((0, gk.isIdentifier)(e))
      a.name = e.name, fi(e, "optional") && typeof e.optional == "boolean" && (a.optional = e.optional), fi(e, "typeAnnotation") && (a.typeAnnotation =
      t ? Ek(e.typeAnnotation, !0, r, s) : e.typeAnnotation);
    else if (fi(yk.NODE_FIELDS, n))
      for (let o of Object.keys(yk.NODE_FIELDS[n]))
        fi(e, o) && (t ? a[o] = (0, gk.isFile)(e) && o === "comments" ? zp(e.comments, t, r, s) : Ek(e[o], !0, r, s) : a[o] = e[o]);
    else
      throw new Error(`Unknown node type: "${n}"`);
    return fi(e, "loc") && (r ? a.loc = null : a.loc = e.loc), fi(e, "leadingComments") && (a.leadingComments = zp(e.leadingComments, t, r, s)),
    fi(e, "innerComments") && (a.innerComments = zp(e.innerComments, t, r, s)), fi(e, "trailingComments") && (a.trailingComments = zp(e.trailingComments,
    t, r, s)), fi(e, "extra") && (a.extra = Object.assign({}, e.extra)), a;
  }
  i(vk, "cloneNodeInternal");
  function zp(e, t, r, s) {
    return !e || !t ? e : e.map((n) => {
      let a = s.get(n);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = n, c = {
        type: o,
        value: l,
        loc: u
      };
      return r && (c.loc = null), s.set(n, c), c;
    });
  }
  i(zp, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var Sk = y((Yb) => {
  "use strict";
  Object.defineProperty(Yb, "__esModule", {
    value: !0
  });
  Yb.default = zde;
  var Xde = ea();
  function zde(e) {
    return (0, Xde.default)(e, !1);
  }
  i(zde, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var Tk = y((Xb) => {
  "use strict";
  Object.defineProperty(Xb, "__esModule", {
    value: !0
  });
  Xb.default = Qde;
  var Jde = ea();
  function Qde(e) {
    return (0, Jde.default)(e);
  }
  i(Qde, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var xk = y((zb) => {
  "use strict";
  Object.defineProperty(zb, "__esModule", {
    value: !0
  });
  zb.default = ehe;
  var Zde = ea();
  function ehe(e) {
    return (0, Zde.default)(e, !0, !0);
  }
  i(ehe, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var Pk = y((Jb) => {
  "use strict";
  Object.defineProperty(Jb, "__esModule", {
    value: !0
  });
  Jb.default = rhe;
  var the = ea();
  function rhe(e) {
    return (0, the.default)(e, !1, !0);
  }
  i(rhe, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var Zb = y((Qb) => {
  "use strict";
  Object.defineProperty(Qb, "__esModule", {
    value: !0
  });
  Qb.default = she;
  function she(e, t, r) {
    if (!r || !e) return e;
    let s = `${t}Comments`;
    return e[s] ? t === "leading" ? e[s] = r.concat(e[s]) : e[s].push(...r) : e[s] = r, e;
  }
  i(she, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var Ak = y((eE) => {
  "use strict";
  Object.defineProperty(eE, "__esModule", {
    value: !0
  });
  eE.default = ihe;
  var nhe = Zb();
  function ihe(e, t, r, s) {
    return (0, nhe.default)(e, t, [{
      type: s ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  i(ihe, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var Jp = y((tE) => {
  "use strict";
  Object.defineProperty(tE, "__esModule", {
    value: !0
  });
  tE.default = ahe;
  function ahe(e, t, r) {
    t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
  }
  i(ahe, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var sE = y((rE) => {
  "use strict";
  Object.defineProperty(rE, "__esModule", {
    value: !0
  });
  rE.default = lhe;
  var ohe = Jp();
  function lhe(e, t) {
    (0, ohe.default)("innerComments", e, t);
  }
  i(lhe, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var iE = y((nE) => {
  "use strict";
  Object.defineProperty(nE, "__esModule", {
    value: !0
  });
  nE.default = che;
  var uhe = Jp();
  function che(e, t) {
    (0, uhe.default)("leadingComments", e, t);
  }
  i(che, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var oE = y((aE) => {
  "use strict";
  Object.defineProperty(aE, "__esModule", {
    value: !0
  });
  aE.default = phe;
  var fhe = Jp();
  function phe(e, t) {
    (0, fhe.default)("trailingComments", e, t);
  }
  i(phe, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var uE = y((lE) => {
  "use strict";
  Object.defineProperty(lE, "__esModule", {
    value: !0
  });
  lE.default = yhe;
  var dhe = oE(), hhe = iE(), mhe = sE();
  function yhe(e, t) {
    return (0, dhe.default)(e, t), (0, hhe.default)(e, t), (0, mhe.default)(e, t), e;
  }
  i(yhe, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var Ck = y((cE) => {
  "use strict";
  Object.defineProperty(cE, "__esModule", {
    value: !0
  });
  cE.default = bhe;
  var ghe = Ji();
  function bhe(e) {
    return ghe.COMMENT_KEYS.forEach((t) => {
      e[t] = null;
    }), e;
  }
  i(bhe, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var wk = y((ne) => {
  "use strict";
  Object.defineProperty(ne, "__esModule", {
    value: !0
  });
  ne.WHILE_TYPES = ne.USERWHITESPACABLE_TYPES = ne.UNARYLIKE_TYPES = ne.TYPESCRIPT_TYPES = ne.TSTYPE_TYPES = ne.TSTYPEELEMENT_TYPES = ne.TSENTITYNAME_TYPES =
  ne.TSBASETYPE_TYPES = ne.TERMINATORLESS_TYPES = ne.STATEMENT_TYPES = ne.STANDARDIZED_TYPES = ne.SCOPABLE_TYPES = ne.PUREISH_TYPES = ne.PROPERTY_TYPES =
  ne.PRIVATE_TYPES = ne.PATTERN_TYPES = ne.PATTERNLIKE_TYPES = ne.OBJECTMEMBER_TYPES = ne.MODULESPECIFIER_TYPES = ne.MODULEDECLARATION_TYPES =
  ne.MISCELLANEOUS_TYPES = ne.METHOD_TYPES = ne.LVAL_TYPES = ne.LOOP_TYPES = ne.LITERAL_TYPES = ne.JSX_TYPES = ne.IMPORTOREXPORTDECLARATION_TYPES =
  ne.IMMUTABLE_TYPES = ne.FUNCTION_TYPES = ne.FUNCTIONPARENT_TYPES = ne.FOR_TYPES = ne.FORXSTATEMENT_TYPES = ne.FLOW_TYPES = ne.FLOWTYPE_TYPES =
  ne.FLOWPREDICATE_TYPES = ne.FLOWDECLARATION_TYPES = ne.FLOWBASEANNOTATION_TYPES = ne.EXPRESSION_TYPES = ne.EXPRESSIONWRAPPER_TYPES = ne.EXPORTDECLARATION_TYPES =
  ne.ENUMMEMBER_TYPES = ne.ENUMBODY_TYPES = ne.DECLARATION_TYPES = ne.CONDITIONAL_TYPES = ne.COMPLETIONSTATEMENT_TYPES = ne.CLASS_TYPES = ne.
  BLOCK_TYPES = ne.BLOCKPARENT_TYPES = ne.BINARY_TYPES = ne.ACCESSOR_TYPES = void 0;
  var Me = Ls(), vze = ne.STANDARDIZED_TYPES = Me.FLIPPED_ALIAS_KEYS.Standardized, Sze = ne.EXPRESSION_TYPES = Me.FLIPPED_ALIAS_KEYS.Expression,
  Tze = ne.BINARY_TYPES = Me.FLIPPED_ALIAS_KEYS.Binary, xze = ne.SCOPABLE_TYPES = Me.FLIPPED_ALIAS_KEYS.Scopable, Pze = ne.BLOCKPARENT_TYPES =
  Me.FLIPPED_ALIAS_KEYS.BlockParent, Aze = ne.BLOCK_TYPES = Me.FLIPPED_ALIAS_KEYS.Block, Cze = ne.STATEMENT_TYPES = Me.FLIPPED_ALIAS_KEYS.Statement,
  wze = ne.TERMINATORLESS_TYPES = Me.FLIPPED_ALIAS_KEYS.Terminatorless, Dze = ne.COMPLETIONSTATEMENT_TYPES = Me.FLIPPED_ALIAS_KEYS.CompletionStatement,
  Ize = ne.CONDITIONAL_TYPES = Me.FLIPPED_ALIAS_KEYS.Conditional, _ze = ne.LOOP_TYPES = Me.FLIPPED_ALIAS_KEYS.Loop, Oze = ne.WHILE_TYPES = Me.
  FLIPPED_ALIAS_KEYS.While, Nze = ne.EXPRESSIONWRAPPER_TYPES = Me.FLIPPED_ALIAS_KEYS.ExpressionWrapper, Rze = ne.FOR_TYPES = Me.FLIPPED_ALIAS_KEYS.
  For, kze = ne.FORXSTATEMENT_TYPES = Me.FLIPPED_ALIAS_KEYS.ForXStatement, Fze = ne.FUNCTION_TYPES = Me.FLIPPED_ALIAS_KEYS.Function, Lze = ne.
  FUNCTIONPARENT_TYPES = Me.FLIPPED_ALIAS_KEYS.FunctionParent, Bze = ne.PUREISH_TYPES = Me.FLIPPED_ALIAS_KEYS.Pureish, Mze = ne.DECLARATION_TYPES =
  Me.FLIPPED_ALIAS_KEYS.Declaration, jze = ne.PATTERNLIKE_TYPES = Me.FLIPPED_ALIAS_KEYS.PatternLike, qze = ne.LVAL_TYPES = Me.FLIPPED_ALIAS_KEYS.
  LVal, $ze = ne.TSENTITYNAME_TYPES = Me.FLIPPED_ALIAS_KEYS.TSEntityName, Uze = ne.LITERAL_TYPES = Me.FLIPPED_ALIAS_KEYS.Literal, Vze = ne.IMMUTABLE_TYPES =
  Me.FLIPPED_ALIAS_KEYS.Immutable, Wze = ne.USERWHITESPACABLE_TYPES = Me.FLIPPED_ALIAS_KEYS.UserWhitespacable, Hze = ne.METHOD_TYPES = Me.FLIPPED_ALIAS_KEYS.
  Method, Gze = ne.OBJECTMEMBER_TYPES = Me.FLIPPED_ALIAS_KEYS.ObjectMember, Kze = ne.PROPERTY_TYPES = Me.FLIPPED_ALIAS_KEYS.Property, Yze = ne.
  UNARYLIKE_TYPES = Me.FLIPPED_ALIAS_KEYS.UnaryLike, Xze = ne.PATTERN_TYPES = Me.FLIPPED_ALIAS_KEYS.Pattern, zze = ne.CLASS_TYPES = Me.FLIPPED_ALIAS_KEYS.
  Class, Ehe = ne.IMPORTOREXPORTDECLARATION_TYPES = Me.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, Jze = ne.EXPORTDECLARATION_TYPES = Me.FLIPPED_ALIAS_KEYS.
  ExportDeclaration, Qze = ne.MODULESPECIFIER_TYPES = Me.FLIPPED_ALIAS_KEYS.ModuleSpecifier, Zze = ne.ACCESSOR_TYPES = Me.FLIPPED_ALIAS_KEYS.
  Accessor, eJe = ne.PRIVATE_TYPES = Me.FLIPPED_ALIAS_KEYS.Private, tJe = ne.FLOW_TYPES = Me.FLIPPED_ALIAS_KEYS.Flow, rJe = ne.FLOWTYPE_TYPES =
  Me.FLIPPED_ALIAS_KEYS.FlowType, sJe = ne.FLOWBASEANNOTATION_TYPES = Me.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, nJe = ne.FLOWDECLARATION_TYPES =
  Me.FLIPPED_ALIAS_KEYS.FlowDeclaration, iJe = ne.FLOWPREDICATE_TYPES = Me.FLIPPED_ALIAS_KEYS.FlowPredicate, aJe = ne.ENUMBODY_TYPES = Me.FLIPPED_ALIAS_KEYS.
  EnumBody, oJe = ne.ENUMMEMBER_TYPES = Me.FLIPPED_ALIAS_KEYS.EnumMember, lJe = ne.JSX_TYPES = Me.FLIPPED_ALIAS_KEYS.JSX, uJe = ne.MISCELLANEOUS_TYPES =
  Me.FLIPPED_ALIAS_KEYS.Miscellaneous, cJe = ne.TYPESCRIPT_TYPES = Me.FLIPPED_ALIAS_KEYS.TypeScript, fJe = ne.TSTYPEELEMENT_TYPES = Me.FLIPPED_ALIAS_KEYS.
  TSTypeElement, pJe = ne.TSTYPE_TYPES = Me.FLIPPED_ALIAS_KEYS.TSType, dJe = ne.TSBASETYPE_TYPES = Me.FLIPPED_ALIAS_KEYS.TSBaseType, hJe = ne.
  MODULEDECLARATION_TYPES = Ehe;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var dE = y((pE) => {
  "use strict";
  Object.defineProperty(pE, "__esModule", {
    value: !0
  });
  pE.default = vhe;
  var Qp = hr(), fE = ns();
  function vhe(e, t) {
    if ((0, Qp.isBlockStatement)(e))
      return e;
    let r = [];
    return (0, Qp.isEmptyStatement)(e) ? r = [] : ((0, Qp.isStatement)(e) || ((0, Qp.isFunction)(t) ? e = (0, fE.returnStatement)(e) : e = (0, fE.
    expressionStatement)(e)), r = [e]), (0, fE.blockStatement)(r);
  }
  i(vhe, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var Dk = y((hE) => {
  "use strict";
  Object.defineProperty(hE, "__esModule", {
    value: !0
  });
  hE.default = The;
  var She = dE();
  function The(e, t = "body") {
    let r = (0, She.default)(e[t], e);
    return e[t] = r, r;
  }
  i(The, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var yE = y((mE) => {
  "use strict";
  Object.defineProperty(mE, "__esModule", {
    value: !0
  });
  mE.default = Ahe;
  var xhe = sl(), Phe = rl();
  function Ahe(e) {
    e = e + "";
    let t = "";
    for (let r of e)
      t += (0, Phe.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, s) {
      return s ? s.toUpperCase() : "";
    }), (0, xhe.default)(t) || (t = `_${t}`), t || "_";
  }
  i(Ahe, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var Ik = y((gE) => {
  "use strict";
  Object.defineProperty(gE, "__esModule", {
    value: !0
  });
  gE.default = whe;
  var Che = yE();
  function whe(e) {
    return e = (0, Che.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
  }
  i(whe, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var _k = y((bE) => {
  "use strict";
  Object.defineProperty(bE, "__esModule", {
    value: !0
  });
  bE.default = _he;
  var Dhe = hr(), Ihe = ns();
  function _he(e, t = e.key || e.property) {
    return !e.computed && (0, Dhe.isIdentifier)(t) && (t = (0, Ihe.stringLiteral)(t.name)), t;
  }
  i(_he, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var Ok = y((Zp) => {
  "use strict";
  Object.defineProperty(Zp, "__esModule", {
    value: !0
  });
  Zp.default = void 0;
  var lc = hr(), CJe = Zp.default = Ohe;
  function Ohe(e) {
    if ((0, lc.isExpressionStatement)(e) && (e = e.expression), (0, lc.isExpression)(e))
      return e;
    if ((0, lc.isClass)(e) ? e.type = "ClassExpression" : (0, lc.isFunction)(e) && (e.type = "FunctionExpression"), !(0, lc.isExpression)(e))
      throw new Error(`cannot turn ${e.type} to an expression`);
    return e;
  }
  i(Ohe, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var SE = y((vE) => {
  "use strict";
  Object.defineProperty(vE, "__esModule", {
    value: !0
  });
  vE.default = EE;
  var Nhe = Ls();
  function EE(e, t, r) {
    if (!e) return;
    let s = Nhe.VISITOR_KEYS[e.type];
    if (s) {
      r = r || {}, t(e, r);
      for (let n of s) {
        let a = e[n];
        if (Array.isArray(a))
          for (let o of a)
            EE(o, t, r);
        else
          EE(a, t, r);
      }
    }
  }
  i(EE, "traverseFast");
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var xE = y((TE) => {
  "use strict";
  Object.defineProperty(TE, "__esModule", {
    value: !0
  });
  TE.default = Fhe;
  var Rhe = Ji(), Nk = ["tokens", "start", "end", "loc", "raw", "rawValue"], khe = [...Rhe.COMMENT_KEYS, "comments", ...Nk];
  function Fhe(e, t = {}) {
    let r = t.preserveComments ? Nk : khe;
    for (let n of r)
      e[n] != null && (e[n] = void 0);
    for (let n of Object.keys(e))
      n[0] === "_" && e[n] != null && (e[n] = void 0);
    let s = Object.getOwnPropertySymbols(e);
    for (let n of s)
      e[n] = null;
  }
  i(Fhe, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var AE = y((PE) => {
  "use strict";
  Object.defineProperty(PE, "__esModule", {
    value: !0
  });
  PE.default = Mhe;
  var Lhe = SE(), Bhe = xE();
  function Mhe(e, t) {
    return (0, Lhe.default)(e, Bhe.default, t), e;
  }
  i(Mhe, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var kk = y((CE) => {
  "use strict";
  Object.defineProperty(CE, "__esModule", {
    value: !0
  });
  CE.default = Ga;
  var Rk = hr(), jhe = ea(), qhe = AE();
  function Ga(e, t = e.key) {
    let r;
    return e.kind === "method" ? Ga.increment() + "" : ((0, Rk.isIdentifier)(t) ? r = t.name : (0, Rk.isStringLiteral)(t) ? r = JSON.stringify(
    t.value) : r = JSON.stringify((0, qhe.default)((0, jhe.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
  }
  i(Ga, "toKeyAlias");
  Ga.uid = 0;
  Ga.increment = function() {
    return Ga.uid >= Number.MAX_SAFE_INTEGER ? Ga.uid = 0 : Ga.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var Fk = y((td) => {
  "use strict";
  Object.defineProperty(td, "__esModule", {
    value: !0
  });
  td.default = void 0;
  var ed = hr(), $he = ns(), BJe = td.default = Uhe;
  function Uhe(e, t) {
    if ((0, ed.isStatement)(e))
      return e;
    let r = !1, s;
    if ((0, ed.isClass)(e))
      r = !0, s = "ClassDeclaration";
    else if ((0, ed.isFunction)(e))
      r = !0, s = "FunctionDeclaration";
    else if ((0, ed.isAssignmentExpression)(e))
      return (0, $he.expressionStatement)(e);
    if (r && !e.id && (s = !1), !s) {
      if (t)
        return !1;
      throw new Error(`cannot turn ${e.type} to a statement`);
    }
    return e.type = s, e;
  }
  i(Uhe, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var Lk = y((rd) => {
  "use strict";
  Object.defineProperty(rd, "__esModule", {
    value: !0
  });
  rd.default = void 0;
  var Vhe = sl(), Br = ns(), qJe = rd.default = wE, Whe = Function.call.bind(Object.prototype.toString);
  function Hhe(e) {
    return Whe(e) === "[object RegExp]";
  }
  i(Hhe, "isRegExp");
  function Ghe(e) {
    if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    let t = Object.getPrototypeOf(e);
    return t === null || Object.getPrototypeOf(t) === null;
  }
  i(Ghe, "isPlainObject");
  function wE(e) {
    if (e === void 0)
      return (0, Br.identifier)("undefined");
    if (e === !0 || e === !1)
      return (0, Br.booleanLiteral)(e);
    if (e === null)
      return (0, Br.nullLiteral)();
    if (typeof e == "string")
      return (0, Br.stringLiteral)(e);
    if (typeof e == "number") {
      let t;
      if (Number.isFinite(e))
        t = (0, Br.numericLiteral)(Math.abs(e));
      else {
        let r;
        Number.isNaN(e) ? r = (0, Br.numericLiteral)(0) : r = (0, Br.numericLiteral)(1), t = (0, Br.binaryExpression)("/", r, (0, Br.numericLiteral)(
        0));
      }
      return (e < 0 || Object.is(e, -0)) && (t = (0, Br.unaryExpression)("-", t)), t;
    }
    if (Hhe(e)) {
      let t = e.source, r = e.toString().match(/\/([a-z]+|)$/)[1];
      return (0, Br.regExpLiteral)(t, r);
    }
    if (Array.isArray(e))
      return (0, Br.arrayExpression)(e.map(wE));
    if (Ghe(e)) {
      let t = [];
      for (let r of Object.keys(e)) {
        let s;
        (0, Vhe.default)(r) ? s = (0, Br.identifier)(r) : s = (0, Br.stringLiteral)(r), t.push((0, Br.objectProperty)(s, wE(e[r])));
      }
      return (0, Br.objectExpression)(t);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  i(wE, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var Bk = y((DE) => {
  "use strict";
  Object.defineProperty(DE, "__esModule", {
    value: !0
  });
  DE.default = Yhe;
  var Khe = ns();
  function Yhe(e, t, r = !1) {
    return e.object = (0, Khe.memberExpression)(e.object, e.property, e.computed), e.property = t, e.computed = !!r, e;
  }
  i(Yhe, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var jk = y((IE) => {
  "use strict";
  Object.defineProperty(IE, "__esModule", {
    value: !0
  });
  IE.default = zhe;
  var Mk = Ji(), Xhe = uE();
  function zhe(e, t) {
    if (!e || !t) return e;
    for (let r of Mk.INHERIT_KEYS.optional)
      e[r] == null && (e[r] = t[r]);
    for (let r of Object.keys(t))
      r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
    for (let r of Mk.INHERIT_KEYS.force)
      e[r] = t[r];
    return (0, Xhe.default)(e, t), e;
  }
  i(zhe, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var qk = y((_E) => {
  "use strict";
  Object.defineProperty(_E, "__esModule", {
    value: !0
  });
  _E.default = Zhe;
  var Jhe = ns(), Qhe = Ne();
  function Zhe(e, t) {
    if ((0, Qhe.isSuper)(e.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e.object = (0, Jhe.memberExpression)(t, e.object), e;
  }
  i(Zhe, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var uc = y((NE) => {
  "use strict";
  Object.defineProperty(NE, "__esModule", {
    value: !0
  });
  NE.default = OE;
  var ta = hr();
  function OE(e, t, r, s) {
    let n = [].concat(e), a = /* @__PURE__ */ Object.create(null);
    for (; n.length; ) {
      let o = n.shift();
      if (!o || s && ((0, ta.isAssignmentExpression)(o) || (0, ta.isUnaryExpression)(o)))
        continue;
      let l = OE.keys[o.type];
      if ((0, ta.isIdentifier)(o)) {
        t ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, ta.isExportDeclaration)(o) && !(0, ta.isExportAllDeclaration)(o)) {
        (0, ta.isDeclaration)(o.declaration) && n.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, ta.isFunctionDeclaration)(o)) {
          n.push(o.id);
          continue;
        }
        if ((0, ta.isFunctionExpression)(o))
          continue;
      }
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], f = o[c];
          f && (Array.isArray(f) ? n.push(...f) : n.push(f));
        }
    }
    return a;
  }
  i(OE, "getBindingIdentifiers");
  OE.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var $k = y((sd) => {
  "use strict";
  Object.defineProperty(sd, "__esModule", {
    value: !0
  });
  sd.default = void 0;
  var eme = uc(), JJe = sd.default = tme;
  function tme(e, t) {
    return (0, eme.default)(e, t, !0);
  }
  i(tme, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var Uk = y((kE) => {
  "use strict";
  Object.defineProperty(kE, "__esModule", {
    value: !0
  });
  kE.default = sme;
  var rme = Ls();
  function sme(e, t, r) {
    typeof t == "function" && (t = {
      enter: t
    });
    let {
      enter: s,
      exit: n
    } = t;
    RE(e, s, n, r, []);
  }
  i(sme, "traverse");
  function RE(e, t, r, s, n) {
    let a = rme.VISITOR_KEYS[e.type];
    if (a) {
      t && t(e, n, s);
      for (let o of a) {
        let l = e[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (n.push({
              node: e,
              key: o,
              index: u
            }), RE(c, t, r, s, n), n.pop());
          }
        else l && (n.push({
          node: e,
          key: o
        }), RE(l, t, r, s, n), n.pop());
      }
      r && r(e, n, s);
    }
  }
  i(RE, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var Vk = y((FE) => {
  "use strict";
  Object.defineProperty(FE, "__esModule", {
    value: !0
  });
  FE.default = ime;
  var nme = uc();
  function ime(e, t, r) {
    if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let s = nme.default.keys[t.type];
    if (s)
      for (let n = 0; n < s.length; n++) {
        let a = s[n], o = t[a];
        if (Array.isArray(o)) {
          if (o.indexOf(e) >= 0) return !0;
        } else if (o === e) return !0;
      }
    return !1;
  }
  i(ime, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var BE = y((LE) => {
  "use strict";
  Object.defineProperty(LE, "__esModule", {
    value: !0
  });
  LE.default = lme;
  var ame = hr(), ome = Ji();
  function lme(e) {
    return (0, ame.isVariableDeclaration)(e) && (e.kind !== "var" || e[ome.BLOCK_SCOPED_SYMBOL]);
  }
  i(lme, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var Hk = y((ME) => {
  "use strict";
  Object.defineProperty(ME, "__esModule", {
    value: !0
  });
  ME.default = cme;
  var Wk = hr(), ume = BE();
  function cme(e) {
    return (0, Wk.isFunctionDeclaration)(e) || (0, Wk.isClassDeclaration)(e) || (0, ume.default)(e);
  }
  i(cme, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var Gk = y((jE) => {
  "use strict";
  Object.defineProperty(jE, "__esModule", {
    value: !0
  });
  jE.default = dme;
  var fme = Mp(), pme = hr();
  function dme(e) {
    return (0, fme.default)(e.type, "Immutable") ? !0 : (0, pme.isIdentifier)(e) ? e.name === "undefined" : !1;
  }
  i(dme, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var Yk = y(($E) => {
  "use strict";
  Object.defineProperty($E, "__esModule", {
    value: !0
  });
  $E.default = qE;
  var Kk = Ls();
  function qE(e, t) {
    if (typeof e != "object" || typeof t != "object" || e == null || t == null)
      return e === t;
    if (e.type !== t.type)
      return !1;
    let r = Object.keys(Kk.NODE_FIELDS[e.type] || e.type), s = Kk.VISITOR_KEYS[e.type];
    for (let n of r) {
      let a = e[n], o = t[n];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!qE(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(s != null && s.includes(n))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!qE(a, o))
          return !1;
      }
    }
    return !0;
  }
  i(qE, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var Xk = y((UE) => {
  "use strict";
  Object.defineProperty(UE, "__esModule", {
    value: !0
  });
  UE.default = hme;
  function hme(e, t, r) {
    switch (t.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t.property === e ? !!t.computed : t.object === e;
      case "JSXMemberExpression":
        return t.object === e;
      case "VariableDeclarator":
        return t.init === e;
      case "ArrowFunctionExpression":
        return t.body === e;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t.key === e ? !!t.computed : !1;
      case "ObjectProperty":
        return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return t.key === e ? !!t.computed : !0;
      case "ClassPrivateProperty":
        return t.key !== e;
      case "ClassDeclaration":
      case "ClassExpression":
        return t.superClass === e;
      case "AssignmentExpression":
        return t.right === e;
      case "AssignmentPattern":
        return t.right === e;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : t.local === e;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return t.key !== e;
      case "TSEnumMember":
        return t.id !== e;
      case "TSPropertySignature":
        return t.key === e ? !!t.computed : !0;
    }
    return !0;
  }
  i(hme, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var zk = y((VE) => {
  "use strict";
  Object.defineProperty(VE, "__esModule", {
    value: !0
  });
  VE.default = mme;
  var Ka = hr();
  function mme(e, t) {
    return (0, Ka.isBlockStatement)(e) && ((0, Ka.isFunction)(t) || (0, Ka.isCatchClause)(t)) ? !1 : (0, Ka.isPattern)(e) && ((0, Ka.isFunction)(
    t) || (0, Ka.isCatchClause)(t)) ? !0 : (0, Ka.isScopable)(e);
  }
  i(mme, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var Qk = y((WE) => {
  "use strict";
  Object.defineProperty(WE, "__esModule", {
    value: !0
  });
  WE.default = yme;
  var Jk = hr();
  function yme(e) {
    return (0, Jk.isImportDefaultSpecifier)(e) || (0, Jk.isIdentifier)(e.imported || e.exported, {
      name: "default"
    });
  }
  i(yme, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var Zk = y((HE) => {
  "use strict";
  Object.defineProperty(HE, "__esModule", {
    value: !0
  });
  HE.default = Eme;
  var gme = sl(), bme = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "impleme\
nts", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "trans\
ient", "volatile"]);
  function Eme(e) {
    return (0, gme.default)(e) && !bme.has(e);
  }
  i(Eme, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var eF = y((GE) => {
  "use strict";
  Object.defineProperty(GE, "__esModule", {
    value: !0
  });
  GE.default = Tme;
  var vme = hr(), Sme = Ji();
  function Tme(e) {
    return (0, vme.isVariableDeclaration)(e, {
      kind: "var"
    }) && !e[Sme.BLOCK_SCOPED_SYMBOL];
  }
  i(Tme, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var tF = y((YE) => {
  "use strict";
  Object.defineProperty(YE, "__esModule", {
    value: !0
  });
  YE.default = nd;
  var xme = uc(), Ya = hr(), KE = ns(), Pme = ea();
  function nd(e, t, r) {
    let s = [], n = !0;
    for (let a of e)
      if ((0, Ya.isEmptyStatement)(a) || (n = !1), (0, Ya.isExpression)(a))
        s.push(a);
      else if ((0, Ya.isExpressionStatement)(a))
        s.push(a.expression);
      else if ((0, Ya.isVariableDeclaration)(a)) {
        if (a.kind !== "var") return;
        for (let o of a.declarations) {
          let l = (0, xme.default)(o);
          for (let u of Object.keys(l))
            r.push({
              kind: a.kind,
              id: (0, Pme.default)(l[u])
            });
          o.init && s.push((0, KE.assignmentExpression)("=", o.id, o.init));
        }
        n = !0;
      } else if ((0, Ya.isIfStatement)(a)) {
        let o = a.consequent ? nd([a.consequent], t, r) : t.buildUndefinedNode(), l = a.alternate ? nd([a.alternate], t, r) : t.buildUndefinedNode();
        if (!o || !l) return;
        s.push((0, KE.conditionalExpression)(a.test, o, l));
      } else if ((0, Ya.isBlockStatement)(a)) {
        let o = nd(a.body, t, r);
        if (!o) return;
        s.push(o);
      } else if ((0, Ya.isEmptyStatement)(a))
        e.indexOf(a) === 0 && (n = !0);
      else
        return;
    return n && s.push(t.buildUndefinedNode()), s.length === 1 ? s[0] : (0, KE.sequenceExpression)(s);
  }
  i(nd, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var rF = y((XE) => {
  "use strict";
  Object.defineProperty(XE, "__esModule", {
    value: !0
  });
  XE.default = Cme;
  var Ame = tF();
  function Cme(e, t) {
    if (!(e != null && e.length)) return;
    let r = [], s = (0, Ame.default)(e, t, r);
    if (s) {
      for (let n of r)
        t.push(n);
      return s;
    }
  }
  i(Cme, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var Ne = y((ue) => {
  "use strict";
  Object.defineProperty(ue, "__esModule", {
    value: !0
  });
  var pi = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(ue, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Dye.default;
    }, "get")
  });
  Object.defineProperty(ue, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Mme.default;
    }, "get")
  });
  Object.defineProperty(ue, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return jme.default;
    }, "get")
  });
  Object.defineProperty(ue, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return eye.default;
    }, "get")
  });
  Object.defineProperty(ue, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return _me.default;
    }, "get")
  });
  Object.defineProperty(ue, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return wye.default;
    }, "get")
  });
  Object.defineProperty(ue, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return kme.default;
    }, "get")
  });
  Object.defineProperty(ue, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Fme.default;
    }, "get")
  });
  Object.defineProperty(ue, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Lme.default;
    }, "get")
  });
  Object.defineProperty(ue, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Rme.default;
    }, "get")
  });
  Object.defineProperty(ue, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Bme.default;
    }, "get")
  });
  Object.defineProperty(ue, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return sF.default;
    }, "get")
  });
  Object.defineProperty(ue, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Nme.default;
    }, "get")
  });
  Object.defineProperty(ue, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ome.default;
    }, "get")
  });
  Object.defineProperty(ue, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return sF.default;
    }, "get")
  });
  Object.defineProperty(ue, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Hme.default;
    }, "get")
  });
  Object.defineProperty(ue, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return aye.default;
    }, "get")
  });
  Object.defineProperty(ue, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return oye.default;
    }, "get")
  });
  Object.defineProperty(ue, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return qme.default;
    }, "get")
  });
  Object.defineProperty(ue, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return $me.default;
    }, "get")
  });
  Object.defineProperty(ue, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vme.default;
    }, "get")
  });
  Object.defineProperty(ue, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return tye.default;
    }, "get")
  });
  Object.defineProperty(ue, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ume.default;
    }, "get")
  });
  Object.defineProperty(ue, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return cye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return pye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return dye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return hye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return mye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return yye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return gye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return bye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Eye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return vye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Sye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Tye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return xye.default;
    }, "get")
  });
  Object.defineProperty(ue, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Pye.default;
    }, "get")
  });
  Object.defineProperty(ue, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Aye.default;
    }, "get")
  });
  Object.defineProperty(ue, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return rye.default;
    }, "get")
  });
  ue.react = void 0;
  Object.defineProperty(ue, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Wme.default;
    }, "get")
  });
  Object.defineProperty(ue, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return sye.default;
    }, "get")
  });
  Object.defineProperty(ue, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return nye.default;
    }, "get")
  });
  Object.defineProperty(ue, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return iye.default;
    }, "get")
  });
  Object.defineProperty(ue, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return uye.default;
    }, "get")
  });
  Object.defineProperty(ue, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Gme.default;
    }, "get")
  });
  Object.defineProperty(ue, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Kme.default;
    }, "get")
  });
  Object.defineProperty(ue, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Yme.default;
    }, "get")
  });
  Object.defineProperty(ue, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xme.default;
    }, "get")
  });
  Object.defineProperty(ue, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return zme.default;
    }, "get")
  });
  Object.defineProperty(ue, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Jme.default;
    }, "get")
  });
  Object.defineProperty(ue, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Qme.default;
    }, "get")
  });
  Object.defineProperty(ue, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return id.default;
    }, "get")
  });
  Object.defineProperty(ue, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return lye.default;
    }, "get")
  });
  Object.defineProperty(ue, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Cye.default;
    }, "get")
  });
  Object.defineProperty(ue, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Zme.default;
    }, "get")
  });
  var wme = oR(), Dme = lR(), Ime = rk(), _me = sk(), zE = nk();
  Object.keys(zE).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(pi, e) || e in ue && ue[e] === zE[e] || Object.defineProperty(
    ue, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return zE[e];
      }, "get")
    });
  });
  var Ome = ik(), sF = lk(), Nme = pk(), JE = ns();
  Object.keys(JE).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(pi, e) || e in ue && ue[e] === JE[e] || Object.defineProperty(
    ue, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return JE[e];
      }, "get")
    });
  });
  var QE = dk();
  Object.keys(QE).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(pi, e) || e in ue && ue[e] === QE[e] || Object.defineProperty(
    ue, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return QE[e];
      }, "get")
    });
  });
  var ZE = mk();
  Object.keys(ZE).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(pi, e) || e in ue && ue[e] === ZE[e] || Object.defineProperty(
    ue, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return ZE[e];
      }, "get")
    });
  });
  var Rme = ea(), kme = Sk(), Fme = Tk(), Lme = xk(), Bme = Pk(), Mme = Ak(), jme = Zb(), qme = sE(), $me = iE(), Ume = uE(), Vme = oE(), Wme = Ck(),
  ev = wk();
  Object.keys(ev).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(pi, e) || e in ue && ue[e] === ev[e] || Object.defineProperty(
    ue, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return ev[e];
      }, "get")
    });
  });
  var tv = Ji();
  Object.keys(tv).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(pi, e) || e in ue && ue[e] === tv[e] || Object.defineProperty(
    ue, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return tv[e];
      }, "get")
    });
  });
  var Hme = Dk(), Gme = Ik(), Kme = dE(), Yme = _k(), Xme = Ok(), zme = yE(), Jme = kk(), Qme = Fk(), Zme = Lk(), rv = Ls();
  Object.keys(rv).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(pi, e) || e in ue && ue[e] === rv[e] || Object.defineProperty(
    ue, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return rv[e];
      }, "get")
    });
  });
  var eye = Bk(), tye = jk(), rye = qk(), sye = xE(), nye = AE(), iye = Ub(), aye = uc(), oye = $k(), id = Uk();
  Object.keys(id).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(pi, e) || e in ue && ue[e] === id[e] || Object.defineProperty(
    ue, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return id[e];
      }, "get")
    });
  });
  var lye = SE(), uye = Lp(), cye = tl(), fye = Vk(), pye = Hk(), dye = Gk(), hye = BE(), mye = jb(), yye = Yk(), gye = pb(), bye = Xk(), Eye = zk(),
  vye = Qk(), Sye = Mp(), Tye = Zk(), xye = sl(), Pye = eF(), Aye = ab(), Cye = Vp(), wye = lb(), sv = hr();
  Object.keys(sv).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(pi, e) || e in ue && ue[e] === sv[e] || Object.defineProperty(
    ue, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return sv[e];
      }, "get")
    });
  });
  var Dye = Yu(), CQe = ue.react = {
    isReactComponent: wme.default,
    isCompatTag: Dme.default,
    buildChildren: Ime.default
  };
  ue.toSequenceExpression = rF().default;
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var nv = y((st) => {
  "use strict";
  Object.defineProperty(st, "__esModule", {
    value: !0
  });
  st.Var = st.User = st.Statement = st.SpreadProperty = st.Scope = st.RestProperty = st.ReferencedMemberExpression = st.ReferencedIdentifier =
  st.Referenced = st.Pure = st.NumericLiteralTypeAnnotation = st.Generated = st.ForAwaitStatement = st.Flow = st.Expression = st.ExistentialTypeParam =
  st.BlockScoped = st.BindingIdentifier = void 0;
  var IQe = st.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], _Qe = st.ReferencedMemberExpression = ["MemberExpression"], OQe = st.
  BindingIdentifier = ["Identifier"], NQe = st.Statement = ["Statement"], RQe = st.Expression = ["Expression"], kQe = st.Scope = ["Scopable",
  "Pattern"], FQe = st.Referenced = null, LQe = st.BlockScoped = null, BQe = st.Var = ["VariableDeclaration"], MQe = st.User = null, jQe = st.
  Generated = null, qQe = st.Pure = null, $Qe = st.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], UQe = st.RestProperty =
  ["RestElement"], VQe = st.SpreadProperty = ["RestElement"], WQe = st.ExistentialTypeParam = ["ExistsTypeAnnotation"], HQe = st.NumericLiteralTypeAnnotation =
  ["NumberLiteralTypeAnnotation"], GQe = st.ForAwaitStatement = ["ForOfStatement"];
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var av = y((gr) => {
  "use strict";
  Object.defineProperty(gr, "__esModule", {
    value: !0
  });
  gr.isBindingIdentifier = Jye;
  gr.isBlockScoped = r0e;
  gr.isExpression = Zye;
  gr.isFlow = o0e;
  gr.isForAwaitStatement = c0e;
  gr.isGenerated = i0e;
  gr.isPure = a0e;
  gr.isReferenced = t0e;
  gr.isReferencedIdentifier = Xye;
  gr.isReferencedMemberExpression = zye;
  gr.isRestProperty = l0e;
  gr.isScope = e0e;
  gr.isSpreadProperty = u0e;
  gr.isStatement = Qye;
  gr.isUser = n0e;
  gr.isVar = s0e;
  var Iye = Ne(), {
    isBinding: _ye,
    isBlockScoped: Oye,
    isExportDeclaration: Nye,
    isExpression: Rye,
    isFlow: kye,
    isForStatement: Fye,
    isForXStatement: Lye,
    isIdentifier: nF,
    isImportDeclaration: Bye,
    isImportSpecifier: Mye,
    isJSXIdentifier: jye,
    isJSXMemberExpression: qye,
    isMemberExpression: $ye,
    isRestElement: iF,
    isReferenced: iv,
    isScope: Uye,
    isStatement: Vye,
    isVar: Wye,
    isVariableDeclaration: Hye,
    react: Gye,
    isForOfStatement: Kye
  } = Iye, {
    isCompatTag: Yye
  } = Gye;
  function Xye(e) {
    let {
      node: t,
      parent: r
    } = this;
    if (!nF(t, e) && !qye(r, e))
      if (jye(t, e)) {
        if (Yye(t.name)) return !1;
      } else
        return !1;
    return iv(t, r, this.parentPath.parent);
  }
  i(Xye, "isReferencedIdentifier");
  function zye() {
    let {
      node: e,
      parent: t
    } = this;
    return $ye(e) && iv(e, t);
  }
  i(zye, "isReferencedMemberExpression");
  function Jye() {
    let {
      node: e,
      parent: t
    } = this, r = this.parentPath.parent;
    return nF(e) && _ye(e, t, r);
  }
  i(Jye, "isBindingIdentifier");
  function Qye() {
    let {
      node: e,
      parent: t
    } = this;
    return Vye(e) ? !(Hye(e) && (Lye(t, {
      left: e
    }) || Fye(t, {
      init: e
    }))) : !1;
  }
  i(Qye, "isStatement");
  function Zye() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : Rye(this.node);
  }
  i(Zye, "isExpression");
  function e0e() {
    return Uye(this.node, this.parent);
  }
  i(e0e, "isScope");
  function t0e() {
    return iv(this.node, this.parent);
  }
  i(t0e, "isReferenced");
  function r0e() {
    return Oye(this.node);
  }
  i(r0e, "isBlockScoped");
  function s0e() {
    return Wye(this.node);
  }
  i(s0e, "isVar");
  function n0e() {
    return this.node && !!this.node.loc;
  }
  i(n0e, "isUser");
  function i0e() {
    return !this.isUser();
  }
  i(i0e, "isGenerated");
  function a0e(e) {
    return this.scope.isPure(this.node, e);
  }
  i(a0e, "isPure");
  function o0e() {
    let {
      node: e
    } = this;
    return kye(e) ? !0 : Bye(e) ? e.importKind === "type" || e.importKind === "typeof" : Nye(e) ? e.exportKind === "type" : Mye(e) ? e.importKind ===
    "type" || e.importKind === "typeof" : !1;
  }
  i(o0e, "isFlow");
  function l0e() {
    return iF(this.node) && this.parentPath && this.parentPath.isObjectPattern();
  }
  i(l0e, "isRestProperty");
  function u0e() {
    return iF(this.node) && this.parentPath && this.parentPath.isObjectExpression();
  }
  i(u0e, "isSpreadProperty");
  function c0e() {
    return Kye(this.node, {
      await: !0
    });
  }
  i(c0e, "isForAwaitStatement");
  gr.isExistentialTypeParam = /* @__PURE__ */ i(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), gr.isNumericLiteralTypeAnnotation = /* @__PURE__ */ i(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/traverse/lib/visitors.js
var fc = y((al) => {
  "use strict";
  Object.defineProperty(al, "__esModule", {
    value: !0
  });
  al.explode = mF;
  al.isExplodedVisitor = hF;
  al.merge = m0e;
  al.verify = yF;
  var dF = nv(), f0e = av(), p0e = Ne(), {
    DEPRECATED_KEYS: aF,
    DEPRECATED_ALIASES: oF,
    FLIPPED_ALIAS_KEYS: lF,
    TYPES: d0e,
    __internal__deprecationWarning: uF
  } = p0e;
  function h0e(e) {
    return e in dF;
  }
  i(h0e, "isVirtualType");
  function hF(e) {
    return e?._exploded;
  }
  i(hF, "isExplodedVisitor");
  function mF(e) {
    if (hF(e)) return e;
    e._exploded = !0;
    for (let t of Object.keys(e)) {
      if (Xa(t)) continue;
      let r = t.split("|");
      if (r.length === 1) continue;
      let s = e[t];
      delete e[t];
      for (let n of r)
        e[n] = s;
    }
    yF(e), delete e.__esModule, y0e(e), pF(e);
    for (let t of Object.keys(e)) {
      if (Xa(t) || !h0e(t)) continue;
      let r = e[t];
      for (let n of Object.keys(r))
        r[n] = g0e(t, r[n]);
      delete e[t];
      let s = dF[t];
      if (s !== null)
        for (let n of s)
          e[n] ? cc(e[n], r) : e[n] = r;
      else
        cc(e, r);
    }
    for (let t of Object.keys(e)) {
      if (Xa(t)) continue;
      let r = lF[t];
      if (t in aF) {
        let n = aF[t];
        uF(t, n, "Visitor "), r = [n];
      } else if (t in oF) {
        let n = oF[t];
        uF(t, n, "Visitor "), r = lF[n];
      }
      if (!r) continue;
      let s = e[t];
      delete e[t];
      for (let n of r) {
        let a = e[n];
        a ? cc(a, s) : e[n] = Object.assign({}, s);
      }
    }
    for (let t of Object.keys(e))
      Xa(t) || pF(e[t]);
    return e;
  }
  i(mF, "explode");
  function yF(e) {
    if (!e._verified) {
      if (typeof e == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let t of Object.keys(e)) {
        if ((t === "enter" || t === "exit") && cF(t, e[t]), Xa(t)) continue;
        if (d0e.indexOf(t) < 0)
          throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);
        let r = e[t];
        if (typeof r == "object")
          for (let s of Object.keys(r))
            if (s === "enter" || s === "exit")
              cF(`${t}.${s}`, r[s]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${s}`);
      }
      e._verified = !0;
    }
  }
  i(yF, "verify");
  function cF(e, t) {
    let r = [].concat(t);
    for (let s of r)
      if (typeof s != "function")
        throw new TypeError(`Non-function found defined in ${e} with type ${typeof s}`);
  }
  i(cF, "validateVisitorMethods");
  function m0e(e, t = [], r) {
    let s = {};
    for (let n = 0; n < e.length; n++) {
      let a = mF(e[n]), o = t[n], l = a;
      (o || r) && (l = fF(l, o, r)), cc(s, l);
      for (let u of Object.keys(a)) {
        if (Xa(u)) continue;
        let c = a[u];
        (o || r) && (c = fF(c, o, r));
        let f = s[u] || (s[u] = {});
        cc(f, c);
      }
    }
    return s;
  }
  i(m0e, "merge");
  function fF(e, t, r) {
    let s = {};
    for (let n of ["enter", "exit"]) {
      let a = e[n];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return t && (l = /* @__PURE__ */ i(function(u) {
          o.call(t, u, t);
        }, "newFn")), r && (l = r(t?.key, n, l)), l !== o && (l.toString = () => o.toString()), l;
      }), s[n] = a);
    }
    return s;
  }
  i(fF, "wrapWithStateOrWrapper");
  function y0e(e) {
    for (let t of Object.keys(e)) {
      if (Xa(t)) continue;
      let r = e[t];
      typeof r == "function" && (e[t] = {
        enter: r
      });
    }
  }
  i(y0e, "ensureEntranceObjects");
  function pF(e) {
    e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
  }
  i(pF, "ensureCallbackArrays");
  function g0e(e, t) {
    let r = `is${e}`, s = f0e[r], n = /* @__PURE__ */ i(function(a) {
      if (s.call(a))
        return t.apply(this, arguments);
    }, "newFn");
    return n.toString = () => t.toString(), n;
  }
  i(g0e, "wrapCheck");
  function Xa(e) {
    return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" ||
    e === "blacklist";
  }
  i(Xa, "shouldIgnoreKey");
  function cc(e, t) {
    for (let r of ["enter", "exit"])
      t[r] && (e[r] = [].concat(e[r] || [], t[r]));
  }
  i(cc, "mergePair");
});

// ../node_modules/@babel/traverse/lib/cache.js
var za = y((Ts) => {
  "use strict";
  Object.defineProperty(Ts, "__esModule", {
    value: !0
  });
  Ts.clear = E0e;
  Ts.clearPath = gF;
  Ts.clearScope = bF;
  Ts.getCachedPaths = v0e;
  Ts.getOrCreateCachedPaths = S0e;
  Ts.scope = Ts.path = void 0;
  var ad = Ts.path = /* @__PURE__ */ new WeakMap(), b0e = Ts.scope = /* @__PURE__ */ new WeakMap();
  function E0e() {
    gF(), bF();
  }
  i(E0e, "clear");
  function gF() {
    Ts.path = ad = /* @__PURE__ */ new WeakMap();
  }
  i(gF, "clearPath");
  function bF() {
    Ts.scope = b0e = /* @__PURE__ */ new WeakMap();
  }
  i(bF, "clearScope");
  var ov = Object.freeze({});
  function v0e(e, t) {
    var r, s;
    return e = null, (r = ad.get((s = e) != null ? s : ov)) == null ? void 0 : r.get(t);
  }
  i(v0e, "getCachedPaths");
  function S0e(e, t) {
    var r, s;
    e = null;
    let n = ad.get((r = e) != null ? r : ov);
    n || ad.set((s = e) != null ? s : ov, n = /* @__PURE__ */ new WeakMap());
    let a = n.get(t);
    return a || n.set(t, a = /* @__PURE__ */ new Map()), a;
  }
  i(S0e, "getOrCreateCachedPaths");
});

// ../node_modules/debug/node_modules/ms/index.js
var vF = y((eZe, EF) => {
  var ol = 1e3, ll = ol * 60, ul = ll * 60, Ja = ul * 24, T0e = Ja * 7, x0e = Ja * 365.25;
  EF.exports = function(e, t) {
    t = t || {};
    var r = typeof e;
    if (r === "string" && e.length > 0)
      return P0e(e);
    if (r === "number" && isFinite(e))
      return t.long ? C0e(e) : A0e(e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(e)
    );
  };
  function P0e(e) {
    if (e = String(e), !(e.length > 100)) {
      var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        e
      );
      if (t) {
        var r = parseFloat(t[1]), s = (t[2] || "ms").toLowerCase();
        switch (s) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * x0e;
          case "weeks":
          case "week":
          case "w":
            return r * T0e;
          case "days":
          case "day":
          case "d":
            return r * Ja;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * ul;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * ll;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * ol;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  i(P0e, "parse");
  function A0e(e) {
    var t = Math.abs(e);
    return t >= Ja ? Math.round(e / Ja) + "d" : t >= ul ? Math.round(e / ul) + "h" : t >= ll ? Math.round(e / ll) + "m" : t >= ol ? Math.round(
    e / ol) + "s" : e + "ms";
  }
  i(A0e, "fmtShort");
  function C0e(e) {
    var t = Math.abs(e);
    return t >= Ja ? od(e, t, Ja, "day") : t >= ul ? od(e, t, ul, "hour") : t >= ll ? od(e, t, ll, "minute") : t >= ol ? od(e, t, ol, "secon\
d") : e + " ms";
  }
  i(C0e, "fmtLong");
  function od(e, t, r, s) {
    var n = t >= r * 1.5;
    return Math.round(e / r) + " " + s + (n ? "s" : "");
  }
  i(od, "plural");
});

// ../node_modules/debug/src/common.js
var lv = y((rZe, SF) => {
  function w0e(e) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = a, r.enable = n, r.enabled = o, r.humanize = vF(), r.destroy = c, Object.keys(e).forEach(
    (f) => {
      r[f] = e[f];
    }), r.names = [], r.skips = [], r.formatters = {};
    function t(f) {
      let p = 0;
      for (let d = 0; d < f.length; d++)
        p = (p << 5) - p + f.charCodeAt(d), p |= 0;
      return r.colors[Math.abs(p) % r.colors.length];
    }
    i(t, "selectColor"), r.selectColor = t;
    function r(f) {
      let p, d = null, m, b;
      function h(...g) {
        if (!h.enabled)
          return;
        let E = h, D = Number(/* @__PURE__ */ new Date()), C = D - (p || D);
        E.diff = C, E.prev = p, E.curr = D, p = D, g[0] = r.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
        let N = 0;
        g[0] = g[0].replace(/%([a-zA-Z%])/g, (M, q) => {
          if (M === "%%")
            return "%";
          N++;
          let V = r.formatters[q];
          if (typeof V == "function") {
            let W = g[N];
            M = V.call(E, W), g.splice(N, 1), N--;
          }
          return M;
        }), r.formatArgs.call(E, g), (E.log || r.log).apply(E, g);
      }
      return i(h, "debug"), h.namespace = f, h.useColors = r.useColors(), h.color = r.selectColor(f), h.extend = s, h.destroy = r.destroy, Object.
      defineProperty(h, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ i(() => d !== null ? d : (m !== r.namespaces && (m = r.namespaces, b = r.enabled(f)), b), "get"),
        set: /* @__PURE__ */ i((g) => {
          d = g;
        }, "set")
      }), typeof r.init == "function" && r.init(h), h;
    }
    i(r, "createDebug");
    function s(f, p) {
      let d = r(this.namespace + (typeof p > "u" ? ":" : p) + f);
      return d.log = this.log, d;
    }
    i(s, "extend");
    function n(f) {
      r.save(f), r.namespaces = f, r.names = [], r.skips = [];
      let p, d = (typeof f == "string" ? f : "").split(/[\s,]+/), m = d.length;
      for (p = 0; p < m; p++)
        d[p] && (f = d[p].replace(/\*/g, ".*?"), f[0] === "-" ? r.skips.push(new RegExp("^" + f.slice(1) + "$")) : r.names.push(new RegExp("\
^" + f + "$")));
    }
    i(n, "enable");
    function a() {
      let f = [
        ...r.names.map(l),
        ...r.skips.map(l).map((p) => "-" + p)
      ].join(",");
      return r.enable(""), f;
    }
    i(a, "disable");
    function o(f) {
      if (f[f.length - 1] === "*")
        return !0;
      let p, d;
      for (p = 0, d = r.skips.length; p < d; p++)
        if (r.skips[p].test(f))
          return !1;
      for (p = 0, d = r.names.length; p < d; p++)
        if (r.names[p].test(f))
          return !0;
      return !1;
    }
    i(o, "enabled");
    function l(f) {
      return f.toString().substring(2, f.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    i(l, "toNamespace");
    function u(f) {
      return f instanceof Error ? f.stack || f.message : f;
    }
    i(u, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return i(c, "destroy"), r.enable(r.load()), r;
  }
  i(w0e, "setup");
  SF.exports = w0e;
});

// ../node_modules/debug/src/browser.js
var TF = y((xs, ld) => {
  xs.formatArgs = I0e;
  xs.save = _0e;
  xs.load = O0e;
  xs.useColors = D0e;
  xs.storage = N0e();
  xs.destroy = /* @__PURE__ */ (() => {
    let e = !1;
    return () => {
      e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  xs.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function D0e() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "\
u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement &&
    document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  i(D0e, "useColors");
  function I0e(e) {
    if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" +
    ld.exports.humanize(this.diff), !this.useColors)
      return;
    let t = "color: " + this.color;
    e.splice(1, 0, t, "color: inherit");
    let r = 0, s = 0;
    e[0].replace(/%[a-zA-Z%]/g, (n) => {
      n !== "%%" && (r++, n === "%c" && (s = r));
    }), e.splice(s, 0, t);
  }
  i(I0e, "formatArgs");
  xs.log = console.debug || console.log || (() => {
  });
  function _0e(e) {
    try {
      e ? xs.storage.setItem("debug", e) : xs.storage.removeItem("debug");
    } catch {
    }
  }
  i(_0e, "save");
  function O0e() {
    let e;
    try {
      e = xs.storage.getItem("debug");
    } catch {
    }
    return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
  }
  i(O0e, "load");
  function N0e() {
    try {
      return localStorage;
    } catch {
    }
  }
  i(N0e, "localstorage");
  ld.exports = lv()(xs);
  var { formatters: R0e } = ld.exports;
  R0e.j = function(e) {
    try {
      return JSON.stringify(e);
    } catch (t) {
      return "[UnexpectedJSONParseError]: " + t.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var PF = y((iZe, xF) => {
  "use strict";
  xF.exports = (e, t = process.argv) => {
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", s = t.indexOf(r + e), n = t.indexOf("--");
    return s !== -1 && (n === -1 || s < n);
  };
});

// ../node_modules/supports-color/index.js
var wF = y((aZe, CF) => {
  "use strict";
  var k0e = require("os"), AF = require("tty"), Bs = PF(), { env: Cr } = process, ra;
  Bs("no-color") || Bs("no-colors") || Bs("color=false") || Bs("color=never") ? ra = 0 : (Bs("color") || Bs("colors") || Bs("color=true") ||
  Bs("color=always")) && (ra = 1);
  "FORCE_COLOR" in Cr && (Cr.FORCE_COLOR === "true" ? ra = 1 : Cr.FORCE_COLOR === "false" ? ra = 0 : ra = Cr.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(Cr.FORCE_COLOR, 10), 3));
  function uv(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  i(uv, "translateLevel");
  function cv(e, t) {
    if (ra === 0)
      return 0;
    if (Bs("color=16m") || Bs("color=full") || Bs("color=truecolor"))
      return 3;
    if (Bs("color=256"))
      return 2;
    if (e && !t && ra === void 0)
      return 0;
    let r = ra || 0;
    if (Cr.TERM === "dumb")
      return r;
    if (process.platform === "win32") {
      let s = k0e.release().split(".");
      return Number(s[0]) >= 10 && Number(s[2]) >= 10586 ? Number(s[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in Cr)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((s) => s in Cr) || Cr.CI_NAME === "codeship" ?
      1 : r;
    if ("TEAMCITY_VERSION" in Cr)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Cr.TEAMCITY_VERSION) ? 1 : 0;
    if (Cr.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in Cr) {
      let s = parseInt((Cr.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Cr.TERM_PROGRAM) {
        case "iTerm.app":
          return s >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Cr.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Cr.TERM) || "COLORTERM" in
    Cr ? 1 : r;
  }
  i(cv, "supportsColor");
  function F0e(e) {
    let t = cv(e, e && e.isTTY);
    return uv(t);
  }
  i(F0e, "getSupportLevel");
  CF.exports = {
    supportsColor: F0e,
    stdout: uv(cv(!0, AF.isatty(1))),
    stderr: uv(cv(!0, AF.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var IF = y((Nr, cd) => {
  var L0e = require("tty"), ud = require("util");
  Nr.init = V0e;
  Nr.log = q0e;
  Nr.formatArgs = M0e;
  Nr.save = $0e;
  Nr.load = U0e;
  Nr.useColors = B0e;
  Nr.destroy = ud.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  Nr.colors = [6, 2, 3, 4, 5, 1];
  try {
    let e = wF();
    e && (e.stderr || e).level >= 2 && (Nr.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  Nr.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
    let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (n, a) => a.toUpperCase()), s = process.env[t];
    return /^(yes|on|true|enabled)$/i.test(s) ? s = !0 : /^(no|off|false|disabled)$/i.test(s) ? s = !1 : s === "null" ? s = null : s = Number(
    s), e[r] = s, e;
  }, {});
  function B0e() {
    return "colors" in Nr.inspectOpts ? !!Nr.inspectOpts.colors : L0e.isatty(process.stderr.fd);
  }
  i(B0e, "useColors");
  function M0e(e) {
    let { namespace: t, useColors: r } = this;
    if (r) {
      let s = this.color, n = "\x1B[3" + (s < 8 ? s : "8;5;" + s), a = `  ${n};1m${t} \x1B[0m`;
      e[0] = a + e[0].split(`
`).join(`
` + a), e.push(n + "m+" + cd.exports.humanize(this.diff) + "\x1B[0m");
    } else
      e[0] = j0e() + t + " " + e[0];
  }
  i(M0e, "formatArgs");
  function j0e() {
    return Nr.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  i(j0e, "getDate");
  function q0e(...e) {
    return process.stderr.write(ud.format(...e) + `
`);
  }
  i(q0e, "log");
  function $0e(e) {
    e ? process.env.DEBUG = e : delete process.env.DEBUG;
  }
  i($0e, "save");
  function U0e() {
    return process.env.DEBUG;
  }
  i(U0e, "load");
  function V0e(e) {
    e.inspectOpts = {};
    let t = Object.keys(Nr.inspectOpts);
    for (let r = 0; r < t.length; r++)
      e.inspectOpts[t[r]] = Nr.inspectOpts[t[r]];
  }
  i(V0e, "init");
  cd.exports = lv()(Nr);
  var { formatters: DF } = cd.exports;
  DF.o = function(e) {
    return this.inspectOpts.colors = this.useColors, ud.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
  };
  DF.O = function(e) {
    return this.inspectOpts.colors = this.useColors, ud.inspect(e, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var Qa = y((uZe, fv) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? fv.exports = TF() : fv.exports = IF();
});

// ../node_modules/@babel/helper-split-export-declaration/lib/index.js
var pc = y((hv) => {
  "use strict";
  Object.defineProperty(hv, "__esModule", {
    value: !0
  });
  hv.default = K0e;
  var W0e = Ne(), {
    cloneNode: pv,
    exportNamedDeclaration: _F,
    exportSpecifier: OF,
    identifier: dv,
    variableDeclaration: H0e,
    variableDeclarator: G0e
  } = W0e;
  function K0e(e) {
    if (!e.isExportDeclaration() || e.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (e.isExportDefaultDeclaration()) {
      let a = e.get("declaration"), o = a.isFunctionDeclaration() || a.isClassDeclaration(), l = a.isFunctionExpression() || a.isClassExpression(),
      u = a.isScope() ? a.scope.parent : a.scope, c = a.node.id, f = !1;
      c ? l && u.hasBinding(c.name) && (f = !0, c = u.generateUidIdentifier(c.name)) : (f = !0, c = u.generateUidIdentifier("default"), (o ||
      l) && (a.node.id = pv(c)));
      let p = o ? a.node : H0e("var", [G0e(pv(c), a.node)]), d = _F(null, [OF(pv(c), dv("default"))]);
      return e.insertAfter(d), e.replaceWith(p), f && u.registerDeclaration(e), e;
    } else if (e.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let t = e.get("declaration"), r = t.getOuterBindingIdentifiers(), s = Object.keys(r).map((a) => OF(dv(a), dv(a))), n = _F(null, s);
    return e.insertAfter(n), e.replaceWith(t.node), e;
  }
  i(K0e, "splitExportDeclaration");
});

// ../node_modules/@babel/helper-environment-visitor/lib/index.js
var sa = y((cl) => {
  "use strict";
  Object.defineProperty(cl, "__esModule", {
    value: !0
  });
  cl.default = void 0;
  cl.requeueComputedKeyAndDecorators = mv;
  cl.skipAllButComputedKey = /* @__PURE__ */ i(function(t) {
    t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
  }, "skipAllButComputedKey");
  function mv(e) {
    let {
      context: t,
      node: r
    } = e;
    if (r.computed && t.maybeQueue(e.get("key")), r.decorators)
      for (let s of e.get("decorators"))
        t.maybeQueue(s);
  }
  i(mv, "requeueComputedKeyAndDecorators");
  var Y0e = {
    FunctionParent(e) {
      e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && mv(e));
    },
    Property(e) {
      e.isObjectProperty() || (e.skip(), mv(e));
    }
  }, X0e = Y0e;
  cl.default = X0e;
});

// ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var NF = y((fd) => {
  "use strict";
  Object.defineProperty(fd, "__esModule", {
    value: !0
  });
  fd.default = void 0;
  var z0e = pc(), J0e = Ne(), Q0e = sa(), Z0e = pd(), ege = fc(), tge = {
    ReferencedIdentifier({
      node: e
    }, t) {
      e.name === t.oldName && (e.name = t.newName);
    },
    Scope(e, t) {
      e.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier) || (e.skip(), e.isMethod() && (0, Q0e.requeueComputedKeyAndDecorators)(
      e));
    },
    ObjectProperty({
      node: e,
      scope: t
    }, r) {
      let {
        name: s
      } = e.key;
      if (e.shorthand && (s === r.oldName || s === r.newName) && t.getBindingIdentifier(s) === r.binding.identifier) {
        var n;
        e.shorthand = !1, (n = e.extra) != null && n.shorthand && (e.extra.shorthand = !1);
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(e, t) {
      if (e.isVariableDeclaration()) return;
      let r = e.getOuterBindingIdentifiers();
      for (let s in r)
        s === t.oldName && (r[s].name = t.newName);
    }
  }, yv = class {
    static {
      i(this, "Renamer");
    }
    constructor(t, r, s) {
      this.newName = s, this.oldName = r, this.binding = t;
    }
    maybeConvertFromExportDeclaration(t) {
      let r = t.parentPath;
      if (r.isExportDeclaration()) {
        if (r.isExportDefaultDeclaration()) {
          let {
            declaration: s
          } = r.node;
          if (J0e.isDeclaration(s) && !s.id)
            return;
        }
        r.isExportAllDeclaration() || (0, z0e.default)(r);
      }
    }
    maybeConvertFromClassFunctionDeclaration(t) {
      return t;
    }
    maybeConvertFromClassFunctionExpression(t) {
      return t;
    }
    rename() {
      let {
        binding: t,
        oldName: r,
        newName: s
      } = this, {
        scope: n,
        path: a
      } = t, o = a.find((u) => u.isDeclaration() || u.isFunctionExpression() || u.isClassExpression());
      o && o.getOuterBindingIdentifiers()[r] === t.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || n.block;
      (0, Z0e.traverseNode)(l, (0, ege.explode)(tge), n, this, n.path, {
        discriminant: !0
      }), arguments[0] || (n.removeOwnBinding(r), n.bindings[s] = t, this.binding.identifier.name = s), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  fd.default = yv;
});

// ../node_modules/@babel/traverse/lib/scope/binding.js
var RF = y((dd) => {
  "use strict";
  Object.defineProperty(dd, "__esModule", {
    value: !0
  });
  dd.default = void 0;
  var gv = class {
    static {
      i(this, "Binding");
    }
    constructor({
      identifier: t,
      scope: r,
      path: s,
      kind: n
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = s, this.kind = n,
      (n === "var" || n === "hoisted") && rge(s) && this.reassign(s), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(t) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(t) {
      this.constant = !1, this.constantViolations.indexOf(t) === -1 && this.constantViolations.push(t);
    }
    reference(t) {
      this.referencePaths.indexOf(t) === -1 && (this.referenced = !0, this.references++, this.referencePaths.push(t));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  dd.default = gv;
  function rge(e) {
    for (let {
      parentPath: t,
      key: r
    } = e; t; {
      parentPath: t,
      key: r
    } = t) {
      if (t.isFunctionParent()) return !1;
      if (t.isWhile() || t.isForXStatement() || t.isForStatement() && r === "body")
        return !0;
    }
    return !1;
  }
  i(rge, "isDeclaredInLoop");
});

// ../node_modules/@babel/traverse/node_modules/globals/globals.json
var kF = y((bZe, sge) => {
  sge.exports = {
    builtin: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      BigInt: !1,
      BigInt64Array: !1,
      BigUint64Array: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      globalThis: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es5: {
      Array: !1,
      Boolean: !1,
      constructor: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      propertyIsEnumerable: !1,
      RangeError: !1,
      ReferenceError: !1,
      RegExp: !1,
      String: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1
    },
    es2015: {
      Array: !1,
      ArrayBuffer: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es2017: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    browser: {
      AbortController: !1,
      AbortSignal: !1,
      addEventListener: !1,
      alert: !1,
      AnalyserNode: !1,
      Animation: !1,
      AnimationEffectReadOnly: !1,
      AnimationEffectTiming: !1,
      AnimationEffectTimingReadOnly: !1,
      AnimationEvent: !1,
      AnimationPlaybackEvent: !1,
      AnimationTimeline: !1,
      applicationCache: !1,
      ApplicationCache: !1,
      ApplicationCacheErrorEvent: !1,
      atob: !1,
      Attr: !1,
      Audio: !1,
      AudioBuffer: !1,
      AudioBufferSourceNode: !1,
      AudioContext: !1,
      AudioDestinationNode: !1,
      AudioListener: !1,
      AudioNode: !1,
      AudioParam: !1,
      AudioProcessingEvent: !1,
      AudioScheduledSourceNode: !1,
      "AudioWorkletGlobalScope ": !1,
      AudioWorkletNode: !1,
      AudioWorkletProcessor: !1,
      BarProp: !1,
      BaseAudioContext: !1,
      BatteryManager: !1,
      BeforeUnloadEvent: !1,
      BiquadFilterNode: !1,
      Blob: !1,
      BlobEvent: !1,
      blur: !1,
      BroadcastChannel: !1,
      btoa: !1,
      BudgetService: !1,
      ByteLengthQueuingStrategy: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      cancelAnimationFrame: !1,
      cancelIdleCallback: !1,
      CanvasCaptureMediaStreamTrack: !1,
      CanvasGradient: !1,
      CanvasPattern: !1,
      CanvasRenderingContext2D: !1,
      ChannelMergerNode: !1,
      ChannelSplitterNode: !1,
      CharacterData: !1,
      clearInterval: !1,
      clearTimeout: !1,
      clientInformation: !1,
      ClipboardEvent: !1,
      close: !1,
      closed: !1,
      CloseEvent: !1,
      Comment: !1,
      CompositionEvent: !1,
      confirm: !1,
      console: !1,
      ConstantSourceNode: !1,
      ConvolverNode: !1,
      CountQueuingStrategy: !1,
      createImageBitmap: !1,
      Credential: !1,
      CredentialsContainer: !1,
      crypto: !1,
      Crypto: !1,
      CryptoKey: !1,
      CSS: !1,
      CSSConditionRule: !1,
      CSSFontFaceRule: !1,
      CSSGroupingRule: !1,
      CSSImportRule: !1,
      CSSKeyframeRule: !1,
      CSSKeyframesRule: !1,
      CSSMediaRule: !1,
      CSSNamespaceRule: !1,
      CSSPageRule: !1,
      CSSRule: !1,
      CSSRuleList: !1,
      CSSStyleDeclaration: !1,
      CSSStyleRule: !1,
      CSSStyleSheet: !1,
      CSSSupportsRule: !1,
      CustomElementRegistry: !1,
      customElements: !1,
      CustomEvent: !1,
      DataTransfer: !1,
      DataTransferItem: !1,
      DataTransferItemList: !1,
      defaultstatus: !1,
      defaultStatus: !1,
      DelayNode: !1,
      DeviceMotionEvent: !1,
      DeviceOrientationEvent: !1,
      devicePixelRatio: !1,
      dispatchEvent: !1,
      document: !1,
      Document: !1,
      DocumentFragment: !1,
      DocumentType: !1,
      DOMError: !1,
      DOMException: !1,
      DOMImplementation: !1,
      DOMMatrix: !1,
      DOMMatrixReadOnly: !1,
      DOMParser: !1,
      DOMPoint: !1,
      DOMPointReadOnly: !1,
      DOMQuad: !1,
      DOMRect: !1,
      DOMRectReadOnly: !1,
      DOMStringList: !1,
      DOMStringMap: !1,
      DOMTokenList: !1,
      DragEvent: !1,
      DynamicsCompressorNode: !1,
      Element: !1,
      ErrorEvent: !1,
      event: !1,
      Event: !1,
      EventSource: !1,
      EventTarget: !1,
      external: !1,
      fetch: !1,
      File: !1,
      FileList: !1,
      FileReader: !1,
      find: !1,
      focus: !1,
      FocusEvent: !1,
      FontFace: !1,
      FontFaceSetLoadEvent: !1,
      FormData: !1,
      frameElement: !1,
      frames: !1,
      GainNode: !1,
      Gamepad: !1,
      GamepadButton: !1,
      GamepadEvent: !1,
      getComputedStyle: !1,
      getSelection: !1,
      HashChangeEvent: !1,
      Headers: !1,
      history: !1,
      History: !1,
      HTMLAllCollection: !1,
      HTMLAnchorElement: !1,
      HTMLAreaElement: !1,
      HTMLAudioElement: !1,
      HTMLBaseElement: !1,
      HTMLBodyElement: !1,
      HTMLBRElement: !1,
      HTMLButtonElement: !1,
      HTMLCanvasElement: !1,
      HTMLCollection: !1,
      HTMLContentElement: !1,
      HTMLDataElement: !1,
      HTMLDataListElement: !1,
      HTMLDetailsElement: !1,
      HTMLDialogElement: !1,
      HTMLDirectoryElement: !1,
      HTMLDivElement: !1,
      HTMLDListElement: !1,
      HTMLDocument: !1,
      HTMLElement: !1,
      HTMLEmbedElement: !1,
      HTMLFieldSetElement: !1,
      HTMLFontElement: !1,
      HTMLFormControlsCollection: !1,
      HTMLFormElement: !1,
      HTMLFrameElement: !1,
      HTMLFrameSetElement: !1,
      HTMLHeadElement: !1,
      HTMLHeadingElement: !1,
      HTMLHRElement: !1,
      HTMLHtmlElement: !1,
      HTMLIFrameElement: !1,
      HTMLImageElement: !1,
      HTMLInputElement: !1,
      HTMLLabelElement: !1,
      HTMLLegendElement: !1,
      HTMLLIElement: !1,
      HTMLLinkElement: !1,
      HTMLMapElement: !1,
      HTMLMarqueeElement: !1,
      HTMLMediaElement: !1,
      HTMLMenuElement: !1,
      HTMLMetaElement: !1,
      HTMLMeterElement: !1,
      HTMLModElement: !1,
      HTMLObjectElement: !1,
      HTMLOListElement: !1,
      HTMLOptGroupElement: !1,
      HTMLOptionElement: !1,
      HTMLOptionsCollection: !1,
      HTMLOutputElement: !1,
      HTMLParagraphElement: !1,
      HTMLParamElement: !1,
      HTMLPictureElement: !1,
      HTMLPreElement: !1,
      HTMLProgressElement: !1,
      HTMLQuoteElement: !1,
      HTMLScriptElement: !1,
      HTMLSelectElement: !1,
      HTMLShadowElement: !1,
      HTMLSlotElement: !1,
      HTMLSourceElement: !1,
      HTMLSpanElement: !1,
      HTMLStyleElement: !1,
      HTMLTableCaptionElement: !1,
      HTMLTableCellElement: !1,
      HTMLTableColElement: !1,
      HTMLTableElement: !1,
      HTMLTableRowElement: !1,
      HTMLTableSectionElement: !1,
      HTMLTemplateElement: !1,
      HTMLTextAreaElement: !1,
      HTMLTimeElement: !1,
      HTMLTitleElement: !1,
      HTMLTrackElement: !1,
      HTMLUListElement: !1,
      HTMLUnknownElement: !1,
      HTMLVideoElement: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      IdleDeadline: !1,
      IIRFilterNode: !1,
      Image: !1,
      ImageBitmap: !1,
      ImageBitmapRenderingContext: !1,
      ImageCapture: !1,
      ImageData: !1,
      indexedDB: !1,
      innerHeight: !1,
      innerWidth: !1,
      InputEvent: !1,
      IntersectionObserver: !1,
      IntersectionObserverEntry: !1,
      Intl: !1,
      isSecureContext: !1,
      KeyboardEvent: !1,
      KeyframeEffect: !1,
      KeyframeEffectReadOnly: !1,
      length: !1,
      localStorage: !1,
      location: !0,
      Location: !1,
      locationbar: !1,
      matchMedia: !1,
      MediaDeviceInfo: !1,
      MediaDevices: !1,
      MediaElementAudioSourceNode: !1,
      MediaEncryptedEvent: !1,
      MediaError: !1,
      MediaKeyMessageEvent: !1,
      MediaKeySession: !1,
      MediaKeyStatusMap: !1,
      MediaKeySystemAccess: !1,
      MediaList: !1,
      MediaQueryList: !1,
      MediaQueryListEvent: !1,
      MediaRecorder: !1,
      MediaSettingsRange: !1,
      MediaSource: !1,
      MediaStream: !1,
      MediaStreamAudioDestinationNode: !1,
      MediaStreamAudioSourceNode: !1,
      MediaStreamEvent: !1,
      MediaStreamTrack: !1,
      MediaStreamTrackEvent: !1,
      menubar: !1,
      MessageChannel: !1,
      MessageEvent: !1,
      MessagePort: !1,
      MIDIAccess: !1,
      MIDIConnectionEvent: !1,
      MIDIInput: !1,
      MIDIInputMap: !1,
      MIDIMessageEvent: !1,
      MIDIOutput: !1,
      MIDIOutputMap: !1,
      MIDIPort: !1,
      MimeType: !1,
      MimeTypeArray: !1,
      MouseEvent: !1,
      moveBy: !1,
      moveTo: !1,
      MutationEvent: !1,
      MutationObserver: !1,
      MutationRecord: !1,
      name: !1,
      NamedNodeMap: !1,
      NavigationPreloadManager: !1,
      navigator: !1,
      Navigator: !1,
      NetworkInformation: !1,
      Node: !1,
      NodeFilter: !1,
      NodeIterator: !1,
      NodeList: !1,
      Notification: !1,
      OfflineAudioCompletionEvent: !1,
      OfflineAudioContext: !1,
      offscreenBuffering: !1,
      OffscreenCanvas: !0,
      onabort: !0,
      onafterprint: !0,
      onanimationend: !0,
      onanimationiteration: !0,
      onanimationstart: !0,
      onappinstalled: !0,
      onauxclick: !0,
      onbeforeinstallprompt: !0,
      onbeforeprint: !0,
      onbeforeunload: !0,
      onblur: !0,
      oncancel: !0,
      oncanplay: !0,
      oncanplaythrough: !0,
      onchange: !0,
      onclick: !0,
      onclose: !0,
      oncontextmenu: !0,
      oncuechange: !0,
      ondblclick: !0,
      ondevicemotion: !0,
      ondeviceorientation: !0,
      ondeviceorientationabsolute: !0,
      ondrag: !0,
      ondragend: !0,
      ondragenter: !0,
      ondragleave: !0,
      ondragover: !0,
      ondragstart: !0,
      ondrop: !0,
      ondurationchange: !0,
      onemptied: !0,
      onended: !0,
      onerror: !0,
      onfocus: !0,
      ongotpointercapture: !0,
      onhashchange: !0,
      oninput: !0,
      oninvalid: !0,
      onkeydown: !0,
      onkeypress: !0,
      onkeyup: !0,
      onlanguagechange: !0,
      onload: !0,
      onloadeddata: !0,
      onloadedmetadata: !0,
      onloadstart: !0,
      onlostpointercapture: !0,
      onmessage: !0,
      onmessageerror: !0,
      onmousedown: !0,
      onmouseenter: !0,
      onmouseleave: !0,
      onmousemove: !0,
      onmouseout: !0,
      onmouseover: !0,
      onmouseup: !0,
      onmousewheel: !0,
      onoffline: !0,
      ononline: !0,
      onpagehide: !0,
      onpageshow: !0,
      onpause: !0,
      onplay: !0,
      onplaying: !0,
      onpointercancel: !0,
      onpointerdown: !0,
      onpointerenter: !0,
      onpointerleave: !0,
      onpointermove: !0,
      onpointerout: !0,
      onpointerover: !0,
      onpointerup: !0,
      onpopstate: !0,
      onprogress: !0,
      onratechange: !0,
      onrejectionhandled: !0,
      onreset: !0,
      onresize: !0,
      onscroll: !0,
      onsearch: !0,
      onseeked: !0,
      onseeking: !0,
      onselect: !0,
      onstalled: !0,
      onstorage: !0,
      onsubmit: !0,
      onsuspend: !0,
      ontimeupdate: !0,
      ontoggle: !0,
      ontransitionend: !0,
      onunhandledrejection: !0,
      onunload: !0,
      onvolumechange: !0,
      onwaiting: !0,
      onwheel: !0,
      open: !1,
      openDatabase: !1,
      opener: !1,
      Option: !1,
      origin: !1,
      OscillatorNode: !1,
      outerHeight: !1,
      outerWidth: !1,
      PageTransitionEvent: !1,
      pageXOffset: !1,
      pageYOffset: !1,
      PannerNode: !1,
      parent: !1,
      Path2D: !1,
      PaymentAddress: !1,
      PaymentRequest: !1,
      PaymentRequestUpdateEvent: !1,
      PaymentResponse: !1,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceLongTaskTiming: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceNavigationTiming: !1,
      PerformanceObserver: !1,
      PerformanceObserverEntryList: !1,
      PerformancePaintTiming: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      PeriodicWave: !1,
      Permissions: !1,
      PermissionStatus: !1,
      personalbar: !1,
      PhotoCapabilities: !1,
      Plugin: !1,
      PluginArray: !1,
      PointerEvent: !1,
      PopStateEvent: !1,
      postMessage: !1,
      Presentation: !1,
      PresentationAvailability: !1,
      PresentationConnection: !1,
      PresentationConnectionAvailableEvent: !1,
      PresentationConnectionCloseEvent: !1,
      PresentationConnectionList: !1,
      PresentationReceiver: !1,
      PresentationRequest: !1,
      print: !1,
      ProcessingInstruction: !1,
      ProgressEvent: !1,
      PromiseRejectionEvent: !1,
      prompt: !1,
      PushManager: !1,
      PushSubscription: !1,
      PushSubscriptionOptions: !1,
      queueMicrotask: !1,
      RadioNodeList: !1,
      Range: !1,
      ReadableStream: !1,
      registerProcessor: !1,
      RemotePlayback: !1,
      removeEventListener: !1,
      Request: !1,
      requestAnimationFrame: !1,
      requestIdleCallback: !1,
      resizeBy: !1,
      ResizeObserver: !1,
      ResizeObserverEntry: !1,
      resizeTo: !1,
      Response: !1,
      RTCCertificate: !1,
      RTCDataChannel: !1,
      RTCDataChannelEvent: !1,
      RTCDtlsTransport: !1,
      RTCIceCandidate: !1,
      RTCIceGatherer: !1,
      RTCIceTransport: !1,
      RTCPeerConnection: !1,
      RTCPeerConnectionIceEvent: !1,
      RTCRtpContributingSource: !1,
      RTCRtpReceiver: !1,
      RTCRtpSender: !1,
      RTCSctpTransport: !1,
      RTCSessionDescription: !1,
      RTCStatsReport: !1,
      RTCTrackEvent: !1,
      screen: !1,
      Screen: !1,
      screenLeft: !1,
      ScreenOrientation: !1,
      screenTop: !1,
      screenX: !1,
      screenY: !1,
      ScriptProcessorNode: !1,
      scroll: !1,
      scrollbars: !1,
      scrollBy: !1,
      scrollTo: !1,
      scrollX: !1,
      scrollY: !1,
      SecurityPolicyViolationEvent: !1,
      Selection: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerRegistration: !1,
      sessionStorage: !1,
      setInterval: !1,
      setTimeout: !1,
      ShadowRoot: !1,
      SharedWorker: !1,
      SourceBuffer: !1,
      SourceBufferList: !1,
      speechSynthesis: !1,
      SpeechSynthesisEvent: !1,
      SpeechSynthesisUtterance: !1,
      StaticRange: !1,
      status: !1,
      statusbar: !1,
      StereoPannerNode: !1,
      stop: !1,
      Storage: !1,
      StorageEvent: !1,
      StorageManager: !1,
      styleMedia: !1,
      StyleSheet: !1,
      StyleSheetList: !1,
      SubtleCrypto: !1,
      SVGAElement: !1,
      SVGAngle: !1,
      SVGAnimatedAngle: !1,
      SVGAnimatedBoolean: !1,
      SVGAnimatedEnumeration: !1,
      SVGAnimatedInteger: !1,
      SVGAnimatedLength: !1,
      SVGAnimatedLengthList: !1,
      SVGAnimatedNumber: !1,
      SVGAnimatedNumberList: !1,
      SVGAnimatedPreserveAspectRatio: !1,
      SVGAnimatedRect: !1,
      SVGAnimatedString: !1,
      SVGAnimatedTransformList: !1,
      SVGAnimateElement: !1,
      SVGAnimateMotionElement: !1,
      SVGAnimateTransformElement: !1,
      SVGAnimationElement: !1,
      SVGCircleElement: !1,
      SVGClipPathElement: !1,
      SVGComponentTransferFunctionElement: !1,
      SVGDefsElement: !1,
      SVGDescElement: !1,
      SVGDiscardElement: !1,
      SVGElement: !1,
      SVGEllipseElement: !1,
      SVGFEBlendElement: !1,
      SVGFEColorMatrixElement: !1,
      SVGFEComponentTransferElement: !1,
      SVGFECompositeElement: !1,
      SVGFEConvolveMatrixElement: !1,
      SVGFEDiffuseLightingElement: !1,
      SVGFEDisplacementMapElement: !1,
      SVGFEDistantLightElement: !1,
      SVGFEDropShadowElement: !1,
      SVGFEFloodElement: !1,
      SVGFEFuncAElement: !1,
      SVGFEFuncBElement: !1,
      SVGFEFuncGElement: !1,
      SVGFEFuncRElement: !1,
      SVGFEGaussianBlurElement: !1,
      SVGFEImageElement: !1,
      SVGFEMergeElement: !1,
      SVGFEMergeNodeElement: !1,
      SVGFEMorphologyElement: !1,
      SVGFEOffsetElement: !1,
      SVGFEPointLightElement: !1,
      SVGFESpecularLightingElement: !1,
      SVGFESpotLightElement: !1,
      SVGFETileElement: !1,
      SVGFETurbulenceElement: !1,
      SVGFilterElement: !1,
      SVGForeignObjectElement: !1,
      SVGGElement: !1,
      SVGGeometryElement: !1,
      SVGGradientElement: !1,
      SVGGraphicsElement: !1,
      SVGImageElement: !1,
      SVGLength: !1,
      SVGLengthList: !1,
      SVGLinearGradientElement: !1,
      SVGLineElement: !1,
      SVGMarkerElement: !1,
      SVGMaskElement: !1,
      SVGMatrix: !1,
      SVGMetadataElement: !1,
      SVGMPathElement: !1,
      SVGNumber: !1,
      SVGNumberList: !1,
      SVGPathElement: !1,
      SVGPatternElement: !1,
      SVGPoint: !1,
      SVGPointList: !1,
      SVGPolygonElement: !1,
      SVGPolylineElement: !1,
      SVGPreserveAspectRatio: !1,
      SVGRadialGradientElement: !1,
      SVGRect: !1,
      SVGRectElement: !1,
      SVGScriptElement: !1,
      SVGSetElement: !1,
      SVGStopElement: !1,
      SVGStringList: !1,
      SVGStyleElement: !1,
      SVGSVGElement: !1,
      SVGSwitchElement: !1,
      SVGSymbolElement: !1,
      SVGTextContentElement: !1,
      SVGTextElement: !1,
      SVGTextPathElement: !1,
      SVGTextPositioningElement: !1,
      SVGTitleElement: !1,
      SVGTransform: !1,
      SVGTransformList: !1,
      SVGTSpanElement: !1,
      SVGUnitTypes: !1,
      SVGUseElement: !1,
      SVGViewElement: !1,
      TaskAttributionTiming: !1,
      Text: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      TextEvent: !1,
      TextMetrics: !1,
      TextTrack: !1,
      TextTrackCue: !1,
      TextTrackCueList: !1,
      TextTrackList: !1,
      TimeRanges: !1,
      toolbar: !1,
      top: !1,
      Touch: !1,
      TouchEvent: !1,
      TouchList: !1,
      TrackEvent: !1,
      TransitionEvent: !1,
      TreeWalker: !1,
      UIEvent: !1,
      URL: !1,
      URLSearchParams: !1,
      ValidityState: !1,
      visualViewport: !1,
      VisualViewport: !1,
      VTTCue: !1,
      WaveShaperNode: !1,
      WebAssembly: !1,
      WebGL2RenderingContext: !1,
      WebGLActiveInfo: !1,
      WebGLBuffer: !1,
      WebGLContextEvent: !1,
      WebGLFramebuffer: !1,
      WebGLProgram: !1,
      WebGLQuery: !1,
      WebGLRenderbuffer: !1,
      WebGLRenderingContext: !1,
      WebGLSampler: !1,
      WebGLShader: !1,
      WebGLShaderPrecisionFormat: !1,
      WebGLSync: !1,
      WebGLTexture: !1,
      WebGLTransformFeedback: !1,
      WebGLUniformLocation: !1,
      WebGLVertexArrayObject: !1,
      WebSocket: !1,
      WheelEvent: !1,
      window: !1,
      Window: !1,
      Worker: !1,
      WritableStream: !1,
      XMLDocument: !1,
      XMLHttpRequest: !1,
      XMLHttpRequestEventTarget: !1,
      XMLHttpRequestUpload: !1,
      XMLSerializer: !1,
      XPathEvaluator: !1,
      XPathExpression: !1,
      XPathResult: !1,
      XSLTProcessor: !1
    },
    worker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      clearInterval: !1,
      clearTimeout: !1,
      close: !0,
      console: !1,
      fetch: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !0,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onoffline: !0,
      ononline: !0,
      onrejectionhandled: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !0,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    node: {
      __dirname: !1,
      __filename: !1,
      Buffer: !1,
      clearImmediate: !1,
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      exports: !0,
      global: !1,
      Intl: !1,
      module: !1,
      process: !1,
      queueMicrotask: !1,
      require: !1,
      setImmediate: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1
    },
    commonjs: {
      exports: !0,
      global: !1,
      module: !1,
      require: !1
    },
    amd: {
      define: !1,
      require: !1
    },
    mocha: {
      after: !1,
      afterEach: !1,
      before: !1,
      beforeEach: !1,
      context: !1,
      describe: !1,
      it: !1,
      mocha: !1,
      run: !1,
      setup: !1,
      specify: !1,
      suite: !1,
      suiteSetup: !1,
      suiteTeardown: !1,
      teardown: !1,
      test: !1,
      xcontext: !1,
      xdescribe: !1,
      xit: !1,
      xspecify: !1
    },
    jasmine: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fail: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jasmine: !1,
      pending: !1,
      runs: !1,
      spyOn: !1,
      spyOnProperty: !1,
      waits: !1,
      waitsFor: !1,
      xdescribe: !1,
      xit: !1
    },
    jest: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jest: !1,
      pit: !1,
      require: !1,
      test: !1,
      xdescribe: !1,
      xit: !1,
      xtest: !1
    },
    qunit: {
      asyncTest: !1,
      deepEqual: !1,
      equal: !1,
      expect: !1,
      module: !1,
      notDeepEqual: !1,
      notEqual: !1,
      notOk: !1,
      notPropEqual: !1,
      notStrictEqual: !1,
      ok: !1,
      propEqual: !1,
      QUnit: !1,
      raises: !1,
      start: !1,
      stop: !1,
      strictEqual: !1,
      test: !1,
      throws: !1
    },
    phantomjs: {
      console: !0,
      exports: !0,
      phantom: !0,
      require: !0,
      WebPage: !0
    },
    couch: {
      emit: !1,
      exports: !1,
      getRow: !1,
      log: !1,
      module: !1,
      provides: !1,
      require: !1,
      respond: !1,
      send: !1,
      start: !1,
      sum: !1
    },
    rhino: {
      defineClass: !1,
      deserialize: !1,
      gc: !1,
      help: !1,
      importClass: !1,
      importPackage: !1,
      java: !1,
      load: !1,
      loadClass: !1,
      Packages: !1,
      print: !1,
      quit: !1,
      readFile: !1,
      readUrl: !1,
      runCommand: !1,
      seal: !1,
      serialize: !1,
      spawn: !1,
      sync: !1,
      toint32: !1,
      version: !1
    },
    nashorn: {
      __DIR__: !1,
      __FILE__: !1,
      __LINE__: !1,
      com: !1,
      edu: !1,
      exit: !1,
      java: !1,
      Java: !1,
      javafx: !1,
      JavaImporter: !1,
      javax: !1,
      JSAdapter: !1,
      load: !1,
      loadWithNewGlobal: !1,
      org: !1,
      Packages: !1,
      print: !1,
      quit: !1
    },
    wsh: {
      ActiveXObject: !0,
      Enumerator: !0,
      GetObject: !0,
      ScriptEngine: !0,
      ScriptEngineBuildVersion: !0,
      ScriptEngineMajorVersion: !0,
      ScriptEngineMinorVersion: !0,
      VBArray: !0,
      WScript: !0,
      WSH: !0,
      XDomainRequest: !0
    },
    jquery: {
      $: !1,
      jQuery: !1
    },
    yui: {
      YAHOO: !1,
      YAHOO_config: !1,
      YUI: !1,
      YUI_config: !1
    },
    shelljs: {
      cat: !1,
      cd: !1,
      chmod: !1,
      config: !1,
      cp: !1,
      dirs: !1,
      echo: !1,
      env: !1,
      error: !1,
      exec: !1,
      exit: !1,
      find: !1,
      grep: !1,
      ln: !1,
      ls: !1,
      mkdir: !1,
      mv: !1,
      popd: !1,
      pushd: !1,
      pwd: !1,
      rm: !1,
      sed: !1,
      set: !1,
      target: !1,
      tempdir: !1,
      test: !1,
      touch: !1,
      which: !1
    },
    prototypejs: {
      $: !1,
      $$: !1,
      $A: !1,
      $break: !1,
      $continue: !1,
      $F: !1,
      $H: !1,
      $R: !1,
      $w: !1,
      Abstract: !1,
      Ajax: !1,
      Autocompleter: !1,
      Builder: !1,
      Class: !1,
      Control: !1,
      Draggable: !1,
      Draggables: !1,
      Droppables: !1,
      Effect: !1,
      Element: !1,
      Enumerable: !1,
      Event: !1,
      Field: !1,
      Form: !1,
      Hash: !1,
      Insertion: !1,
      ObjectRange: !1,
      PeriodicalExecuter: !1,
      Position: !1,
      Prototype: !1,
      Scriptaculous: !1,
      Selector: !1,
      Sortable: !1,
      SortableObserver: !1,
      Sound: !1,
      Template: !1,
      Toggle: !1,
      Try: !1
    },
    meteor: {
      _: !1,
      $: !1,
      Accounts: !1,
      AccountsClient: !1,
      AccountsCommon: !1,
      AccountsServer: !1,
      App: !1,
      Assets: !1,
      Blaze: !1,
      check: !1,
      Cordova: !1,
      DDP: !1,
      DDPRateLimiter: !1,
      DDPServer: !1,
      Deps: !1,
      EJSON: !1,
      Email: !1,
      HTTP: !1,
      Log: !1,
      Match: !1,
      Meteor: !1,
      Mongo: !1,
      MongoInternals: !1,
      Npm: !1,
      Package: !1,
      Plugin: !1,
      process: !1,
      Random: !1,
      ReactiveDict: !1,
      ReactiveVar: !1,
      Router: !1,
      ServiceConfiguration: !1,
      Session: !1,
      share: !1,
      Spacebars: !1,
      Template: !1,
      Tinytest: !1,
      Tracker: !1,
      UI: !1,
      Utils: !1,
      WebApp: !1,
      WebAppInternals: !1
    },
    mongo: {
      _isWindows: !1,
      _rand: !1,
      BulkWriteResult: !1,
      cat: !1,
      cd: !1,
      connect: !1,
      db: !1,
      getHostName: !1,
      getMemInfo: !1,
      hostname: !1,
      ISODate: !1,
      listFiles: !1,
      load: !1,
      ls: !1,
      md5sumFile: !1,
      mkdir: !1,
      Mongo: !1,
      NumberInt: !1,
      NumberLong: !1,
      ObjectId: !1,
      PlanCache: !1,
      print: !1,
      printjson: !1,
      pwd: !1,
      quit: !1,
      removeFile: !1,
      rs: !1,
      sh: !1,
      UUID: !1,
      version: !1,
      WriteResult: !1
    },
    applescript: {
      $: !1,
      Application: !1,
      Automation: !1,
      console: !1,
      delay: !1,
      Library: !1,
      ObjC: !1,
      ObjectSpecifier: !1,
      Path: !1,
      Progress: !1,
      Ref: !1
    },
    serviceworker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      clearInterval: !1,
      clearTimeout: !1,
      Client: !1,
      clients: !1,
      Clients: !1,
      close: !0,
      console: !1,
      ExtendableEvent: !1,
      ExtendableMessageEvent: !1,
      fetch: !1,
      FetchEvent: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !1,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onfetch: !0,
      oninstall: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onmessageerror: !0,
      onnotificationclick: !0,
      onnotificationclose: !0,
      onoffline: !0,
      ononline: !0,
      onpush: !0,
      onpushsubscriptionchange: !0,
      onrejectionhandled: !0,
      onsync: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      registration: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerGlobalScope: !1,
      ServiceWorkerMessageEvent: !1,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      skipWaiting: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      WindowClient: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    atomtest: {
      advanceClock: !1,
      fakeClearInterval: !1,
      fakeClearTimeout: !1,
      fakeSetInterval: !1,
      fakeSetTimeout: !1,
      resetTimeouts: !1,
      waitsForPromise: !1
    },
    embertest: {
      andThen: !1,
      click: !1,
      currentPath: !1,
      currentRouteName: !1,
      currentURL: !1,
      fillIn: !1,
      find: !1,
      findAll: !1,
      findWithAssert: !1,
      keyEvent: !1,
      pauseTest: !1,
      resumeTest: !1,
      triggerEvent: !1,
      visit: !1,
      wait: !1
    },
    protractor: {
      $: !1,
      $$: !1,
      browser: !1,
      by: !1,
      By: !1,
      DartObject: !1,
      element: !1,
      protractor: !1
    },
    "shared-node-browser": {
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      setInterval: !1,
      setTimeout: !1,
      URL: !1,
      URLSearchParams: !1
    },
    webextensions: {
      browser: !1,
      chrome: !1,
      opr: !1
    },
    greasemonkey: {
      cloneInto: !1,
      createObjectIn: !1,
      exportFunction: !1,
      GM: !1,
      GM_addStyle: !1,
      GM_deleteValue: !1,
      GM_getResourceText: !1,
      GM_getResourceURL: !1,
      GM_getValue: !1,
      GM_info: !1,
      GM_listValues: !1,
      GM_log: !1,
      GM_openInTab: !1,
      GM_registerMenuCommand: !1,
      GM_setClipboard: !1,
      GM_setValue: !1,
      GM_xmlhttpRequest: !1,
      unsafeWindow: !1
    },
    devtools: {
      $: !1,
      $_: !1,
      $$: !1,
      $0: !1,
      $1: !1,
      $2: !1,
      $3: !1,
      $4: !1,
      $x: !1,
      chrome: !1,
      clear: !1,
      copy: !1,
      debug: !1,
      dir: !1,
      dirxml: !1,
      getEventListeners: !1,
      inspect: !1,
      keys: !1,
      monitor: !1,
      monitorEvents: !1,
      profile: !1,
      profileEnd: !1,
      queryObjects: !1,
      table: !1,
      undebug: !1,
      unmonitor: !1,
      unmonitorEvents: !1,
      values: !1
    }
  };
});

// ../node_modules/@babel/traverse/node_modules/globals/index.js
var LF = y((EZe, FF) => {
  "use strict";
  FF.exports = kF();
});

// ../node_modules/@babel/traverse/lib/scope/index.js
var Sv = y((md) => {
  "use strict";
  Object.defineProperty(md, "__esModule", {
    value: !0
  });
  md.default = void 0;
  var nge = NF(), ige = Ms(), age = RF(), oge = LF(), GF = Ne(), lge = GF, BF = za(), uge = fc(), {
    NOT_LOCAL_BINDING: MF,
    callExpression: jF,
    cloneNode: qF,
    getBindingIdentifiers: cge,
    identifier: fl,
    isArrayExpression: $F,
    isBinary: fge,
    isCallExpression: UF,
    isClass: pge,
    isClassBody: dge,
    isClassDeclaration: hge,
    isExportAllDeclaration: KF,
    isExportDefaultDeclaration: mge,
    isExportNamedDeclaration: bv,
    isFunctionDeclaration: yge,
    isIdentifier: Za,
    isImportDeclaration: Ev,
    isLiteral: gge,
    isMemberExpression: bge,
    isMethod: Ege,
    isModuleSpecifier: vge,
    isNullLiteral: Sge,
    isObjectExpression: Tge,
    isProperty: xge,
    isPureish: Pge,
    isRegExpLiteral: Age,
    isSuper: Cge,
    isTaggedTemplateExpression: wge,
    isTemplateLiteral: YF,
    isThisExpression: VF,
    isUnaryExpression: Dge,
    isVariableDeclaration: Ige,
    matchesPattern: WF,
    memberExpression: vv,
    numericLiteral: _ge,
    toIdentifier: Oge,
    variableDeclaration: Nge,
    variableDeclarator: Rge,
    isRecordExpression: kge,
    isTupleExpression: Fge,
    isObjectProperty: Lge,
    isTopicReference: HF,
    isMetaProperty: Bge,
    isPrivateName: Mge,
    isExportDeclaration: jge,
    buildUndefinedNode: qge
  } = GF;
  function Ut(e, t) {
    switch (e?.type) {
      default:
        if (Ev(e) || jge(e)) {
          var r;
          if ((KF(e) || bv(e) || Ev(e)) && e.source)
            Ut(e.source, t);
          else if ((bv(e) || Ev(e)) && (r = e.specifiers) != null && r.length)
            for (let s of e.specifiers) Ut(s, t);
          else (mge(e) || bv(e)) && e.declaration && Ut(e.declaration, t);
        } else vge(e) ? Ut(e.local, t) : gge(e) && !Sge(e) && !Age(e) && !YF(e) && t.push(e.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        Ut(e.object, t), Ut(e.property, t);
        break;
      case "Identifier":
      case "JSXIdentifier":
        t.push(e.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        Ut(e.callee, t);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let s of e.properties)
          Ut(s, t);
        break;
      case "SpreadElement":
      case "RestElement":
        Ut(e.argument, t);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        Ut(e.key, t);
        break;
      case "ThisExpression":
        t.push("this");
        break;
      case "Super":
        t.push("super");
        break;
      case "Import":
        t.push("import");
        break;
      case "DoExpression":
        t.push("do");
        break;
      case "YieldExpression":
        t.push("yield"), Ut(e.argument, t);
        break;
      case "AwaitExpression":
        t.push("await"), Ut(e.argument, t);
        break;
      case "AssignmentExpression":
        Ut(e.left, t);
        break;
      case "VariableDeclarator":
        Ut(e.id, t);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        Ut(e.id, t);
        break;
      case "PrivateName":
        Ut(e.id, t);
        break;
      case "ParenthesizedExpression":
        Ut(e.expression, t);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        Ut(e.argument, t);
        break;
      case "MetaProperty":
        Ut(e.meta, t), Ut(e.property, t);
        break;
      case "JSXElement":
        Ut(e.openingElement, t);
        break;
      case "JSXOpeningElement":
        Ut(e.name, t);
        break;
      case "JSXFragment":
        Ut(e.openingFragment, t);
        break;
      case "JSXOpeningFragment":
        t.push("Fragment");
        break;
      case "JSXNamespacedName":
        Ut(e.namespace, t), Ut(e.name, t);
        break;
    }
  }
  i(Ut, "gatherNodeParts");
  var hd = {
    ForStatement(e) {
      let t = e.get("init");
      if (t.isVar()) {
        let {
          scope: r
        } = e;
        (r.getFunctionParent() || r.getProgramParent()).registerBinding("var", t);
      }
    },
    Declaration(e) {
      if (e.isBlockScoped() || e.isImportDeclaration() || e.isExportDeclaration()) return;
      (e.scope.getFunctionParent() || e.scope.getProgramParent()).registerDeclaration(e);
    },
    ImportDeclaration(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    ReferencedIdentifier(e, t) {
      t.references.push(e);
    },
    ForXStatement(e, t) {
      let r = e.get("left");
      if (r.isPattern() || r.isIdentifier())
        t.constantViolations.push(e);
      else if (r.isVar()) {
        let {
          scope: s
        } = e;
        (s.getFunctionParent() || s.getProgramParent()).registerBinding("var", r);
      }
    },
    ExportDeclaration: {
      exit(e) {
        let {
          node: t,
          scope: r
        } = e;
        if (KF(t)) return;
        let s = t.declaration;
        if (hge(s) || yge(s)) {
          let n = s.id;
          if (!n) return;
          let a = r.getBinding(n.name);
          a?.reference(e);
        } else if (Ige(s))
          for (let n of s.declarations)
            for (let a of Object.keys(cge(n))) {
              let o = r.getBinding(a);
              o?.reference(e);
            }
      }
    },
    LabeledStatement(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    AssignmentExpression(e, t) {
      t.assignments.push(e);
    },
    UpdateExpression(e, t) {
      t.constantViolations.push(e);
    },
    UnaryExpression(e, t) {
      e.node.operator === "delete" && t.constantViolations.push(e);
    },
    BlockScoped(e) {
      let t = e.scope;
      if (t.path === e && (t = t.parent), t.getBlockParent().registerDeclaration(e), e.isClassDeclaration() && e.node.id) {
        let n = e.node.id.name;
        e.scope.bindings[n] = e.scope.parent.getBinding(n);
      }
    },
    CatchClause(e) {
      e.scope.registerBinding("let", e);
    },
    Function(e) {
      let t = e.get("params");
      for (let r of t)
        e.scope.registerBinding("param", r);
      e.isFunctionExpression() && e.has("id") && !e.get("id").node[MF] && e.scope.registerBinding("local", e.get("id"), e);
    },
    ClassExpression(e) {
      e.has("id") && !e.get("id").node[MF] && e.scope.registerBinding("local", e);
    }
  }, $ge = 0, dc = class e {
    static {
      i(this, "Scope");
    }
    constructor(t) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references =
      void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: r
      } = t, s = BF.scope.get(r);
      if (s?.path === t)
        return s;
      BF.scope.set(r, this), this.uid = $ge++, this.block = r, this.path = t, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var t;
      let r, s = this.path;
      do {
        let n = s.key === "key" || s.listKey === "decorators";
        s = s.parentPath, n && s.isMethod() && (s = s.parentPath), s && s.isScope() && (r = s);
      } while (s && !r);
      return (t = r) == null ? void 0 : t.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(t, r, s) {
      (0, ige.default)(t, r, this, s, this.path);
    }
    generateDeclaredUidIdentifier(t) {
      let r = this.generateUidIdentifier(t);
      return this.push({
        id: r
      }), qF(r);
    }
    generateUidIdentifier(t) {
      return fl(this.generateUid(t));
    }
    generateUid(t = "temp") {
      t = Oge(t).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let r, s = 1;
      do
        r = this._generateUid(t, s), s++;
      while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r));
      let n = this.getProgramParent();
      return n.references[r] = !0, n.uids[r] = !0, r;
    }
    _generateUid(t, r) {
      let s = t;
      return r > 1 && (s += r), `_${s}`;
    }
    generateUidBasedOnNode(t, r) {
      let s = [];
      Ut(t, s);
      let n = s.join("$");
      return n = n.replace(/^_/, "") || r || "ref", this.generateUid(n.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(t, r) {
      return fl(this.generateUidBasedOnNode(t, r));
    }
    isStatic(t) {
      if (VF(t) || Cge(t) || HF(t))
        return !0;
      if (Za(t)) {
        let r = this.getBinding(t.name);
        return r ? r.constant : this.hasBinding(t.name);
      }
      return !1;
    }
    maybeGenerateMemoised(t, r) {
      if (this.isStatic(t))
        return null;
      {
        let s = this.generateUidIdentifierBasedOnNode(t);
        return r ? s : (this.push({
          id: s
        }), qF(s));
      }
    }
    checkBlockScopedCollisions(t, r, s, n) {
      if (r === "param" || t.kind === "local") return;
      if (r === "let" || t.kind === "let" || t.kind === "const" || t.kind === "module" || t.kind === "param" && r === "const")
        throw this.hub.buildError(n, `Duplicate declaration "${s}"`, TypeError);
    }
    rename(t, r) {
      let s = this.getBinding(t);
      s && (r || (r = this.generateUidIdentifier(t).name), new nge.default(s, t, r).rename(arguments[2]));
    }
    _renameFromMap(t, r, s, n) {
      t[r] && (t[s] = n, t[r] = null);
    }
    dump() {
      let t = "-".repeat(60);
      console.log(t);
      let r = this;
      do {
        console.log("#", r.block.type);
        for (let s of Object.keys(r.bindings)) {
          let n = r.bindings[s];
          console.log(" -", s, {
            constant: n.constant,
            references: n.references,
            violations: n.constantViolations.length,
            kind: n.kind
          });
        }
      } while (r = r.parent);
      console.log(t);
    }
    toArray(t, r, s) {
      if (Za(t)) {
        let o = this.getBinding(t.name);
        if (o != null && o.constant && o.path.isGenericType("Array"))
          return t;
      }
      if ($F(t))
        return t;
      if (Za(t, {
        name: "arguments"
      }))
        return jF(vv(vv(vv(fl("Array"), fl("prototype")), fl("slice")), fl("call")), [t]);
      let n, a = [t];
      return r === !0 ? n = "toConsumableArray" : typeof r == "number" ? (a.push(_ge(r)), n = "slicedToArray") : n = "toArray", s && (a.unshift(
      this.hub.addHelper(n)), n = "maybeArrayLike"), jF(this.hub.addHelper(n), a);
    }
    hasLabel(t) {
      return !!this.getLabel(t);
    }
    getLabel(t) {
      return this.labels.get(t);
    }
    registerLabel(t) {
      this.labels.set(t.node.label.name, t);
    }
    registerDeclaration(t) {
      if (t.isLabeledStatement())
        this.registerLabel(t);
      else if (t.isFunctionDeclaration())
        this.registerBinding("hoisted", t.get("id"), t);
      else if (t.isVariableDeclaration()) {
        let r = t.get("declarations"), {
          kind: s
        } = t.node;
        for (let n of r)
          this.registerBinding(s === "using" || s === "await using" ? "const" : s, n);
      } else if (t.isClassDeclaration()) {
        if (t.node.declare) return;
        this.registerBinding("let", t);
      } else if (t.isImportDeclaration()) {
        let r = t.node.importKind === "type" || t.node.importKind === "typeof", s = t.get("specifiers");
        for (let n of s) {
          let a = r || n.isImportSpecifier() && (n.node.importKind === "type" || n.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", n);
        }
      } else if (t.isExportDeclaration()) {
        let r = t.get("declaration");
        (r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) && this.registerDeclaration(r);
      } else
        this.registerBinding("unknown", t);
    }
    buildUndefinedNode() {
      return qge();
    }
    registerConstantViolation(t) {
      let r = t.getBindingIdentifiers();
      for (let n of Object.keys(r)) {
        var s;
        (s = this.getBinding(n)) == null || s.reassign(t);
      }
    }
    registerBinding(t, r, s = r) {
      if (!t) throw new ReferenceError("no `kind`");
      if (r.isVariableDeclaration()) {
        let o = r.get("declarations");
        for (let l of o)
          this.registerBinding(t, l);
        return;
      }
      let n = this.getProgramParent(), a = r.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        n.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, t, o, l);
          }
          u ? this.registerConstantViolation(s) : this.bindings[o] = new age.default({
            identifier: l,
            scope: this,
            path: s,
            kind: t
          });
        }
      }
    }
    addGlobal(t) {
      this.globals[t.name] = t;
    }
    hasUid(t) {
      let r = this;
      do
        if (r.uids[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasGlobal(t) {
      let r = this;
      do
        if (r.globals[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasReference(t) {
      return !!this.getProgramParent().references[t];
    }
    isPure(t, r) {
      if (Za(t)) {
        let o = this.getBinding(t.name);
        return o ? r ? o.constant : !0 : !1;
      } else {
        if (VF(t) || Bge(t) || HF(t) || Mge(t))
          return !0;
        if (pge(t)) {
          var s;
          return t.superClass && !this.isPure(t.superClass, r) || ((s = t.decorators) == null ? void 0 : s.length) > 0 ? !1 : this.isPure(t.
          body, r);
        } else if (dge(t)) {
          for (let o of t.body)
            if (!this.isPure(o, r)) return !1;
          return !0;
        } else {
          if (fge(t))
            return this.isPure(t.left, r) && this.isPure(t.right, r);
          if ($F(t) || Fge(t)) {
            for (let o of t.elements)
              if (o !== null && !this.isPure(o, r)) return !1;
            return !0;
          } else if (Tge(t) || kge(t)) {
            for (let o of t.properties)
              if (!this.isPure(o, r)) return !1;
            return !0;
          } else if (Ege(t)) {
            var n;
            return !(t.computed && !this.isPure(t.key, r) || ((n = t.decorators) == null ? void 0 : n.length) > 0);
          } else if (xge(t)) {
            var a;
            return !(t.computed && !this.isPure(t.key, r) || ((a = t.decorators) == null ? void 0 : a.length) > 0 || (Lge(t) || t.static) &&
            t.value !== null && !this.isPure(t.value, r));
          } else {
            if (Dge(t))
              return this.isPure(t.argument, r);
            if (YF(t)) {
              for (let o of t.expressions)
                if (!this.isPure(o, r)) return !1;
              return !0;
            } else return wge(t) ? WF(t.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(t.quasi, r) : bge(t) ? !t.computed && Za(t.object) && t.object.name === "Symbol" && Za(t.property) && t.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : UF(t) ? WF(t.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && t.arguments.length === 1 && lge.isStringLiteral(t.arguments[0]) : Pge(t);
          }
        }
      }
    }
    setData(t, r) {
      return this.data[t] = r;
    }
    getData(t) {
      let r = this;
      do {
        let s = r.data[t];
        if (s != null) return s;
      } while (r = r.parent);
    }
    removeData(t) {
      let r = this;
      do
        r.data[t] != null && (r.data[t] = null);
      while (r = r.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let t = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.
      create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      let r = this.getProgramParent();
      if (r.crawling) return;
      let s = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, t.type !== "Program" && (0, uge.isExplodedVisitor)(hd)) {
        for (let a of hd.enter)
          a.call(s, t, s);
        let n = hd[t.type];
        if (n)
          for (let a of n.enter)
            a.call(s, t, s);
      }
      t.traverse(hd, s), this.crawling = !1;
      for (let n of s.assignments) {
        let a = n.getBindingIdentifiers();
        for (let o of Object.keys(a))
          n.scope.getBinding(o) || r.addGlobal(a[o]);
        n.scope.registerConstantViolation(n);
      }
      for (let n of s.references) {
        let a = n.scope.getBinding(n.node.name);
        a ? a.reference(n) : r.addGlobal(n.node);
      }
      for (let n of s.constantViolations)
        n.scope.registerConstantViolation(n);
    }
    push(t) {
      let r = this.path;
      r.isPattern() ? r = this.getPatternParent().path : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path), r.isSwitchStatement() &&
      (r = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: s,
        unique: n,
        kind: a = "var",
        id: o
      } = t;
      if (!s && !n && (a === "var" || a === "let") && r.isFunction() && !r.node.name && UF(r.parent, {
        callee: r.node
      }) && r.parent.arguments.length <= r.node.params.length && Za(o)) {
        r.pushContainer("params", o), r.scope.registerBinding("param", r.get("params")[r.node.params.length - 1]);
        return;
      }
      (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), r = r.get("body"));
      let l = t._blockHoist == null ? 2 : t._blockHoist, u = `declaration:${a}:${l}`, c = !n && r.getData(u);
      if (!c) {
        let d = Nge(a, []);
        d._blockHoist = l, [c] = r.unshiftContainer("body", [d]), n || r.setData(u, c);
      }
      let f = Rge(o, s), p = c.node.declarations.push(f);
      r.scope.registerBinding(a, c.get("declarations")[p - 1]);
    }
    getProgramParent() {
      let t = this;
      do
        if (t.path.isProgram())
          return t;
      while (t = t.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let t = this;
      do
        if (t.path.isFunctionParent())
          return t;
      while (t = t.parent);
      return null;
    }
    getBlockParent() {
      let t = this;
      do
        if (t.path.isBlockParent())
          return t;
      while (t = t.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let t = this;
      do
        if (!t.path.isPattern())
          return t.getBlockParent();
      while (t = t.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let t = /* @__PURE__ */ Object.create(null), r = this;
      do {
        for (let s of Object.keys(r.bindings))
          s in t || (t[s] = r.bindings[s]);
        r = r.parent;
      } while (r);
      return t;
    }
    getAllBindingsOfKind(...t) {
      let r = /* @__PURE__ */ Object.create(null);
      for (let s of t) {
        let n = this;
        do {
          for (let a of Object.keys(n.bindings)) {
            let o = n.bindings[a];
            o.kind === s && (r[a] = o);
          }
          n = n.parent;
        } while (n);
      }
      return r;
    }
    bindingIdentifierEquals(t, r) {
      return this.getBindingIdentifier(t) === r;
    }
    getBinding(t) {
      let r = this, s;
      do {
        let a = r.getOwnBinding(t);
        if (a) {
          var n;
          if (!((n = s) != null && n.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && t === "arguments" && r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
        s = r.path;
      } while (r = r.parent);
    }
    getOwnBinding(t) {
      return this.bindings[t];
    }
    getBindingIdentifier(t) {
      var r;
      return (r = this.getBinding(t)) == null ? void 0 : r.identifier;
    }
    getOwnBindingIdentifier(t) {
      let r = this.bindings[t];
      return r?.identifier;
    }
    hasOwnBinding(t) {
      return !!this.getOwnBinding(t);
    }
    hasBinding(t, r) {
      var s, n, a;
      return t ? !!(this.hasOwnBinding(t) || (typeof r == "boolean" && (r = {
        noGlobals: r
      }), this.parentHasBinding(t, r)) || !((s = r) != null && s.noUids) && this.hasUid(t) || !((n = r) != null && n.noGlobals) && e.globals.
      includes(t) || !((a = r) != null && a.noGlobals) && e.contextVariables.includes(t)) : !1;
    }
    parentHasBinding(t, r) {
      var s;
      return (s = this.parent) == null ? void 0 : s.hasBinding(t, r);
    }
    moveBindingTo(t, r) {
      let s = this.getBinding(t);
      s && (s.scope.removeOwnBinding(t), s.scope = r, r.bindings[t] = s);
    }
    removeOwnBinding(t) {
      delete this.bindings[t];
    }
    removeBinding(t) {
      var r;
      (r = this.getBinding(t)) == null || r.scope.removeOwnBinding(t);
      let s = this;
      do
        s.uids[t] && (s.uids[t] = !1);
      while (s = s.parent);
    }
  };
  md.default = dc;
  dc.globals = Object.keys(oge.builtin);
  dc.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
});

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var zF = y((yd, XF) => {
  (function(e, t) {
    typeof yd == "object" && typeof XF < "u" ? t(yd) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.setArray = {}));
  })(yd, function(e) {
    "use strict";
    class t {
      static {
        i(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function r(l) {
      return l;
    }
    i(r, "cast");
    function s(l, u) {
      return l._indexes[u];
    }
    i(s, "get");
    function n(l, u) {
      let c = s(l, u);
      if (c !== void 0)
        return c;
      let { array: f, _indexes: p } = l, d = f.push(u);
      return p[u] = d - 1;
    }
    i(n, "put");
    function a(l) {
      let { array: u, _indexes: c } = l;
      if (u.length === 0)
        return;
      let f = u.pop();
      c[f] = void 0;
    }
    i(a, "pop");
    function o(l, u) {
      let c = s(l, u);
      if (c === void 0)
        return;
      let { array: f, _indexes: p } = l;
      for (let d = c + 1; d < f.length; d++) {
        let m = f[d];
        f[d - 1] = m, p[m]--;
      }
      p[u] = void 0, f.pop();
    }
    i(o, "remove"), e.SetArray = t, e.get = s, e.pop = a, e.put = n, e.remove = o, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var Tv = y((gd, JF) => {
  (function(e, t) {
    typeof gd == "object" && typeof JF < "u" ? t(gd) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, t(e.sourcemapCodec = {}));
  })(gd, function(e) {
    "use strict";
    let s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(64), a = new Uint8Array(128);
    for (let h = 0; h < s.length; h++) {
      let g = s.charCodeAt(h);
      n[h] = g, a[g] = h;
    }
    let o = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(h) {
        return Buffer.from(h.buffer, h.byteOffset, h.byteLength).toString();
      }
    } : {
      decode(h) {
        let g = "";
        for (let E = 0; E < h.length; E++)
          g += String.fromCharCode(h[E]);
        return g;
      }
    };
    function l(h) {
      let g = new Int32Array(5), E = [], D = 0;
      do {
        let C = u(h, D), N = [], I = !0, M = 0;
        g[0] = 0;
        for (let q = D; q < C; q++) {
          let V;
          q = c(h, q, g, 0);
          let W = g[0];
          W < M && (I = !1), M = W, f(h, q, C) ? (q = c(h, q, g, 1), q = c(h, q, g, 2), q = c(h, q, g, 3), f(h, q, C) ? (q = c(h, q, g, 4), V =
          [W, g[1], g[2], g[3], g[4]]) : V = [W, g[1], g[2], g[3]]) : V = [W], N.push(V);
        }
        I || p(N), E.push(N), D = C + 1;
      } while (D <= h.length);
      return E;
    }
    i(l, "decode");
    function u(h, g) {
      let E = h.indexOf(";", g);
      return E === -1 ? h.length : E;
    }
    i(u, "indexOf");
    function c(h, g, E, D) {
      let C = 0, N = 0, I = 0;
      do {
        let q = h.charCodeAt(g++);
        I = a[q], C |= (I & 31) << N, N += 5;
      } while (I & 32);
      let M = C & 1;
      return C >>>= 1, M && (C = -2147483648 | -C), E[D] += C, g;
    }
    i(c, "decodeInteger");
    function f(h, g, E) {
      return g >= E ? !1 : h.charCodeAt(g) !== 44;
    }
    i(f, "hasMoreVlq");
    function p(h) {
      h.sort(d);
    }
    i(p, "sort");
    function d(h, g) {
      return h[0] - g[0];
    }
    i(d, "sortComparator");
    function m(h) {
      let g = new Int32Array(5), E = 1024 * 16, D = E - 36, C = new Uint8Array(E), N = C.subarray(0, D), I = 0, M = "";
      for (let q = 0; q < h.length; q++) {
        let V = h[q];
        if (q > 0 && (I === E && (M += o.decode(C), I = 0), C[I++] = 59), V.length !== 0) {
          g[0] = 0;
          for (let W = 0; W < V.length; W++) {
            let Y = V[W];
            I > D && (M += o.decode(N), C.copyWithin(0, D, I), I -= D), W > 0 && (C[I++] = 44), I = b(C, I, g, Y, 0), Y.length !== 1 && (I =
            b(C, I, g, Y, 1), I = b(C, I, g, Y, 2), I = b(C, I, g, Y, 3), Y.length !== 4 && (I = b(C, I, g, Y, 4)));
          }
        }
      }
      return M + o.decode(C.subarray(0, I));
    }
    i(m, "encode");
    function b(h, g, E, D, C) {
      let N = D[C], I = N - E[C];
      E[C] = N, I = I < 0 ? -I << 1 | 1 : I << 1;
      do {
        let M = I & 31;
        I >>>= 5, I > 0 && (M |= 32), h[g++] = n[M];
      } while (I > 0);
      return g;
    }
    i(b, "encodeInteger"), e.decode = l, e.encode = m, Object.defineProperty(e, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var QF = y((xv, Pv) => {
  (function(e, t) {
    typeof xv == "object" && typeof Pv < "u" ? Pv.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, e.resolveURI = t());
  })(xv, function() {
    "use strict";
    let e = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var s;
    (function(E) {
      E[E.Empty = 1] = "Empty", E[E.Hash = 2] = "Hash", E[E.Query = 3] = "Query", E[E.RelativePath = 4] = "RelativePath", E[E.AbsolutePath =
      5] = "AbsolutePath", E[E.SchemeRelative = 6] = "SchemeRelative", E[E.Absolute = 7] = "Absolute";
    })(s || (s = {}));
    function n(E) {
      return e.test(E);
    }
    i(n, "isAbsoluteUrl");
    function a(E) {
      return E.startsWith("//");
    }
    i(a, "isSchemeRelativeUrl");
    function o(E) {
      return E.startsWith("/");
    }
    i(o, "isAbsolutePath");
    function l(E) {
      return E.startsWith("file:");
    }
    i(l, "isFileUrl");
    function u(E) {
      return /^[.?#]/.test(E);
    }
    i(u, "isRelative");
    function c(E) {
      let D = t.exec(E);
      return p(D[1], D[2] || "", D[3], D[4] || "", D[5] || "/", D[6] || "", D[7] || "");
    }
    i(c, "parseAbsoluteUrl");
    function f(E) {
      let D = r.exec(E), C = D[2];
      return p("file:", "", D[1] || "", "", o(C) ? C : "/" + C, D[3] || "", D[4] || "");
    }
    i(f, "parseFileUrl");
    function p(E, D, C, N, I, M, q) {
      return {
        scheme: E,
        user: D,
        host: C,
        port: N,
        path: I,
        query: M,
        hash: q,
        type: s.Absolute
      };
    }
    i(p, "makeUrl");
    function d(E) {
      if (a(E)) {
        let C = c("http:" + E);
        return C.scheme = "", C.type = s.SchemeRelative, C;
      }
      if (o(E)) {
        let C = c("http://foo.com" + E);
        return C.scheme = "", C.host = "", C.type = s.AbsolutePath, C;
      }
      if (l(E))
        return f(E);
      if (n(E))
        return c(E);
      let D = c("http://foo.com/" + E);
      return D.scheme = "", D.host = "", D.type = E ? E.startsWith("?") ? s.Query : E.startsWith("#") ? s.Hash : s.RelativePath : s.Empty, D;
    }
    i(d, "parseUrl");
    function m(E) {
      if (E.endsWith("/.."))
        return E;
      let D = E.lastIndexOf("/");
      return E.slice(0, D + 1);
    }
    i(m, "stripPathFilename");
    function b(E, D) {
      h(D, D.type), E.path === "/" ? E.path = D.path : E.path = m(D.path) + E.path;
    }
    i(b, "mergePaths");
    function h(E, D) {
      let C = D <= s.RelativePath, N = E.path.split("/"), I = 1, M = 0, q = !1;
      for (let W = 1; W < N.length; W++) {
        let Y = N[W];
        if (!Y) {
          q = !0;
          continue;
        }
        if (q = !1, Y !== ".") {
          if (Y === "..") {
            M ? (q = !0, M--, I--) : C && (N[I++] = Y);
            continue;
          }
          N[I++] = Y, M++;
        }
      }
      let V = "";
      for (let W = 1; W < I; W++)
        V += "/" + N[W];
      (!V || q && !V.endsWith("/..")) && (V += "/"), E.path = V;
    }
    i(h, "normalizePath");
    function g(E, D) {
      if (!E && !D)
        return "";
      let C = d(E), N = C.type;
      if (D && N !== s.Absolute) {
        let M = d(D), q = M.type;
        switch (N) {
          case s.Empty:
            C.hash = M.hash;
          case s.Hash:
            C.query = M.query;
          case s.Query:
          case s.RelativePath:
            b(C, M);
          case s.AbsolutePath:
            C.user = M.user, C.host = M.host, C.port = M.port;
          case s.SchemeRelative:
            C.scheme = M.scheme;
        }
        q > N && (N = q);
      }
      h(C, N);
      let I = C.query + C.hash;
      switch (N) {
        case s.Hash:
        case s.Query:
          return I;
        case s.RelativePath: {
          let M = C.path.slice(1);
          return M ? u(D || E) && !u(M) ? "./" + M + I : M + I : I || ".";
        }
        case s.AbsolutePath:
          return C.path + I;
        default:
          return C.scheme + "//" + C.user + C.host + C.port + C.path + I;
      }
    }
    return i(g, "resolve"), g;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var Ed = y((bd, ZF) => {
  (function(e, t) {
    typeof bd == "object" && typeof ZF < "u" ? t(bd, Tv(), QF()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.traceMapping = {}, e.sourcemapCodec,
    e.resolveURI));
  })(bd, function(e, t, r) {
    "use strict";
    function s(U, z) {
      return z && !z.endsWith("/") && (z += "/"), r(U, z);
    }
    i(s, "resolve");
    function n(U) {
      if (!U)
        return "";
      let z = U.lastIndexOf("/");
      return U.slice(0, z + 1);
    }
    i(n, "stripFilename");
    let a = 0, o = 1, l = 2, u = 3, c = 4, f = 1, p = 2;
    function d(U, z) {
      let J = m(U, 0);
      if (J === U.length)
        return U;
      z || (U = U.slice());
      for (let ae = J; ae < U.length; ae = m(U, ae + 1))
        U[ae] = h(U[ae], z);
      return U;
    }
    i(d, "maybeSort");
    function m(U, z) {
      for (let J = z; J < U.length; J++)
        if (!b(U[J]))
          return J;
      return U.length;
    }
    i(m, "nextUnsortedSegmentLine");
    function b(U) {
      for (let z = 1; z < U.length; z++)
        if (U[z][a] < U[z - 1][a])
          return !1;
      return !0;
    }
    i(b, "isSorted");
    function h(U, z) {
      return z || (U = U.slice()), U.sort(g);
    }
    i(h, "sortSegments");
    function g(U, z) {
      return U[a] - z[a];
    }
    i(g, "sortComparator");
    let E = !1;
    function D(U, z, J, ae) {
      for (; J <= ae; ) {
        let Re = J + (ae - J >> 1), ge = U[Re][a] - z;
        if (ge === 0)
          return E = !0, Re;
        ge < 0 ? J = Re + 1 : ae = Re - 1;
      }
      return E = !1, J - 1;
    }
    i(D, "binarySearch");
    function C(U, z, J) {
      for (let ae = J + 1; ae < U.length && U[ae][a] === z; J = ae++)
        ;
      return J;
    }
    i(C, "upperBound");
    function N(U, z, J) {
      for (let ae = J - 1; ae >= 0 && U[ae][a] === z; J = ae--)
        ;
      return J;
    }
    i(N, "lowerBound");
    function I() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    i(I, "memoizedState");
    function M(U, z, J, ae) {
      let { lastKey: Re, lastNeedle: ge, lastIndex: Be } = J, Xe = 0, Fe = U.length - 1;
      if (ae === Re) {
        if (z === ge)
          return E = Be !== -1 && U[Be][a] === z, Be;
        z >= ge ? Xe = Be === -1 ? 0 : Be : Fe = Be;
      }
      return J.lastKey = ae, J.lastNeedle = z, J.lastIndex = D(U, z, Xe, Fe);
    }
    i(M, "memoizedBinarySearch");
    function q(U, z) {
      let J = z.map(W);
      for (let ae = 0; ae < U.length; ae++) {
        let Re = U[ae];
        for (let ge = 0; ge < Re.length; ge++) {
          let Be = Re[ge];
          if (Be.length === 1)
            continue;
          let Xe = Be[o], Fe = Be[l], ht = Be[u], Mt = J[Xe], ot = Mt[Fe] || (Mt[Fe] = []), mt = z[Xe], Vt = C(ot, ht, M(ot, ht, mt, Fe));
          mt.lastIndex = ++Vt, V(ot, Vt, [ht, ae, Be[a]]);
        }
      }
      return J;
    }
    i(q, "buildBySources");
    function V(U, z, J) {
      for (let ae = U.length; ae > z; ae--)
        U[ae] = U[ae - 1];
      U[z] = J;
    }
    i(V, "insert");
    function W() {
      return { __proto__: null };
    }
    i(W, "buildNullArray");
    let Y = /* @__PURE__ */ i(function(U, z) {
      let J = j(U);
      if (!("sections" in J))
        return new je(J, z);
      let ae = [], Re = [], ge = [], Be = [], Xe = [];
      ie(J, z, ae, Re, ge, Be, Xe, 0, 0, 1 / 0, 1 / 0);
      let Fe = {
        version: 3,
        file: J.file,
        names: Be,
        sources: Re,
        sourcesContent: ge,
        mappings: ae,
        ignoreList: Xe
      };
      return He(Fe);
    }, "AnyMap");
    function j(U) {
      return typeof U == "string" ? JSON.parse(U) : U;
    }
    i(j, "parse");
    function ie(U, z, J, ae, Re, ge, Be, Xe, Fe, ht, Mt) {
      let { sections: ot } = U;
      for (let mt = 0; mt < ot.length; mt++) {
        let { map: Vt, offset: Zt } = ot[mt], Ss = ht, Dn = Mt;
        if (mt + 1 < ot.length) {
          let $i = ot[mt + 1].offset;
          Ss = Math.min(ht, Xe + $i.line), Ss === ht ? Dn = Math.min(Mt, Fe + $i.column) : Ss < ht && (Dn = Fe + $i.column);
        }
        fe(Vt, z, J, ae, Re, ge, Be, Xe + Zt.line, Fe + Zt.column, Ss, Dn);
      }
    }
    i(ie, "recurse");
    function fe(U, z, J, ae, Re, ge, Be, Xe, Fe, ht, Mt) {
      let ot = j(U);
      if ("sections" in ot)
        return ie(...arguments);
      let mt = new je(ot, z), Vt = ae.length, Zt = ge.length, Ss = Bt(mt), { resolvedSources: Dn, sourcesContent: $i, ignoreList: jo } = mt;
      if (De(ae, Dn), De(ge, mt.names), $i)
        De(Re, $i);
      else
        for (let zr = 0; zr < Dn.length; zr++)
          Re.push(null);
      if (jo)
        for (let zr = 0; zr < jo.length; zr++)
          Be.push(jo[zr] + Vt);
      for (let zr = 0; zr < Ss.length; zr++) {
        let qo = Xe + zr;
        if (qo > ht)
          return;
        let uD = F(J, qo), VW = zr === 0 ? Fe : 0, cD = Ss[zr];
        for (let v0 = 0; v0 < cD.length; v0++) {
          let ja = cD[v0], np = VW + ja[a];
          if (qo === ht && np >= Mt)
            return;
          if (ja.length === 1) {
            uD.push([np]);
            continue;
          }
          let fD = Vt + ja[o], pD = ja[l], dD = ja[u];
          uD.push(ja.length === 4 ? [np, fD, pD, dD] : [np, fD, pD, dD, Zt + ja[c]]);
        }
      }
    }
    i(fe, "addSection");
    function De(U, z) {
      for (let J = 0; J < z.length; J++)
        U.push(z[J]);
    }
    i(De, "append");
    function F(U, z) {
      for (let J = U.length; J <= z; J++)
        U[J] = [];
      return U[z];
    }
    i(F, "getLine");
    let L = "`line` must be greater than 0 (lines start at line 1)", re = "`column` must be greater than or equal to 0 (columns start at col\
umn 0)", se = -1, be = 1;
    class je {
      static {
        i(this, "TraceMap");
      }
      constructor(z, J) {
        let ae = typeof z == "string";
        if (!ae && z._decodedMemo)
          return z;
        let Re = ae ? JSON.parse(z) : z, { version: ge, file: Be, names: Xe, sourceRoot: Fe, sources: ht, sourcesContent: Mt } = Re;
        this.version = ge, this.file = Be, this.names = Xe || [], this.sourceRoot = Fe, this.sources = ht, this.sourcesContent = Mt, this.ignoreList =
        Re.ignoreList || Re.x_google_ignoreList || void 0;
        let ot = s(Fe || "", n(J));
        this.resolvedSources = ht.map((Vt) => s(Vt || "", ot));
        let { mappings: mt } = Re;
        typeof mt == "string" ? (this._encoded = mt, this._decoded = void 0) : (this._encoded = void 0, this._decoded = d(mt, ae)), this._decodedMemo =
        I(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function Pe(U) {
      return U;
    }
    i(Pe, "cast");
    function Rt(U) {
      var z, J;
      return (z = (J = U)._encoded) !== null && z !== void 0 ? z : J._encoded = t.encode(U._decoded);
    }
    i(Rt, "encodedMappings");
    function Bt(U) {
      var z;
      return (z = U)._decoded || (z._decoded = t.decode(U._encoded));
    }
    i(Bt, "decodedMappings");
    function qt(U, z, J) {
      let ae = Bt(U);
      if (z >= ae.length)
        return null;
      let Re = ae[z], ge = ye(Re, U._decodedMemo, z, J, be);
      return ge === -1 ? null : Re[ge];
    }
    i(qt, "traceSegment");
    function Ie(U, z) {
      let { line: J, column: ae, bias: Re } = z;
      if (J--, J < 0)
        throw new Error(L);
      if (ae < 0)
        throw new Error(re);
      let ge = Bt(U);
      if (J >= ge.length)
        return sn(null, null, null, null);
      let Be = ge[J], Xe = ye(Be, U._decodedMemo, J, ae, Re || be);
      if (Xe === -1)
        return sn(null, null, null, null);
      let Fe = Be[Xe];
      if (Fe.length === 1)
        return sn(null, null, null, null);
      let { names: ht, resolvedSources: Mt } = U;
      return sn(Mt[Fe[o]], Fe[l] + 1, Fe[u], Fe.length === 5 ? ht[Fe[c]] : null);
    }
    i(Ie, "originalPositionFor");
    function _e(U, z) {
      let { source: J, line: ae, column: Re, bias: ge } = z;
      return Ge(U, J, ae, Re, ge || be, !1);
    }
    i(_e, "generatedPositionFor");
    function Jt(U, z) {
      let { source: J, line: ae, column: Re, bias: ge } = z;
      return Ge(U, J, ae, Re, ge || se, !0);
    }
    i(Jt, "allGeneratedPositionsFor");
    function Sr(U, z) {
      let J = Bt(U), { names: ae, resolvedSources: Re } = U;
      for (let ge = 0; ge < J.length; ge++) {
        let Be = J[ge];
        for (let Xe = 0; Xe < Be.length; Xe++) {
          let Fe = Be[Xe], ht = ge + 1, Mt = Fe[0], ot = null, mt = null, Vt = null, Zt = null;
          Fe.length !== 1 && (ot = Re[Fe[1]], mt = Fe[2] + 1, Vt = Fe[3]), Fe.length === 5 && (Zt = ae[Fe[4]]), z({
            generatedLine: ht,
            generatedColumn: Mt,
            source: ot,
            originalLine: mt,
            originalColumn: Vt,
            name: Zt
          });
        }
      }
    }
    i(Sr, "eachMapping");
    function pe(U, z) {
      let { sources: J, resolvedSources: ae } = U, Re = J.indexOf(z);
      return Re === -1 && (Re = ae.indexOf(z)), Re;
    }
    i(pe, "sourceIndex");
    function ut(U, z) {
      let { sourcesContent: J } = U;
      if (J == null)
        return null;
      let ae = pe(U, z);
      return ae === -1 ? null : J[ae];
    }
    i(ut, "sourceContentFor");
    function oe(U, z) {
      let { ignoreList: J } = U;
      if (J == null)
        return !1;
      let ae = pe(U, z);
      return ae === -1 ? !1 : J.includes(ae);
    }
    i(oe, "isIgnored");
    function He(U, z) {
      let J = new je(kt(U, []), z);
      return J._decoded = U.mappings, J;
    }
    i(He, "presortedDecodedMap");
    function Pt(U) {
      return kt(U, Bt(U));
    }
    i(Pt, "decodedMap");
    function Qt(U) {
      return kt(U, Rt(U));
    }
    i(Qt, "encodedMap");
    function kt(U, z) {
      return {
        version: U.version,
        file: U.file,
        names: U.names,
        sourceRoot: U.sourceRoot,
        sources: U.sources,
        sourcesContent: U.sourcesContent,
        mappings: z,
        ignoreList: U.ignoreList || U.x_google_ignoreList
      };
    }
    i(kt, "clone");
    function sn(U, z, J, ae) {
      return { source: U, line: z, column: J, name: ae };
    }
    i(sn, "OMapping");
    function Xr(U, z) {
      return { line: U, column: z };
    }
    i(Xr, "GMapping");
    function ye(U, z, J, ae, Re) {
      let ge = M(U, ae, z, J);
      return E ? ge = (Re === se ? C : N)(U, ae, ge) : Re === se && ge++, ge === -1 || ge === U.length ? -1 : ge;
    }
    i(ye, "traceSegmentInternal");
    function ce(U, z, J, ae, Re) {
      let ge = ye(U, z, J, ae, be);
      if (!E && Re === se && ge++, ge === -1 || ge === U.length)
        return [];
      let Be = E ? ae : U[ge][a];
      E || (ge = N(U, Be, ge));
      let Xe = C(U, Be, ge), Fe = [];
      for (; ge <= Xe; ge++) {
        let ht = U[ge];
        Fe.push(Xr(ht[f] + 1, ht[p]));
      }
      return Fe;
    }
    i(ce, "sliceGeneratedPositions");
    function Ge(U, z, J, ae, Re, ge) {
      var Be;
      if (J--, J < 0)
        throw new Error(L);
      if (ae < 0)
        throw new Error(re);
      let { sources: Xe, resolvedSources: Fe } = U, ht = Xe.indexOf(z);
      if (ht === -1 && (ht = Fe.indexOf(z)), ht === -1)
        return ge ? [] : Xr(null, null);
      let ot = ((Be = U)._bySources || (Be._bySources = q(Bt(U), U._bySourceMemos = Xe.map(I))))[ht][J];
      if (ot == null)
        return ge ? [] : Xr(null, null);
      let mt = U._bySourceMemos[ht];
      if (ge)
        return ce(ot, mt, J, ae, Re);
      let Vt = ye(ot, mt, J, ae, Re);
      if (Vt === -1)
        return Xr(null, null);
      let Zt = ot[Vt];
      return Xr(Zt[f] + 1, Zt[p]);
    }
    i(Ge, "generatedPosition"), e.AnyMap = Y, e.GREATEST_LOWER_BOUND = be, e.LEAST_UPPER_BOUND = se, e.TraceMap = je, e.allGeneratedPositionsFor =
    Jt, e.decodedMap = Pt, e.decodedMappings = Bt, e.eachMapping = Sr, e.encodedMap = Qt, e.encodedMappings = Rt, e.generatedPositionFor = _e,
    e.isIgnored = oe, e.originalPositionFor = Ie, e.presortedDecodedMap = He, e.sourceContentFor = ut, e.traceSegment = qt;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var Av = y((vd, eL) => {
  (function(e, t) {
    typeof vd == "object" && typeof eL < "u" ? t(vd, zF(), Tv(), Ed()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], t) : (e = typeof globalThis < "u" ? globalThis : e || self,
    t(e.genMapping = {}, e.setArray, e.sourcemapCodec, e.traceMapping));
  })(vd, function(e, t, r, s) {
    "use strict";
    class f {
      static {
        i(this, "GenMapping");
      }
      constructor({ file: L, sourceRoot: re } = {}) {
        this._names = new t.SetArray(), this._sources = new t.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = L, this.
        sourceRoot = re, this._ignoreList = new t.SetArray();
      }
    }
    function p(F) {
      return F;
    }
    i(p, "cast");
    function d(F, L, re, se, be, je, Pe, Rt) {
      return M(!1, F, L, re, se, be, je, Pe, Rt);
    }
    i(d, "addSegment");
    function m(F, L) {
      return De(!1, F, L);
    }
    i(m, "addMapping");
    let b = /* @__PURE__ */ i((F, L, re, se, be, je, Pe, Rt) => M(!0, F, L, re, se, be, je, Pe, Rt), "maybeAddSegment"), h = /* @__PURE__ */ i(
    (F, L) => De(!0, F, L), "maybeAddMapping");
    function g(F, L, re) {
      let { _sources: se, _sourcesContent: be } = F, je = t.put(se, L);
      be[je] = re;
    }
    i(g, "setSourceContent");
    function E(F, L, re = !0) {
      let { _sources: se, _sourcesContent: be, _ignoreList: je } = F, Pe = t.put(se, L);
      Pe === be.length && (be[Pe] = null), re ? t.put(je, Pe) : t.remove(je, Pe);
    }
    i(E, "setIgnore");
    function D(F) {
      let { _mappings: L, _sources: re, _sourcesContent: se, _names: be, _ignoreList: je } = F;
      return Y(L), {
        version: 3,
        file: F.file || void 0,
        names: be.array,
        sourceRoot: F.sourceRoot || void 0,
        sources: re.array,
        sourcesContent: se,
        mappings: L,
        ignoreList: je.array
      };
    }
    i(D, "toDecodedMap");
    function C(F) {
      let L = D(F);
      return Object.assign(Object.assign({}, L), { mappings: r.encode(L.mappings) });
    }
    i(C, "toEncodedMap");
    function N(F) {
      let L = new s.TraceMap(F), re = new f({ file: L.file, sourceRoot: L.sourceRoot });
      return j(re._names, L.names), j(re._sources, L.sources), re._sourcesContent = L.sourcesContent || L.sources.map(() => null), re._mappings =
      s.decodedMappings(L), L.ignoreList && j(re._ignoreList, L.ignoreList), re;
    }
    i(N, "fromMap");
    function I(F) {
      let L = [], { _mappings: re, _sources: se, _names: be } = F;
      for (let je = 0; je < re.length; je++) {
        let Pe = re[je];
        for (let Rt = 0; Rt < Pe.length; Rt++) {
          let Bt = Pe[Rt], qt = { line: je + 1, column: Bt[0] }, Ie, _e, Jt;
          Bt.length !== 1 && (Ie = se.array[Bt[1]], _e = { line: Bt[2] + 1, column: Bt[3] }, Bt.length === 5 && (Jt = be.array[Bt[4]])), L.push(
          { generated: qt, source: Ie, original: _e, name: Jt });
        }
      }
      return L;
    }
    i(I, "allMappings");
    function M(F, L, re, se, be, je, Pe, Rt, Bt) {
      let { _mappings: qt, _sources: Ie, _sourcesContent: _e, _names: Jt } = L, Sr = q(qt, re), pe = V(Sr, se);
      if (!be)
        return F && ie(Sr, pe) ? void 0 : W(Sr, pe, [se]);
      let ut = t.put(Ie, be), oe = Rt ? t.put(Jt, Rt) : -1;
      if (ut === _e.length && (_e[ut] = Bt ?? null), !(F && fe(Sr, pe, ut, je, Pe, oe)))
        return W(Sr, pe, Rt ? [se, ut, je, Pe, oe] : [se, ut, je, Pe]);
    }
    i(M, "addSegmentInternal");
    function q(F, L) {
      for (let re = F.length; re <= L; re++)
        F[re] = [];
      return F[L];
    }
    i(q, "getLine");
    function V(F, L) {
      let re = F.length;
      for (let se = re - 1; se >= 0; re = se--) {
        let be = F[se];
        if (L >= be[0])
          break;
      }
      return re;
    }
    i(V, "getColumnIndex");
    function W(F, L, re) {
      for (let se = F.length; se > L; se--)
        F[se] = F[se - 1];
      F[L] = re;
    }
    i(W, "insert");
    function Y(F) {
      let { length: L } = F, re = L;
      for (let se = re - 1; se >= 0 && !(F[se].length > 0); re = se, se--)
        ;
      re < L && (F.length = re);
    }
    i(Y, "removeEmptyFinalLines");
    function j(F, L) {
      for (let re = 0; re < L.length; re++)
        t.put(F, L[re]);
    }
    i(j, "putAll");
    function ie(F, L) {
      return L === 0 ? !0 : F[L - 1].length === 1;
    }
    i(ie, "skipSourceless");
    function fe(F, L, re, se, be, je) {
      if (L === 0)
        return !1;
      let Pe = F[L - 1];
      return Pe.length === 1 ? !1 : re === Pe[1] && se === Pe[2] && be === Pe[3] && je === (Pe.length === 5 ? Pe[4] : -1);
    }
    i(fe, "skipSource");
    function De(F, L, re) {
      let { generated: se, source: be, original: je, name: Pe, content: Rt } = re;
      return be ? M(F, L, se.line - 1, se.column, be, je.line - 1, je.column, Pe, Rt) : M(F, L, se.line - 1, se.column, null, null, null, null,
      null);
    }
    i(De, "addMappingInternal"), e.GenMapping = f, e.addMapping = m, e.addSegment = d, e.allMappings = I, e.fromMap = N, e.maybeAddMapping =
    h, e.maybeAddSegment = b, e.setIgnore = E, e.setSourceContent = g, e.toDecodedMap = D, e.toEncodedMap = C, Object.defineProperty(e, "__e\
sModule", { value: !0 });
  });
});

// ../node_modules/@babel/generator/lib/source-map.js
var tL = y((Sd) => {
  "use strict";
  Object.defineProperty(Sd, "__esModule", {
    value: !0
  });
  Sd.default = void 0;
  var na = Av(), Cv = Ed(), wv = class {
    static {
      i(this, "SourceMap");
    }
    constructor(t, r) {
      var s;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let n = this._map = new na.GenMapping({
        sourceRoot: t.sourceRoot
      });
      if (this._sourceFileName = (s = t.sourceFileName) == null ? void 0 : s.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
        this._inputMap = new Cv.TraceMap(t.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, na.setSourceContent)(n, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !t.inputSourceMap)
        (0, na.setSourceContent)(n, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, na.setSourceContent)(n, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, na.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, na.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, na.allMappings)(this._map));
    }
    mark(t, r, s, n, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, Cv.originalPositionFor)(this._inputMap, {
            line: r,
            column: s
          }), !u.name && a) {
            let c = (0, Cv.originalPositionFor)(this._inputMap, a);
            c.name && (n = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: s
          };
      (0, na.maybeAddMapping)(this._map, {
        name: n,
        generated: t,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  Sd.default = wv;
});

// ../node_modules/@babel/generator/lib/buffer.js
var rL = y((Td) => {
  "use strict";
  Object.defineProperty(Td, "__esModule", {
    value: !0
  });
  Td.default = void 0;
  var Dv = class {
    static {
      i(this, "Buffer");
    }
    constructor(t, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = t, this._indentChar = r;
      for (let s = 0; s < 64; s++)
        this._fastIndentations.push(r.repeat(s));
      this._allocQueue();
    }
    _allocQueue() {
      let t = this._queue;
      for (let r = 0; r < 16; r++)
        t.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(t, r, s, n, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = t, l.repeat = r, l.line = s, l.column = n, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let t = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: t?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let s = t ? t.get() : null;
          return r.map = s, s;
        },
        set map(s) {
          Object.defineProperty(r, "map", {
            value: s,
            writable: !0
          });
        },
        get rawMappings() {
          let s = t?.getRawMappings();
          return r.rawMappings = s, s;
        },
        set rawMappings(s) {
          Object.defineProperty(r, "rawMappings", {
            value: s,
            writable: !0
          });
        }
      };
      return r;
    }
    append(t, r) {
      this._flush(), this._append(t, this._sourcePosition, r);
    }
    appendChar(t) {
      this._flush(), this._appendChar(t, 1, this._sourcePosition);
    }
    queue(t) {
      if (t === 10)
        for (; this._queueCursor !== 0; ) {
          let s = this._queue[this._queueCursor - 1].char;
          if (s !== 32 && s !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(t, 1, r.line, r.column, r.filename);
    }
    queueIndentation(t) {
      t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
    }
    _flush() {
      let t = this._queueCursor, r = this._queue;
      for (let s = 0; s < t; s++) {
        let n = r[s];
        this._appendChar(n.char, n.repeat, n);
      }
      this._queueCursor = 0;
    }
    _appendChar(t, r, s) {
      if (this._last = t, t === -1) {
        let n = this._fastIndentations[r];
        n !== void 0 ? this._str += n : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
      t !== 10 ? (this._mark(s.line, s.column, s.identifierName, s.identifierNamePos, s.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
    }
    _append(t, r, s) {
      let n = t.length, a = this._position;
      if (this._last = t.charCodeAt(n - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount =
      0) : this._str += t, !s && !this._map) {
        a.column += n;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = r, f = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let p = t.indexOf(`
`), d = 0;
      for (p !== 0 && this._mark(f, o, l, u, c); p !== -1; )
        a.line++, a.column = 0, d = p + 1, d < n && f !== void 0 && this._mark(++f, 0, null, null, c), p = t.indexOf(`
`, d);
      a.column += n - d;
    }
    _mark(t, r, s, n, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, t, r, s, n, a);
    }
    removeTrailingNewline() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let t = this._queueCursor;
      return t !== 0 ? this._queue[t - 1].char : this._last;
    }
    getNewlineCount() {
      let t = this._queueCursor, r = 0;
      if (t === 0) return this._last === 10 ? 1 : 0;
      for (let s = t - 1; s >= 0 && this._queue[s].char === 10; s--)
        r++;
      return r === t && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let t = this._queue, r = this._queueCursor;
      if (r !== 0)
        return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(t, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", t);
      let s = t.identifierName, n = this._sourcePosition;
      s && (this._canMarkIdName = !1, n.identifierName = s), r(), s && (this._canMarkIdName = !0, n.identifierName = void 0, n.identifierNamePos =
      void 0), this.source("end", t);
    }
    source(t, r) {
      this._map && this._normalizePosition(t, r, 0);
    }
    sourceWithOffset(t, r, s) {
      this._map && this._normalizePosition(t, r, s);
    }
    withSource(t, r, s) {
      this._map && this.source(t, r), s();
    }
    _normalizePosition(t, r, s) {
      let n = r[t], a = this._sourcePosition;
      n && (a.line = n.line, a.column = Math.max(n.column + s, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let t = this._queue, r = this._queueCursor, s = -1, n = 0;
      for (let a = 0; a < r; a++) {
        let o = t[a];
        o.char === 10 && (s = n), n += o.repeat;
      }
      return s === -1 ? this._position.column + n : n - 1 - s;
    }
    getCurrentLine() {
      let t = 0, r = this._queue;
      for (let s = 0; s < this._queueCursor; s++)
        r[s].char === 10 && t++;
      return this._position.line + t;
    }
  };
  Td.default = Dv;
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var oL = y((Pd) => {
  "use strict";
  Object.defineProperty(Pd, "__esModule", {
    value: !0
  });
  Pd.nodes = void 0;
  var Uge = Ne(), {
    FLIPPED_ALIAS_KEYS: Vge,
    isArrayExpression: Wge,
    isAssignmentExpression: nL,
    isBinary: iL,
    isBlockStatement: Hge,
    isCallExpression: aL,
    isFunction: hc,
    isIdentifier: xd,
    isLiteral: Gge,
    isMemberExpression: Iv,
    isObjectExpression: Kge,
    isOptionalCallExpression: Yge,
    isOptionalMemberExpression: Xge,
    isStringLiteral: zge
  } = Uge;
  function pl(e, t) {
    return e && (Iv(e) || Xge(e) ? (pl(e.object, t), e.computed && pl(e.property, t)) : iL(e) || nL(e) ? (pl(e.left, t), pl(e.right, t)) : aL(
    e) || Yge(e) ? (t.hasCall = !0, pl(e.callee, t)) : hc(e) ? t.hasFunction = !0 : xd(e) && (t.hasHelper = t.hasHelper || e.callee && di(e.
    callee))), t;
  }
  i(pl, "crawlInternal");
  function sL(e) {
    return pl(e, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  i(sL, "crawl");
  function di(e) {
    return e ? Iv(e) ? di(e.object) || di(e.property) : xd(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : aL(e) ? di(e.callee) :
    iL(e) || nL(e) ? xd(e.left) && di(e.left) || di(e.right) : !1 : !1;
  }
  i(di, "isHelper");
  function Jge(e) {
    return Gge(e) || Kge(e) || Wge(e) || xd(e) || Iv(e);
  }
  i(Jge, "isType");
  var eo = Pd.nodes = {
    AssignmentExpression(e) {
      let t = sL(e.right);
      if (t.hasCall && t.hasHelper || t.hasFunction)
        return t.hasFunction ? 3 : 2;
    },
    SwitchCase(e, t) {
      return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
    },
    LogicalExpression(e) {
      if (hc(e.left) || hc(e.right))
        return 2;
    },
    Literal(e) {
      if (zge(e) && e.value === "use strict")
        return 2;
    },
    CallExpression(e) {
      if (hc(e.callee) || di(e))
        return 3;
    },
    OptionalCallExpression(e) {
      if (hc(e.callee))
        return 3;
    },
    VariableDeclaration(e) {
      for (let t = 0; t < e.declarations.length; t++) {
        let r = e.declarations[t], s = di(r.id) && !Jge(r.init);
        if (!s && r.init) {
          let n = sL(r.init);
          s = di(r.init) && n.hasCall || n.hasFunction;
        }
        if (s)
          return 3;
      }
    },
    IfStatement(e) {
      if (Hge(e.consequent))
        return 3;
    }
  };
  eo.ObjectProperty = eo.ObjectTypeProperty = eo.ObjectMethod = function(e, t) {
    if (t.properties[0] === e)
      return 1;
  };
  eo.ObjectTypeCallProperty = function(e, t) {
    var r;
    if (t.callProperties[0] === e && !((r = t.properties) != null && r.length))
      return 1;
  };
  eo.ObjectTypeIndexer = function(e, t) {
    var r, s;
    if (t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((s = t.callProperties) != null && s.length))
      return 1;
  };
  eo.ObjectTypeInternalSlot = function(e, t) {
    var r, s, n;
    if (t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((s = t.callProperties) != null && s.length) && !((n = t.indexers) !=
    null && n.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  e, t]) {
    [e].concat(Vge[e] || []).forEach(function(r) {
      let s = t ? 3 : 0;
      eo[r] = () => s;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var pL = y((vt) => {
  "use strict";
  Object.defineProperty(vt, "__esModule", {
    value: !0
  });
  vt.ArrowFunctionExpression = Cbe;
  vt.AssignmentExpression = Dbe;
  vt.Binary = hbe;
  vt.BinaryExpression = Sbe;
  vt.ClassExpression = Pbe;
  vt.ConditionalExpression = _v;
  vt.DoExpression = dbe;
  vt.FunctionExpression = Abe;
  vt.FunctionTypeAnnotation = cbe;
  vt.Identifier = _be;
  vt.LogicalExpression = Ibe;
  vt.NullableTypeAnnotation = ube;
  vt.ObjectExpression = pbe;
  vt.OptionalIndexedAccessType = ybe;
  vt.OptionalCallExpression = vt.OptionalMemberExpression = wbe;
  vt.SequenceExpression = Tbe;
  vt.TSTypeAssertion = vt.TSSatisfiesExpression = vt.TSAsExpression = gbe;
  vt.TSInferType = Ebe;
  vt.TSInstantiationExpression = vbe;
  vt.TSIntersectionType = vt.TSUnionType = bbe;
  vt.UnaryLike = fL;
  vt.IntersectionTypeAnnotation = vt.UnionTypeAnnotation = mbe;
  vt.UpdateExpression = fbe;
  vt.AwaitExpression = vt.YieldExpression = xbe;
  var Qge = Ne(), {
    isArrayTypeAnnotation: Zge,
    isArrowFunctionExpression: ebe,
    isBinaryExpression: tbe,
    isCallExpression: rbe,
    isExportDeclaration: sbe,
    isForOfStatement: nbe,
    isIndexedAccessType: ibe,
    isMemberExpression: uL,
    isObjectPattern: abe,
    isOptionalMemberExpression: obe,
    isYieldExpression: lbe
  } = Qge, lL = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["\
!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function cL(e) {
    return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
  }
  i(cL, "isTSTypeExpression");
  var Ad = /* @__PURE__ */ i((e, t) => {
    let r = t.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
  }, "isClassExtendsClause"), mc = /* @__PURE__ */ i((e, t) => {
    let r = t.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function ube(e, t) {
    return Zge(t);
  }
  i(ube, "NullableTypeAnnotation");
  function cbe(e, t, r) {
    if (r.length < 3) return;
    let s = t.type;
    return s === "UnionTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "ArrayTypeAnnotation" || s === "TypeAnnotation" && ebe(
    r[r.length - 3]);
  }
  i(cbe, "FunctionTypeAnnotation");
  function fbe(e, t) {
    return mc(e, t) || Ad(e, t);
  }
  i(fbe, "UpdateExpression");
  function pbe(e, t, r) {
    return yc(r, 3);
  }
  i(pbe, "ObjectExpression");
  function dbe(e, t, r) {
    return !e.async && yc(r, 1);
  }
  i(dbe, "DoExpression");
  function hbe(e, t) {
    let r = t.type;
    if (e.operator === "**" && r === "BinaryExpression" && t.operator === "**")
      return t.left === e;
    if (Ad(e, t) || mc(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    if (r === "BinaryExpression" || r === "LogicalExpression") {
      let s = lL.get(t.operator), n = lL.get(e.operator);
      if (s === n && t.right === e && r !== "LogicalExpression" || s > n)
        return !0;
    }
  }
  i(hbe, "Binary");
  function mbe(e, t) {
    let r = t.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  i(mbe, "UnionTypeAnnotation");
  function ybe(e, t) {
    return ibe(t) && t.objectType === e;
  }
  i(ybe, "OptionalIndexedAccessType");
  function gbe() {
    return !0;
  }
  i(gbe, "TSAsExpression");
  function bbe(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
  }
  i(bbe, "TSUnionType");
  function Ebe(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSOptionalType";
  }
  i(Ebe, "TSInferType");
  function vbe(e, t) {
    let r = t.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
  }
  i(vbe, "TSInstantiationExpression");
  function Sbe(e, t) {
    if (e.operator === "in") {
      let r = t.type;
      return r === "VariableDeclarator" || r === "ForStatement" || r === "ForInStatement" || r === "ForOfStatement";
    }
    return !1;
  }
  i(Sbe, "BinaryExpression");
  function Tbe(e, t) {
    let r = t.type;
    return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && t.test === e || r === "Whil\
eStatement" && t.test === e || r === "ForInStatement" && t.right === e || r === "SwitchStatement" && t.discriminant === e || r === "Expressi\
onStatement" && t.expression === e);
  }
  i(Tbe, "SequenceExpression");
  function xbe(e, t) {
    let r = t.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || mc(e, t) || r === "A\
waitExpression" && lbe(e) || r === "ConditionalExpression" && e === t.test || Ad(e, t);
  }
  i(xbe, "YieldExpression");
  function Pbe(e, t, r) {
    return yc(r, 5);
  }
  i(Pbe, "ClassExpression");
  function fL(e, t) {
    return mc(e, t) || tbe(t) && t.operator === "**" && t.left === e || Ad(e, t);
  }
  i(fL, "UnaryLike");
  function Abe(e, t, r) {
    return yc(r, 5);
  }
  i(Abe, "FunctionExpression");
  function Cbe(e, t) {
    return sbe(t) || _v(e, t);
  }
  i(Cbe, "ArrowFunctionExpression");
  function _v(e, t) {
    let r = t.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && t.test === e || r === "AwaitExpression" || cL(r) ? !0 : fL(e, t);
  }
  i(_v, "ConditionalExpression");
  function wbe(e, t) {
    return rbe(t) && t.callee === e || uL(t) && t.object === e;
  }
  i(wbe, "OptionalMemberExpression");
  function Dbe(e, t) {
    return abe(e.left) ? !0 : _v(e, t);
  }
  i(Dbe, "AssignmentExpression");
  function Ibe(e, t) {
    let r = t.type;
    if (cL(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (e.operator) {
      case "||":
        return t.operator === "??" || t.operator === "&&";
      case "&&":
        return t.operator === "??";
      case "??":
        return t.operator !== "??";
    }
  }
  i(Ibe, "LogicalExpression");
  function _be(e, t, r) {
    var s;
    let n = t.type;
    if ((s = e.extra) != null && s.parenthesized && n === "AssignmentExpression" && t.left === e) {
      let a = t.right.type;
      if ((a === "FunctionExpression" || a === "ClassExpression") && t.right.id == null)
        return !0;
    }
    if (e.name === "let") {
      let a = uL(t, {
        object: e,
        computed: !0
      }) || obe(t, {
        object: e,
        computed: !0,
        optional: !1
      });
      return yc(r, a ? 57 : 32);
    }
    return e.name === "async" && nbe(t) && e === t.left;
  }
  i(_be, "Identifier");
  function yc(e, t) {
    let r = t & 1, s = t & 2, n = t & 4, a = t & 8, o = t & 16, l = t & 32, u = e.length - 1;
    if (u <= 0) return;
    let c = e[u];
    u--;
    let f = e[u];
    for (; u >= 0; ) {
      let p = f.type;
      if (r && p === "ExpressionStatement" && f.expression === c || n && p === "ExportDefaultDeclaration" && c === f.declaration || s && p ===
      "ArrowFunctionExpression" && f.body === c || a && p === "ForStatement" && f.init === c || o && p === "ForInStatement" && f.left === c ||
      l && p === "ForOfStatement" && f.left === c)
        return !0;
      if (u > 0 && (mc(c, f) && p !== "NewExpression" || p === "SequenceExpression" && f.expressions[0] === c || p === "UpdateExpression" &&
      !f.prefix || p === "ConditionalExpression" && f.test === c || (p === "BinaryExpression" || p === "LogicalExpression") && f.left === c ||
      p === "AssignmentExpression" && f.left === c))
        c = f, u--, f = e[u];
      else
        return !1;
    }
    return !1;
  }
  i(yc, "isFirstInContext");
});

// ../node_modules/@babel/generator/lib/node/index.js
var Nv = y((dl) => {
  "use strict";
  Object.defineProperty(dl, "__esModule", {
    value: !0
  });
  dl.needsParens = Vbe;
  dl.needsWhitespace = Ov;
  dl.needsWhitespaceAfter = Ube;
  dl.needsWhitespaceBefore = $be;
  var Obe = oL(), Nbe = pL(), Rbe = Ne(), {
    FLIPPED_ALIAS_KEYS: kbe,
    isCallExpression: Fbe,
    isExpressionStatement: Lbe,
    isMemberExpression: Bbe,
    isNewExpression: Mbe
  } = Rbe;
  function dL(e) {
    let t = /* @__PURE__ */ new Map();
    function r(s, n) {
      let a = t.get(s);
      t.set(s, a ? function(o, l, u) {
        var c;
        return (c = a(o, l, u)) != null ? c : n(o, l, u);
      } : n);
    }
    i(r, "add");
    for (let s of Object.keys(e)) {
      let n = kbe[s];
      if (n)
        for (let a of n)
          r(a, e[s]);
      else
        r(s, e[s]);
    }
    return t;
  }
  i(dL, "expandAliases");
  var jbe = dL(Nbe), qbe = dL(Obe.nodes);
  function hL(e) {
    return Fbe(e) ? !0 : Bbe(e) && hL(e.object);
  }
  i(hL, "isOrHasCallExpression");
  function Ov(e, t, r) {
    var s;
    if (!e) return !1;
    Lbe(e) && (e = e.expression);
    let n = (s = qbe.get(e.type)) == null ? void 0 : s(e, t);
    return typeof n == "number" ? (n & r) !== 0 : !1;
  }
  i(Ov, "needsWhitespace");
  function $be(e, t) {
    return Ov(e, t, 1);
  }
  i($be, "needsWhitespaceBefore");
  function Ube(e, t) {
    return Ov(e, t, 2);
  }
  i(Ube, "needsWhitespaceAfter");
  function Vbe(e, t, r) {
    var s;
    return t ? Mbe(t) && t.callee === e && hL(e) ? !0 : (s = jbe.get(e.type)) == null ? void 0 : s(e, t, r) : !1;
  }
  i(Vbe, "needsParens");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var mL = y((gc) => {
  "use strict";
  Object.defineProperty(gc, "__esModule", {
    value: !0
  });
  gc.TaggedTemplateExpression = Wbe;
  gc.TemplateElement = Hbe;
  gc.TemplateLiteral = Gbe;
  function Wbe(e) {
    this.print(e.tag, e), this.print(e.typeParameters, e), this.print(e.quasi, e);
  }
  i(Wbe, "TaggedTemplateExpression");
  function Hbe(e, t) {
    let r = t.quasis[0] === e, s = t.quasis[t.quasis.length - 1] === e, n = (r ? "`" : "}") + e.value.raw + (s ? "`" : "${");
    this.token(n, !0);
  }
  i(Hbe, "TemplateElement");
  function Gbe(e) {
    let t = e.quasis;
    for (let r = 0; r < t.length; r++)
      this.print(t[r], e), r + 1 < t.length && this.print(e.expressions[r], e);
  }
  i(Gbe, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var bL = y((At) => {
  "use strict";
  Object.defineProperty(At, "__esModule", {
    value: !0
  });
  At.LogicalExpression = At.BinaryExpression = At.AssignmentExpression = bEe;
  At.AssignmentPattern = gEe;
  At.AwaitExpression = dEe;
  At.BindExpression = EEe;
  At.CallExpression = fEe;
  At.ConditionalExpression = tEe;
  At.Decorator = lEe;
  At.DoExpression = Qbe;
  At.EmptyStatement = mEe;
  At.ExpressionStatement = yEe;
  At.Import = pEe;
  At.MemberExpression = vEe;
  At.MetaProperty = SEe;
  At.ModuleExpression = PEe;
  At.NewExpression = rEe;
  At.OptionalCallExpression = cEe;
  At.OptionalMemberExpression = uEe;
  At.ParenthesizedExpression = Zbe;
  At.PrivateName = TEe;
  At.SequenceExpression = sEe;
  At.Super = iEe;
  At.ThisExpression = nEe;
  At.UnaryExpression = Jbe;
  At.UpdateExpression = eEe;
  At.V8IntrinsicIdentifier = xEe;
  At.YieldExpression = hEe;
  At._shouldPrintDecoratorsBeforeExport = oEe;
  var Kbe = Ne(), Ybe = Nv(), {
    isCallExpression: Xbe,
    isLiteral: yL,
    isMemberExpression: Rv,
    isNewExpression: zbe
  } = Kbe;
  function Jbe(e) {
    let {
      operator: t
    } = e;
    t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument,
    e);
  }
  i(Jbe, "UnaryExpression");
  function Qbe(e) {
    e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body, e);
  }
  i(Qbe, "DoExpression");
  function Zbe(e) {
    this.tokenChar(40), this.print(e.expression, e), this.rightParens(e);
  }
  i(Zbe, "ParenthesizedExpression");
  function eEe(e) {
    e.prefix ? (this.token(e.operator), this.print(e.argument, e)) : (this.printTerminatorless(e.argument, e, !0), this.token(e.operator));
  }
  i(eEe, "UpdateExpression");
  function tEe(e) {
    this.print(e.test, e), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent, e), this.space(), this.tokenChar(58), this.
    space(), this.print(e.alternate, e);
  }
  i(tEe, "ConditionalExpression");
  function rEe(e, t) {
    this.word("new"), this.space(), this.print(e.callee, e), !(this.format.minified && e.arguments.length === 0 && !e.optional && !Xbe(t, {
      callee: e
    }) && !Rv(t) && !zbe(t)) && (this.print(e.typeArguments, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.tokenChar(
    40), this.printList(e.arguments, e), this.rightParens(e));
  }
  i(rEe, "NewExpression");
  function sEe(e) {
    this.printList(e.expressions, e);
  }
  i(sEe, "SequenceExpression");
  function nEe() {
    this.word("this");
  }
  i(nEe, "ThisExpression");
  function iEe() {
    this.word("super");
  }
  i(iEe, "Super");
  function gL(e) {
    switch (e.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !e.computed && e.property.type === "Identifier" && gL(e.object);
      default:
        return !1;
    }
  }
  i(gL, "isDecoratorMemberExpression");
  function aEe(e) {
    return e.type === "ParenthesizedExpression" ? !1 : !gL(e.type === "CallExpression" ? e.callee : e);
  }
  i(aEe, "shouldParenthesizeDecoratorExpression");
  function oEe(e) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start ===
    e.declaration.start;
  }
  i(oEe, "_shouldPrintDecoratorsBeforeExport");
  function lEe(e) {
    this.tokenChar(64);
    let {
      expression: t
    } = e;
    aEe(t) ? (this.tokenChar(40), this.print(t, e), this.tokenChar(41)) : this.print(t, e), this.newline();
  }
  i(lEe, "Decorator");
  function uEe(e) {
    let {
      computed: t
    } = e, {
      optional: r,
      property: s
    } = e;
    if (this.print(e.object, e), !t && Rv(s))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    yL(s) && typeof s.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(s, e), this.tokenChar(93)) :
    (r || this.tokenChar(46), this.print(s, e));
  }
  i(uEe, "OptionalMemberExpression");
  function cEe(e) {
    this.print(e.callee, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.print(e.typeArguments, e), this.tokenChar(
    40), this.printList(e.arguments, e), this.rightParens(e);
  }
  i(cEe, "OptionalCallExpression");
  function fEe(e) {
    this.print(e.callee, e), this.print(e.typeArguments, e), this.print(e.typeParameters, e), this.tokenChar(40), this.printList(e.arguments,
    e), this.rightParens(e);
  }
  i(fEe, "CallExpression");
  function pEe() {
    this.word("import");
  }
  i(pEe, "Import");
  function dEe(e) {
    this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
  }
  i(dEe, "AwaitExpression");
  function hEe(e) {
    this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument, e))) : e.argument && (this.
    space(), this.printTerminatorless(e.argument, e, !1));
  }
  i(hEe, "YieldExpression");
  function mEe() {
    this.semicolon(!0);
  }
  i(mEe, "EmptyStatement");
  function yEe(e) {
    this.print(e.expression, e), this.semicolon();
  }
  i(yEe, "ExpressionStatement");
  function gEe(e) {
    this.print(e.left, e), e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation, e), this.space(), this.tokenChar(61), this.
    space(), this.print(e.right, e);
  }
  i(gEe, "AssignmentPattern");
  function bEe(e, t) {
    let r = this.inForStatementInitCounter && e.operator === "in" && !Ybe.needsParens(e, t);
    r && this.tokenChar(40), this.print(e.left, e), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) :
    this.token(e.operator), this.space(), this.print(e.right, e), r && this.tokenChar(41);
  }
  i(bEe, "AssignmentExpression");
  function EEe(e) {
    this.print(e.object, e), this.token("::"), this.print(e.callee, e);
  }
  i(EEe, "BindExpression");
  function vEe(e) {
    if (this.print(e.object, e), !e.computed && Rv(e.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let t = e.computed;
    yL(e.property) && typeof e.property.value == "number" && (t = !0), t ? (this.tokenChar(91), this.print(e.property, e), this.tokenChar(93)) :
    (this.tokenChar(46), this.print(e.property, e));
  }
  i(vEe, "MemberExpression");
  function SEe(e) {
    this.print(e.meta, e), this.tokenChar(46), this.print(e.property, e);
  }
  i(SEe, "MetaProperty");
  function TEe(e) {
    this.tokenChar(35), this.print(e.id, e);
  }
  i(TEe, "PrivateName");
  function xEe(e) {
    this.tokenChar(37), this.word(e.name);
  }
  i(xEe, "V8IntrinsicIdentifier");
  function PEe(e) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: t
    } = e;
    (t.body.length || t.directives.length) && this.newline(), this.print(t, e), this.dedent(), this.rightBrace(e);
  }
  i(PEe, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var TL = y((ir) => {
  "use strict";
  Object.defineProperty(ir, "__esModule", {
    value: !0
  });
  ir.BreakStatement = kEe;
  ir.CatchClause = qEe;
  ir.ContinueStatement = FEe;
  ir.DebuggerStatement = VEe;
  ir.DoWhileStatement = REe;
  ir.ForOfStatement = ir.ForInStatement = void 0;
  ir.ForStatement = OEe;
  ir.IfStatement = _Ee;
  ir.LabeledStatement = MEe;
  ir.ReturnStatement = LEe;
  ir.SwitchCase = UEe;
  ir.SwitchStatement = $Ee;
  ir.ThrowStatement = BEe;
  ir.TryStatement = jEe;
  ir.VariableDeclaration = WEe;
  ir.VariableDeclarator = HEe;
  ir.WhileStatement = NEe;
  ir.WithStatement = IEe;
  var AEe = Ne(), {
    isFor: EL,
    isForStatement: CEe,
    isIfStatement: wEe,
    isStatement: DEe
  } = AEe;
  function IEe(e) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(e.object, e), this.tokenChar(41), this.printBlock(e);
  }
  i(IEe, "WithStatement");
  function _Ee(e) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.space();
    let t = e.alternate && wEe(vL(e.consequent));
    t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent, e), t && (this.dedent(), this.newline(),
    this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    e.alternate, e));
  }
  i(_Ee, "IfStatement");
  function vL(e) {
    let {
      body: t
    } = e;
    return DEe(t) === !1 ? e : vL(t);
  }
  i(vL, "getLastStatement");
  function OEe(e) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(e.init, e), this.inForStatementInitCounter--,
    this.tokenChar(59), e.test && (this.space(), this.print(e.test, e)), this.tokenChar(59), e.update && (this.space(), this.print(e.update,
    e)), this.tokenChar(41), this.printBlock(e);
  }
  i(OEe, "ForStatement");
  function NEe(e) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.printBlock(e);
  }
  i(NEe, "WhileStatement");
  function SL(e) {
    this.word("for"), this.space();
    let t = e.type === "ForOfStatement";
    t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(e.left, e), this.space(),
    this.word(t ? "of" : "in"), this.space(), this.print(e.right, e), this.tokenChar(41), this.printBlock(e);
  }
  i(SL, "ForXStatement");
  var $Ze = ir.ForInStatement = SL, UZe = ir.ForOfStatement = SL;
  function REe(e) {
    this.word("do"), this.space(), this.print(e.body, e), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test,
    e), this.tokenChar(41), this.semicolon();
  }
  i(REe, "DoWhileStatement");
  function Cd(e, t, r, s) {
    t && (e.space(), e.printTerminatorless(t, r, s)), e.semicolon();
  }
  i(Cd, "printStatementAfterKeyword");
  function kEe(e) {
    this.word("break"), Cd(this, e.label, e, !0);
  }
  i(kEe, "BreakStatement");
  function FEe(e) {
    this.word("continue"), Cd(this, e.label, e, !0);
  }
  i(FEe, "ContinueStatement");
  function LEe(e) {
    this.word("return"), Cd(this, e.argument, e, !1);
  }
  i(LEe, "ReturnStatement");
  function BEe(e) {
    this.word("throw"), Cd(this, e.argument, e, !1);
  }
  i(BEe, "ThrowStatement");
  function MEe(e) {
    this.print(e.label, e), this.tokenChar(58), this.space(), this.print(e.body, e);
  }
  i(MEe, "LabeledStatement");
  function jEe(e) {
    this.word("try"), this.space(), this.print(e.block, e), this.space(), e.handlers ? this.print(e.handlers[0], e) : this.print(e.handler, e),
    e.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e.finalizer, e));
  }
  i(jEe, "TryStatement");
  function qEe(e) {
    this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param, e), this.print(e.param.typeAnnotation, e), this.tokenChar(
    41), this.space()), this.print(e.body, e);
  }
  i(qEe, "CatchClause");
  function $Ee(e) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant, e), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(e.cases, e, {
      indent: !0,
      addNewlines(t, r) {
        if (!t && e.cases[e.cases.length - 1] === r) return -1;
      }
    }), this.rightBrace(e);
  }
  i($Ee, "SwitchStatement");
  function UEe(e) {
    e.test ? (this.word("case"), this.space(), this.print(e.test, e), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.
    length && (this.newline(), this.printSequence(e.consequent, e, {
      indent: !0
    }));
  }
  i(UEe, "SwitchCase");
  function VEe() {
    this.word("debugger"), this.semicolon();
  }
  i(VEe, "DebuggerStatement");
  function WEe(e, t) {
    e.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = e;
    this.word(r, r === "using" || r === "await using"), this.space();
    let s = !1;
    if (!EL(t))
      for (let n of e.declarations)
        n.init && (s = !0);
    if (this.printList(e.declarations, e, {
      separator: s ? function() {
        this.tokenChar(44), this.newline();
      } : void 0,
      indent: e.declarations.length > 1
    }), EL(t)) {
      if (CEe(t)) {
        if (t.init === e) return;
      } else if (t.left === e) return;
    }
    this.semicolon();
  }
  i(WEe, "VariableDeclaration");
  function HEe(e) {
    this.print(e.id, e), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation, e), e.init && (this.space(), this.tokenChar(61), this.
    space(), this.print(e.init, e));
  }
  i(HEe, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var xL = y((js) => {
  "use strict";
  Object.defineProperty(js, "__esModule", {
    value: !0
  });
  js.ClassAccessorProperty = QEe;
  js.ClassBody = zEe;
  js.ClassExpression = js.ClassDeclaration = XEe;
  js.ClassMethod = eve;
  js.ClassPrivateMethod = tve;
  js.ClassPrivateProperty = ZEe;
  js.ClassProperty = JEe;
  js.StaticBlock = sve;
  js._classMethodHead = rve;
  var GEe = Ne(), {
    isExportDefaultDeclaration: KEe,
    isExportNamedDeclaration: YEe
  } = GEe;
  function XEe(e, t) {
    (!(KEe(t) || YEe(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators, e), e.declare && (this.word("declar\
e"), this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id, e)), this.
    print(e.typeParameters, e), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass, e), this.print(e.
    superTypeParameters, e)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e)), this.space(),
    this.print(e.body, e);
  }
  i(XEe, "ClassDeclaration");
  function zEe(e) {
    this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, e, {
      indent: !0
    }), this.endsWith(10) || this.newline(), this.rightBrace(e));
  }
  i(zEe, "ClassBody");
  function JEe(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) :
    (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation,
    e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  i(JEe, "ClassProperty");
  function QEe(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.
    print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(
    33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  i(QEe, "ClassAccessorProperty");
  function ZEe(e) {
    this.printJoin(e.decorators, e), e.static && (this.word("static"), this.space()), this.print(e.key, e), this.print(e.typeAnnotation, e),
    e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
  }
  i(ZEe, "ClassPrivateProperty");
  function eve(e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }
  i(eve, "ClassMethod");
  function tve(e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }
  i(tve, "ClassPrivateMethod");
  function rve(e) {
    var t;
    this.printJoin(e.decorators, e);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this._methodHead(e);
  }
  i(rve, "_classMethodHead");
  function sve(e) {
    this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    e.body, e, {
      indent: !0
    }), this.rightBrace(e));
  }
  i(sve, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var PL = y((fn) => {
  "use strict";
  Object.defineProperty(fn, "__esModule", {
    value: !0
  });
  fn.ArrowFunctionExpression = dve;
  fn.FunctionDeclaration = fn.FunctionExpression = pve;
  fn._functionHead = fve;
  fn._methodHead = uve;
  fn._param = lve;
  fn._parameters = ove;
  fn._params = ave;
  fn._predicate = cve;
  var nve = Ne(), {
    isIdentifier: ive
  } = nve;
  function ave(e, t, r) {
    this.print(e.typeParameters, e);
    let s = mve.call(this, t, r);
    s && this.sourceIdentifierName(s.name, s.pos), this.tokenChar(40), this._parameters(e.params, e), this.tokenChar(41);
    let n = e.type === "ArrowFunctionExpression";
    this.print(e.returnType, e, n), this._noLineTerminator = n;
  }
  i(ave, "_params");
  function ove(e, t) {
    let r = e.length;
    for (let s = 0; s < r; s++)
      this._param(e[s], t), s < e.length - 1 && (this.tokenChar(44), this.space());
  }
  i(ove, "_parameters");
  function lve(e, t) {
    this.printJoin(e.decorators, e), this.print(e, t), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  i(lve, "_param");
  function uve(e) {
    let t = e.kind, r = e.key;
    (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t ===
    "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r, e), this.tokenChar(93)) : this.print(r, e),
    e.optional && this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
  }
  i(uve, "_methodHead");
  function cve(e, t) {
    e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, e, t));
  }
  i(cve, "_predicate");
  function fve(e, t) {
    e.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), e.generator && (this._endsWithInnerRaw =
    !1, this.tokenChar(42)), this.space(), e.id && this.print(e.id, e), this._params(e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(
    e);
  }
  i(fve, "_functionHead");
  function pve(e, t) {
    this._functionHead(e, t), this.space(), this.print(e.body, e);
  }
  i(pve, "FunctionExpression");
  function dve(e, t) {
    e.async && (this.word("async", !0), this.space());
    let r;
    !this.format.retainLines && e.params.length === 1 && ive(r = e.params[0]) && !hve(e, r) ? this.print(r, e, !0) : this._params(e, void 0,
    t), this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e.body, e);
  }
  i(dve, "ArrowFunctionExpression");
  function hve(e, t) {
    var r, s;
    return !!(e.typeParameters || e.returnType || e.predicate || t.typeAnnotation || t.optional || (r = t.leadingComments) != null && r.length ||
    (s = t.trailingComments) != null && s.length);
  }
  i(hve, "hasTypesOrComments");
  function mve(e, t) {
    let r = e;
    if (!r && t) {
      let u = t.type;
      u === "VariableDeclarator" ? r = t.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = t.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = t.key);
    }
    if (!r) return;
    let s;
    if (r.type === "Identifier") {
      var n, a;
      s = {
        pos: (n = r.loc) == null ? void 0 : n.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      s = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      s = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return s;
  }
  i(mve, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var kv = y((is) => {
  "use strict";
  Object.defineProperty(is, "__esModule", {
    value: !0
  });
  is.ExportAllDeclaration = Dve;
  is.ExportDefaultDeclaration = _ve;
  is.ExportDefaultSpecifier = Pve;
  is.ExportNamedDeclaration = Ive;
  is.ExportNamespaceSpecifier = Cve;
  is.ExportSpecifier = Ave;
  is.ImportAttribute = Nve;
  is.ImportDeclaration = Ove;
  is.ImportDefaultSpecifier = xve;
  is.ImportExpression = kve;
  is.ImportNamespaceSpecifier = Rve;
  is.ImportSpecifier = Tve;
  is._printAttributes = wve;
  var yve = Ne(), {
    isClassDeclaration: gve,
    isExportDefaultSpecifier: bve,
    isExportNamespaceSpecifier: Eve,
    isImportDefaultSpecifier: vve,
    isImportNamespaceSpecifier: Sve,
    isStatement: CL
  } = yve;
  function Tve(e) {
    (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported, e), e.local &&
    e.local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local, e));
  }
  i(Tve, "ImportSpecifier");
  function xve(e) {
    this.print(e.local, e);
  }
  i(xve, "ImportDefaultSpecifier");
  function Pve(e) {
    this.print(e.exported, e);
  }
  i(Pve, "ExportDefaultSpecifier");
  function Ave(e) {
    e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local, e), e.exported && e.local.name !== e.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(e.exported, e));
  }
  i(Ave, "ExportSpecifier");
  function Cve(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported, e);
  }
  i(Cve, "ExportNamespaceSpecifier");
  var AL = !1;
  function wve(e) {
    let {
      importAttributesKeyword: t
    } = this.format, {
      attributes: r,
      assertions: s
    } = e;
    r && !t && !AL && (AL = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify \
the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\
\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let n = t === "assert" || !t && s;
    if (this.word(n ? "assert" : "with"), this.space(), !n && t !== "with") {
      this.printList(r || s, e);
      return;
    }
    this.tokenChar(123), this.space(), this.printList(r || s, e), this.space(), this.tokenChar(125);
  }
  i(wve, "_printAttributes");
  function Dve(e) {
    var t, r;
    this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0),
    this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
  }
  i(Dve, "ExportAllDeclaration");
  function wL(e, t) {
    gve(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators, t);
  }
  i(wL, "maybePrintDecoratorsBeforeExport");
  function Ive(e) {
    if (wL(this, e), this.word("export"), this.space(), e.declaration) {
      let s = e.declaration;
      this.print(s, e), CL(s) || this.semicolon();
    } else {
      e.exportKind === "type" && (this.word("type"), this.space());
      let s = e.specifiers.slice(0), n = !1;
      for (; ; ) {
        let a = s[0];
        if (bve(a) || Eve(a))
          n = !0, this.print(s.shift(), e), s.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      if ((s.length || !s.length && !n) && (this.tokenChar(123), s.length && (this.space(), this.printList(s, e), this.space()), this.tokenChar(
      125)), e.source) {
        var t, r;
        this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.
        print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e);
      }
      this.semicolon();
    }
  }
  i(Ive, "ExportNamedDeclaration");
  function _ve(e) {
    wL(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
    let t = e.declaration;
    this.print(t, e), CL(t) || this.semicolon();
  }
  i(_ve, "ExportDefaultDeclaration");
  function Ove(e) {
    var t, r;
    this.word("import"), this.space();
    let s = e.importKind === "type" || e.importKind === "typeof";
    s ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
    let n = e.specifiers.slice(0), a = !!n.length;
    for (; a; ) {
      let o = n[0];
      if (vve(o) || Sve(o))
        this.print(n.shift(), e), n.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    n.length ? (this.tokenChar(123), this.space(), this.printList(n, e), this.space(), this.tokenChar(125)) : s && !a && (this.tokenChar(123),
    this.tokenChar(125)), (a || s) && (this.space(), this.word("from"), this.space()), (t = e.attributes) != null && t.length || (r = e.assertions) !=
    null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
  }
  i(Ove, "ImportDeclaration");
  function Nve(e) {
    this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
  }
  i(Nve, "ImportAttribute");
  function Rve(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local, e);
  }
  i(Rve, "ImportNamespaceSpecifier");
  function kve(e) {
    this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40), this.print(e.source, e), e.options != null &&
    (this.tokenChar(44), this.space(), this.print(e.options, e)), this.tokenChar(41);
  }
  i(kve, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var OL = y((JZe, _L) => {
  "use strict";
  var DL = {}, Fve = DL.hasOwnProperty, IL = /* @__PURE__ */ i((e, t) => {
    for (let r in e)
      Fve.call(e, r) && t(r, e[r]);
  }, "forOwn"), Lve = /* @__PURE__ */ i((e, t) => (t && IL(t, (r, s) => {
    e[r] = s;
  }), e), "extend"), Bve = /* @__PURE__ */ i((e, t) => {
    let r = e.length, s = -1;
    for (; ++s < r; )
      t(e[s]);
  }, "forEach"), bc = DL.toString, Mve = Array.isArray, jve = Buffer.isBuffer, qve = /* @__PURE__ */ i((e) => bc.call(e) == "[object Object]",
  "isObject"), $ve = /* @__PURE__ */ i((e) => typeof e == "string" || bc.call(e) == "[object String]", "isString"), Uve = /* @__PURE__ */ i(
  (e) => typeof e == "number" || bc.call(e) == "[object Number]", "isNumber"), Vve = /* @__PURE__ */ i((e) => typeof e == "function", "isFun\
ction"), Wve = /* @__PURE__ */ i((e) => bc.call(e) == "[object Map]", "isMap"), Hve = /* @__PURE__ */ i((e) => bc.call(e) == "[object Set]",
  "isSet"), Gve = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, Kve = /["'\\\b\f\n\r\t]/, Yve = /[0-9]/, Xve = /[ !#-&\(-\[\]-_a-~]/, ia = /* @__PURE__ */ i((e, t) => {
    let r = /* @__PURE__ */ i(() => {
      c = u, ++t.indentLevel, u = t.indent.repeat(t.indentLevel);
    }, "increaseIndentation"), s = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, n = t && t.json;
    n && (s.quotes = "double", s.wrap = !0), t = Lve(s, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes =
    "single");
    let a = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", o = t.compact, l = t.lowercaseHex, u = t.indent.repeat(t.indentLevel),
    c = "", f = t.__inline1__, p = t.__inline2__, d = o ? "" : `
`, m, b = !0, h = t.numbers == "binary", g = t.numbers == "octal", E = t.numbers == "decimal", D = t.numbers == "hexadecimal";
    if (n && e && Vve(e.toJSON) && (e = e.toJSON()), !$ve(e)) {
      if (Wve(e))
        return e.size == 0 ? "new Map()" : (o || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + ia(Array.from(e), t) + ")");
      if (Hve(e))
        return e.size == 0 ? "new Set()" : "new Set(" + ia(Array.from(e), t) + ")";
      if (jve(e))
        return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + ia(Array.from(e), t) + ")";
      if (Mve(e))
        return m = [], t.wrap = !0, f && (t.__inline1__ = !1, t.__inline2__ = !0), p || r(), Bve(e, (M) => {
          b = !1, p && (t.__inline2__ = !1), m.push(
            (o || p ? "" : u) + ia(M, t)
          );
        }), b ? "[]" : p ? "[" + m.join(", ") + "]" : "[" + d + m.join("," + d) + d + (o ? "" : c) + "]";
      if (Uve(e)) {
        if (n)
          return JSON.stringify(e);
        if (E)
          return String(e);
        if (D) {
          let M = e.toString(16);
          return l || (M = M.toUpperCase()), "0x" + M;
        }
        if (h)
          return "0b" + e.toString(2);
        if (g)
          return "0o" + e.toString(8);
      } else return qve(e) ? (m = [], t.wrap = !0, r(), IL(e, (M, q) => {
        b = !1, m.push(
          (o ? "" : u) + ia(M, t) + ":" + (o ? "" : " ") + ia(q, t)
        );
      }), b ? "{}" : "{" + d + m.join("," + d) + d + (o ? "" : c) + "}") : n ? JSON.stringify(e) || "null" : String(e);
    }
    let C = e, N = -1, I = C.length;
    for (m = ""; ++N < I; ) {
      let M = C.charAt(N);
      if (t.es6) {
        let j = C.charCodeAt(N);
        if (
          // check if its the start of a surrogate pair
          j >= 55296 && j <= 56319 && // high surrogate
          I > N + 1
        ) {
          let ie = C.charCodeAt(N + 1);
          if (ie >= 56320 && ie <= 57343) {
            let De = ((j - 55296) * 1024 + ie - 56320 + 65536).toString(16);
            l || (De = De.toUpperCase()), m += "\\u{" + De + "}", ++N;
            continue;
          }
        }
      }
      if (!t.escapeEverything) {
        if (Xve.test(M)) {
          m += M;
          continue;
        }
        if (M == '"') {
          m += a == M ? '\\"' : M;
          continue;
        }
        if (M == "`") {
          m += a == M ? "\\`" : M;
          continue;
        }
        if (M == "'") {
          m += a == M ? "\\'" : M;
          continue;
        }
      }
      if (M == "\0" && !n && !Yve.test(C.charAt(N + 1))) {
        m += "\\0";
        continue;
      }
      if (Kve.test(M)) {
        m += Gve[M];
        continue;
      }
      let q = M.charCodeAt(0);
      if (t.minimal && q != 8232 && q != 8233) {
        m += M;
        continue;
      }
      let V = q.toString(16);
      l || (V = V.toUpperCase());
      let W = V.length > 2 || n, Y = "\\" + (W ? "u" : "x") + ("0000" + V).slice(W ? -4 : -2);
      m += Y;
    }
    return t.wrap && (m = a + m + a), a == "`" && (m = m.replace(/\$\{/g, "\\${")), t.isScriptContext ? m.replace(/<\/(script|style)/gi, "<\\\
/$1").replace(/<!--/g, n ? "\\u003C!--" : "\\x3C!--") : m;
  }, "jsesc");
  ia.version = "2.5.2";
  _L.exports = ia;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var Lv = y((Wt) => {
  "use strict";
  Object.defineProperty(Wt, "__esModule", {
    value: !0
  });
  Wt.ArgumentPlaceholder = Zve;
  Wt.ArrayPattern = Wt.ArrayExpression = nSe;
  Wt.BigIntLiteral = pSe;
  Wt.BooleanLiteral = lSe;
  Wt.DecimalLiteral = dSe;
  Wt.Identifier = Qve;
  Wt.NullLiteral = uSe;
  Wt.NumericLiteral = cSe;
  Wt.ObjectPattern = Wt.ObjectExpression = tSe;
  Wt.ObjectMethod = rSe;
  Wt.ObjectProperty = sSe;
  Wt.PipelineBareFunction = ySe;
  Wt.PipelinePrimaryTopicReference = gSe;
  Wt.PipelineTopicExpression = mSe;
  Wt.RecordExpression = iSe;
  Wt.RegExpLiteral = oSe;
  Wt.SpreadElement = Wt.RestElement = eSe;
  Wt.StringLiteral = fSe;
  Wt.TopicReference = hSe;
  Wt.TupleExpression = aSe;
  var zve = Ne(), RL = OL(), {
    isAssignmentPattern: Jve,
    isIdentifier: Fv
  } = zve;
  function Qve(e) {
    var t;
    this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(e.name);
  }
  i(Qve, "Identifier");
  function Zve() {
    this.tokenChar(63);
  }
  i(Zve, "ArgumentPlaceholder");
  function eSe(e) {
    this.token("..."), this.print(e.argument, e);
  }
  i(eSe, "RestElement");
  function tSe(e) {
    let t = e.properties;
    this.tokenChar(123), t.length && (this.space(), this.printList(t, e, {
      indent: !0,
      statement: !0
    }), this.space()), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
  }
  i(tSe, "ObjectExpression");
  function rSe(e) {
    this.printJoin(e.decorators, e), this._methodHead(e), this.space(), this.print(e.body, e);
  }
  i(rSe, "ObjectMethod");
  function sSe(e) {
    if (this.printJoin(e.decorators, e), e.computed)
      this.tokenChar(91), this.print(e.key, e), this.tokenChar(93);
    else {
      if (Jve(e.value) && Fv(e.key) && e.key.name === e.value.left.name) {
        this.print(e.value, e);
        return;
      }
      if (this.print(e.key, e), e.shorthand && Fv(e.key) && Fv(e.value) && e.key.name === e.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(e.value, e);
  }
  i(sSe, "ObjectProperty");
  function nSe(e) {
    let t = e.elements, r = t.length;
    this.tokenChar(91);
    for (let s = 0; s < t.length; s++) {
      let n = t[s];
      n ? (s > 0 && this.space(), this.print(n, e), s < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }
  i(nSe, "ArrayExpression");
  function iSe(e) {
    let t = e.properties, r, s;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", s = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", s = "}";
    }
    this.token(r), t.length && (this.space(), this.printList(t, e, {
      indent: !0,
      statement: !0
    }), this.space()), this.token(s);
  }
  i(iSe, "RecordExpression");
  function aSe(e) {
    let t = e.elements, r = t.length, s, n;
    if (this.format.recordAndTupleSyntaxType === "bar")
      s = "[|", n = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      s = "#[", n = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(s);
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      o && (a > 0 && this.space(), this.print(o, e), a < r - 1 && this.tokenChar(44));
    }
    this.token(n);
  }
  i(aSe, "TupleExpression");
  function oSe(e) {
    this.word(`/${e.pattern}/${e.flags}`);
  }
  i(oSe, "RegExpLiteral");
  function lSe(e) {
    this.word(e.value ? "true" : "false");
  }
  i(lSe, "BooleanLiteral");
  function uSe() {
    this.word("null");
  }
  i(uSe, "NullLiteral");
  function cSe(e) {
    let t = this.getPossibleRaw(e), r = this.format.jsescOption, s = e.value, n = s + "";
    r.numbers ? this.number(RL(s, r), s) : t == null ? this.number(n, s) : this.format.minified ? this.number(t.length < n.length ? t : n, s) :
    this.number(t, s);
  }
  i(cSe, "NumericLiteral");
  function fSe(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let r = RL(e.value, this.format.jsescOption);
    this.token(r);
  }
  i(fSe, "StringLiteral");
  function pSe(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "n");
  }
  i(pSe, "BigIntLiteral");
  function dSe(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "m");
  }
  i(dSe, "DecimalLiteral");
  var NL = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function hSe() {
    let {
      topicToken: e
    } = this.format;
    if (NL.has(e))
      this.token(e);
    else {
      let t = JSON.stringify(e), r = Array.from(NL, (s) => JSON.stringify(s));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
    }
  }
  i(hSe, "TopicReference");
  function mSe(e) {
    this.print(e.expression, e);
  }
  i(mSe, "PipelineTopicExpression");
  function ySe(e) {
    this.print(e.callee, e);
  }
  i(ySe, "PipelineBareFunction");
  function gSe() {
    this.tokenChar(35);
  }
  i(gSe, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var FL = y((ve) => {
  "use strict";
  Object.defineProperty(ve, "__esModule", {
    value: !0
  });
  ve.AnyTypeAnnotation = SSe;
  ve.ArrayTypeAnnotation = TSe;
  ve.BooleanLiteralTypeAnnotation = PSe;
  ve.BooleanTypeAnnotation = xSe;
  ve.DeclareClass = CSe;
  ve.DeclareExportAllDeclaration = BSe;
  ve.DeclareExportDeclaration = LSe;
  ve.DeclareFunction = wSe;
  ve.DeclareInterface = _Se;
  ve.DeclareModule = OSe;
  ve.DeclareModuleExports = NSe;
  ve.DeclareOpaqueType = kSe;
  ve.DeclareTypeAlias = RSe;
  ve.DeclareVariable = FSe;
  ve.DeclaredPredicate = ISe;
  ve.EmptyTypeAnnotation = i1e;
  ve.EnumBooleanBody = jSe;
  ve.EnumBooleanMember = WSe;
  ve.EnumDeclaration = MSe;
  ve.EnumDefaultedMember = VSe;
  ve.EnumNumberBody = qSe;
  ve.EnumNumberMember = HSe;
  ve.EnumStringBody = $Se;
  ve.EnumStringMember = GSe;
  ve.EnumSymbolBody = USe;
  ve.ExistsTypeAnnotation = YSe;
  ve.FunctionTypeAnnotation = XSe;
  ve.FunctionTypeParam = zSe;
  ve.IndexedAccessType = _1e;
  ve.InferredPredicate = DSe;
  ve.InterfaceDeclaration = e1e;
  ve.GenericTypeAnnotation = ve.ClassImplements = ve.InterfaceExtends = JSe;
  ve.InterfaceTypeAnnotation = r1e;
  ve.IntersectionTypeAnnotation = s1e;
  ve.MixedTypeAnnotation = n1e;
  ve.NullLiteralTypeAnnotation = ASe;
  ve.NullableTypeAnnotation = a1e;
  Object.defineProperty(ve, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return kL.NumericLiteral;
    }, "get")
  });
  ve.NumberTypeAnnotation = o1e;
  ve.ObjectTypeAnnotation = g1e;
  ve.ObjectTypeCallProperty = E1e;
  ve.ObjectTypeIndexer = v1e;
  ve.ObjectTypeInternalSlot = b1e;
  ve.ObjectTypeProperty = S1e;
  ve.ObjectTypeSpreadProperty = T1e;
  ve.OpaqueType = y1e;
  ve.OptionalIndexedAccessType = O1e;
  ve.QualifiedTypeIdentifier = x1e;
  Object.defineProperty(ve, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return kL.StringLiteral;
    }, "get")
  });
  ve.StringTypeAnnotation = l1e;
  ve.SymbolTypeAnnotation = P1e;
  ve.ThisTypeAnnotation = u1e;
  ve.TupleTypeAnnotation = c1e;
  ve.TypeAlias = p1e;
  ve.TypeAnnotation = d1e;
  ve.TypeCastExpression = w1e;
  ve.TypeParameter = m1e;
  ve.TypeParameterDeclaration = ve.TypeParameterInstantiation = h1e;
  ve.TypeofTypeAnnotation = f1e;
  ve.UnionTypeAnnotation = C1e;
  ve.Variance = D1e;
  ve.VoidTypeAnnotation = I1e;
  ve._interfaceish = QSe;
  ve._variance = ZSe;
  var bSe = Ne(), ESe = kv(), kL = Lv(), {
    isDeclareExportDeclaration: wd,
    isStatement: vSe
  } = bSe;
  function SSe() {
    this.word("any");
  }
  i(SSe, "AnyTypeAnnotation");
  function TSe(e) {
    this.print(e.elementType, e, !0), this.tokenChar(91), this.tokenChar(93);
  }
  i(TSe, "ArrayTypeAnnotation");
  function xSe() {
    this.word("boolean");
  }
  i(xSe, "BooleanTypeAnnotation");
  function PSe(e) {
    this.word(e.value ? "true" : "false");
  }
  i(PSe, "BooleanLiteralTypeAnnotation");
  function ASe() {
    this.word("null");
  }
  i(ASe, "NullLiteralTypeAnnotation");
  function CSe(e, t) {
    wd(t) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e);
  }
  i(CSe, "DeclareClass");
  function wSe(e, t) {
    wd(t) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e.id, e), this.print(e.id.typeAnnotation.
    typeAnnotation, e), e.predicate && (this.space(), this.print(e.predicate, e)), this.semicolon();
  }
  i(wSe, "DeclareFunction");
  function DSe() {
    this.tokenChar(37), this.word("checks");
  }
  i(DSe, "InferredPredicate");
  function ISe(e) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e.value, e), this.tokenChar(41);
  }
  i(ISe, "DeclaredPredicate");
  function _Se(e) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(e);
  }
  i(_Se, "DeclareInterface");
  function OSe(e) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e.id, e), this.space(), this.print(e.body, e);
  }
  i(OSe, "DeclareModule");
  function NSe(e) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e.typeAnnotation, e);
  }
  i(NSe, "DeclareModuleExports");
  function RSe(e) {
    this.word("declare"), this.space(), this.TypeAlias(e);
  }
  i(RSe, "DeclareTypeAlias");
  function kSe(e, t) {
    wd(t) || (this.word("declare"), this.space()), this.OpaqueType(e);
  }
  i(kSe, "DeclareOpaqueType");
  function FSe(e, t) {
    wd(t) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e.id, e), this.print(e.id.typeAnnotation, e), this.
    semicolon();
  }
  i(FSe, "DeclareVariable");
  function LSe(e) {
    this.word("declare"), this.space(), this.word("export"), this.space(), e.default && (this.word("default"), this.space()), KSe.call(this,
    e);
  }
  i(LSe, "DeclareExportDeclaration");
  function BSe(e) {
    this.word("declare"), this.space(), ESe.ExportAllDeclaration.call(this, e);
  }
  i(BSe, "DeclareExportAllDeclaration");
  function MSe(e) {
    let {
      id: t,
      body: r
    } = e;
    this.word("enum"), this.space(), this.print(t, e), this.print(r, e);
  }
  i(MSe, "EnumDeclaration");
  function Dd(e, t, r) {
    r && (e.space(), e.word("of"), e.space(), e.word(t)), e.space();
  }
  i(Dd, "enumExplicitType");
  function Id(e, t) {
    let {
      members: r
    } = t;
    e.token("{"), e.indent(), e.newline();
    for (let s of r)
      e.print(s, t), e.newline();
    t.hasUnknownMembers && (e.token("..."), e.newline()), e.dedent(), e.token("}");
  }
  i(Id, "enumBody");
  function jSe(e) {
    let {
      explicitType: t
    } = e;
    Dd(this, "boolean", t), Id(this, e);
  }
  i(jSe, "EnumBooleanBody");
  function qSe(e) {
    let {
      explicitType: t
    } = e;
    Dd(this, "number", t), Id(this, e);
  }
  i(qSe, "EnumNumberBody");
  function $Se(e) {
    let {
      explicitType: t
    } = e;
    Dd(this, "string", t), Id(this, e);
  }
  i($Se, "EnumStringBody");
  function USe(e) {
    Dd(this, "symbol", !0), Id(this, e);
  }
  i(USe, "EnumSymbolBody");
  function VSe(e) {
    let {
      id: t
    } = e;
    this.print(t, e), this.tokenChar(44);
  }
  i(VSe, "EnumDefaultedMember");
  function Bv(e, t) {
    let {
      id: r,
      init: s
    } = t;
    e.print(r, t), e.space(), e.token("="), e.space(), e.print(s, t), e.token(",");
  }
  i(Bv, "enumInitializedMember");
  function WSe(e) {
    Bv(this, e);
  }
  i(WSe, "EnumBooleanMember");
  function HSe(e) {
    Bv(this, e);
  }
  i(HSe, "EnumNumberMember");
  function GSe(e) {
    Bv(this, e);
  }
  i(GSe, "EnumStringMember");
  function KSe(e) {
    if (e.declaration) {
      let t = e.declaration;
      this.print(t, e), vSe(t) || this.semicolon();
    } else
      this.tokenChar(123), e.specifiers.length && (this.space(), this.printList(e.specifiers, e), this.space()), this.tokenChar(125), e.source &&
      (this.space(), this.word("from"), this.space(), this.print(e.source, e)), this.semicolon();
  }
  i(KSe, "FlowExportDeclaration");
  function YSe() {
    this.tokenChar(42);
  }
  i(YSe, "ExistsTypeAnnotation");
  function XSe(e, t) {
    this.print(e.typeParameters, e), this.tokenChar(40), e.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e.this.typeAnnotation,
    e), (e.params.length || e.rest) && (this.tokenChar(44), this.space())), this.printList(e.params, e), e.rest && (e.params.length && (this.
    tokenChar(44), this.space()), this.token("..."), this.print(e.rest, e)), this.tokenChar(41);
    let r = t?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    t.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e.returnType, e);
  }
  i(XSe, "FunctionTypeAnnotation");
  function zSe(e) {
    this.print(e.name, e), e.optional && this.tokenChar(63), e.name && (this.tokenChar(58), this.space()), this.print(e.typeAnnotation, e);
  }
  i(zSe, "FunctionTypeParam");
  function JSe(e) {
    this.print(e.id, e), this.print(e.typeParameters, e, !0);
  }
  i(JSe, "InterfaceExtends");
  function QSe(e) {
    var t;
    if (this.print(e.id, e), this.print(e.typeParameters, e), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.
    space(), this.printList(e.extends, e)), e.type === "DeclareClass") {
      var r, s;
      (r = e.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(e.mixins, e)), (s = e.implements) !=
      null && s.length && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e));
    }
    this.space(), this.print(e.body, e);
  }
  i(QSe, "_interfaceish");
  function ZSe(e) {
    var t;
    let r = (t = e.variance) == null ? void 0 : t.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  i(ZSe, "_variance");
  function e1e(e) {
    this.word("interface"), this.space(), this._interfaceish(e);
  }
  i(e1e, "InterfaceDeclaration");
  function t1e() {
    this.space(), this.tokenChar(38), this.space();
  }
  i(t1e, "andSeparator");
  function r1e(e) {
    var t;
    this.word("interface"), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e.extends,
    e)), this.space(), this.print(e.body, e);
  }
  i(r1e, "InterfaceTypeAnnotation");
  function s1e(e) {
    this.printJoin(e.types, e, {
      separator: t1e
    });
  }
  i(s1e, "IntersectionTypeAnnotation");
  function n1e() {
    this.word("mixed");
  }
  i(n1e, "MixedTypeAnnotation");
  function i1e() {
    this.word("empty");
  }
  i(i1e, "EmptyTypeAnnotation");
  function a1e(e) {
    this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  i(a1e, "NullableTypeAnnotation");
  function o1e() {
    this.word("number");
  }
  i(o1e, "NumberTypeAnnotation");
  function l1e() {
    this.word("string");
  }
  i(l1e, "StringTypeAnnotation");
  function u1e() {
    this.word("this");
  }
  i(u1e, "ThisTypeAnnotation");
  function c1e(e) {
    this.tokenChar(91), this.printList(e.types, e), this.tokenChar(93);
  }
  i(c1e, "TupleTypeAnnotation");
  function f1e(e) {
    this.word("typeof"), this.space(), this.print(e.argument, e);
  }
  i(f1e, "TypeofTypeAnnotation");
  function p1e(e) {
    this.word("type"), this.space(), this.print(e.id, e), this.print(e.typeParameters, e), this.space(), this.tokenChar(61), this.space(), this.
    print(e.right, e), this.semicolon();
  }
  i(p1e, "TypeAlias");
  function d1e(e) {
    this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  i(d1e, "TypeAnnotation");
  function h1e(e) {
    this.tokenChar(60), this.printList(e.params, e, {}), this.tokenChar(62);
  }
  i(h1e, "TypeParameterInstantiation");
  function m1e(e) {
    this._variance(e), this.word(e.name), e.bound && this.print(e.bound, e), e.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(e.default, e));
  }
  i(m1e, "TypeParameter");
  function y1e(e) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e.id, e), this.print(e.typeParameters, e), e.supertype &&
    (this.tokenChar(58), this.space(), this.print(e.supertype, e)), e.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(
    e.impltype, e)), this.semicolon();
  }
  i(y1e, "OpaqueType");
  function g1e(e) {
    e.exact ? this.token("{|") : this.tokenChar(123);
    let t = [...e.properties, ...e.callProperties || [], ...e.indexers || [], ...e.internalSlots || []];
    t.length && (this.newline(), this.space(), this.printJoin(t, e, {
      addNewlines(r) {
        if (r && !t[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: /* @__PURE__ */ i(() => {
        (t.length !== 1 || e.inexact) && (this.tokenChar(44), this.space());
      }, "iterator")
    }), this.space()), e.inexact && (this.indent(), this.token("..."), t.length && this.newline(), this.dedent()), e.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  i(g1e, "ObjectTypeAnnotation");
  function b1e(e) {
    e.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e.id, e), this.tokenChar(93), this.tokenChar(
    93), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58), this.space()), this.print(e.value, e);
  }
  i(b1e, "ObjectTypeInternalSlot");
  function E1e(e) {
    e.static && (this.word("static"), this.space()), this.print(e.value, e);
  }
  i(E1e, "ObjectTypeCallProperty");
  function v1e(e) {
    e.static && (this.word("static"), this.space()), this._variance(e), this.tokenChar(91), e.id && (this.print(e.id, e), this.tokenChar(58),
    this.space()), this.print(e.key, e), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e.value, e);
  }
  i(v1e, "ObjectTypeIndexer");
  function S1e(e) {
    e.proto && (this.word("proto"), this.space()), e.static && (this.word("static"), this.space()), (e.kind === "get" || e.kind === "set") &&
    (this.word(e.kind), this.space()), this._variance(e), this.print(e.key, e), e.optional && this.tokenChar(63), e.method || (this.tokenChar(
    58), this.space()), this.print(e.value, e);
  }
  i(S1e, "ObjectTypeProperty");
  function T1e(e) {
    this.token("..."), this.print(e.argument, e);
  }
  i(T1e, "ObjectTypeSpreadProperty");
  function x1e(e) {
    this.print(e.qualification, e), this.tokenChar(46), this.print(e.id, e);
  }
  i(x1e, "QualifiedTypeIdentifier");
  function P1e() {
    this.word("symbol");
  }
  i(P1e, "SymbolTypeAnnotation");
  function A1e() {
    this.space(), this.tokenChar(124), this.space();
  }
  i(A1e, "orSeparator");
  function C1e(e) {
    this.printJoin(e.types, e, {
      separator: A1e
    });
  }
  i(C1e, "UnionTypeAnnotation");
  function w1e(e) {
    this.tokenChar(40), this.print(e.expression, e), this.print(e.typeAnnotation, e), this.tokenChar(41);
  }
  i(w1e, "TypeCastExpression");
  function D1e(e) {
    e.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  i(D1e, "Variance");
  function I1e() {
    this.word("void");
  }
  i(I1e, "VoidTypeAnnotation");
  function _1e(e) {
    this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  i(_1e, "IndexedAccessType");
  function O1e(e) {
    this.print(e.objectType, e), e.optional && this.token("?."), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  i(O1e, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var LL = y((hi) => {
  "use strict";
  Object.defineProperty(hi, "__esModule", {
    value: !0
  });
  hi.BlockStatement = k1e;
  hi.Directive = F1e;
  hi.DirectiveLiteral = M1e;
  hi.File = N1e;
  hi.InterpreterDirective = j1e;
  hi.Placeholder = q1e;
  hi.Program = R1e;
  function N1e(e) {
    e.program && this.print(e.program.interpreter, e), this.print(e.program, e);
  }
  i(N1e, "File");
  function R1e(e) {
    var t;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var s;
      let n = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, {
        trailingCommentsLineOffset: n
      }), (s = e.directives[r - 1].trailingComments) != null && s.length || this.newline(n);
    }
    this.printSequence(e.body, e);
  }
  i(R1e, "Program");
  function k1e(e) {
    var t;
    this.tokenChar(123);
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var s;
      let n = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, {
        indent: !0,
        trailingCommentsLineOffset: n
      }), (s = e.directives[r - 1].trailingComments) != null && s.length || this.newline(n);
    }
    this.printSequence(e.body, e, {
      indent: !0
    }), this.rightBrace(e);
  }
  i(k1e, "BlockStatement");
  function F1e(e) {
    this.print(e.value, e), this.semicolon();
  }
  i(F1e, "Directive");
  var L1e = /(?:^|[^\\])(?:\\\\)*'/, B1e = /(?:^|[^\\])(?:\\\\)*"/;
  function M1e(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let {
      value: r
    } = e;
    if (!B1e.test(r))
      this.token(`"${r}"`);
    else if (!L1e.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  i(M1e, "DirectiveLiteral");
  function j1e(e) {
    this.token(`#!${e.value}`), this.newline(1, !0);
  }
  i(j1e, "InterpreterDirective");
  function q1e(e) {
    this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
  }
  i(q1e, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var BL = y((Rr) => {
  "use strict";
  Object.defineProperty(Rr, "__esModule", {
    value: !0
  });
  Rr.JSXAttribute = $1e;
  Rr.JSXClosingElement = Q1e;
  Rr.JSXClosingFragment = rTe;
  Rr.JSXElement = X1e;
  Rr.JSXEmptyExpression = Z1e;
  Rr.JSXExpressionContainer = G1e;
  Rr.JSXFragment = eTe;
  Rr.JSXIdentifier = U1e;
  Rr.JSXMemberExpression = W1e;
  Rr.JSXNamespacedName = V1e;
  Rr.JSXOpeningElement = J1e;
  Rr.JSXOpeningFragment = tTe;
  Rr.JSXSpreadAttribute = H1e;
  Rr.JSXSpreadChild = K1e;
  Rr.JSXText = Y1e;
  function $1e(e) {
    this.print(e.name, e), e.value && (this.tokenChar(61), this.print(e.value, e));
  }
  i($1e, "JSXAttribute");
  function U1e(e) {
    this.word(e.name);
  }
  i(U1e, "JSXIdentifier");
  function V1e(e) {
    this.print(e.namespace, e), this.tokenChar(58), this.print(e.name, e);
  }
  i(V1e, "JSXNamespacedName");
  function W1e(e) {
    this.print(e.object, e), this.tokenChar(46), this.print(e.property, e);
  }
  i(W1e, "JSXMemberExpression");
  function H1e(e) {
    this.tokenChar(123), this.token("..."), this.print(e.argument, e), this.tokenChar(125);
  }
  i(H1e, "JSXSpreadAttribute");
  function G1e(e) {
    this.tokenChar(123), this.print(e.expression, e), this.tokenChar(125);
  }
  i(G1e, "JSXExpressionContainer");
  function K1e(e) {
    this.tokenChar(123), this.token("..."), this.print(e.expression, e), this.tokenChar(125);
  }
  i(K1e, "JSXSpreadChild");
  function Y1e(e) {
    let t = this.getPossibleRaw(e);
    t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
  }
  i(Y1e, "JSXText");
  function X1e(e) {
    let t = e.openingElement;
    if (this.print(t, e), !t.selfClosing) {
      this.indent();
      for (let r of e.children)
        this.print(r, e);
      this.dedent(), this.print(e.closingElement, e);
    }
  }
  i(X1e, "JSXElement");
  function z1e() {
    this.space();
  }
  i(z1e, "spaceSeparator");
  function J1e(e) {
    this.tokenChar(60), this.print(e.name, e), this.print(e.typeParameters, e), e.attributes.length > 0 && (this.space(), this.printJoin(e.attributes,
    e, {
      separator: z1e
    })), e.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }
  i(J1e, "JSXOpeningElement");
  function Q1e(e) {
    this.token("</"), this.print(e.name, e), this.tokenChar(62);
  }
  i(Q1e, "JSXClosingElement");
  function Z1e() {
    this.printInnerComments();
  }
  i(Z1e, "JSXEmptyExpression");
  function eTe(e) {
    this.print(e.openingFragment, e), this.indent();
    for (let t of e.children)
      this.print(t, e);
    this.dedent(), this.print(e.closingFragment, e);
  }
  i(eTe, "JSXFragment");
  function tTe() {
    this.tokenChar(60), this.tokenChar(62);
  }
  i(tTe, "JSXOpeningFragment");
  function rTe() {
    this.token("</"), this.tokenChar(62);
  }
  i(rTe, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var qL = y((Ee) => {
  "use strict";
  Object.defineProperty(Ee, "__esModule", {
    value: !0
  });
  Ee.TSAnyKeyword = yTe;
  Ee.TSArrayType = MTe;
  Ee.TSSatisfiesExpression = Ee.TSAsExpression = rxe;
  Ee.TSBigIntKeyword = gTe;
  Ee.TSBooleanKeyword = STe;
  Ee.TSCallSignatureDeclaration = cTe;
  Ee.TSConditionalType = HTe;
  Ee.TSConstructSignatureDeclaration = fTe;
  Ee.TSConstructorType = OTe;
  Ee.TSDeclareFunction = oTe;
  Ee.TSDeclareMethod = lTe;
  Ee.TSEnumDeclaration = ixe;
  Ee.TSEnumMember = axe;
  Ee.TSExportAssignment = dxe;
  Ee.TSExpressionWithTypeArguments = QTe;
  Ee.TSExternalModuleReference = fxe;
  Ee.TSFunctionType = _Te;
  Ee.TSImportEqualsDeclaration = cxe;
  Ee.TSImportType = uxe;
  Ee.TSIndexSignature = mTe;
  Ee.TSIndexedAccessType = XTe;
  Ee.TSInferType = GTe;
  Ee.TSInstantiationExpression = nxe;
  Ee.TSInterfaceBody = exe;
  Ee.TSInterfaceDeclaration = ZTe;
  Ee.TSIntersectionType = WTe;
  Ee.TSIntrinsicKeyword = DTe;
  Ee.TSLiteralType = JTe;
  Ee.TSMappedType = zTe;
  Ee.TSMethodSignature = hTe;
  Ee.TSModuleBlock = lxe;
  Ee.TSModuleDeclaration = oxe;
  Ee.TSNamedTupleMember = UTe;
  Ee.TSNamespaceExportDeclaration = hxe;
  Ee.TSNeverKeyword = wTe;
  Ee.TSNonNullExpression = pxe;
  Ee.TSNullKeyword = CTe;
  Ee.TSNumberKeyword = ETe;
  Ee.TSObjectKeyword = vTe;
  Ee.TSOptionalType = qTe;
  Ee.TSParameterProperty = aTe;
  Ee.TSParenthesizedType = KTe;
  Ee.TSPropertySignature = pTe;
  Ee.TSQualifiedName = uTe;
  Ee.TSRestType = $Te;
  Ee.TSStringKeyword = TTe;
  Ee.TSSymbolKeyword = xTe;
  Ee.TSThisType = ITe;
  Ee.TSTupleType = jTe;
  Ee.TSTypeAliasDeclaration = txe;
  Ee.TSTypeAnnotation = sTe;
  Ee.TSTypeAssertion = sxe;
  Ee.TSTypeLiteral = LTe;
  Ee.TSTypeOperator = YTe;
  Ee.TSTypeParameter = iTe;
  Ee.TSTypeParameterDeclaration = Ee.TSTypeParameterInstantiation = nTe;
  Ee.TSTypePredicate = kTe;
  Ee.TSTypeQuery = FTe;
  Ee.TSTypeReference = RTe;
  Ee.TSUndefinedKeyword = ATe;
  Ee.TSUnionType = VTe;
  Ee.TSUnknownKeyword = bTe;
  Ee.TSVoidKeyword = PTe;
  Ee.tsPrintClassMemberModifiers = yxe;
  Ee.tsPrintFunctionOrConstructorType = NTe;
  Ee.tsPrintPropertyOrMethodName = dTe;
  Ee.tsPrintSignatureDeclarationBase = mxe;
  Ee.tsPrintTypeLiteralOrInterfaceBody = BTe;
  function sTe(e) {
    this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
  }
  i(sTe, "TSTypeAnnotation");
  function nTe(e, t) {
    this.tokenChar(60), this.printList(e.params, e, {}), t.type === "ArrowFunctionExpression" && e.params.length === 1 && this.tokenChar(44),
    this.tokenChar(62);
  }
  i(nTe, "TSTypeParameterInstantiation");
  function iTe(e) {
    e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(e.constraint, e)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.
    default, e));
  }
  i(iTe, "TSTypeParameter");
  function aTe(e) {
    e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
  }
  i(aTe, "TSParameterProperty");
  function oTe(e, t) {
    e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.tokenChar(59);
  }
  i(oTe, "TSDeclareFunction");
  function lTe(e) {
    this._classMethodHead(e), this.tokenChar(59);
  }
  i(lTe, "TSDeclareMethod");
  function uTe(e) {
    this.print(e.left, e), this.tokenChar(46), this.print(e.right, e);
  }
  i(uTe, "TSQualifiedName");
  function cTe(e) {
    this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
  }
  i(cTe, "TSCallSignatureDeclaration");
  function fTe(e) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
  }
  i(fTe, "TSConstructSignatureDeclaration");
  function pTe(e) {
    let {
      readonly: t
    } = e;
    t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation, e), this.tokenChar(59);
  }
  i(pTe, "TSPropertySignature");
  function dTe(e) {
    e.computed && this.tokenChar(91), this.print(e.key, e), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
  }
  i(dTe, "tsPrintPropertyOrMethodName");
  function hTe(e) {
    let {
      kind: t
    } = e;
    (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(
    e), this.tokenChar(59);
  }
  i(hTe, "TSMethodSignature");
  function mTe(e) {
    let {
      readonly: t,
      static: r
    } = e;
    r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters,
    e), this.tokenChar(93), this.print(e.typeAnnotation, e), this.tokenChar(59);
  }
  i(mTe, "TSIndexSignature");
  function yTe() {
    this.word("any");
  }
  i(yTe, "TSAnyKeyword");
  function gTe() {
    this.word("bigint");
  }
  i(gTe, "TSBigIntKeyword");
  function bTe() {
    this.word("unknown");
  }
  i(bTe, "TSUnknownKeyword");
  function ETe() {
    this.word("number");
  }
  i(ETe, "TSNumberKeyword");
  function vTe() {
    this.word("object");
  }
  i(vTe, "TSObjectKeyword");
  function STe() {
    this.word("boolean");
  }
  i(STe, "TSBooleanKeyword");
  function TTe() {
    this.word("string");
  }
  i(TTe, "TSStringKeyword");
  function xTe() {
    this.word("symbol");
  }
  i(xTe, "TSSymbolKeyword");
  function PTe() {
    this.word("void");
  }
  i(PTe, "TSVoidKeyword");
  function ATe() {
    this.word("undefined");
  }
  i(ATe, "TSUndefinedKeyword");
  function CTe() {
    this.word("null");
  }
  i(CTe, "TSNullKeyword");
  function wTe() {
    this.word("never");
  }
  i(wTe, "TSNeverKeyword");
  function DTe() {
    this.word("intrinsic");
  }
  i(DTe, "TSIntrinsicKeyword");
  function ITe() {
    this.word("this");
  }
  i(ITe, "TSThisType");
  function _Te(e) {
    this.tsPrintFunctionOrConstructorType(e);
  }
  i(_Te, "TSFunctionType");
  function OTe(e) {
    e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
  }
  i(OTe, "TSConstructorType");
  function NTe(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    let s = e.typeAnnotation;
    this.print(s.typeAnnotation, e);
  }
  i(NTe, "tsPrintFunctionOrConstructorType");
  function RTe(e) {
    this.print(e.typeName, e, !0), this.print(e.typeParameters, e, !0);
  }
  i(RTe, "TSTypeReference");
  function kTe(e) {
    e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(e.typeAnnotation.typeAnnotation));
  }
  i(kTe, "TSTypePredicate");
  function FTe(e) {
    this.word("typeof"), this.space(), this.print(e.exprName), e.typeParameters && this.print(e.typeParameters, e);
  }
  i(FTe, "TSTypeQuery");
  function LTe(e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
  }
  i(LTe, "TSTypeLiteral");
  function BTe(e, t) {
    Mv(this, e, t);
  }
  i(BTe, "tsPrintTypeLiteralOrInterfaceBody");
  function Mv(e, t, r) {
    if (e.token("{"), t.length) {
      e.indent(), e.newline();
      for (let s of t)
        e.print(s, r), e.newline();
      e.dedent();
    }
    e.rightBrace(r);
  }
  i(Mv, "tsPrintBraced");
  function MTe(e) {
    this.print(e.elementType, e, !0), this.token("[]");
  }
  i(MTe, "TSArrayType");
  function jTe(e) {
    this.tokenChar(91), this.printList(e.elementTypes, e), this.tokenChar(93);
  }
  i(jTe, "TSTupleType");
  function qTe(e) {
    this.print(e.typeAnnotation, e), this.tokenChar(63);
  }
  i(qTe, "TSOptionalType");
  function $Te(e) {
    this.token("..."), this.print(e.typeAnnotation, e);
  }
  i($Te, "TSRestType");
  function UTe(e) {
    this.print(e.label, e), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType, e);
  }
  i(UTe, "TSNamedTupleMember");
  function VTe(e) {
    jL(this, e, "|");
  }
  i(VTe, "TSUnionType");
  function WTe(e) {
    jL(this, e, "&");
  }
  i(WTe, "TSIntersectionType");
  function jL(e, t, r) {
    e.printJoin(t.types, t, {
      separator() {
        this.space(), this.token(r), this.space();
      }
    });
  }
  i(jL, "tsPrintUnionOrIntersectionType");
  function HTe(e) {
    this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
  }
  i(HTe, "TSConditionalType");
  function GTe(e) {
    this.token("infer"), this.space(), this.print(e.typeParameter);
  }
  i(GTe, "TSInferType");
  function KTe(e) {
    this.tokenChar(40), this.print(e.typeAnnotation, e), this.tokenChar(41);
  }
  i(KTe, "TSParenthesizedType");
  function YTe(e) {
    this.word(e.operator), this.space(), this.print(e.typeAnnotation, e);
  }
  i(YTe, "TSTypeOperator");
  function XTe(e) {
    this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
  }
  i(XTe, "TSIndexedAccessType");
  function zTe(e) {
    let {
      nameType: t,
      optional: r,
      readonly: s,
      typeParameter: n,
      typeAnnotation: a
    } = e;
    this.tokenChar(123), this.space(), s && (ML(this, s), this.word("readonly"), this.space()), this.tokenChar(91), this.word(n.name), this.
    space(), this.word("in"), this.space(), this.print(n.constraint, n), t && (this.space(), this.word("as"), this.space(), this.print(t, e)),
    this.tokenChar(93), r && (ML(this, r), this.tokenChar(63)), a && (this.tokenChar(58), this.space(), this.print(a, e)), this.space(), this.
    tokenChar(125);
  }
  i(zTe, "TSMappedType");
  function ML(e, t) {
    t !== !0 && e.token(t);
  }
  i(ML, "tokenIfPlusMinus");
  function JTe(e) {
    this.print(e.literal, e);
  }
  i(JTe, "TSLiteralType");
  function QTe(e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }
  i(QTe, "TSExpressionWithTypeArguments");
  function ZTe(e) {
    let {
      declare: t,
      id: r,
      typeParameters: s,
      extends: n,
      body: a
    } = e;
    t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, e), this.print(s, e), n != null && n.length &&
    (this.space(), this.word("extends"), this.space(), this.printList(n, e)), this.space(), this.print(a, e);
  }
  i(ZTe, "TSInterfaceDeclaration");
  function exe(e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
  }
  i(exe, "TSInterfaceBody");
  function txe(e) {
    let {
      declare: t,
      id: r,
      typeParameters: s,
      typeAnnotation: n
    } = e;
    t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, e), this.print(s, e), this.space(), this.tokenChar(
    61), this.space(), this.print(n, e), this.tokenChar(59);
  }
  i(txe, "TSTypeAliasDeclaration");
  function rxe(e) {
    var t;
    let {
      type: r,
      expression: s,
      typeAnnotation: n
    } = e, a = !!((t = s.trailingComments) != null && t.length);
    this.print(s, e, !0, void 0, a), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(n, e);
  }
  i(rxe, "TSTypeExpression");
  function sxe(e) {
    let {
      typeAnnotation: t,
      expression: r
    } = e;
    this.tokenChar(60), this.print(t, e), this.tokenChar(62), this.space(), this.print(r, e);
  }
  i(sxe, "TSTypeAssertion");
  function nxe(e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }
  i(nxe, "TSInstantiationExpression");
  function ixe(e) {
    let {
      declare: t,
      const: r,
      id: s,
      members: n
    } = e;
    t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(s, e), this.
    space(), Mv(this, n, e);
  }
  i(ixe, "TSEnumDeclaration");
  function axe(e) {
    let {
      id: t,
      initializer: r
    } = e;
    this.print(t, e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e)), this.tokenChar(44);
  }
  i(axe, "TSEnumMember");
  function oxe(e) {
    let {
      declare: t,
      id: r
    } = e;
    if (t && (this.word("declare"), this.space()), e.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.
    print(r, e), !e.body) {
      this.tokenChar(59);
      return;
    }
    let s = e.body;
    for (; s.type === "TSModuleDeclaration"; )
      this.tokenChar(46), this.print(s.id, s), s = s.body;
    this.space(), this.print(s, e);
  }
  i(oxe, "TSModuleDeclaration");
  function lxe(e) {
    Mv(this, e.body, e);
  }
  i(lxe, "TSModuleBlock");
  function uxe(e) {
    let {
      argument: t,
      qualifier: r,
      typeParameters: s
    } = e;
    this.word("import"), this.tokenChar(40), this.print(t, e), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, e)), s && this.print(
    s, e);
  }
  i(uxe, "TSImportType");
  function cxe(e) {
    let {
      isExport: t,
      id: r,
      moduleReference: s
    } = e;
    t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, e), this.space(), this.tokenChar(61), this.space(),
    this.print(s, e), this.tokenChar(59);
  }
  i(cxe, "TSImportEqualsDeclaration");
  function fxe(e) {
    this.token("require("), this.print(e.expression, e), this.tokenChar(41);
  }
  i(fxe, "TSExternalModuleReference");
  function pxe(e) {
    this.print(e.expression, e), this.tokenChar(33);
  }
  i(pxe, "TSNonNullExpression");
  function dxe(e) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression, e), this.tokenChar(59);
  }
  i(dxe, "TSExportAssignment");
  function hxe(e) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id, e);
  }
  i(hxe, "TSNamespaceExportDeclaration");
  function mxe(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41);
    let s = e.typeAnnotation;
    this.print(s, e);
  }
  i(mxe, "tsPrintSignatureDeclarationBase");
  function yxe(e) {
    let t = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
    t && e.declare && (this.word("declare"), this.space()), e.accessibility && (this.word(e.accessibility), this.space()), e.static && (this.
    word("static"), this.space()), e.override && (this.word("override"), this.space()), e.abstract && (this.word("abstract"), this.space()),
    t && e.readonly && (this.word("readonly"), this.space());
  }
  i(yxe, "tsPrintClassMemberModifiers");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var $L = y((pt) => {
  "use strict";
  Object.defineProperty(pt, "__esModule", {
    value: !0
  });
  var jv = mL();
  Object.keys(jv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === jv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return jv[e];
      }, "get")
    });
  });
  var qv = bL();
  Object.keys(qv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === qv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return qv[e];
      }, "get")
    });
  });
  var $v = TL();
  Object.keys($v).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === $v[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return $v[e];
      }, "get")
    });
  });
  var Uv = xL();
  Object.keys(Uv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === Uv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return Uv[e];
      }, "get")
    });
  });
  var Vv = PL();
  Object.keys(Vv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === Vv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return Vv[e];
      }, "get")
    });
  });
  var Wv = kv();
  Object.keys(Wv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === Wv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return Wv[e];
      }, "get")
    });
  });
  var Hv = Lv();
  Object.keys(Hv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === Hv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return Hv[e];
      }, "get")
    });
  });
  var Gv = FL();
  Object.keys(Gv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === Gv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return Gv[e];
      }, "get")
    });
  });
  var Kv = LL();
  Object.keys(Kv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === Kv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return Kv[e];
      }, "get")
    });
  });
  var Yv = BL();
  Object.keys(Yv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === Yv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return Yv[e];
      }, "get")
    });
  });
  var Xv = qL();
  Object.keys(Xv).forEach(function(e) {
    e === "default" || e === "__esModule" || e in pt && pt[e] === Xv[e] || Object.defineProperty(pt, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return Xv[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/printer.js
var VL = y((_d) => {
  "use strict";
  Object.defineProperty(_d, "__esModule", {
    value: !0
  });
  _d.default = void 0;
  var gxe = rL(), bxe = Nv(), Exe = Ne(), vxe = $L(), {
    isFunction: Sxe,
    isStatement: Txe,
    isClassBody: xxe,
    isTSInterfaceBody: Pxe,
    isTSEnumDeclaration: Axe
  } = Exe, Cxe = /e/i, wxe = /\.0+$/, UL = /[\n\r\u2028\u2029]/, Dxe = /[\n\r\u2028\u2029]|\*\//, {
    needsParens: Ixe
  } = bxe, Ec = class {
    static {
      i(this, "Printer");
    }
    constructor(t, r) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState =
      null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger =
      !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = t, this.
      _indentRepeat = t.indent.style.length, this._inputMap = r?._inputMap, this._buf = new gxe.default(r, t.indent.style[0]);
    }
    generate(t) {
      return this.print(t), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(t = !1) {
      this._maybeAddAuxComment(), t ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(t) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
    }
    rightParens(t) {
      this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
    }
    space(t = !1) {
      if (!this.format.compact) {
        if (t)
          this._space();
        else if (this._buf.hasContent()) {
          let r = this.getLastChar();
          r !== 32 && r !== 10 && this._space();
        }
      }
    }
    word(t, r = !1) {
      this._maybePrintInnerComments(), (this._endsWithWord || t.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(),
      this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(t, r) {
      function s(n) {
        if (n.length > 2 && n.charCodeAt(0) === 48) {
          let a = n.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      i(s, "isNonDecimalLiteral"), this.word(t), this._endsWithInteger = Number.isInteger(r) && !s(t) && !Cxe.test(t) && !wxe.test(t) && t.charCodeAt(
      t.length - 1) !== 46;
    }
    token(t, r = !1) {
      this._maybePrintInnerComments();
      let s = this.getLastChar(), n = t.charCodeAt(0);
      (s === 33 && (t === "--" || n === 61) || n === 43 && s === 43 || n === 45 && s === 45 || n === 46 && this._endsWithInteger) && this._space(),
      this._maybeAddAuxComment(), this._append(t, r), this._noLineTerminator = !1;
    }
    tokenChar(t) {
      this._maybePrintInnerComments();
      let r = this.getLastChar();
      (t === 43 && r === 43 || t === 45 && r === 45 || t === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this.
      _appendChar(t), this._noLineTerminator = !1;
    }
    newline(t = 1, r) {
      if (!(t <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        t > 2 && (t = 2), t -= this._buf.getNewlineCount();
        for (let s = 0; s < t; s++)
          this._newline();
      }
    }
    endsWith(t) {
      return this.getLastChar() === t;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(t, r) {
      if (!t) {
        r();
        return;
      }
      this._catchUp("start", t), this._buf.exactSource(t, r);
    }
    source(t, r) {
      r && (this._catchUp(t, r), this._buf.source(t, r));
    }
    sourceWithOffset(t, r, s) {
      r && (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, s));
    }
    withSource(t, r, s) {
      if (!r) {
        s();
        return;
      }
      this._catchUp(t, r), this._buf.withSource(t, r, s);
    }
    sourceIdentifierName(t, r) {
      if (!this._buf._canMarkIdName) return;
      let s = this._buf._sourcePosition;
      s.identifierNamePos = r, s.identifierName = t;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(t, r) {
      this._maybeAddParen(t), this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _appendChar(t) {
      this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _queue(t) {
      this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(t) {
      this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(t) {
      if (this._indent && t !== 10 && this.endsWith(10))
        return !0;
    }
    _maybeAddParenChar(t) {
      let r = this._parenPushNewlineState;
      if (r && t !== 32) {
        if (t !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40), this.indent(), r.printed = !0;
      }
    }
    _maybeAddParen(t) {
      let r = this._parenPushNewlineState;
      if (!r) return;
      let s = t.length, n;
      for (n = 0; n < s && t.charCodeAt(n) === 32; n++) ;
      if (n === s)
        return;
      let a = t.charCodeAt(n);
      if (a !== 10) {
        if (a !== 47 || n + 1 === s) {
          this._parenPushNewlineState = null;
          return;
        }
        let o = t.charCodeAt(n + 1);
        if (o === 42)
          return;
        if (o !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
    catchUp(t) {
      if (!this.format.retainLines) return;
      let r = t - this._buf.getCurrentLine();
      for (let s = 0; s < r; s++)
        this._newline();
    }
    _catchUp(t, r) {
      var s;
      if (!this.format.retainLines) return;
      let n = r == null || (s = r[t]) == null ? void 0 : s.line;
      if (n != null) {
        let a = n - this._buf.getCurrentLine();
        for (let o = 0; o < a; o++)
          this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(t, r, s) {
      if (s)
        this._noLineTerminator = !0, this.print(t, r);
      else {
        let n = {
          printed: !1
        };
        this._parenPushNewlineState = n, this.print(t, r), n.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(t, r, s, n, a) {
      var o, l;
      if (!t) return;
      this._endsWithInnerRaw = !1;
      let u = t.type, c = this.format, f = c.concise;
      t._compact && (c.concise = !0);
      let p = this[u];
      if (p === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(t.constructor.name)}`);
      this._printStack.push(t);
      let d = this._insideAux;
      this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !d);
      let m = (o = t.extra) == null ? void 0 : o.parenthesized, b = a || m && c.retainFunctionParens && u === "FunctionExpression" || Ixe(t,
      r, this._printStack);
      if (!b && m && (l = t.leadingComments) != null && l.length && t.leadingComments[0].type === "CommentBlock")
        switch (r?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (r.callee !== t) break;
          default:
            b = !0;
        }
      b && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(t, r);
      let h = u === "Program" || u === "File" ? null : t.loc;
      this.exactSource(h, p.bind(this, t, r)), b ? (this._printTrailingComments(t, r), this.tokenChar(41), this._noLineTerminator = s) : s &&
      !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(t, r)) : this._printTrailingComments(t, r, n), this.
      _printStack.pop(), c.concise = f, this._insideAux = d, this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(t) {
      t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let t = this.format.auxiliaryCommentBefore;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let t = this.format.auxiliaryCommentAfter;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    getPossibleRaw(t) {
      let r = t.extra;
      if (r?.raw != null && r.rawValue != null && t.value === r.rawValue)
        return r.raw;
    }
    printJoin(t, r, s = {}) {
      if (!(t != null && t.length)) return;
      let {
        indent: n
      } = s;
      if (n == null && this.format.retainLines) {
        var a;
        let p = (a = t[0].loc) == null ? void 0 : a.start.line;
        p != null && p !== this._buf.getCurrentLine() && (n = !0);
      }
      n && this.indent();
      let o = {
        addNewlines: s.addNewlines,
        nextNodeStartLine: 0
      }, l = s.separator ? s.separator.bind(this) : null, u = t.length;
      for (let p = 0; p < u; p++) {
        let d = t[p];
        if (d && (s.statement && this._printNewline(p === 0, o), this.print(d, r, void 0, s.trailingCommentsLineOffset || 0), s.iterator == null ||
        s.iterator(d, p), p < u - 1 && l?.(), s.statement)) {
          var c;
          if ((c = d.trailingComments) != null && c.length || (this._lastCommentLine = 0), p + 1 === u)
            this.newline(1);
          else {
            var f;
            let m = t[p + 1];
            o.nextNodeStartLine = ((f = m.loc) == null ? void 0 : f.start.line) || 0, this._printNewline(!0, o);
          }
        }
      }
      n && this.dedent();
    }
    printAndIndentOnComments(t, r) {
      let s = t.leadingComments && t.leadingComments.length > 0;
      s && this.indent(), this.print(t, r), s && this.dedent();
    }
    printBlock(t) {
      let r = t.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r, t);
    }
    _printTrailingComments(t, r, s) {
      let {
        innerComments: n,
        trailingComments: a
      } = t;
      n != null && n.length && this._printComments(2, n, t, r, s), a != null && a.length && this._printComments(2, a, t, r, s);
    }
    _printLeadingComments(t, r) {
      let s = t.leadingComments;
      s != null && s.length && this._printComments(0, s, t, r);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments() {
      let t = this._printStack[this._printStack.length - 1], r = t.innerComments;
      if (!(r != null && r.length)) return;
      let s = this.endsWith(32), n = this._indentInnerComments, a = this._printedComments.size;
      n && this.indent(), this._printComments(1, r, t), s && a !== this._printedComments.size && this.space(), n && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(t, r, s = {}) {
      var n;
      s.statement = !0, (n = s.indent) != null || (s.indent = !1), this.printJoin(t, r, s);
    }
    printList(t, r, s = {}) {
      s.separator == null && (s.separator = _xe), this.printJoin(t, r, s);
    }
    _printNewline(t, r) {
      let s = this.format;
      if (s.retainLines || s.compact) return;
      if (s.concise) {
        this.space();
        return;
      }
      if (!t)
        return;
      let n = r.nextNodeStartLine, a = this._lastCommentLine;
      if (n > 0 && a > 0) {
        let o = n - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(t) {
      return t.ignore || this._printedComments.has(t) ? 0 : this._noLineTerminator && Dxe.test(t.value) ? 2 : (this._printedComments.add(t),
      this.format.shouldPrintComment(t.value) ? 1 : 0);
    }
    _printComment(t, r) {
      let s = this._noLineTerminator, n = t.type === "CommentBlock", a = n && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && this.space();
      let l;
      if (n) {
        let {
          _parenPushNewlineState: c
        } = this;
        if (c?.printed === !1 && UL.test(t.value) && (this.tokenChar(40), this.indent(), c.printed = !0), l = `/*${t.value}*/`, this.format.
        indent.adjustMultilineComment) {
          var u;
          let f = (u = t.loc) == null ? void 0 : u.start.column;
          if (f) {
            let p = new RegExp("\\n\\s{1," + f + "}", "g");
            l = l.replace(p, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let p = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (p += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(p)}`);
          }
        }
      } else s ? l = `/*${t.value}*/` : l = `//${t.value}`;
      this.endsWith(47) && this._space(), this.source("start", t.loc), this._append(l, n), !n && !s && this.newline(1, !0), a && r !== 3 && this.
      newline(1);
    }
    _printComments(t, r, s, n, a = 0) {
      let o = s.loc, l = r.length, u = !!o, c = u ? o.start.line : 0, f = u ? o.end.line : 0, p = 0, d = 0, m = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let b = 0; b < l; b++) {
        let h = r[b], g = this._shouldPrintComment(h);
        if (g === 2) {
          u = !1;
          break;
        }
        if (u && h.loc && g === 1) {
          let E = h.loc.start.line, D = h.loc.end.line;
          if (t === 0) {
            let C = 0;
            b === 0 ? this._buf.hasContent() && (h.type === "CommentLine" || E != D) && (C = d = 1) : C = E - p, p = D, m(C), this._printComment(
            h, 1), b + 1 === l && (m(Math.max(c - p, d)), p = c);
          } else if (t === 1) {
            let C = E - (b === 0 ? c : p);
            p = D, m(C), this._printComment(h, 1), b + 1 === l && (m(Math.min(1, f - p)), p = f);
          } else {
            let C = E - (b === 0 ? f - a : p);
            p = D, m(C), this._printComment(h, 1);
          }
        } else {
          if (u = !1, g !== 1)
            continue;
          if (l === 1) {
            let E = h.loc ? h.loc.start.line === h.loc.end.line : !UL.test(h.value), D = E && !Txe(s) && !xxe(n) && !Pxe(n) && !Axe(n);
            t === 0 ? this._printComment(h, D && s.type !== "ObjectExpression" || E && Sxe(n, {
              body: s
            }) ? 1 : 0) : D && t === 2 ? this._printComment(h, 1) : this._printComment(h, 0);
          } else t === 1 && !(s.type === "ObjectExpression" && s.properties.length > 1) && s.type !== "ClassBody" && s.type !== "TSInterface\
Body" ? this._printComment(h, b === 0 ? 2 : b === l - 1 ? 3 : 0) : this._printComment(h, 0);
        }
      }
      t === 2 && u && p && (this._lastCommentLine = p);
    }
  };
  Object.assign(Ec.prototype, vxe);
  Ec.prototype.Noop = /* @__PURE__ */ i(function() {
  }, "Noop");
  var pet = _d.default = Ec;
  function _xe() {
    this.tokenChar(44), this.space();
  }
  i(_xe, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var Nd = y((Od) => {
  "use strict";
  Object.defineProperty(Od, "__esModule", {
    value: !0
  });
  Od.default = Oxe;
  var WL = tL(), HL = VL();
  function GL(e, t) {
    var r;
    let s = {
      auxiliaryCommentBefore: t.auxiliaryCommentBefore,
      auxiliaryCommentAfter: t.auxiliaryCommentAfter,
      shouldPrintComment: t.shouldPrintComment,
      retainLines: t.retainLines,
      retainFunctionParens: t.retainFunctionParens,
      comments: t.comments == null || t.comments,
      compact: t.compact,
      minified: t.minified,
      concise: t.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, t.jsescOption),
      recordAndTupleSyntaxType: (r = t.recordAndTupleSyntaxType) != null ? r : "hash",
      topicToken: t.topicToken,
      importAttributesKeyword: t.importAttributesKeyword
    };
    s.decoratorsBeforeExport = t.decoratorsBeforeExport, s.jsescOption.json = t.jsonCompatibleStrings, s.minified ? (s.compact = !0, s.shouldPrintComment =
    s.shouldPrintComment || (() => s.comments)) : s.shouldPrintComment = s.shouldPrintComment || ((l) => s.comments || l.includes("@license") ||
    l.includes("@preserve")), s.compact === "auto" && (s.compact = typeof e == "string" && e.length > 5e5, s.compact && console.error(`[BABE\
L] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)), s.compact && (s.indent.adjustMultilineComment =
    !1);
    let {
      auxiliaryCommentBefore: n,
      auxiliaryCommentAfter: a,
      shouldPrintComment: o
    } = s;
    return n && !o(n) && (s.auxiliaryCommentBefore = void 0), a && !o(a) && (s.auxiliaryCommentAfter = void 0), s;
  }
  i(GL, "normalizeOptions");
  Od.CodeGenerator = class {
    static {
      i(this, "CodeGenerator");
    }
    constructor(t, r = {}, s) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = GL(s, r), this._map = r.sourceMaps ? new WL.
      default(r, s) : null;
    }
    generate() {
      return new HL.default(this._format, this._map).generate(this._ast);
    }
  };
  function Oxe(e, t = {}, r) {
    let s = GL(r, t), n = t.sourceMaps ? new WL.default(t, r) : null;
    return new HL.default(s, n).generate(e);
  }
  i(Oxe, "generate");
});

// ../node_modules/@babel/traverse/lib/path/ancestry.js
var KL = y((qs) => {
  "use strict";
  Object.defineProperty(qs, "__esModule", {
    value: !0
  });
  qs.find = Fxe;
  qs.findParent = kxe;
  qs.getAncestry = qxe;
  qs.getDeepestCommonAncestorFrom = jxe;
  qs.getEarliestCommonAncestorFrom = Mxe;
  qs.getFunctionParent = Lxe;
  qs.getStatementParent = Bxe;
  qs.inType = Vxe;
  qs.isAncestor = $xe;
  qs.isDescendant = Uxe;
  var Nxe = Ne(), {
    VISITOR_KEYS: Rxe
  } = Nxe;
  function kxe(e) {
    let t = this;
    for (; t = t.parentPath; )
      if (e(t)) return t;
    return null;
  }
  i(kxe, "findParent");
  function Fxe(e) {
    let t = this;
    do
      if (e(t)) return t;
    while (t = t.parentPath);
    return null;
  }
  i(Fxe, "find");
  function Lxe() {
    return this.findParent((e) => e.isFunction());
  }
  i(Lxe, "getFunctionParent");
  function Bxe() {
    let e = this;
    do {
      if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
        break;
      e = e.parentPath;
    } while (e);
    if (e && (e.isProgram() || e.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return e;
  }
  i(Bxe, "getStatementParent");
  function Mxe(e) {
    return this.getDeepestCommonAncestorFrom(e, function(t, r, s) {
      let n, a = Rxe[t.type];
      for (let o of s) {
        let l = o[r + 1];
        if (!n) {
          n = l;
          continue;
        }
        if (l.listKey && n.listKey === l.listKey && l.key < n.key) {
          n = l;
          continue;
        }
        let u = a.indexOf(n.parentKey), c = a.indexOf(l.parentKey);
        u > c && (n = l);
      }
      return n;
    });
  }
  i(Mxe, "getEarliestCommonAncestorFrom");
  function jxe(e, t) {
    if (!e.length)
      return this;
    if (e.length === 1)
      return e[0];
    let r = 1 / 0, s, n, a = e.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < r && (r = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < r; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      s = l, n = u;
    }
    if (n)
      return t ? t(n, s, a) : n;
    throw new Error("Couldn't find intersection");
  }
  i(jxe, "getDeepestCommonAncestorFrom");
  function qxe() {
    let e = this, t = [];
    do
      t.push(e);
    while (e = e.parentPath);
    return t;
  }
  i(qxe, "getAncestry");
  function $xe(e) {
    return e.isDescendant(this);
  }
  i($xe, "isAncestor");
  function Uxe(e) {
    return !!this.findParent((t) => t === e);
  }
  i(Uxe, "isDescendant");
  function Vxe(...e) {
    let t = this;
    for (; t; ) {
      for (let r of e)
        if (t.node.type === r) return !0;
      t = t.parentPath;
    }
    return !1;
  }
  i(Vxe, "inType");
});

// ../node_modules/@babel/traverse/lib/path/inference/util.js
var Jv = y((zv) => {
  "use strict";
  Object.defineProperty(zv, "__esModule", {
    value: !0
  });
  zv.createUnionType = Yxe;
  var Wxe = Ne(), {
    createFlowUnionType: YL,
    createTSUnionType: XL,
    createUnionTypeAnnotation: Hxe,
    isFlowType: Gxe,
    isTSType: Kxe
  } = Wxe;
  function Yxe(e) {
    {
      if (e.every((t) => Gxe(t)))
        return YL ? YL(e) : Hxe(e);
      if (e.every((t) => Kxe(t)) && XL)
        return XL(e);
    }
  }
  i(Yxe, "createUnionType");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var e3 = y((Qv) => {
  "use strict";
  Object.defineProperty(Qv, "__esModule", {
    value: !0
  });
  Qv.default = Zxe;
  var Xxe = Ne(), JL = Jv(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: zxe,
    createTypeAnnotationBasedOnTypeof: Jxe,
    numberTypeAnnotation: QL,
    voidTypeAnnotation: Qxe
  } = Xxe;
  function Zxe(e) {
    if (!this.isReferenced()) return;
    let t = this.scope.getBinding(e.name);
    if (t)
      return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : ePe(t, this, e.name);
    if (e.name === "undefined")
      return Qxe();
    if (e.name === "NaN" || e.name === "Infinity")
      return QL();
    e.name;
  }
  i(Zxe, "_default");
  function ePe(e, t, r) {
    let s = [], n = [], a = zL(e, t, n), o = ZL(e, t, r);
    if (o) {
      let l = zL(e, o.ifStatement);
      a = a.filter((u) => l.indexOf(u) < 0), s.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...n);
      for (let l of a)
        s.push(l.getTypeAnnotation());
    }
    if (s.length)
      return (0, JL.createUnionType)(s);
  }
  i(ePe, "getTypeAnnotationBindingConstantViolations");
  function zL(e, t, r) {
    let s = e.constantViolations.slice();
    return s.unshift(e.path), s.filter((n) => {
      n = n.resolve();
      let a = n._guessExecutionStatusRelativeTo(t);
      return r && a === "unknown" && r.push(n), a === "before";
    });
  }
  i(zL, "getConstantViolationsBefore");
  function tPe(e, t) {
    let r = t.node.operator, s = t.get("right").resolve(), n = t.get("left").resolve(), a;
    if (n.isIdentifier({
      name: e
    }) ? a = s : s.isIdentifier({
      name: e
    }) && (a = n), a)
      return r === "===" ? a.getTypeAnnotation() : zxe.indexOf(r) >= 0 ? QL() : void 0;
    if (r !== "===" && r !== "==") return;
    let o, l;
    if (n.isUnaryExpression({
      operator: "typeof"
    }) ? (o = n, l = s) : s.isUnaryExpression({
      operator: "typeof"
    }) && (o = s, l = n), !o || !o.get("argument").isIdentifier({
      name: e
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return Jxe(u);
  }
  i(tPe, "inferAnnotationFromBinaryExpression");
  function rPe(e, t, r) {
    let s;
    for (; s = t.parentPath; ) {
      if (s.isIfStatement() || s.isConditionalExpression())
        return t.key === "test" ? void 0 : s;
      if (s.isFunction() && s.parentPath.scope.getBinding(r) !== e)
        return;
      t = s;
    }
  }
  i(rPe, "getParentConditionalPath");
  function ZL(e, t, r) {
    let s = rPe(e, t, r);
    if (!s) return;
    let a = [s.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = tPe(r, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, JL.createUnionType)(o),
      ifStatement: s
    } : ZL(e, s, r);
  }
  i(ZL, "getConditionalAnnotation");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferers.js
var l3 = y((St) => {
  "use strict";
  Object.defineProperty(St, "__esModule", {
    value: !0
  });
  St.ArrayExpression = i3;
  St.AssignmentExpression = APe;
  St.BinaryExpression = vPe;
  St.BooleanLiteral = IPe;
  St.CallExpression = MPe;
  St.ConditionalExpression = TPe;
  St.ClassDeclaration = St.ClassExpression = St.FunctionDeclaration = St.ArrowFunctionExpression = St.FunctionExpression = RPe;
  Object.defineProperty(St, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return nPe.default;
    }, "get")
  });
  St.LogicalExpression = SPe;
  St.NewExpression = gPe;
  St.NullLiteral = _Pe;
  St.NumericLiteral = DPe;
  St.ObjectExpression = NPe;
  St.ParenthesizedExpression = PPe;
  St.RegExpLiteral = OPe;
  St.RestElement = a3;
  St.SequenceExpression = xPe;
  St.StringLiteral = wPe;
  St.TSAsExpression = n3;
  St.TSNonNullExpression = yPe;
  St.TaggedTemplateExpression = jPe;
  St.TemplateLiteral = bPe;
  St.TypeCastExpression = s3;
  St.UnaryExpression = EPe;
  St.UpdateExpression = CPe;
  St.VariableDeclarator = mPe;
  var sPe = Ne(), nPe = e3(), r3 = Jv(), {
    BOOLEAN_BINARY_OPERATORS: iPe,
    BOOLEAN_UNARY_OPERATORS: aPe,
    NUMBER_BINARY_OPERATORS: oPe,
    NUMBER_UNARY_OPERATORS: lPe,
    STRING_UNARY_OPERATORS: uPe,
    anyTypeAnnotation: t3,
    arrayTypeAnnotation: Zv,
    booleanTypeAnnotation: eS,
    buildMatchMemberExpression: Rd,
    genericTypeAnnotation: aa,
    identifier: to,
    nullLiteralTypeAnnotation: cPe,
    numberTypeAnnotation: hl,
    stringTypeAnnotation: ro,
    tupleTypeAnnotation: fPe,
    unionTypeAnnotation: pPe,
    voidTypeAnnotation: dPe,
    isIdentifier: hPe
  } = sPe;
  function mPe() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  i(mPe, "VariableDeclarator");
  function s3(e) {
    return e.typeAnnotation;
  }
  i(s3, "TypeCastExpression");
  s3.validParent = !0;
  function n3(e) {
    return e.typeAnnotation;
  }
  i(n3, "TSAsExpression");
  n3.validParent = !0;
  function yPe() {
    return this.get("expression").getTypeAnnotation();
  }
  i(yPe, "TSNonNullExpression");
  function gPe(e) {
    if (e.callee.type === "Identifier")
      return aa(e.callee);
  }
  i(gPe, "NewExpression");
  function bPe() {
    return ro();
  }
  i(bPe, "TemplateLiteral");
  function EPe(e) {
    let t = e.operator;
    if (t === "void")
      return dPe();
    if (lPe.indexOf(t) >= 0)
      return hl();
    if (uPe.indexOf(t) >= 0)
      return ro();
    if (aPe.indexOf(t) >= 0)
      return eS();
  }
  i(EPe, "UnaryExpression");
  function vPe(e) {
    let t = e.operator;
    if (oPe.indexOf(t) >= 0)
      return hl();
    if (iPe.indexOf(t) >= 0)
      return eS();
    if (t === "+") {
      let r = this.get("right"), s = this.get("left");
      return s.isBaseType("number") && r.isBaseType("number") ? hl() : s.isBaseType("string") || r.isBaseType("string") ? ro() : pPe([ro(), hl()]);
    }
  }
  i(vPe, "BinaryExpression");
  function SPe() {
    let e = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, r3.createUnionType)(e);
  }
  i(SPe, "LogicalExpression");
  function TPe() {
    let e = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, r3.createUnionType)(e);
  }
  i(TPe, "ConditionalExpression");
  function xPe() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  i(xPe, "SequenceExpression");
  function PPe() {
    return this.get("expression").getTypeAnnotation();
  }
  i(PPe, "ParenthesizedExpression");
  function APe() {
    return this.get("right").getTypeAnnotation();
  }
  i(APe, "AssignmentExpression");
  function CPe(e) {
    let t = e.operator;
    if (t === "++" || t === "--")
      return hl();
  }
  i(CPe, "UpdateExpression");
  function wPe() {
    return ro();
  }
  i(wPe, "StringLiteral");
  function DPe() {
    return hl();
  }
  i(DPe, "NumericLiteral");
  function IPe() {
    return eS();
  }
  i(IPe, "BooleanLiteral");
  function _Pe() {
    return cPe();
  }
  i(_Pe, "NullLiteral");
  function OPe() {
    return aa(to("RegExp"));
  }
  i(OPe, "RegExpLiteral");
  function NPe() {
    return aa(to("Object"));
  }
  i(NPe, "ObjectExpression");
  function i3() {
    return aa(to("Array"));
  }
  i(i3, "ArrayExpression");
  function a3() {
    return i3();
  }
  i(a3, "RestElement");
  a3.validParent = !0;
  function RPe() {
    return aa(to("Function"));
  }
  i(RPe, "Func");
  var kPe = Rd("Array.from"), FPe = Rd("Object.keys"), LPe = Rd("Object.values"), BPe = Rd("Object.entries");
  function MPe() {
    let {
      callee: e
    } = this.node;
    return FPe(e) ? Zv(ro()) : kPe(e) || LPe(e) || hPe(e, {
      name: "Array"
    }) ? Zv(t3()) : BPe(e) ? Zv(fPe([ro(), t3()])) : o3(this.get("callee"));
  }
  i(MPe, "CallExpression");
  function jPe() {
    return o3(this.get("tag"));
  }
  i(jPe, "TaggedTemplateExpression");
  function o3(e) {
    if (e = e.resolve(), e.isFunction()) {
      let {
        node: t
      } = e;
      if (t.async)
        return t.generator ? aa(to("AsyncIterator")) : aa(to("Promise"));
      if (t.generator)
        return aa(to("Iterator"));
      if (e.node.returnType)
        return e.node.returnType;
    }
  }
  i(o3, "resolveCall");
});

// ../node_modules/@babel/traverse/lib/path/inference/index.js
var p3 = y((oa) => {
  "use strict";
  Object.defineProperty(oa, "__esModule", {
    value: !0
  });
  oa._getTypeAnnotation = iAe;
  oa.baseTypeStrictlyMatches = lAe;
  oa.couldBeBaseType = oAe;
  oa.getTypeAnnotation = nAe;
  oa.isBaseType = aAe;
  oa.isGenericType = uAe;
  var u3 = l3(), qPe = Ne(), {
    anyTypeAnnotation: f3,
    isAnyTypeAnnotation: kd,
    isArrayTypeAnnotation: $Pe,
    isBooleanTypeAnnotation: UPe,
    isEmptyTypeAnnotation: VPe,
    isFlowBaseAnnotation: WPe,
    isGenericTypeAnnotation: HPe,
    isIdentifier: c3,
    isMixedTypeAnnotation: GPe,
    isNumberTypeAnnotation: KPe,
    isStringTypeAnnotation: YPe,
    isTSArrayType: XPe,
    isTSTypeAnnotation: zPe,
    isTSTypeReference: JPe,
    isTupleTypeAnnotation: QPe,
    isTypeAnnotation: ZPe,
    isUnionTypeAnnotation: eAe,
    isVoidTypeAnnotation: tAe,
    stringTypeAnnotation: rAe,
    voidTypeAnnotation: sAe
  } = qPe;
  function nAe() {
    let e = this.getData("typeAnnotation");
    return e != null || (e = this._getTypeAnnotation() || f3(), (ZPe(e) || zPe(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation",
    e)), e;
  }
  i(nAe, "getTypeAnnotation");
  var tS = /* @__PURE__ */ new WeakSet();
  function iAe() {
    let e = this.node;
    if (!e)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let r = this.parentPath.parentPath, s = r.parentPath;
        return r.key === "left" && s.isForInStatement() ? rAe() : r.key === "left" && s.isForOfStatement() ? f3() : sAe();
      } else
        return;
    if (e.typeAnnotation)
      return e.typeAnnotation;
    if (!tS.has(e)) {
      tS.add(e);
      try {
        var t;
        let r = u3[e.type];
        if (r)
          return r.call(this, e);
        if (r = u3[this.parentPath.type], (t = r) != null && t.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        tS.delete(e);
      }
    }
  }
  i(iAe, "_getTypeAnnotation");
  function aAe(e, t) {
    return rS(e, this.getTypeAnnotation(), t);
  }
  i(aAe, "isBaseType");
  function rS(e, t, r) {
    if (e === "string")
      return YPe(t);
    if (e === "number")
      return KPe(t);
    if (e === "boolean")
      return UPe(t);
    if (e === "any")
      return kd(t);
    if (e === "mixed")
      return GPe(t);
    if (e === "empty")
      return VPe(t);
    if (e === "void")
      return tAe(t);
    if (r)
      return !1;
    throw new Error(`Unknown base type ${e}`);
  }
  i(rS, "_isBaseType");
  function oAe(e) {
    let t = this.getTypeAnnotation();
    if (kd(t)) return !0;
    if (eAe(t)) {
      for (let r of t.types)
        if (kd(r) || rS(e, r, !0))
          return !0;
      return !1;
    } else
      return rS(e, t, !0);
  }
  i(oAe, "couldBeBaseType");
  function lAe(e) {
    let t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
    return !kd(t) && WPe(t) ? r.type === t.type : !1;
  }
  i(lAe, "baseTypeStrictlyMatches");
  function uAe(e) {
    let t = this.getTypeAnnotation();
    return e === "Array" && (XPe(t) || $Pe(t) || QPe(t)) ? !0 : HPe(t) && c3(t.id, {
      name: e
    }) || JPe(t) && c3(t.typeName, {
      name: e
    });
  }
  i(uAe, "isGenericType");
});

// ../node_modules/js-tokens/index.js
var d3 = y((Fd) => {
  Object.defineProperty(Fd, "__esModule", {
    value: !0
  });
  Fd.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  Fd.matchToToken = function(e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) :
    e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "white\
space"), t;
  };
});

// ../node_modules/picocolors/picocolors.js
var nS = y((_et, sS) => {
  var cAe = require("tty"), fAe = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.
  argv.includes("--color") || process.platform === "win32" || cAe.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env), Xt = /* @__PURE__ */ i(
  (e, t, r = e) => (s) => {
    let n = "" + s, a = n.indexOf(t, e.length);
    return ~a ? e + h3(n, t, r, a) + t : e + n + t;
  }, "formatter"), h3 = /* @__PURE__ */ i((e, t, r, s) => {
    let n = e.substring(0, s) + r, a = e.substring(s + t.length), o = a.indexOf(t);
    return ~o ? n + h3(a, t, r, o) : n + a;
  }, "replaceClose"), m3 = /* @__PURE__ */ i((e = fAe) => ({
    isColorSupported: e,
    reset: e ? (t) => `\x1B[0m${t}\x1B[0m` : String,
    bold: e ? Xt("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
    dim: e ? Xt("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
    italic: e ? Xt("\x1B[3m", "\x1B[23m") : String,
    underline: e ? Xt("\x1B[4m", "\x1B[24m") : String,
    inverse: e ? Xt("\x1B[7m", "\x1B[27m") : String,
    hidden: e ? Xt("\x1B[8m", "\x1B[28m") : String,
    strikethrough: e ? Xt("\x1B[9m", "\x1B[29m") : String,
    black: e ? Xt("\x1B[30m", "\x1B[39m") : String,
    red: e ? Xt("\x1B[31m", "\x1B[39m") : String,
    green: e ? Xt("\x1B[32m", "\x1B[39m") : String,
    yellow: e ? Xt("\x1B[33m", "\x1B[39m") : String,
    blue: e ? Xt("\x1B[34m", "\x1B[39m") : String,
    magenta: e ? Xt("\x1B[35m", "\x1B[39m") : String,
    cyan: e ? Xt("\x1B[36m", "\x1B[39m") : String,
    white: e ? Xt("\x1B[37m", "\x1B[39m") : String,
    gray: e ? Xt("\x1B[90m", "\x1B[39m") : String,
    bgBlack: e ? Xt("\x1B[40m", "\x1B[49m") : String,
    bgRed: e ? Xt("\x1B[41m", "\x1B[49m") : String,
    bgGreen: e ? Xt("\x1B[42m", "\x1B[49m") : String,
    bgYellow: e ? Xt("\x1B[43m", "\x1B[49m") : String,
    bgBlue: e ? Xt("\x1B[44m", "\x1B[49m") : String,
    bgMagenta: e ? Xt("\x1B[45m", "\x1B[49m") : String,
    bgCyan: e ? Xt("\x1B[46m", "\x1B[49m") : String,
    bgWhite: e ? Xt("\x1B[47m", "\x1B[49m") : String
  }), "createColors");
  sS.exports = m3();
  sS.exports.createColors = m3;
});

// ../node_modules/escape-string-regexp/index.js
var g3 = y((Net, y3) => {
  "use strict";
  var pAe = /[|\\{}()[\]^$+*?.]/g;
  y3.exports = function(e) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return e.replace(pAe, "\\$&");
  };
});

// ../node_modules/@babel/highlight/node_modules/color-name/index.js
var E3 = y((Ret, b3) => {
  "use strict";
  b3.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var iS = y((ket, x3) => {
  var so = E3(), T3 = {};
  for (Ld in so)
    so.hasOwnProperty(Ld) && (T3[so[Ld]] = Ld);
  var Ld, Ae = x3.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (as in Ae)
    if (Ae.hasOwnProperty(as)) {
      if (!("channels" in Ae[as]))
        throw new Error("missing channels property: " + as);
      if (!("labels" in Ae[as]))
        throw new Error("missing channel labels property: " + as);
      if (Ae[as].labels.length !== Ae[as].channels)
        throw new Error("channel and label counts mismatch: " + as);
      v3 = Ae[as].channels, S3 = Ae[as].labels, delete Ae[as].channels, delete Ae[as].labels, Object.defineProperty(Ae[as], "channels", { value: v3 }),
      Object.defineProperty(Ae[as], "labels", { value: S3 });
    }
  var v3, S3, as;
  Ae.rgb.hsl = function(e) {
    var t = e[0] / 255, r = e[1] / 255, s = e[2] / 255, n = Math.min(t, r, s), a = Math.max(t, r, s), o = a - n, l, u, c;
    return a === n ? l = 0 : t === a ? l = (r - s) / o : r === a ? l = 2 + (s - t) / o : s === a && (l = 4 + (t - r) / o), l = Math.min(l * 60,
    360), l < 0 && (l += 360), c = (n + a) / 2, a === n ? u = 0 : c <= 0.5 ? u = o / (a + n) : u = o / (2 - a - n), [l, u * 100, c * 100];
  };
  Ae.rgb.hsv = function(e) {
    var t, r, s, n, a, o = e[0] / 255, l = e[1] / 255, u = e[2] / 255, c = Math.max(o, l, u), f = c - Math.min(o, l, u), p = /* @__PURE__ */ i(
    function(d) {
      return (c - d) / 6 / f + 1 / 2;
    }, "diffc");
    return f === 0 ? n = a = 0 : (a = f / c, t = p(o), r = p(l), s = p(u), o === c ? n = s - r : l === c ? n = 1 / 3 + t - s : u === c && (n =
    2 / 3 + r - t), n < 0 ? n += 1 : n > 1 && (n -= 1)), [
      n * 360,
      a * 100,
      c * 100
    ];
  };
  Ae.rgb.hwb = function(e) {
    var t = e[0], r = e[1], s = e[2], n = Ae.rgb.hsl(e)[0], a = 1 / 255 * Math.min(t, Math.min(r, s));
    return s = 1 - 1 / 255 * Math.max(t, Math.max(r, s)), [n, a * 100, s * 100];
  };
  Ae.rgb.cmyk = function(e) {
    var t = e[0] / 255, r = e[1] / 255, s = e[2] / 255, n, a, o, l;
    return l = Math.min(1 - t, 1 - r, 1 - s), n = (1 - t - l) / (1 - l) || 0, a = (1 - r - l) / (1 - l) || 0, o = (1 - s - l) / (1 - l) || 0,
    [n * 100, a * 100, o * 100, l * 100];
  };
  function dAe(e, t) {
    return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2);
  }
  i(dAe, "comparativeDistance");
  Ae.rgb.keyword = function(e) {
    var t = T3[e];
    if (t)
      return t;
    var r = 1 / 0, s;
    for (var n in so)
      if (so.hasOwnProperty(n)) {
        var a = so[n], o = dAe(e, a);
        o < r && (r = o, s = n);
      }
    return s;
  };
  Ae.keyword.rgb = function(e) {
    return so[e];
  };
  Ae.rgb.xyz = function(e) {
    var t = e[0] / 255, r = e[1] / 255, s = e[2] / 255;
    t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, s = s >
    0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
    var n = t * 0.4124 + r * 0.3576 + s * 0.1805, a = t * 0.2126 + r * 0.7152 + s * 0.0722, o = t * 0.0193 + r * 0.1192 + s * 0.9505;
    return [n * 100, a * 100, o * 100];
  };
  Ae.rgb.lab = function(e) {
    var t = Ae.rgb.xyz(e), r = t[0], s = t[1], n = t[2], a, o, l;
    return r /= 95.047, s /= 100, n /= 108.883, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 /
    3) : 7.787 * s + 16 / 116, n = n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, a = 116 * s - 16, o = 500 * (r - s), l = 200 * (s -
    n), [a, o, l];
  };
  Ae.hsl.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, s = e[2] / 100, n, a, o, l, u;
    if (r === 0)
      return u = s * 255, [u, u, u];
    s < 0.5 ? a = s * (1 + r) : a = s + r - s * r, n = 2 * s - a, l = [0, 0, 0];
    for (var c = 0; c < 3; c++)
      o = t + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? u = n + (a - n) * 6 * o : 2 * o < 1 ? u = a : 3 * o < 2 ? u = n + (a -
      n) * (2 / 3 - o) * 6 : u = n, l[c] = u * 255;
    return l;
  };
  Ae.hsl.hsv = function(e) {
    var t = e[0], r = e[1] / 100, s = e[2] / 100, n = r, a = Math.max(s, 0.01), o, l;
    return s *= 2, r *= s <= 1 ? s : 2 - s, n *= a <= 1 ? a : 2 - a, l = (s + r) / 2, o = s === 0 ? 2 * n / (a + n) : 2 * r / (s + r), [t, o *
    100, l * 100];
  };
  Ae.hsv.rgb = function(e) {
    var t = e[0] / 60, r = e[1] / 100, s = e[2] / 100, n = Math.floor(t) % 6, a = t - Math.floor(t), o = 255 * s * (1 - r), l = 255 * s * (1 -
    r * a), u = 255 * s * (1 - r * (1 - a));
    switch (s *= 255, n) {
      case 0:
        return [s, u, o];
      case 1:
        return [l, s, o];
      case 2:
        return [o, s, u];
      case 3:
        return [o, l, s];
      case 4:
        return [u, o, s];
      case 5:
        return [s, o, l];
    }
  };
  Ae.hsv.hsl = function(e) {
    var t = e[0], r = e[1] / 100, s = e[2] / 100, n = Math.max(s, 0.01), a, o, l;
    return l = (2 - r) * s, a = (2 - r) * n, o = r * n, o /= a <= 1 ? a : 2 - a, o = o || 0, l /= 2, [t, o * 100, l * 100];
  };
  Ae.hwb.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, s = e[2] / 100, n = r + s, a, o, l, u;
    n > 1 && (r /= n, s /= n), a = Math.floor(6 * t), o = 1 - s, l = 6 * t - a, a & 1 && (l = 1 - l), u = r + l * (o - r);
    var c, f, p;
    switch (a) {
      default:
      case 6:
      case 0:
        c = o, f = u, p = r;
        break;
      case 1:
        c = u, f = o, p = r;
        break;
      case 2:
        c = r, f = o, p = u;
        break;
      case 3:
        c = r, f = u, p = o;
        break;
      case 4:
        c = u, f = r, p = o;
        break;
      case 5:
        c = o, f = r, p = u;
        break;
    }
    return [c * 255, f * 255, p * 255];
  };
  Ae.cmyk.rgb = function(e) {
    var t = e[0] / 100, r = e[1] / 100, s = e[2] / 100, n = e[3] / 100, a, o, l;
    return a = 1 - Math.min(1, t * (1 - n) + n), o = 1 - Math.min(1, r * (1 - n) + n), l = 1 - Math.min(1, s * (1 - n) + n), [a * 255, o * 255,
    l * 255];
  };
  Ae.xyz.rgb = function(e) {
    var t = e[0] / 100, r = e[1] / 100, s = e[2] / 100, n, a, o;
    return n = t * 3.2406 + r * -1.5372 + s * -0.4986, a = t * -0.9689 + r * 1.8758 + s * 0.0415, o = t * 0.0557 + r * -0.204 + s * 1.057, n =
    n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92, o =
    o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, n = Math.min(Math.max(0, n), 1), a = Math.min(Math.max(0, a), 1), o = Math.
    min(Math.max(0, o), 1), [n * 255, a * 255, o * 255];
  };
  Ae.xyz.lab = function(e) {
    var t = e[0], r = e[1], s = e[2], n, a, o;
    return t /= 95.047, r /= 100, s /= 108.883, t = t > 8856e-6 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 /
    3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, n = 116 * r - 16, a = 500 * (t - r), o = 200 * (r -
    s), [n, a, o];
  };
  Ae.lab.xyz = function(e) {
    var t = e[0], r = e[1], s = e[2], n, a, o;
    a = (t + 16) / 116, n = r / 500 + a, o = a - s / 200;
    var l = Math.pow(a, 3), u = Math.pow(n, 3), c = Math.pow(o, 3);
    return a = l > 8856e-6 ? l : (a - 16 / 116) / 7.787, n = u > 8856e-6 ? u : (n - 16 / 116) / 7.787, o = c > 8856e-6 ? c : (o - 16 / 116) /
    7.787, n *= 95.047, a *= 100, o *= 108.883, [n, a, o];
  };
  Ae.lab.lch = function(e) {
    var t = e[0], r = e[1], s = e[2], n, a, o;
    return n = Math.atan2(s, r), a = n * 360 / 2 / Math.PI, a < 0 && (a += 360), o = Math.sqrt(r * r + s * s), [t, o, a];
  };
  Ae.lch.lab = function(e) {
    var t = e[0], r = e[1], s = e[2], n, a, o;
    return o = s / 360 * 2 * Math.PI, n = r * Math.cos(o), a = r * Math.sin(o), [t, n, a];
  };
  Ae.rgb.ansi16 = function(e) {
    var t = e[0], r = e[1], s = e[2], n = 1 in arguments ? arguments[1] : Ae.rgb.hsv(e)[2];
    if (n = Math.round(n / 50), n === 0)
      return 30;
    var a = 30 + (Math.round(s / 255) << 2 | Math.round(r / 255) << 1 | Math.round(t / 255));
    return n === 2 && (a += 60), a;
  };
  Ae.hsv.ansi16 = function(e) {
    return Ae.rgb.ansi16(Ae.hsv.rgb(e), e[2]);
  };
  Ae.rgb.ansi256 = function(e) {
    var t = e[0], r = e[1], s = e[2];
    if (t === r && r === s)
      return t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232;
    var n = 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(s / 255 * 5);
    return n;
  };
  Ae.ansi16.rgb = function(e) {
    var t = e % 10;
    if (t === 0 || t === 7)
      return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
    var r = (~~(e > 50) + 1) * 0.5, s = (t & 1) * r * 255, n = (t >> 1 & 1) * r * 255, a = (t >> 2 & 1) * r * 255;
    return [s, n, a];
  };
  Ae.ansi256.rgb = function(e) {
    if (e >= 232) {
      var t = (e - 232) * 10 + 8;
      return [t, t, t];
    }
    e -= 16;
    var r, s = Math.floor(e / 36) / 5 * 255, n = Math.floor((r = e % 36) / 6) / 5 * 255, a = r % 6 / 5 * 255;
    return [s, n, a];
  };
  Ae.rgb.hex = function(e) {
    var t = ((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255), r = t.toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  };
  Ae.hex.rgb = function(e) {
    var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t)
      return [0, 0, 0];
    var r = t[0];
    t[0].length === 3 && (r = r.split("").map(function(l) {
      return l + l;
    }).join(""));
    var s = parseInt(r, 16), n = s >> 16 & 255, a = s >> 8 & 255, o = s & 255;
    return [n, a, o];
  };
  Ae.rgb.hcg = function(e) {
    var t = e[0] / 255, r = e[1] / 255, s = e[2] / 255, n = Math.max(Math.max(t, r), s), a = Math.min(Math.min(t, r), s), o = n - a, l, u;
    return o < 1 ? l = a / (1 - o) : l = 0, o <= 0 ? u = 0 : n === t ? u = (r - s) / o % 6 : n === r ? u = 2 + (s - t) / o : u = 4 + (t - r) /
    o + 4, u /= 6, u %= 1, [u * 360, o * 100, l * 100];
  };
  Ae.hsl.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, s = 1, n = 0;
    return r < 0.5 ? s = 2 * t * r : s = 2 * t * (1 - r), s < 1 && (n = (r - 0.5 * s) / (1 - s)), [e[0], s * 100, n * 100];
  };
  Ae.hsv.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, s = t * r, n = 0;
    return s < 1 && (n = (r - s) / (1 - s)), [e[0], s * 100, n * 100];
  };
  Ae.hcg.rgb = function(e) {
    var t = e[0] / 360, r = e[1] / 100, s = e[2] / 100;
    if (r === 0)
      return [s * 255, s * 255, s * 255];
    var n = [0, 0, 0], a = t % 1 * 6, o = a % 1, l = 1 - o, u = 0;
    switch (Math.floor(a)) {
      case 0:
        n[0] = 1, n[1] = o, n[2] = 0;
        break;
      case 1:
        n[0] = l, n[1] = 1, n[2] = 0;
        break;
      case 2:
        n[0] = 0, n[1] = 1, n[2] = o;
        break;
      case 3:
        n[0] = 0, n[1] = l, n[2] = 1;
        break;
      case 4:
        n[0] = o, n[1] = 0, n[2] = 1;
        break;
      default:
        n[0] = 1, n[1] = 0, n[2] = l;
    }
    return u = (1 - r) * s, [
      (r * n[0] + u) * 255,
      (r * n[1] + u) * 255,
      (r * n[2] + u) * 255
    ];
  };
  Ae.hcg.hsv = function(e) {
    var t = e[1] / 100, r = e[2] / 100, s = t + r * (1 - t), n = 0;
    return s > 0 && (n = t / s), [e[0], n * 100, s * 100];
  };
  Ae.hcg.hsl = function(e) {
    var t = e[1] / 100, r = e[2] / 100, s = r * (1 - t) + 0.5 * t, n = 0;
    return s > 0 && s < 0.5 ? n = t / (2 * s) : s >= 0.5 && s < 1 && (n = t / (2 * (1 - s))), [e[0], n * 100, s * 100];
  };
  Ae.hcg.hwb = function(e) {
    var t = e[1] / 100, r = e[2] / 100, s = t + r * (1 - t);
    return [e[0], (s - t) * 100, (1 - s) * 100];
  };
  Ae.hwb.hcg = function(e) {
    var t = e[1] / 100, r = e[2] / 100, s = 1 - r, n = s - t, a = 0;
    return n < 1 && (a = (s - n) / (1 - n)), [e[0], n * 100, a * 100];
  };
  Ae.apple.rgb = function(e) {
    return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
  };
  Ae.rgb.apple = function(e) {
    return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
  };
  Ae.gray.rgb = function(e) {
    return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
  };
  Ae.gray.hsl = Ae.gray.hsv = function(e) {
    return [0, 0, e[0]];
  };
  Ae.gray.hwb = function(e) {
    return [0, 100, e[0]];
  };
  Ae.gray.cmyk = function(e) {
    return [0, 0, 0, e[0]];
  };
  Ae.gray.lab = function(e) {
    return [e[0], 0, 0];
  };
  Ae.gray.hex = function(e) {
    var t = Math.round(e[0] / 100 * 255) & 255, r = (t << 16) + (t << 8) + t, s = r.toString(16).toUpperCase();
    return "000000".substring(s.length) + s;
  };
  Ae.rgb.gray = function(e) {
    var t = (e[0] + e[1] + e[2]) / 3;
    return [t / 255 * 100];
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/route.js
var A3 = y((Let, P3) => {
  var Bd = iS();
  function hAe() {
    for (var e = {}, t = Object.keys(Bd), r = t.length, s = 0; s < r; s++)
      e[t[s]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return e;
  }
  i(hAe, "buildGraph");
  function mAe(e) {
    var t = hAe(), r = [e];
    for (t[e].distance = 0; r.length; )
      for (var s = r.pop(), n = Object.keys(Bd[s]), a = n.length, o = 0; o < a; o++) {
        var l = n[o], u = t[l];
        u.distance === -1 && (u.distance = t[s].distance + 1, u.parent = s, r.unshift(l));
      }
    return t;
  }
  i(mAe, "deriveBFS");
  function yAe(e, t) {
    return function(r) {
      return t(e(r));
    };
  }
  i(yAe, "link");
  function gAe(e, t) {
    for (var r = [t[e].parent, e], s = Bd[t[e].parent][e], n = t[e].parent; t[n].parent; )
      r.unshift(t[n].parent), s = yAe(Bd[t[n].parent][n], s), n = t[n].parent;
    return s.conversion = r, s;
  }
  i(gAe, "wrapConversion");
  P3.exports = function(e) {
    for (var t = mAe(e), r = {}, s = Object.keys(t), n = s.length, a = 0; a < n; a++) {
      var o = s[a], l = t[o];
      l.parent !== null && (r[o] = gAe(o, t));
    }
    return r;
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/index.js
var w3 = y((Met, C3) => {
  var aS = iS(), bAe = A3(), ml = {}, EAe = Object.keys(aS);
  function vAe(e) {
    var t = /* @__PURE__ */ i(function(r) {
      return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), e(r));
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  i(vAe, "wrapRaw");
  function SAe(e) {
    var t = /* @__PURE__ */ i(function(r) {
      if (r == null)
        return r;
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
      var s = e(r);
      if (typeof s == "object")
        for (var n = s.length, a = 0; a < n; a++)
          s[a] = Math.round(s[a]);
      return s;
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  i(SAe, "wrapRounded");
  EAe.forEach(function(e) {
    ml[e] = {}, Object.defineProperty(ml[e], "channels", { value: aS[e].channels }), Object.defineProperty(ml[e], "labels", { value: aS[e].labels });
    var t = bAe(e), r = Object.keys(t);
    r.forEach(function(s) {
      var n = t[s];
      ml[e][s] = SAe(n), ml[e][s].raw = vAe(n);
    });
  });
  C3.exports = ml;
});

// ../node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var I3 = y((qet, D3) => {
  "use strict";
  var yl = w3(), Md = /* @__PURE__ */ i((e, t) => function() {
    return `\x1B[${e.apply(yl, arguments) + t}m`;
  }, "wrapAnsi16"), jd = /* @__PURE__ */ i((e, t) => function() {
    let r = e.apply(yl, arguments);
    return `\x1B[${38 + t};5;${r}m`;
  }, "wrapAnsi256"), qd = /* @__PURE__ */ i((e, t) => function() {
    let r = e.apply(yl, arguments);
    return `\x1B[${38 + t};2;${r[0]};${r[1]};${r[2]}m`;
  }, "wrapAnsi16m");
  function TAe() {
    let e = /* @__PURE__ */ new Map(), t = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    t.color.grey = t.color.gray;
    for (let n of Object.keys(t)) {
      let a = t[n];
      for (let o of Object.keys(a)) {
        let l = a[o];
        t[o] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, a[o] = t[o], e.set(l[0], l[1]);
      }
      Object.defineProperty(t, n, {
        value: a,
        enumerable: !1
      }), Object.defineProperty(t, "codes", {
        value: e,
        enumerable: !1
      });
    }
    let r = /* @__PURE__ */ i((n) => n, "ansi2ansi"), s = /* @__PURE__ */ i((n, a, o) => [n, a, o], "rgb2rgb");
    t.color.close = "\x1B[39m", t.bgColor.close = "\x1B[49m", t.color.ansi = {
      ansi: Md(r, 0)
    }, t.color.ansi256 = {
      ansi256: jd(r, 0)
    }, t.color.ansi16m = {
      rgb: qd(s, 0)
    }, t.bgColor.ansi = {
      ansi: Md(r, 10)
    }, t.bgColor.ansi256 = {
      ansi256: jd(r, 10)
    }, t.bgColor.ansi16m = {
      rgb: qd(s, 10)
    };
    for (let n of Object.keys(yl)) {
      if (typeof yl[n] != "object")
        continue;
      let a = yl[n];
      n === "ansi16" && (n = "ansi"), "ansi16" in a && (t.color.ansi[n] = Md(a.ansi16, 0), t.bgColor.ansi[n] = Md(a.ansi16, 10)), "ansi256" in
      a && (t.color.ansi256[n] = jd(a.ansi256, 0), t.bgColor.ansi256[n] = jd(a.ansi256, 10)), "rgb" in a && (t.color.ansi16m[n] = qd(a.rgb, 0),
      t.bgColor.ansi16m[n] = qd(a.rgb, 10));
    }
    return t;
  }
  i(TAe, "assembleStyles");
  Object.defineProperty(D3, "exports", {
    enumerable: !0,
    get: TAe
  });
});

// ../node_modules/@babel/highlight/node_modules/has-flag/index.js
var O3 = y((Uet, _3) => {
  "use strict";
  _3.exports = (e, t) => {
    t = t || process.argv;
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", s = t.indexOf(r + e), n = t.indexOf("--");
    return s !== -1 && (n === -1 ? !0 : s < n);
  };
});

// ../node_modules/@babel/highlight/node_modules/supports-color/index.js
var R3 = y((Vet, N3) => {
  "use strict";
  var xAe = require("os"), pn = O3(), Mr = process.env, gl;
  pn("no-color") || pn("no-colors") || pn("color=false") ? gl = !1 : (pn("color") || pn("colors") || pn("color=true") || pn("color=always")) &&
  (gl = !0);
  "FORCE_COLOR" in Mr && (gl = Mr.FORCE_COLOR.length === 0 || parseInt(Mr.FORCE_COLOR, 10) !== 0);
  function PAe(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  i(PAe, "translateLevel");
  function AAe(e) {
    if (gl === !1)
      return 0;
    if (pn("color=16m") || pn("color=full") || pn("color=truecolor"))
      return 3;
    if (pn("color=256"))
      return 2;
    if (e && !e.isTTY && gl !== !0)
      return 0;
    let t = gl ? 1 : 0;
    if (process.platform === "win32") {
      let r = xAe.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 :
      1;
    }
    if ("CI" in Mr)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((r) => r in Mr) || Mr.CI_NAME === "codeship" ? 1 : t;
    if ("TEAMCITY_VERSION" in Mr)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Mr.TEAMCITY_VERSION) ? 1 : 0;
    if (Mr.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in Mr) {
      let r = parseInt((Mr.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Mr.TERM_PROGRAM) {
        case "iTerm.app":
          return r >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Mr.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Mr.TERM) || "COLORTERM" in
    Mr ? 1 : (Mr.TERM === "dumb", t);
  }
  i(AAe, "supportsColor");
  function oS(e) {
    let t = AAe(e);
    return PAe(t);
  }
  i(oS, "getSupportLevel");
  N3.exports = {
    supportsColor: oS,
    stdout: oS(process.stdout),
    stderr: oS(process.stderr)
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/templates.js
var M3 = y((Het, B3) => {
  "use strict";
  var CAe = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
  k3 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, wAe = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, DAe = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, IAe = /* @__PURE__ */ new Map(
  [
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function L3(e) {
    return e[0] === "u" && e.length === 5 || e[0] === "x" && e.length === 3 ? String.fromCharCode(parseInt(e.slice(1), 16)) : IAe.get(e) || e;
  }
  i(L3, "unescape");
  function _Ae(e, t) {
    let r = [], s = t.trim().split(/\s*,\s*/g), n;
    for (let a of s)
      if (!isNaN(a))
        r.push(Number(a));
      else if (n = a.match(wAe))
        r.push(n[2].replace(DAe, (o, l, u) => l ? L3(l) : u));
      else
        throw new Error(`Invalid Chalk template style argument: ${a} (in style '${e}')`);
    return r;
  }
  i(_Ae, "parseArguments");
  function OAe(e) {
    k3.lastIndex = 0;
    let t = [], r;
    for (; (r = k3.exec(e)) !== null; ) {
      let s = r[1];
      if (r[2]) {
        let n = _Ae(s, r[2]);
        t.push([s].concat(n));
      } else
        t.push([s]);
    }
    return t;
  }
  i(OAe, "parseStyle");
  function F3(e, t) {
    let r = {};
    for (let n of t)
      for (let a of n.styles)
        r[a[0]] = n.inverse ? null : a.slice(1);
    let s = e;
    for (let n of Object.keys(r))
      if (Array.isArray(r[n])) {
        if (!(n in s))
          throw new Error(`Unknown Chalk style: ${n}`);
        r[n].length > 0 ? s = s[n].apply(s, r[n]) : s = s[n];
      }
    return s;
  }
  i(F3, "buildStyle");
  B3.exports = (e, t) => {
    let r = [], s = [], n = [];
    if (t.replace(CAe, (a, o, l, u, c, f) => {
      if (o)
        n.push(L3(o));
      else if (u) {
        let p = n.join("");
        n = [], s.push(r.length === 0 ? p : F3(e, r)(p)), r.push({ inverse: l, styles: OAe(u) });
      } else if (c) {
        if (r.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        s.push(F3(e, r)(n.join(""))), n = [], r.pop();
      } else
        n.push(f);
    }), s.push(n.join("")), r.length > 0) {
      let a = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(a);
    }
    return s.join("");
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/index.js
var V3 = y((Ket, Sc) => {
  "use strict";
  var uS = g3(), br = I3(), lS = R3().stdout, NAe = M3(), q3 = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith(
  "xterm"), $3 = ["ansi", "ansi", "ansi256", "ansi16m"], U3 = /* @__PURE__ */ new Set(["gray"]), bl = /* @__PURE__ */ Object.create(null);
  function j3(e, t) {
    t = t || {};
    let r = lS ? lS.level : 0;
    e.level = t.level === void 0 ? r : t.level, e.enabled = "enabled" in t ? t.enabled : e.level > 0;
  }
  i(j3, "applyOptions");
  function vc(e) {
    if (!this || !(this instanceof vc) || this.template) {
      let t = {};
      return j3(t, e), t.template = function() {
        let r = [].slice.call(arguments);
        return FAe.apply(null, [t.template].concat(r));
      }, Object.setPrototypeOf(t, vc.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = vc, t.template;
    }
    j3(this, e);
  }
  i(vc, "Chalk");
  q3 && (br.blue.open = "\x1B[94m");
  for (let e of Object.keys(br))
    br[e].closeRe = new RegExp(uS(br[e].close), "g"), bl[e] = {
      get() {
        let t = br[e];
        return $d.call(this, this._styles ? this._styles.concat(t) : [t], this._empty, e);
      }
    };
  bl.visible = {
    get() {
      return $d.call(this, this._styles || [], !0, "visible");
    }
  };
  br.color.closeRe = new RegExp(uS(br.color.close), "g");
  for (let e of Object.keys(br.color.ansi))
    U3.has(e) || (bl[e] = {
      get() {
        let t = this.level;
        return function() {
          let s = {
            open: br.color[$3[t]][e].apply(null, arguments),
            close: br.color.close,
            closeRe: br.color.closeRe
          };
          return $d.call(this, this._styles ? this._styles.concat(s) : [s], this._empty, e);
        };
      }
    });
  br.bgColor.closeRe = new RegExp(uS(br.bgColor.close), "g");
  for (let e of Object.keys(br.bgColor.ansi)) {
    if (U3.has(e))
      continue;
    let t = "bg" + e[0].toUpperCase() + e.slice(1);
    bl[t] = {
      get() {
        let r = this.level;
        return function() {
          let n = {
            open: br.bgColor[$3[r]][e].apply(null, arguments),
            close: br.bgColor.close,
            closeRe: br.bgColor.closeRe
          };
          return $d.call(this, this._styles ? this._styles.concat(n) : [n], this._empty, e);
        };
      }
    };
  }
  var RAe = Object.defineProperties(() => {
  }, bl);
  function $d(e, t, r) {
    let s = /* @__PURE__ */ i(function() {
      return kAe.apply(s, arguments);
    }, "builder");
    s._styles = e, s._empty = t;
    let n = this;
    return Object.defineProperty(s, "level", {
      enumerable: !0,
      get() {
        return n.level;
      },
      set(a) {
        n.level = a;
      }
    }), Object.defineProperty(s, "enabled", {
      enumerable: !0,
      get() {
        return n.enabled;
      },
      set(a) {
        n.enabled = a;
      }
    }), s.hasGrey = this.hasGrey || r === "gray" || r === "grey", s.__proto__ = RAe, s;
  }
  i($d, "build");
  function kAe() {
    let e = arguments, t = e.length, r = String(arguments[0]);
    if (t === 0)
      return "";
    if (t > 1)
      for (let n = 1; n < t; n++)
        r += " " + e[n];
    if (!this.enabled || this.level <= 0 || !r)
      return this._empty ? "" : r;
    let s = br.dim.open;
    q3 && this.hasGrey && (br.dim.open = "");
    for (let n of this._styles.slice().reverse())
      r = n.open + r.replace(n.closeRe, n.open) + n.close, r = r.replace(/\r?\n/g, `${n.close}$&${n.open}`);
    return br.dim.open = s, r;
  }
  i(kAe, "applyStyle");
  function FAe(e, t) {
    if (!Array.isArray(t))
      return [].slice.call(arguments, 1).join(" ");
    let r = [].slice.call(arguments, 2), s = [t.raw[0]];
    for (let n = 1; n < t.length; n++)
      s.push(String(r[n - 1]).replace(/[{}\\]/g, "\\$&")), s.push(String(t.raw[n]));
    return NAe(e, s.join(""));
  }
  i(FAe, "chalkTag");
  Object.defineProperties(vc.prototype, bl);
  Sc.exports = vc();
  Sc.exports.supportsColor = lS;
  Sc.exports.default = Sc.exports;
});

// ../node_modules/@babel/highlight/lib/index.js
var J3 = y((Tc) => {
  "use strict";
  Object.defineProperty(Tc, "__esModule", {
    value: !0
  });
  Tc.default = VAe;
  Tc.shouldHighlight = z3;
  var W3 = d3(), H3 = rl(), fS = LAe(nS(), !0);
  function K3(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (K3 = /* @__PURE__ */ i(function(s) {
      return s ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  i(K3, "_getRequireWildcardCache");
  function LAe(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = K3(t);
    if (r && r.has(e)) return r.get(e);
    var s = { __proto__: null }, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var o = n ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = e[a];
    }
    return s.default = e, r && r.set(e, s), s;
  }
  i(LAe, "_interopRequireWildcard");
  var Y3 = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, fS.createColors)(!1) :
  fS.default, G3 = /* @__PURE__ */ i((e, t) => (r) => e(t(r)), "compose"), BAe = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of",
  "set"]);
  function MAe(e) {
    return {
      keyword: e.cyan,
      capitalized: e.yellow,
      jsxIdentifier: e.yellow,
      punctuator: e.yellow,
      number: e.magenta,
      string: e.green,
      regex: e.magenta,
      comment: e.gray,
      invalid: G3(G3(e.white, e.bgRed), e.bold)
    };
  }
  i(MAe, "getDefs");
  var jAe = /\r\n|[\n\r\u2028\u2029]/, qAe = /^[()[\]{}]$/, X3;
  {
    let e = /^[a-z][\w-]*$/i, t = /* @__PURE__ */ i(function(r, s, n) {
      if (r.type === "name") {
        if ((0, H3.isKeyword)(r.value) || (0, H3.isStrictReservedWord)(r.value, !0) || BAe.has(r.value))
          return "keyword";
        if (e.test(r.value) && (n[s - 1] === "<" || n.slice(s - 2, s) == "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && qAe.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punc\
tuator" : r.type;
    }, "getTokenType");
    X3 = /* @__PURE__ */ i(function* (r) {
      let s;
      for (; s = W3.default.exec(r); ) {
        let n = W3.matchToToken(s);
        yield {
          type: t(n, s.index, r),
          value: n.value
        };
      }
    }, "tokenize");
  }
  function $Ae(e, t) {
    let r = "";
    for (let {
      type: s,
      value: n
    } of X3(t)) {
      let a = e[s];
      a ? r += n.split(jAe).map((o) => a(o)).join(`
`) : r += n;
    }
    return r;
  }
  i($Ae, "highlightTokens");
  function z3(e) {
    return Y3.isColorSupported || e.forceColor;
  }
  i(z3, "shouldHighlight");
  var cS;
  function UAe(e) {
    if (e) {
      var t;
      return (t = cS) != null || (cS = (0, fS.createColors)(!0)), cS;
    }
    return Y3;
  }
  i(UAe, "getColors");
  function VAe(e, t = {}) {
    if (e !== "" && z3(t)) {
      let r = MAe(UAe(t.forceColor));
      return $Ae(r, e);
    } else
      return e;
  }
  i(VAe, "highlight");
  {
    let e, t;
    Tc.getChalk = ({
      forceColor: r
    }) => {
      var s;
      if ((s = e) != null || (e = V3()), r) {
        var n;
        return (n = t) != null || (t = new e.constructor({
          enabled: !0,
          level: 1
        })), t;
      }
      return e;
    };
  }
});

// ../node_modules/@babel/code-frame/lib/index.js
var xc = y((Ud) => {
  "use strict";
  Object.defineProperty(Ud, "__esModule", {
    value: !0
  });
  Ud.codeFrameColumns = sB;
  Ud.default = XAe;
  var Q3 = J3(), dS = WAe(nS(), !0);
  function rB(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (rB = /* @__PURE__ */ i(function(s) {
      return s ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  i(rB, "_getRequireWildcardCache");
  function WAe(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = rB(t);
    if (r && r.has(e)) return r.get(e);
    var s = { __proto__: null }, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var o = n ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = e[a];
    }
    return s.default = e, r && r.set(e, s), s;
  }
  i(WAe, "_interopRequireWildcard");
  var HAe = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, dS.createColors)(!1) :
  dS.default, Z3 = /* @__PURE__ */ i((e, t) => (r) => e(t(r)), "compose"), pS;
  function GAe(e) {
    if (e) {
      var t;
      return (t = pS) != null || (pS = (0, dS.createColors)(!0)), pS;
    }
    return HAe;
  }
  i(GAe, "getColors");
  var eB = !1;
  function KAe(e) {
    return {
      gutter: e.gray,
      marker: Z3(e.red, e.bold),
      message: Z3(e.red, e.bold)
    };
  }
  i(KAe, "getDefs");
  var tB = /\r\n|[\n\r\u2028\u2029]/;
  function YAe(e, t, r) {
    let s = Object.assign({
      column: 0,
      line: -1
    }, e.start), n = Object.assign({}, s, e.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, l = s.line, u = s.column, c = n.line, f = n.column, p = Math.max(l - (a + 1), 0), d = Math.min(t.length, c + o);
    l === -1 && (p = 0), c === -1 && (d = t.length);
    let m = c - l, b = {};
    if (m)
      for (let h = 0; h <= m; h++) {
        let g = h + l;
        if (!u)
          b[g] = !0;
        else if (h === 0) {
          let E = t[g - 1].length;
          b[g] = [u, E - u + 1];
        } else if (h === m)
          b[g] = [0, f];
        else {
          let E = t[g - h].length;
          b[g] = [0, E];
        }
      }
    else
      u === f ? u ? b[l] = [u, 0] : b[l] = !0 : b[l] = [u, f - u];
    return {
      start: p,
      end: d,
      markerLines: b
    };
  }
  i(YAe, "getMarkerLines");
  function sB(e, t, r = {}) {
    let s = (r.highlightCode || r.forceColor) && (0, Q3.shouldHighlight)(r), n = GAe(r.forceColor), a = KAe(n), o = /* @__PURE__ */ i((h, g) => s ?
    h(g) : g, "maybeHighlight"), l = e.split(tB), {
      start: u,
      end: c,
      markerLines: f
    } = YAe(t, l, r), p = t.start && typeof t.start.column == "number", d = String(c).length, b = (s ? (0, Q3.default)(e, r) : e).split(tB, c).
    slice(u, c).map((h, g) => {
      let E = u + 1 + g, C = ` ${` ${E}`.slice(-d)} |`, N = f[E], I = !f[E + 1];
      if (N) {
        let M = "";
        if (Array.isArray(N)) {
          let q = h.slice(0, Math.max(N[0] - 1, 0)).replace(/[^\t]/g, " "), V = N[1] || 1;
          M = [`
 `, o(a.gutter, C.replace(/\d/g, " ")), " ", q, o(a.marker, "^").repeat(V)].join(""), I && r.message && (M += " " + o(a.message, r.message));
        }
        return [o(a.marker, ">"), o(a.gutter, C), h.length > 0 ? ` ${h}` : "", M].join("");
      } else
        return ` ${o(a.gutter, C)}${h.length > 0 ? ` ${h}` : ""}`;
    }).join(`
`);
    return r.message && !p && (b = `${" ".repeat(d + 1)}${r.message}
${b}`), s ? n.reset(b) : b;
  }
  i(sB, "codeFrameColumns");
  function XAe(e, t, r, s = {}) {
    if (!eB) {
      eB = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), sB(e, {
      start: {
        column: r,
        line: t
      }
    }, s);
  }
  i(XAe, "_default");
});

// ../node_modules/@babel/parser/lib/index.js
var ao = y((kc) => {
  "use strict";
  Object.defineProperty(kc, "__esModule", {
    value: !0
  });
  function vB(e, t) {
    if (e == null) return {};
    var r = {}, s = Object.keys(e), n, a;
    for (a = 0; a < s.length; a++)
      n = s[a], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
    return r;
  }
  i(vB, "_objectWithoutPropertiesLoose");
  var Mn = class {
    static {
      i(this, "Position");
    }
    constructor(t, r, s) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = s;
    }
  }, Tl = class {
    static {
      i(this, "SourceLocation");
    }
    constructor(t, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
    }
  };
  function ls(e, t) {
    let {
      line: r,
      column: s,
      index: n
    } = e;
    return new Mn(r, s + t, n + t);
  }
  i(ls, "createPositionWithColumnOffset");
  var nB = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", zAe = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: nB
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: nB
    }
  }, iB = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Hd = /* @__PURE__ */ i(({
    type: e,
    prefix: t
  }) => e === "UpdateExpression" ? iB.UpdateExpression[String(t)] : iB[e], "toNodeDescription"), JAe = {
    AccessorIsGenerator: /* @__PURE__ */ i(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ i(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ i(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ i(({
      phase: e
    }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ i(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ i(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ i(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ i(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ i(({
      maxArgumentCount: e
    }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ i(({
      radix: e
    }) => `Expected number in radix ${e}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ i(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Invalid identifier ${e}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ i(({
      ancestor: e
    }) => `Invalid left-hand side in ${Hd(e)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ i(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${Hd(e)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ i(({
      ancestor: e
    }) => `Invalid optional chaining in the left-hand side of ${Hd(e)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ i(({
      unexpected: e
    }) => `Unexpected character '${e}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Private name #${e} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ i(({
      labelName: e
    }) => `Label '${e}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ i(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ i(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ i(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ i(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ i(({
      localName: e
    }) => `Export '${e}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Duplicate private name #${e}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ i(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ i(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ i(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ i(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, QAe = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ i(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ i(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, ZAe = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), eCe = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ i(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${e}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ i(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${Hd({
      type: e
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, tCe = ["toMessage"], rCe = ["message"];
  function aB(e, t, r) {
    Object.defineProperty(e, t, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  i(aB, "defineHidden");
  function sCe(e) {
    let {
      toMessage: t
    } = e, r = vB(e, tCe);
    return /* @__PURE__ */ i(function s(n, a) {
      let o = new SyntaxError();
      return Object.assign(o, r, {
        loc: n,
        pos: n.index
      }), "missingPlugin" in a && Object.assign(o, {
        missingPlugin: a.missingPlugin
      }), aB(o, "clone", /* @__PURE__ */ i(function(u = {}) {
        var c;
        let {
          line: f,
          column: p,
          index: d
        } = (c = u.loc) != null ? c : n;
        return s(new Mn(f, p, d), Object.assign({}, a, u.details));
      }, "clone")), aB(o, "details", a), Object.defineProperty(o, "message", {
        configurable: !0,
        get() {
          let l = `${t(a)} (${n.line}:${n.column})`;
          return this.message = l, l;
        },
        set(l) {
          Object.defineProperty(this, "message", {
            value: l,
            writable: !0
          });
        }
      }), o;
    }, "constructor");
  }
  i(sCe, "toParseErrorConstructor");
  function bi(e, t) {
    if (Array.isArray(e))
      return (s) => bi(s, e[0]);
    let r = {};
    for (let s of Object.keys(e)) {
      let n = e[s], a = typeof n == "string" ? {
        message: /* @__PURE__ */ i(() => n, "message")
      } : typeof n == "function" ? {
        message: n
      } : n, {
        message: o
      } = a, l = vB(a, rCe), u = typeof o == "string" ? () => o : o;
      r[s] = sCe(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: s,
        toMessage: u
      }, t ? {
        syntaxPlugin: t
      } : {}, l));
    }
    return r;
  }
  i(bi, "ParseErrorEnum");
  var k = Object.assign({}, bi(zAe), bi(JAe), bi(QAe), bi`pipelineOperator`(eCe)), {
    defineProperty: nCe
  } = Object, oB = /* @__PURE__ */ i((e, t) => nCe(e, t, {
    enumerable: !1,
    value: e[t]
  }), "toUnenumerable");
  function Pc(e) {
    return e.loc.start && oB(e.loc.start, "index"), e.loc.end && oB(e.loc.end, "index"), e;
  }
  i(Pc, "toESTreeLocation");
  var iCe = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "ESTreeParserMixin");
    }
    parse() {
      let r = Pc(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map(Pc)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: s
    }) {
      let n = null;
      try {
        n = new RegExp(r, s);
      } catch {
      }
      let a = this.estreeParseLiteral(n);
      return a.regex = {
        pattern: r,
        flags: s
      }, a;
    }
    parseBigIntLiteral(r) {
      let s;
      try {
        s = BigInt(r);
      } catch {
        s = null;
      }
      let n = this.estreeParseLiteral(s);
      return n.bigint = String(n.value || r), n;
    }
    parseDecimalLiteral(r) {
      let n = this.estreeParseLiteral(null);
      return n.decimal = String(n.value || r), n;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let s = r.value;
      delete r.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
      let n = r;
      return n.type = "ExpressionStatement", n.expression = s, n.directive = s.extra.rawValue, delete s.extra, n;
    }
    initFunction(r, s) {
      super.initFunction(r, s), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var s;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((s = r.expression.
      extra) != null && s.parenthesized);
    }
    parseBlockBody(r, s, n, a, o) {
      super.parseBlockBody(r, s, n, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, s, n, a, o, l) {
      this.parseMethod(s, n, a, o, l, "ClassMethod", !0), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters),
      r.body.push(s);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let s = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = s, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, s) {
      let n = super.parseLiteral(r, s);
      return n.raw = n.extra.raw, delete n.extra, n;
    }
    parseFunctionBody(r, s, n = !1) {
      super.parseFunctionBody(r, s, n), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, s, n, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, s, n, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    parseClassProperty(...r) {
      let s = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
    }
    parseClassPrivateProperty(...r) {
      let s = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = !1), s;
    }
    parseObjectMethod(r, s, n, a, o) {
      let l = super.parseObjectMethod(r, s, n, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, s, n, a) {
      let o = super.parseObjectProperty(r, s, n, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, s, n) {
      return r === "Property" ? "value" : super.isValidLVal(r, s, n);
    }
    isAssignable(r, s) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: n,
          value: a
        } = r;
        this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(a, s);
      } else
        super.toAssignable(r, s);
    }
    toAssignableObjectExpressionProp(r, s, n) {
      r.kind === "get" || r.kind === "set" ? this.raise(k.PatternHasAccessor, r.key) : r.method ? this.raise(k.PatternHasMethod, r.key) : super.
      toAssignableObjectExpressionProp(r, s, n);
    }
    finishCallExpression(r, s) {
      let n = super.finishCallExpression(r, s);
      if (n.callee.type === "Import") {
        if (n.type = "ImportExpression", n.source = n.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          n.options = (a = n.arguments[1]) != null ? a : null, n.attributes = (o = n.arguments[1]) != null ? o : null;
        }
        delete n.arguments, delete n.callee;
      }
      return n;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, s) {
      let n = this.state.lastTokStartLoc, a = super.parseExport(r, s);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, n);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, s, n, a) {
      let o = super.parseSubscript(r, s, n, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.method || r.kind === "get" || r.kind === "set";
    }
    finishNodeAt(r, s, n) {
      return Pc(super.finishNodeAt(r, s, n));
    }
    resetStartLocation(r, s) {
      super.resetStartLocation(r, s), Pc(r);
    }
    resetEndLocation(r, s = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, s), Pc(r);
    }
  }, "estree"), io = class {
    static {
      i(this, "TokContext");
    }
    constructor(t, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
    }
  }, Lt = {
    brace: new io("{"),
    j_oTag: new io("<tag"),
    j_cTag: new io("</tag"),
    j_expr: new io("<tag>...</tag>", !0)
  };
  Lt.template = new io("`", !0);
  var tt = !0, he = !0, hS = !0, Ac = !0, la = !0, aCe = !0, Xd = class {
    static {
      i(this, "ExportedTokenType");
    }
    constructor(t, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, jS = /* @__PURE__ */ new Map();
  function dt(e, t = {}) {
    t.keyword = e;
    let r = Oe(e, t);
    return jS.set(e, r), r;
  }
  i(dt, "createKeyword");
  function os(e, t) {
    return Oe(e, {
      beforeExpr: tt,
      binop: t
    });
  }
  i(os, "createBinop");
  var Ic = -1, yi = [], qS = [], $S = [], US = [], VS = [], WS = [];
  function Oe(e, t = {}) {
    var r, s, n, a;
    return ++Ic, qS.push(e), $S.push((r = t.binop) != null ? r : -1), US.push((s = t.beforeExpr) != null ? s : !1), VS.push((n = t.startsExpr) !=
    null ? n : !1), WS.push((a = t.prefix) != null ? a : !1), yi.push(new Xd(e, t)), Ic;
  }
  i(Oe, "createToken");
  function et(e, t = {}) {
    var r, s, n, a;
    return ++Ic, jS.set(e, Ic), qS.push(e), $S.push((r = t.binop) != null ? r : -1), US.push((s = t.beforeExpr) != null ? s : !1), VS.push((n =
    t.startsExpr) != null ? n : !1), WS.push((a = t.prefix) != null ? a : !1), yi.push(new Xd("name", t)), Ic;
  }
  i(et, "createKeywordLike");
  var oCe = {
    bracketL: Oe("[", {
      beforeExpr: tt,
      startsExpr: he
    }),
    bracketHashL: Oe("#[", {
      beforeExpr: tt,
      startsExpr: he
    }),
    bracketBarL: Oe("[|", {
      beforeExpr: tt,
      startsExpr: he
    }),
    bracketR: Oe("]"),
    bracketBarR: Oe("|]"),
    braceL: Oe("{", {
      beforeExpr: tt,
      startsExpr: he
    }),
    braceBarL: Oe("{|", {
      beforeExpr: tt,
      startsExpr: he
    }),
    braceHashL: Oe("#{", {
      beforeExpr: tt,
      startsExpr: he
    }),
    braceR: Oe("}"),
    braceBarR: Oe("|}"),
    parenL: Oe("(", {
      beforeExpr: tt,
      startsExpr: he
    }),
    parenR: Oe(")"),
    comma: Oe(",", {
      beforeExpr: tt
    }),
    semi: Oe(";", {
      beforeExpr: tt
    }),
    colon: Oe(":", {
      beforeExpr: tt
    }),
    doubleColon: Oe("::", {
      beforeExpr: tt
    }),
    dot: Oe("."),
    question: Oe("?", {
      beforeExpr: tt
    }),
    questionDot: Oe("?."),
    arrow: Oe("=>", {
      beforeExpr: tt
    }),
    template: Oe("template"),
    ellipsis: Oe("...", {
      beforeExpr: tt
    }),
    backQuote: Oe("`", {
      startsExpr: he
    }),
    dollarBraceL: Oe("${", {
      beforeExpr: tt,
      startsExpr: he
    }),
    templateTail: Oe("...`", {
      startsExpr: he
    }),
    templateNonTail: Oe("...${", {
      beforeExpr: tt,
      startsExpr: he
    }),
    at: Oe("@"),
    hash: Oe("#", {
      startsExpr: he
    }),
    interpreterDirective: Oe("#!..."),
    eq: Oe("=", {
      beforeExpr: tt,
      isAssign: Ac
    }),
    assign: Oe("_=", {
      beforeExpr: tt,
      isAssign: Ac
    }),
    slashAssign: Oe("_=", {
      beforeExpr: tt,
      isAssign: Ac
    }),
    xorAssign: Oe("_=", {
      beforeExpr: tt,
      isAssign: Ac
    }),
    moduloAssign: Oe("_=", {
      beforeExpr: tt,
      isAssign: Ac
    }),
    incDec: Oe("++/--", {
      prefix: la,
      postfix: aCe,
      startsExpr: he
    }),
    bang: Oe("!", {
      beforeExpr: tt,
      prefix: la,
      startsExpr: he
    }),
    tilde: Oe("~", {
      beforeExpr: tt,
      prefix: la,
      startsExpr: he
    }),
    doubleCaret: Oe("^^", {
      startsExpr: he
    }),
    doubleAt: Oe("@@", {
      startsExpr: he
    }),
    pipeline: os("|>", 0),
    nullishCoalescing: os("??", 1),
    logicalOR: os("||", 1),
    logicalAND: os("&&", 2),
    bitwiseOR: os("|", 3),
    bitwiseXOR: os("^", 4),
    bitwiseAND: os("&", 5),
    equality: os("==/!=/===/!==", 6),
    lt: os("</>/<=/>=", 7),
    gt: os("</>/<=/>=", 7),
    relational: os("</>/<=/>=", 7),
    bitShift: os("<</>>/>>>", 8),
    bitShiftL: os("<</>>/>>>", 8),
    bitShiftR: os("<</>>/>>>", 8),
    plusMin: Oe("+/-", {
      beforeExpr: tt,
      binop: 9,
      prefix: la,
      startsExpr: he
    }),
    modulo: Oe("%", {
      binop: 10,
      startsExpr: he
    }),
    star: Oe("*", {
      binop: 10
    }),
    slash: os("/", 10),
    exponent: Oe("**", {
      beforeExpr: tt,
      binop: 11,
      rightAssociative: !0
    }),
    _in: dt("in", {
      beforeExpr: tt,
      binop: 7
    }),
    _instanceof: dt("instanceof", {
      beforeExpr: tt,
      binop: 7
    }),
    _break: dt("break"),
    _case: dt("case", {
      beforeExpr: tt
    }),
    _catch: dt("catch"),
    _continue: dt("continue"),
    _debugger: dt("debugger"),
    _default: dt("default", {
      beforeExpr: tt
    }),
    _else: dt("else", {
      beforeExpr: tt
    }),
    _finally: dt("finally"),
    _function: dt("function", {
      startsExpr: he
    }),
    _if: dt("if"),
    _return: dt("return", {
      beforeExpr: tt
    }),
    _switch: dt("switch"),
    _throw: dt("throw", {
      beforeExpr: tt,
      prefix: la,
      startsExpr: he
    }),
    _try: dt("try"),
    _var: dt("var"),
    _const: dt("const"),
    _with: dt("with"),
    _new: dt("new", {
      beforeExpr: tt,
      startsExpr: he
    }),
    _this: dt("this", {
      startsExpr: he
    }),
    _super: dt("super", {
      startsExpr: he
    }),
    _class: dt("class", {
      startsExpr: he
    }),
    _extends: dt("extends", {
      beforeExpr: tt
    }),
    _export: dt("export"),
    _import: dt("import", {
      startsExpr: he
    }),
    _null: dt("null", {
      startsExpr: he
    }),
    _true: dt("true", {
      startsExpr: he
    }),
    _false: dt("false", {
      startsExpr: he
    }),
    _typeof: dt("typeof", {
      beforeExpr: tt,
      prefix: la,
      startsExpr: he
    }),
    _void: dt("void", {
      beforeExpr: tt,
      prefix: la,
      startsExpr: he
    }),
    _delete: dt("delete", {
      beforeExpr: tt,
      prefix: la,
      startsExpr: he
    }),
    _do: dt("do", {
      isLoop: hS,
      beforeExpr: tt
    }),
    _for: dt("for", {
      isLoop: hS
    }),
    _while: dt("while", {
      isLoop: hS
    }),
    _as: et("as", {
      startsExpr: he
    }),
    _assert: et("assert", {
      startsExpr: he
    }),
    _async: et("async", {
      startsExpr: he
    }),
    _await: et("await", {
      startsExpr: he
    }),
    _defer: et("defer", {
      startsExpr: he
    }),
    _from: et("from", {
      startsExpr: he
    }),
    _get: et("get", {
      startsExpr: he
    }),
    _let: et("let", {
      startsExpr: he
    }),
    _meta: et("meta", {
      startsExpr: he
    }),
    _of: et("of", {
      startsExpr: he
    }),
    _sent: et("sent", {
      startsExpr: he
    }),
    _set: et("set", {
      startsExpr: he
    }),
    _source: et("source", {
      startsExpr: he
    }),
    _static: et("static", {
      startsExpr: he
    }),
    _using: et("using", {
      startsExpr: he
    }),
    _yield: et("yield", {
      startsExpr: he
    }),
    _asserts: et("asserts", {
      startsExpr: he
    }),
    _checks: et("checks", {
      startsExpr: he
    }),
    _exports: et("exports", {
      startsExpr: he
    }),
    _global: et("global", {
      startsExpr: he
    }),
    _implements: et("implements", {
      startsExpr: he
    }),
    _intrinsic: et("intrinsic", {
      startsExpr: he
    }),
    _infer: et("infer", {
      startsExpr: he
    }),
    _is: et("is", {
      startsExpr: he
    }),
    _mixins: et("mixins", {
      startsExpr: he
    }),
    _proto: et("proto", {
      startsExpr: he
    }),
    _require: et("require", {
      startsExpr: he
    }),
    _satisfies: et("satisfies", {
      startsExpr: he
    }),
    _keyof: et("keyof", {
      startsExpr: he
    }),
    _readonly: et("readonly", {
      startsExpr: he
    }),
    _unique: et("unique", {
      startsExpr: he
    }),
    _abstract: et("abstract", {
      startsExpr: he
    }),
    _declare: et("declare", {
      startsExpr: he
    }),
    _enum: et("enum", {
      startsExpr: he
    }),
    _module: et("module", {
      startsExpr: he
    }),
    _namespace: et("namespace", {
      startsExpr: he
    }),
    _interface: et("interface", {
      startsExpr: he
    }),
    _type: et("type", {
      startsExpr: he
    }),
    _opaque: et("opaque", {
      startsExpr: he
    }),
    name: Oe("name", {
      startsExpr: he
    }),
    string: Oe("string", {
      startsExpr: he
    }),
    num: Oe("num", {
      startsExpr: he
    }),
    bigint: Oe("bigint", {
      startsExpr: he
    }),
    decimal: Oe("decimal", {
      startsExpr: he
    }),
    regexp: Oe("regexp", {
      startsExpr: he
    }),
    privateName: Oe("#name", {
      startsExpr: he
    }),
    eof: Oe("eof"),
    jsxName: Oe("jsxName"),
    jsxText: Oe("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: Oe("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: Oe("jsxTagEnd"),
    placeholder: Oe("%%", {
      startsExpr: !0
    })
  };
  function Tt(e) {
    return e >= 93 && e <= 132;
  }
  i(Tt, "tokenIsIdentifier");
  function lCe(e) {
    return e <= 92;
  }
  i(lCe, "tokenKeywordOrIdentifierIsKeyword");
  function dn(e) {
    return e >= 58 && e <= 132;
  }
  i(dn, "tokenIsKeywordOrIdentifier");
  function SB(e) {
    return e >= 58 && e <= 136;
  }
  i(SB, "tokenIsLiteralPropertyName");
  function uCe(e) {
    return US[e];
  }
  i(uCe, "tokenComesBeforeExpression");
  function ES(e) {
    return VS[e];
  }
  i(ES, "tokenCanStartExpression");
  function cCe(e) {
    return e >= 29 && e <= 33;
  }
  i(cCe, "tokenIsAssignment");
  function lB(e) {
    return e >= 129 && e <= 131;
  }
  i(lB, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function fCe(e) {
    return e >= 90 && e <= 92;
  }
  i(fCe, "tokenIsLoop");
  function HS(e) {
    return e >= 58 && e <= 92;
  }
  i(HS, "tokenIsKeyword");
  function pCe(e) {
    return e >= 39 && e <= 59;
  }
  i(pCe, "tokenIsOperator");
  function dCe(e) {
    return e === 34;
  }
  i(dCe, "tokenIsPostfix");
  function hCe(e) {
    return WS[e];
  }
  i(hCe, "tokenIsPrefix");
  function mCe(e) {
    return e >= 121 && e <= 123;
  }
  i(mCe, "tokenIsTSTypeOperator");
  function yCe(e) {
    return e >= 124 && e <= 130;
  }
  i(yCe, "tokenIsTSDeclarationStart");
  function fa(e) {
    return qS[e];
  }
  i(fa, "tokenLabelName");
  function Gd(e) {
    return $S[e];
  }
  i(Gd, "tokenOperatorPrecedence");
  function gCe(e) {
    return e === 57;
  }
  i(gCe, "tokenIsRightAssociative");
  function zd(e) {
    return e >= 24 && e <= 25;
  }
  i(zd, "tokenIsTemplate");
  function mi(e) {
    return yi[e];
  }
  i(mi, "getExportedToken");
  yi[8].updateContext = (e) => {
    e.pop();
  }, yi[5].updateContext = yi[7].updateContext = yi[23].updateContext = (e) => {
    e.push(Lt.brace);
  }, yi[22].updateContext = (e) => {
    e[e.length - 1] === Lt.template ? e.pop() : e.push(Lt.template);
  }, yi[142].updateContext = (e) => {
    e.push(Lt.j_expr, Lt.j_oTag);
  };
  var GS = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  TB = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", bCe = new RegExp("[" + GS + "]"), ECe = new RegExp("[" + GS + TB + "\
]");
  GS = TB = null;
  var xB = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], vCe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function vS(e, t) {
    let r = 65536;
    for (let s = 0, n = t.length; s < n; s += 2) {
      if (r += t[s], r > e) return !1;
      if (r += t[s + 1], r >= e) return !0;
    }
    return !1;
  }
  i(vS, "isInAstralSet");
  function gi(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && bCe.test(String.fromCharCode(e)) :
    vS(e, xB);
  }
  i(gi, "isIdentifierStart");
  function vl(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && ECe.test(
    String.fromCharCode(e)) : vS(e, xB) || vS(e, vCe);
  }
  i(vl, "isIdentifierChar");
  var KS = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, SCe = new Set(KS.keyword), TCe = new Set(KS.strict), xCe = new Set(KS.strictBind);
  function PB(e, t) {
    return t && e === "await" || e === "enum";
  }
  i(PB, "isReservedWord");
  function AB(e, t) {
    return PB(e, t) || TCe.has(e);
  }
  i(AB, "isStrictReservedWord");
  function CB(e) {
    return xCe.has(e);
  }
  i(CB, "isStrictBindOnlyReservedWord");
  function wB(e, t) {
    return AB(e, t) || CB(e);
  }
  i(wB, "isStrictBindReservedWord");
  function PCe(e) {
    return SCe.has(e);
  }
  i(PCe, "isKeyword");
  function ACe(e, t, r) {
    return e === 64 && t === 64 && gi(r);
  }
  i(ACe, "isIteratorStart");
  var CCe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function wCe(e) {
    return CCe.has(e);
  }
  i(wCe, "canBeReservedWord");
  var Oc = class {
    static {
      i(this, "Scope");
    }
    constructor(t) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
    }
  }, Nc = class {
    static {
      i(this, "ScopeHandler");
    }
    constructor(t, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let t = this.currentThisScopeFlags();
      return (t & 64) > 0 && (t & 2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new Oc(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
    }
    declareName(t, r, s) {
      let n = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(n, t, r, s);
        let a = n.names.get(t) || 0;
        r & 16 ? a = a | 4 : (n.firstLexicalName || (n.firstLexicalName = t), a = a | 2), n.names.set(t, a), r & 8 && this.maybeExportDefined(
        n, t);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (n = this.scopeStack[a], this.checkRedeclarationInScope(n, t, r, s), n.names.set(
        t, (n.names.get(t) || 0) | 1), this.maybeExportDefined(n, t), !(n.flags & 387)); --a)
          ;
      this.parser.inModule && n.flags & 1 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, r) {
      this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(t, r, s, n) {
      this.isRedeclaredInScope(t, r, s) && this.parser.raise(k.VarRedeclaration, n, {
        identifierName: r
      });
    }
    isRedeclaredInScope(t, r, s) {
      if (!(s & 1)) return !1;
      if (s & 8)
        return t.names.has(r);
      let n = t.names.get(r);
      return s & 16 ? (n & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (n & 1) > 0 : (n & 2) > 0 && !(t.flags & 8 && t.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(t) && (n & 4) > 0;
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, SS = class extends Oc {
    static {
      i(this, "FlowScope");
    }
    constructor(...t) {
      super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, TS = class extends Nc {
    static {
      i(this, "FlowScopeHandler");
    }
    createScope(t) {
      return new SS(t);
    }
    declareName(t, r, s) {
      let n = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(n, t, r, s), this.maybeExportDefined(n, t), n.declareFunctions.add(t);
        return;
      }
      super.declareName(t, r, s);
    }
    isRedeclaredInScope(t, r, s) {
      if (super.isRedeclaredInScope(t, r, s)) return !0;
      if (s & 2048 && !t.declareFunctions.has(r)) {
        let n = t.names.get(r);
        return (n & 4) > 0 || (n & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }, xS = class {
    static {
      i(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        let [r, s] = t;
        if (!this.hasPlugin(r))
          return !1;
        let n = this.plugins.get(r);
        for (let a of Object.keys(s))
          if (n?.[a] !== s[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(t, r) {
      var s;
      return (s = this.plugins.get(t)) == null ? void 0 : s[r];
    }
  };
  function DB(e, t) {
    e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
  }
  i(DB, "setTrailingComments");
  function DCe(e, t) {
    e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
  }
  i(DCe, "setLeadingComments");
  function Rc(e, t) {
    e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
  }
  i(Rc, "setInnerComments");
  function Cc(e, t, r) {
    let s = null, n = t.length;
    for (; s === null && n > 0; )
      s = t[--n];
    s === null || s.start > r.start ? Rc(e, r.comments) : DB(s, r.comments);
  }
  i(Cc, "adjustInnerComments");
  var PS = class extends xS {
    static {
      i(this, "CommentsParser");
    }
    addComment(t) {
      this.filename && (t.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length != r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
    }
    processComment(t) {
      let {
        commentStack: r
      } = this.state, s = r.length;
      if (s === 0) return;
      let n = s - 1, a = r[n];
      a.start === t.end && (a.leadingNode = t, n--);
      let {
        start: o
      } = t;
      for (; n >= 0; n--) {
        let l = r[n], u = l.end;
        if (u > o)
          l.containingNode = t, this.finalizeComment(l), r.splice(n, 1);
        else {
          u === o && (l.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      let {
        comments: r
      } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && DB(t.leadingNode, r), t.trailingNode !== null && DCe(t.trailingNode, r);
      else {
        let {
          containingNode: s,
          start: n
        } = t;
        if (this.input.charCodeAt(n - 1) === 44)
          switch (s.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Cc(s, s.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Cc(s, s.arguments, t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Cc(s, s.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Cc(s, s.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Cc(s, s.specifiers, t);
              break;
            default:
              Rc(s, r);
          }
        else
          Rc(s, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: t
      } = this.state;
      for (let r = t.length - 1; r >= 0; r--)
        this.finalizeComment(t[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      if (s === 0) return;
      let n = r[s - 1];
      n.leadingNode === t && (n.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      s !== 0 && (r[s - 1].trailingNode === t ? r[s - 1].trailingNode = null : s >= 2 && r[s - 2].trailingNode === t && (r[s - 2].trailingNode =
      null));
    }
    takeSurroundingComments(t, r, s) {
      let {
        commentStack: n
      } = this.state, a = n.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = n[o], u = l.end;
        if (l.start === s)
          l.leadingNode = t;
        else if (u === r)
          l.trailingNode = t;
        else if (u < r)
          break;
      }
    }
  }, IB = /\r\n?|[\n\u2028\u2029]/, Vd = new RegExp(IB.source, "g");
  function _c(e) {
    switch (e) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  i(_c, "isNewLine");
  var mS = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Kd = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, uB = new RegExp("(?=(" + Kd.source + "))\\\
1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function ICe(e) {
    switch (e) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  i(ICe, "isWhitespace");
  var AS = class e {
    static {
      i(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Lt.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(t) {
      t ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: t,
      sourceType: r,
      startLine: s,
      startColumn: n
    }) {
      this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.curLine = s, this.lineStart = -n, this.startLoc = this.endLoc = new Mn(
      s, n, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(t) {
      t ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(t) {
      t ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(t) {
      t ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(t) {
      t ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(t) {
      t ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(t) {
      t ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(t) {
      t ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(t) {
      t ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(t) {
      t ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(t) {
      t ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(t) {
      t ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new Mn(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let t = new e();
      return t.flags = this.flags, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc,
      t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen,
      t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.
      end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
    }
  }, _Ce = /* @__PURE__ */ i(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), cB = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Wd = {
    bin: /* @__PURE__ */ i((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ i((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ i((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ i((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function fB(e, t, r, s, n, a) {
    let o = r, l = s, u = n, c = "", f = null, p = r, {
      length: d
    } = t;
    for (; ; ) {
      if (r >= d) {
        a.unterminated(o, l, u), c += t.slice(p, r);
        break;
      }
      let m = t.charCodeAt(r);
      if (OCe(e, m, t, r)) {
        c += t.slice(p, r);
        break;
      }
      if (m === 92) {
        c += t.slice(p, r);
        let b = NCe(t, r, s, n, e === "template", a);
        b.ch === null && !f ? f = {
          pos: r,
          lineStart: s,
          curLine: n
        } : c += b.ch, {
          pos: r,
          lineStart: s,
          curLine: n
        } = b, p = r;
      } else m === 8232 || m === 8233 ? (++r, ++n, s = r) : m === 10 || m === 13 ? e === "template" ? (c += t.slice(p, r) + `
`, ++r, m === 13 && t.charCodeAt(r) === 10 && ++r, ++n, p = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: f,
      lineStart: s,
      curLine: n,
      containsInvalid: !!f
    };
  }
  i(fB, "readStringContents");
  function OCe(e, t, r, s) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(s + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  i(OCe, "isStringEnd");
  function NCe(e, t, r, s, n, a) {
    let o = !n;
    t++;
    let l = /* @__PURE__ */ i((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = CS(e, t, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = OB(e, t, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(t - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, p = e.slice(c, t + 2).match(/^[0-7]+/)[0], d = parseInt(p, 8);
          d > 255 && (p = p.slice(0, -1), d = parseInt(p, 8)), t += p.length - 1;
          let m = e.charCodeAt(t);
          if (p !== "0" || m === 56 || m === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(d));
        }
        return l(String.fromCharCode(u));
    }
  }
  i(NCe, "readEscapedChar");
  function CS(e, t, r, s, n, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = _B(e, t, r, s, 16, n, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  i(CS, "readHexChar");
  function _B(e, t, r, s, n, a, o, l, u, c) {
    let f = t, p = n === 16 ? cB.hex : cB.decBinOct, d = n === 16 ? Wd.hex : n === 10 ? Wd.dec : n === 8 ? Wd.oct : Wd.bin, m = !1, b = 0;
    for (let h = 0, g = a ?? 1 / 0; h < g; ++h) {
      let E = e.charCodeAt(t), D;
      if (E === 95 && l !== "bail") {
        let C = e.charCodeAt(t - 1), N = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(N) || !d(N) || p.has(C) || p.has(N)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, s);
        }
        ++t;
        continue;
      }
      if (E >= 97 ? D = E - 97 + 10 : E >= 65 ? D = E - 65 + 10 : _Ce(E) ? D = E - 48 : D = 1 / 0, D >= n) {
        if (D <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (D <= 9 && u.invalidDigit(t, r, s, n))
          D = 0;
        else if (o)
          D = 0, m = !0;
        else
          break;
      }
      ++t, b = b * n + D;
    }
    return t === f || a != null && t - f !== a || m ? {
      n: null,
      pos: t
    } : {
      n: b,
      pos: t
    };
  }
  i(_B, "readInt");
  function OB(e, t, r, s, n, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = CS(e, t, r, s, e.indexOf("}", t) - t, !0, n, a), ++t, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(t, r, s);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = CS(e, t, r, s, 4, !1, n, a));
    return {
      code: l,
      pos: t
    };
  }
  i(OB, "readCodePoint");
  function wc(e, t, r) {
    return new Mn(r, e - t, e);
  }
  i(wc, "buildPosition");
  var RCe = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Bn = class {
    static {
      i(this, "Token");
    }
    constructor(t) {
      this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new Tl(t.startLoc, t.endLoc);
    }
  }, wS = class extends PS {
    static {
      i(this, "Tokenizer");
    }
    constructor(t, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ i((s, n, a, o) => this.options.errorRecovery ? (this.raise(k.InvalidDigit, wc(s, n, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(k.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(k.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(k.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(k.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ i((s, n, a) => {
          this.recordStrictModeErrors(k.StrictNumericEscape, wc(s, n, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ i((s, n, a) => {
          throw this.raise(k.UnterminatedString, wc(s - 1, n, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(k.StrictNumericEscape),
        unterminated: /* @__PURE__ */ i((s, n, a) => {
          throw this.raise(k.UnterminatedTemplate, wc(s, n, a));
        }, "unterminated")
      }), this.state = new AS(), this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Bn(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), !0) : !1;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return {
        pos: t.pos,
        value: null,
        type: t.type,
        start: t.start,
        end: t.end,
        context: [this.curContext()],
        inType: t.inType,
        startLoc: t.startLoc,
        lastTokEndLoc: t.lastTokEndLoc,
        curLine: t.curLine,
        lineStart: t.lineStart,
        curPosition: t.curPosition
      };
    }
    lookahead() {
      let t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = t, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return mS.lastIndex = t, mS.test(this.input) ? mS.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(t) {
      return Kd.lastIndex = t, Kd.test(this.input) ? Kd.lastIndex : t;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(t) {
      let r = this.input.charCodeAt(t);
      if ((r & 64512) === 55296 && ++t < this.input.length) {
        let s = this.input.charCodeAt(t);
        (s & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (s & 1023));
      }
      return r;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach(([r, s]) => this.raise(r, s)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(t) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let s = this.state.pos, n = this.input.indexOf(t, s + 2);
      if (n === -1)
        throw this.raise(k.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = n + t.length, Vd.lastIndex = s + 2; Vd.test(this.input) && Vd.lastIndex <= n; )
        ++this.state.curLine, this.state.lineStart = Vd.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(s + 2, n),
        start: s,
        end: n + t.length,
        loc: new Tl(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(t) {
      let r = this.state.pos, s;
      this.isLookahead || (s = this.state.curPosition());
      let n = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !_c(n) && ++this.state.pos < this.length; )
          n = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + t, a),
        start: r,
        end: a,
        loc: new Tl(s, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let t = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let s = this.input.charCodeAt(this.state.pos);
        switch (s) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let n = this.skipBlockComment("*/");
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
                break;
              }
              case 47: {
                let n = this.skipLineComment(2);
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (ICe(s))
              ++this.state.pos;
            else if (s === 45 && !this.inModule && this.options.annexB) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 45 && this.input.charCodeAt(n + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (s === 60 && !this.inModule && this.options.annexB) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 33 && this.input.charCodeAt(n + 2) === 45 && this.input.charCodeAt(n + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let s = this.state.pos, n = {
          start: t,
          end: s,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(n);
      }
    }
    finishToken(t, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let s = this.state.type;
      this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(s);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let t = this.state.pos + 1, r = this.codePointAtPos(t);
      if (r >= 48 && r <= 57)
        throw this.raise(k.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? k.RecordExpressionHashIncorrectStartSyntaxType : k.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else gi(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(!0);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !_c(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      let s = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, s), !0;
    }
    readToken_mult_modulo(t) {
      let r = t === 42 ? 55 : 54, s = 1, n = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && n === 42 && (s++, n = this.input.charCodeAt(this.state.pos + 2), r = 57), n === 61 && !this.state.inType && (s++, r = t ===
      37 ? 33 : 30), this.finishOp(r, s);
    }
    readToken_pipe_amp(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(k.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(k.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 62) {
        let s = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + s) === 61) {
          this.finishOp(30, s + 1);
          return;
        }
        this.finishOp(52, s);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(k.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(k.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (gi(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(k.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(t)
      });
    }
    finishOp(t, r) {
      let s = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(t, s);
    }
    readRegexp() {
      let t = this.state.startLoc, r = this.state.start + 1, s, n, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(k.UnterminatedRegExp, ls(t, 1));
        let c = this.input.charCodeAt(a);
        if (_c(c))
          throw this.raise(k.UnterminatedRegExp, ls(t, 1));
        if (s)
          s = !1;
        else {
          if (c === 91)
            n = !0;
          else if (c === 93 && n)
            n = !1;
          else if (c === 47 && !n)
            break;
          s = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ i(() => ls(t, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), f = String.fromCharCode(c);
        if (RCe.has(c))
          c === 118 ? l.includes("u") && this.raise(k.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(k.IncompatibleRegExpUVFlags,
          u()), l.includes(f) && this.raise(k.DuplicateRegExpFlags, u());
        else if (vl(c) || c === 92)
          this.raise(k.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += f;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(t, r, s = !1, n = !0) {
      let {
        n: a,
        pos: o
      } = _B(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, s, n, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(t) {
      let r = this.state.curPosition(), s = !1;
      this.state.pos += 2;
      let n = this.readInt(t);
      n == null && this.raise(k.InvalidDigit, ls(r, 2), {
        radix: t
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, s = !0;
      else if (a === 109)
        throw this.raise(k.InvalidDecimal, r);
      if (gi(this.codePointAtPos(this.state.pos)))
        throw this.raise(k.NumberIdentifier, this.state.curPosition());
      if (s) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, n);
    }
    readNumber(t) {
      let r = this.state.pos, s = this.state.curPosition(), n = !1, a = !1, o = !1, l = !1, u = !1;
      !t && this.readInt(10) === null && this.raise(k.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let m = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(k.StrictOctalLiteral, s), !this.state.strict) {
          let b = m.indexOf("_");
          b > 0 && this.raise(k.ZeroDigitNumericSeparator, ls(s, b));
        }
        u = c && !/[89]/.test(m);
      }
      let f = this.input.charCodeAt(this.state.pos);
      if (f === 46 && !u && (++this.state.pos, this.readInt(10), n = !0, f = this.input.charCodeAt(this.state.pos)), (f === 69 || f === 101) &&
      !u && (f = this.input.charCodeAt(++this.state.pos), (f === 43 || f === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      k.InvalidOrMissingExponent, s), n = !0, l = !0, f = this.input.charCodeAt(this.state.pos)), f === 110 && ((n || c) && this.raise(k.InvalidBigIntLiteral,
      s), ++this.state.pos, a = !0), f === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(k.InvalidDecimal,
      s), ++this.state.pos, o = !0), gi(this.codePointAtPos(this.state.pos)))
        throw this.raise(k.NumberIdentifier, this.state.curPosition());
      let p = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, p);
        return;
      }
      if (o) {
        this.finishToken(136, p);
        return;
      }
      let d = u ? parseInt(p, 8) : parseFloat(p);
      this.finishToken(134, d);
    }
    readCodePoint(t) {
      let {
        code: r,
        pos: s
      } = OB(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
      return this.state.pos = s, r;
    }
    readString(t) {
      let {
        str: r,
        pos: s,
        curLine: n,
        lineStart: a
      } = fB(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = n, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let t = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: s,
        pos: n,
        curLine: a,
        lineStart: o
      } = fB("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = n + 1, this.state.lineStart = o, this.state.curLine = a, s && (this.state.firstInvalidTemplateEscapePos = new Mn(s.curLine,
      s.pos - s.lineStart, s.pos)), this.input.codePointAt(n) === 96 ? this.finishToken(24, s ? null : t + r + "`") : (this.state.pos++, this.
      finishToken(25, s ? null : t + r + "${"));
    }
    recordStrictModeErrors(t, r) {
      let s = r.index;
      this.state.strict && !this.state.strictErrors.has(s) ? this.raise(t, r) : this.state.strictErrors.set(s, [t, r]);
    }
    readWord1(t) {
      this.state.containsEsc = !1;
      let r = "", s = this.state.pos, n = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (vl(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(n, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === s ? gi : vl;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(k.MissingUnicodeEscape, this.state.curPosition()), n = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(k.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), n = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(n, this.state.pos);
    }
    readWord(t) {
      let r = this.readWord1(t), s = jS.get(r);
      s !== void 0 ? this.finishToken(s, fa(s)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: t
      } = this.state;
      HS(t) && this.state.containsEsc && this.raise(k.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: fa(t)
      });
    }
    raise(t, r, s = {}) {
      let n = r instanceof Mn ? r : r.loc.start, a = t(n, s);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(t, r, s = {}) {
      let n = r instanceof Mn ? r : r.loc.start, a = n.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = t(n, s);
        if (u.loc.index < a) break;
      }
      return this.raise(t, r, s);
    }
    updateContext(t) {
    }
    unexpected(t, r) {
      throw this.raise(k.UnexpectedToken, t ?? this.state.startLoc, {
        expected: r ? fa(r) : null
      });
    }
    expectPlugin(t, r) {
      if (this.hasPlugin(t))
        return !0;
      throw this.raise(k.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [t]
      });
    }
    expectOnePlugin(t) {
      if (!t.some((r) => this.hasPlugin(r)))
        throw this.raise(k.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: t
        });
    }
    errorBuilder(t) {
      return (r, s, n) => {
        this.raise(t, wc(r, s, n));
      };
    }
  }, DS = class {
    static {
      i(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, IS = class {
    static {
      i(this, "ClassScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new DS());
    }
    exit() {
      let t = this.stack.pop(), r = this.current();
      for (let [s, n] of Array.from(t.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(s) || r.undefinedPrivateNames.set(s, n) : this.parser.raise(k.InvalidPrivateFieldResolution, n, {
          identifierName: s
        });
    }
    declarePrivateName(t, r, s) {
      let {
        privateNames: n,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = n.has(t);
      if (r & 3) {
        let u = l && a.get(t);
        if (u) {
          let c = u & 4, f = r & 4, p = u & 3, d = r & 3;
          l = p === d || c !== f, l || a.delete(t);
        } else l || a.set(t, r);
      }
      l && this.parser.raise(k.PrivateNameRedeclaration, s, {
        identifierName: t
      }), n.add(t), o.delete(t);
    }
    usePrivateName(t, r) {
      let s;
      for (s of this.stack)
        if (s.privateNames.has(t)) return;
      s ? s.undefinedPrivateNames.set(t, r) : this.parser.raise(k.InvalidPrivateFieldResolution, r, {
        identifierName: t
      });
    }
  }, xl = class {
    static {
      i(this, "ExpressionScope");
    }
    constructor(t = 0) {
      this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Jd = class extends xl {
    static {
      i(this, "ArrowHeadParsingScope");
    }
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, r) {
      let s = r.index;
      this.declarationErrors.set(s, [t, r]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }, _S = class {
    static {
      i(this, "ExpressionScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [new xl()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, r) {
      let s = r.loc.start, {
        stack: n
      } = this, a = n.length - 1, o = n[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(t, s);
        else
          return;
        o = n[--a];
      }
      this.parser.raise(t, s);
    }
    recordArrowParameterBindingError(t, r) {
      let {
        stack: s
      } = this, n = s[s.length - 1], a = r.loc.start;
      if (n.isCertainlyParameterDeclaration())
        this.parser.raise(t, a);
      else if (n.canBeArrowParameterDeclaration())
        n.recordDeclarationError(t, a);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      let {
        stack: r
      } = this, s = r.length - 1, n = r[s];
      for (; n.canBeArrowParameterDeclaration(); )
        n.type === 2 && n.recordDeclarationError(k.AwaitBindingIdentifier, t), n = r[--s];
    }
    validateAsPattern() {
      let {
        stack: t
      } = this, r = t[t.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([s, n]) => {
        this.parser.raise(s, n);
        let a = t.length - 2, o = t[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(n.index), o = t[--a];
      });
    }
  };
  function kCe() {
    return new xl(3);
  }
  i(kCe, "newParameterDeclarationScope");
  function FCe() {
    return new Jd(1);
  }
  i(FCe, "newArrowHeadScope");
  function LCe() {
    return new Jd(2);
  }
  i(LCe, "newAsyncArrowScope");
  function NB() {
    return new xl();
  }
  i(NB, "newExpressionScope");
  var OS = class {
    static {
      i(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Yd(e, t) {
    return (e ? 2 : 0) | (t ? 1 : 0);
  }
  i(Yd, "functionFlags");
  var NS = class extends wS {
    static {
      i(this, "UtilParser");
    }
    addExtra(t, r, s, n = !0) {
      if (!t) return;
      let a = t.extra = t.extra || {};
      n ? a[r] = s : Object.defineProperty(a, r, {
        enumerable: n,
        value: s
      });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, r) {
      let s = t + r.length;
      if (this.input.slice(t, s) === r) {
        let n = this.input.charCodeAt(s);
        return !(vl(n) || (n & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(t) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), !0) : !1;
    }
    expectContextual(t, r) {
      if (!this.eatContextual(t)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, t);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return IB.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return uB.lastIndex = this.state.end, uB.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(t = !0) {
      (t ? this.isLineTerminator() : this.eat(13)) || this.raise(k.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(t, r) {
      this.eat(t) || this.unexpected(r, t);
    }
    tryParse(t, r = this.state.clone()) {
      let s = {
        node: null
      };
      try {
        let n = t((a = null) => {
          throw s.node = a, s;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: n,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: n,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (n) {
        let a = this.state;
        if (this.state = r, n instanceof SyntaxError)
          return {
            node: null,
            error: n,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (n === s)
          return {
            node: s.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw n;
      }
    }
    checkExpressionErrors(t, r) {
      if (!t) return !1;
      let {
        shorthandAssignLoc: s,
        doubleProtoLoc: n,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = t, l = !!s || !!n || !!o || !!a;
      if (!r)
        return l;
      s != null && this.raise(k.InvalidCoverInitializedName, s), n != null && this.raise(k.DuplicateProto, n), a != null && this.raise(k.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return SB(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes(t = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let s = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let n = this.inModule;
      this.inModule = t;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, t);
      let l = this.prodParam;
      this.prodParam = new OS();
      let u = this.classScope;
      this.classScope = new IS(this);
      let c = this.expressionScope;
      return this.expressionScope = new _S(this), () => {
        this.state.labels = r, this.exportedIdentifiers = s, this.inModule = n, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let t = 0;
      this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
    }
    checkDestructuringPrivate(t) {
      let {
        privateKeyLoc: r
      } = t;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, Sl = class {
    static {
      i(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Pl = class {
    static {
      i(this, "Node");
    }
    constructor(t, r, s) {
      this.type = "", this.start = r, this.end = 0, this.loc = new Tl(s), t != null && t.options.ranges && (this.range = [r, 0]), t != null &&
      t.filename && (this.loc.filename = t.filename);
    }
  }, YS = Pl.prototype;
  YS.__clone = function() {
    let e = new Pl(void 0, this.start, this.loc.start), t = Object.keys(this);
    for (let r = 0, s = t.length; r < s; r++) {
      let n = t[r];
      n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments" && (e[n] = this[n]);
    }
    return e;
  };
  function BCe(e) {
    return Ei(e);
  }
  i(BCe, "clonePlaceholder");
  function Ei(e) {
    let {
      type: t,
      start: r,
      end: s,
      loc: n,
      range: a,
      extra: o,
      name: l
    } = e, u = Object.create(YS);
    return u.type = t, u.start = r, u.end = s, u.loc = n, u.range = a, u.extra = o, u.name = l, t === "Placeholder" && (u.expectedNode = e.expectedNode),
    u;
  }
  i(Ei, "cloneIdentifier");
  function MCe(e) {
    let {
      type: t,
      start: r,
      end: s,
      loc: n,
      range: a,
      extra: o
    } = e;
    if (t === "Placeholder")
      return BCe(e);
    let l = Object.create(YS);
    return l.type = t, l.start = r, l.end = s, l.loc = n, l.range = a, e.raw !== void 0 ? l.raw = e.raw : l.extra = o, l.value = e.value, l;
  }
  i(MCe, "cloneStringLiteral");
  var RS = class extends NS {
    static {
      i(this, "NodeUtils");
    }
    startNode() {
      let t = this.state.startLoc;
      return new Pl(this, t.index, t);
    }
    startNodeAt(t) {
      return new Pl(this, t.index, t);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.loc.start);
    }
    finishNode(t, r) {
      return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, r, s) {
      return t.type = r, t.end = s.index, t.loc.end = s, this.options.ranges && (t.range[1] = s.index), this.options.attachComment && this.processComment(
      t), t;
    }
    resetStartLocation(t, r) {
      t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
    }
    resetEndLocation(t, r = this.state.lastTokEndLoc) {
      t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
    }
    resetStartLocationFromNode(t, r) {
      this.resetStartLocation(t, r.loc.start);
    }
  }, jCe = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), ke = bi`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ i(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ i(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ i(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ i(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ i(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ i(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ i(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ i(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ i(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function qCe(e) {
    return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "T\
ypeAlias" && e.declaration.type !== "InterfaceDeclaration");
  }
  i(qCe, "isEsModuleType");
  function pB(e) {
    return e.importKind === "type" || e.importKind === "typeof";
  }
  i(pB, "hasTypeImportKind");
  var $Ce = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function UCe(e, t) {
    let r = [], s = [];
    for (let n = 0; n < e.length; n++)
      (t(e[n], n, e) ? r : s).push(e[n]);
    return [r, s];
  }
  i(UCe, "partition");
  var VCe = /\*?\s*@((?:no)?flow)\b/, WCe = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return TS;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, s) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, s);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let s = VCe.exec(r.value);
        if (s) if (s[1] === "flow")
          this.flowPragma = "flow";
        else if (s[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let n = this.flowParseType();
      return this.state.inType = s, n;
    }
    flowParsePredicate() {
      let r = this.startNode(), s = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(ke.UnexpectedSpaceBetweenModuloChecks,
      s), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let s = null, n = null;
      return this.match(54) ? (this.state.inType = r, n = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = r, this.
      match(54) && (n = this.flowParsePredicate())), [s, n];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let s = r.id = this.parseIdentifier(), n = this.startNode(), a = this.startNode();
      this.match(47) ? n.typeParameters = this.flowParseTypeParameterDeclaration() : n.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return n.params = o.params, n.rest = o.rest, n.this = o._this, this.expect(11), [n.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(n, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      s), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, s) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (s && this.raise(ke.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, s);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let s = r.body = this.startNode(), n = s.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ke.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, ke.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), n.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
      let a = null, o = !1;
      return n.forEach((l) => {
        qCe(l) ? (a === "CommonJS" && this.raise(ke.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(ke.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(ke.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, s) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
        let n = this.state.value;
        throw this.raise(ke.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: n,
          suggestion: $Ce[n]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let s = this.flowParseTypeAlias(r);
      return s.type = "DeclareTypeAlias", s;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let s = this.flowParseOpaqueType(r, !0);
      return s.type = "DeclareOpaqueType", s;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, s) {
      if (r.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(r.id.name, s ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!s && this.eat(12));
      if (s) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: s,
        allowExact: !1,
        allowSpread: !1,
        allowProto: s,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(ke.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, s, n) {
      jCe.has(r) && this.raise(n ? ke.AssignReservedType : ke.UnexpectedReservedType, s, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, s) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, s) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, s || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let s = this.state.startLoc, n = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return n.name = o.name, n.variance = a, n.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), n.default = this.flowParseType()) :
      r && this.raise(ke.MissingTypeParamDefault, s), this.finishNode(n, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, s = this.startNode();
      s.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let n = !1;
      do {
        let a = this.flowParseTypeParameter(n);
        s.params.push(a), a.default && (n = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(s, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), s = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let n = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = n, this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), s = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, s, n) {
      return r.static = s, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = n, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, s) {
      return r.static = s, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, s) {
      let n = this.startNode();
      return r.static = s, r.value = this.flowParseObjectTypeMethodish(n), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: s,
      allowSpread: n,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, f, p = !1;
      for (s && this.match(6) ? (this.expect(6), c = 9, f = !0) : (this.expect(5), c = 8, f = !1), u.exact = f; !this.match(c); ) {
        let m = !1, b = null, h = null, g = this.startNode();
        if (a && this.isContextual(118)) {
          let D = this.lookahead();
          D.type !== 14 && D.type !== 17 && (this.next(), b = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let D = this.lookahead();
          D.type !== 14 && D.type !== 17 && (this.next(), m = !0);
        }
        let E = this.flowParseVariance();
        if (this.eat(0))
          b != null && this.unexpected(b), this.eat(0) ? (E && this.unexpected(E.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          g, m))) : u.indexers.push(this.flowParseObjectTypeIndexer(g, m, E));
        else if (this.match(10) || this.match(47))
          b != null && this.unexpected(b), E && this.unexpected(E.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(g, m));
        else {
          let D = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let N = this.lookahead();
            SB(N.type) && (D = this.state.value, this.next());
          }
          let C = this.flowParseObjectTypeProperty(g, m, b, E, D, n, o ?? !f);
          C === null ? (p = !0, h = this.state.lastTokStartLoc) : u.properties.push(C);
        }
        this.flowObjectTypeSemicolon(), h && !this.match(8) && !this.match(9) && this.raise(ke.UnexpectedExplicitInexactInObject, h);
      }
      this.expect(c), n && (u.inexact = p);
      let d = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, d;
    }
    flowParseObjectTypeProperty(r, s, n, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(ke.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(ke.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(ke.InexactVariance, a), null) : (l || this.raise(
        ke.UnexpectedSpreadType, this.state.lastTokStartLoc), n != null && this.unexpected(n), a && this.raise(ke.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = s, r.proto = n != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, n != null && this.unexpected(n), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(ke.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let s = r.kind === "get" ? 0 : 1, n = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? ke.GetterMayNotHaveThisParam : ke.SetterMayNotHaveThisParam, r.value.this), n !== s && this.
      raise(r.kind === "get" ? k.BadGetterArity : k.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(k.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, s) {
      var n;
      (n = r) != null || (r = this.state.startLoc);
      let a = s || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, s) {
      let n = this.startNodeAt(r);
      return n.typeParameters = null, n.id = this.flowParseQualifiedTypeIdentifier(r, s), this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(n, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let s = null, n = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(ke.ThisParamMustBeFirst, o), s = this.parseIdentifier(u), this.eat(17) &&
      (n = !0, u && this.raise(ke.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = s,
      o.optional = n, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let s = this.startNodeAt(r.loc.start);
      return s.name = null, s.optional = !1, s.typeAnnotation = r, this.finishNode(s, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let s = null, n = null;
      for (this.match(78) && (n = this.flowParseFunctionTypeParam(!0), n.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: s,
        _this: n
      };
    }
    flowIdentToTypeAnnotation(r, s, n) {
      switch (n.name) {
        case "any":
          return this.finishNode(s, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(n.name), this.flowParseGenericType(r, n);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, s = this.startNode(), n, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47:
          return s.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), n = this.flowParseFunctionTypeParams(), s.params =
          n.params, s.rest = n.rest, s.this = n._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), this.finishNode(
          s, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (Tt(this.state.type) || this.match(78)) {
              let u = this.lookahead().type;
              o = u !== 17 && u !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? n = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : n = this.flowParseFunctionTypeParams(),
          s.params = n.params, s.rest = n.rest, s.this = n._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), s.typeParameters =
          null, this.finishNode(s, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
            throw this.raise(ke.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(s, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(s, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (HS(this.state.type)) {
            let u = fa(this.state.type);
            return this.next(), super.createIdentifier(s, u);
          } else if (Tt(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, s = this.flowParsePrimaryType(), n = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        n = n || o, this.expect(0), !o && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = s, a.indexType = this.flowParseType(), this.expect(3), n ? (a.optional = o, s = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : s = this.finishNode(a, "IndexedAccessType"));
      }
      return s;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s = this.startNodeAt(r.loc.start);
        return s.params = [this.reinterpretTypeAsFunctionTypeParam(r)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.
        typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let s = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [s]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? s : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let s = this.flowParseIntersectionType();
      for (r.types = [s]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? s : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let s = this.flowParseUnionType();
      return this.state.inType = r, s;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, s = this.parseIdentifier();
        return this.flowParseGenericType(r, s);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let s = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, s, n = !1) {
      if (s) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, n));
        return;
      }
      super.parseFunctionBody(r, !1, n);
    }
    parseFunctionBodyAndFinish(r, s, n = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, s, n);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let n = this.lookahead();
        if (dn(n.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let n = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(n);
      }
      let s = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
    }
    parseExpressionStatement(r, s, n) {
      if (s.type === "Identifier") {
        if (s.name === "declare") {
          if (this.match(80) || Tt(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (Tt(this.state.type)) {
          if (s.name === "interface")
            return this.flowParseInterface(r);
          if (s.name === "type")
            return this.flowParseTypeAlias(r);
          if (s.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, s, n);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return lB(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return lB(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, s, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let d = this.lookaheadCharCode();
        if (d === 44 || d === 61 || d === 58 || d === 41)
          return this.setOptionalParametersError(n), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(s), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [f, p] = this.getArrowLikeExpressions(u);
      if (c || p.length > 0) {
        let d = [...o];
        if (p.length > 0) {
          this.state = a, this.state.noArrowAt = d;
          for (let m = 0; m < p.length; m++)
            d.push(p[m].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [f, p] = this.getArrowLikeExpressions(u);
        }
        c && f.length > 1 && this.raise(ke.AmbiguousConditionalArrow, a.startLoc), c && f.length === 1 && (this.state = a, d.push(f[0].start),
        this.state.noArrowAt = d, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), s = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: s
      };
    }
    getArrowLikeExpressions(r, s) {
      let n = [r], a = [];
      for (; n.length !== 0; ) {
        let o = n.pop();
        o.type === "ArrowFunctionExpression" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(o) : a.push(o), n.push(o.body)) :
        o.type === "ConditionalExpression" && (n.push(o.consequent), n.push(o.alternate));
      }
      return s ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : UCe(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var s;
      this.toAssignableList(r.params, (s = r.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, s) {
      let n;
      return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), n =
      s(), this.state.noArrowParamsConversionAt.pop()) : n = s(), n;
    }
    parseParenItem(r, s) {
      if (r = super.parseParenItem(r, s), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let n = this.startNodeAt(s);
        return n.expression = r, n.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n, "TypeCastExpression");
      }
      return r;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        s);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseOpaqueType(s, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseInterface(s);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: s
      } = this.state, n = super.maybeParseExportNamespaceSpecifier(r);
      return n && r.exportKind === "type" && this.unexpected(s), n;
    }
    parseClassId(r, s, n) {
      super.parseClassId(r, s, n), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, s, n) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, s))
          return;
        s.declare = !0;
      }
      super.parseClassMember(r, s, n), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "Property\
Definition" ? this.raise(ke.DeclareClassElement, a) : s.value && this.raise(ke.DeclareClassFieldInitializer, s.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), s = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(k.InvalidIdentifier, this.state.curPosition(), {
        identifierName: s
      }), this.finishToken(132, s);
    }
    getTokenFromCode(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : ACe(r, s, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, s) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      !s && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, s);
    }
    toAssignableList(r, s, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, n);
    }
    toReferencedList(r, s) {
      for (let a = 0; a < r.length; a++) {
        var n;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((n = o.extra) != null && n.parenthesized) && (r.length > 1 || !s) && this.raise(ke.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, s, n, a) {
      let o = super.parseArrayLike(r, s, n, a);
      return s && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, s, n) {
      return r === "TypeCastExpression" || super.isValidLVal(r, s, n);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, s, n, a, o, l) {
      if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, s, n, a, o, l), s.params && o) {
        let u = s.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(ke.ThisParamBannedInConstructor, s);
      } else if (s.type === "MethodDefinition" && o && s.value.params) {
        let u = s.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(ke.ThisParamBannedInConstructor, s);
      }
    }
    pushClassPrivateMethod(r, s, n, a) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, s, n, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let s = r.implements = [];
        do {
          let n = this.startNode();
          n.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? n.typeParameters = this.flowParseTypeParameterInstantiation() : n.
          typeParameters = null, s.push(this.finishNode(n, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let s = this.getObjectOrClassMethodParams(r);
      if (s.length > 0) {
        let n = s[0];
        this.isThisParam(n) && r.kind === "get" ? this.raise(ke.GetterMayNotHaveThisParam, n) : this.isThisParam(n) && this.raise(ke.SetterMayNotHaveThisParam,
        n);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, s, n, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let f = super.parseObjPropValue(r, s, n, a, o, l, u);
      return c && ((f.value || f).typeParameters = c), f;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(ke.PatternIsOptional, r), this.isThisParam(r) && this.raise(ke.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(ke.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(ke.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, s) {
      let n = super.parseMaybeDefault(r, s);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(ke.TypeBeforeInitializer,
      n.typeAnnotation), n;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(ke.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, s, n) {
      s.local = pB(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(s,
      n));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let s = this.lookaheadCharCode();
        return s === 123 || s === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, n, a) {
      if (super.applyImportPhase(r, s, n, a), s) {
        if (!n && this.match(65))
          return;
        r.exportKind = n === "type" ? n : "value";
      } else
        n === "type" && this.match(55) && this.unexpected(), r.importKind = n === "type" || n === "typeof" ? n : "value";
    }
    parseImportSpecifier(r, s, n, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let p = this.parseIdentifier(!0);
        u !== null && !dn(this.state.type) ? (r.imported = p, r.importKind = u, r.local = Ei(p)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && dn(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (s)
            throw this.raise(k.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = Ei(r.imported));
      }
      let f = pB(r);
      return n && f && this.raise(ke.ImportTypeShorthandOnlyInPureImport, r), (n || f) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !n && !f && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, s) {
      let n = r.kind;
      n !== "get" && n !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      if (this.match(14)) {
        let n = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = n;
      }
      return super.parseAsyncArrowFromCallExpression(r, s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, s) {
      var n;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, s), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, f = c[c.length - 1];
        (f === Lt.j_oTag || f === Lt.j_expr) && c.pop();
      }
      if ((n = o) != null && n.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, f = this.tryParse((d) => {
          var m;
          c = this.flowParseTypeParameterDeclaration();
          let b = this.forwardNoArrowParamsConversionAt(c, () => {
            let g = super.parseMaybeAssign(r, s);
            return this.resetStartLocationFromNode(g, c), g;
          });
          (m = b.extra) != null && m.parenthesized && d();
          let h = this.maybeUnwrapTypeCastExpression(b);
          return h.type !== "ArrowFunctionExpression" && d(), h.typeParameters = c, this.resetStartLocationFromNode(h, c), b;
        }, a), p = null;
        if (f.node && this.maybeUnwrapTypeCastExpression(f.node).type === "ArrowFunctionExpression") {
          if (!f.error && !f.aborted)
            return f.node.async && this.raise(ke.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), f.node;
          p = f.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (p)
          return this.state = f.failState, p;
        throw (u = o) != null && u.thrown ? o.error : f.thrown ? f.error : this.raise(ke.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse(() => {
          let n = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = n, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (s.thrown) return null;
        s.error && (this.state = s.failState), r.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, s) {
      this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = s : super.setArrowFunctionParameters(r, s);
    }
    checkParams(r, s, n, a = !0) {
      if (!(n && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(ke.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, s, n, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(r, s, n) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
        this.next();
        let a = this.startNodeAt(s);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, s, n), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, s, n);
    }
    parseSubscript(r, s, n, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, n)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(s);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!n && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(s);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, s, n, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let s = null;
      this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      s;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let s = this.startNodeAt(r);
      if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
        return super.parseArrowExpression(s, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && s === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && s === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, s) {
      let n = super.parseTopLevel(r, s);
      return this.state.hasFlowComment && this.raise(ke.UnterminatedFlowComment, this.state.curPosition()), n;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(ke.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, s = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + s)); )
        s++;
      let n = this.input.charCodeAt(s + r), a = this.input.charCodeAt(s + r + 1);
      return n === 58 && a === 58 ? s + 2 : this.input.slice(s + r, s + r + 12) === "flow-include" ? s + 12 : n === 58 && a !== 58 ? s : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(k.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: s,
      memberName: n
    }) {
      this.raise(ke.EnumBooleanMemberNotInitialized, r, {
        memberName: n,
        enumName: s
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, s) {
      return this.raise(s.explicitType ? s.explicitType === "symbol" ? ke.EnumInvalidMemberInitializerSymbolType : ke.EnumInvalidMemberInitializerPrimaryType :
      ke.EnumInvalidMemberInitializerUnknownType, r, s);
    }
    flowEnumErrorNumberMemberNotInitialized(r, s) {
      this.raise(ke.EnumNumberMemberNotInitialized, r, s);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, s) {
      this.raise(ke.EnumStringMemberInconsistentlyInitialized, r, s);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, s = /* @__PURE__ */ i(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let n = this.parseNumericLiteral(this.state.value);
          return s() ? {
            type: "number",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let n = this.parseStringLiteral(this.state.value);
          return s() ? {
            type: "string",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let n = this.parseBooleanLiteral(this.match(85));
          return s() ? {
            type: "boolean",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, s = this.parseIdentifier(!0), n = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: s,
        init: n
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, s, n) {
      let {
        explicitType: a
      } = s;
      a !== null && a !== n && this.flowEnumErrorInvalidMemberInitializer(r, s);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: s
    }) {
      let n = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), f = u.name;
        if (f === "")
          continue;
        /^[a-z]/.test(f) && this.raise(ke.EnumInvalidMemberName, u, {
          memberName: f,
          suggestion: f[0].toUpperCase() + f.slice(1),
          enumName: r
        }), n.has(f) && this.raise(ke.EnumDuplicateMemberName, u, {
          memberName: f,
          enumName: r
        }), n.add(f);
        let p = {
          enumName: r,
          explicitType: s,
          memberName: f
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, p, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, p, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, p, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, p);
          case "none":
            switch (s) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, p);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, p);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, s, {
      enumName: n
    }) {
      if (r.length === 0)
        return s;
      if (s.length === 0)
        return r;
      if (s.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return s;
      } else {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!Tt(this.state.type))
        throw this.raise(ke.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: s
      } = this.state;
      return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(ke.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: s
      }), s;
    }
    flowEnumBody(r, s) {
      let n = s.name, a = s.loc.start, o = this.flowEnumParseExplicitType({
        enumName: n
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: n,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: n
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ i(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let f = l.booleanMembers.length, p = l.numberMembers.length, d = l.stringMembers.length, m = l.defaultedMembers.length;
          if (!f && !p && !d && !m)
            return c();
          if (!f && !p)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: n
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!p && !d && f >= m) {
            for (let b of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(b.loc.start, {
                enumName: n,
                memberName: b.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!f && !d && p >= m) {
            for (let b of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(b.loc.start, {
                enumName: n,
                memberName: b.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(ke.EnumInconsistentMemberValues, a, {
              enumName: n
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let s = this.parseIdentifier();
      return r.id = s, r.body = this.flowEnumBody(this.startNode(), s), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let s = this.input.charCodeAt(r + 1);
        return s !== 60 && s !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), HCe = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, no = bi`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ i(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ i(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function ua(e) {
    return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
  }
  i(ua, "isFragment");
  function El(e) {
    if (e.type === "JSXIdentifier")
      return e.name;
    if (e.type === "JSXNamespacedName")
      return e.namespace.name + ":" + e.name.name;
    if (e.type === "JSXMemberExpression")
      return El(e.object) + "." + El(e.property);
    throw new Error("Node had unexpected type: " + e.type);
  }
  i(El, "getQualifiedJSXName");
  var GCe = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", s = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(no.UnterminatedJsxContent, this.state.startLoc);
        let n = this.input.charCodeAt(this.state.pos);
        switch (n) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              n === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(n);
              return;
            }
            r += this.input.slice(s, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(s, this.state.pos), r += this.jsxReadEntity(), s = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            _c(n) ? (r += this.input.slice(s, this.state.pos), r += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let s = this.input.charCodeAt(this.state.pos), n;
      return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, n = r ? `
` : `\r
`) : n = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, n;
    }
    jsxReadString(r) {
      let s = "", n = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(k.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (s += this.input.slice(n, this.state.pos), s += this.jsxReadEntity(), n = this.state.pos) : _c(a) ? (s += this.input.slice(
        n, this.state.pos), s += this.jsxReadNewLine(!1), n = this.state.pos) : ++this.state.pos;
      }
      s += this.input.slice(n, this.state.pos++), this.finishToken(133, s);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
        let n = this.readInt(s, void 0, !1, "bail");
        if (n !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(n);
      } else {
        let s = 0, n = !1;
        for (; s++ < 10 && this.state.pos < this.length && !(n = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (n) {
          let a = this.input.slice(r, this.state.pos), o = HCe[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, s = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (vl(r) || r === 45);
      this.finishToken(140, this.input.slice(s, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : HS(this.state.type) ? r.name = fa(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, s = this.jsxParseIdentifier();
      if (!this.eat(14)) return s;
      let n = this.startNodeAt(r);
      return n.namespace = s, n.name = this.jsxParseIdentifier(), this.finishNode(n, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, s = this.jsxParseNamespacedName();
      if (s.type === "JSXNamespacedName")
        return s;
      for (; this.eat(16); ) {
        let n = this.startNodeAt(r);
        n.object = s, n.property = this.jsxParseIdentifier(), s = this.finishNode(n, "JSXMemberExpression");
      }
      return s;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(Lt.brace), this.next(), r = this.jsxParseExpressionContainer(r, Lt.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(no.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(no.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(Lt.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, s) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let n = this.parseExpression();
        r.expression = n;
      }
      return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(Lt.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      Lt.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      s));
    }
    jsxParseOpeningElementAfterName(r) {
      let s = [];
      for (; !this.match(56) && !this.match(143); )
        s.push(this.jsxParseAttribute());
      return r.attributes = s, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      s, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let s = this.startNodeAt(r), n = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              n.push(this.jsxParseElementAt(r));
              break;
            case 141:
              n.push(this.parseExprAtom());
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(Lt.brace), this.next(), this.match(21) ? n.push(this.jsxParseSpreadChild(l)) : n.push(this.jsxParseExpressionContainer(
              l, Lt.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        ua(a) && !ua(o) && o !== null ? this.raise(no.MissingClosingTagFragment, o) : !ua(a) && ua(o) ? this.raise(no.MissingClosingTagElement,
        o, {
          openingTagName: El(a.name)
        }) : !ua(a) && !ua(o) && El(o.name) !== El(a.name) && this.raise(no.MissingClosingTagElement, o, {
          openingTagName: El(a.name)
        });
      }
      if (ua(a) ? (s.openingFragment = a, s.closingFragment = o) : (s.openingElement = a, s.closingElement = o), s.children = n, this.match(
      47))
        throw this.raise(no.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return ua(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: s
      } = this.state;
      s[s.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) &&
      this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let s = this.curContext();
      if (s === Lt.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (s === Lt.j_oTag || s === Lt.j_cTag) {
        if (gi(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && s === Lt.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: s,
        type: n
      } = this.state;
      if (n === 56 && r === 142)
        s.splice(-2, 2, Lt.j_cTag), this.state.canStartJSXElement = !1;
      else if (n === 142)
        s.push(Lt.j_oTag);
      else if (n === 143) {
        let a = s[s.length - 1];
        a === Lt.j_oTag && r === 56 || a === Lt.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === Lt.j_expr) : (this.setContext(
        Lt.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = uCe(n);
    }
  }, "jsx"), kS = class extends Oc {
    static {
      i(this, "TypeScriptScope");
    }
    constructor(...t) {
      super(...t), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, FS = class extends Nc {
    static {
      i(this, "TypeScriptScopeHandler");
    }
    constructor(...t) {
      super(...t), this.importsStack = [];
    }
    createScope(t) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new kS(t);
    }
    enter(t) {
      t == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
    }
    exit() {
      let t = super.exit();
      return t == 256 && this.importsStack.pop(), t;
    }
    hasImport(t, r) {
      let s = this.importsStack.length;
      if (this.importsStack[s - 1].has(t))
        return !0;
      if (!r && s > 1) {
        for (let n = 0; n < s - 1; n++)
          if (this.importsStack[n].has(t)) return !0;
      }
      return !1;
    }
    declareName(t, r, s) {
      if (r & 4096) {
        this.hasImport(t, !0) && this.parser.raise(k.VarRedeclaration, s, {
          identifierName: t
        }), this.importsStack[this.importsStack.length - 1].add(t);
        return;
      }
      let n = this.currentScope(), a = n.tsNames.get(t) || 0;
      if (r & 1024) {
        this.maybeExportDefined(n, t), n.tsNames.set(t, a | 16);
        return;
      }
      super.declareName(t, r, s), r & 2 && (r & 1 || (this.checkRedeclarationInScope(n, t, r, s), this.maybeExportDefined(n, t)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && n.tsNames.set(t, a);
    }
    isRedeclaredInScope(t, r, s) {
      let n = t.tsNames.get(r);
      if ((n & 2) > 0) {
        if (s & 256) {
          let a = !!(s & 512), o = (n & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return s & 128 && (n & 8) > 0 ? t.names.get(r) & 2 ? !!(s & 1) : !1 : s & 2 && (n & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, s);
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      if (this.hasImport(r)) return;
      let s = this.scopeStack.length;
      for (let n = s - 1; n >= 0; n--) {
        let o = this.scopeStack[n].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(t);
    }
  }, KCe = /* @__PURE__ */ i((e, t) => hasOwnProperty.call(e, t) && e[t], "getOwn$1"), RB = /* @__PURE__ */ i((e) => e.type === "Parenthesiz\
edExpression" ? RB(e.expression) : e, "unwrapParenthesizedExpression"), LS = class extends RS {
    static {
      i(this, "LValParser");
    }
    toAssignable(t, r = !1) {
      var s, n;
      let a;
      switch ((t.type === "ParenthesizedExpression" || (s = t.extra) != null && s.parenthesized) && (a = RB(t), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(k.InvalidParenthesizedAssignment, t) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(k.InvalidParenthesizedAssignment, t) : this.raise(k.InvalidParenthesizedAssignment, t)), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          t.type = "ObjectPattern";
          for (let l = 0, u = t.properties.length, c = u - 1; l < u; l++) {
            var o;
            let f = t.properties[l], p = l === c;
            this.toAssignableObjectExpressionProp(f, p, r), p && f.type === "RestElement" && (o = t.extra) != null && o.trailingCommaLoc && this.
            raise(k.RestTrailingComma, t.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = t;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          t.type = "ArrayPattern", this.toAssignableList(t.elements, (n = t.extra) == null ? void 0 : n.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(k.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(
          t.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, r, s) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? k.PatternHasAccessor : k.PatternHasMethod, t.key);
      else if (t.type === "SpreadElement") {
        t.type = "RestElement";
        let n = t.argument;
        this.checkToRestConversion(n, !1), this.toAssignable(n, s), r || this.raise(k.RestTrailingComma, t);
      } else
        this.toAssignable(t, s);
    }
    toAssignableList(t, r, s) {
      let n = t.length - 1;
      for (let a = 0; a <= n; a++) {
        let o = t[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, s);
          } else
            this.toAssignable(o, s);
          o.type === "RestElement" && (a < n ? this.raise(k.RestTrailingComma, o) : r && this.raise(k.RestTrailingComma, r));
        }
      }
    }
    isAssignable(t, r) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let s = t.properties.length - 1;
          return t.properties.every((n, a) => n.type !== "ObjectMethod" && (a === s || n.type !== "SpreadElement") && this.isAssignable(n));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((s) => s === null || this.isAssignable(s));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(t, r) {
      return t;
    }
    toReferencedListDeep(t, r) {
      this.toReferencedList(t, r);
      for (let s of t)
        s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
    }
    parseSpread(t) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let t = this.startNode();
      return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, r, s) {
      let n = s & 1, a = [], o = !0;
      for (; !this.eat(t); )
        if (o ? o = !1 : this.expect(12), n && this.match(12))
          a.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(r)) {
              this.expect(t);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(k.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(s, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(t) {
      return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      let t = this.startNode(), {
        type: r,
        startLoc: s
      } = this.state;
      return r === 21 ? this.parseBindingRestProperty(t) : (r === 138 ? (this.expectPlugin("destructuringPrivate", s), this.classScope.usePrivateName(
      this.state.value, s), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = !1, this.parseObjPropValue(t, s, !1, !1,
      !0, !1));
    }
    parseAssignableListItem(t, r) {
      let s = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s, t);
      let n = this.parseMaybeDefault(s.loc.start, s);
      return r.length && (s.decorators = r), n;
    }
    parseAssignableListItemTypes(t, r) {
      return t;
    }
    parseMaybeDefault(t, r) {
      var s, n;
      if ((s = t) != null || (t = this.state.startLoc), r = (n = r) != null ? n : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(t);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(t, r, s) {
      return KCe({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, t);
    }
    isOptionalMemberExpression(t) {
      return t.type === "OptionalMemberExpression";
    }
    checkLVal(t, {
      in: r,
      binding: s = 64,
      checkClashes: n = !1,
      strictModeChanged: a = !1,
      hasParenthesizedAncestor: o = !1
    }) {
      var l;
      let u = t.type;
      if (this.isObjectMethod(t)) return;
      let c = this.isOptionalMemberExpression(t);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(k.InvalidLhsOptionalChaining,
        t, {
          ancestor: r
        })), s !== 64 && this.raise(k.InvalidPropertyBindingPattern, t);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(t, s, a);
        let {
          name: b
        } = t;
        n && (n.has(b) ? this.raise(k.ParamDupe, t) : n.add(b));
        return;
      }
      let f = this.isValidLVal(u, !(o || (l = t.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", s);
      if (f === !0) return;
      if (f === !1) {
        let b = s === 64 ? k.InvalidLhs : k.InvalidLhsBinding;
        this.raise(b, t, {
          ancestor: r
        });
        return;
      }
      let [p, d] = Array.isArray(f) ? f : [f, u === "ParenthesizedExpression"], m = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r;
      for (let b of [].concat(t[p]))
        b && this.checkLVal(b, {
          in: m,
          binding: s,
          checkClashes: n,
          strictModeChanged: a,
          hasParenthesizedAncestor: d
        });
    }
    checkIdentifier(t, r, s = !1) {
      this.state.strict && (s ? wB(t.name, this.inModule) : CB(t.name)) && (r === 64 ? this.raise(k.StrictEvalArguments, t, {
        referenceName: t.name
      }) : this.raise(k.StrictEvalArgumentsBinding, t, {
        bindingName: t.name
      })), r & 8192 && t.name === "let" && this.raise(k.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
    }
    declareNameFromIdentifier(t, r) {
      this.scope.declareName(t.name, r, t.loc.start);
    }
    checkToRestConversion(t, r) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(k.InvalidRestAssignmentPattern, t);
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? k.RestTrailingComma : k.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, YCe = /* @__PURE__ */ i((e, t) => hasOwnProperty.call(e, t) && e[t], "getOwn");
  function XCe(e) {
    if (e == null)
      throw new Error(`Unexpected ${e} value.`);
    return e;
  }
  i(XCe, "nonNull");
  function dB(e) {
    if (!e)
      throw new Error("Assert fail");
  }
  i(dB, "assert");
  var Se = bi`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ i(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ i(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ i(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ i(({
      modifier: e
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ i(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ i(({
      token: e
    }) => `'${e}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ i(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ i(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ i(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ i(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ i(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ i(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ i(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ i(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ i(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`, "UnsupportedSignatureParameterKind")
  });
  function zCe(e) {
    switch (e) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  i(zCe, "keywordTypeFromName");
  function hB(e) {
    return e === "private" || e === "public" || e === "protected";
  }
  i(hB, "tsIsAccessModifier");
  function JCe(e) {
    return e === "in" || e === "out";
  }
  i(JCe, "tsIsVarianceAnnotations");
  var QCe = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Se.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: Se.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Se.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return FS;
    }
    tsIsIdentifier() {
      return Tt(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, s) {
      if (!Tt(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let n = this.state.value;
      if (r.indexOf(n) !== -1) {
        if (s && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return n;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: s,
      stopOnStartOfClassStaticBlock: n,
      errorTemplate: a = Se.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ i((c, f, p, d) => {
        f === p && o[d] && this.raise(Se.InvalidModifiersOrder, c, {
          orderedModifiers: [p, d]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ i((c, f, p, d) => {
        (o[p] && f === d || o[d] && f === p) && this.raise(Se.IncompatibleModifiers, c, {
          modifiers: [p, d]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, f = this.tsParseModifier(r.concat(s ?? []), n);
        if (!f) break;
        hB(f) ? o.accessibility ? this.raise(Se.DuplicateAccessibilityModifier, c, {
          modifier: f
        }) : (l(c, f, f, "override"), l(c, f, f, "static"), l(c, f, f, "readonly"), o.accessibility = f) : JCe(f) ? (o[f] && this.raise(Se.DuplicateModifier,
        c, {
          modifier: f
        }), o[f] = !0, l(c, f, "in", "out")) : (hasOwnProperty.call(o, f) ? this.raise(Se.DuplicateModifier, c, {
          modifier: f
        }) : (l(c, f, "static", "readonly"), l(c, f, "static", "override"), l(c, f, "override", "readonly"), l(c, f, "abstract", "override"),
        u(c, f, "declare", "override"), u(c, f, "static", "abstract")), o[f] = !0), s != null && s.includes(f) && this.raise(a, c, {
          modifier: f
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, s) {
      let n = [];
      for (; !this.tsIsListTerminator(r); )
        n.push(s());
      return n;
    }
    tsParseDelimitedList(r, s, n) {
      return XCe(this.tsParseDelimitedListWorker(r, s, !0, n));
    }
    tsParseDelimitedListWorker(r, s, n, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = s();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        n && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, s, n, a, o) {
      a || (n ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, s, o);
      return n ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(Se.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let s = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let n = this.startNodeAtNode(s);
        n.left = s, n.right = this.parseIdentifier(r), s = this.finishNode(n, "TSQualifiedName");
      }
      return s;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let s = this.startNodeAtNode(r);
      return s.parameterName = r, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let s = this.startNode();
      return r(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(
      29), this.finishNode(s, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let s = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let n = {
        value: -1
      };
      return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, n), s.params.
      length === 0 && this.raise(Se.EmptyTypeParameters, s), n.value !== -1 && this.addExtra(s, "trailingComma", n.value), this.finishNode(s,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, s) {
      let n = r === 19, a = "parameters", o = "typeAnnotation";
      s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(),
      n ? s[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (s[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let s of r) {
        let {
          type: n
        } = s;
        (n === "AssignmentPattern" || n === "TSParameterProperty") && this.raise(Se.UnsupportedSignatureParameterKind, s, {
          type: n
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, s) {
      return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), Tt(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s = this.parseIdentifier();
      s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), r.parameters = [s];
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, s) {
      this.eat(17) && (r.optional = !0);
      let n = r;
      if (this.match(10) || this.match(47)) {
        s && this.raise(Se.ReadonlyForMethodSignature, r);
        let a = n;
        a.kind && this.match(47) && this.raise(Se.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(k.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(Se.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(k.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(Se.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(Se.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            Se.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(Se.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = n;
        s && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let n = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(n, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let s = this.tsTryParseIndexSignature(r);
      return s || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let s = !1;
      return r.elementTypes.forEach((n) => {
        let {
          type: a
        } = n;
        s && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && n.optional) && this.raise(Se.OptionalTypeBeforeRequired,
        n), s || (s = a === "TSNamedTupleMember" && n.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, s = this.eat(21), n, a, o, l, c = dn(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        n = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let f = this.state.startLoc, p = this.state.value, d = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (n = !0, a = this.createIdentifier(this.startNodeAt(f), p), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (n = !1, l = d, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), n = this.eat(14);
      if (n) {
        let f;
        a ? (f = this.startNodeAtNode(a), f.optional = o, f.label = a, f.elementType = l, this.eat(17) && (f.optional = !0, this.raise(Se.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (f = this.startNodeAtNode(l), f.optional = o, this.raise(Se.InvalidTupleMemberLabel, l), f.label = l,
        f.elementType = this.tsParseType()), l = this.finishNode(f, "TSNamedTupleMember");
      } else if (o) {
        let f = this.startNodeAtNode(l);
        f.typeAnnotation = l, l = this.finishNode(f, "TSOptionalType");
      }
      if (s) {
        let f = this.startNodeAt(r);
        f.typeAnnotation = l, l = this.finishNode(f, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, s) {
      let n = this.startNode();
      return r === "TSConstructorType" && (n.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, n)), this.finishNode(n, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), s = this.lookahead();
            return s.type !== 134 && s.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (Tt(r) || r === 88 || r === 84) {
            let s = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : zCe(this.state.value);
            if (s !== void 0 && this.lookaheadCharCode() !== 46) {
              let n = this.startNode();
              return this.next(), this.finishNode(n, s);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s = this.startNodeAtNode(r);
          s.elementType = r, this.expect(3), r = this.finishNode(s, "TSArrayType");
        } else {
          let s = this.startNodeAtNode(r);
          s.objectType = r, s.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(s, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), s = this.state.value;
      return this.next(), r.operator = s, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(Se.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let s = this.startNode();
      return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(s, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return mCe(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, s, n) {
      let a = this.startNode(), o = this.eat(n), l = [];
      do
        l.push(s());
      while (this.eat(n));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (Tt(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === s;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === s;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let s = this.startNode();
        this.expect(r);
        let n = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (n.parameterName = u, n.asserts = !0, n.typeAnnotation = null, u = this.finishNode(n, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, n), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (n.parameterName = this.parseIdentifier(), n.asserts = a, n.typeAnnotation = null, s.typeAnnotation = this.finishNode(n,
          "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
        let l = this.tsParseTypeAnnotation(!1);
        return n.parameterName = o, n.typeAnnotation = l, n.asserts = a, s.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(
        s, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !Tt(this.state.type) && !this.match(78) ? !1 : (r && this.raise(k.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, s = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), s.typeAnnotation = this.tsParseType();
      }), this.finishNode(s, "TSTypeAnnotation");
    }
    tsParseType() {
      dB(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let s = this.startNodeAtNode(r);
      return s.checkType = r, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(s, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Se.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let s = this.state.startLoc, n = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return n.length || this.raise(Se.EmptyHeritageClauseType, s, {
        token: r
      }), n;
    }
    tsParseInterfaceDeclaration(r, s = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), s.declare && (r.declare = !0), Tt(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(Se.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let n = this.startNode();
      return n.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(n, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let s = this.startNode();
          return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return r();
      } finally {
        this.state.context = s;
      }
    }
    tsInType(r) {
      let s = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = s;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, s = {}) {
      return s.const && (r.const = !0), s.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, s = !1) {
      if (r.id = this.parseIdentifier(), s || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let n = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(n, !0), r.body = n;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, s, n) {
      r.isExport = n || !1, r.id = s || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(Se.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let s = this.state.clone(), n = r();
      return this.state = s, n;
    }
    tsTryParseAndCatch(r) {
      let s = this.tryParse((n) => r() || n());
      if (!(s.aborted || !s.node))
        return s.error && (this.state = s.failState), s.node;
    }
    tsTryParse(r) {
      let s = this.state.clone(), n = r();
      if (n !== void 0 && n !== !1)
        return n;
      this.state = s;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let s = this.state.type, n;
      return this.isContextual(100) && (s = 74, n = "let"), this.tsInAmbientContext(() => {
        switch (s) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, n || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (Tt(s))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, s, n) {
      switch (s.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, s.name, !1, n);
      }
    }
    tsParseDeclaration(r, s, n, a) {
      switch (s) {
        case "abstract":
          if (this.tsCheckLineTerminator(n) && (this.match(80) || Tt(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(n)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (Tt(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(n) && Tt(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(n) && Tt(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let s = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let n = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = s, !!n)
        return super.parseArrowExpression(n, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(Se.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      Lt.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return yCe(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, s) {
      let n = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(Se.UnexpectedParameterModifier, n);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let f = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let p = this.startNodeAt(n);
        return s.length && (p.decorators = s), o && (p.accessibility = o), u && (p.readonly = u), l && (p.override = l), f.type !== "Identif\
ier" && f.type !== "AssignmentPattern" && this.raise(Se.UnsupportedParameterPropertyKind, p), p.parameter = f, this.finishNode(p, "TSParamet\
erProperty");
      }
      return s.length && (c.decorators = s), f;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let s of r.params)
        s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(Se.PatternIsOptional, s);
    }
    setArrowFunctionParameters(r, s, n) {
      super.setArrowFunctionParameters(r, s, n), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, s, n = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(Se.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, n) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, s, n));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((s) => {
        s?.type === "TSTypeCastExpression" && this.raise(Se.UnexpectedTypeAnnotation, s.typeAnnotation);
      });
    }
    toReferencedList(r, s) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, s, n, a) {
      let o = super.parseArrayLike(r, s, n, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, s, n, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(s);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (n)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!n && this.atPossibleAsyncArrow(r)) {
            let d = this.tsTryParseGenericAsyncArrowFunction(s);
            if (d)
              return d;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (zd(this.state.type)) {
            let d = super.parseTaggedTemplateExpression(r, s, a);
            return d.typeParameters = c, d;
          }
          if (!n && this.eat(10)) {
            let d = this.startNodeAt(s);
            return d.callee = r, d.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(d.arguments), d.typeParameters =
            c, a.optionalChainMember && (d.optional = o), this.finishCallExpression(d, a.optionalChainMember);
          }
          let f = this.state.type;
          if (f === 48 || f === 52 || f !== 10 && ES(f) && !this.hasPrecedingLineBreak())
            return;
          let p = this.startNodeAt(s);
          return p.expression = r, p.typeParameters = c, this.finishNode(p, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          Se.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, s, n, a);
    }
    parseNewCallee(r) {
      var s;
      super.parseNewCallee(r);
      let {
        callee: n
      } = r;
      n.type === "TSInstantiationExpression" && !((s = n.extra) != null && s.parenthesized) && (r.typeParameters = n.typeParameters, r.callee =
      n.expression);
    }
    parseExprOp(r, s, n) {
      let a;
      if (Gd(58) > n && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(s);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(k.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, s, n);
      }
      return super.parseExprOp(r, s, n);
    }
    checkReservedWord(r, s, n, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, s, n, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Se.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let s = this.lookaheadCharCode();
        return r ? s === 123 || s === 42 : s !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, n, a) {
      super.applyImportPhase(r, s, n, a), s ? r.exportKind = n === "type" ? "type" : "value" : r.importKind = n === "type" || n === "typeof" ?
      n : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let s;
      if (Tt(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let n = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, n);
        s = super.parseImportSpecifiersAndAfter(r, n);
      } else
        s = super.parseImport(r);
      return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(Se.TypeImportCannotSpecifyDefaultAndNamed,
      s), s;
    }
    parseExport(r, s) {
      if (this.match(83)) {
        this.next();
        let n = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? n = this.parseMaybeImportPhase(r, !1) : r.importKind = "value", this.
        tsParseImportEqualsDeclaration(r, n, !0);
      } else if (this.eat(29)) {
        let n = r;
        return n.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(n, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let n = r;
        return this.expectContextual(128), n.id = this.parseIdentifier(), this.semicolon(), this.finishNode(n, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, s);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, s, n = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, s, n || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (s !== "const" || l.typeAnnotation ? this.raise(Se.InitializerNotAllowedInAmbientContext, u) : ewe(u, this.hasPlugin("estree")) ||
        this.raise(Se.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, s) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let n = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(n, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let n = this.tsParseInterfaceDeclaration(this.startNode());
        if (n) return n;
      }
      return super.parseStatementContent(r, s);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, s) {
      return s.some((n) => hB(n) ? r.accessibility === n : !!r[n]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, s, n) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: Se.InvalidModifierOnTypeParameterPositions
      }, s);
      let o = /* @__PURE__ */ i(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(Se.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, s)) : this.parseClassMemberWithIsStatic(r, s, n, !!s.static);
      }, "callParseClassMemberWithIsStatic");
      s.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, s, n, a) {
      let o = this.tsTryParseIndexSignature(s);
      if (o) {
        r.body.push(o), s.abstract && this.raise(Se.IndexSignatureHasAbstract, s), s.accessibility && this.raise(Se.IndexSignatureHasAccessibility,
        s, {
          modifier: s.accessibility
        }), s.declare && this.raise(Se.IndexSignatureHasDeclare, s), s.override && this.raise(Se.IndexSignatureHasOverride, s);
        return;
      }
      !this.state.inAbstractClass && s.abstract && this.raise(Se.NonAbstractClassHasAbstractMethod, s), s.override && (n.hadSuperClass || this.
      raise(Se.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(r, s, n, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(Se.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(Se.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, s, n) {
      return (s.type === "Identifier" ? this.tsParseExpressionStatement(r, s, n) : void 0) || super.parseExpressionStatement(r, s, n);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, s, n) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, s, n);
      let a = this.tryParse(() => super.parseConditional(r, s));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(n, a.error), r);
    }
    parseParenItem(r, s) {
      if (r = super.parseParenItem(r, s), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let n = this.startNodeAt(s);
        return n.expression = r, n.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let s = this.state.startLoc, n = this.eatContextual(125);
      if (n && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(Se.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = Tt(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || n) && (r.exportKind = "type"), n && (this.resetStartLocation(
      o, s), o.declare = !0), o) : null;
    }
    parseClassId(r, s, n, a) {
      if ((!s || n) && this.isContextual(113))
        return;
      super.parseClassId(r, s, n, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let s = this.tsTryParseTypeAnnotation();
      s && (r.typeAnnotation = s);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(Se.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: s
        } = r;
        this.raise(Se.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: s.type === "Identifier" && !r.computed ? s.name : `[${this.input.slice(s.start, s.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(Se.PrivateElementHasAbstract, r), r.accessibility && this.raise(Se.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(Se.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, s, n, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(Se.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: f
      } = s;
      c && (f === "get" || f === "set") && this.raise(Se.DeclareAccessor, s, {
        kind: f
      }), u && (s.typeParameters = u), super.pushClassMethod(r, s, n, a, o, l);
    }
    pushClassPrivateMethod(r, s, n, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (s.typeParameters = o), super.pushClassPrivateMethod(r, s, n, a);
    }
    declareClassPrivateMethodInScope(r, s) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !r.value.body || super.declareClassPrivateMethodInScope(r, s));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, s, n, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, s, n, a, o, l, u);
    }
    parseFunctionParams(r, s) {
      let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      n && (r.typeParameters = n), super.parseFunctionParams(r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let n = this.tsTryParseTypeAnnotation();
      n && (r.id.typeAnnotation = n, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, s);
    }
    parseMaybeAssign(r, s) {
      var n, a, o, l, u;
      let c, f, p;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), f = this.tryParse(() => super.parseMaybeAssign(r, s), c), !f.error) return f.node;
        let {
          context: b
        } = this.state, h = b[b.length - 1];
        (h === Lt.j_oTag || h === Lt.j_expr) && b.pop();
      }
      if (!((n = f) != null && n.error) && !this.match(47))
        return super.parseMaybeAssign(r, s);
      (!c || c === this.state) && (c = this.state.clone());
      let d, m = this.tryParse((b) => {
        var h, g;
        d = this.tsParseTypeParameters(this.tsParseConstModifier);
        let E = super.parseMaybeAssign(r, s);
        return (E.type !== "ArrowFunctionExpression" || (h = E.extra) != null && h.parenthesized) && b(), ((g = d) == null ? void 0 : g.params.
        length) !== 0 && this.resetStartLocationFromNode(E, d), E.typeParameters = d, E;
      }, c);
      if (!m.error && !m.aborted)
        return d && this.reportReservedArrowTypeParam(d), m.node;
      if (!f && (dB(!this.hasPlugin("jsx")), p = this.tryParse(() => super.parseMaybeAssign(r, s), c), !p.error))
        return p.node;
      if ((a = f) != null && a.node)
        return this.state = f.failState, f.node;
      if (m.node)
        return this.state = m.failState, d && this.reportReservedArrowTypeParam(d), m.node;
      if ((o = p) != null && o.node)
        return this.state = p.failState, p.node;
      throw ((l = f) == null ? void 0 : l.error) || m.error || ((u = p) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var s;
      r.params.length === 1 && !r.params[0].constraint && !((s = r.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(Se.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, s) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse((n) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && n(), a;
        });
        if (s.aborted) return;
        s.thrown || (s.error && (this.state = s.failState), r.returnType = s.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, s) {
      if (!(s & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.resetEndLocation(r), r;
    }
    isAssignable(r, s) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, s);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, s);
      }
    }
    toAssignable(r, s = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, s);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s ? this.expressionScope.recordArrowParameterBindingError(Se.UnexpectedTypeCastInParameter, r) : this.raise(Se.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, s);
          break;
        case "AssignmentExpression":
          !s && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, s);
      }
    }
    toAssignableParenthesizedExpression(r, s) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, s);
          break;
        default:
          super.toAssignable(r, s);
      }
    }
    checkToRestConversion(r, s) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, s);
      }
    }
    isValidLVal(r, s, n) {
      return YCe({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (n !== 64 || !s) && ["expression", !0],
        TSSatisfiesExpression: (n !== 64 || !s) && ["expression", !0],
        TSTypeAssertion: (n !== 64 || !s) && ["expression", !0]
      }, r) || super.isValidLVal(r, s, n);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let n = super.parseMaybeDecoratorArguments(r);
          return n.typeParameters = s, n;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, s) {
      let n = super.parseMaybeDefault(r, s);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(Se.TypeAnnotationAfterAssign,
      n.typeAnnotation), n;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, s, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, n);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s && (r.typeParameters = s);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let s = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? s + 1 : s;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let s = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = s;
      }
    }
    parseClass(r, s, n) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, s, n);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, s) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(Se.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, s, n, a, o, l, u) {
      let c = super.parseMethod(r, s, n, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: p
        } = c;
        this.raise(Se.AbstractMethodHasImplementation, c, {
          methodName: p.type === "Identifier" && !c.computed ? p.name : `[${this.input.slice(p.start, p.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, s, n, a) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, n), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, s, n, a));
    }
    parseImportSpecifier(r, s, n, a, o) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, n), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, s, n, a, n ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, s, n) {
      let a = s ? "imported" : "local", o = s ? "local" : "exported", l = r[a], u, c = !1, f = !0, p = l.loc.start;
      if (this.isContextual(93)) {
        let m = this.parseIdentifier();
        if (this.isContextual(93)) {
          let b = this.parseIdentifier();
          dn(this.state.type) ? (c = !0, l = m, u = s ? this.parseIdentifier() : this.parseModuleExportName(), f = !1) : (u = b, f = !1);
        } else dn(this.state.type) ? (f = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = m);
      } else dn(this.state.type) && (c = !0, s ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && n && this.raise(s ? Se.TypeModifierIsUsedInTypeImports : Se.TypeModifierIsUsedInTypeExports, p), r[a] = l, r[o] = u;
      let d = s ? "importKind" : "exportKind";
      r[d] = c ? "type" : "value", f && this.eatContextual(93) && (r[o] = s ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = Ei(r[a])), s && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function ZCe(e) {
    if (e.type !== "MemberExpression") return !1;
    let {
      computed: t,
      property: r
    } = e;
    return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : FB(e.object);
  }
  i(ZCe, "isPossiblyLiteralEnum");
  function ewe(e, t) {
    var r;
    let {
      type: s
    } = e;
    if ((r = e.extra) != null && r.parenthesized)
      return !1;
    if (t) {
      if (s === "Literal") {
        let {
          value: n
        } = e;
        if (typeof n == "string" || typeof n == "boolean")
          return !0;
      }
    } else if (s === "StringLiteral" || s === "BooleanLiteral")
      return !0;
    return !!(kB(e, t) || twe(e, t) || s === "TemplateLiteral" && e.expressions.length === 0 || ZCe(e));
  }
  i(ewe, "isValidAmbientConstInitializer");
  function kB(e, t) {
    return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLite\
ral";
  }
  i(kB, "isNumber");
  function twe(e, t) {
    if (e.type === "UnaryExpression") {
      let {
        operator: r,
        argument: s
      } = e;
      if (r === "-" && kB(s, t))
        return !0;
    }
    return !1;
  }
  i(twe, "isNegativeNumber");
  function FB(e) {
    return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : FB(e.object);
  }
  i(FB, "isUncomputedMemberExpressionChain");
  var mB = bi`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), rwe = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let s = this.startNode();
        return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        s, r);
      }
    }
    finishPlaceholder(r, s) {
      let n = !!(r.expectedNode && r.type === "Placeholder");
      return r.expectedNode = s, n ? r : this.finishNode(r, "Placeholder");
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, s, n, a) {
      r !== void 0 && super.checkReservedWord(r, s, n, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, s, n) {
      return r === "Placeholder" || super.isValidLVal(r, s, n);
    }
    toAssignable(r, s) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, s);
    }
    chStartsBindingIdentifier(r, s) {
      return !!(super.chStartsBindingIdentifier(r, s) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, s) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, s);
    }
    parseExpressionStatement(r, s) {
      var n;
      if (s.type !== "Placeholder" || (n = s.extra) != null && n.parenthesized)
        return super.parseExpressionStatement(r, s);
      if (this.match(14)) {
        let a = r;
        return a.label = this.finishPlaceholder(s, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(a, "LabeledStatement");
      }
      return this.semicolon(), r.name = s.name, this.finishPlaceholder(r, "Statement");
    }
    parseBlock(r, s, n) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, s, n);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, s, n) {
      let a = s ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (n || !s)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(mB.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, s, n);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, s) {
      let n = this.parsePlaceholder("Identifier");
      if (!n) return super.parseExport(r, s);
      if (!this.isContextual(98) && !this.match(12))
        return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(n, "Declaration"), this.finishNode(r, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let a = this.startNode();
      return a.exported = n, r.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(r, s);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(fa(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, s) {
      var n;
      return (n = r.specifiers) != null && n.length ? !0 : super.maybeParseExportDefaultSpecifier(r, s);
    }
    checkExport(r) {
      let {
        specifiers: s
      } = r;
      s != null && s.length && (r.specifiers = s.filter((n) => n.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = s;
    }
    parseImport(r) {
      let s = this.parsePlaceholder("Identifier");
      if (!s) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let n = this.startNodeAtNode(s);
      return n.local = s, r.specifiers.push(this.finishNode(n, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(mB.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), swe = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, s = this.startNode();
        if (this.next(), Tt(this.state.type)) {
          let n = this.parseIdentifierName(), a = this.createIdentifier(s, n);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic");
  function Er(e, t) {
    let [r, s] = typeof t == "string" ? [t, {}] : t, n = Object.keys(s), a = n.length === 0;
    return e.some((o) => {
      if (typeof o == "string")
        return a && o === r;
      {
        let [l, u] = o;
        if (l !== r)
          return !1;
        for (let c of n)
          if (u[c] !== s[c])
            return !1;
        return !0;
      }
    });
  }
  i(Er, "hasPlugin");
  function ca(e, t, r) {
    let s = e.find((n) => Array.isArray(n) ? n[0] === t : n === t);
    return s && Array.isArray(s) && s.length > 1 ? s[1][r] : null;
  }
  i(ca, "getPluginOption");
  var yB = ["minimal", "fsharp", "hack", "smart"], gB = ["^^", "@@", "^", "%", "#"], bB = ["hash", "bar"];
  function nwe(e) {
    if (Er(e, "decorators")) {
      if (Er(e, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let t = ca(e, "decorators", "decoratorsBeforeExport");
      if (t != null && typeof t != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let r = ca(e, "decorators", "allowCallParenthesized");
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Er(e, "flow") && Er(e, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Er(e, "placeholders") && Er(e, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Er(e, "pipelineOperator")) {
      let t = ca(e, "pipelineOperator", "proposal");
      if (!yB.includes(t)) {
        let s = yB.map((n) => `"${n}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
      }
      let r = Er(e, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (t === "hack") {
        if (Er(e, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Er(e, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let s = ca(e, "pipelineOperator", "topicToken");
        if (!gB.includes(s)) {
          let n = gB.map((a) => `"${a}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}\
.`);
        }
        if (s === "#" && r)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { s\
yntaxType: "hash"}]`.');
      } else if (t === "smart" && r)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}\
]`.');
    }
    if (Er(e, "moduleAttributes")) {
      if (Er(e, "importAssertions") || Er(e, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (ca(e, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (Er(e, "importAssertions") && Er(e, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Er(e, "recordAndTuple") && ca(e, "recordAndTuple", "syntaxType") != null && !bB.includes(ca(e, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + bB.map((t) => `'${t}'`).join(", "));
    if (Er(e, "asyncDoExpressions") && !Er(e, "doExpressions")) {
      let t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw t.missingPlugins = "doExpressions", t;
    }
    if (Er(e, "optionalChainingAssign") && ca(e, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  i(nwe, "validatePlugins");
  var LB = {
    estree: iCe,
    jsx: GCe,
    flow: WCe,
    typescript: QCe,
    v8intrinsic: swe,
    placeholders: rwe
  }, iwe = Object.keys(LB), yS = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function awe(e) {
    if (e == null)
      return Object.assign({}, yS);
    if (e.annexB != null && e.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let t = {};
    for (let s of Object.keys(yS)) {
      var r;
      t[s] = (r = e[s]) != null ? r : yS[s];
    }
    return t;
  }
  i(awe, "getOptions");
  var BS = class extends LS {
    static {
      i(this, "ExpressionParser");
    }
    checkProto(t, r, s, n) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return;
      let a = t.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(k.RecordNoProto, a);
          return;
        }
        s.used && (n ? n.doubleProtoLoc === null && (n.doubleProtoLoc = a.loc.start) : this.raise(k.DuplicateProto, a)), s.used = !0;
      }
    }
    shouldExitDescending(t, r) {
      return t.type === "ArrowFunctionExpression" && t.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let t = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors,
      this.options.tokens && (t.tokens = this.tokens), t;
    }
    parseExpression(t, r) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(t) {
      let r = this.state.startLoc, s = this.parseMaybeAssign(t);
      if (this.match(12)) {
        let n = this.startNodeAt(r);
        for (n.expressions = [s]; this.eat(12); )
          n.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(n.expressions), this.finishNode(n, "SequenceExpression");
      }
      return s;
    }
    parseMaybeAssignDisallowIn(t, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
    }
    parseMaybeAssignAllowIn(t, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, r));
    }
    setOptionalParametersError(t, r) {
      var s;
      t.optionalParametersLoc = (s = r?.loc) != null ? s : this.state.startLoc;
    }
    parseMaybeAssign(t, r) {
      let s = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, s)), l;
      }
      let n;
      t ? n = !1 : (t = new Sl(), n = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || Tt(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(t);
      if (r && (o = r.call(this, o, s)), cCe(this.state.type)) {
        let l = this.startNodeAt(s), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = s.index;
          t.doubleProtoLoc != null && t.doubleProtoLoc.index >= c && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.
          index >= c && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          t), t.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, {
          in: this.finishNode(l, "AssignmentExpression")
        }), l;
      } else n && this.checkExpressionErrors(t, !0);
      return o;
    }
    parseMaybeConditional(t) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, n = this.parseExprOps(t);
      return this.shouldExitDescending(n, s) ? n : this.parseConditional(n, r, t);
    }
    parseConditional(t, r, s) {
      if (this.eat(17)) {
        let n = this.startNodeAt(r);
        return n.test = t, n.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), n.alternate = this.parseMaybeAssign(), this.finishNode(
        n, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, n = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(n, s) ? n : this.parseExprOp(n, r, -1);
    }
    parseExprOp(t, r, s) {
      if (this.isPrivateName(t)) {
        let a = this.getPrivateNameSV(t);
        (s >= Gd(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(k.PrivateInExpectedIn, t, {
          identifierName: a
        }), this.classScope.usePrivateName(a, t.loc.start);
      }
      let n = this.state.type;
      if (pCe(n) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Gd(n);
        if (a > s) {
          if (n === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, r);
          }
          let o = this.startNodeAt(r);
          o.left = t, o.operator = this.state.value;
          let l = n === 41 || n === 42, u = n === 40;
          if (u && (a = Gd(42)), this.next(), n === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(k.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(n, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), f = this.state.type;
          if (u && (f === 41 || f === 42) || l && f === 40)
            throw this.raise(k.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, s);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, r) {
      let s = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(k.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), s);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(t, r);
      }
    }
    parseExprOpBaseRightExpr(t, r) {
      let s = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, gCe(t) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var t;
      let {
        startLoc: r
      } = this.state, s = this.parseMaybeAssign();
      return ZAe.has(s.type) && !((t = s.extra) != null && t.parenthesized) && this.raise(k.PipeUnparenthesizedBody, r, {
        type: s.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(k.PipeTopicUnused, r), s;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(k.UnexpectedTokenUnaryExponentiation, t.argument);
    }
    parseMaybeUnary(t, r) {
      let s = this.state.startLoc, n = this.isContextual(96);
      if (n && this.isAwaitAllowed()) {
        this.next();
        let u = this.parseAwait(s);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (hCe(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(k.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(k.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, t);
      if (n) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? ES(u) : ES(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(k.AwaitNotInAsyncContext, s), this.parseAwait(s);
      }
      return l;
    }
    parseUpdate(t, r, s) {
      if (r) {
        let o = t;
        return this.checkLVal(o.argument, {
          in: this.finishNode(o, "UpdateExpression")
        }), t;
      }
      let n = this.state.startLoc, a = this.parseExprSubscripts(s);
      if (this.checkExpressionErrors(s, !1)) return a;
      for (; dCe(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(n);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, {
          in: a = this.finishNode(o, "UpdateExpression")
        });
      }
      return a;
    }
    parseExprSubscripts(t) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, n = this.parseExprAtom(t);
      return this.shouldExitDescending(n, s) ? n : this.parseSubscripts(n, r);
    }
    parseSubscripts(t, r, s) {
      let n = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(t),
        stop: !1
      };
      do
        t = this.parseSubscript(t, r, s, n), n.maybeAsyncArrow = !1;
      while (!n.stop);
      return t;
    }
    parseSubscript(t, r, s, n) {
      let {
        type: a
      } = this.state;
      if (!s && a === 15)
        return this.parseBind(t, r, s, n);
      if (zd(a))
        return this.parseTaggedTemplateExpression(t, r, n);
      let o = !1;
      if (a === 18) {
        if (s && (this.raise(k.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return n.stop = !0, t;
        n.optionalChainMember = o = !0, this.next();
      }
      if (!s && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, r, n, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(t, r, n, l, o) : (n.stop = !0, t);
      }
    }
    parseMember(t, r, s, n, a) {
      let o = this.startNodeAt(r);
      return o.object = t, o.computed = n, n ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t.type === "Super" &&
      this.raise(k.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), s.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(t, r, s, n) {
      let a = this.startNodeAt(r);
      return a.object = t, this.next(), a.callee = this.parseNoCallExpr(), n.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, s);
    }
    parseCoverCallAndAsyncArrowHead(t, r, s, n) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = t;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = s;
      u && (this.expressionScope.enter(LCe()), o = new Sl()), c && (l.optional = n), n ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", l, o);
      let f = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !n ? (s.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), f = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), f)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(f)), this.state.maybeInArrowParameters = a, f;
    }
    toReferencedArguments(t, r) {
      this.toReferencedListDeep(t.arguments, r);
    }
    parseTaggedTemplateExpression(t, r, s) {
      let n = this.startNodeAt(r);
      return n.tag = t, n.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(k.OptionalChainingNoTemplate, r), this.finishNode(
      n, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end -
      t.start === 5 && t.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(t, r) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 ||
        t.arguments.length > 2)
          this.raise(k.ImportCallArity, t, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let s of t.arguments)
            s.type === "SpreadElement" && this.raise(k.ImportCallSpreadArgument, s);
      return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, r, s, n, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(t)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          k.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, s));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, r) {
      var s;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (s = r.extra) == null ?
      void 0 : s.trailingCommaLoc), r.innerComments && Rc(t, r.innerComments), r.callee.trailingComments && Rc(t, r.callee.trailingComments),
      t;
    }
    parseNoCallExpr() {
      let t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, !0);
    }
    parseExprAtom(t) {
      let r, s = null, {
        type: n
      } = this.state;
      switch (n) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(k.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, t);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          s = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(k.UnsupportedBind, a);
        }
        case 138:
          return this.raise(k.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          gi(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (Tt(n)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (Tt(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, r) {
      let s = this.getPluginOption("pipelineOperator", "proposal");
      if (s)
        return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = ls(this.state.endLoc, -1),
        this.parseTopicReference(s);
      this.unexpected();
    }
    parseTopicReference(t) {
      let r = this.startNode(), s = this.state.startLoc, n = this.state.type;
      return this.next(), this.finishTopicReference(r, s, t, n);
    }
    finishTopicReference(t, r, s, n) {
      if (this.testTopicReferenceConfiguration(s, r, n)) {
        let a = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? k.PrimaryTopicNotAllowed : k.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(t, a);
      } else
        throw this.raise(k.PipeTopicUnconfiguredToken, r, {
          token: fa(n)
        });
    }
    testTopicReferenceConfiguration(t, r, s) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: fa(s)
          }]);
        case "smart":
          return s === 27;
        default:
          throw this.raise(k.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(Yd(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(k.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(t, r, !0);
    }
    parseDo(t, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
      let s = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(),
      this.state.labels = s, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      let t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(k.SuperNotAllowed,
      t) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(k.UnexpectedSuper, t), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(k.UnsupportedSuper, t), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      let t = this.startNode(), r = this.startNodeAt(ls(this.state.startLoc, 1)), s = this.state.value;
      return this.next(), t.id = this.createIdentifier(r, s), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(t, r, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, r, s) {
      t.meta = r;
      let n = this.state.containsEsc;
      return t.property = this.parseIdentifier(!0), (t.property.name !== s || n) && this.raise(k.UnsupportedMetaProperty, t.property, {
        target: r.name,
        onlyValidPropertyName: s
      }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaProperty(t) {
      let r = this.createIdentifier(this.startNodeAtNode(t), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(k.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let s = this.isContextual(105);
        if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(k.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), t.phase = s ? "source" : "defer", this.parseImportCall(t);
      }
      return this.parseMetaProperty(t, r, "meta");
    }
    parseLiteralAtNode(t, r, s) {
      return this.addExtra(s, "rawValue", t), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = t, this.next(), this.
      finishNode(s, r);
    }
    parseLiteral(t, r) {
      let s = this.startNode();
      return this.parseLiteralAtNode(t, r, s);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      let r = this.parseLiteral(t.value, "RegExpLiteral");
      return r.pattern = t.pattern, r.flags = t.flags, r;
    }
    parseBooleanLiteral(t) {
      let r = this.startNode();
      return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      let r = this.state.startLoc, s;
      this.next(), this.expressionScope.enter(FCe());
      let n = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new Sl(), c = !0, f, p;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          p = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let b = this.state.startLoc;
          if (f = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), b)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let d = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = n, this.state.inFSharpPipelineDirectBody = a;
      let m = this.startNodeAt(r);
      return t && this.shouldParseArrow(l) && (m = this.parseArrow(m)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(m, l, !1), m) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), p && this.unexpected(p), f && this.unexpected(f), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (s = this.startNodeAt(o), s.expressions = l, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s,
      d)) : s = l[0], this.wrapParenthesis(r, s));
    }
    wrapParenthesis(t, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.
        state.lastTokEndLoc.index), r;
      let s = this.startNodeAt(t);
      return s.expression = r, this.finishNode(s, "ParenthesizedExpression");
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, r) {
      return t;
    }
    parseNewOrNewTarget() {
      let t = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        let s = this.parseMetaProperty(t, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(k.UnexpectedNewTarget,
        s), s;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), t.arguments = r;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      let r = this.match(83), s = this.parseNoCallExpr();
      t.callee = s, r && (s.type === "Import" || s.type === "ImportExpression") && this.raise(k.ImportCallNotNewExpression, s);
    }
    parseTemplateElement(t) {
      let {
        start: r,
        startLoc: s,
        end: n,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(ls(s, 1));
      a === null && (t || this.raise(k.InvalidEscapeSequenceTemplate, ls(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, f = n + c;
      l.value = {
        raw: this.input.slice(o, f).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let p = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(p, ls(this.state.lastTokEndLoc, c)), p;
    }
    parseTemplate(t) {
      let r = this.startNode();
      r.expressions = [];
      let s = this.parseTemplateElement(t);
      for (r.quasis = [s]; !s.tail; )
        r.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.quasis.push(s = this.parseTemplateElement(t));
      return this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, r, s, n) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(t); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let f;
        r ? f = this.parseBindingProperty() : (f = this.parsePropertyDefinition(n), this.checkProto(f, s, o, n)), s && !this.isObjectProperty(
        f) && f.type !== "SpreadElement" && this.raise(k.InvalidRecordProperty, f), f.shorthand && this.addExtra(f, "shorthand", !0), u.properties.
        push(f);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(k.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let s = this.startNode(), n = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (s.decorators = r, r = []), s.method = !1, t && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(s);
      let u = this.state.containsEsc, c = this.parsePropertyName(s, t);
      if (!l && !u && this.maybeAsyncOrAccessorProp(s)) {
        let f = c.name;
        f === "async" && !this.hasPrecedingLineBreak() && (n = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        s)), (f === "get" || f === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), s.kind = f, this.match(55) && (l = !0, this.
        raise(k.AccessorIsGenerator, this.state.curPosition(), {
          kind: f
        }), this.next()), this.parsePropertyName(s));
      }
      return this.parseObjPropValue(s, o, l, n, !1, a, t);
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var r;
      let s = this.getGetterSetterExpectedParamCount(t), n = this.getObjectOrClassMethodParams(t);
      n.length !== s && this.raise(t.kind === "get" ? k.BadGetterArity : k.BadSetterArity, t), t.kind === "set" && ((r = n[n.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(k.BadSetterRestParameter, t);
    }
    parseObjectMethod(t, r, s, n, a) {
      if (a) {
        let o = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (s || r || this.match(10))
        return n && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, s, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(t, r, s, n) {
      if (t.shorthand = !1, this.eat(14))
        return t.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n), this.finishNode(t, "ObjectProper\
ty");
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), s)
          t.value = this.parseMaybeDefault(r, Ei(t.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          n != null ? n.shorthandAssignLoc === null && (n.shorthandAssignLoc = a) : this.raise(k.InvalidCoverInitializedName, a), t.value = this.
          parseMaybeDefault(r, Ei(t.key));
        } else
          t.value = Ei(t.key);
        return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
      }
    }
    parseObjPropValue(t, r, s, n, a, o, l) {
      let u = this.parseObjectMethod(t, s, n, a, o) || this.parseObjectProperty(t, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(t, r) {
      if (this.eat(0))
        t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: s,
          value: n
        } = this.state, a;
        if (dn(s))
          a = this.parseIdentifier(!0);
        else
          switch (s) {
            case 134:
              a = this.parseNumericLiteral(n);
              break;
            case 133:
              a = this.parseStringLiteral(n);
              break;
            case 135:
              a = this.parseBigIntLiteral(n);
              break;
            case 136:
              a = this.parseDecimalLiteral(n);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(k.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        t.key = a, s !== 138 && (t.computed = !1);
      }
      return t.key;
    }
    initFunction(t, r) {
      t.id = null, t.generator = !1, t.async = r;
    }
    parseMethod(t, r, s, n, a, o, l = !1) {
      this.initFunction(t, s), t.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(Yd(s, t.generator)),
      this.parseFunctionParams(t, n);
      let u = this.parseFunctionBodyAndFinish(t, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(t, r, s, n) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(t, !s, n, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, s ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, r, s, n) {
      this.scope.enter(6);
      let a = Yd(s, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(t, s);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, n)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(t, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(t, r, s) {
      this.toAssignableList(r, s, !1), t.params = r;
    }
    parseFunctionBodyAndFinish(t, r, s = !1) {
      return this.parseFunctionBody(t, !1, s), this.finishNode(t, r);
    }
    parseFunctionBody(t, r, s = !1) {
      let n = r && !this.match(5);
      if (this.expressionScope.enter(NB()), n)
        t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(t.params);
          l && u && this.raise(k.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
          let c = !a && this.state.strict;
          this.checkParams(t, !this.state.strict && !r && !s && !u, r, c), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let r = 0, s = t.length; r < s; r++)
        if (!this.isSimpleParameter(t[r])) return !1;
      return !0;
    }
    checkParams(t, r, s, n = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of t.params)
        this.checkLVal(l, {
          in: o,
          binding: 5,
          checkClashes: a,
          strictModeChanged: n
        });
    }
    parseExprList(t, r, s, n) {
      let a = [], o = !0;
      for (; !this.eat(t); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(t)) {
          n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, s));
      }
      return a;
    }
    parseExprListItem(t, r, s) {
      let n;
      if (this.match(12))
        t || this.raise(k.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), n = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        n = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), s || this.raise(k.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), n = this.finishNode(a, "ArgumentPlaceholder");
      } else
        n = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return n;
    }
    parseIdentifier(t) {
      let r = this.startNode(), s = this.parseIdentifierName(t);
      return this.createIdentifier(r, s);
    }
    createIdentifier(t, r) {
      return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
    }
    parseIdentifierName(t) {
      let r, {
        startLoc: s,
        type: n
      } = this.state;
      dn(n) ? r = this.state.value : this.unexpected();
      let a = lCe(n);
      return t ? a && this.replaceToken(132) : this.checkReservedWord(r, s, a, !1), this.next(), r;
    }
    checkReservedWord(t, r, s, n) {
      if (t.length > 10 || !wCe(t))
        return;
      if (s && PCe(t)) {
        this.raise(k.UnexpectedKeyword, r, {
          keyword: t
        });
        return;
      }
      if ((this.state.strict ? n ? wB : AB : PB)(t, this.inModule)) {
        this.raise(k.UnexpectedReservedWord, r, {
          reservedWord: t
        });
        return;
      } else if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(k.YieldBindingIdentifier, r);
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(k.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(k.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(k.ArgumentsInClass, r);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(t) {
      let r = this.startNodeAt(t);
      return this.expressionScope.recordParameterInitializerError(k.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(k.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: t
      } = this.state;
      return t === 53 || t === 10 || t === 0 || zd(t) || t === 102 && !this.state.containsEsc || t === 137 || t === 56 || this.hasPlugin("v8\
intrinsic") && t === 54;
    }
    parseYield() {
      let t = this.startNode();
      this.expressionScope.recordParameterInitializerError(k.YieldInParameter, t), this.next();
      let r = !1, s = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            s = this.parseMaybeAssign();
        }
      return t.delegate = r, t.argument = s, this.finishNode(t, "YieldExpression");
    }
    parseImportCall(t) {
      return this.next(), t.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(t, "ImportExpression");
    }
    checkPipelineAtInfixOperator(t, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && t.type === "SequenceExpression" && this.raise(k.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(t, r) {
      if (this.isSimpleReference(t)) {
        let s = this.startNodeAt(r);
        return s.callee = t, this.finishNode(s, "PipelineBareFunction");
      } else {
        let s = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), s.expression = t, this.finishNode(s, "PipelineTopicExpression");
      }
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(k.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(k.PipelineTopicUnused, t);
    }
    withTopicBindingContext(t) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return t();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return t();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
      return this.state.inFSharpPipelineDirectBody = s, n;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let t = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let s = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        t.body = this.parseProgram(r, 8, "module");
      } finally {
        s();
      }
      return this.finishNode(t, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }, gS = {
    kind: 1
  }, owe = {
    kind: 2
  }, lwe = /[\uD800-\uDFFF]/u, bS = /in(?:stanceof)?/y;
  function uwe(e, t) {
    for (let r = 0; r < e.length; r++) {
      let s = e[r], {
        type: n
      } = s;
      if (typeof n == "number") {
        {
          if (n === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, f = ls(a.start, 1);
            e.splice(r, 1, new Bn({
              type: mi(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: f
            }), new Bn({
              type: mi(132),
              value: l,
              start: c,
              end: u,
              startLoc: f,
              endLoc: a.end
            })), r++;
            continue;
          }
          if (zd(n)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, f = ls(a.start, 1), p;
            t.charCodeAt(o) === 96 ? p = new Bn({
              type: mi(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: f
            }) : p = new Bn({
              type: mi(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: f
            });
            let d, m, b, h;
            n === 24 ? (m = u - 1, b = ls(a.end, -1), d = l === null ? null : l.slice(1, -1), h = new Bn({
              type: mi(22),
              value: "`",
              start: m,
              end: u,
              startLoc: b,
              endLoc: a.end
            })) : (m = u - 2, b = ls(a.end, -2), d = l === null ? null : l.slice(1, -2), h = new Bn({
              type: mi(23),
              value: "${",
              start: m,
              end: u,
              startLoc: b,
              endLoc: a.end
            })), e.splice(r, 1, p, new Bn({
              type: mi(20),
              value: d,
              start: c,
              end: m,
              startLoc: f,
              endLoc: b
            }), h), r += 2;
            continue;
          }
        }
        s.type = mi(n);
      }
    }
    return e;
  }
  i(uwe, "babel7CompatTokens");
  var MS = class extends BS {
    static {
      i(this, "StatementParser");
    }
    parseTopLevel(t, r) {
      return t.program = this.parseProgram(r), t.comments = this.comments, this.options.tokens && (t.tokens = uwe(this.tokens, this.input)),
      this.finishNode(t, "File");
    }
    parseProgram(t, r = 139, s = this.options.sourceType) {
      if (t.sourceType = s, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule && !this.options.
      allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [a, o] of Array.from(this.scope.undefinedExports))
          this.raise(k.ModuleExportUndefined, o, {
            localName: a
          });
      let n;
      return r === 139 ? n = this.finishNode(t, "Program") : n = this.finishNodeAt(t, "Program", ls(this.state.startLoc, -1)), n;
    }
    stmtToDirective(t) {
      let r = t;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let s = r.value, n = s.value, a = this.input.slice(s.start, s.end), o = s.value = a.slice(1, -1);
      return this.addExtra(s, "raw", a), this.addExtra(s, "rawValue", o), this.addExtra(s, "expressionValue", n), s.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(t, r) {
      if (gi(t)) {
        if (bS.lastIndex = r, bS.test(this.input)) {
          let s = this.codePointAtPos(bS.lastIndex);
          if (!vl(s) && s !== 92)
            return !1;
        }
        return !0;
      } else return t === 92;
    }
    chStartsBindingPattern(t) {
      return t === 91 || t === 123;
    }
    hasFollowingBindingAtom() {
      let t = this.nextTokenStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
    }
    hasInLineFollowingBindingIdentifier() {
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingIdentifier(r, t);
    }
    startsUsingForOf() {
      let {
        type: t,
        containsEsc: r
      } = this.lookahead();
      if (t === 102 && !r)
        return !1;
      if (Tt(t) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let t = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(t, "using")) {
        t = this.nextTokenInLineStartSince(t + 5);
        let r = this.codePointAtPos(t);
        if (this.chStartsBindingIdentifier(r, t))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(t) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
    }
    parseStatementContent(t, r) {
      let s = this.state.type, n = this.startNode(), a = !!(t & 2), o = !!(t & 4), l = t & 1;
      switch (s) {
        case 60:
          return this.parseBreakContinueStatement(n, !0);
        case 63:
          return this.parseBreakContinueStatement(n, !1);
        case 64:
          return this.parseDebuggerStatement(n);
        case 90:
          return this.parseDoWhileStatement(n);
        case 91:
          return this.parseForStatement(n);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? k.StrictFunction : this.options.annexB ? k.SloppyFunctionAnnexB : k.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(n, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, n), !0);
        case 69:
          return this.parseIfStatement(n);
        case 70:
          return this.parseReturnStatement(n);
        case 71:
          return this.parseSwitchStatement(n);
        case 72:
          return this.parseThrowStatement(n);
        case 73:
          return this.parseTryStatement(n);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? a || this.raise(k.UnexpectedLexicalDeclaration, n) : this.raise(k.AwaitUsingNotInAsyncContext, n),
            this.next(), this.parseVarStatement(n, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(k.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(k.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let f = this.nextTokenStart(), p = this.codePointAtPos(f);
          if (p !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(p, f) && p !== 123))
            break;
        }
        case 75:
          a || this.raise(k.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let f = this.state.value;
          return this.parseVarStatement(n, f);
        }
        case 92:
          return this.parseWhileStatement(n);
        case 76:
          return this.parseWithStatement(n);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(n);
        case 83: {
          let f = this.lookaheadCharCode();
          if (f === 40 || f === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(k.UnexpectedImportExport, this.state.startLoc), this.next();
          let f;
          return s === 83 ? (f = this.parseImport(n), f.type === "ImportDeclaration" && (!f.importKind || f.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (f = this.parseExport(n, r), (f.type === "ExportNamedDeclaration" && (!f.exportKind || f.exportKind ===
          "value") || f.type === "ExportAllDeclaration" && (!f.exportKind || f.exportKind === "value") || f.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(f), f;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(k.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return Tt(s) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(n, u, c, t) : this.parseExpressionStatement(n, c,
      r);
    }
    assertModuleNodeAllowed(t) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(k.ImportOutsideModule, t);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(t, r, s) {
      return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(k.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(
      r, t[0]), s && this.resetStartLocationFromNode(s, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(k.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(k.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, s;
        if (this.match(10)) {
          let n = this.state.startLoc;
          this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(n, s);
          let a = this.state.startLoc;
          t.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !==
          s && this.raise(k.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (s = this.parseIdentifier(!1); this.eat(16); ) {
            let n = this.startNodeAt(r);
            n.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) :
            n.property = this.parseIdentifier(!0), n.computed = !1, s = this.finishNode(n, "MemberExpression");
          }
          t.expression = this.parseMaybeDecoratorArguments(s);
        }
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(t);
        return r.callee = t, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return t;
    }
    parseBreakContinueStatement(t, r) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, r) {
      let s;
      for (s = 0; s < this.state.labels.length; ++s) {
        let n = this.state.labels[s];
        if ((t.label == null || n.name === t.label.name) && (n.kind != null && (r || n.kind === 1) || t.label && r))
          break;
      }
      if (s === this.state.labels.length) {
        let n = r ? "BreakStatement" : "ContinueStatement";
        this.raise(k.IllegalBreakContinue, t, {
          type: n
        });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoWhileStatement(t) {
      return this.next(), this.state.labels.push(gS), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(gS);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(
      13))
        return r !== null && this.unexpected(r), this.parseFor(t, null);
      let s = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), f = s && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || f) {
          let p = this.startNode(), d;
          u ? (d = "await using", this.isAwaitAllowed() || this.raise(k.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : d =
          this.state.value, this.next(), this.parseVar(p, !0, d);
          let m = this.finishNode(p, "VariableDeclaration"), b = this.match(58);
          return b && c && this.raise(k.ForInUsing, m), (b || this.isContextual(102)) && m.declarations.length === 1 ? this.parseForIn(t, m,
          r) : (r !== null && this.unexpected(r), this.parseFor(t, m));
        }
      }
      let n = this.isContextual(95), a = new Sl(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (s && this.raise(k.ForOfLet, o), r === null && n && o.type === "Identifier" && this.raise(k.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          in: {
            type: u
          }
        }), this.parseForIn(t, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(t, o);
    }
    parseFunctionStatement(t, r, s) {
      return this.next(), this.parseFunction(t, 1 | (s ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(k.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "Ret\
urnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      let r = t.cases = [];
      this.expect(5), this.state.labels.push(owe), this.scope.enter(0);
      let s;
      for (let n; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          s && this.finishNode(s, "SwitchCase"), r.push(s = this.startNode()), s.consequent = [], this.next(), a ? s.test = this.parseExpression() :
          (n && this.raise(k.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), n = !0, s.test = null), this.expect(14);
        } else
          s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchState\
ment");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(k.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let t = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(
        r, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(k.NoCatchOrFinally, t), this.finishNode(
      t, "TryStatement");
    }
    parseVarStatement(t, r, s = !1) {
      return this.next(), this.parseVar(t, !1, r, s), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(gS), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(k.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, r, s, n) {
      for (let o of this.state.labels)
        o.name === r && this.raise(k.LabelRedeclaration, s, {
          labelName: r
        });
      let a = fCe(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === t.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), t.body = n & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label =
      s, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, r, s) {
      return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock(t = !1, r = !0, s) {
      let n = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(n, t, !1, 8, s), r && this.
      scope.exit(), this.finishNode(n, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, r, s, n, a) {
      let o = t.body = [], l = t.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, s, n, a);
    }
    parseBlockOrModuleBlockBody(t, r, s, n, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(n); ) {
        let c = s ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let f = this.stmtToDirective(c);
            r.push(f), !l && f.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        t.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(t, r) {
      return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, r, s) {
      let n = this.match(58);
      return this.next(), n ? s !== null && this.unexpected(s) : t.await = s !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!n || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(k.ForInOfLoopInitializer, r, {
        type: n ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(k.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), t.left = r, t.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, n ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, r, s, n = !1) {
      let a = t.declarations = [];
      for (t.kind = s; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, s), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !n && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(k.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(k.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: s
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return t;
    }
    parseVarId(t, r) {
      let s = this.parseBindingAtom();
      this.checkLVal(s, {
        in: {
          type: "VariableDeclarator"
        },
        binding: r === "var" ? 5 : 8201
      }), t.id = s;
    }
    parseAsyncFunctionExpression(t) {
      return this.parseFunction(t, 8);
    }
    parseFunction(t, r = 0) {
      let s = r & 2, n = !!(r & 1), a = n && !(r & 4), o = !!(r & 8);
      this.initFunction(t, o), this.match(55) && (s && this.raise(k.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.
      generator = !0), n && (t.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Yd(o, t.generator)), n || (t.id = this.parseFunctionId()),
      this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, n ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), n && !s && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = l, t;
    }
    parseFunctionId(t) {
      return t || Tt(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, r) {
      this.expect(10), this.expressionScope.enter(kCe()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, t.id.loc.start);
    }
    parseClass(t, r, s) {
      this.next();
      let n = this.state.strict;
      return this.state.strict = !0, this.parseClassId(t, r, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, n), this.
      finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
    }
    parseClassBody(t, r) {
      this.classScope.enter();
      let s = {
        hadConstructor: !1,
        hadSuperClass: t
      }, n = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (n.length > 0)
              throw this.raise(k.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            n.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          n.length && (o.decorators = n, this.resetStartLocationFromNode(o, n[0]), n = []), this.parseClassMember(a, o, s), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(k.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), n.length)
        throw this.raise(k.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(t, r) {
      let s = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let n = r;
        return n.kind = "method", n.computed = !1, n.key = s, n.static = !1, this.pushClassMethod(t, n, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let n = r;
        return n.computed = !1, n.key = s, n.static = !1, t.body.push(this.parseClassProperty(n)), !0;
      }
      return this.resetPreviousNodeTrailingComments(s), !1;
    }
    parseClassMember(t, r, s) {
      let n = this.isContextual(106);
      if (n) {
        if (this.parseClassMemberFromModifier(t, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, r, s, n);
    }
    parseClassMemberWithIsStatic(t, r, s, n) {
      let a = r, o = r, l = r, u = r, c = r, f = a, p = a;
      if (r.static = n, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        f.kind = "method";
        let g = this.match(138);
        if (this.parseClassElementName(f), g) {
          this.pushClassPrivateMethod(t, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(k.ConstructorIsGenerator, a.key), this.pushClassMethod(t, a, !0, !1, !1, !1);
        return;
      }
      let d = Tt(this.state.type) && !this.state.containsEsc, m = this.match(138), b = this.parseClassElementName(r), h = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(p), this.isClassMethod()) {
        if (f.kind = "method", m) {
          this.pushClassPrivateMethod(t, o, !1, !1);
          return;
        }
        let g = this.isNonstaticConstructor(a), E = !1;
        g && (a.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(k.DuplicateConstructor, b), g && this.
        hasPlugin("typescript") && r.override && this.raise(k.OverrideOnConstructor, b), s.hadConstructor = !0, E = s.hadSuperClass), this.pushClassMethod(
        t, a, !1, !1, g, E);
      } else if (this.isClassProperty())
        m ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l);
      else if (d && b.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(b);
        let g = this.eat(55);
        p.optional && this.unexpected(h), f.kind = "method";
        let E = this.match(138);
        this.parseClassElementName(f), this.parsePostMemberNameModifiers(p), E ? this.pushClassPrivateMethod(t, o, g, !0) : (this.isNonstaticConstructor(
        a) && this.raise(k.ConstructorIsAsync, a.key), this.pushClassMethod(t, a, g, !0, !1, !1));
      } else if (d && (b.name === "get" || b.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(b), f.kind = b.name;
        let g = this.match(138);
        this.parseClassElementName(a), g ? this.pushClassPrivateMethod(t, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(k.ConstructorIsAccessor,
        a.key), this.pushClassMethod(t, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (d && b.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(b);
        let g = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(t, c, g);
      } else this.isLineTerminator() ? m ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l) : this.unexpected();
    }
    parseClassElementName(t) {
      let {
        type: r,
        value: s
      } = this.state;
      if ((r === 132 || r === 133) && t.static && s === "prototype" && this.raise(k.StaticPrototype, this.state.startLoc), r === 138) {
        s === "constructor" && this.raise(k.ConstructorClassPrivateField, this.state.startLoc);
        let n = this.parsePrivateName();
        return t.key = n, n;
      }
      return this.parsePropertyName(t);
    }
    parseClassStaticBlock(t, r) {
      var s;
      this.scope.enter(208);
      let n = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n, t.body.push(this.
      finishNode(r, "StaticBlock")), (s = r.decorators) != null && s.length && this.raise(k.DecoratorStaticBlock, r);
    }
    pushClassProperty(t, r) {
      !r.computed && (r.key.name === "constructor" || r.key.value === "constructor") && this.raise(k.ConstructorClassField, r.key), t.body.push(
      this.parseClassProperty(r));
    }
    pushClassPrivateProperty(t, r) {
      let s = this.parseClassPrivateProperty(r);
      t.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
    }
    pushClassAccessorProperty(t, r, s) {
      if (!s && !r.computed) {
        let a = r.key;
        (a.name === "constructor" || a.value === "constructor") && this.raise(k.ConstructorClassField, a);
      }
      let n = this.parseClassAccessorProperty(r);
      t.body.push(n), s && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
    }
    pushClassMethod(t, r, s, n, a, o) {
      t.body.push(this.parseMethod(r, s, n, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(t, r, s, n) {
      let a = this.parseMethod(r, s, n, !1, !1, "ClassPrivateMethod", !0);
      t.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(t, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(80), this.expressionScope.enter(NB()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, r, s, n = 8331) {
      if (Tt(this.state.type))
        t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, n);
      else if (s || !r)
        t.id = null;
      else
        throw this.raise(k.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t, r) {
      let s = this.parseMaybeImportPhase(t, !0), n = this.maybeParseExportDefaultSpecifier(t, s), a = !n || this.eat(12), o = a && this.eatExportStar(
      t), l = o && this.maybeParseExportNamespaceSpecifier(t), u = a && (!l || this.eat(12)), c = n || o;
      if (o && !l) {
        if (n && this.unexpected(), r)
          throw this.raise(k.UnsupportedDecoratorExport, t);
        return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
      }
      let f = this.maybeParseExportNamedSpecifiers(t);
      n && a && !o && !f && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let p;
      if (c || f) {
        if (p = !1, r)
          throw this.raise(k.UnsupportedDecoratorExport, t);
        this.parseExportFrom(t, c);
      } else
        p = this.maybeParseExportDeclaration(t);
      if (c || f || p) {
        var d;
        let m = t;
        if (this.checkExport(m, !0, !1, !!m.source), ((d = m.declaration) == null ? void 0 : d.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, m.declaration, m);
        else if (r)
          throw this.raise(k.UnsupportedDecoratorExport, t);
        return this.finishNode(m, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let m = t, b = this.parseExportDefaultExpression();
        if (m.declaration = b, b.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, b, m);
        else if (r)
          throw this.raise(k.UnsupportedDecoratorExport, t);
        return this.checkExport(m, !0, !0), this.finishNode(m, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let s = r || this.parseIdentifier(!0), n = this.startNodeAtNode(s);
        return n.exported = s, t.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        t.specifiers || (t.specifiers = []);
        let r = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), r.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        t.specifiers || (t.specifiers = []);
        let r = t.exportKind === "type";
        return t.specifiers.push(...this.parseExportSpecifiers(r)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") &&
        (t.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions =
      []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let t = this.nextTokenInLineStart();
      return this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      let t = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(t, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, 13);
      if (this.match(80))
        return this.parseClass(t, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(k.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(k.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(t) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: t
      } = this.state;
      if (Tt(t)) {
        if (t === 95 && !this.state.containsEsc || t === 100)
          return !1;
        if ((t === 130 || t === 129) && !this.state.containsEsc) {
          let {
            type: n
          } = this.lookahead();
          if (Tt(n) && n !== 98 || n === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), s = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || Tt(this.state.type) && s)
        return !0;
      if (this.match(65) && s) {
        let n = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return n === 34 || n === 39;
      }
      return !1;
    }
    parseExportFrom(t, r) {
      this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(
      t)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: t
      } = this.state;
      return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(k.DecoratorBeforeExport, this.state.startLoc), !0) : t === 74 || t === 75 || t ===
      68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, r, s, n) {
      if (r) {
        var a;
        if (s) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = t.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            k.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = t.specifiers) != null && a.length)
          for (let l of t.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !n && l.local) {
              let {
                local: f
              } = l;
              f.type !== "Identifier" ? this.raise(k.ExportBindingIsString, l, {
                localName: f.value,
                exportName: c
              }) : (this.checkReservedWord(f.name, f.loc.start, !0, !1), this.scope.checkLocalExport(f));
            }
          }
        else if (t.declaration) {
          if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
            let l = t.declaration.id;
            if (!l) throw new Error("Assertion failure");
            this.checkDuplicateExports(t, l.name);
          } else if (t.declaration.type === "VariableDeclaration")
            for (let l of t.declaration.declarations)
              this.checkDeclaration(l.id);
        }
      }
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (let r of t.properties)
          this.checkDeclaration(r);
      else if (t.type === "ArrayPattern")
        for (let r of t.elements)
          r && this.checkDeclaration(r);
      else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type ===
      "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(k.DuplicateDefaultExport, t) : this.raise(k.DuplicateExport, t, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(t) {
      let r = [], s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else if (this.expect(12), this.eat(8)) break;
        let n = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, t, n));
      }
      return r;
    }
    parseExportSpecifier(t, r, s, n) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = MCe(t.local) : t.exported || (t.exported =
      Ei(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let t = this.parseStringLiteral(this.state.value), r = t.value.match(lwe);
        return r && this.raise(k.ModuleExportNameHasLoneSurrogate, t, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), t;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(t) {
      return t.assertions != null ? t.assertions.some(({
        key: r,
        value: s
      }) => s.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(t) {
      let {
        specifiers: r
      } = t, s = r.length === 1 ? r[0].type : null;
      if (t.phase === "source")
        s !== "ImportDefaultSpecifier" && this.raise(k.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (t.phase === "defer")
        s !== "ImportNamespaceSpecifier" && this.raise(k.DeferImportRequiresNamespace, r[0].loc.start);
      else if (t.module) {
        var n;
        s !== "ImportDefaultSpecifier" && this.raise(k.ImportReflectionNotBinding, r[0].loc.start), ((n = t.assertions) == null ? void 0 : n.
        length) > 0 && this.raise(k.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(t) {
      if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = t;
        if (r != null) {
          let s = r.find((n) => {
            let a;
            if (n.type === "ExportSpecifier" ? a = n.local : n.type === "ImportSpecifier" && (a = n.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          s !== void 0 && this.raise(k.ImportJSONBindingNotDefault, s.loc.start);
        }
      }
    }
    isPotentialImportPhase(t) {
      return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(t, r, s, n) {
      r || (s === "module" ? (this.expectPlugin("importReflection", n), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1),
      s === "source" ? (this.expectPlugin("sourcePhaseImports", n), t.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", n), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
    }
    parseMaybeImportPhase(t, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(t, r, null), null;
      let s = this.parseIdentifier(!0), {
        type: n
      } = this.state;
      return (dn(n) ? n !== 98 || this.lookaheadCharCode() === 102 : n !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(
      t, r, s.name, s.loc.start), null) : (this.applyImportPhase(t, r, null), s);
    }
    isPrecedingIdImportPhase(t) {
      let {
        type: r
      } = this.state;
      return Tt(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(t) {
      return this.match(133) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
    }
    parseImportSpecifiersAndAfter(t, r) {
      t.specifiers = [];
      let n = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), a = n && this.maybeParseStarImportSpecifier(t);
      return n && !a && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
    }
    parseImportSourceAndAttributes(t) {
      var r;
      return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.
      checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(t, r, s) {
      r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, s));
    }
    finishImportSpecifier(t, r, s = 8201) {
      return this.checkLVal(t.local, {
        in: {
          type: r
        },
        binding: s
      }), this.finishNode(t, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let s = this.startNode(), n = this.state.value;
        if (r.has(n) && this.raise(k.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: n
        }), r.add(n), this.match(133) ? s.key = this.parseStringLiteral(n) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(k.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), t;
    }
    parseModuleAttributes() {
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        let s = this.startNode();
        if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(k.ModuleAttributeDifferentFromType, s.key), r.has(s.key.name) &&
        this.raise(k.ModuleAttributesWithDuplicateKeys, s.key, {
          key: s.key.name
        }), r.add(s.key.name), this.expect(14), !this.match(133))
          throw this.raise(k.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAttributes(t) {
      let r, s = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), s = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(k.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !s && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
    }
    maybeParseDefaultImportSpecifier(t, r) {
      if (r) {
        let s = this.startNodeAtNode(r);
        return s.local = r, t.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
      } else if (dn(this.state.type))
        return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(t) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(k.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let s = this.startNode(), n = this.match(133), a = this.isContextual(130);
        s.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(s, n, t.importKind === "type" || t.importKind === "typeof", a, void 0);
        t.specifiers.push(o);
      }
    }
    parseImportSpecifier(t, r, s, n, a) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = t;
        if (r)
          throw this.raise(k.ImportBindingIsString, t, {
            importName: o.value
          });
        this.checkReservedWord(o.name, t.loc.start, !0, !0), t.local || (t.local = Ei(o));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier", a);
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }, Qd = class extends MS {
    static {
      i(this, "Parser");
    }
    constructor(t, r) {
      t = awe(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = cwe(this.options.plugins), this.filename = t.sourceFilename;
    }
    getScopeHandler() {
      return Nc;
    }
    parse() {
      this.enterInitialScopes();
      let t = this.startNode(), r = this.startNode();
      return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t.comments.length = this.state.commentsLen,
      t;
    }
  };
  function cwe(e) {
    let t = /* @__PURE__ */ new Map();
    for (let r of e) {
      let [s, n] = Array.isArray(r) ? r : [r, {}];
      t.has(s) || t.set(s, n || {});
    }
    return t;
  }
  i(cwe, "pluginsMap");
  function fwe(e, t) {
    var r;
    if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
      t = Object.assign({}, t);
      try {
        t.sourceType = "module";
        let s = Dc(t, e), n = s.parse();
        if (s.sawUnambiguousESM)
          return n;
        if (s.ambiguousScriptDifferentAst)
          try {
            return t.sourceType = "script", Dc(t, e).parse();
          } catch {
          }
        else
          n.program.sourceType = "script";
        return n;
      } catch (s) {
        try {
          return t.sourceType = "script", Dc(t, e).parse();
        } catch {
        }
        throw s;
      }
    } else
      return Dc(t, e).parse();
  }
  i(fwe, "parse");
  function pwe(e, t) {
    let r = Dc(t, e);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  i(pwe, "parseExpression");
  function dwe(e) {
    let t = {};
    for (let r of Object.keys(e))
      t[r] = mi(e[r]);
    return t;
  }
  i(dwe, "generateExportedTokenTypes");
  var hwe = dwe(oCe);
  function Dc(e, t) {
    let r = Qd;
    return e != null && e.plugins && (nwe(e.plugins), r = mwe(e.plugins)), new r(e, t);
  }
  i(Dc, "getParser");
  var EB = {};
  function mwe(e) {
    let t = iwe.filter((n) => Er(e, n)), r = t.join("/"), s = EB[r];
    if (!s) {
      s = Qd;
      for (let n of t)
        s = LB[n](s);
      EB[r] = s;
    }
    return s;
  }
  i(mwe, "getParserClass");
  kc.parse = fwe;
  kc.parseExpression = pwe;
  kc.tokTypes = hwe;
});

// ../node_modules/@babel/helper-hoist-variables/lib/index.js
var BB = y((XS) => {
  "use strict";
  Object.defineProperty(XS, "__esModule", {
    value: !0
  });
  XS.default = Swe;
  var ywe = Ne(), {
    assignmentExpression: gwe,
    expressionStatement: bwe,
    identifier: Ewe
  } = ywe, vwe = {
    Scope(e, t) {
      t.kind === "let" && e.skip();
    },
    FunctionParent(e) {
      e.skip();
    },
    VariableDeclaration(e, t) {
      if (t.kind && e.node.kind !== t.kind) return;
      let r = [], s = e.get("declarations"), n;
      for (let a of s) {
        n = a.node.id, a.node.init && r.push(bwe(gwe("=", a.node.id, a.node.init)));
        for (let o of Object.keys(a.getBindingIdentifiers()))
          t.emit(Ewe(o), o, a.node.init !== null);
      }
      e.parentPath.isFor({
        left: e.node
      }) ? e.replaceWith(n) : e.replaceWithMultiple(r);
    }
  };
  function Swe(e, t, r = "var") {
    e.traverse(vwe, {
      kind: r,
      emit: t
    });
  }
  i(Swe, "hoistVariables");
});

// ../node_modules/@babel/traverse/lib/path/replacement.js
var HB = y((pa) => {
  "use strict";
  Object.defineProperty(pa, "__esModule", {
    value: !0
  });
  pa._replaceWith = zwe;
  pa.replaceExpressionWithStatements = Jwe;
  pa.replaceInline = Qwe;
  pa.replaceWith = Xwe;
  pa.replaceWithMultiple = Kwe;
  pa.replaceWithSourceString = Ywe;
  var Twe = xc(), JS = Ms(), xwe = da(), UB = za(), Pwe = ao(), Awe = Ne(), Cwe = BB(), {
    FUNCTION_TYPES: MB,
    arrowFunctionExpression: wwe,
    assignmentExpression: VB,
    awaitExpression: Dwe,
    blockStatement: Iwe,
    buildUndefinedNode: zS,
    callExpression: _we,
    cloneNode: QS,
    conditionalExpression: Owe,
    expressionStatement: Nwe,
    getBindingIdentifiers: Rwe,
    identifier: kwe,
    inheritLeadingComments: Fwe,
    inheritTrailingComments: Lwe,
    inheritsComments: Bwe,
    isBlockStatement: Mwe,
    isEmptyStatement: jB,
    isExpression: WB,
    isExpressionStatement: jwe,
    isIfStatement: qwe,
    isProgram: $we,
    isStatement: Uwe,
    isVariableDeclaration: Vwe,
    removeComments: Wwe,
    returnStatement: qB,
    sequenceExpression: Hwe,
    validate: $B,
    yieldExpression: Gwe
  } = Awe;
  function Kwe(e) {
    var t;
    this.resync(), e = this._verifyNodeList(e), Fwe(e[0], this.node), Lwe(e[e.length - 1], this.node), (t = (0, UB.getCachedPaths)(this.hub,
    this.parent)) == null || t.delete(this.node), this.node = this.container[this.key] = null;
    let r = this.insertAfter(e);
    return this.node ? this.requeue() : this.remove(), r;
  }
  i(Kwe, "replaceWithMultiple");
  function Ywe(e) {
    this.resync();
    let t;
    try {
      e = `(${e})`, t = (0, Pwe.parse)(e);
    } catch (s) {
      let n = s.loc;
      throw n && (s.message += ` - make sure this is an expression.
` + (0, Twe.codeFrameColumns)(e, {
        start: {
          line: n.line,
          column: n.column + 1
        }
      }), s.code = "BABEL_REPLACE_SOURCE_ERROR"), s;
    }
    let r = t.program.body[0].expression;
    return JS.default.removeProperties(r), this.replaceWith(r);
  }
  i(Ywe, "replaceWithSourceString");
  function Xwe(e) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let t = e instanceof xwe.default ? e.node : e;
    if (!t)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === t)
      return [this];
    if (this.isProgram() && !$we(t))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(t))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof t == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r = "";
    if (this.isNodeType("Statement") && WB(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    t) && !this.parentPath.isExportDefaultDeclaration() && (t = Nwe(t), r = "expression"), this.isNodeType("Expression") && Uwe(t) && !this.
    canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t))
      return this.replaceExpressionWithStatements([t]);
    let s = this.node;
    return s && (Bwe(t, s), Wwe(s)), this._replaceWith(t), this.type = t.type, this.setScope(), this.requeue(), [r ? this.get(r) : this];
  }
  i(Xwe, "replaceWith");
  function zwe(e) {
    var t;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? $B(this.parent, this.key, [e]) : $B(this.parent, this.key, e), this.debug(`Replace with ${e?.type}`), (t = (0, UB.getCachedPaths)(
    this.hub, this.parent)) == null || t.set(e, this).delete(this.node), this.node = this.container[this.key] = e;
  }
  i(zwe, "_replaceWith");
  function Jwe(e) {
    this.resync();
    let t = [], r = Zd(e, t);
    if (r) {
      for (let d of t) this.scope.push({
        id: d
      });
      return this.replaceWith(r)[0].get("expressions");
    }
    let s = this.getFunctionParent(), n = s?.is("async"), a = s?.is("generator"), o = wwe([], Iwe(e));
    this.replaceWith(_we(o, []));
    let l = this.get("callee");
    (0, Cwe.default)(l.get("body"), (d) => {
      this.scope.push({
        id: d
      });
    }, "var");
    let u = this.get("callee").getCompletionRecords();
    for (let d of u) {
      if (!d.isExpressionStatement()) continue;
      let m = d.findParent((b) => b.isLoop());
      if (m) {
        let b = m.getData("expressionReplacementReturnUid");
        b ? b = kwe(b.name) : (b = l.scope.generateDeclaredUidIdentifier("ret"), l.get("body").pushContainer("body", qB(QS(b))), m.setData("\
expressionReplacementReturnUid", b)), d.get("expression").replaceWith(VB("=", QS(b), d.node.expression));
      } else
        d.replaceWith(qB(d.node.expression));
    }
    l.arrowFunctionToExpression();
    let c = l, f = n && JS.default.hasType(this.get("callee.body").node, "AwaitExpression", MB), p = a && JS.default.hasType(this.get("calle\
e.body").node, "YieldExpression", MB);
    return f && (c.set("async", !0), p || this.replaceWith(Dwe(this.node))), p && (c.set("generator", !0), this.replaceWith(Gwe(this.node, !0))),
    c.get("body.body");
  }
  i(Jwe, "replaceExpressionWithStatements");
  function Zd(e, t) {
    let r = [], s = !0;
    for (let n of e)
      if (jB(n) || (s = !1), WB(n))
        r.push(n);
      else if (jwe(n))
        r.push(n.expression);
      else if (Vwe(n)) {
        if (n.kind !== "var") return;
        for (let a of n.declarations) {
          let o = Rwe(a);
          for (let l of Object.keys(o))
            t.push(QS(o[l]));
          a.init && r.push(VB("=", a.id, a.init));
        }
        s = !0;
      } else if (qwe(n)) {
        let a = n.consequent ? Zd([n.consequent], t) : zS(), o = n.alternate ? Zd([n.alternate], t) : zS();
        if (!a || !o) return;
        r.push(Owe(n.test, a, o));
      } else if (Mwe(n)) {
        let a = Zd(n.body, t);
        if (!a) return;
        r.push(a);
      } else if (jB(n))
        e.indexOf(n) === 0 && (s = !0);
      else
        return;
    return s && r.push(zS()), r.length === 1 ? r[0] : Hwe(r);
  }
  i(Zd, "gatherSequenceExpressions");
  function Qwe(e) {
    if (this.resync(), Array.isArray(e))
      if (Array.isArray(this.container)) {
        e = this._verifyNodeList(e);
        let t = this._containerInsertAfter(e);
        return this.remove(), t;
      } else
        return this.replaceWithMultiple(e);
    else
      return this.replaceWith(e);
  }
  i(Qwe, "replaceInline");
});

// ../node_modules/@babel/traverse/lib/path/evaluation.js
var XB = y((eh) => {
  "use strict";
  Object.defineProperty(eh, "__esModule", {
    value: !0
  });
  eh.evaluate = aDe;
  eh.evaluateTruthy = nDe;
  var Zwe = ["Number", "String", "Math"], eDe = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeUR\
I", "encodeURIComponent", null, null], tDe = ["random"];
  function GB(e) {
    return Zwe.includes(e);
  }
  i(GB, "isValidObjectCallee");
  function rDe(e) {
    return eDe.includes(e);
  }
  i(rDe, "isValidIdentifierCallee");
  function sDe(e) {
    return tDe.includes(e);
  }
  i(sDe, "isInvalidMethod");
  function nDe() {
    let e = this.evaluate();
    if (e.confident) return !!e.value;
  }
  i(nDe, "evaluateTruthy");
  function vi(e, t) {
    t.confident && (t.deoptPath = e, t.confident = !1);
  }
  i(vi, "deopt");
  var KB = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function us(e, t) {
    let {
      node: r
    } = e, {
      seen: s
    } = t;
    if (s.has(r)) {
      let n = s.get(r);
      if (n.resolved)
        return n.value;
      vi(e, t);
      return;
    } else {
      let n = {
        resolved: !1
      };
      s.set(r, n);
      let a = iDe(e, t);
      return t.confident && (n.resolved = !0, n.value = a), a;
    }
  }
  i(us, "evaluateCached");
  function iDe(e, t) {
    if (t.confident) {
      if (e.isSequenceExpression()) {
        let r = e.get("expressions");
        return us(r[r.length - 1], t);
      }
      if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
        return e.node.value;
      if (e.isNullLiteral())
        return null;
      if (e.isTemplateLiteral())
        return YB(e, e.node.quasis, t);
      if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
        let r = e.get("tag.object"), {
          node: {
            name: s
          }
        } = r, n = e.get("tag.property");
        if (r.isIdentifier() && s === "String" && !e.scope.getBinding(s) && n.isIdentifier() && n.node.name === "raw")
          return YB(e, e.node.quasi.quasis, t, !0);
      }
      if (e.isConditionalExpression()) {
        let r = us(e.get("test"), t);
        return t.confident ? us(r ? e.get("consequent") : e.get("alternate"), t) : void 0;
      }
      if (e.isExpressionWrapper())
        return us(e.get("expression"), t);
      if (e.isMemberExpression() && !e.parentPath.isCallExpression({
        callee: e.node
      })) {
        let r = e.get("property"), s = e.get("object");
        if (s.isLiteral()) {
          let n = s.node.value, a = typeof n, o = null;
          if (e.node.computed) {
            if (o = us(r, t), !t.confident) return;
          } else r.isIdentifier() && (o = r.node.name);
          if ((a === "number" || a === "string") && o != null && (typeof o == "number" || typeof o == "string"))
            return n[o];
        }
      }
      if (e.isReferencedIdentifier()) {
        let r = e.scope.getBinding(e.node.name);
        if (r) {
          if (r.constantViolations.length > 0 || e.node.start < r.path.node.end) {
            vi(r.path, t);
            return;
          }
          if (r.hasValue)
            return r.value;
        }
        let s = e.node.name;
        if (KB.has(s)) {
          if (!r)
            return KB.get(s);
          vi(r.path, t);
          return;
        }
        let n = e.resolve();
        if (n === e) {
          vi(e, t);
          return;
        } else
          return us(n, t);
      }
      if (e.isUnaryExpression({
        prefix: !0
      })) {
        if (e.node.operator === "void")
          return;
        let r = e.get("argument");
        if (e.node.operator === "typeof" && (r.isFunction() || r.isClass()))
          return "function";
        let s = us(r, t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "!":
            return !s;
          case "+":
            return +s;
          case "-":
            return -s;
          case "~":
            return ~s;
          case "typeof":
            return typeof s;
        }
      }
      if (e.isArrayExpression()) {
        let r = [], s = e.get("elements");
        for (let n of s) {
          let a = n.evaluate();
          if (a.confident)
            r.push(a.value);
          else {
            vi(a.deopt, t);
            return;
          }
        }
        return r;
      }
      if (e.isObjectExpression()) {
        let r = {}, s = e.get("properties");
        for (let n of s) {
          if (n.isObjectMethod() || n.isSpreadElement()) {
            vi(n, t);
            return;
          }
          let a = n.get("key"), o;
          if (n.node.computed) {
            if (o = a.evaluate(), !o.confident) {
              vi(o.deopt, t);
              return;
            }
            o = o.value;
          } else a.isIdentifier() ? o = a.node.name : o = a.node.value;
          let u = n.get("value").evaluate();
          if (!u.confident) {
            vi(u.deopt, t);
            return;
          }
          u = u.value, r[o] = u;
        }
        return r;
      }
      if (e.isLogicalExpression()) {
        let r = t.confident, s = us(e.get("left"), t), n = t.confident;
        t.confident = r;
        let a = us(e.get("right"), t), o = t.confident;
        switch (e.node.operator) {
          case "||":
            return t.confident = n && (!!s || o), t.confident ? s || a : void 0;
          case "&&":
            return t.confident = n && (!s || o), t.confident ? s && a : void 0;
          case "??":
            return t.confident = n && (s != null || o), t.confident ? s ?? a : void 0;
        }
      }
      if (e.isBinaryExpression()) {
        let r = us(e.get("left"), t);
        if (!t.confident) return;
        let s = us(e.get("right"), t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "-":
            return r - s;
          case "+":
            return r + s;
          case "/":
            return r / s;
          case "*":
            return r * s;
          case "%":
            return r % s;
          case "**":
            return Math.pow(r, s);
          case "<":
            return r < s;
          case ">":
            return r > s;
          case "<=":
            return r <= s;
          case ">=":
            return r >= s;
          case "==":
            return r == s;
          case "!=":
            return r != s;
          case "===":
            return r === s;
          case "!==":
            return r !== s;
          case "|":
            return r | s;
          case "&":
            return r & s;
          case "^":
            return r ^ s;
          case "<<":
            return r << s;
          case ">>":
            return r >> s;
          case ">>>":
            return r >>> s;
        }
      }
      if (e.isCallExpression()) {
        let r = e.get("callee"), s, n;
        if (r.isIdentifier() && !e.scope.getBinding(r.node.name) && (GB(r.node.name) || rDe(r.node.name)) && (n = global[r.node.name]), r.isMemberExpression()) {
          let a = r.get("object"), o = r.get("property");
          if (a.isIdentifier() && o.isIdentifier() && GB(a.node.name) && !sDe(o.node.name)) {
            s = global[a.node.name];
            let l = o.node.name;
            hasOwnProperty.call(s, l) && (n = s[l]);
          }
          if (a.isLiteral() && o.isIdentifier()) {
            let l = typeof a.node.value;
            (l === "string" || l === "number") && (s = a.node.value, n = s[o.node.name]);
          }
        }
        if (n) {
          let a = e.get("arguments").map((o) => us(o, t));
          return t.confident ? n.apply(s, a) : void 0;
        }
      }
      vi(e, t);
    }
  }
  i(iDe, "_evaluate");
  function YB(e, t, r, s = !1) {
    let n = "", a = 0, o = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
    for (let l of t) {
      if (!r.confident) break;
      n += s ? l.value.raw : l.value.cooked;
      let u = o[a++];
      u && (n += String(us(u, r)));
    }
    if (r.confident)
      return n;
  }
  i(YB, "evaluateQuasis");
  function aDe() {
    let e = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, t = us(this, e);
    return e.confident || (t = void 0), {
      confident: e.confident,
      deopt: e.deoptPath,
      value: t
    };
  }
  i(aDe, "evaluate");
});

// ../node_modules/@babel/template/lib/formatters.js
var zB = y(($s) => {
  "use strict";
  Object.defineProperty($s, "__esModule", {
    value: !0
  });
  $s.statements = $s.statement = $s.smart = $s.program = $s.expression = void 0;
  var oDe = Ne(), {
    assertExpressionStatement: lDe
  } = oDe;
  function ZS(e) {
    return {
      code: /* @__PURE__ */ i((t) => `/* @babel/template */;
${t}`, "code"),
      validate: /* @__PURE__ */ i(() => {
      }, "validate"),
      unwrap: /* @__PURE__ */ i((t) => e(t.program.body.slice(1)), "unwrap")
    };
  }
  i(ZS, "makeStatementFormatter");
  var dtt = $s.smart = ZS((e) => e.length > 1 ? e : e[0]), htt = $s.statements = ZS((e) => e), mtt = $s.statement = ZS((e) => {
    if (e.length === 0)
      throw new Error("Found nothing to return.");
    if (e.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return e[0];
  }), uDe = $s.expression = {
    code: /* @__PURE__ */ i((e) => `(
${e}
)`, "code"),
    validate: /* @__PURE__ */ i((e) => {
      if (e.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (uDe.unwrap(e).start === 0)
        throw new Error("Parse result included parens.");
    }, "validate"),
    unwrap: /* @__PURE__ */ i(({
      program: e
    }) => {
      let [t] = e.body;
      return lDe(t), t.expression;
    }, "unwrap")
  }, ytt = $s.program = {
    code: /* @__PURE__ */ i((e) => e, "code"),
    validate: /* @__PURE__ */ i(() => {
    }, "validate"),
    unwrap: /* @__PURE__ */ i((e) => e.program, "unwrap")
  };
});

// ../node_modules/@babel/template/lib/options.js
var th = y((Fc) => {
  "use strict";
  Object.defineProperty(Fc, "__esModule", {
    value: !0
  });
  Fc.merge = pDe;
  Fc.normalizeReplacements = hDe;
  Fc.validate = dDe;
  var cDe = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function fDe(e, t) {
    if (e == null) return {};
    var r = {}, s = Object.keys(e), n, a;
    for (a = 0; a < s.length; a++)
      n = s[a], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
    return r;
  }
  i(fDe, "_objectWithoutPropertiesLoose");
  function pDe(e, t) {
    let {
      placeholderWhitelist: r = e.placeholderWhitelist,
      placeholderPattern: s = e.placeholderPattern,
      preserveComments: n = e.preserveComments,
      syntacticPlaceholders: a = e.syntacticPlaceholders
    } = t;
    return {
      parser: Object.assign({}, e.parser, t.parser),
      placeholderWhitelist: r,
      placeholderPattern: s,
      preserveComments: n,
      syntacticPlaceholders: a
    };
  }
  i(pDe, "merge");
  function dDe(e) {
    if (e != null && typeof e != "object")
      throw new Error("Unknown template options.");
    let t = e || {}, {
      placeholderWhitelist: r,
      placeholderPattern: s,
      preserveComments: n,
      syntacticPlaceholders: a
    } = t, o = fDe(t, cDe);
    if (r != null && !(r instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (s != null && !(s instanceof RegExp) && s !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (n != null && typeof n != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (a != null && typeof a != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (a === !0 && (r != null || s != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: o,
      placeholderWhitelist: r || void 0,
      placeholderPattern: s ?? void 0,
      preserveComments: n ?? void 0,
      syntacticPlaceholders: a ?? void 0
    };
  }
  i(dDe, "validate");
  function hDe(e) {
    if (Array.isArray(e))
      return e.reduce((t, r, s) => (t["$" + s] = r, t), {});
    if (typeof e == "object" || e == null)
      return e || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  i(hDe, "normalizeReplacements");
});

// ../node_modules/@babel/template/lib/parse.js
var t1 = y((e1) => {
  "use strict";
  Object.defineProperty(e1, "__esModule", {
    value: !0
  });
  e1.default = DDe;
  var mDe = Ne(), yDe = ao(), gDe = xc(), {
    isCallExpression: bDe,
    isExpressionStatement: EDe,
    isFunction: vDe,
    isIdentifier: SDe,
    isJSXIdentifier: TDe,
    isNewExpression: xDe,
    isPlaceholder: rh,
    isStatement: PDe,
    isStringLiteral: JB,
    removePropertiesDeep: ADe,
    traverse: CDe
  } = mDe, wDe = /^[_$A-Z0-9]+$/;
  function DDe(e, t, r) {
    let {
      placeholderWhitelist: s,
      placeholderPattern: n,
      preserveComments: a,
      syntacticPlaceholders: o
    } = r, l = ODe(t, r.parser, o);
    ADe(l, {
      preserveComments: a
    }), e.validate(l);
    let u = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: s,
      placeholderPattern: n,
      syntacticPlaceholders: o
    };
    return CDe(l, IDe, u), Object.assign({
      ast: l
    }, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
  }
  i(DDe, "parseAndBuildMetadata");
  function IDe(e, t, r) {
    var s;
    let n, a = r.syntactic.placeholders.length > 0;
    if (rh(e)) {
      if (r.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      n = e.name.name, a = !0;
    } else {
      if (a || r.syntacticPlaceholders)
        return;
      if (SDe(e) || TDe(e))
        n = e.name;
      else if (JB(e))
        n = e.value;
      else
        return;
    }
    if (a && (r.placeholderPattern != null || r.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!a && (r.placeholderPattern === !1 || !(r.placeholderPattern || wDe).test(n)) && !((s = r.placeholderWhitelist) != null && s.has(n)))
      return;
    t = t.slice();
    let {
      node: o,
      key: l
    } = t[t.length - 1], u;
    JB(e) || rh(e, {
      expectedNode: "StringLiteral"
    }) ? u = "string" : xDe(o) && l === "arguments" || bDe(o) && l === "arguments" || vDe(o) && l === "params" ? u = "param" : EDe(o) && !rh(
    e) ? (u = "statement", t = t.slice(0, -1)) : PDe(e) && rh(e) ? u = "statement" : u = "other";
    let {
      placeholders: c,
      placeholderNames: f
    } = a ? r.syntactic : r.legacy;
    c.push({
      name: n,
      type: u,
      resolve: /* @__PURE__ */ i((p) => _De(p, t), "resolve"),
      isDuplicate: f.has(n)
    }), f.add(n);
  }
  i(IDe, "placeholderVisitorHandler");
  function _De(e, t) {
    let r = e;
    for (let a = 0; a < t.length - 1; a++) {
      let {
        key: o,
        index: l
      } = t[a];
      l === void 0 ? r = r[o] : r = r[o][l];
    }
    let {
      key: s,
      index: n
    } = t[t.length - 1];
    return {
      parent: r,
      key: s,
      index: n
    };
  }
  i(_De, "resolveAncestors");
  function ODe(e, t, r) {
    let s = (t.plugins || []).slice();
    r !== !1 && s.push("placeholders"), t = Object.assign({
      allowReturnOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      sourceType: "module"
    }, t, {
      plugins: s
    });
    try {
      return (0, yDe.parse)(e, t);
    } catch (n) {
      let a = n.loc;
      throw a && (n.message += `
` + (0, gDe.codeFrameColumns)(e, {
        start: a
      }), n.code = "BABEL_TEMPLATE_PARSE_ERROR"), n;
    }
  }
  i(ODe, "parseWithCodeFrame");
});

// ../node_modules/@babel/template/lib/populate.js
var i1 = y((n1) => {
  "use strict";
  Object.defineProperty(n1, "__esModule", {
    value: !0
  });
  n1.default = BDe;
  var NDe = Ne(), {
    blockStatement: RDe,
    cloneNode: s1,
    emptyStatement: kDe,
    expressionStatement: r1,
    identifier: sh,
    isStatement: QB,
    isStringLiteral: FDe,
    stringLiteral: LDe,
    validate: ZB
  } = NDe;
  function BDe(e, t) {
    let r = s1(e.ast);
    return t && (e.placeholders.forEach((s) => {
      if (!hasOwnProperty.call(t, s.name)) {
        let n = s.name;
        throw new Error(`Error: No substitution given for "${n}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${n}'])}
            - { placeholderPattern: /^${n}$/ }`);
      }
    }), Object.keys(t).forEach((s) => {
      if (!e.placeholderNames.has(s))
        throw new Error(`Unknown substitution "${s}" given`);
    })), e.placeholders.slice().reverse().forEach((s) => {
      try {
        MDe(s, r, t && t[s.name] || null);
      } catch (n) {
        throw n.message = `@babel/template placeholder "${s.name}": ${n.message}`, n;
      }
    }), r;
  }
  i(BDe, "populatePlaceholders");
  function MDe(e, t, r) {
    e.isDuplicate && (Array.isArray(r) ? r = r.map((o) => s1(o)) : typeof r == "object" && (r = s1(r)));
    let {
      parent: s,
      key: n,
      index: a
    } = e.resolve(t);
    if (e.type === "string") {
      if (typeof r == "string" && (r = LDe(r)), !r || !FDe(r))
        throw new Error("Expected string substitution");
    } else if (e.type === "statement")
      a === void 0 ? r ? Array.isArray(r) ? r = RDe(r) : typeof r == "string" ? r = r1(sh(r)) : QB(r) || (r = r1(r)) : r = kDe() : r && !Array.
      isArray(r) && (typeof r == "string" && (r = sh(r)), QB(r) || (r = r1(r)));
    else if (e.type === "param") {
      if (typeof r == "string" && (r = sh(r)), a === void 0) throw new Error("Assertion failure.");
    } else if (typeof r == "string" && (r = sh(r)), Array.isArray(r))
      throw new Error("Cannot replace single expression with an array.");
    if (a === void 0)
      ZB(s, n, r), s[n] = r;
    else {
      let o = s[n].slice();
      e.type === "statement" || e.type === "param" ? r == null ? o.splice(a, 1) : Array.isArray(r) ? o.splice(a, 1, ...r) : o[a] = r : o[a] =
      r, ZB(s, n, o), s[n] = o;
    }
  }
  i(MDe, "applyReplacement");
});

// ../node_modules/@babel/template/lib/string.js
var eM = y((a1) => {
  "use strict";
  Object.defineProperty(a1, "__esModule", {
    value: !0
  });
  a1.default = UDe;
  var jDe = th(), qDe = t1(), $De = i1();
  function UDe(e, t, r) {
    t = e.code(t);
    let s;
    return (n) => {
      let a = (0, jDe.normalizeReplacements)(n);
      return s || (s = (0, qDe.default)(e, t, r)), e.unwrap((0, $De.default)(s, a));
    };
  }
  i(UDe, "stringTemplate");
});

// ../node_modules/@babel/template/lib/literal.js
var tM = y((o1) => {
  "use strict";
  Object.defineProperty(o1, "__esModule", {
    value: !0
  });
  o1.default = GDe;
  var VDe = th(), WDe = t1(), HDe = i1();
  function GDe(e, t, r) {
    let {
      metadata: s,
      names: n
    } = KDe(e, t, r);
    return (a) => {
      let o = {};
      return a.forEach((l, u) => {
        o[n[u]] = l;
      }), (l) => {
        let u = (0, VDe.normalizeReplacements)(l);
        return u && Object.keys(u).forEach((c) => {
          if (hasOwnProperty.call(o, c))
            throw new Error("Unexpected replacement overlap.");
        }), e.unwrap((0, HDe.default)(s, u ? Object.assign(u, o) : o));
      };
    };
  }
  i(GDe, "literalTemplate");
  function KDe(e, t, r) {
    let s = "BABEL_TPL$", n = t.join("");
    do
      s = "$$" + s;
    while (n.includes(s));
    let {
      names: a,
      code: o
    } = YDe(t, s);
    return {
      metadata: (0, WDe.default)(e, e.code(o), {
        parser: r.parser,
        placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
        placeholderPattern: r.placeholderPattern,
        preserveComments: r.preserveComments,
        syntacticPlaceholders: r.syntacticPlaceholders
      }),
      names: a
    };
  }
  i(KDe, "buildLiteralData");
  function YDe(e, t) {
    let r = [], s = e[0];
    for (let n = 1; n < e.length; n++) {
      let a = `${t}${n - 1}`;
      r.push(a), s += a + e[n];
    }
    return {
      names: r,
      code: s
    };
  }
  i(YDe, "buildTemplateCode");
});

// ../node_modules/@babel/template/lib/builder.js
var oM = y((l1) => {
  "use strict";
  Object.defineProperty(l1, "__esModule", {
    value: !0
  });
  l1.default = aM;
  var jn = th(), rM = eM(), sM = tM(), nM = (0, jn.validate)({
    placeholderPattern: !1
  });
  function aM(e, t) {
    let r = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap(), n = t || (0, jn.validate)(null);
    return Object.assign((a, ...o) => {
      if (typeof a == "string") {
        if (o.length > 1) throw new Error("Unexpected extra params.");
        return iM((0, rM.default)(e, a, (0, jn.merge)(n, (0, jn.validate)(o[0]))));
      } else if (Array.isArray(a)) {
        let l = r.get(a);
        return l || (l = (0, sM.default)(e, a, n), r.set(a, l)), iM(l(o));
      } else if (typeof a == "object" && a) {
        if (o.length > 0) throw new Error("Unexpected extra params.");
        return aM(e, (0, jn.merge)(n, (0, jn.validate)(a)));
      }
      throw new Error(`Unexpected template param ${typeof a}`);
    }, {
      ast: /* @__PURE__ */ i((a, ...o) => {
        if (typeof a == "string") {
          if (o.length > 1) throw new Error("Unexpected extra params.");
          return (0, rM.default)(e, a, (0, jn.merge)((0, jn.merge)(n, (0, jn.validate)(o[0])), nM))();
        } else if (Array.isArray(a)) {
          let l = s.get(a);
          return l || (l = (0, sM.default)(e, a, (0, jn.merge)(n, nM)), s.set(a, l)), l(o)();
        }
        throw new Error(`Unexpected template param ${typeof a}`);
      }, "ast")
    });
  }
  i(aM, "createTemplateBuilder");
  function iM(e) {
    let t = "";
    try {
      throw new Error();
    } catch (r) {
      r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
    }
    return (r) => {
      try {
        return e(r);
      } catch (s) {
        throw s.stack += `
    =============
${t}`, s;
      }
    };
  }
  i(iM, "extendedTrace");
});

// ../node_modules/@babel/template/lib/index.js
var Al = y((bs) => {
  "use strict";
  Object.defineProperty(bs, "__esModule", {
    value: !0
  });
  bs.statements = bs.statement = bs.smart = bs.program = bs.expression = bs.default = void 0;
  var Lc = zB(), Bc = oM(), u1 = bs.smart = (0, Bc.default)(Lc.smart), XDe = bs.statement = (0, Bc.default)(Lc.statement), zDe = bs.statements =
  (0, Bc.default)(Lc.statements), JDe = bs.expression = (0, Bc.default)(Lc.expression), QDe = bs.program = (0, Bc.default)(Lc.program), Ott = bs.
  default = Object.assign(u1.bind(void 0), {
    smart: u1,
    statement: XDe,
    statements: zDe,
    expression: JDe,
    program: QDe,
    ast: u1.ast
  });
});

// ../node_modules/@babel/helper-function-name/lib/index.js
var nh = y((c1) => {
  "use strict";
  Object.defineProperty(c1, "__esModule", {
    value: !0
  });
  c1.default = E2e;
  var fM = Al(), ZDe = Ne(), {
    NOT_LOCAL_BINDING: lM,
    cloneNode: e2e,
    identifier: t2e,
    isAssignmentExpression: r2e,
    isAssignmentPattern: s2e,
    isFunction: pM,
    isIdentifier: uM,
    isLiteral: cM,
    isNullLiteral: n2e,
    isObjectMethod: i2e,
    isObjectProperty: a2e,
    isRegExpLiteral: o2e,
    isRestElement: l2e,
    isTemplateLiteral: u2e,
    isVariableDeclarator: c2e,
    toBindingIdentifierName: f2e
  } = ZDe;
  function p2e(e) {
    let t = e.params.findIndex((r) => s2e(r) || l2e(r));
    return t === -1 ? e.params.length : t;
  }
  i(p2e, "getFunctionArity");
  var d2e = fM.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), h2e = fM.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), m2e = {
    "ReferencedIdentifier|BindingIdentifier"(e, t) {
      e.node.name !== t.name || e.scope.getBindingIdentifier(t.name) !== t.outerDeclar || (t.selfReference = !0, e.stop());
    }
  };
  function y2e(e) {
    return n2e(e) ? "null" : o2e(e) ? `_${e.pattern}_${e.flags}` : u2e(e) ? e.quasis.map((t) => t.value.raw).join("") : e.value !== void 0 ?
    e.value + "" : "";
  }
  i(y2e, "getNameFromLiteralId");
  function g2e(e, t, r, s) {
    if (e.selfReference)
      if (s.hasBinding(r.name) && !s.hasGlobal(r.name))
        s.rename(r.name);
      else {
        if (!pM(t)) return;
        let n = d2e;
        t.generator && (n = h2e);
        let a = n({
          FUNCTION: t,
          FUNCTION_ID: r,
          FUNCTION_KEY: s.generateUidIdentifier(r.name)
        }).expression, o = a.callee.body.body[0].params;
        for (let l = 0, u = p2e(t); l < u; l++)
          o.push(s.generateUidIdentifier("x"));
        return a;
      }
    t.id = r, s.getProgramParent().references[r.name] = !0;
  }
  i(g2e, "wrap");
  function b2e(e, t, r) {
    let s = {
      selfAssignment: !1,
      selfReference: !1,
      outerDeclar: r.getBindingIdentifier(t),
      name: t
    }, n = r.getOwnBinding(t);
    return n ? n.kind === "param" && (s.selfReference = !0) : (s.outerDeclar || r.hasGlobal(t)) && r.traverse(e, m2e, s), s;
  }
  i(b2e, "visit");
  function E2e({
    node: e,
    parent: t,
    scope: r,
    id: s
  }, n = !1, a = !1) {
    if (e.id) return;
    if ((a2e(t) || i2e(t, {
      kind: "method"
    })) && (!t.computed || cM(t.key)))
      s = t.key;
    else if (c2e(t)) {
      if (s = t.id, uM(s) && !n) {
        let c = r.parent.getBinding(s.name);
        if (c && c.constant && r.getBinding(s.name) === c) {
          e.id = e2e(s), e.id[lM] = !0;
          return;
        }
      }
    } else if (r2e(t, {
      operator: "="
    }))
      s = t.left;
    else if (!s)
      return;
    let o;
    if (s && cM(s) ? o = y2e(s) : s && uM(s) && (o = s.name), o === void 0 || !a && pM(e) && /[\uD800-\uDFFF]/.test(o))
      return;
    o = f2e(o);
    let l = t2e(o);
    l[lM] = !0;
    let u = b2e(e, o, r);
    return g2e(u, e, l, r) || e;
  }
  i(E2e, "_default");
});

// ../node_modules/@babel/traverse/lib/path/conversion.js
var gM = y((lo) => {
  "use strict";
  Object.defineProperty(lo, "__esModule", {
    value: !0
  });
  lo.arrowFunctionToExpression = $2e;
  lo.ensureBlock = M2e;
  lo.toComputedKey = B2e;
  lo.unwrapFunctionEnvironment = j2e;
  var v2e = Ne(), d1 = sa(), S2e = nh(), h1 = fc(), {
    arrowFunctionExpression: m1,
    assignmentExpression: oo,
    binaryExpression: f1,
    blockStatement: T2e,
    callExpression: Cl,
    conditionalExpression: x2e,
    expressionStatement: dM,
    identifier: Ht,
    isIdentifier: P2e,
    jsxIdentifier: A2e,
    logicalExpression: C2e,
    LOGICAL_OPERATORS: w2e,
    memberExpression: hn,
    metaProperty: D2e,
    numericLiteral: I2e,
    objectExpression: _2e,
    restElement: O2e,
    returnStatement: N2e,
    sequenceExpression: R2e,
    spreadElement: k2e,
    stringLiteral: hM,
    super: p1,
    thisExpression: Mc,
    toExpression: F2e,
    unaryExpression: L2e
  } = v2e;
  function B2e() {
    let e;
    if (this.isMemberExpression())
      e = this.node.property;
    else if (this.isProperty() || this.isMethod())
      e = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || P2e(e) && (e = hM(e.name)), e;
  }
  i(B2e, "toComputedKey");
  function M2e() {
    let e = this.get("body"), t = e.node;
    if (Array.isArray(e))
      throw new Error("Can't convert array path to a block statement");
    if (!t)
      throw new Error("Can't convert node without a body");
    if (e.isBlockStatement())
      return t;
    let r = [], s = "body", n, a;
    e.isStatement() ? (a = "body", n = 0, r.push(e.node)) : (s += ".body.0", this.isFunction() ? (n = "argument", r.push(N2e(e.node))) : (n =
    "expression", r.push(dM(e.node)))), this.node.body = T2e(r);
    let o = this.get(s);
    return e.setup(o, a ? o.node[a] : o.node, a, n), this.node;
  }
  i(M2e, "ensureBlock");
  lo.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function j2e() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    mM(this);
  }
  i(j2e, "unwrapFunctionEnvironment");
  function q2e(e, t) {
    e.node.type = t;
  }
  i(q2e, "setType");
  function $2e({
    allowInsertArrow: e = !0,
    allowInsertArrowWithRest: t = e,
    noNewArrows: r = !((s) => (s = arguments[0]) == null ? void 0 : s.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let {
      thisBinding: s,
      fnPath: n
    } = mM(this, r, e, t);
    if (n.ensureBlock(), q2e(n, "FunctionExpression"), !r) {
      let a = s ? null : n.scope.generateUidIdentifier("arrowCheckId");
      return a && n.parentPath.scope.push({
        id: a,
        init: _2e([])
      }), n.get("body").unshiftContainer("body", dM(Cl(this.hub.addHelper("newArrowCheck"), [Mc(), Ht(a ? a.name : s)]))), n.replaceWith(Cl(
      hn((0, S2e.default)(this, !0) || n.node, Ht("bind")), [a ? Ht(a.name) : Mc()])), n.get("callee.object");
    }
    return n;
  }
  i($2e, "arrowFunctionToExpression");
  var U2e = (0, h1.merge)([{
    CallExpression(e, {
      allSuperCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    }
  }, d1.default]);
  function mM(e, t = !0, r = !0, s = !0) {
    let n, a = e.findParent((m) => {
      if (m.isArrowFunctionExpression()) {
        var b;
        return (b = n) != null || (n = m), !1;
      }
      return m.isFunction() || m.isProgram() || m.isClassProperty({
        static: !1
      }) || m.isClassPrivateProperty({
        static: !1
      });
    }), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (n)
        a = n;
      else if (r)
        e.replaceWith(Cl(m1([], F2e(e.node)), [])), a = e.get("callee"), e = a.get("body");
      else
        throw e.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: l,
      argumentsPaths: u,
      newTargetPaths: c,
      superProps: f,
      superCalls: p
    } = z2e(e);
    if (o && p.length > 0) {
      if (!r)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!s)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let m = [];
      a.traverse(U2e, {
        allSuperCalls: m
      });
      let b = K2e(a);
      m.forEach((h) => {
        let g = Ht(b);
        g.loc = h.node.callee.loc, h.get("callee").replaceWith(g);
      });
    }
    if (u.length > 0) {
      let m = jc(a, "arguments", () => {
        let b = /* @__PURE__ */ i(() => Ht("arguments"), "args");
        return a.scope.path.isProgram() ? x2e(f1("===", L2e("typeof", b()), hM("undefined")), a.scope.buildUndefinedNode(), b()) : b();
      });
      u.forEach((b) => {
        let h = Ht(m);
        h.loc = b.node.loc, b.replaceWith(h);
      });
    }
    if (c.length > 0) {
      let m = jc(a, "newtarget", () => D2e(Ht("new"), Ht("target")));
      c.forEach((b) => {
        let h = Ht(m);
        h.loc = b.node.loc, b.replaceWith(h);
      });
    }
    if (f.length > 0) {
      if (!r)
        throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      f.reduce((b, h) => b.concat(W2e(h)), []).forEach((b) => {
        let h = b.node.computed ? "" : b.get("property").node.name, g = b.parentPath, E = g.isAssignmentExpression({
          left: b.node
        }), D = g.isCallExpression({
          callee: b.node
        }), C = g.isTaggedTemplateExpression({
          tag: b.node
        }), N = Y2e(a, E, h), I = [];
        if (b.node.computed && I.push(b.get("property").node), E) {
          let q = g.node.right;
          I.push(q);
        }
        let M = Cl(Ht(N), I);
        D ? (g.unshiftContainer("arguments", Mc()), b.replaceWith(hn(M, Ht("call"))), l.push(g.get("arguments.0"))) : E ? g.replaceWith(M) :
        C ? (b.replaceWith(Cl(hn(M, Ht("bind"), !1), [Mc()])), l.push(b.get("arguments.0"))) : b.replaceWith(M);
      });
    }
    let d;
    return (l.length > 0 || !t) && (d = G2e(a, o), (t || o && yM(a)) && (l.forEach((m) => {
      let b = m.isJSX() ? A2e(d) : Ht(d);
      b.loc = m.node.loc, m.replaceWith(b);
    }), t || (d = null))), {
      thisBinding: d,
      fnPath: e
    };
  }
  i(mM, "hoistFunctionEnvironment");
  function V2e(e) {
    return w2e.includes(e);
  }
  i(V2e, "isLogicalOp");
  function W2e(e) {
    if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
      let r = e.parentPath, s = r.node.operator.slice(0, -1), n = r.node.right, a = V2e(s);
      if (e.node.computed) {
        let o = e.scope.generateDeclaredUidIdentifier("tmp"), l = e.node.object, u = e.node.property;
        r.get("left").replaceWith(hn(l, oo("=", o, u), !0)), r.get("right").replaceWith(t(a ? "=" : s, hn(l, Ht(o.name), !0), n));
      } else {
        let o = e.node.object, l = e.node.property;
        r.get("left").replaceWith(hn(o, l)), r.get("right").replaceWith(t(a ? "=" : s, hn(o, Ht(l.name)), n));
      }
      return a ? r.replaceWith(C2e(s, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
    } else if (e.parentPath.isUpdateExpression()) {
      let r = e.parentPath, s = e.scope.generateDeclaredUidIdentifier("tmp"), n = e.node.computed ? e.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [oo("=", s, hn(e.node.object, n ? oo("=", n, e.node.property) : e.node.property, e.node.computed)), oo("=", hn(e.node.object,
      n ? Ht(n.name) : e.node.property, e.node.computed), f1(e.parentPath.node.operator[0], Ht(s.name), I2e(1)))];
      e.parentPath.node.prefix || a.push(Ht(s.name)), r.replaceWith(R2e(a));
      let o = r.get("expressions.0.right"), l = r.get("expressions.1.left");
      return [o, l];
    }
    return [e];
    function t(r, s, n) {
      return r === "=" ? oo("=", s, n) : f1(r, s, n);
    }
  }
  i(W2e, "standardizeSuperProperty");
  function yM(e) {
    return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
  }
  i(yM, "hasSuperClass");
  var H2e = (0, h1.merge)([{
    CallExpression(e, {
      supers: t,
      thisBinding: r
    }) {
      e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, oo("=", Ht(r), Ht("this"))])));
    }
  }, d1.default]);
  function G2e(e, t) {
    return jc(e, "this", (r) => {
      if (!t || !yM(e)) return Mc();
      e.traverse(H2e, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: r
      });
    });
  }
  i(G2e, "getThisBinding");
  function K2e(e) {
    return jc(e, "supercall", () => {
      let t = e.scope.generateUidIdentifier("args");
      return m1([O2e(t)], Cl(p1(), [k2e(Ht(t.name))]));
    });
  }
  i(K2e, "getSuperBinding");
  function Y2e(e, t, r) {
    return jc(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
      let n = [], a;
      if (r)
        a = hn(p1(), Ht(r));
      else {
        let o = e.scope.generateUidIdentifier("prop");
        n.unshift(o), a = hn(p1(), Ht(o.name), !0);
      }
      if (t) {
        let o = e.scope.generateUidIdentifier("value");
        n.push(o), a = oo("=", a, Ht(o.name));
      }
      return m1(n, a);
    });
  }
  i(Y2e, "getSuperPropBinding");
  function jc(e, t, r) {
    let s = "binding:" + t, n = e.getData(s);
    if (!n) {
      let a = e.scope.generateUidIdentifier(t);
      n = a.name, e.setData(s, n), e.scope.push({
        id: a,
        init: r(n)
      });
    }
    return n;
  }
  i(jc, "getBinding");
  var X2e = (0, h1.merge)([{
    ThisExpression(e, {
      thisPaths: t
    }) {
      t.push(e);
    },
    JSXIdentifier(e, {
      thisPaths: t
    }) {
      e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
        object: e.node
      }) && !e.parentPath.isJSXOpeningElement({
        name: e.node
      }) || t.push(e));
    },
    CallExpression(e, {
      superCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    },
    MemberExpression(e, {
      superProps: t
    }) {
      e.get("object").isSuper() && t.push(e);
    },
    Identifier(e, {
      argumentsPaths: t
    }) {
      if (!e.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let r = e.scope;
      do {
        if (r.hasOwnBinding("arguments")) {
          r.rename("arguments");
          return;
        }
        if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
      } while (r = r.parent);
      t.push(e);
    },
    MetaProperty(e, {
      newTargetPaths: t
    }) {
      e.get("meta").isIdentifier({
        name: "new"
      }) && e.get("property").isIdentifier({
        name: "target"
      }) && t.push(e);
    }
  }, d1.default]);
  function z2e(e) {
    let t = [], r = [], s = [], n = [], a = [];
    return e.traverse(X2e, {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: s,
      superProps: n,
      superCalls: a
    }), {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: s,
      superProps: n,
      superCalls: a
    };
  }
  i(z2e, "getScopeInformation");
});

// ../node_modules/@babel/traverse/lib/path/introspection.js
var xM = y((fr) => {
  "use strict";
  Object.defineProperty(fr, "__esModule", {
    value: !0
  });
  fr._guessExecutionStatusRelativeTo = EIe;
  fr._resolve = xIe;
  fr.canHaveVariableDeclarationOrExpression = fIe;
  fr.canSwapBetweenExpressionAndStatement = pIe;
  fr.equals = uIe;
  fr.getSource = yIe;
  fr.has = TM;
  fr.is = void 0;
  fr.isCompletionRecord = dIe;
  fr.isConstantExpression = PIe;
  fr.isInStrictMode = AIe;
  fr.isNodeType = cIe;
  fr.isStatementOrBlock = hIe;
  fr.isStatic = oIe;
  fr.isnt = lIe;
  fr.matchesPattern = aIe;
  fr.referencesImport = mIe;
  fr.resolve = TIe;
  fr.willIMaybeExecuteBefore = gIe;
  var J2e = Ne(), {
    STATEMENT_OR_BLOCK_KEYS: Q2e,
    VISITOR_KEYS: Z2e,
    isBlockStatement: SM,
    isExpression: eIe,
    isIdentifier: tIe,
    isLiteral: rIe,
    isStringLiteral: sIe,
    isType: nIe,
    matchesPattern: iIe
  } = J2e;
  function aIe(e, t) {
    return iIe(this.node, e, t);
  }
  i(aIe, "matchesPattern");
  function TM(e) {
    let t = this.node && this.node[e];
    return t && Array.isArray(t) ? !!t.length : !!t;
  }
  i(TM, "has");
  function oIe() {
    return this.scope.isStatic(this.node);
  }
  i(oIe, "isStatic");
  var Btt = fr.is = TM;
  function lIe(e) {
    return !this.has(e);
  }
  i(lIe, "isnt");
  function uIe(e, t) {
    return this.node[e] === t;
  }
  i(uIe, "equals");
  function cIe(e) {
    return nIe(this.type, e);
  }
  i(cIe, "isNodeType");
  function fIe() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  i(fIe, "canHaveVariableDeclarationOrExpression");
  function pIe(e) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? SM(e) : this.isBlockStatement() ?
    eIe(e) : !1;
  }
  i(pIe, "canSwapBetweenExpressionAndStatement");
  function dIe(e) {
    let t = this, r = !0;
    do {
      let {
        type: s,
        container: n
      } = t;
      if (!r && (t.isFunction() || s === "StaticBlock"))
        return !!e;
      if (r = !1, Array.isArray(n) && t.key !== n.length - 1)
        return !1;
    } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
    return !0;
  }
  i(dIe, "isCompletionRecord");
  function hIe() {
    return this.parentPath.isLabeledStatement() || SM(this.container) ? !1 : Q2e.includes(this.key);
  }
  i(hIe, "isStatementOrBlock");
  function mIe(e, t) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? sIe(this.node.property, {
        value: t
      }) : this.node.property.name === t)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(e, "*");
      }
      return !1;
    }
    let r = this.scope.getBinding(this.node.name);
    if (!r || r.kind !== "module") return !1;
    let s = r.path, n = s.parentPath;
    if (!n.isImportDeclaration()) return !1;
    if (n.node.source.value === e) {
      if (!t) return !0;
    } else
      return !1;
    return !!(s.isImportDefaultSpecifier() && t === "default" || s.isImportNamespaceSpecifier() && t === "*" || s.isImportSpecifier() && tIe(
    s.node.imported, {
      name: t
    }));
  }
  i(mIe, "referencesImport");
  function yIe() {
    let e = this.node;
    if (e.end) {
      let t = this.hub.getCode();
      if (t) return t.slice(e.start, e.end);
    }
    return "";
  }
  i(yIe, "getSource");
  function gIe(e) {
    return this._guessExecutionStatusRelativeTo(e) !== "after";
  }
  i(gIe, "willIMaybeExecuteBefore");
  function bM(e) {
    return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
  }
  i(bM, "getOuterFunction");
  function bIe(e, t) {
    switch (e) {
      case "LogicalExpression":
        return t === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return t === "consequent" || t === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return t === "body";
      case "ForStatement":
        return t === "body" || t === "update";
      case "SwitchStatement":
        return t === "cases";
      case "TryStatement":
        return t === "handler";
      case "AssignmentPattern":
        return t === "right";
      case "OptionalMemberExpression":
        return t === "property";
      case "OptionalCallExpression":
        return t === "arguments";
      default:
        return !1;
    }
  }
  i(bIe, "isExecutionUncertain");
  function EM(e, t) {
    for (let r = 0; r < t; r++) {
      let s = e[r];
      if (bIe(s.parent.type, s.parentKey))
        return !0;
    }
    return !1;
  }
  i(EM, "isExecutionUncertainInList");
  var vM = Symbol();
  function EIe(e) {
    return y1(this, e, /* @__PURE__ */ new Map());
  }
  i(EIe, "_guessExecutionStatusRelativeTo");
  function y1(e, t, r) {
    let s = {
      this: bM(e),
      target: bM(t)
    };
    if (s.target.node !== s.this.node)
      return SIe(e, s.target, r);
    let n = {
      target: t.getAncestry(),
      this: e.getAncestry()
    };
    if (n.target.indexOf(e) >= 0) return "after";
    if (n.this.indexOf(t) >= 0) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < n.this.length; ) {
      let f = n.this[o.this];
      o.target = n.target.indexOf(f), o.target >= 0 ? a = f : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (EM(n.this, o.this - 1) || EM(n.target, o.target - 1))
      return "unknown";
    let l = {
      this: n.this[o.this - 1],
      target: n.target[o.target - 1]
    };
    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container)
      return l.target.key > l.this.key ? "before" : "after";
    let u = Z2e[a.type], c = {
      this: u.indexOf(l.this.parentKey),
      target: u.indexOf(l.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  i(y1, "_guessExecutionStatusRelativeToCached");
  function vIe(e, t, r) {
    if (t.isFunctionDeclaration()) {
      if (t.parentPath.isExportDeclaration())
        return "unknown";
    } else return y1(e, t, r) === "before" ? "before" : "unknown";
    let s = t.scope.getBinding(t.node.id.name);
    if (!s.references) return "before";
    let n = s.referencePaths, a;
    for (let o of n) {
      if (!!o.find((c) => c.node === t.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let u = y1(e, o, r);
      if (a && a !== u)
        return "unknown";
      a = u;
    }
    return a;
  }
  i(vIe, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function SIe(e, t, r) {
    let s = r.get(e.node), n;
    if (!s)
      r.set(e.node, s = /* @__PURE__ */ new Map());
    else if (n = s.get(t.node))
      return n === vM ? "unknown" : n;
    s.set(t.node, vM);
    let a = vIe(e, t, r);
    return s.set(t.node, a), a;
  }
  i(SIe, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function TIe(e, t) {
    return this._resolve(e, t) || this;
  }
  i(TIe, "resolve");
  function xIe(e, t) {
    if (!(t && t.indexOf(this) >= 0))
      if (t = t || [], t.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(e, t);
      } else if (this.isReferencedIdentifier()) {
        let r = this.scope.getBinding(this.node.name);
        if (!r || !r.constant || r.kind === "module") return;
        if (r.path !== this) {
          let s = r.path.resolve(e, t);
          return this.find((n) => n.node === s.node) ? void 0 : s;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(e, t);
        if (e && this.isMemberExpression()) {
          let r = this.toComputedKey();
          if (!rIe(r)) return;
          let s = r.value, n = this.get("object").resolve(e, t);
          if (n.isObjectExpression()) {
            let a = n.get("properties");
            for (let o of a) {
              if (!o.isProperty()) continue;
              let l = o.get("key"), u = o.isnt("computed") && l.isIdentifier({
                name: s
              });
              if (u = u || l.isLiteral({
                value: s
              }), u) return o.get("value").resolve(e, t);
            }
          } else if (n.isArrayExpression() && !isNaN(+s)) {
            let o = n.get("elements")[s];
            if (o) return o.resolve(e, t);
          }
        }
      }
  }
  i(xIe, "_resolve");
  function PIe() {
    if (this.isIdentifier()) {
      let e = this.scope.getBinding(this.node.name);
      return e ? e.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: e
      } = this.node;
      return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  i(PIe, "isConstantExpression");
  function AIe() {
    return !!(this.isProgram() ? this : this.parentPath).find((r) => {
      if (r.isProgram({
        sourceType: "module"
      }) || r.isClass()) return !0;
      if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
        return !1;
      let s;
      if (r.isFunction())
        s = r.node.body;
      else if (r.isProgram())
        s = r.node;
      else
        return !1;
      for (let n of s.directives)
        if (n.value.value === "use strict")
          return !0;
    });
  }
  i(AIe, "isInStrictMode");
});

// ../node_modules/@babel/traverse/lib/path/context.js
var CM = y((ar) => {
  "use strict";
  Object.defineProperty(ar, "__esModule", {
    value: !0
  });
  ar._call = DIe;
  ar._getQueueContexts = GIe;
  ar._resyncKey = MIe;
  ar._resyncList = jIe;
  ar._resyncParent = BIe;
  ar._resyncRemoved = qIe;
  ar.call = wIe;
  ar.isBlacklisted = ar.isDenylisted = IIe;
  ar.popContext = $Ie;
  ar.pushContext = UIe;
  ar.requeue = HIe;
  ar.resync = LIe;
  ar.setContext = FIe;
  ar.setKey = WIe;
  ar.setScope = kIe;
  ar.setup = VIe;
  ar.skip = OIe;
  ar.skipKey = NIe;
  ar.stop = RIe;
  ar.visit = _Ie;
  var CIe = pd(), PM = da();
  function wIe(e) {
    let t = this.opts;
    if (this.debug(e), this.node && this._call(t[e]))
      return !0;
    if (this.node) {
      var r;
      return this._call((r = t[this.node.type]) == null ? void 0 : r[e]);
    }
    return !1;
  }
  i(wIe, "call");
  function DIe(e) {
    if (!e) return !1;
    for (let t of e) {
      if (!t) continue;
      let r = this.node;
      if (!r) return !0;
      let s = t.call(this.state, this, this.state);
      if (s && typeof s == "object" && typeof s.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (s)
        throw new Error(`Unexpected return value from visitor method ${t}`);
      if (this.node !== r || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  i(DIe, "_call");
  function IIe() {
    var e;
    let t = (e = this.opts.denylist) != null ? e : this.opts.blacklist;
    return t && t.indexOf(this.node.type) > -1;
  }
  i(IIe, "isDenylisted");
  function AM(e, t) {
    e.context !== t && (e.context = t, e.state = t.state, e.opts = t.opts);
  }
  i(AM, "restoreContext");
  function _Ie() {
    var e, t;
    if (!this.node || this.isDenylisted() || (e = (t = this.opts).shouldSkip) != null && e.call(t, this))
      return !1;
    let r = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (AM(this, r), this.debug("Recursing into..."),
    this.shouldStop = (0, CIe.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), AM(this, r), this.call("exit"),
    this.shouldStop);
  }
  i(_Ie, "visit");
  function OIe() {
    this.shouldSkip = !0;
  }
  i(OIe, "skip");
  function NIe(e) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[e] = !0;
  }
  i(NIe, "skipKey");
  function RIe() {
    this._traverseFlags |= PM.SHOULD_SKIP | PM.SHOULD_STOP;
  }
  i(RIe, "stop");
  function kIe() {
    var e, t;
    if ((e = this.opts) != null && e.noScope) return;
    let r = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) && (r = r.
    parentPath);
    let s;
    for (; r && !s; ) {
      var n;
      if ((n = r.opts) != null && n.noScope) return;
      s = r.scope, r = r.parentPath;
    }
    this.scope = this.getScope(s), (t = this.scope) == null || t.init();
  }
  i(kIe, "setScope");
  function FIe(e) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, e && (this.context = e, this.state = e.state, this.opts =
    e.opts), this.setScope(), this;
  }
  i(FIe, "setContext");
  function LIe() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }
  i(LIe, "resync");
  function BIe() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  i(BIe, "_resyncParent");
  function MIe() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let e = 0; e < this.container.length; e++)
          if (this.container[e] === this.node) {
            this.setKey(e);
            return;
          }
      } else
        for (let e of Object.keys(this.container))
          if (this.container[e] === this.node) {
            this.setKey(e);
            return;
          }
      this.key = null;
    }
  }
  i(MIe, "_resyncKey");
  function jIe() {
    if (!this.parent || !this.inList) return;
    let e = this.parent[this.listKey];
    this.container !== e && (this.container = e || null);
  }
  i(jIe, "_resyncList");
  function qIe() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && this._markRemoved();
  }
  i(qIe, "_resyncRemoved");
  function $Ie() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  i($Ie, "popContext");
  function UIe(e) {
    this.contexts.push(e), this.setContext(e);
  }
  i(UIe, "pushContext");
  function VIe(e, t, r, s) {
    this.listKey = r, this.container = t, this.parentPath = e || this.parentPath, this.setKey(s);
  }
  i(VIe, "setup");
  function WIe(e) {
    var t;
    this.key = e, this.node = this.container[this.key], this.type = (t = this.node) == null ? void 0 : t.type;
  }
  i(WIe, "setKey");
  function HIe(e = this) {
    if (e.removed) return;
    let t = this.contexts;
    for (let r of t)
      r.maybeQueue(e);
  }
  i(HIe, "requeue");
  function GIe() {
    let e = this, t = this.contexts;
    for (; !t.length && (e = e.parentPath, !!e); )
      t = e.contexts;
    return t;
  }
  i(GIe, "_getQueueContexts");
});

// ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var wM = y((ih) => {
  "use strict";
  Object.defineProperty(ih, "__esModule", {
    value: !0
  });
  ih.hooks = void 0;
  var Utt = ih.hooks = [function(e, t) {
    if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.
    isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expr\
ession" && t.isExpressionStatement())
      return t.remove(), !0;
  }, function(e, t) {
    if (t.isSequenceExpression() && t.node.expressions.length === 1)
      return t.replaceWith(t.node.expressions[0]), !0;
  }, function(e, t) {
    if (t.isBinary())
      return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
  }, function(e, t) {
    if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
      return e.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/traverse/lib/path/removal.js
var IM = y((ha) => {
  "use strict";
  Object.defineProperty(ha, "__esModule", {
    value: !0
  });
  ha._assertUnremoved = r_e;
  ha._callRemovalHooks = ZIe;
  ha._markRemoved = t_e;
  ha._remove = e_e;
  ha._removeFromScope = QIe;
  ha.remove = JIe;
  var KIe = wM(), YIe = za(), DM = da(), XIe = Ne(), {
    getBindingIdentifiers: zIe
  } = XIe;
  function JIe() {
    var e;
    if (this._assertUnremoved(), this.resync(), (e = this.opts) != null && e.noScope || this._removeFromScope(), this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
  }
  i(JIe, "remove");
  function QIe() {
    let e = zIe(this.node, !1, !1, !0);
    Object.keys(e).forEach((t) => this.scope.removeBinding(t));
  }
  i(QIe, "_removeFromScope");
  function ZIe() {
    if (this.parentPath) {
      for (let e of KIe.hooks)
        if (e(this, this.parentPath)) return !0;
    }
  }
  i(ZIe, "_callRemovalHooks");
  function e_e() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }
  i(e_e, "_remove");
  function t_e() {
    this._traverseFlags |= DM.SHOULD_SKIP | DM.REMOVED, this.parent && (0, YIe.getCachedPaths)(this.hub, this.parent).delete(this.node), this.
    node = null;
  }
  i(t_e, "_markRemoved");
  function r_e() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  i(r_e, "_assertUnremoved");
});

// ../node_modules/@babel/traverse/lib/path/lib/hoister.js
var OM = y((ah) => {
  "use strict";
  Object.defineProperty(ah, "__esModule", {
    value: !0
  });
  ah.default = void 0;
  var _M = Ne(), s_e = _M, {
    react: n_e
  } = _M, {
    cloneNode: i_e,
    jsxExpressionContainer: a_e,
    variableDeclaration: o_e,
    variableDeclarator: l_e
  } = s_e, u_e = {
    ReferencedIdentifier(e, t) {
      if (e.isJSXIdentifier() && n_e.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
        return;
      if (e.node.name === "this") {
        let s = e.scope;
        do
          if (s.path.isFunction() && !s.path.isArrowFunctionExpression())
            break;
        while (s = s.parent);
        s && t.breakOnScopePaths.push(s.path);
      }
      let r = e.scope.getBinding(e.node.name);
      if (r) {
        for (let s of r.constantViolations)
          if (s.scope !== r.path.scope) {
            t.mutableBinding = !0, e.stop();
            return;
          }
        r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
      }
    }
  }, g1 = class {
    static {
      i(this, "PathHoister");
    }
    constructor(t, r) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = r, this.path = t, this.attachAfter = !1;
    }
    isCompatibleScope(t) {
      for (let r of Object.keys(this.bindings)) {
        let s = this.bindings[r];
        if (!t.bindingIdentifierEquals(r, s.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let t = this.path.scope;
      do {
        if (this.isCompatibleScope(t))
          this.scopes.push(t);
        else
          break;
        if (this.breakOnScopePaths.indexOf(t.path) >= 0)
          break;
      } while (t = t.parent);
    }
    getAttachmentPath() {
      let t = this._getAttachmentPath();
      if (!t) return;
      let r = t.scope;
      if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction())
        for (let s of Object.keys(this.bindings)) {
          if (!r.hasOwnBinding(s)) continue;
          let n = this.bindings[s];
          if (n.kind === "param" || n.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(n.path).key >= t.key) {
            this.attachAfter = !0, t = n.path;
            for (let o of n.constantViolations)
              this.getAttachmentParentForPath(o).key > t.key && (t = o);
          }
        }
      return t;
    }
    _getAttachmentPath() {
      let r = this.scopes.pop();
      if (r) {
        if (r.path.isFunction())
          if (this.hasOwnParamBindings(r)) {
            if (this.scope === r) return;
            let s = r.path.get("body").get("body");
            for (let n = 0; n < s.length; n++)
              if (!s[n].node._blockHoist)
                return s[n];
          } else
            return this.getNextScopeAttachmentParent();
        else if (r.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let t = this.scopes.pop();
      if (t) return this.getAttachmentParentForPath(t.path);
    }
    getAttachmentParentForPath(t) {
      do
        if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
          return t;
      while (t = t.parentPath);
    }
    hasOwnParamBindings(t) {
      for (let r of Object.keys(this.bindings)) {
        if (!t.hasOwnBinding(r)) continue;
        let s = this.bindings[r];
        if (s.kind === "param" && s.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(u_e, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let t = this.getAttachmentPath();
      if (!t || t.getFunctionParent() === this.path.getFunctionParent()) return;
      let r = t.scope.generateUidIdentifier("ref"), s = l_e(r, this.path.node), n = this.attachAfter ? "insertAfter" : "insertBefore", [a] = t[n](
      [t.isVariableDeclarator() ? s : o_e("var", [s])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (r = a_e(r)), this.path.replaceWith(i_e(r)), t.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  ah.default = g1;
});

// ../node_modules/@babel/traverse/lib/path/modification.js
var LM = y((Us) => {
  "use strict";
  Object.defineProperty(Us, "__esModule", {
    value: !0
  });
  Us._containerInsert = A_e;
  Us._containerInsertAfter = w_e;
  Us._containerInsertBefore = C_e;
  Us._verifyNodeList = O_e;
  Us.hoist = k_e;
  Us.insertAfter = I_e;
  Us.insertBefore = P_e;
  Us.pushContainer = R_e;
  Us.unshiftContainer = N_e;
  Us.updateSiblingKeys = __e;
  var c_e = za(), f_e = OM(), v1 = da(), p_e = Ne(), {
    arrowFunctionExpression: d_e,
    assertExpression: h_e,
    assignmentExpression: m_e,
    blockStatement: NM,
    callExpression: y_e,
    cloneNode: b1,
    expressionStatement: E1,
    isAssignmentExpression: g_e,
    isCallExpression: b_e,
    isExportNamedDeclaration: RM,
    isExpression: E_e,
    isIdentifier: v_e,
    isSequenceExpression: S_e,
    isSuper: T_e,
    thisExpression: x_e
  } = p_e;
  function P_e(e) {
    this._assertUnremoved();
    let t = this._verifyNodeList(e), {
      parentPath: r,
      parent: s
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || RM(s) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertBefore(t);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init")
      return this.node && t.push(this.node), this.replaceExpressionWithStatements(t);
    if (Array.isArray(this.container))
      return this._containerInsertBefore(t);
    if (this.isStatementOrBlock()) {
      let n = this.node, a = n && (!this.isExpressionStatement() || n.expression != null);
      return this.replaceWith(NM(a ? [n] : [])), this.unshiftContainer("body", t);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  i(P_e, "insertBefore");
  function A_e(e, t) {
    this.updateSiblingKeys(e, t.length);
    let r = [];
    this.container.splice(e, 0, ...t);
    for (let a = 0; a < t.length; a++) {
      var s;
      let o = e + a, l = this.getSibling(o);
      r.push(l), (s = this.context) != null && s.queue && l.pushContext(this.context);
    }
    let n = this._getQueueContexts();
    for (let a of r) {
      a.setScope(), a.debug("Inserted.");
      for (let o of n)
        o.maybeQueue(a, !0);
    }
    return r;
  }
  i(A_e, "_containerInsert");
  function C_e(e) {
    return this._containerInsert(this.key, e);
  }
  i(C_e, "_containerInsertBefore");
  function w_e(e) {
    return this._containerInsert(this.key + 1, e);
  }
  i(w_e, "_containerInsertAfter");
  var kM = /* @__PURE__ */ i((e) => e[e.length - 1], "last");
  function FM(e) {
    return S_e(e.parent) && (kM(e.parent.expressions) !== e.node || FM(e.parentPath));
  }
  i(FM, "isHiddenInSequenceExpression");
  function D_e(e, t) {
    if (!g_e(e) || !v_e(e.left))
      return !1;
    let r = t.getBlockParent();
    return r.hasOwnBinding(e.left.name) && r.getOwnBinding(e.left.name).constantViolations.length <= 1;
  }
  i(D_e, "isAlmostConstantAssignment");
  function I_e(e) {
    if (this._assertUnremoved(), this.isSequenceExpression())
      return kM(this.get("expressions")).insertAfter(e);
    let t = this._verifyNodeList(e), {
      parentPath: r,
      parent: s
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || RM(s) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertAfter(t.map((n) => E_e(n) ? E1(n) : n));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
      if (this.node) {
        let n = this.node, {
          scope: a
        } = this;
        if (a.path.isPattern())
          return h_e(n), this.replaceWith(y_e(d_e([], n), [])), this.get("callee.body").insertAfter(t), [this];
        if (FM(this))
          t.unshift(n);
        else if (b_e(n) && T_e(n.callee))
          t.unshift(n), t.push(x_e());
        else if (D_e(n, a))
          t.unshift(n), t.push(b1(n.left));
        else if (a.isPure(n, !0))
          t.push(n);
        else {
          r.isMethod({
            computed: !0,
            key: n
          }) && (a = a.parent);
          let o = a.generateDeclaredUidIdentifier();
          t.unshift(E1(m_e("=", b1(o), n))), t.push(E1(b1(o)));
        }
      }
      return this.replaceExpressionWithStatements(t);
    } else {
      if (Array.isArray(this.container))
        return this._containerInsertAfter(t);
      if (this.isStatementOrBlock()) {
        let n = this.node, a = n && (!this.isExpressionStatement() || n.expression != null);
        return this.replaceWith(NM(a ? [n] : [])), this.pushContainer("body", t);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  i(I_e, "insertAfter");
  function __e(e, t) {
    if (!this.parent) return;
    let r = (0, c_e.getCachedPaths)(this.hub, this.parent) || [];
    for (let [, s] of r)
      typeof s.key == "number" && s.key >= e && (s.key += t);
  }
  i(__e, "updateSiblingKeys");
  function O_e(e) {
    if (!e)
      return [];
    Array.isArray(e) || (e = [e]);
    for (let t = 0; t < e.length; t++) {
      let r = e[t], s;
      if (r ? typeof r != "object" ? s = "contains a non-object node" : r.type ? r instanceof v1.default && (s = "has a NodePath when it exp\
ected a raw object") : s = "without a type" : s = "has falsy node", s) {
        let n = Array.isArray(r) ? "array" : typeof r;
        throw new Error(`Node list ${s} with the index of ${t} and type of ${n}`);
      }
    }
    return e;
  }
  i(O_e, "_verifyNodeList");
  function N_e(e, t) {
    return this._assertUnremoved(), t = this._verifyNodeList(t), v1.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[e],
      listKey: e,
      key: 0
    }).setContext(this.context)._containerInsertBefore(t);
  }
  i(N_e, "unshiftContainer");
  function R_e(e, t) {
    this._assertUnremoved();
    let r = this._verifyNodeList(t), s = this.node[e];
    return v1.default.get({
      parentPath: this,
      parent: this.node,
      container: s,
      listKey: e,
      key: s.length
    }).setContext(this.context).replaceWithMultiple(r);
  }
  i(R_e, "pushContainer");
  function k_e(e = this.scope) {
    return new f_e.default(this, e).run();
  }
  i(k_e, "hoist");
});

// ../node_modules/@babel/traverse/lib/path/family.js
var jM = y((jr) => {
  "use strict";
  Object.defineProperty(jr, "__esModule", {
    value: !0
  });
  jr._getKey = Q_e;
  jr._getPattern = Z_e;
  jr.get = J_e;
  jr.getAllNextSiblings = X_e;
  jr.getAllPrevSiblings = z_e;
  jr.getBindingIdentifierPaths = rOe;
  jr.getBindingIdentifiers = eOe;
  jr.getCompletionRecords = H_e;
  jr.getNextSibling = Y_e;
  jr.getOpposite = U_e;
  jr.getOuterBindingIdentifierPaths = sOe;
  jr.getOuterBindingIdentifiers = tOe;
  jr.getPrevSibling = K_e;
  jr.getSibling = G_e;
  var T1 = da(), F_e = Ne(), {
    getBindingIdentifiers: MM,
    getOuterBindingIdentifiers: L_e,
    isDeclaration: B_e,
    numericLiteral: M_e,
    unaryExpression: j_e
  } = F_e, x1 = 0, qc = 1;
  function q_e(e) {
    return {
      type: x1,
      path: e
    };
  }
  i(q_e, "NormalCompletion");
  function $_e(e) {
    return {
      type: qc,
      path: e
    };
  }
  i($_e, "BreakCompletion");
  function U_e() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  i(U_e, "getOpposite");
  function wl(e, t, r) {
    return e && t.push(...Dl(e, r)), t;
  }
  i(wl, "addCompletionRecords");
  function V_e(e, t, r) {
    let s = [];
    for (let n = 0; n < e.length; n++) {
      let a = e[n], o = Dl(a, r), l = [], u = [];
      for (let c of o)
        c.type === x1 && l.push(c), c.type === qc && u.push(c);
      l.length && (s = l), t.push(...u);
    }
    return t.push(...s), t;
  }
  i(V_e, "completionRecordForSwitch");
  function W_e(e) {
    e.forEach((t) => {
      t.type = qc;
    });
  }
  i(W_e, "normalCompletionToBreak");
  function S1(e, t) {
    e.forEach((r) => {
      r.path.isBreakStatement({
        label: null
      }) && (t ? r.path.replaceWith(j_e("void", M_e(0))) : r.path.remove());
    });
  }
  i(S1, "replaceBreakStatementInBreakCompletion");
  function BM(e, t) {
    let r = [];
    if (t.canHaveBreak) {
      let s = [];
      for (let n = 0; n < e.length; n++) {
        let a = e[n], o = Object.assign({}, t, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let l = Dl(a, o);
        if (l.length > 0 && l.every((u) => u.type === qc)) {
          s.length > 0 && l.every((u) => u.path.isBreakStatement({
            label: null
          })) ? (W_e(s), r.push(...s), s.some((u) => u.path.isDeclaration()) && (r.push(...l), S1(l, !0)), S1(l, !1)) : (r.push(...l), t.shouldPopulateBreak ||
          S1(l, !0));
          break;
        }
        if (n === e.length - 1)
          r.push(...l);
        else {
          s = [];
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c.type === qc && r.push(c), c.type === x1 && s.push(c);
          }
        }
      }
    } else if (e.length)
      for (let s = e.length - 1; s >= 0; s--) {
        let n = Dl(e[s], t);
        if (n.length > 1 || n.length === 1 && !n[0].path.isVariableDeclaration()) {
          r.push(...n);
          break;
        }
      }
    return r;
  }
  i(BM, "getStatementListCompletion");
  function Dl(e, t) {
    let r = [];
    if (e.isIfStatement())
      r = wl(e.get("consequent"), r, t), r = wl(e.get("alternate"), r, t);
    else {
      if (e.isDoExpression() || e.isFor() || e.isWhile() || e.isLabeledStatement())
        return wl(e.get("body"), r, t);
      if (e.isProgram() || e.isBlockStatement())
        return BM(e.get("body"), t);
      if (e.isFunction())
        return Dl(e.get("body"), t);
      if (e.isTryStatement())
        r = wl(e.get("block"), r, t), r = wl(e.get("handler"), r, t);
      else {
        if (e.isCatchClause())
          return wl(e.get("body"), r, t);
        if (e.isSwitchStatement())
          return V_e(e.get("cases"), r, t);
        if (e.isSwitchCase())
          return BM(e.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        e.isBreakStatement() ? r.push($_e(e)) : r.push(q_e(e));
      }
    }
    return r;
  }
  i(Dl, "_getCompletionRecords");
  function H_e() {
    return Dl(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((t) => t.path);
  }
  i(H_e, "getCompletionRecords");
  function G_e(e) {
    return T1.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: e
    }).setContext(this.context);
  }
  i(G_e, "getSibling");
  function K_e() {
    return this.getSibling(this.key - 1);
  }
  i(K_e, "getPrevSibling");
  function Y_e() {
    return this.getSibling(this.key + 1);
  }
  i(Y_e, "getNextSibling");
  function X_e() {
    let e = this.key, t = this.getSibling(++e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(++e);
    return r;
  }
  i(X_e, "getAllNextSiblings");
  function z_e() {
    let e = this.key, t = this.getSibling(--e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(--e);
    return r;
  }
  i(z_e, "getAllPrevSiblings");
  function J_e(e, t = !0) {
    t === !0 && (t = this.context);
    let r = e.split(".");
    return r.length === 1 ? this._getKey(e, t) : this._getPattern(r, t);
  }
  i(J_e, "get");
  function Q_e(e, t) {
    let r = this.node, s = r[e];
    return Array.isArray(s) ? s.map((n, a) => T1.default.get({
      listKey: e,
      parentPath: this,
      parent: r,
      container: s,
      key: a
    }).setContext(t)) : T1.default.get({
      parentPath: this,
      parent: r,
      container: r,
      key: e
    }).setContext(t);
  }
  i(Q_e, "_getKey");
  function Z_e(e, t) {
    let r = this;
    for (let s of e)
      s === "." ? r = r.parentPath : Array.isArray(r) ? r = r[s] : r = r.get(s, t);
    return r;
  }
  i(Z_e, "_getPattern");
  function eOe(e) {
    return MM(this.node, e);
  }
  i(eOe, "getBindingIdentifiers");
  function tOe(e) {
    return L_e(this.node, e);
  }
  i(tOe, "getOuterBindingIdentifiers");
  function rOe(e = !1, t = !1) {
    let s = [this], n = /* @__PURE__ */ Object.create(null);
    for (; s.length; ) {
      let a = s.shift();
      if (!a || !a.node) continue;
      let o = MM.keys[a.node.type];
      if (a.isIdentifier()) {
        e ? (n[a.node.name] = n[a.node.name] || []).push(a) : n[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let l = a.get("declaration");
        B_e(l) && s.push(l);
        continue;
      }
      if (t) {
        if (a.isFunctionDeclaration()) {
          s.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let l = 0; l < o.length; l++) {
          let u = o[l], c = a.get(u);
          Array.isArray(c) ? s.push(...c) : c.node && s.push(c);
        }
    }
    return n;
  }
  i(rOe, "getBindingIdentifierPaths");
  function sOe(e = !1) {
    return this.getBindingIdentifierPaths(e, !0);
  }
  i(sOe, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/traverse/lib/path/comments.js
var $M = y(($c) => {
  "use strict";
  Object.defineProperty($c, "__esModule", {
    value: !0
  });
  $c.addComment = lOe;
  $c.addComments = uOe;
  $c.shareCommentsWithSiblings = oOe;
  var nOe = Ne(), {
    addComment: iOe,
    addComments: aOe
  } = nOe;
  function oOe() {
    if (typeof this.key == "string") return;
    let e = this.node;
    if (!e) return;
    let t = e.trailingComments, r = e.leadingComments;
    if (!t && !r) return;
    let s = this.getSibling(this.key - 1), n = this.getSibling(this.key + 1), a = !!s.node, o = !!n.node;
    a && (r && s.addComments("trailing", qM(r, s.node.trailingComments)), t && !o && s.addComments("trailing", t)), o && (t && n.addComments(
    "leading", qM(t, n.node.leadingComments)), r && !a && n.addComments("leading", r));
  }
  i(oOe, "shareCommentsWithSiblings");
  function qM(e, t) {
    if (!(t != null && t.length)) return e;
    let r = new Set(t);
    return e.filter((s) => !r.has(s));
  }
  i(qM, "removeIfExisting");
  function lOe(e, t, r) {
    iOe(this.node, e, t, r);
  }
  i(lOe, "addComment");
  function uOe(e, t) {
    aOe(this.node, e, t);
  }
  i(uOe, "addComments");
});

// ../node_modules/@babel/traverse/lib/path/index.js
var da = y((qn) => {
  "use strict";
  Object.defineProperty(qn, "__esModule", {
    value: !0
  });
  qn.default = qn.SHOULD_STOP = qn.SHOULD_SKIP = qn.REMOVED = void 0;
  var cOe = nv(), fOe = Qa(), pOe = Ms(), dOe = Sv(), VM = Ne(), oh = VM, hOe = za(), mOe = Nd(), yOe = KL(), gOe = p3(), bOe = HB(), EOe = XB(),
  vOe = gM(), WM = xM(), SOe = CM(), TOe = IM(), xOe = LM(), POe = jM(), AOe = $M(), COe = av(), {
    validate: wOe
  } = VM, UM = fOe("babel"), P1 = qn.REMOVED = 1, A1 = qn.SHOULD_STOP = 2, C1 = qn.SHOULD_SKIP = 4, ma = class e {
    static {
      i(this, "NodePath");
    }
    constructor(t, r) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container =
      null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = r, this.hub = t, this.data = null, this.
      context = null, this.scope = null;
    }
    static get({
      hub: t,
      parentPath: r,
      parent: s,
      container: n,
      listKey: a,
      key: o
    }) {
      if (!t && r && (t = r.hub), !s)
        throw new Error("To get a node path the parent needs to exist");
      let l = n[o], u = hOe.getOrCreateCachedPaths(t, s), c = u.get(l);
      return c || (c = new e(t, s), l && u.set(l, c)), c.setup(r, n, a, o), c;
    }
    getScope(t) {
      return this.isScope() ? new dOe.default(this) : t;
    }
    setData(t, r) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[t] = r;
    }
    getData(t, r) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let s = this.data[t];
      return s === void 0 && r !== void 0 && (s = this.data[t] = r), s;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(t, r = SyntaxError) {
      return this.hub.buildError(this.node, t, r);
    }
    traverse(t, r) {
      (0, pOe.default)(this.node, t, this.scope, r, this);
    }
    set(t, r) {
      wOe(this.node, t, r), this.node[t] = r;
    }
    getPathLocation() {
      let t = [], r = this;
      do {
        let s = r.key;
        r.inList && (s = `${r.listKey}[${s}]`), t.unshift(s);
      } while (r = r.parentPath);
      return t.join(".");
    }
    debug(t) {
      UM.enabled && UM(`${this.getPathLocation()} ${this.type}: ${t}`);
    }
    toString() {
      return (0, mOe.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(t) {
      t || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & C1);
    }
    set shouldSkip(t) {
      t ? this._traverseFlags |= C1 : this._traverseFlags &= ~C1;
    }
    get shouldStop() {
      return !!(this._traverseFlags & A1);
    }
    set shouldStop(t) {
      t ? this._traverseFlags |= A1 : this._traverseFlags &= ~A1;
    }
    get removed() {
      return !!(this._traverseFlags & P1);
    }
    set removed(t) {
      t ? this._traverseFlags |= P1 : this._traverseFlags &= ~P1;
    }
  };
  Object.assign(ma.prototype, yOe, gOe, bOe, EOe, vOe, WM, SOe, TOe, xOe, POe, AOe);
  ma.prototype._guessExecutionStatusRelativeToDifferentFunctions = WM._guessExecutionStatusRelativeTo;
  for (let e of oh.TYPES) {
    let t = `is${e}`, r = oh[t];
    ma.prototype[t] = function(s) {
      return r(this.node, s);
    }, ma.prototype[`assert${e}`] = function(s) {
      if (!r(this.node, s))
        throw new TypeError(`Expected node path of type ${e}`);
    };
  }
  Object.assign(ma.prototype, COe);
  for (let e of Object.keys(cOe))
    e[0] !== "_" && (oh.TYPES.includes(e) || oh.TYPES.push(e));
  var ert = qn.default = ma;
});

// ../node_modules/@babel/traverse/lib/context.js
var HM = y((lh) => {
  "use strict";
  Object.defineProperty(lh, "__esModule", {
    value: !0
  });
  lh.default = void 0;
  var DOe = da(), IOe = Ne(), {
    VISITOR_KEYS: _Oe
  } = IOe, w1 = class {
    static {
      i(this, "TraversalContext");
    }
    constructor(t, r, s, n) {
      this.queue = null, this.priorityQueue = null, this.parentPath = n, this.scope = t, this.state = s, this.opts = r;
    }
    shouldVisit(t) {
      let r = this.opts;
      if (r.enter || r.exit || r[t.type]) return !0;
      let s = _Oe[t.type];
      if (!(s != null && s.length)) return !1;
      for (let n of s)
        if (t[n])
          return !0;
      return !1;
    }
    create(t, r, s, n) {
      return DOe.default.get({
        parentPath: this.parentPath,
        parent: t,
        container: r,
        key: s,
        listKey: n
      });
    }
    maybeQueue(t, r) {
      this.queue && (r ? this.queue.push(t) : this.priorityQueue.push(t));
    }
    visitMultiple(t, r, s) {
      if (t.length === 0) return !1;
      let n = [];
      for (let a = 0; a < t.length; a++) {
        let o = t[a];
        o && this.shouldVisit(o) && n.push(this.create(r, t, a, s));
      }
      return this.visitQueue(n);
    }
    visitSingle(t, r) {
      return this.shouldVisit(t[r]) ? this.visitQueue([this.create(t, t, r)]) : !1;
    }
    visitQueue(t) {
      this.queue = t, this.priorityQueue = [];
      let r = /* @__PURE__ */ new WeakSet(), s = !1, n = 0;
      for (; n < t.length; ) {
        let a = t[n];
        if (n++, a.resync(), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && a.pushContext(this), a.key === null)
         continue;
        let {
          node: o
        } = a;
        if (!r.has(o)) {
          if (o && r.add(o), a.visit()) {
            s = !0;
            break;
          }
          if (this.priorityQueue.length && (s = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = t, s))
            break;
        }
      }
      for (let a = 0; a < n; a++)
        t[a].popContext();
      return this.queue = null, s;
    }
    visit(t, r) {
      let s = t[r];
      return s ? Array.isArray(s) ? this.visitMultiple(s, t, r) : this.visitSingle(t, r) : !1;
    }
  };
  lh.default = w1;
});

// ../node_modules/@babel/traverse/lib/traverse-node.js
var pd = y((D1) => {
  "use strict";
  Object.defineProperty(D1, "__esModule", {
    value: !0
  });
  D1.traverseNode = kOe;
  var OOe = HM(), NOe = Ne(), {
    VISITOR_KEYS: ROe
  } = NOe;
  function kOe(e, t, r, s, n, a, o) {
    let l = ROe[e.type];
    if (!l) return !1;
    let u = new OOe.default(r, t, s, n);
    if (o)
      return a != null && a[n.parentKey] ? !1 : u.visitQueue([n]);
    for (let c of l)
      if (!(a != null && a[c]) && u.visit(e, c))
        return !0;
    return !1;
  }
  i(kOe, "traverseNode");
});

// ../node_modules/@babel/traverse/lib/hub.js
var GM = y((uh) => {
  "use strict";
  Object.defineProperty(uh, "__esModule", {
    value: !0
  });
  uh.default = void 0;
  var I1 = class {
    static {
      i(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(t, r, s = TypeError) {
      return new s(r);
    }
  };
  uh.default = I1;
});

// ../node_modules/@babel/traverse/lib/index.js
var Ms = y((Si) => {
  "use strict";
  Object.defineProperty(Si, "__esModule", {
    value: !0
  });
  Object.defineProperty(Si, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return jOe.default;
    }, "get")
  });
  Object.defineProperty(Si, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return BOe.default;
    }, "get")
  });
  Object.defineProperty(Si, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return MOe.default;
    }, "get")
  });
  Si.visitors = Si.default = void 0;
  var Uc = fc();
  Si.visitors = Uc;
  var FOe = Ne(), LOe = za(), KM = pd(), BOe = da(), MOe = Sv(), jOe = GM(), {
    VISITOR_KEYS: qOe,
    removeProperties: $Oe,
    traverseFast: YM
  } = FOe;
  function Vs(e, t = {}, r, s, n, a) {
    if (e) {
      if (!t.noScope && !r && e.type !== "Program" && e.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e.
        type} node without passing scope and parentPath.`);
      if (!n && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      qOe[e.type] && (Uc.explode(t), (0, KM.traverseNode)(e, t, r, s, n, null, a));
    }
  }
  i(Vs, "traverse");
  var urt = Si.default = Vs;
  Vs.visitors = Uc;
  Vs.verify = Uc.verify;
  Vs.explode = Uc.explode;
  Vs.cheap = function(e, t) {
    YM(e, t);
  };
  Vs.node = function(e, t, r, s, n, a) {
    (0, KM.traverseNode)(e, t, r, s, n, a);
  };
  Vs.clearNode = function(e, t) {
    $Oe(e, t);
  };
  Vs.removeProperties = function(e, t) {
    return YM(e, Vs.clearNode, t), e;
  };
  function UOe(e, t) {
    e.node.type === t.type && (t.has = !0, e.stop());
  }
  i(UOe, "hasDenylistedType");
  Vs.hasType = function(e, t, r) {
    if (r != null && r.includes(e.type)) return !1;
    if (e.type === t) return !0;
    let s = {
      has: !1,
      type: t
    };
    return Vs(e, {
      noScope: !0,
      denylist: r,
      enter: UOe
    }, null, s), s.has;
  };
  Vs.cache = LOe;
});

// ../node_modules/@babel/helpers/lib/helpers-generated.js
var sj = y((dh) => {
  "use strict";
  Object.defineProperty(dh, "__esModule", {
    value: !0
  });
  dh.default = void 0;
  var GOe = Al();
  function lt(e, t) {
    return Object.freeze({
      minVersion: e,
      ast: /* @__PURE__ */ i(() => GOe.default.program.ast(t, {
        preserveComments: !0
      }), "ast")
    });
  }
  i(lt, "helper");
  var Drt = dh.default = Object.freeze({
    AsyncGenerator: lt("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function AsyncGenerator(e){var r,t;function \
resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"re\
turn":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch\
(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:\
r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e\
,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.p\
rototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(\
e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return\
=function(e){return this._invoke("return",e)};'),
    OverloadYield: lt("7.18.14", "export default function _OverloadYield(t,e){this.v=t,this.k=e}"),
    applyDecs: lt("7.17.8", 'import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function old_createMetada\
taMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(v\
oid 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.has\
OwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataK\
ey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&\
&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Sy\
mbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c\
=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n\
.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_cre\
ateAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}\
function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c\
="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializ\
er=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(\
1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try\
{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw\
 Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError(\
"Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a fu\
nction")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorator\
s must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.se\
t&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCa\
llable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators\
 must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn\
(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(\
0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunc\
tionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2==\
=o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(\
o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!\
==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,\
f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){ret\
urn t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=functi\
on(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push\
((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.ca\
ll(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o\
[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i|\
|[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor\
 that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property\
 name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}fu\
nction old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,\
a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitialize\
r:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertVali\
dReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}export default function applyDecs(e,t,a){var r=[],o\
={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataM\
apToFinal(e,o),r}'),
    applyDecs2203: lt("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){\
if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}funct\
ion memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";b\
reak;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p\
)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=fu\
nction(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{retu\
rn e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertV\
alidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with \
get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor\
.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"met\
hod")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{g\
et:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.se\
t}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f)\
,0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberD\
ec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==\
g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typ\
eof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.\
push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.c\
all(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProper\
ty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){\
var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=\
c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g\
&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public me\
thod/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberD\
ec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length\
-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&\
(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;export \
default function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}'),
    applyDecs2203R: lt("7.20.0", 'import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function applyDecs22\
03RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer\
 after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case \
1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+\
t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=funct\
ion(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!\
==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function as\
sertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;i\
f(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void \
0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallabl\
e(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a func\
tion or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?\
(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"\
+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"functi\
on"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,\
f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0==\
=a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)\
))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length\
;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.v\
alue=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}\
))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[]\
,i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n\
=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempte\
d to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently suppor\
ted by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializer\
s(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}ret\
urn function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i-\
-){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertVal\
idReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2203R(e,t,\
r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}'),
    applyDecs2301: lt("7.21.0", 'import checkInRHS from"checkInRHS";import setFunctionName from"setFunctionName";import toPropertyKey from"t\
oPropertyKey";function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error(\
"attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceI\
fPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var \
u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={k\
ind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==\
a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInst\
anceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(\
e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t\
 in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("fu\
nction"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r\
||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&asse\
rtCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init"\
)}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}functio\
n curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={g\
et:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3\
]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)\
),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c)\
)&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0\
;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.s\
et,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){\
return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=fun\
ction(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.p\
ush((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p\
.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l\
=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return check\
InRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Erro\
r("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not curre\
ntly supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pu\
shInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);re\
turn e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t\
.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void \
0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function ap\
plyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}'),
    applyDecs2305: lt("7.21.0", 'import checkInRHS from"checkInRHS";import setFunctionName from"setFunctionName";import toPropertyKey from"t\
oPropertyKey";export default function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}funct\
ion c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError\
(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))thr\
ow new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={\
},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e\
)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=\
v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t\
){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)\
};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.v\
alue}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={h\
as:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&\
P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)\
throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+"\
 decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(\
e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,\
t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.lengt\
h>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function\
(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){\
var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw \
Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not c\
urrently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h\
),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&\
&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}'),
    applyDecs2311: lt("7.24.0", 'import checkInRHS from"checkInRHS";import setFunctionName from"setFunctionName";import toPropertyKey from"t\
oPropertyKey";export default function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object\
.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a+\
+)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be\
")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attem\
pted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return \
function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionNam\
e((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnProperty\
Descriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported \
yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var z=b(h[O],"A decorator","be",!0),A=n?h[O-1]:void 0,H={},K={kind:["field",\
"accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addIn\
itializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,H)};if(w)c=z.call(A,N,K),H.v=1,b(c,"class decor\
ators","return")&&(N=c);else if(K.static=s,K.private=f,c=K.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){retu\
rn d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=z.call(A,D?{get:P.get,set:P.set\
}:P[F],K),H.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"acces\
sor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init propertie\
s or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||\
(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerabl\
e:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i+\
+){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s\
=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var\
 n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}'),
    assertClassBrand: lt("7.24.0", 'export default function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments\
.length<3?t:n;throw new TypeError("Private element is not present on this object")}'),
    asyncGeneratorDelegate: lt("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _asyncGeneratorDelegate(t){\
var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undef\
ined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"\
==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return \
n?(n=!1,t):pump("return",t)}),e}'),
    asyncIterator: lt("7.15.9", 'export default function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIter\
ator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@as\
yncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIter\
atorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.valu\
e).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.protot\
ype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s\
.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r)\
{var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIte\
rator(r)}'),
    awaitAsyncGenerator: lt("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _awaitAsyncGenerator(e){return\
 new OverloadYield(e,0)}'),
    callSuper: lt("7.23.8", 'import getPrototypeOf from"getPrototypeOf";import isNativeReflectConstruct from"isNativeReflectConstruct";impor\
t possibleConstructorReturn from"possibleConstructorReturn";export default function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleCon\
structorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}'),
    checkInRHS: lt("7.20.5", `export default function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an \
object, got "+(null!==e?typeof e:"null"));return e}`),
    classPrivateFieldGet2: lt("7.24.0", 'import assertClassBrand from"assertClassBrand";export default function _classPrivateFieldGet2(s,a){\
return s.get(assertClassBrand(s,a))}'),
    classPrivateFieldSet2: lt("7.24.0", 'import assertClassBrand from"assertClassBrand";export default function _classPrivateFieldSet2(s,a,r\
){return s.set(assertClassBrand(s,a),r),r}'),
    classPrivateGetter: lt("7.24.0", 'import assertClassBrand from"assertClassBrand";export default function _classPrivateGetter(s,r,a){retu\
rn a(assertClassBrand(s,r))}'),
    classPrivateSetter: lt("7.24.0", 'import assertClassBrand from"assertClassBrand";export default function _classPrivateSetter(s,r,a,t){re\
turn r(assertClassBrand(s,a),t),t}'),
    construct: lt("7.0.0-beta.0", 'import setPrototypeOf from"setPrototypeOf";import isNativeReflectConstruct from"isNativeReflectConstruct"\
;export default function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.\
apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}'),
    defineAccessor: lt("7.20.7", "export default function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Objec\
t.defineProperty(r,n,c)}"),
    dispose: lt("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=Suppresse\
dError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Obj\
ect.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}expo\
rt default function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then\
(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}'),
    importDeferProxy: lt("7.23.0", "export default function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return \
e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deletePr\
operty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null\
),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setP\
rototypeOf:constValue(!1)})}"),
    interopRequireWildcard: lt("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t\
=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}export default function _interopRequireWildcard(e,r){if(!r&&e&&e.\
__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e)\
)return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnP\
roperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.defau\
lt=e,t&&t.set(e,n),n}'),
    isNativeReflectConstruct: lt("7.9.0", "export default function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Ref\
lect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}"),
    iterableToArrayLimit: lt("7.0.0-beta.0", 'export default function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symb\
ol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=\
!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return\
(),Object(u)!==u))return}finally{if(o)throw n}}return a}}'),
    iterableToArrayLimitLoose: lt("7.0.0-beta.0", 'export default function _iterableToArrayLimitLoose(e,r){var t=e&&("undefined"!=typeof Sym\
bol&&e[Symbol.iterator]||e["@@iterator"]);if(null!=t){var o,l=[];for(t=t.call(e);e.length<r&&!(o=t.next()).done;)l.push(o.value);return l}}'),
    jsx: lt("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEME\
NT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n|\
|(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in \
o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:nu\
ll}}'),
    objectSpread2: lt("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnProper\
tySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.pu\
sh.apply(t,o)}return t}export default function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{\
};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Obje\
ct.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}\
return e}'),
    regeneratorRuntime: lt("7.18.0", `export default function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LI\
CENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t\
[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStr\
ingTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}\
catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(\
i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",\
arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={}\
;function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));v\
ar d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype\
=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invo\
ke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;retur\
n h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a\
)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:fun\
ction(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg\
,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Er\
ror("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c\
){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(\
o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p\
.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function ma\
ybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.a\
rg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n\
+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;ret\
urn a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw"\
,r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc\
=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",\
delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function value\
s(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){fo\
r(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new T\
ypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFuncti\
onPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displa\
yName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;r\
eturn!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.set\
PrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create\
(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){re\
turn this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);retu\
rn e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator")\
,define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[]\
;for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}r\
eturn next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this\
._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.c\
harAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.\
type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",\
a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("r\
oot"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.cat\
chLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.\
catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abru\
pt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.\
prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.\
type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;retu\
rn"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"n\
ormal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLo\
c===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var \
r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal ca\
tch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.ar\
g=t),y}},e}`),
    setFunctionName: lt("7.23.6", 'export default function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try\
{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}'),
    toPrimitive: lt("7.1.5", 'export default function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(voi\
d 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}ret\
urn("string"===r?String:Number)(t)}'),
    toPropertyKey: lt("7.1.5", 'import toPrimitive from"toPrimitive";export default function toPropertyKey(t){var i=toPrimitive(t,"string");\
return"symbol"==typeof i?i:i+""}'),
    toSetter: lt("7.24.0", 'export default function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:fun\
ction(o){e[r]=o,t.apply(n,e)}})}'),
    typeof: lt("7.0.0-beta.0", 'export default function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symb\
ol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol\
.prototype?"symbol":typeof o},_typeof(o)}'),
    using: lt("7.22.0", 'export default function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations \
can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null\
==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a functi\
on.");return o.push({v:n,d:r,a:e}),n}'),
    usingCtx: lt("7.23.9", 'export default function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,n){var e\
=Error();return e.name="SuppressedError",e.suppressed=n,e.error=r,e},n={},e=[];function using(r,n){if(null!=n){if(Object(n)!==n)throw new Ty\
peError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=n[Symbol.asyncDispose||Symbol.for("Sy\
mbol.asyncDispose")];if(null==o&&(o=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof o)throw new TypeError("Property [Sym\
bol.dispose] is not a function.");e.push({v:n,d:o,a:r})}return n}return{e:n,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o=t\
his.e;function next(){for(;r=e.pop();)try{var r,t=r.d.call(r.v);if(r.a)return Promise.resolve(t).then(next,err)}catch(r){return err(r)}if(o!\
==n)throw o}function err(e){return o=o!==n?new r(o,e):e,next()}return next()}}}'),
    wrapRegExp: lt("7.19.0", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(\
){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegEx\
p(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).re\
duce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),\
Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=bui\
ldGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"\
==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArr\
ay(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"\
!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.\
apply(this,arguments)}')
  });
});

// ../node_modules/@babel/helpers/lib/helpers.js
var nj = y((hh) => {
  "use strict";
  Object.defineProperty(hh, "__esModule", {
    value: !0
  });
  hh.default = void 0;
  var KOe = Al(), YOe = sj(), de = Object.assign({
    __proto__: null
  }, YOe.default), Ort = hh.default = de, me = /* @__PURE__ */ i((e) => (t) => ({
    minVersion: e,
    ast: /* @__PURE__ */ i(() => KOe.default.program.ast(t), "ast")
  }), "helper");
  de.AwaitValue = me("7.0.0-beta.0")`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `;
  de.wrapAsyncGenerator = me("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`;
  de.asyncToGenerator = me("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`;
  de.classCallCheck = me("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`;
  de.createClass = me("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`;
  de.defineEnumerableProperties = me("7.0.0-beta.0")`
    export default function _defineEnumerableProperties(obj, descs) {
      for (var key in descs) {
        var desc = descs[key];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, key, desc);
      }

      // Symbols are not enumerated over by for-in loops. If native
      // Symbols are available, fetch all of the descs object's own
      // symbol properties and define them on our target object too.
      if (Object.getOwnPropertySymbols) {
        var objectSymbols = Object.getOwnPropertySymbols(descs);
        for (var i = 0; i < objectSymbols.length; i++) {
          var sym = objectSymbols[i];
          var desc = descs[sym];
          desc.configurable = desc.enumerable = true;
          if ("value" in desc) desc.writable = true;
          Object.defineProperty(obj, sym, desc);
        }
      }
      return obj;
    }
`;
  de.defaults = me("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`;
  de.defineProperty = me("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  export default function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`;
  de.extends = me("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`;
  de.objectSpread = me("7.0.0-beta.0")`
    import defineProperty from "defineProperty";

    export default function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = (arguments[i] != null) ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
  `;
  de.inherits = me("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`;
  de.inheritsLoose = me("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`;
  de.getPrototypeOf = me("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`;
  de.setPrototypeOf = me("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`;
  de.isNativeFunction = me("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    try {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    } catch (e) {
      // Firefox 31 throws when "toString" is applied to an HTMLElement
      return typeof fn === "function";
    }
  }
`;
  de.wrapNativeSuper = me("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`;
  de.instanceof = me("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`;
  de.interopRequireDefault = me("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`;
  de.newArrowCheck = me("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`;
  de.objectDestructuringEmpty = me("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
`;
  de.objectWithoutPropertiesLoose = me("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`;
  de.objectWithoutProperties = me("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`;
  de.assertThisInitialized = me("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`;
  de.possibleConstructorReturn = me("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`;
  de.createSuper = me("7.9.0")`
    import getPrototypeOf from "getPrototypeOf";
    import isNativeReflectConstruct from "isNativeReflectConstruct";
    import possibleConstructorReturn from "possibleConstructorReturn";

    export default function _createSuper(Derived) {
      var hasNativeReflectConstruct = isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          // NOTE: This doesn't work if this.__proto__.constructor has been modified.
          var NewTarget = getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return possibleConstructorReturn(this, result);
      }
    }
`;
  de.superPropBase = me("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`;
  de.get = me("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`;
  de.set = me("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new TypeError('failed to set property');
    }

    return value;
  }
`;
  de.taggedTemplateLiteral = me("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`;
  de.taggedTemplateLiteralLoose = me("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`;
  de.readOnlyError = me("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`;
  de.writeOnlyError = me("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`;
  de.classNameTDZError = me("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new ReferenceError("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`;
  de.temporalUndefined = me("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`;
  de.tdz = me("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`;
  de.temporalRef = me("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`;
  de.slicedToArray = me("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
  de.slicedToArrayLoose = me("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
  de.toArray = me("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`;
  de.toConsumableArray = me("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`;
  de.arrayWithoutHoles = me("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`;
  de.arrayWithHoles = me("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`;
  de.maybeArrayLike = me("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`;
  de.iterableToArray = me("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`;
  de.unsupportedIterableToArray = me("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`;
  de.arrayLikeToArray = me("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`;
  de.nonIterableSpread = me("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
  de.nonIterableRest = me("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
  de.createForOfIteratorHelper = me("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`;
  de.createForOfIteratorHelperLoose = me("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`;
  de.skipFirstGeneratorNext = me("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`;
  de.initializerWarningHelper = me("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'transform-class-properties is enabled and runs after the decorators transform.'
        );
    }
`;
  de.initializerDefineProperty = me("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`;
  de.applyDecoratedDescriptor = me("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`;
  de.classPrivateFieldLooseKey = me("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`;
  de.classPrivateFieldLooseBase = me("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`;
  de.classPrivateFieldGet = me("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classPrivateFieldGet2 from "classPrivateFieldGet2";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classPrivateFieldGet2(privateMap, receiver);
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
  de.classPrivateFieldSet = me("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classPrivateFieldGet2 from "classPrivateFieldGet2";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classPrivateFieldGet2(privateMap, receiver);
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
  de.classPrivateFieldDestructureSet = me("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classPrivateFieldGet2 from "classPrivateFieldGet2";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classPrivateFieldGet2(privateMap, receiver);
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
  de.classExtractFieldDescriptor = me("7.13.10")`
  import classPrivateFieldGet2 from "classPrivateFieldGet2";

  export default function _classExtractFieldDescriptor(receiver, privateMap) {
    return classPrivateFieldGet2(privateMap, receiver);
  }
`;
  de.classStaticPrivateFieldSpecGet = me("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import assertClassBrand from "assertClassBrand";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    assertClassBrand(classConstructor, receiver);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
  de.classStaticPrivateFieldSpecSet = me("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import assertClassBrand from "assertClassBrand";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    assertClassBrand(classConstructor, receiver);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
  de.classStaticPrivateMethodGet = me("7.3.2")`
  import assertClassBrand from "assertClassBrand";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    assertClassBrand(classConstructor, receiver);
    return method;
  }
`;
  de.classStaticPrivateMethodSet = me("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`;
  de.classApplyDescriptorGet = me("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`;
  de.classApplyDescriptorSet = me("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`;
  de.classApplyDescriptorDestructureSet = me("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`;
  de.classStaticPrivateFieldDestructureSet = me("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import assertClassBrand from "assertClassBrand";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    assertClassBrand(classConstructor, receiver);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
  de.classCheckPrivateStaticAccess = me("7.13.10")`
  import assertClassBrand from "assertClassBrand";
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor, returnValue) {
    return assertClassBrand(classConstructor, receiver, returnValue);
  }
`;
  de.classCheckPrivateStaticFieldDescriptor = me("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`;
  de.decorate = me("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`;
  de.classPrivateMethodGet = me("7.1.6")`
  import assertClassBrand from "assertClassBrand";
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    assertClassBrand(privateSet, receiver);
    return fn;
  }
`;
  de.checkPrivateRedeclaration = me("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`;
  de.classPrivateFieldInitSpec = me("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`;
  de.classPrivateMethodInitSpec = me("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`;
  de.classPrivateMethodSet = me("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `;
  de.identity = me("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`;
  de.nullishReceiverError = me("7.22.6")`
  export default function _nullishReceiverError(r) {
    throw new TypeError("Cannot set property of null or undefined.");
  }
`;
});

// ../node_modules/@babel/helpers/lib/index.js
var L1 = y((Un) => {
  "use strict";
  Object.defineProperty(Un, "__esModule", {
    value: !0
  });
  Un.default = void 0;
  Un.ensure = rNe;
  Un.get = lj;
  Un.getDependencies = tNe;
  Un.list = void 0;
  Un.minVersion = eNe;
  var k1 = Ms(), XOe = Ne(), F1 = nj(), {
    assignmentExpression: ij,
    cloneNode: zOe,
    expressionStatement: JOe,
    file: aj,
    identifier: QOe
  } = XOe;
  function mh(e) {
    let t = [];
    for (; e.parentPath; e = e.parentPath)
      t.push(e.key), e.inList && t.push(e.listKey);
    return t.reverse().join(".");
  }
  i(mh, "makePath");
  var yh;
  function oj(e) {
    let t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Map(), n, a, o = [], l = [], u = [], c = {
      ImportDeclaration(p) {
        let d = p.node.source.value;
        if (!F1.default[d])
          throw p.buildCodeFrameError(`Unknown helper ${d}`);
        if (p.get("specifiers").length !== 1 || !p.get("specifiers.0").isImportDefaultSpecifier())
          throw p.buildCodeFrameError("Helpers can only import a default value");
        let m = p.node.specifiers[0].local;
        s.set(m, d), l.push(mh(p));
      },
      ExportDefaultDeclaration(p) {
        let d = p.get("declaration");
        if (!d.isFunctionDeclaration() || !d.node.id)
          throw d.buildCodeFrameError("Helpers can only export named function declarations");
        n = d.node.id.name, a = mh(p);
      },
      ExportAllDeclaration(p) {
        throw p.buildCodeFrameError("Helpers can only export default");
      },
      ExportNamedDeclaration(p) {
        throw p.buildCodeFrameError("Helpers can only export default");
      },
      Statement(p) {
        p.isImportDeclaration() || p.isExportDeclaration() || p.skip();
      }
    }, f = {
      Program(p) {
        let d = p.scope.getAllBindings();
        Object.keys(d).forEach((m) => {
          m !== n && (s.has(d[m].identifier) || r.add(m));
        });
      },
      ReferencedIdentifier(p) {
        let d = p.node.name, m = p.scope.getBinding(d);
        m ? s.has(m.identifier) && u.push(mh(p)) : (d !== "arguments" || p.scope.path.isProgram()) && t.add(d);
      },
      AssignmentExpression(p) {
        let d = p.get("left");
        if (!(n in d.getBindingIdentifiers())) return;
        if (!d.isIdentifier())
          throw d.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
        let m = p.scope.getBinding(n);
        m != null && m.scope.path.isProgram() && o.push(mh(p));
      }
    };
    if ((0, k1.default)(e.ast, c, e.scope), (0, k1.default)(e.ast, f, e.scope), !a) throw new Error("Helpers must have a default export.");
    return o.reverse(), {
      globals: Array.from(t),
      localBindingNames: Array.from(r),
      dependencies: s,
      exportBindingAssignments: o,
      exportPath: a,
      exportName: n,
      importBindingsReferences: u,
      importPaths: l
    };
  }
  i(oj, "getHelperMetadata");
  function ZOe(e, t, r, s, n) {
    if (s && !r)
      throw new Error("Unexpected local bindings for module-based helpers.");
    if (!r) return;
    let {
      localBindingNames: a,
      dependencies: o,
      exportBindingAssignments: l,
      exportPath: u,
      exportName: c,
      importBindingsReferences: f,
      importPaths: p
    } = t, d = {};
    o.forEach((N, I) => {
      d[I.name] = typeof n == "function" && n(N) || I;
    });
    let m = {}, b = new Set(s || []);
    r.type === "Identifier" && b.add(r.name), a.forEach((N) => {
      let I = N;
      for (; b.has(I); ) I = "_" + I;
      I !== N && (m[N] = I);
    }), r.type === "Identifier" && c !== r.name && (m[c] = r.name);
    let {
      path: h
    } = e, g = h.get(u), E = p.map((N) => h.get(N)), D = f.map((N) => h.get(N)), C = g.get("declaration");
    if (r.type === "Identifier")
      g.replaceWith(C);
    else if (r.type === "MemberExpression")
      l.forEach((N) => {
        let I = h.get(N);
        I.replaceWith(ij("=", r, I.node));
      }), g.replaceWith(C), h.pushContainer("body", JOe(ij("=", r, QOe(c))));
    else
      throw new Error("Unexpected helper format.");
    Object.keys(m).forEach((N) => {
      h.scope.rename(N, m[N]);
    });
    for (let N of E) N.remove();
    for (let N of D) {
      let I = zOe(d[N.node.name]);
      N.replaceWith(I);
    }
  }
  i(ZOe, "permuteHelperAST");
  var R1 = /* @__PURE__ */ Object.create(null);
  function gh(e) {
    if (!R1[e]) {
      let t = F1.default[e];
      if (!t)
        throw Object.assign(new ReferenceError(`Unknown helper ${e}`), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: e
        });
      let r = /* @__PURE__ */ i(() => {
        if (!yh) {
          let n = {
            ast: aj(t.ast()),
            path: null
          };
          return (0, k1.default)(n.ast, {
            Program: /* @__PURE__ */ i((a) => (n.path = a).stop(), "Program")
          }), n;
        }
        return new yh({
          filename: `babel-helper://${e}`
        }, {
          ast: aj(t.ast()),
          code: "[internal Babel helper code]",
          inputMap: null
        });
      }, "fn"), s = null;
      R1[e] = {
        minVersion: t.minVersion,
        build(n, a, o) {
          let l = r();
          return s || (s = oj(l)), ZOe(l, s, a, o, n), {
            nodes: l.ast.program.body,
            globals: s.globals
          };
        },
        getDependencies() {
          return s || (s = oj(r())), Array.from(s.dependencies.values());
        }
      };
    }
    return R1[e];
  }
  i(gh, "loadHelper");
  function lj(e, t, r, s) {
    return gh(e).build(t, r, s);
  }
  i(lj, "get");
  function eNe(e) {
    return gh(e).minVersion;
  }
  i(eNe, "minVersion");
  function tNe(e) {
    return gh(e).getDependencies();
  }
  i(tNe, "getDependencies");
  function rNe(e, t) {
    yh || (yh = t), gh(e);
  }
  i(rNe, "ensure");
  var krt = Un.list = Object.keys(F1.default).map((e) => e.replace(/^_/, "")), Frt = Un.default = lj;
});

// ../node_modules/@babel/helper-module-imports/lib/import-builder.js
var fj = y((Eh) => {
  "use strict";
  Object.defineProperty(Eh, "__esModule", {
    value: !0
  });
  Eh.default = void 0;
  var mn = require("assert"), sNe = Ne(), {
    callExpression: B1,
    cloneNode: bh,
    expressionStatement: uj,
    identifier: Wc,
    importDeclaration: nNe,
    importDefaultSpecifier: iNe,
    importNamespaceSpecifier: aNe,
    importSpecifier: oNe,
    memberExpression: M1,
    stringLiteral: cj,
    variableDeclaration: lNe,
    variableDeclarator: uNe
  } = sNe, j1 = class {
    static {
      i(this, "ImportBuilder");
    }
    constructor(t, r, s) {
      this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = r, this._hub = s, this._importedSource = t;
    }
    done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    }
    import() {
      return this._statements.push(nNe([], cj(this._importedSource))), this;
    }
    require() {
      return this._statements.push(uj(B1(Wc("require"), [cj(this._importedSource)]))), this;
    }
    namespace(t = "namespace") {
      let r = this._scope.generateUidIdentifier(t), s = this._statements[this._statements.length - 1];
      return mn(s.type === "ImportDeclaration"), mn(s.specifiers.length === 0), s.specifiers = [aNe(r)], this._resultName = bh(r), this;
    }
    default(t) {
      let r = this._scope.generateUidIdentifier(t), s = this._statements[this._statements.length - 1];
      return mn(s.type === "ImportDeclaration"), mn(s.specifiers.length === 0), s.specifiers = [iNe(r)], this._resultName = bh(r), this;
    }
    named(t, r) {
      if (r === "default") return this.default(t);
      let s = this._scope.generateUidIdentifier(t), n = this._statements[this._statements.length - 1];
      return mn(n.type === "ImportDeclaration"), mn(n.specifiers.length === 0), n.specifiers = [oNe(s, Wc(r))], this._resultName = bh(s), this;
    }
    var(t) {
      let r = this._scope.generateUidIdentifier(t), s = this._statements[this._statements.length - 1];
      return s.type !== "ExpressionStatement" && (mn(this._resultName), s = uj(this._resultName), this._statements.push(s)), this._statements[this.
      _statements.length - 1] = lNe("var", [uNe(r, s.expression)]), this._resultName = bh(r), this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(t) {
      let r = this._statements[this._statements.length - 1];
      return r.type === "ExpressionStatement" ? r.expression = B1(t, [r.expression]) : r.type === "VariableDeclaration" ? (mn(r.declarations.
      length === 1), r.declarations[0].init = B1(t, [r.declarations[0].init])) : mn.fail("Unexpected type."), this;
    }
    prop(t) {
      let r = this._statements[this._statements.length - 1];
      return r.type === "ExpressionStatement" ? r.expression = M1(r.expression, Wc(t)) : r.type === "VariableDeclaration" ? (mn(r.declarations.
      length === 1), r.declarations[0].init = M1(r.declarations[0].init, Wc(t))) : mn.fail("Unexpected type:" + r.type), this;
    }
    read(t) {
      this._resultName = M1(this._resultName, Wc(t));
    }
  };
  Eh.default = j1;
});

// ../node_modules/@babel/helper-module-imports/lib/is-module.js
var $1 = y((q1) => {
  "use strict";
  Object.defineProperty(q1, "__esModule", {
    value: !0
  });
  q1.default = cNe;
  function cNe(e) {
    return e.node.sourceType === "module";
  }
  i(cNe, "isModule");
});

// ../node_modules/@babel/helper-module-imports/lib/import-injector.js
var gj = y((Sh) => {
  "use strict";
  Object.defineProperty(Sh, "__esModule", {
    value: !0
  });
  Sh.default = void 0;
  var pj = require("assert"), fNe = Ne(), pNe = fj(), dNe = $1(), {
    identifier: hNe,
    importSpecifier: mNe,
    numericLiteral: yNe,
    sequenceExpression: gNe,
    isImportDeclaration: dj
  } = fNe, U1 = class {
    static {
      i(this, "ImportInjector");
    }
    constructor(t, r, s) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: !1,
        ensureNoContext: !1,
        importPosition: "before"
      };
      let n = t.find((a) => a.isProgram());
      this._programPath = n, this._programScope = n.scope, this._hub = n.hub, this._defaultOpts = this._applyDefaults(r, s, !0);
    }
    addDefault(t, r) {
      return this.addNamed("default", t, r);
    }
    addNamed(t, r, s) {
      return pj(typeof t == "string"), this._generateImport(this._applyDefaults(r, s), t);
    }
    addNamespace(t, r) {
      return this._generateImport(this._applyDefaults(t, r), null);
    }
    addSideEffect(t, r) {
      return this._generateImport(this._applyDefaults(t, r), void 0);
    }
    _applyDefaults(t, r, s = !1) {
      let n;
      return typeof t == "string" ? n = Object.assign({}, this._defaultOpts, {
        importedSource: t
      }, r) : (pj(!r, "Unexpected secondary arguments."), n = Object.assign({}, this._defaultOpts, t)), !s && r && (r.nameHint !== void 0 &&
      (n.nameHint = r.nameHint), r.blockHoist !== void 0 && (n.blockHoist = r.blockHoist)), n;
    }
    _generateImport(t, r) {
      let s = r === "default", n = !!r && !s, a = r === null, {
        importedSource: o,
        importedType: l,
        importedInterop: u,
        importingInterop: c,
        ensureLiveReference: f,
        ensureNoContext: p,
        nameHint: d,
        importPosition: m,
        blockHoist: b
      } = t, h = d || r, g = (0, dNe.default)(this._programPath), E = g && c === "node", D = g && c === "babel";
      if (m === "after" && !g)
        throw new Error('"importPosition": "after" is only supported in modules');
      let C = new pNe.default(o, this._programScope, this._hub);
      if (l === "es6") {
        if (!E && !D)
          throw new Error("Cannot import an ES6 module from CommonJS");
        C.import(), a ? C.namespace(d || o) : (s || n) && C.named(h, r);
      } else {
        if (l !== "commonjs")
          throw new Error(`Unexpected interopType "${l}"`);
        if (u === "babel")
          if (E) {
            h = h !== "default" ? h : o;
            let M = `${o}$es6Default`;
            C.import(), a ? C.default(M).var(h || o).wildcardInterop() : s ? f ? C.default(M).var(h || o).defaultInterop().read("default") :
            C.default(M).var(h).defaultInterop().prop(r) : n && C.default(M).read(r);
          } else D ? (C.import(), a ? C.namespace(h || o) : (s || n) && C.named(h, r)) : (C.require(), a ? C.var(h || o).wildcardInterop() :
          (s || n) && f ? s ? (h = h !== "default" ? h : o, C.var(h).read(r), C.defaultInterop()) : C.var(o).read(r) : s ? C.var(h).defaultInterop().
          prop(r) : n && C.var(h).prop(r));
        else if (u === "compiled")
          E ? (C.import(), a ? C.default(h || o) : (s || n) && C.default(o).read(h)) : D ? (C.import(), a ? C.namespace(h || o) : (s || n) &&
          C.named(h, r)) : (C.require(), a ? C.var(h || o) : (s || n) && (f ? C.var(o).read(h) : C.prop(r).var(h)));
        else if (u === "uncompiled") {
          if (s && f)
            throw new Error("No live reference for commonjs default");
          E ? (C.import(), a ? C.default(h || o) : s ? C.default(h) : n && C.default(o).read(h)) : D ? (C.import(), a ? C.default(h || o) : s ?
          C.default(h) : n && C.named(h, r)) : (C.require(), a ? C.var(h || o) : s ? C.var(h) : n && (f ? C.var(o).read(h) : C.var(h).prop(r)));
        } else
          throw new Error(`Unknown importedInterop "${u}".`);
      }
      let {
        statements: N,
        resultName: I
      } = C.done();
      return this._insertStatements(N, m, b), (s || n) && p && I.type !== "Identifier" ? gNe([yNe(0), I]) : I;
    }
    _insertStatements(t, r = "before", s = 3) {
      if (r === "after") {
        if (this._insertStatementsAfter(t)) return;
      } else if (this._insertStatementsBefore(t, s)) return;
      this._programPath.unshiftContainer("body", t);
    }
    _insertStatementsBefore(t, r) {
      if (t.length === 1 && dj(t[0]) && vh(t[0])) {
        let n = this._programPath.get("body").find((a) => a.isImportDeclaration() && vh(a.node));
        if (n?.node.source.value === t[0].source.value && yj(n.node, t[0]))
          return !0;
      }
      t.forEach((n) => {
        n._blockHoist = r;
      });
      let s = this._programPath.get("body").find((n) => {
        let a = n.node._blockHoist;
        return Number.isFinite(a) && a < 4;
      });
      return s ? (s.insertBefore(t), !0) : !1;
    }
    _insertStatementsAfter(t) {
      let r = new Set(t), s = /* @__PURE__ */ new Map();
      for (let a of t)
        if (dj(a) && vh(a)) {
          let o = a.source.value;
          s.has(o) || s.set(o, []), s.get(o).push(a);
        }
      let n = null;
      for (let a of this._programPath.get("body"))
        if (a.isImportDeclaration() && vh(a.node)) {
          n = a;
          let o = a.node.source.value, l = s.get(o);
          if (!l) continue;
          for (let u of l)
            r.has(u) && yj(a.node, u) && r.delete(u);
        }
      return r.size === 0 ? !0 : (n && n.insertAfter(Array.from(r)), !!n);
    }
  };
  Sh.default = U1;
  function vh(e) {
    return e.importKind !== "type" && e.importKind !== "typeof";
  }
  i(vh, "isValueImport");
  function hj(e) {
    return e.specifiers.length === 1 && e.specifiers[0].type === "ImportNamespaceSpecifier" || e.specifiers.length === 2 && e.specifiers[1].
    type === "ImportNamespaceSpecifier";
  }
  i(hj, "hasNamespaceImport");
  function mj(e) {
    return e.specifiers.length > 0 && e.specifiers[0].type === "ImportDefaultSpecifier";
  }
  i(mj, "hasDefaultImport");
  function yj(e, t) {
    return e.specifiers.length ? t.specifiers.length ? hj(e) || hj(t) ? !1 : (mj(t) && (mj(e) ? t.specifiers[0] = mNe(t.specifiers[0].local,
    hNe("default")) : e.specifiers.unshift(t.specifiers.shift())), e.specifiers.push(...t.specifiers), !0) : !0 : (e.specifiers = t.specifiers,
    !0);
  }
  i(yj, "maybeAppendImportSpecifiers");
});

// ../node_modules/@babel/helper-module-imports/lib/index.js
var bj = y((ga) => {
  "use strict";
  Object.defineProperty(ga, "__esModule", {
    value: !0
  });
  Object.defineProperty(ga, "ImportInjector", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Hc.default;
    }, "get")
  });
  ga.addDefault = ENe;
  ga.addNamed = vNe;
  ga.addNamespace = SNe;
  ga.addSideEffect = TNe;
  Object.defineProperty(ga, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return bNe.default;
    }, "get")
  });
  var Hc = gj(), bNe = $1();
  function ENe(e, t, r) {
    return new Hc.default(e).addDefault(t, r);
  }
  i(ENe, "addDefault");
  function vNe(e, t, r, s) {
    return new Hc.default(e).addNamed(t, r, s);
  }
  i(vNe, "addNamed");
  function SNe(e, t, r) {
    return new Hc.default(e).addNamespace(t, r);
  }
  i(SNe, "addNamespace");
  function TNe(e, t, r) {
    return new Hc.default(e).addSideEffect(t, r);
  }
  i(TNe, "addSideEffect");
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-this.js
var Ej = y((W1) => {
  "use strict";
  Object.defineProperty(W1, "__esModule", {
    value: !0
  });
  W1.default = wNe;
  var xNe = sa(), V1 = mr(), {
    numericLiteral: PNe,
    unaryExpression: ANe
  } = V1.types, CNe = V1.traverse.visitors.merge([xNe.default, {
    ThisExpression(e) {
      e.replaceWith(ANe("void", PNe(0), !0));
    }
  }]);
  function wNe(e) {
    (0, V1.traverse)(e.node, Object.assign({}, CNe, {
      noScope: !0
    }));
  }
  i(wNe, "rewriteThis");
});

// ../node_modules/@babel/helper-simple-access/lib/index.js
var X1 = y((Y1) => {
  "use strict";
  Object.defineProperty(Y1, "__esModule", {
    value: !0
  });
  Y1.default = NNe;
  var DNe = Ne(), {
    LOGICAL_OPERATORS: INe,
    assignmentExpression: Gc,
    binaryExpression: G1,
    cloneNode: K1,
    identifier: Th,
    logicalExpression: _Ne,
    numericLiteral: H1,
    sequenceExpression: ONe,
    unaryExpression: vj
  } = DNe, Sj = {
    AssignmentExpression: {
      exit(e) {
        let {
          scope: t,
          seen: r,
          bindingNames: s
        } = this;
        if (e.node.operator === "=" || r.has(e.node)) return;
        r.add(e.node);
        let n = e.get("left");
        if (!n.isIdentifier()) return;
        let a = n.node.name;
        if (!s.has(a) || t.getBinding(a) !== e.scope.getBinding(a))
          return;
        let o = e.node.operator.slice(0, -1);
        INe.includes(o) ? e.replaceWith(_Ne(o, e.node.left, Gc("=", K1(e.node.left), e.node.right))) : (e.node.right = G1(o, K1(e.node.left),
        e.node.right), e.node.operator = "=");
      }
    }
  };
  Sj.UpdateExpression = {
    exit(e) {
      if (!this.includeUpdateExpression) return;
      let {
        scope: t,
        bindingNames: r
      } = this, s = e.get("argument");
      if (!s.isIdentifier()) return;
      let n = s.node.name;
      if (r.has(n) && t.getBinding(n) === e.scope.getBinding(n))
        if (e.parentPath.isExpressionStatement() && !e.isCompletionRecord()) {
          let a = e.node.operator == "++" ? "+=" : "-=";
          e.replaceWith(Gc(a, s.node, H1(1)));
        } else if (e.node.prefix)
          e.replaceWith(Gc("=", Th(n), G1(e.node.operator[0], vj("+", s.node), H1(1))));
        else {
          let a = e.scope.generateUidIdentifierBasedOnNode(s.node, "old"), o = a.name;
          e.scope.push({
            id: a
          });
          let l = G1(e.node.operator[0], Th(o), H1(1));
          e.replaceWith(ONe([Gc("=", Th(o), vj("+", s.node)), Gc("=", K1(s.node), l), Th(o)]));
        }
    }
  };
  function NNe(e, t) {
    {
      var r;
      e.traverse(Sj, {
        scope: e.scope,
        bindingNames: t,
        seen: /* @__PURE__ */ new WeakSet(),
        includeUpdateExpression: (r = arguments[2]) != null ? r : !0
      });
    }
  }
  i(NNe, "simplifyAccess");
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js
var wj = y((z1) => {
  "use strict";
  Object.defineProperty(z1, "__esModule", {
    value: !0
  });
  z1.default = GNe;
  var RNe = require("assert"), Pj = mr(), kNe = X1(), {
    assignmentExpression: Ph,
    cloneNode: Kc,
    expressionStatement: Xc,
    getOuterBindingIdentifiers: FNe,
    identifier: ba,
    isArrowFunctionExpression: LNe,
    isClassExpression: BNe,
    isFunctionExpression: MNe,
    isIdentifier: jNe,
    isMemberExpression: Tj,
    isVariableDeclaration: qNe,
    jsxIdentifier: xj,
    jsxMemberExpression: $Ne,
    memberExpression: Aj,
    numericLiteral: UNe,
    sequenceExpression: Yc,
    stringLiteral: Cj,
    variableDeclaration: VNe,
    variableDeclarator: WNe
  } = Pj.types;
  function HNe(e) {
    do
      switch (e.parent.type) {
        case "TSTypeAnnotation":
        case "TSTypeAliasDeclaration":
        case "TSTypeReference":
        case "TypeAnnotation":
        case "TypeAlias":
          return !0;
        case "ExportSpecifier":
          return e.parentPath.parent.exportKind === "type";
        default:
          if (e.parentPath.isStatement() || e.parentPath.isExpression())
            return !1;
      }
    while (e = e.parentPath);
  }
  i(HNe, "isInType");
  function GNe(e, t, r) {
    let s = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ i((c) => {
      e.requeue(c);
    }, "requeueInParent");
    for (let [c, f] of t.source) {
      for (let [p, d] of f.imports)
        s.set(p, [c, d, null]);
      for (let p of f.importsNamespace)
        s.set(p, [c, null, p]);
    }
    for (let [c, f] of t.local) {
      let p = n.get(c);
      p || (p = [], n.set(c, p)), p.push(...f.names);
    }
    let o = {
      metadata: t,
      requeueInParent: a,
      scope: e.scope,
      exported: n
    };
    e.traverse(KNe, o);
    let l = /* @__PURE__ */ new Set([...Array.from(s.keys()), ...Array.from(n.keys())]);
    (0, kNe.default)(e, l, !1);
    let u = {
      seen: /* @__PURE__ */ new WeakSet(),
      metadata: t,
      requeueInParent: a,
      scope: e.scope,
      imported: s,
      exported: n,
      buildImportReference([c, f, p], d) {
        let m = t.source.get(c);
        if (m.referenced = !0, p) {
          if (m.wrap) {
            var b;
            d = (b = r(d, m.wrap)) != null ? b : d;
          }
          return d;
        }
        let h = ba(m.name);
        if (m.wrap) {
          var g;
          h = (g = r(h, m.wrap)) != null ? g : h;
        }
        if (f === "default" && m.interop === "node-default")
          return h;
        let E = t.stringSpecifiers.has(f);
        return Aj(h, E ? Cj(f) : ba(f), E);
      }
    };
    e.traverse(YNe, u);
  }
  i(GNe, "rewriteLiveReferences");
  var KNe = {
    Scope(e) {
      e.skip();
    },
    ClassDeclaration(e) {
      let {
        requeueInParent: t,
        exported: r,
        metadata: s
      } = this, {
        id: n
      } = e.node;
      if (!n) throw new Error("Expected class to have a name");
      let a = n.name, o = r.get(a) || [];
      if (o.length > 0) {
        let l = Xc(uo(s, o, ba(a), e.scope));
        l._blockHoist = e.node._blockHoist, t(e.insertAfter(l)[0]);
      }
    },
    VariableDeclaration(e) {
      let {
        requeueInParent: t,
        exported: r,
        metadata: s
      } = this, n = e.node.kind === "var";
      for (let a of e.get("declarations")) {
        let {
          id: o
        } = a.node, {
          init: l
        } = a.node;
        if (jNe(o) && r.has(o.name) && !LNe(l) && (!MNe(l) || l.id) && (!BNe(l) || l.id)) {
          if (!l) {
            if (n)
              continue;
            l = e.scope.buildUndefinedNode();
          }
          a.node.init = uo(s, r.get(o.name), l, e.scope), t(a.get("init"));
        } else
          for (let u of Object.keys(a.getOuterBindingIdentifiers()))
            if (r.has(u)) {
              let c = Xc(uo(s, r.get(u), ba(u), e.scope));
              c._blockHoist = e.node._blockHoist, t(e.insertAfter(c)[0]);
            }
      }
    }
  }, uo = /* @__PURE__ */ i((e, t, r, s) => {
    let n = e.exportName;
    for (let a = s; a != null; a = a.parent)
      a.hasOwnBinding(n) && a.rename(n);
    return (t || []).reduce((a, o) => {
      let {
        stringSpecifiers: l
      } = e, u = l.has(o);
      return Ph("=", Aj(ba(n), u ? Cj(o) : ba(o), u), a);
    }, r);
  }, "buildBindingExportAssignmentExpression"), xh = /* @__PURE__ */ i((e) => Pj.template.expression.ast`
    (function() {
      throw new Error('"' + '${e}' + '" is read-only.');
    })()
  `, "buildImportThrow"), YNe = {
    ReferencedIdentifier(e) {
      let {
        seen: t,
        buildImportReference: r,
        scope: s,
        imported: n,
        requeueInParent: a
      } = this;
      if (t.has(e.node)) return;
      t.add(e.node);
      let o = e.node.name, l = n.get(o);
      if (l) {
        if (HNe(e))
          throw e.buildCodeFrameError(`Cannot transform the imported binding "${o}" since it's also used in a type annotation. Please strip \
type annotations using @babel/preset-typescript or @babel/preset-flow.`);
        let u = e.scope.getBinding(o);
        if (s.getBinding(o) !== u) return;
        let f = r(l, e.node);
        if (f.loc = e.node.loc, (e.parentPath.isCallExpression({
          callee: e.node
        }) || e.parentPath.isOptionalCallExpression({
          callee: e.node
        }) || e.parentPath.isTaggedTemplateExpression({
          tag: e.node
        })) && Tj(f))
          e.replaceWith(Yc([UNe(0), f]));
        else if (e.isJSXIdentifier() && Tj(f)) {
          let {
            object: p,
            property: d
          } = f;
          e.replaceWith($Ne(xj(p.name), xj(d.name)));
        } else
          e.replaceWith(f);
        a(e), e.skip();
      }
    },
    UpdateExpression(e) {
      let {
        scope: t,
        seen: r,
        imported: s,
        exported: n,
        requeueInParent: a,
        buildImportReference: o
      } = this;
      if (r.has(e.node)) return;
      r.add(e.node);
      let l = e.get("argument");
      if (l.isMemberExpression()) return;
      let u = e.node;
      if (l.isIdentifier()) {
        let c = l.node.name;
        if (t.getBinding(c) !== e.scope.getBinding(c))
          return;
        let f = n.get(c), p = s.get(c);
        if (f?.length > 0 || p)
          if (p)
            e.replaceWith(Ph(u.operator[0] + "=", o(p, l.node), xh(c)));
          else if (u.prefix)
            e.replaceWith(uo(this.metadata, f, Kc(u), e.scope));
          else {
            let d = t.generateDeclaredUidIdentifier(c);
            e.replaceWith(Yc([Ph("=", Kc(d), Kc(u)), uo(this.metadata, f, ba(c), e.scope), Kc(d)]));
          }
      }
      a(e), e.skip();
    },
    AssignmentExpression: {
      exit(e) {
        let {
          scope: t,
          seen: r,
          imported: s,
          exported: n,
          requeueInParent: a,
          buildImportReference: o
        } = this;
        if (r.has(e.node)) return;
        r.add(e.node);
        let l = e.get("left");
        if (!l.isMemberExpression())
          if (l.isIdentifier()) {
            let u = l.node.name;
            if (t.getBinding(u) !== e.scope.getBinding(u))
              return;
            let c = n.get(u), f = s.get(u);
            if (c?.length > 0 || f) {
              RNe(e.node.operator === "=", "Path was not simplified");
              let p = e.node;
              f && (p.left = o(f, l.node), p.right = Yc([p.right, xh(u)])), e.replaceWith(uo(this.metadata, c, p, e.scope)), a(e);
            }
          } else {
            let u = l.getOuterBindingIdentifiers(), c = Object.keys(u).filter((d) => t.getBinding(d) === e.scope.getBinding(d)), f = c.find(
            (d) => s.has(d));
            f && (e.node.right = Yc([e.node.right, xh(f)]));
            let p = [];
            if (c.forEach((d) => {
              let m = n.get(d) || [];
              m.length > 0 && p.push(uo(this.metadata, m, ba(d), e.scope));
            }), p.length > 0) {
              let d = Yc(p);
              e.parentPath.isExpressionStatement() && (d = Xc(d), d._blockHoist = e.parentPath.node._blockHoist);
              let m = e.insertAfter(d)[0];
              a(m);
            }
          }
      }
    },
    "ForOfStatement|ForInStatement"(e) {
      let {
        scope: t,
        node: r
      } = e, {
        left: s
      } = r, {
        exported: n,
        imported: a,
        scope: o
      } = this;
      if (!qNe(s)) {
        let l = !1, u, c = e.get("body").scope;
        for (let d of Object.keys(FNe(s)))
          o.getBinding(d) === t.getBinding(d) && (n.has(d) && (l = !0, c.hasOwnBinding(d) && c.rename(d)), a.has(d) && !u && (u = d));
        if (!l && !u)
          return;
        e.ensureBlock();
        let f = e.get("body"), p = t.generateUidIdentifierBasedOnNode(s);
        e.get("left").replaceWith(VNe("let", [WNe(Kc(p))])), t.registerDeclaration(e.get("left")), l && f.unshiftContainer("body", Xc(Ph("=",
        s, p))), u && f.unshiftContainer("body", Xc(xh(u)));
      }
    }
  };
});

// ../node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js
var J1 = y((Il) => {
  "use strict";
  Object.defineProperty(Il, "__esModule", {
    value: !0
  });
  Il.default = eRe;
  Il.hasExports = JNe;
  Il.isSideEffectImport = QNe;
  Il.validateImportInteropOption = Ij;
  var Dj = require("path"), XNe = rl(), zNe = pc();
  function JNe(e) {
    return e.hasExports;
  }
  i(JNe, "hasExports");
  function QNe(e) {
    return e.imports.size === 0 && e.importsNamespace.size === 0 && e.reexports.size === 0 && e.reexportNamespace.size === 0 && !e.reexportAll;
  }
  i(QNe, "isSideEffectImport");
  function Ij(e) {
    if (typeof e != "function" && e !== "none" && e !== "babel" && e !== "node")
      throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e}).`);
    return e;
  }
  i(Ij, "validateImportInteropOption");
  function ZNe(e, t, r) {
    return typeof e == "function" ? Ij(e(t, r)) : e;
  }
  i(ZNe, "resolveImportInterop");
  function eRe(e, t, {
    importInterop: r,
    initializeReexports: s = !1,
    getWrapperPayload: n,
    esNamespaceOnly: a = !1,
    filename: o
  }) {
    t || (t = e.scope.generateUidIdentifier("exports").name);
    let l = /* @__PURE__ */ new Set();
    sRe(e);
    let {
      local: u,
      sources: c,
      hasExports: f
    } = tRe(e, {
      initializeReexports: s,
      getWrapperPayload: n
    }, l);
    nRe(e);
    for (let [p, d] of c) {
      let {
        importsNamespace: m,
        imports: b
      } = d;
      if (m.size > 0 && b.size === 0) {
        let [g] = m;
        d.name = g;
      }
      let h = ZNe(r, p, o);
      h === "none" ? d.interop = "none" : h === "node" && d.interop === "namespace" ? d.interop = "node-namespace" : h === "node" && d.interop ===
      "default" ? d.interop = "node-default" : a && d.interop === "namespace" && (d.interop = "default");
    }
    return {
      exportName: t,
      exportNameListName: null,
      hasExports: f,
      local: u,
      source: c,
      stringSpecifiers: l
    };
  }
  i(eRe, "normalizeModuleAndLoadMetadata");
  function Ah(e, t) {
    if (e.isIdentifier())
      return e.node.name;
    if (e.isStringLiteral()) {
      let r = e.node.value;
      return (0, XNe.isIdentifierName)(r) || t.add(r), r;
    } else
      throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e.node.type}`);
  }
  i(Ah, "getExportSpecifierName");
  function _j(e) {
    if (!e.isExportSpecifier())
      throw e.isExportNamespaceSpecifier() ? e.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform\
-export-namespace-from`.") : e.buildCodeFrameError("Unexpected export specifier type");
  }
  i(_j, "assertExportSpecifier");
  function tRe(e, {
    getWrapperPayload: t,
    initializeReexports: r
  }, s) {
    let n = rRe(e, r, s), a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ i((c, f) => {
      let p = c.value, d = o.get(p);
      return d ? a.get(p).push(f) : (d = {
        name: e.scope.generateUidIdentifier((0, Dj.basename)(p, (0, Dj.extname)(p))).name,
        interop: "none",
        loc: null,
        imports: /* @__PURE__ */ new Map(),
        importsNamespace: /* @__PURE__ */ new Set(),
        reexports: /* @__PURE__ */ new Map(),
        reexportNamespace: /* @__PURE__ */ new Set(),
        reexportAll: null,
        wrap: null,
        get lazy() {
          return this.wrap === "lazy";
        },
        referenced: !1
      }, o.set(p, d), a.set(p, [f])), d;
    }, "getData"), u = !1;
    e.get("body").forEach((c) => {
      if (c.isImportDeclaration()) {
        let f = l(c.node.source, c.node);
        f.loc || (f.loc = c.node.loc), c.get("specifiers").forEach((p) => {
          if (p.isImportDefaultSpecifier()) {
            let d = p.get("local").node.name;
            f.imports.set(d, "default");
            let m = n.get(d);
            m && (n.delete(d), m.names.forEach((b) => {
              f.reexports.set(b, "default");
            }), f.referenced = !0);
          } else if (p.isImportNamespaceSpecifier()) {
            let d = p.get("local").node.name;
            f.importsNamespace.add(d);
            let m = n.get(d);
            m && (n.delete(d), m.names.forEach((b) => {
              f.reexportNamespace.add(b);
            }), f.referenced = !0);
          } else if (p.isImportSpecifier()) {
            let d = Ah(p.get("imported"), s), m = p.get("local").node.name;
            f.imports.set(m, d);
            let b = n.get(m);
            b && (n.delete(m), b.names.forEach((h) => {
              f.reexports.set(h, d);
            }), f.referenced = !0);
          }
        });
      } else if (c.isExportAllDeclaration()) {
        u = !0;
        let f = l(c.node.source, c.node);
        f.loc || (f.loc = c.node.loc), f.reexportAll = {
          loc: c.node.loc
        }, f.referenced = !0;
      } else if (c.isExportNamedDeclaration() && c.node.source) {
        u = !0;
        let f = l(c.node.source, c.node);
        f.loc || (f.loc = c.node.loc), c.get("specifiers").forEach((p) => {
          _j(p);
          let d = Ah(p.get("local"), s), m = Ah(p.get("exported"), s);
          if (f.reexports.set(m, d), f.referenced = !0, m === "__esModule")
            throw p.get("exported").buildCodeFrameError('Illegal export "__esModule".');
        });
      } else (c.isExportNamedDeclaration() || c.isExportDefaultDeclaration()) && (u = !0);
    });
    for (let c of o.values()) {
      let f = !1, p = !1;
      c.importsNamespace.size > 0 && (f = !0, p = !0), c.reexportAll && (p = !0);
      for (let d of c.imports.values())
        d === "default" ? f = !0 : p = !0;
      for (let d of c.reexports.values())
        d === "default" ? f = !0 : p = !0;
      f && p ? c.interop = "namespace" : f && (c.interop = "default");
    }
    if (t)
      for (let [c, f] of o)
        f.wrap = t(c, f, a.get(c));
    return {
      hasExports: u,
      local: n,
      sources: o
    };
  }
  i(tRe, "getModuleMetadata");
  function rRe(e, t, r) {
    let s = /* @__PURE__ */ new Map();
    e.get("body").forEach((o) => {
      let l;
      if (o.isImportDeclaration())
        l = "import";
      else {
        if (o.isExportDefaultDeclaration() && (o = o.get("declaration")), o.isExportNamedDeclaration()) {
          if (o.node.declaration)
            o = o.get("declaration");
          else if (t && o.node.source && o.get("source").isStringLiteral()) {
            o.get("specifiers").forEach((u) => {
              _j(u), s.set(u.get("local").node.name, "block");
            });
            return;
          }
        }
        if (o.isFunctionDeclaration())
          l = "hoisted";
        else if (o.isClassDeclaration())
          l = "block";
        else if (o.isVariableDeclaration({
          kind: "var"
        }))
          l = "var";
        else if (o.isVariableDeclaration())
          l = "block";
        else
          return;
      }
      Object.keys(o.getOuterBindingIdentifiers()).forEach((u) => {
        s.set(u, l);
      });
    });
    let n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ i((o) => {
      let l = o.node.name, u = n.get(l);
      if (!u) {
        let c = s.get(l);
        if (c === void 0)
          throw o.buildCodeFrameError(`Exporting local "${l}", which is not declared.`);
        u = {
          names: [],
          kind: c
        }, n.set(l, u);
      }
      return u;
    }, "getLocalMetadata");
    return e.get("body").forEach((o) => {
      if (o.isExportNamedDeclaration() && (t || !o.node.source))
        if (o.node.declaration) {
          let l = o.get("declaration"), u = l.getOuterBindingIdentifierPaths();
          Object.keys(u).forEach((c) => {
            if (c === "__esModule")
              throw l.buildCodeFrameError('Illegal export "__esModule".');
            a(u[c]).names.push(c);
          });
        } else
          o.get("specifiers").forEach((l) => {
            let u = l.get("local"), c = l.get("exported"), f = a(u), p = Ah(c, r);
            if (p === "__esModule")
              throw c.buildCodeFrameError('Illegal export "__esModule".');
            f.names.push(p);
          });
      else if (o.isExportDefaultDeclaration()) {
        let l = o.get("declaration");
        if (l.isFunctionDeclaration() || l.isClassDeclaration())
          a(l.get("id")).names.push("default");
        else
          throw l.buildCodeFrameError("Unexpected default expression export.");
      }
    }), n;
  }
  i(rRe, "getLocalExportMetadata");
  function sRe(e) {
    e.get("body").forEach((t) => {
      t.isExportDefaultDeclaration() && (0, zNe.default)(t);
    });
  }
  i(sRe, "nameAnonymousExports");
  function nRe(e) {
    e.get("body").forEach((t) => {
      if (t.isImportDeclaration())
        t.remove();
      else if (t.isExportNamedDeclaration())
        t.node.declaration ? (t.node.declaration._blockHoist = t.node._blockHoist, t.replaceWith(t.node.declaration)) : t.remove();
      else if (t.isExportDefaultDeclaration()) {
        let r = t.get("declaration");
        if (r.isFunctionDeclaration() || r.isClassDeclaration())
          r._blockHoist = t.node._blockHoist, t.replaceWith(r);
        else
          throw r.buildCodeFrameError("Unexpected default expression export.");
      } else t.isExportAllDeclaration() && t.remove();
    });
  }
  i(nRe, "removeImportExportDeclarations");
});

// ../node_modules/@babel/helper-module-transforms/lib/lazy-modules.js
var Oj = y((Ch) => {
  "use strict";
  Object.defineProperty(Ch, "__esModule", {
    value: !0
  });
  Ch.toGetWrapperPayload = oRe;
  Ch.wrapReference = lRe;
  var iRe = mr(), aRe = J1();
  function oRe(e) {
    return (t, r) => {
      if (e === !1 || (0, aRe.isSideEffectImport)(r) || r.reexportAll) return null;
      if (e === !0)
        return /\./.test(t) ? null : "lazy";
      if (Array.isArray(e))
        return e.indexOf(t) === -1 ? null : "lazy";
      if (typeof e == "function")
        return e(t) ? "lazy" : null;
      throw new Error(".lazy must be a boolean, string array, or function");
    };
  }
  i(oRe, "toGetWrapperPayload");
  function lRe(e, t) {
    return t === "lazy" ? iRe.types.callExpression(e, []) : null;
  }
  i(lRe, "wrapReference");
});

// ../node_modules/@babel/helper-module-transforms/lib/dynamic-import.js
var Q1 = y((wh) => {
  "use strict";
  Object.defineProperty(wh, "__esModule", {
    value: !0
  });
  wh.buildDynamicImport = uRe;
  var Fr = mr();
  wh.getDynamicImportSource = /* @__PURE__ */ i(function(t) {
    let [r] = t.arguments;
    return Fr.types.isStringLiteral(r) || Fr.types.isTemplateLiteral(r) ? r : Fr.template.expression.ast`\`\${${r}}\``;
  }, "getDynamicImportSource");
  function uRe(e, t, r, s) {
    let n = Fr.types.isCallExpression(e) ? e.arguments[0] : e.source;
    if (Fr.types.isStringLiteral(n) || Fr.types.isTemplateLiteral(n) && n.quasis.length === 0)
      return t ? Fr.template.expression.ast`
        Promise.resolve().then(() => ${s(n)})
      ` : s(n);
    let a = Fr.types.isTemplateLiteral(n) ? Fr.types.identifier("specifier") : Fr.types.templateLiteral([Fr.types.templateElement({
      raw: ""
    }), Fr.types.templateElement({
      raw: ""
    })], [Fr.types.identifier("specifier")]);
    return t ? Fr.template.expression.ast`
      (specifier =>
        new Promise(r => r(${a}))
          .then(s => ${s(Fr.types.identifier("s"))})
      )(${n})
    ` : r ? Fr.template.expression.ast`
      (specifier =>
        new Promise(r => r(${s(a)}))
      )(${n})
    ` : Fr.template.expression.ast`
      (specifier => ${s(a)})(${n})
    `;
  }
  i(uRe, "buildDynamicImport");
});

// ../node_modules/@babel/helper-module-transforms/lib/get-module-name.js
var Nj = y((Dh) => {
  "use strict";
  Object.defineProperty(Dh, "__esModule", {
    value: !0
  });
  Dh.default = Z1;
  {
    let e = Z1;
    Dh.default = Z1 = /* @__PURE__ */ i(function(r, s) {
      var n, a, o, l;
      return e(r, {
        moduleId: (n = s.moduleId) != null ? n : r.moduleId,
        moduleIds: (a = s.moduleIds) != null ? a : r.moduleIds,
        getModuleId: (o = s.getModuleId) != null ? o : r.getModuleId,
        moduleRoot: (l = s.moduleRoot) != null ? l : r.moduleRoot
      });
    }, "getModuleName");
  }
  function Z1(e, t) {
    let {
      filename: r,
      filenameRelative: s = r,
      sourceRoot: n = t.moduleRoot
    } = e, {
      moduleId: a,
      moduleIds: o = !!a,
      getModuleId: l,
      moduleRoot: u = n
    } = t;
    if (!o) return null;
    if (a != null && !l)
      return a;
    let c = u != null ? u + "/" : "";
    if (s) {
      let f = n != null ? new RegExp("^" + n + "/?") : "";
      c += s.replace(f, "").replace(/\.(\w*?)$/, "");
    }
    return c = c.replace(/\\/g, "/"), l && l(c) || c;
  }
  i(Z1, "getModuleName");
});

// ../node_modules/@babel/helper-module-transforms/lib/index.js
var Jc = y((Ps) => {
  "use strict";
  Object.defineProperty(Ps, "__esModule", {
    value: !0
  });
  Object.defineProperty(Ps, "buildDynamicImport", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return pRe.buildDynamicImport;
    }, "get")
  });
  Ps.buildNamespaceInitStatements = CRe;
  Ps.ensureStatementsHoisted = PRe;
  Object.defineProperty(Ps, "getModuleName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return dRe.default;
    }, "get")
  });
  Object.defineProperty(Ps, "hasExports", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return zc.hasExports;
    }, "get")
  });
  Object.defineProperty(Ps, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Fj.isModule;
    }, "get")
  });
  Object.defineProperty(Ps, "isSideEffectImport", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return zc.isSideEffectImport;
    }, "get")
  });
  Ps.rewriteModuleStatementsAndPrepareHeader = xRe;
  Object.defineProperty(Ps, "rewriteThis", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Lj.default;
    }, "get")
  });
  Ps.wrapInterop = ARe;
  var cRe = require("assert"), qr = mr(), Fj = bj(), Lj = Ej(), fRe = wj(), zc = J1(), sT = Oj(), pRe = Q1(), dRe = Nj(), {
    booleanLiteral: hRe,
    callExpression: Rj,
    cloneNode: Ih,
    directive: mRe,
    directiveLiteral: yRe,
    expressionStatement: gRe,
    identifier: _h,
    isIdentifier: bRe,
    memberExpression: kj,
    stringLiteral: ERe,
    valueToNode: vRe,
    variableDeclaration: SRe,
    variableDeclarator: TRe
  } = qr.types;
  Ps.getDynamicImportSource = Q1().getDynamicImportSource;
  function xRe(e, {
    exportName: t,
    strict: r,
    allowTopLevelThis: s,
    strictMode: n,
    noInterop: a,
    importInterop: o = a ? "none" : "babel",
    lazy: l,
    getWrapperPayload: u = sT.toGetWrapperPayload(l ?? !1),
    wrapReference: c = sT.wrapReference,
    esNamespaceOnly: f,
    filename: p,
    constantReexports: d = arguments[1].loose,
    enumerableModuleMeta: m = arguments[1].loose,
    noIncompleteNsImportDetection: b
  }) {
    (0, zc.validateImportInteropOption)(o), cRe((0, Fj.isModule)(e), "Cannot process module statements in a script"), e.node.sourceType = "s\
cript";
    let h = (0, zc.default)(e, t, {
      importInterop: o,
      initializeReexports: d,
      getWrapperPayload: u,
      esNamespaceOnly: f,
      filename: p
    });
    s || (0, Lj.default)(e), (0, fRe.default)(e, h, c), n !== !1 && (e.node.directives.some((C) => C.value.value === "use strict") || e.unshiftContainer(
    "directives", mRe(yRe("use strict"))));
    let g = [];
    (0, zc.hasExports)(h) && !r && g.push(wRe(h, m));
    let E = IRe(e, h);
    return E && (h.exportNameListName = E.name, g.push(E.statement)), g.push(..._Re(e, h, c, d, b)), {
      meta: h,
      headers: g
    };
  }
  i(xRe, "rewriteModuleStatementsAndPrepareHeader");
  function PRe(e) {
    e.forEach((t) => {
      t._blockHoist = 3;
    });
  }
  i(PRe, "ensureStatementsHoisted");
  function ARe(e, t, r) {
    if (r === "none")
      return null;
    if (r === "node-namespace")
      return Rj(e.hub.addHelper("interopRequireWildcard"), [t, hRe(!0)]);
    if (r === "node-default")
      return null;
    let s;
    if (r === "default")
      s = "interopRequireDefault";
    else if (r === "namespace")
      s = "interopRequireWildcard";
    else
      throw new Error(`Unknown interop: ${r}`);
    return Rj(e.hub.addHelper(s), [t]);
  }
  i(ARe, "wrapInterop");
  function CRe(e, t, r = !1, s = sT.wrapReference) {
    var n;
    let a = [], o = _h(t.name);
    for (let u of t.importsNamespace)
      u !== t.name && a.push(qr.template.statement`var NAME = SOURCE;`({
        NAME: u,
        SOURCE: Ih(o)
      }));
    let l = (n = s(o, t.wrap)) != null ? n : o;
    r && a.push(...Bj(e, t, !0, s));
    for (let u of t.reexportNamespace)
      a.push((qr.types.isIdentifier(l) ? qr.template.statement`EXPORTS.NAME = NAMESPACE;` : qr.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({
        EXPORTS: e.exportName,
        NAME: u,
        NAMESPACE: Ih(l)
      }));
    if (t.reexportAll) {
      let u = DRe(e, Ih(l), r);
      u.loc = t.reexportAll.loc, a.push(u);
    }
    return a;
  }
  i(CRe, "buildNamespaceInitStatements");
  var eT = {
    constant: qr.template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,
    constantComputed: qr.template.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`,
    spec: qr.template.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    `
  };
  function Bj(e, t, r, s) {
    var n;
    let a = _h(t.name);
    a = (n = s(a, t.wrap)) != null ? n : a;
    let {
      stringSpecifiers: o
    } = e;
    return Array.from(t.reexports, ([l, u]) => {
      let c = Ih(a);
      u === "default" && t.interop === "node-default" || (o.has(u) ? c = kj(c, ERe(u), !0) : c = kj(c, _h(u)));
      let f = {
        EXPORTS: e.exportName,
        EXPORT_NAME: l,
        NAMESPACE_IMPORT: c
      };
      return r || bRe(c) ? o.has(l) ? eT.constantComputed(f) : eT.constant(f) : eT.spec(f);
    });
  }
  i(Bj, "buildReexportsFromMeta");
  function wRe(e, t = !1) {
    return (t ? qr.template.statement`
        EXPORTS.__esModule = true;
      ` : qr.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
      EXPORTS: e.exportName
    });
  }
  i(wRe, "buildESModuleHeader");
  function DRe(e, t, r) {
    return (r ? qr.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : qr.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
      NAMESPACE: t,
      EXPORTS: e.exportName,
      VERIFY_NAME_LIST: e.exportNameListName ? (0, qr.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
        EXPORTS_LIST: e.exportNameListName
      }) : null
    });
  }
  i(DRe, "buildNamespaceReexport");
  function IRe(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let a of t.local.values())
      for (let o of a.names)
        r[o] = !0;
    let s = !1;
    for (let a of t.source.values()) {
      for (let o of a.reexports.keys())
        r[o] = !0;
      for (let o of a.reexportNamespace)
        r[o] = !0;
      s = s || !!a.reexportAll;
    }
    if (!s || Object.keys(r).length === 0) return null;
    let n = e.scope.generateUidIdentifier("exportNames");
    return delete r.default, {
      name: n.name,
      statement: SRe("var", [TRe(n, vRe(r))])
    };
  }
  i(IRe, "buildExportNameListDeclaration");
  function _Re(e, t, r, s = !1, n = !1) {
    let a = [];
    for (let [l, u] of t.local)
      if (u.kind !== "import") {
        if (u.kind === "hoisted")
          a.push([u.names[0], rT(t, u.names, _h(l))]);
        else if (!n)
          for (let c of u.names)
            a.push([c, null]);
      }
    for (let l of t.source.values()) {
      if (!s) {
        let u = Bj(t, l, !1, r), c = [...l.reexports.keys()];
        for (let f = 0; f < u.length; f++)
          a.push([c[f], u[f]]);
      }
      if (!n)
        for (let u of l.reexportNamespace)
          a.push([u, null]);
    }
    a.sort(([l], [u]) => l < u ? -1 : u < l ? 1 : 0);
    let o = [];
    if (n)
      for (let [, l] of a)
        o.push(l);
    else
      for (let u = 0; u < a.length; u += 100) {
        let c = [];
        for (let f = 0; f < 100 && u + f < a.length; f++) {
          let [p, d] = a[u + f];
          d !== null ? (c.length > 0 && (o.push(rT(t, c, e.scope.buildUndefinedNode())), c = []), o.push(d)) : c.push(p);
        }
        c.length > 0 && o.push(rT(t, c, e.scope.buildUndefinedNode()));
      }
    return o;
  }
  i(_Re, "buildExportInitializationStatements");
  var tT = {
    computed: qr.template.expression`EXPORTS["NAME"] = VALUE`,
    default: qr.template.expression`EXPORTS.NAME = VALUE`,
    define: qr.template.expression`Object.defineProperty(EXPORTS, "NAME", { enumerable:true, value: void 0, writable: true })["NAME"] = VALUE`
  };
  function rT(e, t, r) {
    let {
      stringSpecifiers: s,
      exportName: n
    } = e;
    return gRe(t.reduce((a, o) => {
      let l = {
        EXPORTS: n,
        NAME: o,
        VALUE: a
      };
      return o === "__proto__" ? tT.define(l) : s.has(o) ? tT.computed(l) : tT.default(l);
    }, r));
  }
  i(rT, "buildInitStatement");
});

// ../node_modules/@babel/core/node_modules/semver/semver.js
var Fh = y((qe, Uj) => {
  qe = Uj.exports = ze;
  var Dt;
  typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? Dt = /* @__PURE__ */ i(
  function() {
    var e = Array.prototype.slice.call(arguments, 0);
    e.unshift("SEMVER"), console.log.apply(console, e);
  }, "debug") : Dt = /* @__PURE__ */ i(function() {
  }, "debug");
  qe.SEMVER_SPEC_VERSION = "2.0.0";
  var Qc = 256, Oh = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, nT = 16, ORe = Qc - 6, _l = qe.re = [], wt = qe.safeRe = [], Z = qe.src = [], H = qe.tokens = {}, qj = 0;
  function nt(e) {
    H[e] = qj++;
  }
  i(nt, "tok");
  var aT = "[a-zA-Z0-9-]", iT = [
    ["\\s", 1],
    ["\\d", Qc],
    [aT, ORe]
  ];
  function ef(e) {
    for (var t = 0; t < iT.length; t++) {
      var r = iT[t][0], s = iT[t][1];
      e = e.split(r + "*").join(r + "{0," + s + "}").split(r + "+").join(r + "{1," + s + "}");
    }
    return e;
  }
  i(ef, "makeSafeRe");
  nt("NUMERICIDENTIFIER");
  Z[H.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  nt("NUMERICIDENTIFIERLOOSE");
  Z[H.NUMERICIDENTIFIERLOOSE] = "\\d+";
  nt("NONNUMERICIDENTIFIER");
  Z[H.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + aT + "*";
  nt("MAINVERSION");
  Z[H.MAINVERSION] = "(" + Z[H.NUMERICIDENTIFIER] + ")\\.(" + Z[H.NUMERICIDENTIFIER] + ")\\.(" + Z[H.NUMERICIDENTIFIER] + ")";
  nt("MAINVERSIONLOOSE");
  Z[H.MAINVERSIONLOOSE] = "(" + Z[H.NUMERICIDENTIFIERLOOSE] + ")\\.(" + Z[H.NUMERICIDENTIFIERLOOSE] + ")\\.(" + Z[H.NUMERICIDENTIFIERLOOSE] +
  ")";
  nt("PRERELEASEIDENTIFIER");
  Z[H.PRERELEASEIDENTIFIER] = "(?:" + Z[H.NUMERICIDENTIFIER] + "|" + Z[H.NONNUMERICIDENTIFIER] + ")";
  nt("PRERELEASEIDENTIFIERLOOSE");
  Z[H.PRERELEASEIDENTIFIERLOOSE] = "(?:" + Z[H.NUMERICIDENTIFIERLOOSE] + "|" + Z[H.NONNUMERICIDENTIFIER] + ")";
  nt("PRERELEASE");
  Z[H.PRERELEASE] = "(?:-(" + Z[H.PRERELEASEIDENTIFIER] + "(?:\\." + Z[H.PRERELEASEIDENTIFIER] + ")*))";
  nt("PRERELEASELOOSE");
  Z[H.PRERELEASELOOSE] = "(?:-?(" + Z[H.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + Z[H.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  nt("BUILDIDENTIFIER");
  Z[H.BUILDIDENTIFIER] = aT + "+";
  nt("BUILD");
  Z[H.BUILD] = "(?:\\+(" + Z[H.BUILDIDENTIFIER] + "(?:\\." + Z[H.BUILDIDENTIFIER] + ")*))";
  nt("FULL");
  nt("FULLPLAIN");
  Z[H.FULLPLAIN] = "v?" + Z[H.MAINVERSION] + Z[H.PRERELEASE] + "?" + Z[H.BUILD] + "?";
  Z[H.FULL] = "^" + Z[H.FULLPLAIN] + "$";
  nt("LOOSEPLAIN");
  Z[H.LOOSEPLAIN] = "[v=\\s]*" + Z[H.MAINVERSIONLOOSE] + Z[H.PRERELEASELOOSE] + "?" + Z[H.BUILD] + "?";
  nt("LOOSE");
  Z[H.LOOSE] = "^" + Z[H.LOOSEPLAIN] + "$";
  nt("GTLT");
  Z[H.GTLT] = "((?:<|>)?=?)";
  nt("XRANGEIDENTIFIERLOOSE");
  Z[H.XRANGEIDENTIFIERLOOSE] = Z[H.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  nt("XRANGEIDENTIFIER");
  Z[H.XRANGEIDENTIFIER] = Z[H.NUMERICIDENTIFIER] + "|x|X|\\*";
  nt("XRANGEPLAIN");
  Z[H.XRANGEPLAIN] = "[v=\\s]*(" + Z[H.XRANGEIDENTIFIER] + ")(?:\\.(" + Z[H.XRANGEIDENTIFIER] + ")(?:\\.(" + Z[H.XRANGEIDENTIFIER] + ")(?:" +
  Z[H.PRERELEASE] + ")?" + Z[H.BUILD] + "?)?)?";
  nt("XRANGEPLAINLOOSE");
  Z[H.XRANGEPLAINLOOSE] = "[v=\\s]*(" + Z[H.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + Z[H.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + Z[H.XRANGEIDENTIFIERLOOSE] +
  ")(?:" + Z[H.PRERELEASELOOSE] + ")?" + Z[H.BUILD] + "?)?)?";
  nt("XRANGE");
  Z[H.XRANGE] = "^" + Z[H.GTLT] + "\\s*" + Z[H.XRANGEPLAIN] + "$";
  nt("XRANGELOOSE");
  Z[H.XRANGELOOSE] = "^" + Z[H.GTLT] + "\\s*" + Z[H.XRANGEPLAINLOOSE] + "$";
  nt("COERCE");
  Z[H.COERCE] = "(^|[^\\d])(\\d{1," + nT + "})(?:\\.(\\d{1," + nT + "}))?(?:\\.(\\d{1," + nT + "}))?(?:$|[^\\d])";
  nt("COERCERTL");
  _l[H.COERCERTL] = new RegExp(Z[H.COERCE], "g");
  wt[H.COERCERTL] = new RegExp(ef(Z[H.COERCE]), "g");
  nt("LONETILDE");
  Z[H.LONETILDE] = "(?:~>?)";
  nt("TILDETRIM");
  Z[H.TILDETRIM] = "(\\s*)" + Z[H.LONETILDE] + "\\s+";
  _l[H.TILDETRIM] = new RegExp(Z[H.TILDETRIM], "g");
  wt[H.TILDETRIM] = new RegExp(ef(Z[H.TILDETRIM]), "g");
  var NRe = "$1~";
  nt("TILDE");
  Z[H.TILDE] = "^" + Z[H.LONETILDE] + Z[H.XRANGEPLAIN] + "$";
  nt("TILDELOOSE");
  Z[H.TILDELOOSE] = "^" + Z[H.LONETILDE] + Z[H.XRANGEPLAINLOOSE] + "$";
  nt("LONECARET");
  Z[H.LONECARET] = "(?:\\^)";
  nt("CARETTRIM");
  Z[H.CARETTRIM] = "(\\s*)" + Z[H.LONECARET] + "\\s+";
  _l[H.CARETTRIM] = new RegExp(Z[H.CARETTRIM], "g");
  wt[H.CARETTRIM] = new RegExp(ef(Z[H.CARETTRIM]), "g");
  var RRe = "$1^";
  nt("CARET");
  Z[H.CARET] = "^" + Z[H.LONECARET] + Z[H.XRANGEPLAIN] + "$";
  nt("CARETLOOSE");
  Z[H.CARETLOOSE] = "^" + Z[H.LONECARET] + Z[H.XRANGEPLAINLOOSE] + "$";
  nt("COMPARATORLOOSE");
  Z[H.COMPARATORLOOSE] = "^" + Z[H.GTLT] + "\\s*(" + Z[H.LOOSEPLAIN] + ")$|^$";
  nt("COMPARATOR");
  Z[H.COMPARATOR] = "^" + Z[H.GTLT] + "\\s*(" + Z[H.FULLPLAIN] + ")$|^$";
  nt("COMPARATORTRIM");
  Z[H.COMPARATORTRIM] = "(\\s*)" + Z[H.GTLT] + "\\s*(" + Z[H.LOOSEPLAIN] + "|" + Z[H.XRANGEPLAIN] + ")";
  _l[H.COMPARATORTRIM] = new RegExp(Z[H.COMPARATORTRIM], "g");
  wt[H.COMPARATORTRIM] = new RegExp(ef(Z[H.COMPARATORTRIM]), "g");
  var kRe = "$1$2$3";
  nt("HYPHENRANGE");
  Z[H.HYPHENRANGE] = "^\\s*(" + Z[H.XRANGEPLAIN] + ")\\s+-\\s+(" + Z[H.XRANGEPLAIN] + ")\\s*$";
  nt("HYPHENRANGELOOSE");
  Z[H.HYPHENRANGELOOSE] = "^\\s*(" + Z[H.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + Z[H.XRANGEPLAINLOOSE] + ")\\s*$";
  nt("STAR");
  Z[H.STAR] = "(<|>)?=?\\s*\\*";
  for (Vn = 0; Vn < qj; Vn++)
    Dt(Vn, Z[Vn]), _l[Vn] || (_l[Vn] = new RegExp(Z[Vn]), wt[Vn] = new RegExp(ef(Z[Vn])));
  var Vn;
  qe.parse = fo;
  function fo(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof ze)
      return e;
    if (typeof e != "string" || e.length > Qc)
      return null;
    var r = t.loose ? wt[H.LOOSE] : wt[H.FULL];
    if (!r.test(e))
      return null;
    try {
      return new ze(e, t);
    } catch {
      return null;
    }
  }
  i(fo, "parse");
  qe.valid = FRe;
  function FRe(e, t) {
    var r = fo(e, t);
    return r ? r.version : null;
  }
  i(FRe, "valid");
  qe.clean = LRe;
  function LRe(e, t) {
    var r = fo(e.trim().replace(/^[=v]+/, ""), t);
    return r ? r.version : null;
  }
  i(LRe, "clean");
  qe.SemVer = ze;
  function ze(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof ze) {
      if (e.loose === t.loose)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError("Invalid Version: " + e);
    if (e.length > Qc)
      throw new TypeError("version is longer than " + Qc + " characters");
    if (!(this instanceof ze))
      return new ze(e, t);
    Dt("SemVer", e, t), this.options = t, this.loose = !!t.loose;
    var r = e.trim().match(t.loose ? wt[H.LOOSE] : wt[H.FULL]);
    if (!r)
      throw new TypeError("Invalid Version: " + e);
    if (this.raw = e, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > Oh || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Oh || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Oh || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4] ? this.prerelease = r[4].split(".").map(function(s) {
      if (/^[0-9]+$/.test(s)) {
        var n = +s;
        if (n >= 0 && n < Oh)
          return n;
      }
      return s;
    }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format();
  }
  i(ze, "SemVer");
  ze.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.
    join(".")), this.version;
  };
  ze.prototype.toString = function() {
    return this.version;
  };
  ze.prototype.compare = function(e) {
    return Dt("SemVer.compare", this.version, this.options, e), e instanceof ze || (e = new ze(e, this.options)), this.compareMain(e) || this.
    comparePre(e);
  };
  ze.prototype.compareMain = function(e) {
    return e instanceof ze || (e = new ze(e, this.options)), co(this.major, e.major) || co(this.minor, e.minor) || co(this.patch, e.patch);
  };
  ze.prototype.comparePre = function(e) {
    if (e instanceof ze || (e = new ze(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    var t = 0;
    do {
      var r = this.prerelease[t], s = e.prerelease[t];
      if (Dt("prerelease compare", t, r, s), r === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === s)
        continue;
      return co(r, s);
    } while (++t);
  };
  ze.prototype.compareBuild = function(e) {
    e instanceof ze || (e = new ze(e, this.options));
    var t = 0;
    do {
      var r = this.build[t], s = e.build[t];
      if (Dt("prerelease compare", t, r, s), r === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === s)
        continue;
      return co(r, s);
    } while (++t);
  };
  ze.prototype.inc = function(e, t) {
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t), this.inc("pre", t);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease =
        [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var r = this.prerelease.length; --r >= 0; )
            typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
          r === -1 && this.prerelease.push(0);
        }
        t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + e);
    }
    return this.format(), this.raw = this.version, this;
  };
  qe.inc = BRe;
  function BRe(e, t, r, s) {
    typeof r == "string" && (s = r, r = void 0);
    try {
      return new ze(e, r).inc(t, s).version;
    } catch {
      return null;
    }
  }
  i(BRe, "inc");
  qe.diff = MRe;
  function MRe(e, t) {
    if (oT(e, t))
      return null;
    var r = fo(e), s = fo(t), n = "";
    if (r.prerelease.length || s.prerelease.length) {
      n = "pre";
      var a = "prerelease";
    }
    for (var o in r)
      if ((o === "major" || o === "minor" || o === "patch") && r[o] !== s[o])
        return n + o;
    return a;
  }
  i(MRe, "diff");
  qe.compareIdentifiers = co;
  var Mj = /^[0-9]+$/;
  function co(e, t) {
    var r = Mj.test(e), s = Mj.test(t);
    return r && s && (e = +e, t = +t), e === t ? 0 : r && !s ? -1 : s && !r ? 1 : e < t ? -1 : 1;
  }
  i(co, "compareIdentifiers");
  qe.rcompareIdentifiers = jRe;
  function jRe(e, t) {
    return co(t, e);
  }
  i(jRe, "rcompareIdentifiers");
  qe.major = qRe;
  function qRe(e, t) {
    return new ze(e, t).major;
  }
  i(qRe, "major");
  qe.minor = $Re;
  function $Re(e, t) {
    return new ze(e, t).minor;
  }
  i($Re, "minor");
  qe.patch = URe;
  function URe(e, t) {
    return new ze(e, t).patch;
  }
  i(URe, "patch");
  qe.compare = Ti;
  function Ti(e, t, r) {
    return new ze(e, r).compare(new ze(t, r));
  }
  i(Ti, "compare");
  qe.compareLoose = VRe;
  function VRe(e, t) {
    return Ti(e, t, !0);
  }
  i(VRe, "compareLoose");
  qe.compareBuild = WRe;
  function WRe(e, t, r) {
    var s = new ze(e, r), n = new ze(t, r);
    return s.compare(n) || s.compareBuild(n);
  }
  i(WRe, "compareBuild");
  qe.rcompare = HRe;
  function HRe(e, t, r) {
    return Ti(t, e, r);
  }
  i(HRe, "rcompare");
  qe.sort = GRe;
  function GRe(e, t) {
    return e.sort(function(r, s) {
      return qe.compareBuild(r, s, t);
    });
  }
  i(GRe, "sort");
  qe.rsort = KRe;
  function KRe(e, t) {
    return e.sort(function(r, s) {
      return qe.compareBuild(s, r, t);
    });
  }
  i(KRe, "rsort");
  qe.gt = Zc;
  function Zc(e, t, r) {
    return Ti(e, t, r) > 0;
  }
  i(Zc, "gt");
  qe.lt = Nh;
  function Nh(e, t, r) {
    return Ti(e, t, r) < 0;
  }
  i(Nh, "lt");
  qe.eq = oT;
  function oT(e, t, r) {
    return Ti(e, t, r) === 0;
  }
  i(oT, "eq");
  qe.neq = $j;
  function $j(e, t, r) {
    return Ti(e, t, r) !== 0;
  }
  i($j, "neq");
  qe.gte = lT;
  function lT(e, t, r) {
    return Ti(e, t, r) >= 0;
  }
  i(lT, "gte");
  qe.lte = uT;
  function uT(e, t, r) {
    return Ti(e, t, r) <= 0;
  }
  i(uT, "lte");
  qe.cmp = Rh;
  function Rh(e, t, r, s) {
    switch (t) {
      case "===":
        return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
      case "!==":
        return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
      case "":
      case "=":
      case "==":
        return oT(e, r, s);
      case "!=":
        return $j(e, r, s);
      case ">":
        return Zc(e, r, s);
      case ">=":
        return lT(e, r, s);
      case "<":
        return Nh(e, r, s);
      case "<=":
        return uT(e, r, s);
      default:
        throw new TypeError("Invalid operator: " + t);
    }
  }
  i(Rh, "cmp");
  qe.Comparator = Hs;
  function Hs(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof Hs) {
      if (e.loose === !!t.loose)
        return e;
      e = e.value;
    }
    if (!(this instanceof Hs))
      return new Hs(e, t);
    e = e.trim().split(/\s+/).join(" "), Dt("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === Ol ?
    this.value = "" : this.value = this.operator + this.semver.version, Dt("comp", this);
  }
  i(Hs, "Comparator");
  var Ol = {};
  Hs.prototype.parse = function(e) {
    var t = this.options.loose ? wt[H.COMPARATORLOOSE] : wt[H.COMPARATOR], r = e.match(t);
    if (!r)
      throw new TypeError("Invalid comparator: " + e);
    this.operator = r[1] !== void 0 ? r[1] : "", this.operator === "=" && (this.operator = ""), r[2] ? this.semver = new ze(r[2], this.options.
    loose) : this.semver = Ol;
  };
  Hs.prototype.toString = function() {
    return this.value;
  };
  Hs.prototype.test = function(e) {
    if (Dt("Comparator.test", e, this.options.loose), this.semver === Ol || e === Ol)
      return !0;
    if (typeof e == "string")
      try {
        e = new ze(e, this.options);
      } catch {
        return !1;
      }
    return Rh(e, this.operator, this.semver, this.options);
  };
  Hs.prototype.intersects = function(e, t) {
    if (!(e instanceof Hs))
      throw new TypeError("a Comparator is required");
    (!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    });
    var r;
    if (this.operator === "")
      return this.value === "" ? !0 : (r = new or(e.value, t), kh(this.value, r, t));
    if (e.operator === "")
      return e.value === "" ? !0 : (r = new or(this.value, t), kh(e.semver, r, t));
    var s = (this.operator === ">=" || this.operator === ">") && (e.operator === ">=" || e.operator === ">"), n = (this.operator === "<=" ||
    this.operator === "<") && (e.operator === "<=" || e.operator === "<"), a = this.semver.version === e.semver.version, o = (this.operator ===
    ">=" || this.operator === "<=") && (e.operator === ">=" || e.operator === "<="), l = Rh(this.semver, "<", e.semver, t) && (this.operator ===
    ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"), u = Rh(this.semver, ">", e.semver, t) && (this.operator ===
    "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
    return s || n || a && o || l || u;
  };
  qe.Range = or;
  function or(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof or)
      return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new or(e.raw, t);
    if (e instanceof Hs)
      return new or(e.value, t);
    if (!(this instanceof or))
      return new or(e, t);
    if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e.trim().split(/\s+/).join(" "),
    this.set = this.raw.split("||").map(function(r) {
      return this.parseRange(r.trim());
    }, this).filter(function(r) {
      return r.length;
    }), !this.set.length)
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    this.format();
  }
  i(or, "Range");
  or.prototype.format = function() {
    return this.range = this.set.map(function(e) {
      return e.join(" ").trim();
    }).join("||").trim(), this.range;
  };
  or.prototype.toString = function() {
    return this.range;
  };
  or.prototype.parseRange = function(e) {
    var t = this.options.loose, r = t ? wt[H.HYPHENRANGELOOSE] : wt[H.HYPHENRANGE];
    e = e.replace(r, ske), Dt("hyphen replace", e), e = e.replace(wt[H.COMPARATORTRIM], kRe), Dt("comparator trim", e, wt[H.COMPARATORTRIM]),
    e = e.replace(wt[H.TILDETRIM], NRe), e = e.replace(wt[H.CARETTRIM], RRe), e = e.split(/\s+/).join(" ");
    var s = t ? wt[H.COMPARATORLOOSE] : wt[H.COMPARATOR], n = e.split(" ").map(function(a) {
      return XRe(a, this.options);
    }, this).join(" ").split(/\s+/);
    return this.options.loose && (n = n.filter(function(a) {
      return !!a.match(s);
    })), n = n.map(function(a) {
      return new Hs(a, this.options);
    }, this), n;
  };
  or.prototype.intersects = function(e, t) {
    if (!(e instanceof or))
      throw new TypeError("a Range is required");
    return this.set.some(function(r) {
      return jj(r, t) && e.set.some(function(s) {
        return jj(s, t) && r.every(function(n) {
          return s.every(function(a) {
            return n.intersects(a, t);
          });
        });
      });
    });
  };
  function jj(e, t) {
    for (var r = !0, s = e.slice(), n = s.pop(); r && s.length; )
      r = s.every(function(a) {
        return n.intersects(a, t);
      }), n = s.pop();
    return r;
  }
  i(jj, "isSatisfiable");
  qe.toComparators = YRe;
  function YRe(e, t) {
    return new or(e, t).set.map(function(r) {
      return r.map(function(s) {
        return s.value;
      }).join(" ").trim().split(" ");
    });
  }
  i(YRe, "toComparators");
  function XRe(e, t) {
    return Dt("comp", e, t), e = QRe(e, t), Dt("caret", e), e = zRe(e, t), Dt("tildes", e), e = eke(e, t), Dt("xrange", e), e = rke(e, t), Dt(
    "stars", e), e;
  }
  i(XRe, "parseComparator");
  function cs(e) {
    return !e || e.toLowerCase() === "x" || e === "*";
  }
  i(cs, "isX");
  function zRe(e, t) {
    return e.trim().split(/\s+/).map(function(r) {
      return JRe(r, t);
    }).join(" ");
  }
  i(zRe, "replaceTildes");
  function JRe(e, t) {
    var r = t.loose ? wt[H.TILDELOOSE] : wt[H.TILDE];
    return e.replace(r, function(s, n, a, o, l) {
      Dt("tilde", e, s, n, a, o, l);
      var u;
      return cs(n) ? u = "" : cs(a) ? u = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : cs(o) ? u = ">=" + n + "." + a + ".0 <" + n + "." + (+a +
      1) + ".0" : l ? (Dt("replaceTilde pr", l), u = ">=" + n + "." + a + "." + o + "-" + l + " <" + n + "." + (+a + 1) + ".0") : u = ">=" +
      n + "." + a + "." + o + " <" + n + "." + (+a + 1) + ".0", Dt("tilde return", u), u;
    });
  }
  i(JRe, "replaceTilde");
  function QRe(e, t) {
    return e.trim().split(/\s+/).map(function(r) {
      return ZRe(r, t);
    }).join(" ");
  }
  i(QRe, "replaceCarets");
  function ZRe(e, t) {
    Dt("caret", e, t);
    var r = t.loose ? wt[H.CARETLOOSE] : wt[H.CARET];
    return e.replace(r, function(s, n, a, o, l) {
      Dt("caret", e, s, n, a, o, l);
      var u;
      return cs(n) ? u = "" : cs(a) ? u = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : cs(o) ? n === "0" ? u = ">=" + n + "." + a + ".0 <" + n +
      "." + (+a + 1) + ".0" : u = ">=" + n + "." + a + ".0 <" + (+n + 1) + ".0.0" : l ? (Dt("replaceCaret pr", l), n === "0" ? a === "0" ? u =
      ">=" + n + "." + a + "." + o + "-" + l + " <" + n + "." + a + "." + (+o + 1) : u = ">=" + n + "." + a + "." + o + "-" + l + " <" + n +
      "." + (+a + 1) + ".0" : u = ">=" + n + "." + a + "." + o + "-" + l + " <" + (+n + 1) + ".0.0") : (Dt("no pr"), n === "0" ? a === "0" ?
      u = ">=" + n + "." + a + "." + o + " <" + n + "." + a + "." + (+o + 1) : u = ">=" + n + "." + a + "." + o + " <" + n + "." + (+a + 1) +
      ".0" : u = ">=" + n + "." + a + "." + o + " <" + (+n + 1) + ".0.0"), Dt("caret return", u), u;
    });
  }
  i(ZRe, "replaceCaret");
  function eke(e, t) {
    return Dt("replaceXRanges", e, t), e.split(/\s+/).map(function(r) {
      return tke(r, t);
    }).join(" ");
  }
  i(eke, "replaceXRanges");
  function tke(e, t) {
    e = e.trim();
    var r = t.loose ? wt[H.XRANGELOOSE] : wt[H.XRANGE];
    return e.replace(r, function(s, n, a, o, l, u) {
      Dt("xRange", e, s, n, a, o, l, u);
      var c = cs(a), f = c || cs(o), p = f || cs(l), d = p;
      return n === "=" && d && (n = ""), u = t.includePrerelease ? "-0" : "", c ? n === ">" || n === "<" ? s = "<0.0.0-0" : s = "*" : n && d ?
      (f && (o = 0), l = 0, n === ">" ? (n = ">=", f ? (a = +a + 1, o = 0, l = 0) : (o = +o + 1, l = 0)) : n === "<=" && (n = "<", f ? a = +a +
      1 : o = +o + 1), s = n + a + "." + o + "." + l + u) : f ? s = ">=" + a + ".0.0" + u + " <" + (+a + 1) + ".0.0" + u : p && (s = ">=" + a +
      "." + o + ".0" + u + " <" + a + "." + (+o + 1) + ".0" + u), Dt("xRange return", s), s;
    });
  }
  i(tke, "replaceXRange");
  function rke(e, t) {
    return Dt("replaceStars", e, t), e.trim().replace(wt[H.STAR], "");
  }
  i(rke, "replaceStars");
  function ske(e, t, r, s, n, a, o, l, u, c, f, p, d) {
    return cs(r) ? t = "" : cs(s) ? t = ">=" + r + ".0.0" : cs(n) ? t = ">=" + r + "." + s + ".0" : t = ">=" + t, cs(u) ? l = "" : cs(c) ? l =
    "<" + (+u + 1) + ".0.0" : cs(f) ? l = "<" + u + "." + (+c + 1) + ".0" : p ? l = "<=" + u + "." + c + "." + f + "-" + p : l = "<=" + l, (t +
    " " + l).trim();
  }
  i(ske, "hyphenReplace");
  or.prototype.test = function(e) {
    if (!e)
      return !1;
    if (typeof e == "string")
      try {
        e = new ze(e, this.options);
      } catch {
        return !1;
      }
    for (var t = 0; t < this.set.length; t++)
      if (nke(this.set[t], e, this.options))
        return !0;
    return !1;
  };
  function nke(e, t, r) {
    for (var s = 0; s < e.length; s++)
      if (!e[s].test(t))
        return !1;
    if (t.prerelease.length && !r.includePrerelease) {
      for (s = 0; s < e.length; s++)
        if (Dt(e[s].semver), e[s].semver !== Ol && e[s].semver.prerelease.length > 0) {
          var n = e[s].semver;
          if (n.major === t.major && n.minor === t.minor && n.patch === t.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  }
  i(nke, "testSet");
  qe.satisfies = kh;
  function kh(e, t, r) {
    try {
      t = new or(t, r);
    } catch {
      return !1;
    }
    return t.test(e);
  }
  i(kh, "satisfies");
  qe.maxSatisfying = ike;
  function ike(e, t, r) {
    var s = null, n = null;
    try {
      var a = new or(t, r);
    } catch {
      return null;
    }
    return e.forEach(function(o) {
      a.test(o) && (!s || n.compare(o) === -1) && (s = o, n = new ze(s, r));
    }), s;
  }
  i(ike, "maxSatisfying");
  qe.minSatisfying = ake;
  function ake(e, t, r) {
    var s = null, n = null;
    try {
      var a = new or(t, r);
    } catch {
      return null;
    }
    return e.forEach(function(o) {
      a.test(o) && (!s || n.compare(o) === 1) && (s = o, n = new ze(s, r));
    }), s;
  }
  i(ake, "minSatisfying");
  qe.minVersion = oke;
  function oke(e, t) {
    e = new or(e, t);
    var r = new ze("0.0.0");
    if (e.test(r) || (r = new ze("0.0.0-0"), e.test(r)))
      return r;
    r = null;
    for (var s = 0; s < e.set.length; ++s) {
      var n = e.set[s];
      n.forEach(function(a) {
        var o = new ze(a.semver.version);
        switch (a.operator) {
          case ">":
            o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0), o.raw = o.format();
          case "":
          case ">=":
            (!r || Zc(r, o)) && (r = o);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + a.operator);
        }
      });
    }
    return r && e.test(r) ? r : null;
  }
  i(oke, "minVersion");
  qe.validRange = lke;
  function lke(e, t) {
    try {
      return new or(e, t).range || "*";
    } catch {
      return null;
    }
  }
  i(lke, "validRange");
  qe.ltr = uke;
  function uke(e, t, r) {
    return cT(e, t, "<", r);
  }
  i(uke, "ltr");
  qe.gtr = cke;
  function cke(e, t, r) {
    return cT(e, t, ">", r);
  }
  i(cke, "gtr");
  qe.outside = cT;
  function cT(e, t, r, s) {
    e = new ze(e, s), t = new or(t, s);
    var n, a, o, l, u;
    switch (r) {
      case ">":
        n = Zc, a = uT, o = Nh, l = ">", u = ">=";
        break;
      case "<":
        n = Nh, a = lT, o = Zc, l = "<", u = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (kh(e, t, s))
      return !1;
    for (var c = 0; c < t.set.length; ++c) {
      var f = t.set[c], p = null, d = null;
      if (f.forEach(function(m) {
        m.semver === Ol && (m = new Hs(">=0.0.0")), p = p || m, d = d || m, n(m.semver, p.semver, s) ? p = m : o(m.semver, d.semver, s) && (d =
        m);
      }), p.operator === l || p.operator === u || (!d.operator || d.operator === l) && a(e, d.semver))
        return !1;
      if (d.operator === u && o(e, d.semver))
        return !1;
    }
    return !0;
  }
  i(cT, "outside");
  qe.prerelease = fke;
  function fke(e, t) {
    var r = fo(e, t);
    return r && r.prerelease.length ? r.prerelease : null;
  }
  i(fke, "prerelease");
  qe.intersects = pke;
  function pke(e, t, r) {
    return e = new or(e, r), t = new or(t, r), e.intersects(t);
  }
  i(pke, "intersects");
  qe.coerce = dke;
  function dke(e, t) {
    if (e instanceof ze)
      return e;
    if (typeof e == "number" && (e = String(e)), typeof e != "string")
      return null;
    t = t || {};
    var r = null;
    if (!t.rtl)
      r = e.match(wt[H.COERCE]);
    else {
      for (var s; (s = wt[H.COERCERTL].exec(e)) && (!r || r.index + r[0].length !== e.length); )
        (!r || s.index + s[0].length !== r.index + r[0].length) && (r = s), wt[H.COERCERTL].lastIndex = s.index + s[1].length + s[2].length;
      wt[H.COERCERTL].lastIndex = -1;
    }
    return r === null ? null : fo(r[2] + "." + (r[3] || "0") + "." + (r[4] || "0"), t);
  }
  i(dke, "coerce");
});

// ../node_modules/@babel/core/lib/transformation/file/file.js
var Mh = y((Bh) => {
  "use strict";
  Object.defineProperty(Bh, "__esModule", {
    value: !0
  });
  Bh.default = void 0;
  function tf() {
    let e = L1();
    return tf = /* @__PURE__ */ i(function() {
      return e;
    }, "helpers"), e;
  }
  i(tf, "helpers");
  function fT() {
    let e = Ms();
    return fT = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(fT, "_traverse");
  function Vj() {
    let e = xc();
    return Vj = /* @__PURE__ */ i(function() {
      return e;
    }, "_codeFrame"), e;
  }
  i(Vj, "_codeFrame");
  function Wj() {
    let e = Ne();
    return Wj = /* @__PURE__ */ i(function() {
      return e;
    }, "_t"), e;
  }
  i(Wj, "_t");
  function Hj() {
    let e = Jc();
    return Hj = /* @__PURE__ */ i(function() {
      return e;
    }, "_helperModuleTransforms"), e;
  }
  i(Hj, "_helperModuleTransforms");
  function Lh() {
    let e = Fh();
    return Lh = /* @__PURE__ */ i(function() {
      return e;
    }, "_semver"), e;
  }
  i(Lh, "_semver");
  var {
    cloneNode: hke,
    interpreterDirective: mke
  } = Wj(), yke = {
    enter(e, t) {
      let r = e.node.loc;
      r && (t.loc = r, e.stop());
    }
  }, rf = class e {
    static {
      i(this, "File");
    }
    constructor(t, {
      code: r,
      ast: s,
      inputMap: n
    }) {
      this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope =
      void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = {
        file: this,
        getCode: /* @__PURE__ */ i(() => this.code, "getCode"),
        getScope: /* @__PURE__ */ i(() => this.scope, "getScope"),
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      }, this.opts = t, this.code = r, this.ast = s, this.inputMap = n, this.path = fT().NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext(), this.scope = this.path.scope;
    }
    get shebang() {
      let {
        interpreter: t
      } = this.path.node;
      return t ? t.value : "";
    }
    set shebang(t) {
      t ? this.path.get("interpreter").replaceWith(mke(t)) : this.path.get("interpreter").remove();
    }
    set(t, r) {
      if (t === "helpersNamespace")
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-\
helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to \
explore using 'helperGenerator' alongside 'file.availableHelper()'.");
      this._map.set(t, r);
    }
    get(t) {
      return this._map.get(t);
    }
    has(t) {
      return this._map.has(t);
    }
    getModuleName() {
      return (0, Hj().getModuleName)(this.opts, this.opts);
    }
    availableHelper(t, r) {
      let s;
      try {
        s = tf().minVersion(t);
      } catch (n) {
        if (n.code !== "BABEL_HELPER_UNKNOWN") throw n;
        return !1;
      }
      return typeof r != "string" ? !0 : (Lh().valid(r) && (r = `^${r}`), !Lh().intersects(`<${s}`, r) && !Lh().intersects(">=8.0.0", r));
    }
    addHelper(t) {
      let r = this.declarations[t];
      if (r) return hke(r);
      let s = this.get("helperGenerator");
      if (s) {
        let c = s(t);
        if (c) return c;
      }
      tf().ensure(t, e);
      let n = this.declarations[t] = this.scope.generateUidIdentifier(t), a = {};
      for (let c of tf().getDependencies(t))
        a[c] = this.addHelper(c);
      let {
        nodes: o,
        globals: l
      } = tf().get(t, (c) => a[c], n, Object.keys(this.scope.getAllBindings()));
      l.forEach((c) => {
        this.path.scope.hasBinding(c, !0) && this.path.scope.rename(c);
      }), o.forEach((c) => {
        c._compact = !0;
      });
      let u = this.path.unshiftContainer("body", o);
      for (let c of u)
        c.isVariableDeclaration() && this.scope.registerDeclaration(c);
      return n;
    }
    buildCodeFrameError(t, r, s = SyntaxError) {
      let n = t?.loc;
      if (!n && t) {
        let a = {
          loc: null
        };
        (0, fT().default)(t, yke, this.scope, a), n = a.loc;
        let o = "This is an error on an internal node. Probably an internal error.";
        n && (o += " Location has been estimated."), r += ` (${o})`;
      }
      if (n) {
        let {
          highlightCode: a = !0
        } = this.opts;
        r += `
` + (0, Vj().codeFrameColumns)(this.code, {
          start: {
            line: n.start.line,
            column: n.start.column + 1
          },
          end: n.end && n.start.line === n.end.line ? {
            line: n.end.line,
            column: n.end.column + 1
          } : void 0
        }, {
          highlightCode: a
        });
      }
      return new s(r);
    }
  };
  Bh.default = rf;
  rf.prototype.addImport = /* @__PURE__ */ i(function() {
    throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-mo\
dule-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
  }, "addImport"), rf.prototype.addTemplateObject = /* @__PURE__ */ i(function() {
    throw new Error("This function has been moved into the template literal transform itself.");
  }, "addTemplateObject");
});

// ../node_modules/@babel/core/lib/tools/build-external-helpers.js
var Qj = y((yT) => {
  "use strict";
  Object.defineProperty(yT, "__esModule", {
    value: !0
  });
  yT.default = Rke;
  function jh() {
    let e = L1();
    return jh = /* @__PURE__ */ i(function() {
      return e;
    }, "helpers"), e;
  }
  i(jh, "helpers");
  function Gj() {
    let e = Nd();
    return Gj = /* @__PURE__ */ i(function() {
      return e;
    }, "_generator"), e;
  }
  i(Gj, "_generator");
  function Kj() {
    let e = Al();
    return Kj = /* @__PURE__ */ i(function() {
      return e;
    }, "_template"), e;
  }
  i(Kj, "_template");
  function Yj() {
    let e = Ne();
    return Yj = /* @__PURE__ */ i(function() {
      return e;
    }, "_t"), e;
  }
  i(Yj, "_t");
  var gke = Mh(), {
    arrayExpression: bke,
    assignmentExpression: Xj,
    binaryExpression: Eke,
    blockStatement: vke,
    callExpression: Ske,
    cloneNode: Tke,
    conditionalExpression: xke,
    exportNamedDeclaration: Pke,
    exportSpecifier: Ake,
    expressionStatement: zj,
    functionExpression: Cke,
    identifier: $r,
    memberExpression: pT,
    objectExpression: dT,
    program: qh,
    stringLiteral: Jj,
    unaryExpression: wke,
    variableDeclaration: hT,
    variableDeclarator: mT
  } = Yj(), Dke = /* @__PURE__ */ i((e) => Kj().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e), "buildUmdWrapper");
  function Ike(e) {
    let t = $r("babelHelpers"), r = [], s = Cke(null, [$r("global")], vke(r)), n = qh([zj(Ske(s, [xke(Eke("===", wke("typeof", $r("global")),
    Jj("undefined")), $r("self"), $r("global"))]))]);
    return r.push(hT("var", [mT(t, Xj("=", pT($r("global"), t), dT([])))])), $h(r, t, e), n;
  }
  i(Ike, "buildGlobal");
  function _ke(e) {
    let t = [], r = $h(t, null, e);
    return t.unshift(Pke(null, Object.keys(r).map((s) => Ake(Tke(r[s]), $r(s))))), qh(t, [], "module");
  }
  i(_ke, "buildModule");
  function Oke(e) {
    let t = $r("babelHelpers"), r = [];
    return r.push(hT("var", [mT(t, $r("global"))])), $h(r, t, e), qh([Dke({
      FACTORY_PARAMETERS: $r("global"),
      BROWSER_ARGUMENTS: Xj("=", pT($r("root"), t), dT([])),
      COMMON_ARGUMENTS: $r("exports"),
      AMD_ARGUMENTS: bke([Jj("exports")]),
      FACTORY_BODY: r,
      UMD_ROOT: $r("this")
    })]);
  }
  i(Oke, "buildUmd");
  function Nke(e) {
    let t = $r("babelHelpers"), r = [];
    r.push(hT("var", [mT(t, dT([]))]));
    let s = qh(r);
    return $h(r, t, e), r.push(zj(t)), s;
  }
  i(Nke, "buildVar");
  function $h(e, t, r) {
    let s = /* @__PURE__ */ i((a) => t ? pT(t, $r(a)) : $r(`_${a}`), "getHelperReference"), n = {};
    return jh().list.forEach(function(a) {
      if (r && r.indexOf(a) < 0) return;
      let o = n[a] = s(a);
      jh().ensure(a, gke.default);
      let {
        nodes: l
      } = jh().get(a, s, o);
      e.push(...l);
    }), n;
  }
  i($h, "buildHelpers");
  function Rke(e, t = "global") {
    let r, s = {
      global: Ike,
      module: _ke,
      umd: Oke,
      var: Nke
    }[t];
    if (s)
      r = s(e);
    else
      throw new Error(`Unsupported output type ${t}`);
    return (0, Gj().default)(r).code;
  }
  i(Rke, "_default");
});

// ../node_modules/gensync/index.js
var As = y((dst, a4) => {
  "use strict";
  var e4 = Symbol.for("gensync:v1:start"), t4 = Symbol.for("gensync:v1:suspend"), kke = "GENSYNC_EXPECTED_START", Fke = "GENSYNC_EXPECTED_SU\
SPEND", r4 = "GENSYNC_OPTIONS_ERROR", Zj = "GENSYNC_RACE_NONEMPTY", Lke = "GENSYNC_ERRBACK_NO_CALLBACK";
  a4.exports = Object.assign(
    /* @__PURE__ */ i(function(t) {
      let r = t;
      return typeof t != "function" ? r = Mke(t) : r = jke(t), Object.assign(r, Bke(r));
    }, "gensync"),
    {
      all: gT({
        name: "all",
        arity: 1,
        sync: /* @__PURE__ */ i(function(e) {
          return Array.from(e[0]).map((r) => bT(r));
        }, "sync"),
        async: /* @__PURE__ */ i(function(e, t, r) {
          let s = Array.from(e[0]);
          if (s.length === 0) {
            Promise.resolve().then(() => t([]));
            return;
          }
          let n = 0, a = s.map(() => {
          });
          s.forEach((o, l) => {
            Uh(
              o,
              (u) => {
                a[l] = u, n += 1, n === a.length && t(a);
              },
              r
            );
          });
        }, "async")
      }),
      race: gT({
        name: "race",
        arity: 1,
        sync: /* @__PURE__ */ i(function(e) {
          let t = Array.from(e[0]);
          if (t.length === 0)
            throw po("Must race at least 1 item", Zj);
          return bT(t[0]);
        }, "sync"),
        async: /* @__PURE__ */ i(function(e, t, r) {
          let s = Array.from(e[0]);
          if (s.length === 0)
            throw po("Must race at least 1 item", Zj);
          for (let n of s)
            Uh(n, t, r);
        }, "async")
      })
    }
  );
  function Bke(e) {
    return {
      sync: /* @__PURE__ */ i(function(...r) {
        return bT(e.apply(this, r));
      }, "sync"),
      async: /* @__PURE__ */ i(function(...r) {
        return new Promise((s, n) => {
          Uh(e.apply(this, r), s, n);
        });
      }, "async"),
      errback: /* @__PURE__ */ i(function(...r) {
        let s = r.pop();
        if (typeof s != "function")
          throw po(
            "Asynchronous function called without callback",
            Lke
          );
        let n;
        try {
          n = e.apply(this, r);
        } catch (a) {
          s(a);
          return;
        }
        Uh(n, (a) => s(void 0, a), (a) => s(a));
      }, "errback")
    };
  }
  i(Bke, "makeFunctionAPI");
  function sf(e, t, r, s) {
    if (typeof r === e || s && typeof r > "u")
      return;
    let n;
    throw s ? n = `Expected opts.${t} to be either a ${e}, or undefined.` : n = `Expected opts.${t} to be a ${e}.`, po(n, r4);
  }
  i(sf, "assertTypeof");
  function po(e, t) {
    return Object.assign(new Error(e), { code: t });
  }
  i(po, "makeError");
  function Mke({ name: e, arity: t, sync: r, async: s, errback: n }) {
    if (sf(
      "string",
      "name",
      e,
      !0
      /* allowUndefined */
    ), sf(
      "number",
      "arity",
      t,
      !0
      /* allowUndefined */
    ), sf("function", "sync", r), sf(
      "function",
      "async",
      s,
      !0
      /* allowUndefined */
    ), sf(
      "function",
      "errback",
      n,
      !0
      /* allowUndefined */
    ), s && n)
      throw po(
        "Expected one of either opts.async or opts.errback, but got _both_.",
        r4
      );
    if (typeof e != "string") {
      let a;
      n && n.name && n.name !== "errback" && (a = n.name), s && s.name && s.name !== "async" && (a = s.name.replace(/Async$/, "")), r && r.name &&
      r.name !== "sync" && (a = r.name.replace(/Sync$/, "")), typeof a == "string" && (e = a);
    }
    return typeof t != "number" && (t = r.length), gT({
      name: e,
      arity: t,
      sync: /* @__PURE__ */ i(function(a) {
        return r.apply(this, a);
      }, "sync"),
      async: /* @__PURE__ */ i(function(a, o, l) {
        s ? s.apply(this, a).then(o, l) : n ? n.call(this, ...a, (u, c) => {
          u == null ? o(c) : l(u);
        }) : o(r.apply(this, a));
      }, "async")
    });
  }
  i(Mke, "newGenerator");
  function jke(e) {
    return i4(e.name, e.length, function(...t) {
      return e.apply(this, t);
    });
  }
  i(jke, "wrapGenerator");
  function gT({ name: e, arity: t, sync: r, async: s }) {
    return i4(e, t, function* (...n) {
      let a = yield e4;
      if (!a)
        return r.call(this, n);
      let o;
      try {
        s.call(
          this,
          n,
          (l) => {
            o || (o = { value: l }, a());
          },
          (l) => {
            o || (o = { err: l }, a());
          }
        );
      } catch (l) {
        o = { err: l }, a();
      }
      if (yield t4, o.hasOwnProperty("err"))
        throw o.err;
      return o.value;
    });
  }
  i(gT, "buildOperation");
  function bT(e) {
    let t;
    for (; !({ value: t } = e.next()).done; )
      s4(t, e);
    return t;
  }
  i(bT, "evaluateSync");
  function Uh(e, t, r) {
    (/* @__PURE__ */ i(function s() {
      try {
        let n;
        for (; !({ value: n } = e.next()).done; ) {
          s4(n, e);
          let a = !0, o = !1, l = e.next(() => {
            a ? o = !0 : s();
          });
          if (a = !1, qke(l, e), !o)
            return;
        }
        return t(n);
      } catch (n) {
        return r(n);
      }
    }, "step"))();
  }
  i(Uh, "evaluateAsync");
  function s4(e, t) {
    e !== e4 && n4(
      t,
      po(
        `Got unexpected yielded value in gensync generator: ${JSON.stringify(
          e
        )}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,
        kke
      )
    );
  }
  i(s4, "assertStart");
  function qke({ value: e, done: t }, r) {
    !t && e === t4 || n4(
      r,
      po(
        t ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(
          e
        )}. If you get this, it is probably a gensync bug.`,
        Fke
      )
    );
  }
  i(qke, "assertSuspend");
  function n4(e, t) {
    throw e.throw && e.throw(t), t;
  }
  i(n4, "throwError");
  function i4(e, t, r) {
    if (typeof e == "string") {
      let s = Object.getOwnPropertyDescriptor(r, "name");
      (!s || s.configurable) && Object.defineProperty(
        r,
        "name",
        Object.assign(s || {}, {
          configurable: !0,
          value: e
        })
      );
    }
    if (typeof t == "number") {
      let s = Object.getOwnPropertyDescriptor(r, "length");
      (!s || s.configurable) && Object.defineProperty(
        r,
        "length",
        Object.assign(s || {}, {
          configurable: !0,
          value: t
        })
      );
    }
    return r;
  }
  i(i4, "setFunctionMetadata");
});

// ../node_modules/@babel/core/lib/gensync-utils/async.js
var Nl = y((yn) => {
  "use strict";
  Object.defineProperty(yn, "__esModule", {
    value: !0
  });
  yn.forwardAsync = Vke;
  yn.isAsync = void 0;
  yn.isThenable = c4;
  yn.maybeAsync = $ke;
  yn.waitFor = yn.onFirstPause = void 0;
  function Ea() {
    let e = As();
    return Ea = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(Ea, "_gensync");
  function o4(e, t, r, s, n, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      r(c);
      return;
    }
    l.done ? t(u) : Promise.resolve(u).then(s, n);
  }
  i(o4, "asyncGeneratorStep");
  function u4(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(s, n) {
        var a = e.apply(t, r);
        function o(u) {
          o4(a, s, n, o, l, "next", u);
        }
        i(o, "_next");
        function l(u) {
          o4(a, s, n, o, l, "throw", u);
        }
        i(l, "_throw"), o(void 0);
      });
    };
  }
  i(u4, "_asyncToGenerator");
  var l4 = Ea()(function* (e) {
    return yield* e;
  }), mst = yn.isAsync = Ea()({
    sync: /* @__PURE__ */ i(() => !1, "sync"),
    errback: /* @__PURE__ */ i((e) => e(null, !0), "errback")
  });
  function $ke(e, t) {
    return Ea()({
      sync(...r) {
        let s = e.apply(this, r);
        if (c4(s)) throw new Error(t);
        return s;
      },
      async(...r) {
        return Promise.resolve(e.apply(this, r));
      }
    });
  }
  i($ke, "maybeAsync");
  var Uke = Ea()({
    sync: /* @__PURE__ */ i((e) => e("sync"), "sync"),
    async: function() {
      var e = u4(function* (t) {
        return t("async");
      });
      return /* @__PURE__ */ i(function(r) {
        return e.apply(this, arguments);
      }, "async");
    }()
  });
  function Vke(e, t) {
    let r = Ea()(e);
    return Uke((s) => {
      let n = r[s];
      return t(n);
    });
  }
  i(Vke, "forwardAsync");
  var yst = yn.onFirstPause = Ea()({
    name: "onFirstPause",
    arity: 2,
    sync: /* @__PURE__ */ i(function(e) {
      return l4.sync(e);
    }, "sync"),
    errback: /* @__PURE__ */ i(function(e, t, r) {
      let s = !1;
      l4.errback(e, (n, a) => {
        s = !0, r(n, a);
      }), s || t();
    }, "errback")
  }), gst = yn.waitFor = Ea()({
    sync: /* @__PURE__ */ i((e) => e, "sync"),
    async: function() {
      var e = u4(function* (t) {
        return t;
      });
      return /* @__PURE__ */ i(function(r) {
        return e.apply(this, arguments);
      }, "async");
    }()
  });
  function c4(e) {
    return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
  }
  i(c4, "isThenable");
});

// ../node_modules/@babel/core/lib/config/util.js
var Wh = y((Vh) => {
  "use strict";
  Object.defineProperty(Vh, "__esModule", {
    value: !0
  });
  Vh.isIterableIterator = Gke;
  Vh.mergeOptions = Wke;
  function Wke(e, t) {
    for (let r of Object.keys(t))
      if ((r === "parserOpts" || r === "generatorOpts" || r === "assumptions") && t[r]) {
        let s = t[r], n = e[r] || (e[r] = {});
        Hke(n, s);
      } else {
        let s = t[r];
        s !== void 0 && (e[r] = s);
      }
  }
  i(Wke, "mergeOptions");
  function Hke(e, t) {
    for (let r of Object.keys(t)) {
      let s = t[r];
      s !== void 0 && (e[r] = s);
    }
  }
  i(Hke, "mergeDefaultFields");
  function Gke(e) {
    return !!e && typeof e.next == "function" && typeof e[Symbol.iterator] == "function";
  }
  i(Gke, "isIterableIterator");
});

// ../node_modules/@babel/core/lib/config/caching.js
var mo = y((ho) => {
  "use strict";
  Object.defineProperty(ho, "__esModule", {
    value: !0
  });
  ho.assertSimpleType = Hh;
  ho.makeStrongCache = m4;
  ho.makeStrongCacheSync = zke;
  ho.makeWeakCache = h4;
  ho.makeWeakCacheSync = Xke;
  function p4() {
    let e = As();
    return p4 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(p4, "_gensync");
  var Rl = Nl(), Kke = Wh(), d4 = /* @__PURE__ */ i((e) => p4()(e).sync, "synchronize");
  function* Yke() {
    return !0;
  }
  i(Yke, "genTrue");
  function h4(e) {
    return y4(WeakMap, e);
  }
  i(h4, "makeWeakCache");
  function Xke(e) {
    return d4(h4(e));
  }
  i(Xke, "makeWeakCacheSync");
  function m4(e) {
    return y4(Map, e);
  }
  i(m4, "makeStrongCache");
  function zke(e) {
    return d4(m4(e));
  }
  i(zke, "makeStrongCacheSync");
  function y4(e, t) {
    let r = new e(), s = new e(), n = new e();
    return /* @__PURE__ */ i(function* (o, l) {
      let u = yield* (0, Rl.isAsync)(), c = u ? s : r, f = yield* Jke(u, c, n, o, l);
      if (f.valid) return f.value;
      let p = new ET(l), d = t(o, p), m, b;
      return (0, Kke.isIterableIterator)(d) ? b = yield* (0, Rl.onFirstPause)(d, () => {
        m = Qke(p, n, o);
      }) : b = d, g4(c, p, o, b), m && (n.delete(o), m.release(b)), b;
    }, "cachedFunction");
  }
  i(y4, "makeCachedFunction");
  function* f4(e, t, r) {
    let s = e.get(t);
    if (s) {
      for (let {
        value: n,
        valid: a
      } of s)
        if (yield* a(r)) return {
          valid: !0,
          value: n
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  i(f4, "getCachedValue");
  function* Jke(e, t, r, s, n) {
    let a = yield* f4(t, s, n);
    if (a.valid)
      return a;
    if (e) {
      let o = yield* f4(r, s, n);
      if (o.valid)
        return {
          valid: !0,
          value: yield* (0, Rl.waitFor)(o.value.promise)
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  i(Jke, "getCachedValueOrWait");
  function Qke(e, t, r) {
    let s = new vT();
    return g4(t, e, r, s), s;
  }
  i(Qke, "setupAsyncLocks");
  function g4(e, t, r, s) {
    t.configured() || t.forever();
    let n = e.get(r);
    switch (t.deactivate(), t.mode()) {
      case "forever":
        n = [{
          value: s,
          valid: Yke
        }], e.set(r, n);
        break;
      case "invalidate":
        n = [{
          value: s,
          valid: t.validator()
        }], e.set(r, n);
        break;
      case "valid":
        n ? n.push({
          value: s,
          valid: t.validator()
        }) : (n = [{
          value: s,
          valid: t.validator()
        }], e.set(r, n));
    }
  }
  i(g4, "updateFunctionCache");
  var ET = class {
    static {
      i(this, "CacheConfigurator");
    }
    constructor(t) {
      this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0,
      this._data = t;
    }
    simple() {
      return Zke(this);
    }
    mode() {
      return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
    }
    forever() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never)
        throw new Error("Caching has already been configured with .never()");
      this._forever = !0, this._configured = !0;
    }
    never() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._forever)
        throw new Error("Caching has already been configured with .forever()");
      this._never = !0, this._configured = !0;
    }
    using(t) {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never || this._forever)
        throw new Error("Caching has already been configured with .never or .forever()");
      this._configured = !0;
      let r = t(this._data), s = (0, Rl.maybeAsync)(t, "You appear to be using an async cache handler, but Babel has been called synchronous\
ly");
      return (0, Rl.isThenable)(r) ? r.then((n) => (this._pairs.push([n, s]), n)) : (this._pairs.push([r, s]), r);
    }
    invalidate(t) {
      return this._invalidate = !0, this.using(t);
    }
    validator() {
      let t = this._pairs;
      return function* (r) {
        for (let [s, n] of t)
          if (s !== (yield* n(r))) return !1;
        return !0;
      };
    }
    deactivate() {
      this._active = !1;
    }
    configured() {
      return this._configured;
    }
  };
  function Zke(e) {
    function t(r) {
      if (typeof r == "boolean") {
        r ? e.forever() : e.never();
        return;
      }
      return e.using(() => Hh(r()));
    }
    return i(t, "cacheFn"), t.forever = () => e.forever(), t.never = () => e.never(), t.using = (r) => e.using(() => Hh(r())), t.invalidate =
    (r) => e.invalidate(() => Hh(r())), t;
  }
  i(Zke, "makeSimpleConfigurator");
  function Hh(e) {
    if ((0, Rl.isThenable)(e))
      throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add suppo\
rt for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchron\
ously handle your caching logic.");
    if (e != null && typeof e != "string" && typeof e != "boolean" && typeof e != "number")
      throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    return e;
  }
  i(Hh, "assertSimpleType");
  var vT = class {
    static {
      i(this, "Lock");
    }
    constructor() {
      this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((t) => {
        this._resolve = t;
      });
    }
    release(t) {
      this.released = !0, this._resolve(t);
    }
  };
});

// ../node_modules/@babel/core/lib/gensync-utils/fs.js
var Gh = y((kl) => {
  "use strict";
  Object.defineProperty(kl, "__esModule", {
    value: !0
  });
  kl.stat = kl.readFile = void 0;
  function nf() {
    let e = require("fs");
    return nf = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(nf, "_fs");
  function ST() {
    let e = As();
    return ST = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(ST, "_gensync");
  var Pst = kl.readFile = ST()({
    sync: nf().readFileSync,
    errback: nf().readFile
  }), Ast = kl.stat = ST()({
    sync: nf().statSync,
    errback: nf().stat
  });
});

// ../node_modules/@babel/core/lib/config/files/utils.js
var PT = y((xT) => {
  "use strict";
  Object.defineProperty(xT, "__esModule", {
    value: !0
  });
  xT.makeStaticFileCache = rFe;
  var eFe = mo(), tFe = Gh();
  function TT() {
    let e = require("fs");
    return TT = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs2"), e;
  }
  i(TT, "_fs2");
  function rFe(e) {
    return (0, eFe.makeStrongCache)(function* (t, r) {
      return r.invalidate(() => sFe(t)) === null ? null : e(t, yield* tFe.readFile(t, "utf8"));
    });
  }
  i(rFe, "makeStaticFileCache");
  function sFe(e) {
    if (!TT().existsSync(e)) return null;
    try {
      return +TT().statSync(e).mtime;
    } catch (t) {
      if (t.code !== "ENOENT" && t.code !== "ENOTDIR") throw t;
    }
    return null;
  }
  i(sFe, "fileMtime");
});

// ../node_modules/@babel/core/lib/errors/rewrite-stack-trace.js
var xi = y((Fl) => {
  "use strict";
  Object.defineProperty(Fl, "__esModule", {
    value: !0
  });
  Fl.beginHiddenCallStack = oFe;
  Fl.endHiddenCallStack = lFe;
  Fl.expectedError = aFe;
  Fl.injectVirtualStackFrame = iFe;
  var b4, E4 = Function.call.bind(Error.prototype.toString), Yh = !!Error.captureStackTrace && ((b4 = Object.getOwnPropertyDescriptor(Error,
  "stackTraceLimit")) == null ? void 0 : b4.writable) === !0, v4 = "startHiding - secret - don't use this - v1", S4 = "stopHiding - secret -\
 don't use this - v1", T4 = /* @__PURE__ */ new WeakSet(), Kh = /* @__PURE__ */ new WeakMap();
  function nFe(e) {
    return /* @__PURE__ */ Object.create({
      isNative: /* @__PURE__ */ i(() => !1, "isNative"),
      isConstructor: /* @__PURE__ */ i(() => !1, "isConstructor"),
      isToplevel: /* @__PURE__ */ i(() => !0, "isToplevel"),
      getFileName: /* @__PURE__ */ i(() => e, "getFileName"),
      getLineNumber: /* @__PURE__ */ i(() => {
      }, "getLineNumber"),
      getColumnNumber: /* @__PURE__ */ i(() => {
      }, "getColumnNumber"),
      getFunctionName: /* @__PURE__ */ i(() => {
      }, "getFunctionName"),
      getMethodName: /* @__PURE__ */ i(() => {
      }, "getMethodName"),
      getTypeName: /* @__PURE__ */ i(() => {
      }, "getTypeName"),
      toString: /* @__PURE__ */ i(() => e, "toString")
    });
  }
  i(nFe, "CallSite");
  function iFe(e, t) {
    if (!Yh) return;
    let r = Kh.get(e);
    return r || Kh.set(e, r = []), r.push(nFe(t)), e;
  }
  i(iFe, "injectVirtualStackFrame");
  function aFe(e) {
    if (Yh)
      return T4.add(e), e;
  }
  i(aFe, "expectedError");
  function oFe(e) {
    return Yh ? Object.defineProperty(function(...t) {
      return x4(), e(...t);
    }, "name", {
      value: S4
    }) : e;
  }
  i(oFe, "beginHiddenCallStack");
  function lFe(e) {
    return Yh ? Object.defineProperty(function(...t) {
      return e(...t);
    }, "name", {
      value: v4
    }) : e;
  }
  i(lFe, "endHiddenCallStack");
  function x4() {
    x4 = /* @__PURE__ */ i(() => {
    }, "setupPrepareStackTrace");
    let {
      prepareStackTrace: e = uFe
    } = Error, t = 50;
    Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, t)), Error.prepareStackTrace = /* @__PURE__ */ i(function(s, n) {
      let a = [], l = T4.has(s) ? "hiding" : "unknown";
      for (let u = 0; u < n.length; u++) {
        let c = n[u].getFunctionName();
        if (c === v4)
          l = "hiding";
        else if (c === S4) {
          if (l === "hiding")
            l = "showing", Kh.has(s) && a.unshift(...Kh.get(s));
          else if (l === "unknown") {
            a = n;
            break;
          }
        } else l !== "hiding" && a.push(n[u]);
      }
      return e(s, a);
    }, "stackTraceRewriter");
  }
  i(x4, "setupPrepareStackTrace");
  function uFe(e, t) {
    return t.length === 0 ? E4(e) : `${E4(e)}
    at ${t.join(`
    at `)}`;
  }
  i(uFe, "defaultPrepareStackTrace");
});

// ../node_modules/@babel/core/lib/errors/config-error.js
var yo = y((Xh) => {
  "use strict";
  Object.defineProperty(Xh, "__esModule", {
    value: !0
  });
  Xh.default = void 0;
  var P4 = xi(), AT = class extends Error {
    static {
      i(this, "ConfigError");
    }
    constructor(t, r) {
      super(t), (0, P4.expectedError)(this), r && (0, P4.injectVirtualStackFrame)(this, r);
    }
  };
  Xh.default = AT;
});

// ../node_modules/@babel/core/lib/config/files/package.js
var A4 = y((wT) => {
  "use strict";
  Object.defineProperty(wT, "__esModule", {
    value: !0
  });
  wT.findPackageData = dFe;
  function Ll() {
    let e = require("path");
    return Ll = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(Ll, "_path");
  var cFe = PT(), CT = yo(), fFe = "package.json", pFe = (0, cFe.makeStaticFileCache)((e, t) => {
    let r;
    try {
      r = JSON.parse(t);
    } catch (s) {
      throw new CT.default(`Error while parsing JSON - ${s.message}`, e);
    }
    if (!r) throw new Error(`${e}: No config detected`);
    if (typeof r != "object")
      throw new CT.default(`Config returned typeof ${typeof r}`, e);
    if (Array.isArray(r))
      throw new CT.default("Expected config object but found array", e);
    return {
      filepath: e,
      dirname: Ll().dirname(e),
      options: r
    };
  });
  function* dFe(e) {
    let t = null, r = [], s = !0, n = Ll().dirname(e);
    for (; !t && Ll().basename(n) !== "node_modules"; ) {
      r.push(n), t = yield* pFe(Ll().join(n, fFe));
      let a = Ll().dirname(n);
      if (n === a) {
        s = !1;
        break;
      }
      n = a;
    }
    return {
      filepath: e,
      directories: r,
      pkg: t,
      isPackage: s
    };
  }
  i(dFe, "findPackageData");
});

// ../node_modules/json5/lib/unicode.js
var C4 = y((Lst, zh) => {
  zh.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  zh.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  zh.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});

// ../node_modules/json5/lib/util.js
var IT = y((Bst, w4) => {
  var DT = C4();
  w4.exports = {
    isSpaceSeparator(e) {
      return typeof e == "string" && DT.Space_Separator.test(e);
    },
    isIdStartChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e === "$" || e === "_" || DT.ID_Start.test(e));
    },
    isIdContinueChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <= "9" || e === "$" || e === "_" || e ===
      "\u200C" || e === "\u200D" || DT.ID_Continue.test(e));
    },
    isDigit(e) {
      return typeof e == "string" && /[0-9]/.test(e);
    },
    isHexDigit(e) {
      return typeof e == "string" && /[0-9A-Fa-f]/.test(e);
    }
  };
});

// ../node_modules/json5/lib/parse.js
var N4 = y((Mst, O4) => {
  var wr = IT(), OT, fs, Ai, Qh, va, gn, Dr, kT, of;
  O4.exports = /* @__PURE__ */ i(function(t, r) {
    OT = String(t), fs = "start", Ai = [], Qh = 0, va = 1, gn = 0, Dr = void 0, kT = void 0, of = void 0;
    do
      Dr = hFe(), gFe[fs]();
    while (Dr.type !== "eof");
    return typeof r == "function" ? NT({ "": of }, "", r) : of;
  }, "parse");
  function NT(e, t, r) {
    let s = e[t];
    if (s != null && typeof s == "object")
      if (Array.isArray(s))
        for (let n = 0; n < s.length; n++) {
          let a = String(n), o = NT(s, a, r);
          o === void 0 ? delete s[a] : Object.defineProperty(s, a, {
            value: o,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
      else
        for (let n in s) {
          let a = NT(s, n, r);
          a === void 0 ? delete s[n] : Object.defineProperty(s, n, {
            value: a,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
    return r.call(e, t, s);
  }
  i(NT, "internalize");
  var Je, Ke, af, Pi, ct;
  function hFe() {
    for (Je = "default", Ke = "", af = !1, Pi = 1; ; ) {
      ct = Ci();
      let e = I4[Je]();
      if (e)
        return e;
    }
  }
  i(hFe, "lex");
  function Ci() {
    if (OT[Qh])
      return String.fromCodePoint(OT.codePointAt(Qh));
  }
  i(Ci, "peek");
  function Q() {
    let e = Ci();
    return e === `
` ? (va++, gn = 0) : e ? gn += e.length : gn++, e && (Qh += e.length), e;
  }
  i(Q, "read");
  var I4 = {
    default() {
      switch (ct) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          Q();
          return;
        case "/":
          Q(), Je = "comment";
          return;
        case void 0:
          return Q(), Gt("eof");
      }
      if (wr.isSpaceSeparator(ct)) {
        Q();
        return;
      }
      return I4[fs]();
    },
    comment() {
      switch (ct) {
        case "*":
          Q(), Je = "multiLineComment";
          return;
        case "/":
          Q(), Je = "singleLineComment";
          return;
      }
      throw Kt(Q());
    },
    multiLineComment() {
      switch (ct) {
        case "*":
          Q(), Je = "multiLineCommentAsterisk";
          return;
        case void 0:
          throw Kt(Q());
      }
      Q();
    },
    multiLineCommentAsterisk() {
      switch (ct) {
        case "*":
          Q();
          return;
        case "/":
          Q(), Je = "default";
          return;
        case void 0:
          throw Kt(Q());
      }
      Q(), Je = "multiLineComment";
    },
    singleLineComment() {
      switch (ct) {
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          Q(), Je = "default";
          return;
        case void 0:
          return Q(), Gt("eof");
      }
      Q();
    },
    value() {
      switch (ct) {
        case "{":
        case "[":
          return Gt("punctuator", Q());
        case "n":
          return Q(), go("ull"), Gt("null", null);
        case "t":
          return Q(), go("rue"), Gt("boolean", !0);
        case "f":
          return Q(), go("alse"), Gt("boolean", !1);
        case "-":
        case "+":
          Q() === "-" && (Pi = -1), Je = "sign";
          return;
        case ".":
          Ke = Q(), Je = "decimalPointLeading";
          return;
        case "0":
          Ke = Q(), Je = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          Ke = Q(), Je = "decimalInteger";
          return;
        case "I":
          return Q(), go("nfinity"), Gt("numeric", 1 / 0);
        case "N":
          return Q(), go("aN"), Gt("numeric", NaN);
        case '"':
        case "'":
          af = Q() === '"', Ke = "", Je = "string";
          return;
      }
      throw Kt(Q());
    },
    identifierNameStartEscape() {
      if (ct !== "u")
        throw Kt(Q());
      Q();
      let e = RT();
      switch (e) {
        case "$":
        case "_":
          break;
        default:
          if (!wr.isIdStartChar(e))
            throw D4();
          break;
      }
      Ke += e, Je = "identifierName";
    },
    identifierName() {
      switch (ct) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          Ke += Q();
          return;
        case "\\":
          Q(), Je = "identifierNameEscape";
          return;
      }
      if (wr.isIdContinueChar(ct)) {
        Ke += Q();
        return;
      }
      return Gt("identifier", Ke);
    },
    identifierNameEscape() {
      if (ct !== "u")
        throw Kt(Q());
      Q();
      let e = RT();
      switch (e) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!wr.isIdContinueChar(e))
            throw D4();
          break;
      }
      Ke += e, Je = "identifierName";
    },
    sign() {
      switch (ct) {
        case ".":
          Ke = Q(), Je = "decimalPointLeading";
          return;
        case "0":
          Ke = Q(), Je = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          Ke = Q(), Je = "decimalInteger";
          return;
        case "I":
          return Q(), go("nfinity"), Gt("numeric", Pi * (1 / 0));
        case "N":
          return Q(), go("aN"), Gt("numeric", NaN);
      }
      throw Kt(Q());
    },
    zero() {
      switch (ct) {
        case ".":
          Ke += Q(), Je = "decimalPoint";
          return;
        case "e":
        case "E":
          Ke += Q(), Je = "decimalExponent";
          return;
        case "x":
        case "X":
          Ke += Q(), Je = "hexadecimal";
          return;
      }
      return Gt("numeric", Pi * 0);
    },
    decimalInteger() {
      switch (ct) {
        case ".":
          Ke += Q(), Je = "decimalPoint";
          return;
        case "e":
        case "E":
          Ke += Q(), Je = "decimalExponent";
          return;
      }
      if (wr.isDigit(ct)) {
        Ke += Q();
        return;
      }
      return Gt("numeric", Pi * Number(Ke));
    },
    decimalPointLeading() {
      if (wr.isDigit(ct)) {
        Ke += Q(), Je = "decimalFraction";
        return;
      }
      throw Kt(Q());
    },
    decimalPoint() {
      switch (ct) {
        case "e":
        case "E":
          Ke += Q(), Je = "decimalExponent";
          return;
      }
      if (wr.isDigit(ct)) {
        Ke += Q(), Je = "decimalFraction";
        return;
      }
      return Gt("numeric", Pi * Number(Ke));
    },
    decimalFraction() {
      switch (ct) {
        case "e":
        case "E":
          Ke += Q(), Je = "decimalExponent";
          return;
      }
      if (wr.isDigit(ct)) {
        Ke += Q();
        return;
      }
      return Gt("numeric", Pi * Number(Ke));
    },
    decimalExponent() {
      switch (ct) {
        case "+":
        case "-":
          Ke += Q(), Je = "decimalExponentSign";
          return;
      }
      if (wr.isDigit(ct)) {
        Ke += Q(), Je = "decimalExponentInteger";
        return;
      }
      throw Kt(Q());
    },
    decimalExponentSign() {
      if (wr.isDigit(ct)) {
        Ke += Q(), Je = "decimalExponentInteger";
        return;
      }
      throw Kt(Q());
    },
    decimalExponentInteger() {
      if (wr.isDigit(ct)) {
        Ke += Q();
        return;
      }
      return Gt("numeric", Pi * Number(Ke));
    },
    hexadecimal() {
      if (wr.isHexDigit(ct)) {
        Ke += Q(), Je = "hexadecimalInteger";
        return;
      }
      throw Kt(Q());
    },
    hexadecimalInteger() {
      if (wr.isHexDigit(ct)) {
        Ke += Q();
        return;
      }
      return Gt("numeric", Pi * Number(Ke));
    },
    string() {
      switch (ct) {
        case "\\":
          Q(), Ke += mFe();
          return;
        case '"':
          if (af)
            return Q(), Gt("string", Ke);
          Ke += Q();
          return;
        case "'":
          if (!af)
            return Q(), Gt("string", Ke);
          Ke += Q();
          return;
        case `
`:
        case "\r":
          throw Kt(Q());
        case "\u2028":
        case "\u2029":
          bFe(ct);
          break;
        case void 0:
          throw Kt(Q());
      }
      Ke += Q();
    },
    start() {
      switch (ct) {
        case "{":
        case "[":
          return Gt("punctuator", Q());
      }
      Je = "value";
    },
    beforePropertyName() {
      switch (ct) {
        case "$":
        case "_":
          Ke = Q(), Je = "identifierName";
          return;
        case "\\":
          Q(), Je = "identifierNameStartEscape";
          return;
        case "}":
          return Gt("punctuator", Q());
        case '"':
        case "'":
          af = Q() === '"', Je = "string";
          return;
      }
      if (wr.isIdStartChar(ct)) {
        Ke += Q(), Je = "identifierName";
        return;
      }
      throw Kt(Q());
    },
    afterPropertyName() {
      if (ct === ":")
        return Gt("punctuator", Q());
      throw Kt(Q());
    },
    beforePropertyValue() {
      Je = "value";
    },
    afterPropertyValue() {
      switch (ct) {
        case ",":
        case "}":
          return Gt("punctuator", Q());
      }
      throw Kt(Q());
    },
    beforeArrayValue() {
      if (ct === "]")
        return Gt("punctuator", Q());
      Je = "value";
    },
    afterArrayValue() {
      switch (ct) {
        case ",":
        case "]":
          return Gt("punctuator", Q());
      }
      throw Kt(Q());
    },
    end() {
      throw Kt(Q());
    }
  };
  function Gt(e, t) {
    return {
      type: e,
      value: t,
      line: va,
      column: gn
    };
  }
  i(Gt, "newToken");
  function go(e) {
    for (let t of e) {
      if (Ci() !== t)
        throw Kt(Q());
      Q();
    }
  }
  i(go, "literal");
  function mFe() {
    switch (Ci()) {
      case "b":
        return Q(), "\b";
      case "f":
        return Q(), "\f";
      case "n":
        return Q(), `
`;
      case "r":
        return Q(), "\r";
      case "t":
        return Q(), "	";
      case "v":
        return Q(), "\v";
      case "0":
        if (Q(), wr.isDigit(Ci()))
          throw Kt(Q());
        return "\0";
      case "x":
        return Q(), yFe();
      case "u":
        return Q(), RT();
      case `
`:
      case "\u2028":
      case "\u2029":
        return Q(), "";
      case "\r":
        return Q(), Ci() === `
` && Q(), "";
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw Kt(Q());
      case void 0:
        throw Kt(Q());
    }
    return Q();
  }
  i(mFe, "escape");
  function yFe() {
    let e = "", t = Ci();
    if (!wr.isHexDigit(t) || (e += Q(), t = Ci(), !wr.isHexDigit(t)))
      throw Kt(Q());
    return e += Q(), String.fromCodePoint(parseInt(e, 16));
  }
  i(yFe, "hexEscape");
  function RT() {
    let e = "", t = 4;
    for (; t-- > 0; ) {
      let r = Ci();
      if (!wr.isHexDigit(r))
        throw Kt(Q());
      e += Q();
    }
    return String.fromCodePoint(parseInt(e, 16));
  }
  i(RT, "unicodeEscape");
  var gFe = {
    start() {
      if (Dr.type === "eof")
        throw bo();
      _T();
    },
    beforePropertyName() {
      switch (Dr.type) {
        case "identifier":
        case "string":
          kT = Dr.value, fs = "afterPropertyName";
          return;
        case "punctuator":
          Jh();
          return;
        case "eof":
          throw bo();
      }
    },
    afterPropertyName() {
      if (Dr.type === "eof")
        throw bo();
      fs = "beforePropertyValue";
    },
    beforePropertyValue() {
      if (Dr.type === "eof")
        throw bo();
      _T();
    },
    beforeArrayValue() {
      if (Dr.type === "eof")
        throw bo();
      if (Dr.type === "punctuator" && Dr.value === "]") {
        Jh();
        return;
      }
      _T();
    },
    afterPropertyValue() {
      if (Dr.type === "eof")
        throw bo();
      switch (Dr.value) {
        case ",":
          fs = "beforePropertyName";
          return;
        case "}":
          Jh();
      }
    },
    afterArrayValue() {
      if (Dr.type === "eof")
        throw bo();
      switch (Dr.value) {
        case ",":
          fs = "beforeArrayValue";
          return;
        case "]":
          Jh();
      }
    },
    end() {
    }
  };
  function _T() {
    let e;
    switch (Dr.type) {
      case "punctuator":
        switch (Dr.value) {
          case "{":
            e = {};
            break;
          case "[":
            e = [];
            break;
        }
        break;
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        e = Dr.value;
        break;
    }
    if (of === void 0)
      of = e;
    else {
      let t = Ai[Ai.length - 1];
      Array.isArray(t) ? t.push(e) : Object.defineProperty(t, kT, {
        value: e,
        writable: !0,
        enumerable: !0,
        configurable: !0
      });
    }
    if (e !== null && typeof e == "object")
      Ai.push(e), Array.isArray(e) ? fs = "beforeArrayValue" : fs = "beforePropertyName";
    else {
      let t = Ai[Ai.length - 1];
      t == null ? fs = "end" : Array.isArray(t) ? fs = "afterArrayValue" : fs = "afterPropertyValue";
    }
  }
  i(_T, "push");
  function Jh() {
    Ai.pop();
    let e = Ai[Ai.length - 1];
    e == null ? fs = "end" : Array.isArray(e) ? fs = "afterArrayValue" : fs = "afterPropertyValue";
  }
  i(Jh, "pop");
  function Kt(e) {
    return Zh(e === void 0 ? `JSON5: invalid end of input at ${va}:${gn}` : `JSON5: invalid character '${_4(e)}' at ${va}:${gn}`);
  }
  i(Kt, "invalidChar");
  function bo() {
    return Zh(`JSON5: invalid end of input at ${va}:${gn}`);
  }
  i(bo, "invalidEOF");
  function D4() {
    return gn -= 5, Zh(`JSON5: invalid identifier character at ${va}:${gn}`);
  }
  i(D4, "invalidIdentifier");
  function bFe(e) {
    console.warn(`JSON5: '${_4(e)}' in strings is not valid ECMAScript; consider escaping`);
  }
  i(bFe, "separatorChar");
  function _4(e) {
    let t = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    if (t[e])
      return t[e];
    if (e < " ") {
      let r = e.charCodeAt(0).toString(16);
      return "\\x" + ("00" + r).substring(r.length);
    }
    return e;
  }
  i(_4, "formatChar");
  function Zh(e) {
    let t = new SyntaxError(e);
    return t.lineNumber = va, t.columnNumber = gn, t;
  }
  i(Zh, "syntaxError");
});

// ../node_modules/json5/lib/stringify.js
var k4 = y((qst, R4) => {
  var FT = IT();
  R4.exports = /* @__PURE__ */ i(function(t, r, s) {
    let n = [], a = "", o, l, u = "", c;
    if (r != null && typeof r == "object" && !Array.isArray(r) && (s = r.space, c = r.quote, r = r.replacer), typeof r == "function")
      l = r;
    else if (Array.isArray(r)) {
      o = [];
      for (let h of r) {
        let g;
        typeof h == "string" ? g = h : (typeof h == "number" || h instanceof String || h instanceof Number) && (g = String(h)), g !== void 0 &&
        o.indexOf(g) < 0 && o.push(g);
      }
    }
    return s instanceof Number ? s = Number(s) : s instanceof String && (s = String(s)), typeof s == "number" ? s > 0 && (s = Math.min(10, Math.
    floor(s)), u = "          ".substr(0, s)) : typeof s == "string" && (u = s.substr(0, 10)), f("", { "": t });
    function f(h, g) {
      let E = g[h];
      switch (E != null && (typeof E.toJSON5 == "function" ? E = E.toJSON5(h) : typeof E.toJSON == "function" && (E = E.toJSON(h))), l && (E =
      l.call(g, h, E)), E instanceof Number ? E = Number(E) : E instanceof String ? E = String(E) : E instanceof Boolean && (E = E.valueOf()),
      E) {
        case null:
          return "null";
        case !0:
          return "true";
        case !1:
          return "false";
      }
      if (typeof E == "string")
        return p(E, !1);
      if (typeof E == "number")
        return String(E);
      if (typeof E == "object")
        return Array.isArray(E) ? b(E) : d(E);
    }
    i(f, "serializeProperty");
    function p(h) {
      let g = {
        "'": 0.1,
        '"': 0.2
      }, E = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      }, D = "";
      for (let N = 0; N < h.length; N++) {
        let I = h[N];
        switch (I) {
          case "'":
          case '"':
            g[I]++, D += I;
            continue;
          case "\0":
            if (FT.isDigit(h[N + 1])) {
              D += "\\x00";
              continue;
            }
        }
        if (E[I]) {
          D += E[I];
          continue;
        }
        if (I < " ") {
          let M = I.charCodeAt(0).toString(16);
          D += "\\x" + ("00" + M).substring(M.length);
          continue;
        }
        D += I;
      }
      let C = c || Object.keys(g).reduce((N, I) => g[N] < g[I] ? N : I);
      return D = D.replace(new RegExp(C, "g"), E[C]), C + D + C;
    }
    i(p, "quoteString");
    function d(h) {
      if (n.indexOf(h) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      n.push(h);
      let g = a;
      a = a + u;
      let E = o || Object.keys(h), D = [];
      for (let N of E) {
        let I = f(N, h);
        if (I !== void 0) {
          let M = m(N) + ":";
          u !== "" && (M += " "), M += I, D.push(M);
        }
      }
      let C;
      if (D.length === 0)
        C = "{}";
      else {
        let N;
        if (u === "")
          N = D.join(","), C = "{" + N + "}";
        else {
          let I = `,
` + a;
          N = D.join(I), C = `{
` + a + N + `,
` + g + "}";
        }
      }
      return n.pop(), a = g, C;
    }
    i(d, "serializeObject");
    function m(h) {
      if (h.length === 0)
        return p(h, !0);
      let g = String.fromCodePoint(h.codePointAt(0));
      if (!FT.isIdStartChar(g))
        return p(h, !0);
      for (let E = g.length; E < h.length; E++)
        if (!FT.isIdContinueChar(String.fromCodePoint(h.codePointAt(E))))
          return p(h, !0);
      return h;
    }
    i(m, "serializeKey");
    function b(h) {
      if (n.indexOf(h) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      n.push(h);
      let g = a;
      a = a + u;
      let E = [];
      for (let C = 0; C < h.length; C++) {
        let N = f(String(C), h);
        E.push(N !== void 0 ? N : "null");
      }
      let D;
      if (E.length === 0)
        D = "[]";
      else if (u === "")
        D = "[" + E.join(",") + "]";
      else {
        let C = `,
` + a, N = E.join(C);
        D = `[
` + a + N + `,
` + g + "]";
      }
      return n.pop(), a = g, D;
    }
    i(b, "serializeArray");
  }, "stringify");
});

// ../node_modules/json5/lib/index.js
var L4 = y((Ust, F4) => {
  var EFe = N4(), vFe = k4(), SFe = {
    parse: EFe,
    stringify: vFe
  };
  F4.exports = SFe;
});

// ../node_modules/@babel/core/lib/config/helpers/config-api.js
var LT = y((lf) => {
  "use strict";
  Object.defineProperty(lf, "__esModule", {
    value: !0
  });
  lf.makeConfigAPI = j4;
  lf.makePluginAPI = TFe;
  lf.makePresetAPI = q4;
  function M4() {
    let e = Fh();
    return M4 = /* @__PURE__ */ i(function() {
      return e;
    }, "_semver"), e;
  }
  i(M4, "_semver");
  var em = mr(), B4 = mo();
  function j4(e) {
    let t = /* @__PURE__ */ i((s) => e.using((n) => typeof s > "u" ? n.envName : typeof s == "function" ? (0, B4.assertSimpleType)(s(n.envName)) :
    (Array.isArray(s) ? s : [s]).some((a) => {
      if (typeof a != "string")
        throw new Error("Unexpected non-string value");
      return a === n.envName;
    })), "env"), r = /* @__PURE__ */ i((s) => e.using((n) => (0, B4.assertSimpleType)(s(n.caller))), "caller");
    return {
      version: em.version,
      cache: e.simple(),
      env: t,
      async: /* @__PURE__ */ i(() => !1, "async"),
      caller: r,
      assertVersion: xFe
    };
  }
  i(j4, "makeConfigAPI");
  function q4(e, t) {
    let r = /* @__PURE__ */ i(() => JSON.parse(e.using((n) => JSON.stringify(n.targets))), "targets"), s = /* @__PURE__ */ i((n) => {
      t.push(n);
    }, "addExternalDependency");
    return Object.assign({}, j4(e), {
      targets: r,
      addExternalDependency: s
    });
  }
  i(q4, "makePresetAPI");
  function TFe(e, t) {
    let r = /* @__PURE__ */ i((s) => e.using((n) => n.assumptions[s]), "assumption");
    return Object.assign({}, q4(e, t), {
      assumption: r
    });
  }
  i(TFe, "makePluginAPI");
  function xFe(e) {
    if (typeof e == "number") {
      if (!Number.isInteger(e))
        throw new Error("Expected string or integer value.");
      e = `^${e}.0.0-0`;
    }
    if (typeof e != "string")
      throw new Error("Expected string or integer value.");
    if (e === "*" || M4().satisfies(em.version, e)) return;
    let t = Error.stackTraceLimit;
    typeof t == "number" && t < 25 && (Error.stackTraceLimit = 25);
    let r = new Error(`Requires Babel "${e}", but was loaded with "${em.version}". If you are sure you have a compatible version of @babel/c\
ore, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the f\
irst entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    throw typeof t == "number" && (Error.stackTraceLimit = t), Object.assign(r, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: em.version,
      range: e
    });
  }
  i(xFe, "assertVersion");
});

// ../node_modules/@babel/core/lib/config/helpers/deep-array.js
var rm = y((tm) => {
  "use strict";
  Object.defineProperty(tm, "__esModule", {
    value: !0
  });
  tm.finalize = PFe;
  tm.flattenToSet = AFe;
  function PFe(e) {
    return Object.freeze(e);
  }
  i(PFe, "finalize");
  function AFe(e) {
    let t = /* @__PURE__ */ new Set(), r = [e];
    for (; r.length > 0; )
      for (let s of r.pop())
        Array.isArray(s) ? r.push(s) : t.add(s);
    return t;
  }
  i(AFe, "flattenToSet");
});

// ../node_modules/@babel/core/lib/config/plugin.js
var nm = y((sm) => {
  "use strict";
  Object.defineProperty(sm, "__esModule", {
    value: !0
  });
  sm.default = void 0;
  var CFe = rm(), BT = class {
    static {
      i(this, "Plugin");
    }
    constructor(t, r, s, n = (0, CFe.finalize)([])) {
      this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride =
      void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = t.name || s, this.manipulateOptions =
      t.manipulateOptions, this.post = t.post, this.pre = t.pre, this.visitor = t.visitor || {}, this.parserOverride = t.parserOverride, this.
      generatorOverride = t.generatorOverride, this.options = r, this.externalDependencies = n;
    }
  };
  sm.default = BT;
});

// ../node_modules/@babel/core/lib/gensync-utils/functional.js
var U4 = y((MT) => {
  "use strict";
  Object.defineProperty(MT, "__esModule", {
    value: !0
  });
  MT.once = wFe;
  var $4 = Nl();
  function wFe(e) {
    let t, r, s = !1;
    return function* () {
      if (!t) {
        if (r)
          return s = !0, yield* (0, $4.waitFor)(r);
        if (yield* (0, $4.isAsync)()) {
          let n, a;
          r = new Promise((o, l) => {
            n = o, a = l;
          });
          try {
            t = {
              ok: !0,
              value: yield* e()
            }, r = null, s && n(t.value);
          } catch (o) {
            t = {
              ok: !1,
              value: o
            }, r = null, s && a(o);
          }
        } else
          try {
            t = {
              ok: !0,
              value: yield* e()
            };
          } catch (n) {
            t = {
              ok: !1,
              value: n
            };
          }
      }
      if (t.ok) return t.value;
      throw t.value;
    };
  }
  i(wFe, "once");
});

// ../node_modules/node-releases/data/processed/envs.json
var V4 = y((Jst, DFe) => {
  DFe.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.3.8.0" }, { name: "nodejs", version: "\
0.3.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.5.1.0" }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: !1, security: !1,
  v8: "3.1.2.0" }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: !1, security: !1, v8: "3.1.8.25" }, { name: "nodejs", version: "\
0.6.0", date: "2011-11-04", lts: !1, security: !1, v8: "3.6.6.6" }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: !1, security: !1,
  v8: "3.8.6.0" }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: !1, security: !1, v8: "3.11.10.10" }, { name: "nodejs", version: "\
0.9.0", date: "2012-07-20", lts: !1, security: !1, v8: "3.11.10.15" }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: !1, security: !1,
  v8: "3.14.5.8" }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: !1, security: !1, v8: "3.17.13.0" }, { name: "nodejs", version: "\
0.12.0", date: "2015-02-06", lts: !1, security: !1, v8: "3.28.73.0" }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: !1, security: !1,
  v8: "4.5.103.30" }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: !1, security: !1, v8: "4.5.103.33" }, { name: "nodejs", version: "\
4.2.0", date: "2015-10-12", lts: "Argon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Ar\
gon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: !1, v8: "4.5.103.35" },
  { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: !1, v8: "4.5.103.37" }, { name: "nodejs", version: "4.6.0",
  date: "2016-09-27", lts: "Argon", security: !0, v8: "4.5.103.37" }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: !1,
  v8: "4.5.103.43" }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: !1, v8: "4.5.103.45" }, { name: "nodej\
s", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: !0, v8: "4.5.103.53" }, { name: "nodejs", version: "5.0.0", date: "2015-10\
-29", lts: !1, security: !1, v8: "4.6.85.28" }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: !1, security: !1, v8: "4.6.85.3\
1" }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.3.0", date: "\
2015-12-15", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: !1, security: !1, v8: "4\
.6.85.31" }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5\
.6.0", date: "2016-02-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.9.0", date: "2016-03-16", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.12.0", date: "2016-06-23", lts: !1, security: !1, v8: "4.6.85.32" }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: !1, security: !1,
  v8: "5.0.71.35" }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: !1, security: !1, v8: "5.0.71.35" }, { name: "nodejs", version: "\
6.2.0", date: "2016-05-17", lts: !1, security: !1, v8: "5.0.71.47" }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: !1, security: !1,
  v8: "5.0.71.52" }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: !1, security: !1, v8: "5.0.71.60" }, { name: "nodejs", version: "\
6.5.0", date: "2016-08-26", lts: !1, security: !1, v8: "5.1.281.81" }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: !1, security: !1,
  v8: "5.1.281.83" }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: !1, security: !0, v8: "5.1.281.83" }, { name: "nodejs", version: "\
6.8.0", date: "2016-10-12", lts: !1, security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron",
  security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: !1, v8: "5.1.281.93" },
  { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: !1, v8: "5.1.281.102" }, { name: "nodejs", version: "6.12\
.0", date: "2017-11-06", lts: "Boron", security: !1, v8: "5.1.281.108" }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Bor\
on", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: !0, v8: "5.1.281.11\
1" }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "\
6.16.0", date: "2018-12-26", lts: "Boron", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "\
Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: !1, security: !1, v8: "5.4.500.36" },
  { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: !1, security: !1, v8: "5.4.500.36" }, { name: "nodejs", version: "7.2.0", date: "\
2016-11-22", lts: !1, security: !1, v8: "5.4.500.43" }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: !1, security: !1, v8: "\
5.4.500.45" }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: !1, security: !1, v8: "5.4.500.45" }, { name: "nodejs", version: "\
7.5.0", date: "2017-01-31", lts: !1, security: !1, v8: "5.4.500.48" }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: !1, security: !1,
  v8: "5.5.372.40" }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: !1, security: !1, v8: "5.5.372.41" }, { name: "nodejs", version: "\
7.8.0", date: "2017-03-29", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: !1, security: !1,
  v8: "5.5.372.43" }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "\
8.0.0", date: "2017-05-30", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: !1, security: !1,
  v8: "5.8.283.41" }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "\
8.3.0", date: "2017-08-08", lts: !1, security: !1, v8: "6.0.286.52" }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: !1, security: !1,
  v8: "6.0.286.52" }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "\
8.6.0", date: "2017-09-26", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: !1, security: !1,
  v8: "6.1.534.42" }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: !1, security: !1, v8: "6.1.534.42" }, { name: "nodejs", version: "\
8.9.0", date: "2017-10-31", lts: "Carbon", security: !1, v8: "6.1.534.46" }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "\
Carbon", security: !1, v8: "6.2.414.50" }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: !0, v8: "6.2.41\
4.50" }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: !1, v8: "6.2.414.66" }, { name: "nodejs", version: "\
8.13.0", date: "2018-11-20", lts: "Carbon", security: !1, v8: "6.2.414.72" }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "\
Carbon", security: !0, v8: "6.2.414.72" }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: !1, v8: "6.2.41\
4.75" }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: !1, v8: "6.2.414.77" }, { name: "nodejs", version: "\
8.17.0", date: "2019-12-17", lts: "Carbon", security: !0, v8: "6.2.414.78" }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: !1,
  security: !1, v8: "6.2.414.32" }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: !1, security: !1, v8: "6.2.414.32" }, { name: "\
nodejs", version: "9.2.0", date: "2017-11-14", lts: !1, security: !1, v8: "6.2.414.44" }, { name: "nodejs", version: "9.3.0", date: "2017-12\
-12", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: !1, security: !1, v8: "6.2.414\
.46" }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.6.0",
  date: "2018-02-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: !1, security: !1,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
9.9.0", date: "2018-03-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: !1, security: !0,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
10.0.0", date: "2018-04-24", lts: !1, security: !1, v8: "6.6.346.24" }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: !1, security: !1,
  v8: "6.6.346.27" }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "\
10.3.0", date: "2018-05-29", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: !1, security: !1,
  v8: "6.7.288.43" }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "\
10.6.0", date: "2018-07-04", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: !1, security: !1,
  v8: "6.7.288.49" }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: !1, security: !1, v8: "6.7.288.49" }, { name: "nodejs", version: "\
10.9.0", date: "2018-08-15", lts: !1, security: !1, v8: "6.8.275.24" }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: !1, security: !1,
  v8: "6.8.275.30" }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.12.0", date: "2018-10-10", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.13.0", date: "2018-10-30",
  lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: !0, v8: "\
6.8.275.32" }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.17.0", date: "201\
9-10-22", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: !0,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.21.0", date: "\
2020-06-02", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: !1,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "11.0.0", date: "\
2018-10-23", lts: !1, security: !1, v8: "7.0.276.28" }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: !1, security: !1, v8: "\
7.0.276.32" }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.3.0", date: "2018-11-27", lts: !1, security: !0, v8: "7.0.276.38" }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.6.0", date: "2018-12-26", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.9.0", date: "2019-01-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs",
  version: "11.12.0", date: "2019-03-14", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.13.0", date: "2019-03-28",
  lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: !1, security: !1, v8: "7.0.276.3\
8" }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "12.0.\
0", date: "2019-04-23", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: !1, security: !1,
  v8: "7.4.288.21" }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "\
12.3.0", date: "2019-05-21", lts: !1, security: !1, v8: "7.4.288.27" }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: !1, security: !1,
  v8: "7.4.288.27" }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.6.0", date: "2019-07-03", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: !1, security: !1,
  v8: "7.5.288.22" }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.9.0", date: "2019-08-20", lts: !1, security: !1, v8: "7.6.303.29" }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: !1, security: !1,
  v8: "7.6.303.29" }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: !1, security: !1, v8: "7.7.299.11" }, { name: "nodejs",
  version: "12.12.0", date: "2019-10-11", lts: !1, security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.13.0", date: "2019-10-21",
  lts: "Erbium", security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: !0, v8: "\
7.7.299.13" }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: !0, v8: "7.7.299.13" }, { name: "nodejs", version: "\
12.16.0", date: "2020-02-11", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "\
Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: !0, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "\
12.20.0", date: "2020-11-24", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "\
Erbium", security: !0, v8: "7.8.279.23" }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: !1, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13\
.1.0", date: "2019-11-05", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: !1, security: !1,
  v8: "7.9.317.23" }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.4.0", date: "2019-12-17", lts: !1, security: !0, v8: "7.9.317.25" }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.7.0", date: "2020-01-21", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: !1, security: !0,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.10.0", date: "2020-03-04", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs",
  version: "13.13.0", date: "2020-04-14", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.14.0", date: "2020-04-29",
  lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: !1, security: !1, v8: "8.1.307.30" },
  { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.2.0", date: "\
2020-05-05", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: !1, security: !1, v8: "\
8.1.307.31" }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: !1, security: !0, v8: "8.1.307.31" }, { name: "nodejs", version: "\
14.5.0", date: "2020-06-30", lts: !1, security: !1, v8: "8.3.110.9" }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "\
14.8.0", date: "2020-08-11", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs",
  version: "14.11.0", date: "2020-09-15", lts: !1, security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.12.0", date: "2020-09-22",
  lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: !1, security: !1, v8: "8.4.371.1\
9" }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.15\
.0", date: "2020-10-27", lts: "Fermium", security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "F\
ermium", security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: !1, v8: "8.4.\
371.23" }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "\
14.19.0", date: "2022-02-01", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "\
Fermium", security: !0, v8: "8.4.371.23" }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: !1, v8: "8.4\
.371.23" }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: !1, security: !1, v8: "8.6.395.16" }, { name: "nodejs", version: "\
15.1.0", date: "2020-11-04", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.4.0", date: "2020-12-09", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.7.0", date: "2021-01-25", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.10.0", date: "2021-02-23", lts: !1, security: !0, v8: "8.6.395.17" }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs",
  version: "15.13.0", date: "2021-03-31", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.14.0", date: "2021-04-06",
  lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: !1, security: !1, v8: "9.0.257.17" },
  { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: !1, security: !1, v8: "9.0.257.24" }, { name: "nodejs", version: "16.2.0", date: "\
2021-05-19", lts: !1, security: !1, v8: "9.0.257.25" }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: !1, security: !1, v8: "\
9.0.257.25" }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: !1, security: !1, v8: "9.1.269.36" }, { name: "nodejs", version: "\
16.5.0", date: "2021-07-14", lts: !1, security: !1, v8: "9.1.269.38" }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: !1, security: !0,
  v8: "9.2.230.21" }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "\
16.8.0", date: "2021-08-25", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: !1, security: !1,
  v8: "9.3.345.16" }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: !1, security: !1, v8: "9.3.345.19" }, { name: "nodejs",
  version: "16.11.0", date: "2021-10-08", lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.12.0", date: "2021-10-20",
  lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: !1, v8: "9.\
4.146.19" }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "\
16.15.0", date: "2022-04-26", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "\
Gallium", security: !0, v8: "9.4.146.24" }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: !1, v8: "9.4\
.146.26" }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "\
16.19.0", date: "2022-12-13", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "16.20.0", date: "2023-03-28", lts: "\
Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: !1, security: !1, v8: "9.5.172.21" },
  { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: !1, security: !1, v8: "9.5.172.25" }, { name: "nodejs", version: "17.2.0", date: "\
2021-11-30", lts: !1, security: !1, v8: "9.6.180.14" }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: !1, security: !1, v8: "\
9.6.180.15" }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.5.0", date: "2022-02-10", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.8.0", date: "2022-03-22", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "\
18.1.0", date: "2022-05-03", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: !1, security: !1,
  v8: "10.1.124.8" }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "\
18.4.0", date: "2022-06-16", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: !1, security: !0,
  v8: "10.2.154.4" }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs",
  version: "18.7.0", date: "2022-07-26", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.8.0", date: "2022-08-24",
  lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: !1, security: !1, v8: "10.2.154.\
15" }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.\
11.0", date: "2022-10-13", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydro\
gen", security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: !1, v8: "10.2.\
154.23" }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: !1, v8: "10.2.154.23" }, { name: "nodejs", version: "\
18.15.0", date: "2023-03-05", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.16.0", date: "2023-04-12", lts: "\
Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.17.0", date: "2023-07-18", lts: "Hydrogen", security: !1, v8: "\
10.2.154.26" }, { name: "nodejs", version: "18.18.0", date: "2023-09-18", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodej\
s", version: "18.19.0", date: "2023-11-29", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "19.0.0", date: "\
2022-10-17", lts: !1, security: !1, v8: "10.7.193.13" }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: !1, security: !1, v8: "\
10.7.193.20" }, { name: "nodejs", version: "19.2.0", date: "2022-11-29", lts: !1, security: !1, v8: "10.8.168.20" }, { name: "nodejs", version: "\
19.3.0", date: "2022-12-14", lts: !1, security: !1, v8: "10.8.168.21" }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: !1, security: !1,
  v8: "10.8.168.25" }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs",
  version: "19.6.0", date: "2023-02-01", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.7.0", date: "2023-02-21",
  lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.8.0", date: "2023-03-14", lts: !1, security: !1, v8: "10.8.168.\
25" }, { name: "nodejs", version: "19.9.0", date: "2023-04-10", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "20.0\
.0", date: "2023-04-17", lts: !1, security: !1, v8: "11.3.244.4" }, { name: "nodejs", version: "20.1.0", date: "2023-05-03", lts: !1, security: !1,
  v8: "11.3.244.8" }, { name: "nodejs", version: "20.2.0", date: "2023-05-16", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.3.0", date: "2023-06-08", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.4.0", date: "2023-07-04", lts: !1, security: !1,
  v8: "11.3.244.8" }, { name: "nodejs", version: "20.5.0", date: "2023-07-19", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.6.0", date: "2023-08-23", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.7.0", date: "2023-09-18", lts: !1, security: !1,
  v8: "11.3.244.8" }, { name: "nodejs", version: "20.8.0", date: "2023-09-28", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.9.0", date: "2023-10-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.10.0", date: "2023-11-22", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "21.0.0", date: "2023-10-17", lts: !1, security: !1, v8: "11.8.172.13" },
  { name: "nodejs", version: "21.1.0", date: "2023-10-24", lts: !1, security: !1, v8: "11.8.172.15" }, { name: "nodejs", version: "21.2.0", date: "\
2023-11-14", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.3.0", date: "2023-11-30", lts: !1, security: !1, v8: "\
11.8.172.17" }];
});

// ../node_modules/caniuse-lite/data/browsers.js
var H4 = y((Qst, W4) => {
  W4.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "\
op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browsers.js
var im = y((Zst, G4) => {
  G4.exports.browsers = H4();
});

// ../node_modules/caniuse-lite/data/browserVersions.js
var Y4 = y((ent, K4) => {
  K4.exports = { 0: "113", 1: "114", 2: "115", 3: "116", 4: "117", 5: "118", 6: "119", 7: "120", 8: "121", 9: "5", A: "10", B: "11", C: "12",
  D: "7", E: "8", F: "9", G: "15", H: "80", I: "122", J: "4", K: "6", L: "13", M: "14", N: "16", O: "17", P: "18", Q: "79", R: "81", S: "83",
  T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "\
99", j: "100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "107", r: "108", s: "20", t: "21", u: "22", v: "23", w: "109",
  x: "110", y: "111", z: "112", AB: "19", BB: "24", CB: "25", DB: "26", EB: "27", FB: "28", GB: "29", HB: "30", IB: "31", JB: "32", KB: "33",
  LB: "34", MB: "35", NB: "36", OB: "37", PB: "38", QB: "39", RB: "40", SB: "41", TB: "42", UB: "43", VB: "44", WB: "45", XB: "46", YB: "47",
  ZB: "48", aB: "49", bB: "50", cB: "51", dB: "52", eB: "53", fB: "54", gB: "55", hB: "56", iB: "57", jB: "58", kB: "60", lB: "62", mB: "63",
  nB: "64", oB: "65", pB: "66", qB: "67", rB: "68", sB: "69", tB: "70", uB: "71", vB: "72", wB: "73", xB: "74", yB: "75", zB: "76", "0B": "7\
7", "1B": "78", "2B": "123", "3B": "11.1", "4B": "12.1", "5B": "15.5", "6B": "16.0", "7B": "17.0", "8B": "3", "9B": "59", AC: "61", BC: "82",
  CC: "124", DC: "125", EC: "3.2", FC: "10.1", GC: "15.2-15.3", HC: "15.4", IC: "16.1", JC: "16.2", KC: "16.3", LC: "16.4", MC: "16.5", NC: "\
17.1", OC: "17.2", PC: "17.3", QC: "17.4", RC: "11.5", SC: "4.2-4.3", TC: "5.5", UC: "2", VC: "126", WC: "3.5", XC: "3.6", YC: "3.1", ZC: "5\
.1", aC: "6.1", bC: "7.1", cC: "9.1", dC: "13.1", eC: "14.1", fC: "15.1", gC: "15.6", hC: "16.6", iC: "TP", jC: "9.5-9.6", kC: "10.0-10.1", lC: "\
10.5", mC: "10.6", nC: "11.6", oC: "4.0-4.1", pC: "5.0-5.1", qC: "6.0-6.1", rC: "7.0-7.1", sC: "8.1-8.4", tC: "9.0-9.2", uC: "9.3", vC: "10.\
0-10.2", wC: "10.3", xC: "11.0-11.2", yC: "11.3-11.4", zC: "12.0-12.1", "0C": "12.2-12.5", "1C": "13.0-13.1", "2C": "13.2", "3C": "13.3", "4\
C": "13.4-13.7", "5C": "14.0-14.4", "6C": "14.5-14.8", "7C": "15.0-15.1", "8C": "15.6-15.8", "9C": "16.6-16.7", AD: "all", BD: "2.1", CD: "2\
.2", DD: "2.3", ED: "4.1", FD: "4.4", GD: "4.4.3-4.4.4", HD: "5.0-5.4", ID: "6.2-6.4", JD: "7.2-7.4", KD: "8.2", LD: "9.2", MD: "11.1-11.2",
  ND: "12.0", OD: "13.0", PD: "14.0", QD: "15.0", RD: "18.0", SD: "19.0", TD: "14.9", UD: "13.52", VD: "2.5", WD: "3.0-3.1" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browserVersions.js
var jT = y((tnt, X4) => {
  X4.exports.browserVersions = Y4();
});

// ../node_modules/caniuse-lite/data/agents.js
var J4 = y((rnt, z4) => {
  z4.exports = { A: { A: { K: 0, D: 0, E: 0.0155495, F: 0.0466486, A: 0, B: 0.450937, TC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "TC", "K", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { TC: 962323200, K: 998870400, D: 1161129600, E: 1237420800, F: 1300060800,
  A: 1346716800, B: 1381968e3 } }, B: { A: { 0: 0.015204, 1: 0.019005, 2: 0.011403, 3: 0.011403, 4: 0.015204, 5: 0.022806, 6: 0.133035, 7: 0.277473,
  8: 3.58054, C: 3801e-6, L: 0, M: 3801e-6, G: 3801e-6, N: 0, O: 7602e-6, P: 0.011403, Q: 0, H: 0, R: 0, S: 0, T: 0, U: 0, V: 0, W: 0.053214,
  X: 0, Y: 0, Z: 0, a: 0, b: 0.011403, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0.011403, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 3801e-6, q: 7602e-6,
  r: 7602e-6, w: 0.068418, x: 7602e-6, y: 7602e-6, z: 7602e-6, I: 0.551145 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "L", "M", "G", "N", "O", "\
P", "Q", "H", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "\
q", "r", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "I", "", "", ""], E: "Edge", F: { 0: 1683158400, 1: 1685664e3, 2: 1689897600,
  3: 1692576e3, 4: 1694649600, 5: 1697155200, 6: 1698969600, 7: 1701993600, 8: 1706227200, C: 1438128e3, L: 1447286400, M: 1470096e3, G: 1491868800,
  N: 1508198400, O: 1525046400, P: 1542067200, Q: 1579046400, H: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600,
  W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200,
  g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600, o: 1661990400, p: 1664755200,
  q: 1666915200, r: 1670198400, w: 1673481600, x: 1675900800, y: 1678665600, z: 1680825600, I: 1708732800 }, D: { C: "ms", L: "ms", M: "ms",
  G: "ms", N: "ms", O: "ms", P: "ms" } }, C: { A: { 0: 7602e-6, 1: 7602e-6, 2: 0.429513, 3: 3801e-6, 4: 0.011403, 5: 0.095025, 6: 0.110229, 7: 0.106428,
  8: 0.064617, 9: 0, UC: 0, "8B": 0, J: 3801e-6, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0.034209, C: 0.019005, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0,
  AB: 0, s: 0, t: 0, u: 0, v: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0,
  RB: 0, SB: 0, TB: 0, UB: 7602e-6, VB: 7602e-6, WB: 3801e-6, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 7602e-6, cB: 0, dB: 0.053214, eB: 7602e-6, fB: 7602e-6,
  gB: 3801e-6, hB: 0.019005, iB: 0, jB: 0, "9B": 3801e-6, kB: 0, AC: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0,
  vB: 3801e-6, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0.015204, Q: 0, H: 0, R: 0, BC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0.011403, Y: 0,
  Z: 0, a: 7602e-6, b: 0, c: 0, d: 3801e-6, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 3801e-6, l: 0.022806, m: 0.030408, n: 0, o: 3801e-6, p: 0,
  q: 3801e-6, r: 3801e-6, w: 7602e-6, x: 3801e-6, y: 0, z: 3801e-6, I: 1.1593, "2B": 0.349692, CC: 0, DC: 0, VC: 0, WC: 0, XC: 0 }, B: "moz",
  C: ["UC", "8B", "WC", "XC", "J", "9", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "AB", "s", "t", "u", "v", "BB", "CB",
  "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "\
aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "9B", "kB", "AC", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB",
  "wB", "xB", "yB", "zB", "0B", "1B", "Q", "H", "R", "BC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "\
i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "I", "2B", "CC", "DC", "VC"],
  E: "Firefox", F: { 0: 1683590400, 1: 1686009600, 2: 1688428800, 3: 1690848e3, 4: 1693267200, 5: 1695686400, 6: 1698105600, 7: 1700524800, 8: 1702944e3,
  9: 1308614400, UC: 1161648e3, "8B": 1213660800, WC: 124632e4, XC: 1264032e3, J: 1300752e3, K: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400,
  A: 1324339200, B: 1327968e3, C: 1331596800, L: 1335225600, M: 1338854400, G: 1342483200, N: 1346112e3, O: 1349740800, P: 1353628800, AB: 1357603200,
  s: 1361232e3, t: 1364860800, u: 1368489600, v: 1372118400, BB: 1375747200, CB: 1379376e3, DB: 1386633600, EB: 1391472e3, FB: 1395100800, GB: 1398729600,
  HB: 1402358400, IB: 1405987200, JB: 1409616e3, KB: 1413244800, LB: 1417392e3, MB: 1421107200, NB: 1424736e3, OB: 1428278400, PB: 1431475200,
  QB: 1435881600, RB: 1439251200, SB: 144288e4, TB: 1446508800, UB: 1450137600, VB: 1453852800, WB: 1457395200, XB: 1461628800, YB: 1465257600,
  ZB: 1470096e3, aB: 1474329600, bB: 1479168e3, cB: 1485216e3, dB: 1488844800, eB: 149256e4, fB: 1497312e3, gB: 1502150400, hB: 1506556800, iB: 1510617600,
  jB: 1516665600, "9B": 1520985600, kB: 1525824e3, AC: 1529971200, lB: 1536105600, mB: 1540252800, nB: 1544486400, oB: 154872e4, pB: 1552953600,
  qB: 1558396800, rB: 1562630400, sB: 1567468800, tB: 1571788800, uB: 1575331200, vB: 1578355200, wB: 1581379200, xB: 1583798400, yB: 1586304e3,
  zB: 1588636800, "0B": 1591056e3, "1B": 1593475200, Q: 1595894400, H: 1598313600, R: 1600732800, BC: 1603152e3, S: 1605571200, T: 1607990400,
  U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392e3, d: 1635811200,
  e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200, l: 1656374400, m: 1658793600, n: 1661212800,
  o: 1663632e3, p: 1666051200, q: 1668470400, r: 1670889600, w: 1673913600, x: 1676332800, y: 1678752e3, z: 1681171200, I: 1705968e3, "2B": 1708387200,
  CC: null, DC: null, VC: null } }, D: { A: { 0: 0.106428, 1: 0.102627, 2: 0.057015, 3: 0.250866, 4: 0.155841, 5: 0.273672, 6: 1.10229, 7: 2.08675,
  8: 13.6988, 9: 0, J: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, AB: 0, s: 0, t: 0, u: 0, v: 0, BB: 0,
  CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 3801e-6, MB: 0, NB: 0, OB: 0, PB: 0.015204, QB: 0, RB: 0, SB: 0, TB: 0,
  UB: 0, VB: 0, WB: 0, XB: 0, YB: 7602e-6, ZB: 0.030408, aB: 0.026607, bB: 0.011403, cB: 0, dB: 0, eB: 3801e-6, fB: 3801e-6, gB: 3801e-6, hB: 0.011403,
  iB: 7602e-6, jB: 0, "9B": 0, kB: 0.019005, AC: 0.011403, lB: 0, mB: 3801e-6, nB: 0, oB: 3801e-6, pB: 0.026607, qB: 3801e-6, rB: 3801e-6, sB: 0.034209,
  tB: 0.049413, uB: 7602e-6, vB: 3801e-6, wB: 7602e-6, xB: 7602e-6, yB: 7602e-6, zB: 7602e-6, "0B": 0.011403, "1B": 0.015204, Q: 0.11403, H: 0.015204,
  R: 0.030408, S: 0.03801, T: 7602e-6, U: 0.022806, V: 0.03801, W: 0.079821, X: 0.019005, Y: 0.019005, Z: 0.015204, a: 0.057015, b: 0.026607,
  c: 0.049413, d: 0.045612, e: 0.011403, f: 0.011403, g: 0.019005, h: 0.072219, i: 0.034209, j: 0.030408, k: 0.041811, l: 0.034209, m: 0.144438,
  n: 0.03801, o: 0.030408, p: 0.041811, q: 0.034209, r: 0.060816, w: 1.62303, x: 0.049413, y: 0.057015, z: 0.053214, I: 1.87769, "2B": 0.019005,
  CC: 3801e-6, DC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "J", "9", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "\
AB", "s", "t", "u", "v", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "\
UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "9B", "kB", "AC", "lB", "mB", "nB", "oB", "pB",
  "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "Q", "H", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "\
c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "\
8", "I", "2B", "CC", "DC"], E: "Chrome", F: { 0: 1682985600, 1: 1685404800, 2: 1689724800, 3: 1692057600, 4: 1694476800, 5: 1696896e3, 6: 1698710400,
  7: 1701993600, 8: 1705968e3, 9: 1274745600, J: 1264377600, K: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600, A: 1299542400, B: 1303862400,
  C: 1307404800, L: 1312243200, M: 1316131200, G: 1316131200, N: 1319500800, O: 1323734400, P: 1328659200, AB: 1332892800, s: 133704e4, t: 1340668800,
  u: 1343692800, v: 1348531200, BB: 1352246400, CB: 1357862400, DB: 1361404800, EB: 1364428800, FB: 1369094400, GB: 1374105600, HB: 1376956800,
  IB: 1384214400, JB: 1389657600, KB: 1392940800, LB: 1397001600, MB: 1400544e3, NB: 1405468800, OB: 1409011200, PB: 141264e4, QB: 1416268800,
  RB: 1421798400, SB: 1425513600, TB: 1429401600, UB: 143208e4, VB: 1437523200, WB: 1441152e3, XB: 1444780800, YB: 1449014400, ZB: 1453248e3,
  aB: 1456963200, bB: 1460592e3, cB: 1464134400, dB: 1469059200, eB: 1472601600, fB: 1476230400, gB: 1480550400, hB: 1485302400, iB: 1489017600,
  jB: 149256e4, "9B": 1496707200, kB: 1500940800, AC: 1504569600, lB: 1508198400, mB: 1512518400, nB: 1516752e3, oB: 1520294400, pB: 1523923200,
  qB: 1527552e3, rB: 1532390400, sB: 1536019200, tB: 1539648e3, uB: 1543968e3, vB: 154872e4, wB: 1552348800, xB: 1555977600, yB: 1559606400,
  zB: 1564444800, "0B": 1568073600, "1B": 1571702400, Q: 1575936e3, H: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600,
  V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600,
  f: 1637020800, g: 1641340800, h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600,
  p: 1664236800, q: 1666656e3, r: 166968e4, w: 1673308800, x: 1675728e3, y: 1678147200, z: 1680566400, I: 1708387200, "2B": null, CC: null, DC: null } },
  E: { A: { 9: 0, J: 0, K: 0, D: 0, E: 3801e-6, F: 3801e-6, A: 0, B: 0, C: 0, L: 7602e-6, M: 0.03801, G: 7602e-6, YC: 0, EC: 0, ZC: 0, aC: 0,
  bC: 0, cC: 7602e-6, FC: 0, "3B": 0.011403, "4B": 0.015204, dC: 0.072219, eC: 0.106428, fC: 0.030408, GC: 0.011403, HC: 0.026607, "5B": 0.041811,
  gC: 0.273672, "6B": 0.030408, IC: 0.060816, JC: 0.053214, KC: 0.125433, LC: 0.049413, MC: 0.083622, hC: 0.440916, "7B": 0.07602, NC: 0.243264,
  OC: 0.919842, PC: 0.475125, QC: 0.011403, iC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "YC", "EC", "J",
  "9", "ZC", "K", "aC", "D", "bC", "E", "F", "cC", "A", "FC", "B", "3B", "C", "4B", "L", "dC", "M", "eC", "G", "fC", "GC", "HC", "5B", "gC",
  "6B", "IC", "JC", "KC", "LC", "MC", "hC", "7B", "NC", "OC", "PC", "QC", "iC", "", ""], E: "Safari", F: { 9: 1275868800, YC: 1205798400, EC: 1226534400,
  J: 1244419200, ZC: 131112e4, K: 1343174400, aC: 13824e5, D: 13824e5, bC: 1410998400, E: 1413417600, F: 1443657600, cC: 1458518400, A: 1474329600,
  FC: 1490572800, B: 1505779200, "3B": 1522281600, C: 1537142400, "4B": 1553472e3, L: 1568851200, dC: 1585008e3, M: 1600214400, eC: 1619395200,
  G: 1632096e3, fC: 1635292800, GC: 1639353600, HC: 1647216e3, "5B": 1652745600, gC: 1658275200, "6B": 1662940800, IC: 1666569600, JC: 1670889600,
  KC: 1674432e3, LC: 1679875200, MC: 1684368e3, hC: 1690156800, "7B": 1695686400, NC: 1698192e3, OC: 1702252800, PC: 1705881600, QC: 1709596800,
  iC: null } }, F: { A: { F: 0, B: 0, C: 0, G: 0, N: 0, O: 0, P: 0, AB: 0, s: 0, t: 0, u: 0, v: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 3801e-6, GB: 0,
  HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 3801e-6, OB: 0, PB: 0, QB: 0, RB: 3801e-6, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0, XB: 0.015204, YB: 0,
  ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0,
  tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0, Q: 0, H: 0, R: 0, BC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0,
  a: 0, b: 0, c: 0, d: 0, e: 0.045612, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0.049413, m: 0, n: 0, o: 7602e-6, p: 0.661374, q: 0, r: 0, jC: 0,
  kC: 0, lC: 0, mC: 0, "3B": 0, RC: 0, nC: 0, "4B": 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "F", "jC", "kC", "lC", "mC", "B", "3B", "RC", "nC", "C", "4B", "G", "N", "O", "P", "AB", "s", "t", "u", "v", "BB", "CB", "\
DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB",
  "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "\
yB", "zB", "0B", "1B", "Q", "H", "R", "BC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "\
l", "m", "n", "o", "p", "q", "r", "", "", ""], E: "Opera", F: { F: 1150761600, jC: 1223424e3, kC: 1251763200, lC: 1267488e3, mC: 1277942400,
  B: 1292457600, "3B": 1302566400, RC: 1309219200, nC: 1323129600, C: 1323129600, "4B": 1352073600, G: 1372723200, N: 1377561600, O: 1381104e3,
  P: 1386288e3, AB: 1390867200, s: 1393891200, t: 1399334400, u: 1401753600, v: 1405987200, BB: 1409616e3, CB: 1413331200, DB: 1417132800, EB: 1422316800,
  FB: 1425945600, GB: 1430179200, HB: 1433808e3, IB: 1438646400, JB: 1442448e3, KB: 1445904e3, LB: 1449100800, MB: 1454371200, NB: 1457308800,
  OB: 146232e4, PB: 1465344e3, QB: 1470096e3, RB: 1474329600, SB: 1477267200, TB: 1481587200, UB: 1486425600, VB: 1490054400, WB: 1494374400,
  XB: 1498003200, YB: 1502236800, ZB: 1506470400, aB: 1510099200, bB: 1515024e3, cB: 1517961600, dB: 1521676800, eB: 1525910400, fB: 1530144e3,
  gB: 1534982400, hB: 1537833600, iB: 1543363200, jB: 1548201600, kB: 1554768e3, lB: 1561593600, mB: 1566259200, nB: 1570406400, oB: 1573689600,
  pB: 1578441600, qB: 1583971200, rB: 1587513600, sB: 1592956800, tB: 1595894400, uB: 1600128e3, vB: 1603238400, wB: 161352e4, xB: 1612224e3,
  yB: 1616544e3, zB: 1619568e3, "0B": 1623715200, "1B": 1627948800, Q: 1631577600, H: 1633392e3, R: 1635984e3, BC: 1638403200, S: 1642550400,
  T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200,
  d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800,
  n: 169992e4, o: 169992e4, p: 1702944e3, q: 1707264e3, r: 1710115200 }, D: { F: "o", B: "o", C: "o", jC: "o", kC: "o", lC: "o", mC: "o", "3\
B": "o", RC: "o", nC: "o", "4B": "o" } }, G: { A: { E: 0, EC: 0, oC: 0, SC: 293537e-8, pC: 293537e-8, qC: 880612e-8, rC: 0.0102738, sC: 146769e-8,
  tC: 733843e-8, uC: 0.0352245, vC: 587075e-8, wC: 0.0587075, xC: 0.0264184, yC: 0.0190799, zC: 0.0102738, "0C": 0.265651, "1C": 440306e-8, "\
2C": 0.0425629, "3C": 0.0132092, "4C": 0.0572398, "5C": 0.121818, "6C": 0.15851, "7C": 0.0675136, GC: 0.0792551, HC: 0.0895289, "5B": 0.118883,
  "8C": 0.978947, "6B": 0.25391, IC: 0.540109, JC: 0.250974, KC: 0.457918, LC: 0.102738, MC: 0.214282, "9C": 1.65702, "7B": 0.237765, NC: 0.725037,
  OC: 5.42163, PC: 2.54497, QC: 0.0733843 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "EC", "oC", "SC", "\
pC", "qC", "rC", "E", "sC", "tC", "uC", "vC", "wC", "xC", "yC", "zC", "0C", "1C", "2C", "3C", "4C", "5C", "6C", "7C", "GC", "HC", "5B", "8C",
  "6B", "IC", "JC", "KC", "LC", "MC", "9C", "7B", "NC", "OC", "PC", "QC", "", "", ""], E: "Safari on iOS", F: { EC: 1270252800, oC: 1283904e3,
  SC: 1299628800, pC: 1331078400, qC: 1359331200, rC: 1394409600, E: 1410912e3, sC: 1413763200, tC: 1442361600, uC: 1458518400, vC: 1473724800,
  wC: 1490572800, xC: 1505779200, yC: 1522281600, zC: 1537142400, "0C": 1553472e3, "1C": 1568851200, "2C": 1572220800, "3C": 1580169600, "4C": 1585008e3,
  "5C": 1600214400, "6C": 1619395200, "7C": 1632096e3, GC: 1639353600, HC: 1647216e3, "5B": 1652659200, "8C": 1658275200, "6B": 1662940800, IC: 1666569600,
  JC: 1670889600, KC: 1674432e3, LC: 1679875200, MC: 1684368e3, "9C": 1690156800, "7B": 1694995200, NC: 1698192e3, OC: 1702252800, PC: 1705881600,
  QC: 1709596800 } }, H: { A: { AD: 0.09 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AD", "", "", ""],
  E: "Opera Mini", F: { AD: 1426464e3 } }, I: { A: { "8B": 0, J: 582612e-10, I: 0.580223, BD: 0, CD: 582612e-10, DD: 0, ED: 582612e-10, SC: 349567e-9,
  FD: 0, GD: 139827e-8 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "BD", "CD", "DD", "8B", "J", "ED", "SC", "FD", "GD", "I", "", "",
  ""], E: "Android Browser", F: { BD: 1256515200, CD: 1274313600, DD: 1291593600, "8B": 1298332800, J: 1318896e3, ED: 1341792e3, SC: 1374624e3,
  FD: 1386547200, GD: 1401667200, I: 1709078400 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, H: 1.23017,
  "3B": 0, RC: 0, "4B": 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "3B", "RC", "C", "4B", "H", "", "", ""],
  E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, "3B": 1314835200, RC: 1318291200, C: 1330300800, "4B": 1349740800, H: 1709769600 }, D: {
  H: "webkit" } }, L: { A: { I: 42.4244 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "", "",
  ""], E: "Chrome for Android", F: { I: 1709078400 } }, M: { A: { "2B": 0.291306 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "2B", "", "", ""], E: "Firefox for Android", F: { "2B": 1708387200 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } },
  O: { A: { "5B": 0.818136 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "5B", "", "", ""], E: "\
UC Browser for Android", F: { "5B": 1710115200 }, D: { "5B": "webkit" } }, P: { A: { J: 0.13981, s: 0.0322639, t: 0.0752824, u: 0.0860371, v: 2.04338,
  HD: 0.0107546, ID: 0, JD: 0.0537732, KD: 0, LD: 0, FC: 0, MD: 0.0107546, ND: 0, OD: 0.0107546, PD: 0, QD: 0, "6B": 0.0107546, "7B": 0.0322639,
  RD: 0.0215093, SD: 0.0430185 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "J", "HD", "ID", "JD", "KD", "LD", "FC", "MD", "ND", "OD", "PD", "QD", "6B", "7B", "RD", "SD",
  "s", "t", "u", "v", "", "", ""], E: "Samsung Internet", F: { J: 1461024e3, HD: 1481846400, ID: 1509408e3, JD: 1528329600, KD: 1546128e3, LD: 1554163200,
  FC: 1567900800, MD: 1582588800, ND: 1593475200, OD: 1605657600, PD: 1618531200, QD: 1629072e3, "6B": 1640736e3, "7B": 1651708800, RD: 1659657600,
  SD: 1667260800, s: 1677369600, t: 1684454400, u: 1689292800, v: 1697587200 } }, Q: { A: { TD: 0.241722 }, B: "webkit", C: ["", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "TD", "", "", ""], E: "QQ Browser", F: { TD: 1710288e3 } }, R: { A: { UD: 0 }, B: "\
webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "UD", "", "", ""], E: "Baidu Browser", F: { UD: 1710201600 } },
  S: { A: { VD: 0.086772, WD: 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "VD", "WD", "", "", ""],
  E: "KaiOS Browser", F: { VD: 1527811200, WD: 1631664e3 } } };
});

// ../node_modules/caniuse-lite/dist/unpacker/agents.js
var t8 = y((snt, e8) => {
  "use strict";
  var IFe = im().browsers, qT = jT().browserVersions, Q4 = J4();
  function Z4(e) {
    return Object.keys(e).reduce((t, r) => (t[qT[r]] = e[r], t), {});
  }
  i(Z4, "unpackBrowserVersions");
  e8.exports.agents = Object.keys(Q4).reduce((e, t) => {
    let r = Q4[t];
    return e[IFe[t]] = Object.keys(r).reduce((s, n) => (n === "A" ? s.usage_global = Z4(r[n]) : n === "C" ? s.versions = r[n].reduce((a, o) => (o ===
    "" ? a.push(null) : a.push(qT[o]), a), []) : n === "D" ? s.prefix_exceptions = Z4(r[n]) : n === "E" ? s.browser = r[n] : n === "F" ? s.release_date =
    Object.keys(r[n]).reduce(
      (a, o) => (a[qT[o]] = r[n][o], a),
      {}
    ) : s.prefix = r[n], s), {}), e;
  }, {});
});

// ../node_modules/node-releases/data/release-schedule/release-schedule.json
var r8 = y((int, _Fe) => {
  _Fe.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "\
2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Arg\
on" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "\
2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "\
2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "\
2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Du\
bnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "\
2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "\
2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "\
2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Ga\
llium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "\
2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "\
2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "Iron" }, v21: { start: "2023-10-17", maintenance: "\
2024-04-01", end: "2024-06-01" }, v22: { start: "2024-04-23", lts: "2024-10-29", maintenance: "2025-10-21", end: "2027-04-30", codename: "" },
  v23: { start: "2024-10-15", maintenance: "2025-04-01", end: "2025-06-01" }, v24: { start: "2025-04-22", lts: "2025-10-28", maintenance: "2\
026-10-20", end: "2028-04-30", codename: "" } };
});

// ../node_modules/electron-to-chromium/versions.js
var n8 = y((ant, s8) => {
  s8.exports = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "19.1": "102",
    "20.0": "104",
    "20.1": "104",
    "20.2": "104",
    "20.3": "104",
    "21.0": "106",
    "21.1": "106",
    "21.2": "106",
    "21.3": "106",
    "21.4": "106",
    "22.0": "108",
    "22.1": "108",
    "22.2": "108",
    "22.3": "108",
    "23.0": "110",
    "23.1": "110",
    "23.2": "110",
    "23.3": "110",
    "24.0": "112",
    "24.1": "112",
    "24.2": "112",
    "24.3": "112",
    "24.4": "112",
    "24.5": "112",
    "24.6": "112",
    "24.7": "112",
    "24.8": "112",
    "25.0": "114",
    "25.1": "114",
    "25.2": "114",
    "25.3": "114",
    "25.4": "114",
    "25.5": "114",
    "25.6": "114",
    "25.7": "114",
    "25.8": "114",
    "25.9": "114",
    "26.0": "116",
    "26.1": "116",
    "26.2": "116",
    "26.3": "116",
    "26.4": "116",
    "26.5": "116",
    "26.6": "116",
    "27.0": "118",
    "27.1": "118",
    "27.2": "118",
    "27.3": "118",
    "28.0": "120",
    "28.1": "120",
    "28.2": "120",
    "29.0": "122",
    "29.1": "122",
    "30.0": "124"
  };
});

// ../node_modules/browserslist/error.js
var UT = y((ont, i8) => {
  function $T(e) {
    this.name = "BrowserslistError", this.message = e, this.browserslist = !0, Error.captureStackTrace && Error.captureStackTrace(this, $T);
  }
  i($T, "BrowserslistError");
  $T.prototype = Error.prototype;
  i8.exports = $T;
});

// ../node_modules/browserslist/parse.js
var c8 = y((unt, u8) => {
  var a8 = /^\s+and\s+(.*)/i, o8 = /^(?:,\s*|\s+or\s+)(.*)/i;
  function l8(e) {
    return Array.isArray(e) ? e.reduce(function(t, r) {
      return t.concat(l8(r));
    }, []) : [e];
  }
  i(l8, "flatten");
  function OFe(e, t) {
    for (var r = 1, s = e.length; r <= s; r++) {
      var n = e.substr(-r, r);
      if (t(n, r, s))
        return e.slice(0, -r);
    }
    return "";
  }
  i(OFe, "find");
  function VT(e, t) {
    var r = { query: t };
    t.indexOf("not ") === 0 && (r.not = !0, t = t.slice(4));
    for (var s in e) {
      var n = e[s], a = t.match(n.regexp);
      if (a) {
        r.type = s;
        for (var o = 0; o < n.matches.length; o++)
          r[n.matches[o]] = a[o + 1];
        return r;
      }
    }
    return r.type = "unknown", r;
  }
  i(VT, "matchQuery");
  function NFe(e, t, r) {
    var s;
    return OFe(t, function(n, a, o) {
      return a8.test(n) ? (s = VT(e, n.match(a8)[1]), s.compose = "and", r.unshift(s), !0) : o8.test(n) ? (s = VT(e, n.match(o8)[1]), s.compose =
      "or", r.unshift(s), !0) : a === o ? (s = VT(e, n.trim()), s.compose = "or", r.unshift(s), !0) : !1;
    });
  }
  i(NFe, "matchBlock");
  u8.exports = /* @__PURE__ */ i(function(t, r) {
    return Array.isArray(r) || (r = [r]), l8(
      r.map(function(s) {
        var n = [];
        do
          s = NFe(t, s, n);
        while (s);
        return n;
      })
    );
  }, "parse");
});

// ../node_modules/caniuse-lite/dist/lib/statuses.js
var p8 = y((fnt, f8) => {
  f8.exports = {
    1: "ls",
    // WHATWG Living Standard
    2: "rec",
    // W3C Recommendation
    3: "pr",
    // W3C Proposed Recommendation
    4: "cr",
    // W3C Candidate Recommendation
    5: "wd",
    // W3C Working Draft
    6: "other",
    // Non-W3C, but reputable
    7: "unoff"
    // Unofficial, Editor's Draft or W3C "Note"
  };
});

// ../node_modules/caniuse-lite/dist/lib/supported.js
var h8 = y((pnt, d8) => {
  d8.exports = {
    y: 1,
    n: 2,
    a: 4,
    p: 8,
    u: 16,
    x: 32,
    d: 64
  };
});

// ../node_modules/caniuse-lite/dist/unpacker/feature.js
var g8 = y((dnt, WT) => {
  "use strict";
  var RFe = p8(), m8 = h8(), kFe = im().browsers, FFe = jT().browserVersions, LFe = Math.log(2);
  function BFe(e) {
    let t = Object.keys(m8).reduce((n, a) => (e & m8[a] && n.push(a), n), []), r = e >> 7, s = [];
    for (; r; ) {
      let n = Math.floor(Math.log(r) / LFe) + 1;
      s.unshift(`#${n}`), r -= Math.pow(2, n - 1);
    }
    return t.concat(s).join(" ");
  }
  i(BFe, "unpackSupport");
  function y8(e) {
    let t = {
      status: RFe[e.B],
      title: e.C,
      shown: e.D
    };
    return t.stats = Object.keys(e.A).reduce((r, s) => {
      let n = e.A[s];
      return r[kFe[s]] = Object.keys(n).reduce(
        (a, o) => {
          let l = n[o].split(" "), u = BFe(o);
          return l.forEach((c) => a[FFe[c]] = u), a;
        },
        {}
      ), r;
    }, {}), t;
  }
  i(y8, "unpackFeature");
  WT.exports = y8;
  WT.exports.default = y8;
});

// ../node_modules/caniuse-lite/dist/unpacker/region.js
var E8 = y((mnt, HT) => {
  "use strict";
  var MFe = im().browsers;
  function b8(e) {
    return Object.keys(e).reduce((t, r) => {
      let s = e[r];
      return t[MFe[r]] = Object.keys(s).reduce((n, a) => {
        let o = s[a];
        return a === "_" ? o.split(" ").forEach((l) => n[l] = null) : n[a] = o, n;
      }, {}), t;
    }, {});
  }
  i(b8, "unpackRegion");
  HT.exports = b8;
  HT.exports.default = b8;
});

// ../node_modules/browserslist/node.js
var C8 = y((gnt, Eo) => {
  var jFe = g8().default, qFe = E8().default, Cs = require("path"), Bl = require("fs"), Ur = UT(), v8 = /^\s*\[(.+)]\s*$/, $Fe = /^browserslist-config-/,
  UFe = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/, VFe = 6 * 30 * 24 * 60 * 60 * 1e3, S8 = "Browserslist config should be a string\
 or an array of strings with browser queries", GT = !1, lm = {}, am = {};
  function T8(e) {
    var t = " Use `dangerousExtend` option to disable.";
    if (!$Fe.test(e) && !UFe.test(e))
      throw new Ur(
        "Browserslist config needs `browserslist-config-` prefix. " + t
      );
    if (e.replace(/^@[^/]+\//, "").indexOf(".") !== -1)
      throw new Ur(
        "`.` not allowed in Browserslist config name. " + t
      );
    if (e.indexOf("node_modules") !== -1)
      throw new Ur(
        "`node_modules` not allowed in Browserslist config." + t
      );
  }
  i(T8, "checkExtend");
  function Wn(e) {
    if (e in lm)
      return lm[e];
    var t = Bl.existsSync(e) && Bl.statSync(e).isFile();
    return process.env.BROWSERSLIST_DISABLE_CACHE || (lm[e] = t), t;
  }
  i(Wn, "isFile");
  function x8(e, t) {
    var r = Wn(e) ? Cs.dirname(e) : e, s = Cs.resolve(r);
    do {
      if (!WFe(s)) break;
      var n = t(s);
      if (typeof n < "u") return n;
    } while (s !== (s = Cs.dirname(s)));
  }
  i(x8, "eachParent");
  function WFe(e) {
    if (!process.env.BROWSERSLIST_ROOT_PATH) return !0;
    var t = Cs.resolve(process.env.BROWSERSLIST_ROOT_PATH);
    return Cs.relative(t, e).substring(0, 2) !== "..";
  }
  i(WFe, "pathInRoot");
  function HFe(e) {
    if (Array.isArray(e)) {
      for (var t = 0; t < e.length; t++)
        if (typeof e[t] != "string")
          throw new Ur(S8);
    } else if (typeof e != "string")
      throw new Ur(S8);
  }
  i(HFe, "check");
  function om(e, t) {
    if (typeof e != "object") return e;
    var r;
    if (typeof t.env == "string" ? r = t.env : process.env.BROWSERSLIST_ENV ? r = process.env.BROWSERSLIST_ENV : process.env.NODE_ENV ? r = process.
    env.NODE_ENV : r = "production", t.throwOnMissing && r && r !== "defaults" && !e[r])
      throw new Ur(
        "Missing config for Browserslist environment `" + r + "`"
      );
    return e[r] || e.defaults;
  }
  i(om, "pickEnv");
  function P8(e) {
    var t = JSON.parse(
      Bl.readFileSync(e).toString().replace(/^\uFEFF/m, "")
    );
    if (t.browserlist && !t.browserslist)
      throw new Ur(
        "`browserlist` key instead of `browserslist` in " + e
      );
    var r = t.browserslist;
    (Array.isArray(r) || typeof r == "string") && (r = { defaults: r });
    for (var s in r)
      HFe(r[s]);
    return r;
  }
  i(P8, "parsePackage");
  function GFe(e) {
    var t = 0;
    for (var r in e) {
      var s = e[r].releaseDate || {};
      for (var n in s)
        t < s[n] && (t = s[n]);
    }
    return t * 1e3;
  }
  i(GFe, "latestReleaseTime");
  function A8(e, t) {
    if (e || (e = {}), t && "dataByBrowser" in t && (t = t.dataByBrowser), typeof t == "object") {
      var r = {};
      for (var s in t) {
        var n = Object.keys(t[s]);
        if (n.length === 1 && e[s] && e[s].versions.length === 1) {
          var a = e[s].versions[0];
          r[s] = {}, r[s][a] = t[s][n[0]];
        } else
          r[s] = t[s];
      }
      return r;
    }
  }
  i(A8, "normalizeStats");
  function KFe(e, t) {
    for (var r in e) {
      var s = e[r];
      if ("0" in s) {
        var n = t[r].versions;
        s[n[n.length - 1]] = s[0], delete s[0];
      }
    }
  }
  i(KFe, "normalizeUsageData");
  Eo.exports = {
    loadQueries: /* @__PURE__ */ i(function(t, r) {
      !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && T8(r);
      var s = require(require.resolve(r, { paths: [".", t.path] }));
      if (s) {
        if (Array.isArray(s))
          return s;
        if (typeof s == "object")
          return s.defaults || (s.defaults = []), om(s, t, r);
      }
      throw new Ur(
        "`" + r + "` config exports not an array of queries or an object of envs"
      );
    }, "loadQueries"),
    loadStat: /* @__PURE__ */ i(function(t, r, s) {
      !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && T8(r);
      var n = require(require.resolve(
        Cs.join(r, "browserslist-stats.json"),
        { paths: ["."] }
      ));
      return A8(s, n);
    }, "loadStat"),
    getStat: /* @__PURE__ */ i(function(t, r) {
      var s;
      if (t.stats ? s = t.stats : process.env.BROWSERSLIST_STATS ? s = process.env.BROWSERSLIST_STATS : t.path && Cs.resolve && Bl.existsSync &&
      (s = x8(t.path, function(n) {
        var a = Cs.join(n, "browserslist-stats.json");
        return Wn(a) ? a : void 0;
      })), typeof s == "string")
        try {
          s = JSON.parse(Bl.readFileSync(s));
        } catch {
          throw new Ur("Can't read " + s);
        }
      return A8(r, s);
    }, "getStat"),
    loadConfig: /* @__PURE__ */ i(function(t) {
      if (process.env.BROWSERSLIST)
        return process.env.BROWSERSLIST;
      if (t.config || process.env.BROWSERSLIST_CONFIG) {
        var r = t.config || process.env.BROWSERSLIST_CONFIG;
        return Cs.basename(r) === "package.json" ? om(P8(r), t) : om(Eo.exports.readConfig(r), t);
      } else return t.path ? om(Eo.exports.findConfig(t.path), t) : void 0;
    }, "loadConfig"),
    loadCountry: /* @__PURE__ */ i(function(t, r, s) {
      var n = r.replace(/[^\w-]/g, "");
      if (!t[n]) {
        var a;
        try {
          a = require("caniuse-lite/data/regions/" + n + ".js");
        } catch {
          throw new Ur("Unknown region name `" + n + "`.");
        }
        var o = qFe(a);
        KFe(o, s), t[r] = {};
        for (var l in o)
          for (var u in o[l])
            t[r][l + " " + u] = o[l][u];
      }
    }, "loadCountry"),
    loadFeature: /* @__PURE__ */ i(function(t, r) {
      if (r = r.replace(/[^\w-]/g, ""), !t[r]) {
        var s;
        try {
          s = require("caniuse-lite/data/features/" + r + ".js");
        } catch {
          throw new Ur("Unknown feature name `" + r + "`.");
        }
        var n = jFe(s).stats;
        t[r] = {};
        for (var a in n) {
          t[r][a] = {};
          for (var o in n[a])
            t[r][a][o] = n[a][o];
        }
      }
    }, "loadFeature"),
    parseConfig: /* @__PURE__ */ i(function(t) {
      var r = { defaults: [] }, s = ["defaults"];
      return t.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function(n) {
        return n.trim();
      }).filter(function(n) {
        return n !== "";
      }).forEach(function(n) {
        v8.test(n) ? (s = n.match(v8)[1].trim().split(" "), s.forEach(function(a) {
          if (r[a])
            throw new Ur(
              "Duplicate section " + a + " in Browserslist config"
            );
          r[a] = [];
        })) : s.forEach(function(a) {
          r[a].push(n);
        });
      }), r;
    }, "parseConfig"),
    readConfig: /* @__PURE__ */ i(function(t) {
      if (!Wn(t))
        throw new Ur("Can't read " + t + " config");
      return Eo.exports.parseConfig(Bl.readFileSync(t));
    }, "readConfig"),
    findConfig: /* @__PURE__ */ i(function(t) {
      t = Cs.resolve(t);
      var r = [], s = x8(t, function(n) {
        if (n in am)
          return am[n];
        r.push(n);
        var a = Cs.join(n, "browserslist"), o = Cs.join(n, "package.json"), l = Cs.join(n, ".browserslistrc"), u;
        if (Wn(o))
          try {
            u = P8(o);
          } catch (c) {
            if (c.name === "BrowserslistError") throw c;
            console.warn(
              "[Browserslist] Could not parse " + o + ". Ignoring it."
            );
          }
        if (Wn(a) && u)
          throw new Ur(
            n + " contains both browserslist and package.json with browsers"
          );
        if (Wn(l) && u)
          throw new Ur(
            n + " contains both .browserslistrc and package.json with browsers"
          );
        if (Wn(a) && Wn(l))
          throw new Ur(
            n + " contains both .browserslistrc and browserslist"
          );
        return Wn(a) ? Eo.exports.readConfig(a) : Wn(l) ? Eo.exports.readConfig(l) : u;
      });
      return process.env.BROWSERSLIST_DISABLE_CACHE || r.forEach(function(n) {
        am[n] = s;
      }), s;
    }, "findConfig"),
    clearCaches: /* @__PURE__ */ i(function() {
      GT = !1, lm = {}, am = {}, this.cache = {};
    }, "clearCaches"),
    oldDataWarning: /* @__PURE__ */ i(function(t) {
      if (!GT && (GT = !0, !process.env.BROWSERSLIST_IGNORE_OLD_DATA)) {
        var r = GFe(t), s = Date.now() - VFe;
        r !== 0 && r < s && console.warn(
          `Browserslist: caniuse-lite is outdated. Please run:
  npx update-browserslist-db@latest
  Why you should do it regularly: https://github.com/browserslist/update-db#readme`
        );
      }
    }, "oldDataWarning"),
    currentNode: /* @__PURE__ */ i(function() {
      return "node " + process.versions.node;
    }, "currentNode"),
    env: process.env
  };
});

// ../node_modules/browserslist/index.js
var W8 = y((Ent, V8) => {
  var YFe = V4(), wi = t8().agents, KT = r8(), hm = require("path"), bn = n8(), Es = UT(), F8 = c8(), Vr = C8(), XFe = 365.259641 * 24 * 60 *
  60 * 1e3, L8 = "37", zFe = 14;
  function B8(e, t) {
    return (e + ".").indexOf(t + ".") === 0;
  }
  i(B8, "isVersionsMatch");
  function JFe(e) {
    var t = e.slice(1);
    return Ce.nodeVersions.some(function(r) {
      return B8(r, t);
    });
  }
  i(JFe, "isEolReleased");
  function w8(e) {
    return e.filter(function(t) {
      return typeof t == "string";
    });
  }
  i(w8, "normalize");
  function um(e) {
    var t = e;
    return e.split(".").length === 3 && (t = e.split(".").slice(0, -1).join(".")), t;
  }
  i(um, "normalizeElectron");
  function Sa(e) {
    return /* @__PURE__ */ i(function(r) {
      return e + " " + r;
    }, "mapName");
  }
  i(Sa, "nameMapper");
  function JT(e) {
    return parseInt(e.split(".")[0]);
  }
  i(JT, "getMajor");
  function cm(e, t) {
    if (e.length === 0) return [];
    var r = M8(e.map(JT)), s = r[r.length - t];
    if (!s)
      return e;
    for (var n = [], a = e.length - 1; a >= 0 && !(s > JT(e[a])); a--)
      n.unshift(e[a]);
    return n;
  }
  i(cm, "getMajorVersions");
  function M8(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.indexOf(e[r]) === -1 && t.push(e[r]);
    return t;
  }
  i(M8, "uniq");
  function mm(e, t, r) {
    for (var s in r)
      e[t + " " + s] = r[s];
  }
  i(mm, "fillUsage");
  function D8(e, t) {
    return t = parseFloat(t), e === ">" ? function(r) {
      return parseFloat(r) > t;
    } : e === ">=" ? function(r) {
      return parseFloat(r) >= t;
    } : e === "<" ? function(r) {
      return parseFloat(r) < t;
    } : function(r) {
      return parseFloat(r) <= t;
    };
  }
  i(D8, "generateFilter");
  function QFe(e, t) {
    return t = t.split(".").map(Ta), t[1] = t[1] || 0, t[2] = t[2] || 0, e === ">" ? function(r) {
      return r = r.split(".").map(Ta), uf(r, t) > 0;
    } : e === ">=" ? function(r) {
      return r = r.split(".").map(Ta), uf(r, t) >= 0;
    } : e === "<" ? function(r) {
      return r = r.split(".").map(Ta), uf(t, r) > 0;
    } : function(r) {
      return r = r.split(".").map(Ta), uf(t, r) >= 0;
    };
  }
  i(QFe, "generateSemverFilter");
  function Ta(e) {
    return parseInt(e);
  }
  i(Ta, "parseSimpleInt");
  function dm(e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }
  i(dm, "compare");
  function uf(e, t) {
    return dm(parseInt(e[0]), parseInt(t[0])) || dm(parseInt(e[1] || "0"), parseInt(t[1] || "0")) || dm(parseInt(e[2] || "0"), parseInt(t[2] ||
    "0"));
  }
  i(uf, "compareSemver");
  function I8(e, t) {
    switch (t = t.split(".").map(Ta), typeof t[1] > "u" && (t[1] = "x"), e) {
      case "<=":
        return function(r) {
          return r = r.split(".").map(Ta), _8(r, t) <= 0;
        };
      case ">=":
      default:
        return function(r) {
          return r = r.split(".").map(Ta), _8(r, t) >= 0;
        };
    }
  }
  i(I8, "semverFilterLoose");
  function _8(e, t) {
    return e[0] !== t[0] ? e[0] < t[0] ? -1 : 1 : t[1] === "x" ? 0 : e[1] !== t[1] ? e[1] < t[1] ? -1 : 1 : 0;
  }
  i(_8, "compareSemverLoose");
  function ZFe(e, t) {
    return e.versions.indexOf(t) !== -1 ? t : Ce.versionAliases[e.name][t] ? Ce.versionAliases[e.name][t] : !1;
  }
  i(ZFe, "resolveVersion");
  function fm(e, t) {
    var r = ZFe(e, t);
    return r || (e.versions.length === 1 ? e.versions[0] : !1);
  }
  i(fm, "normalizeVersion");
  function j8(e, t) {
    return e = e / 1e3, Object.keys(wi).reduce(function(r, s) {
      var n = xa(s, t);
      if (!n) return r;
      var a = Object.keys(n.releaseDate).filter(function(o) {
        var l = n.releaseDate[o];
        return l !== null && l >= e;
      });
      return r.concat(a.map(Sa(n.name)));
    }, []);
  }
  i(j8, "filterByYear");
  function O8(e) {
    return {
      name: e.name,
      versions: e.versions,
      released: e.released,
      releaseDate: e.releaseDate
    };
  }
  i(O8, "cloneData");
  function xa(e, t) {
    if (e = e.toLowerCase(), e = Ce.aliases[e] || e, t.mobileToDesktop && Ce.desktopNames[e]) {
      var r = Ce.data[Ce.desktopNames[e]];
      if (e === "android")
        return tLe(O8(Ce.data[e]), r);
      var s = O8(r);
      return s.name = e, s;
    }
    return Ce.data[e];
  }
  i(xa, "byName");
  function N8(e, t) {
    var r = t.indexOf(L8);
    return e.filter(function(s) {
      return /^(?:[2-4]\.|[34]$)/.test(s);
    }).concat(t.slice(r));
  }
  i(N8, "normalizeAndroidVersions");
  function eLe(e) {
    var t = {};
    for (var r in e)
      t[r] = e[r];
    return t;
  }
  i(eLe, "copyObject");
  function tLe(e, t) {
    return e.released = N8(e.released, t.released), e.versions = N8(e.versions, t.versions), e.releaseDate = eLe(e.releaseDate), e.released.
    forEach(function(r) {
      e.releaseDate[r] === void 0 && (e.releaseDate[r] = t.releaseDate[r]);
    }), e;
  }
  i(tLe, "normalizeAndroidData");
  function Ml(e, t) {
    var r = xa(e, t);
    if (!r) throw new Es("Unknown browser " + e);
    return r;
  }
  i(Ml, "checkName");
  function rLe(e) {
    return new Es(
      "Unknown browser query `" + e + "`. Maybe you are using old Browserslist or made typo in query."
    );
  }
  i(rLe, "unknownQuery");
  function pm(e, t, r, s) {
    var n = 1;
    switch (t) {
      case "android":
        if (s.mobileToDesktop) return e;
        var a = Ce.data.chrome.released;
        n = a.length - a.indexOf(L8);
        break;
      case "op_mob":
        var o = Ce.data.op_mob.released.slice(-1)[0];
        n = JT(o) - zFe + 1;
        break;
      default:
        return e;
    }
    return r <= n ? e.slice(-1) : e.slice(n - 1 - r);
  }
  i(pm, "filterJumps");
  function R8(e, t) {
    return typeof e == "string" && (e.indexOf("y") >= 0 || t && e.indexOf("a") >= 0);
  }
  i(R8, "isSupported");
  function jl(e, t) {
    return F8(QT, e).reduce(function(r, s, n) {
      if (s.not && n === 0)
        throw new Es(
          "Write any browsers query (for instance, `defaults`) before `" + s.query + "`"
        );
      var a = QT[s.type], o = a.select.call(Ce, t, s).map(function(u) {
        var c = u.split(" ");
        return c[1] === "0" ? c[0] + " " + xa(c[0], t).versions[0] : u;
      });
      if (s.compose === "and")
        return s.not ? r.filter(function(u) {
          return o.indexOf(u) === -1;
        }) : r.filter(function(u) {
          return o.indexOf(u) !== -1;
        });
      if (s.not) {
        var l = {};
        return o.forEach(function(u) {
          l[u] = !0;
        }), r.filter(function(u) {
          return !l[u];
        });
      }
      return r.concat(o);
    }, []);
  }
  i(jl, "resolve");
  function q8(e) {
    return typeof e > "u" && (e = {}), typeof e.path > "u" && (e.path = hm.resolve ? hm.resolve(".") : "."), e;
  }
  i(q8, "prepareOpts");
  function $8(e, t) {
    if (typeof e > "u" || e === null) {
      var r = Ce.loadConfig(t);
      r ? e = r : e = Ce.defaults;
    }
    return e;
  }
  i($8, "prepareQueries");
  function U8(e) {
    if (!(typeof e == "string" || Array.isArray(e)))
      throw new Es(
        "Browser queries must be an array or string. Got " + typeof e + "."
      );
  }
  i(U8, "checkQueries");
  var YT = {};
  function Ce(e, t) {
    t = q8(t), e = $8(e, t), U8(e);
    var r = {
      ignoreUnknownVersions: t.ignoreUnknownVersions,
      dangerousExtend: t.dangerousExtend,
      mobileToDesktop: t.mobileToDesktop,
      path: t.path,
      env: t.env
    };
    Vr.oldDataWarning(Ce.data);
    var s = Vr.getStat(t, Ce.data);
    if (s) {
      r.customUsage = {};
      for (var n in s)
        mm(r.customUsage, n, s[n]);
    }
    var a = JSON.stringify([e, r]);
    if (YT[a]) return YT[a];
    var o = M8(jl(e, r)).sort(function(l, u) {
      if (l = l.split(" "), u = u.split(" "), l[0] === u[0]) {
        var c = l[1].split("-")[0], f = u[1].split("-")[0];
        return uf(f.split("."), c.split("."));
      } else
        return dm(l[0], u[0]);
    });
    return Vr.env.BROWSERSLIST_DISABLE_CACHE || (YT[a] = o), o;
  }
  i(Ce, "browserslist");
  Ce.parse = function(e, t) {
    return t = q8(t), e = $8(e, t), U8(e), F8(QT, e);
  };
  Ce.cache = {};
  Ce.data = {};
  Ce.usage = {
    global: {},
    custom: null
  };
  Ce.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
  Ce.aliases = {
    fx: "firefox",
    ff: "firefox",
    ios: "ios_saf",
    explorer: "ie",
    blackberry: "bb",
    explorermobile: "ie_mob",
    operamini: "op_mini",
    operamobile: "op_mob",
    chromeandroid: "and_chr",
    firefoxandroid: "and_ff",
    ucandroid: "and_uc",
    qqandroid: "and_qq"
  };
  Ce.desktopNames = {
    and_chr: "chrome",
    and_ff: "firefox",
    ie_mob: "ie",
    android: "chrome"
    // has extra processing logic
  };
  Ce.versionAliases = {};
  Ce.clearCaches = Vr.clearCaches;
  Ce.parseConfig = Vr.parseConfig;
  Ce.readConfig = Vr.readConfig;
  Ce.findConfig = Vr.findConfig;
  Ce.loadConfig = Vr.loadConfig;
  Ce.coverage = function(e, t) {
    var r;
    if (typeof t > "u")
      r = Ce.usage.global;
    else if (t === "my stats") {
      var s = {};
      s.path = hm.resolve ? hm.resolve(".") : ".";
      var n = Vr.getStat(s);
      if (!n)
        throw new Es("Custom usage statistics was not provided");
      r = {};
      for (var a in n)
        mm(r, a, n[a]);
    } else if (typeof t == "string")
      t.length > 2 ? t = t.toLowerCase() : t = t.toUpperCase(), Vr.loadCountry(Ce.usage, t, Ce.data), r = Ce.usage[t];
    else {
      "dataByBrowser" in t && (t = t.dataByBrowser), r = {};
      for (var o in t)
        for (var l in t[o])
          r[o + " " + l] = t[o][l];
    }
    return e.reduce(function(u, c) {
      var f = r[c];
      return f === void 0 && (f = r[c.replace(/ \S+$/, " 0")]), u + (f || 0);
    }, 0);
  };
  function XT(e, t) {
    var r = Ce.nodeVersions.filter(function(s) {
      return B8(s, t.version);
    });
    if (r.length === 0) {
      if (e.ignoreUnknownVersions)
        return [];
      throw new Es(
        "Unknown version " + t.version + " of Node.js"
      );
    }
    return ["node " + r[r.length - 1]];
  }
  i(XT, "nodeQuery");
  function zT(e, t) {
    var r = parseInt(t.year), s = parseInt(t.month || "01") - 1, n = parseInt(t.day || "01");
    return j8(Date.UTC(r, s, n, 0, 0, 0), e);
  }
  i(zT, "sinceQuery");
  function k8(e, t) {
    var r = parseFloat(t.coverage), s = Ce.usage.global;
    if (t.place)
      if (t.place.match(/^my\s+stats$/i)) {
        if (!e.customUsage)
          throw new Es("Custom usage statistics was not provided");
        s = e.customUsage;
      } else {
        var n;
        t.place.length === 2 ? n = t.place.toUpperCase() : n = t.place.toLowerCase(), Vr.loadCountry(Ce.usage, n, Ce.data), s = Ce.usage[n];
      }
    for (var a = Object.keys(s).sort(function(f, p) {
      return s[p] - s[f];
    }), o = 0, l = [], u, c = 0; c < a.length && (u = a[c], !(s[u] === 0 || (o += s[u], l.push(u), o >= r))); c++)
      ;
    return l;
  }
  i(k8, "coverQuery");
  var QT = {
    last_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Object.keys(wi).reduce(function(r, s) {
          var n = xa(s, e);
          if (!n) return r;
          var a = cm(n.released, t.versions);
          return a = a.map(Sa(n.name)), a = pm(a, n.name, t.versions, e), r.concat(a);
        }, []);
      }, "select")
    },
    last_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Object.keys(wi).reduce(function(r, s) {
          var n = xa(s, e);
          if (!n) return r;
          var a = n.released.slice(-t.versions);
          return a = a.map(Sa(n.name)), a = pm(a, n.name, t.versions, e), r.concat(a);
        }, []);
      }, "select")
    },
    last_electron_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = cm(Object.keys(bn), t.versions);
        return r.map(function(s) {
          return "chrome " + bn[s];
        });
      }, "select")
    },
    last_node_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return cm(Ce.nodeVersions, t.versions).map(
          function(r) {
            return "node " + r;
          }
        );
      }, "select")
    },
    last_browser_major_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Ml(t.browser, e), s = cm(r.released, t.versions), n = s.map(Sa(r.name));
        return n = pm(n, r.name, t.versions, e), n;
      }, "select")
    },
    last_electron_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Object.keys(bn).slice(-t.versions).map(function(r) {
          return "chrome " + bn[r];
        });
      }, "select")
    },
    last_node_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Ce.nodeVersions.slice(-t.versions).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    last_browser_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Ml(t.browser, e), s = r.released.slice(-t.versions).map(Sa(r.name));
        return s = pm(s, r.name, t.versions, e), s;
      }, "select")
    },
    unreleased_versions: {
      matches: [],
      regexp: /^unreleased\s+versions$/i,
      select: /* @__PURE__ */ i(function(e) {
        return Object.keys(wi).reduce(function(t, r) {
          var s = xa(r, e);
          if (!s) return t;
          var n = s.versions.filter(function(a) {
            return s.released.indexOf(a) === -1;
          });
          return n = n.map(Sa(s.name)), t.concat(n);
        }, []);
      }, "select")
    },
    unreleased_electron_versions: {
      matches: [],
      regexp: /^unreleased\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ i(function() {
        return [];
      }, "select")
    },
    unreleased_browser_versions: {
      matches: ["browser"],
      regexp: /^unreleased\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Ml(t.browser, e);
        return r.versions.filter(function(s) {
          return r.released.indexOf(s) === -1;
        }).map(Sa(r.name));
      }, "select")
    },
    last_years: {
      matches: ["years"],
      regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return j8(Date.now() - XFe * t.years, e);
      }, "select")
    },
    since_y: {
      matches: ["year"],
      regexp: /^since (\d+)$/i,
      select: zT
    },
    since_y_m: {
      matches: ["year", "month"],
      regexp: /^since (\d+)-(\d+)$/i,
      select: zT
    },
    since_y_m_d: {
      matches: ["year", "month", "day"],
      regexp: /^since (\d+)-(\d+)-(\d+)$/i,
      select: zT
    },
    popularity: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = parseFloat(t.popularity), s = Ce.usage.global;
        return Object.keys(s).reduce(function(n, a) {
          return t.sign === ">" ? s[a] > r && n.push(a) : t.sign === "<" ? s[a] < r && n.push(a) : t.sign === "<=" ? s[a] <= r && n.push(a) :
          s[a] >= r && n.push(a), n;
        }, []);
      }, "select")
    },
    popularity_in_my_stats: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = parseFloat(t.popularity);
        if (!e.customUsage)
          throw new Es("Custom usage statistics was not provided");
        var s = e.customUsage;
        return Object.keys(s).reduce(function(n, a) {
          var o = s[a];
          return o == null || (t.sign === ">" ? o > r && n.push(a) : t.sign === "<" ? o < r && n.push(a) : t.sign === "<=" ? o <= r && n.push(
          a) : o >= r && n.push(a)), n;
        }, []);
      }, "select")
    },
    popularity_in_config_stats: {
      matches: ["sign", "popularity", "config"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = parseFloat(t.popularity), s = Vr.loadStat(e, t.config, Ce.data);
        if (s) {
          e.customUsage = {};
          for (var n in s)
            mm(e.customUsage, n, s[n]);
        }
        if (!e.customUsage)
          throw new Es("Custom usage statistics was not provided");
        var a = e.customUsage;
        return Object.keys(a).reduce(function(o, l) {
          var u = a[l];
          return u == null || (t.sign === ">" ? u > r && o.push(l) : t.sign === "<" ? u < r && o.push(l) : t.sign === "<=" ? u <= r && o.push(
          l) : u >= r && o.push(l)), o;
        }, []);
      }, "select")
    },
    popularity_in_place: {
      matches: ["sign", "popularity", "place"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = parseFloat(t.popularity), s = t.place;
        s.length === 2 ? s = s.toUpperCase() : s = s.toLowerCase(), Vr.loadCountry(Ce.usage, s, Ce.data);
        var n = Ce.usage[s];
        return Object.keys(n).reduce(function(a, o) {
          var l = n[o];
          return l == null || (t.sign === ">" ? l > r && a.push(o) : t.sign === "<" ? l < r && a.push(o) : t.sign === "<=" ? l <= r && a.push(
          o) : l >= r && a.push(o)), a;
        }, []);
      }, "select")
    },
    cover: {
      matches: ["coverage"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
      select: k8
    },
    cover_in: {
      matches: ["coverage", "place"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
      select: k8
    },
    supports: {
      matches: ["supportType", "feature"],
      regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
      select: /* @__PURE__ */ i(function(e, t) {
        Vr.loadFeature(Ce.cache, t.feature);
        var r = t.supportType !== "fully", s = Ce.cache[t.feature], n = [];
        for (var a in s) {
          var o = xa(a, e), l = e.mobileToDesktop && a in Ce.desktopNames && R8(s[a][o.released.slice(-1)[0]], r);
          o.versions.forEach(function(u) {
            var c = s[a][u];
            c === void 0 && l && (c = s[Ce.desktopNames[a]][u]), R8(c, r) && n.push(a + " " + u);
          });
        }
        return n;
      }, "select")
    },
    electron_range: {
      matches: ["from", "to"],
      regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = um(t.from), s = um(t.to), n = parseFloat(t.from), a = parseFloat(t.to);
        if (!bn[r])
          throw new Es("Unknown version " + n + " of electron");
        if (!bn[s])
          throw new Es("Unknown version " + a + " of electron");
        return Object.keys(bn).filter(function(o) {
          var l = parseFloat(o);
          return l >= n && l <= a;
        }).map(function(o) {
          return "chrome " + bn[o];
        });
      }, "select")
    },
    node_range: {
      matches: ["from", "to"],
      regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Ce.nodeVersions.filter(I8(">=", t.from)).filter(I8("<=", t.to)).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    browser_range: {
      matches: ["browser", "from", "to"],
      regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Ml(t.browser, e), s = parseFloat(fm(r, t.from) || t.from), n = parseFloat(fm(r, t.to) || t.to);
        function a(o) {
          var l = parseFloat(o);
          return l >= s && l <= n;
        }
        return i(a, "filter"), r.released.filter(a).map(Sa(r.name));
      }, "select")
    },
    electron_ray: {
      matches: ["sign", "version"],
      regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = um(t.version);
        return Object.keys(bn).filter(D8(t.sign, r)).map(function(s) {
          return "chrome " + bn[s];
        });
      }, "select")
    },
    node_ray: {
      matches: ["sign", "version"],
      regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Ce.nodeVersions.filter(QFe(t.sign, t.version)).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    browser_ray: {
      matches: ["browser", "sign", "version"],
      regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = t.version, s = Ml(t.browser, e), n = Ce.versionAliases[s.name][r];
        return n && (r = n), s.released.filter(D8(t.sign, r)).map(function(a) {
          return s.name + " " + a;
        });
      }, "select")
    },
    firefox_esr: {
      matches: [],
      regexp: /^(firefox|ff|fx)\s+esr$/i,
      select: /* @__PURE__ */ i(function() {
        return ["firefox 115"];
      }, "select")
    },
    opera_mini_all: {
      matches: [],
      regexp: /(operamini|op_mini)\s+all/i,
      select: /* @__PURE__ */ i(function() {
        return ["op_mini all"];
      }, "select")
    },
    electron_version: {
      matches: ["version"],
      regexp: /^electron\s+([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = um(t.version), s = bn[r];
        if (!s)
          throw new Es(
            "Unknown version " + t.version + " of electron"
          );
        return ["chrome " + s];
      }, "select")
    },
    node_major_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+)$/i,
      select: XT
    },
    node_minor_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+)$/i,
      select: XT
    },
    node_patch_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
      select: XT
    },
    current_node: {
      matches: [],
      regexp: /^current\s+node$/i,
      select: /* @__PURE__ */ i(function(e) {
        return [Vr.currentNode(jl, e)];
      }, "select")
    },
    maintained_node: {
      matches: [],
      regexp: /^maintained\s+node\s+versions$/i,
      select: /* @__PURE__ */ i(function(e) {
        var t = Date.now(), r = Object.keys(KT).filter(function(s) {
          return t < Date.parse(KT[s].end) && t > Date.parse(KT[s].start) && JFe(s);
        }).map(function(s) {
          return "node " + s.slice(1);
        });
        return jl(r, e);
      }, "select")
    },
    phantomjs_1_9: {
      matches: [],
      regexp: /^phantomjs\s+1.9$/i,
      select: /* @__PURE__ */ i(function() {
        return ["safari 5"];
      }, "select")
    },
    phantomjs_2_1: {
      matches: [],
      regexp: /^phantomjs\s+2.1$/i,
      select: /* @__PURE__ */ i(function() {
        return ["safari 6"];
      }, "select")
    },
    browser_version: {
      matches: ["browser", "version"],
      regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = t.version;
        /^tp$/i.test(r) && (r = "TP");
        var s = Ml(t.browser, e), n = fm(s, r);
        if (n)
          r = n;
        else if (r.indexOf(".") === -1 ? n = r + ".0" : n = r.replace(/\.0$/, ""), n = fm(s, n), n)
          r = n;
        else {
          if (e.ignoreUnknownVersions)
            return [];
          throw new Es(
            "Unknown version " + r + " of " + t.browser
          );
        }
        return [s.name + " " + r];
      }, "select")
    },
    browserslist_config: {
      matches: [],
      regexp: /^browserslist config$/i,
      select: /* @__PURE__ */ i(function(e) {
        return Ce(void 0, e);
      }, "select")
    },
    extends: {
      matches: ["config"],
      regexp: /^extends (.+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return jl(Vr.loadQueries(e, t.config), e);
      }, "select")
    },
    defaults: {
      matches: [],
      regexp: /^defaults$/i,
      select: /* @__PURE__ */ i(function(e) {
        return jl(Ce.defaults, e);
      }, "select")
    },
    dead: {
      matches: [],
      regexp: /^dead$/i,
      select: /* @__PURE__ */ i(function(e) {
        var t = [
          "Baidu >= 0",
          "ie <= 11",
          "ie_mob <= 11",
          "bb <= 10",
          "op_mob <= 12.1",
          "samsung 4"
        ];
        return jl(t, e);
      }, "select")
    },
    unknown: {
      matches: [],
      regexp: /^(\w+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        throw xa(t.query, e) ? new Es(
          "Specify versions in Browserslist query for browser " + t.query
        ) : rLe(t.query);
      }, "select")
    }
  };
  (function() {
    for (var e in wi) {
      var t = wi[e];
      Ce.data[e] = {
        name: e,
        versions: w8(wi[e].versions),
        released: w8(wi[e].versions.slice(0, -3)),
        releaseDate: wi[e].release_date
      }, mm(Ce.usage.global, e, t.usage_global), Ce.versionAliases[e] = {};
      for (var r = 0; r < t.versions.length; r++) {
        var s = t.versions[r];
        if (s && s.indexOf("-") !== -1)
          for (var n = s.split("-"), a = 0; a < n.length; a++)
            Ce.versionAliases[e][n[a]] = s;
      }
    }
    Ce.nodeVersions = YFe.map(function(o) {
      return o.version;
    });
  })();
  V8.exports = Ce;
});

// ../node_modules/@babel/helper-validator-option/lib/find-suggestion.js
var ex = y((ZT) => {
  "use strict";
  Object.defineProperty(ZT, "__esModule", {
    value: !0
  });
  ZT.findSuggestion = nLe;
  var {
    min: H8
  } = Math;
  function sLe(e, t) {
    let r = [], s = [], n, a, o = e.length, l = t.length;
    if (!o)
      return l;
    if (!l)
      return o;
    for (a = 0; a <= l; a++)
      r[a] = a;
    for (n = 1; n <= o; n++) {
      for (s = [n], a = 1; a <= l; a++)
        s[a] = e[n - 1] === t[a - 1] ? r[a - 1] : H8(r[a - 1], r[a], s[a - 1]) + 1;
      r = s;
    }
    return s[l];
  }
  i(sLe, "levenshtein");
  function nLe(e, t) {
    let r = t.map((s) => sLe(s, e));
    return t[r.indexOf(H8(...r))];
  }
  i(nLe, "findSuggestion");
});

// ../node_modules/@babel/helper-validator-option/lib/validator.js
var G8 = y((ym) => {
  "use strict";
  Object.defineProperty(ym, "__esModule", {
    value: !0
  });
  ym.OptionValidator = void 0;
  var iLe = ex(), tx = class {
    static {
      i(this, "OptionValidator");
    }
    constructor(t) {
      this.descriptor = t;
    }
    validateTopLevelOptions(t, r) {
      let s = Object.keys(r);
      for (let n of Object.keys(t))
        if (!s.includes(n))
          throw new Error(this.formatMessage(`'${n}' is not a valid top-level option.
- Did you mean '${(0, iLe.findSuggestion)(n, s)}'?`));
    }
    validateBooleanOption(t, r, s) {
      return r === void 0 ? s : (this.invariant(typeof r == "boolean", `'${t}' option must be a boolean.`), r);
    }
    validateStringOption(t, r, s) {
      return r === void 0 ? s : (this.invariant(typeof r == "string", `'${t}' option must be a string.`), r);
    }
    invariant(t, r) {
      if (!t)
        throw new Error(this.formatMessage(r));
    }
    formatMessage(t) {
      return `${this.descriptor}: ${t}`;
    }
  };
  ym.OptionValidator = tx;
});

// ../node_modules/@babel/helper-validator-option/lib/index.js
var bm = y((gm) => {
  "use strict";
  Object.defineProperty(gm, "__esModule", {
    value: !0
  });
  Object.defineProperty(gm, "OptionValidator", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return aLe.OptionValidator;
    }, "get")
  });
  Object.defineProperty(gm, "findSuggestion", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return oLe.findSuggestion;
    }, "get")
  });
  var aLe = G8(), oLe = ex();
});

// ../node_modules/@babel/compat-data/data/native-modules.json
var K8 = y((wnt, lLe) => {
  lLe.exports = {
    "es6.module": {
      chrome: "61",
      and_chr: "61",
      edge: "16",
      firefox: "60",
      and_ff: "60",
      node: "13.2.0",
      opera: "48",
      op_mob: "45",
      safari: "10.1",
      ios: "10.3",
      samsung: "8.2",
      android: "61",
      electron: "2.0",
      ios_saf: "10.3"
    }
  };
});

// ../node_modules/@babel/compat-data/native-modules.js
var X8 = y((Dnt, Y8) => {
  Y8.exports = K8();
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/iterator.js
var J8 = y((Int, z8) => {
  "use strict";
  z8.exports = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  };
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/yallist.js
var Z8 = y((_nt, Q8) => {
  "use strict";
  Q8.exports = xt;
  xt.Node = vo;
  xt.create = xt;
  function xt(e) {
    var t = this;
    if (t instanceof xt || (t = new xt()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
      e.forEach(function(n) {
        t.push(n);
      });
    else if (arguments.length > 0)
      for (var r = 0, s = arguments.length; r < s; r++)
        t.push(arguments[r]);
    return t;
  }
  i(xt, "Yallist");
  xt.prototype.removeNode = function(e) {
    if (e.list !== this)
      throw new Error("removing node which does not belong to this list");
    var t = e.next, r = e.prev;
    return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.
    next = null, e.prev = null, e.list = null, t;
  };
  xt.prototype.unshiftNode = function(e) {
    if (e !== this.head) {
      e.list && e.list.removeNode(e);
      var t = this.head;
      e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
    }
  };
  xt.prototype.pushNode = function(e) {
    if (e !== this.tail) {
      e.list && e.list.removeNode(e);
      var t = this.tail;
      e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
    }
  };
  xt.prototype.push = function() {
    for (var e = 0, t = arguments.length; e < t; e++)
      cLe(this, arguments[e]);
    return this.length;
  };
  xt.prototype.unshift = function() {
    for (var e = 0, t = arguments.length; e < t; e++)
      fLe(this, arguments[e]);
    return this.length;
  };
  xt.prototype.pop = function() {
    if (this.tail) {
      var e = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
    }
  };
  xt.prototype.shift = function() {
    if (this.head) {
      var e = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
    }
  };
  xt.prototype.forEach = function(e, t) {
    t = t || this;
    for (var r = this.head, s = 0; r !== null; s++)
      e.call(t, r.value, s, this), r = r.next;
  };
  xt.prototype.forEachReverse = function(e, t) {
    t = t || this;
    for (var r = this.tail, s = this.length - 1; r !== null; s--)
      e.call(t, r.value, s, this), r = r.prev;
  };
  xt.prototype.get = function(e) {
    for (var t = 0, r = this.head; r !== null && t < e; t++)
      r = r.next;
    if (t === e && r !== null)
      return r.value;
  };
  xt.prototype.getReverse = function(e) {
    for (var t = 0, r = this.tail; r !== null && t < e; t++)
      r = r.prev;
    if (t === e && r !== null)
      return r.value;
  };
  xt.prototype.map = function(e, t) {
    t = t || this;
    for (var r = new xt(), s = this.head; s !== null; )
      r.push(e.call(t, s.value, this)), s = s.next;
    return r;
  };
  xt.prototype.mapReverse = function(e, t) {
    t = t || this;
    for (var r = new xt(), s = this.tail; s !== null; )
      r.push(e.call(t, s.value, this)), s = s.prev;
    return r;
  };
  xt.prototype.reduce = function(e, t) {
    var r, s = this.head;
    if (arguments.length > 1)
      r = t;
    else if (this.head)
      s = this.head.next, r = this.head.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var n = 0; s !== null; n++)
      r = e(r, s.value, n), s = s.next;
    return r;
  };
  xt.prototype.reduceReverse = function(e, t) {
    var r, s = this.tail;
    if (arguments.length > 1)
      r = t;
    else if (this.tail)
      s = this.tail.prev, r = this.tail.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var n = this.length - 1; s !== null; n--)
      r = e(r, s.value, n), s = s.prev;
    return r;
  };
  xt.prototype.toArray = function() {
    for (var e = new Array(this.length), t = 0, r = this.head; r !== null; t++)
      e[t] = r.value, r = r.next;
    return e;
  };
  xt.prototype.toArrayReverse = function() {
    for (var e = new Array(this.length), t = 0, r = this.tail; r !== null; t++)
      e[t] = r.value, r = r.prev;
    return e;
  };
  xt.prototype.slice = function(e, t) {
    t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
    var r = new xt();
    if (t < e || t < 0)
      return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var s = 0, n = this.head; n !== null && s < e; s++)
      n = n.next;
    for (; n !== null && s < t; s++, n = n.next)
      r.push(n.value);
    return r;
  };
  xt.prototype.sliceReverse = function(e, t) {
    t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
    var r = new xt();
    if (t < e || t < 0)
      return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var s = this.length, n = this.tail; n !== null && s > t; s--)
      n = n.prev;
    for (; n !== null && s > e; s--, n = n.prev)
      r.push(n.value);
    return r;
  };
  xt.prototype.splice = function(e, t) {
    e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
    for (var r = 0, s = this.head; s !== null && r < e; r++)
      s = s.next;
    for (var n = [], r = 0; s && r < t; r++)
      n.push(s.value), s = this.removeNode(s);
    s === null && (s = this.tail), s !== this.head && s !== this.tail && (s = s.prev);
    for (var r = 2; r < arguments.length; r++)
      s = uLe(this, s, arguments[r]);
    return n;
  };
  xt.prototype.reverse = function() {
    for (var e = this.head, t = this.tail, r = e; r !== null; r = r.prev) {
      var s = r.prev;
      r.prev = r.next, r.next = s;
    }
    return this.head = t, this.tail = e, this;
  };
  function uLe(e, t, r) {
    var s = t === e.head ? new vo(r, null, t, e) : new vo(r, t, t.next, e);
    return s.next === null && (e.tail = s), s.prev === null && (e.head = s), e.length++, s;
  }
  i(uLe, "insert");
  function cLe(e, t) {
    e.tail = new vo(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
  }
  i(cLe, "push");
  function fLe(e, t) {
    e.head = new vo(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
  }
  i(fLe, "unshift");
  function vo(e, t, r, s) {
    if (!(this instanceof vo))
      return new vo(e, t, r, s);
    this.list = s, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
  }
  i(vo, "Node");
  try {
    J8()(xt);
  } catch {
  }
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/index.js
var n6 = y((Nnt, s6) => {
  "use strict";
  var pLe = Z8(), So = Symbol("max"), Ii = Symbol("length"), ql = Symbol("lengthCalculator"), ff = Symbol("allowStale"), To = Symbol("maxAge"),
  Di = Symbol("dispose"), e6 = Symbol("noDisposeOnSet"), Ir = Symbol("lruList"), En = Symbol("cache"), r6 = Symbol("updateAgeOnGet"), rx = /* @__PURE__ */ i(
  () => 1, "naiveLength"), nx = class {
    static {
      i(this, "LRUCache");
    }
    constructor(t) {
      if (typeof t == "number" && (t = { max: t }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
        throw new TypeError("max must be a non-negative number");
      let r = this[So] = t.max || 1 / 0, s = t.length || rx;
      if (this[ql] = typeof s != "function" ? rx : s, this[ff] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
        throw new TypeError("maxAge must be a number");
      this[To] = t.maxAge || 0, this[Di] = t.dispose, this[e6] = t.noDisposeOnSet || !1, this[r6] = t.updateAgeOnGet || !1, this.reset();
    }
    // resize the cache when the max changes.
    set max(t) {
      if (typeof t != "number" || t < 0)
        throw new TypeError("max must be a non-negative number");
      this[So] = t || 1 / 0, cf(this);
    }
    get max() {
      return this[So];
    }
    set allowStale(t) {
      this[ff] = !!t;
    }
    get allowStale() {
      return this[ff];
    }
    set maxAge(t) {
      if (typeof t != "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[To] = t, cf(this);
    }
    get maxAge() {
      return this[To];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(t) {
      typeof t != "function" && (t = rx), t !== this[ql] && (this[ql] = t, this[Ii] = 0, this[Ir].forEach((r) => {
        r.length = this[ql](r.value, r.key), this[Ii] += r.length;
      })), cf(this);
    }
    get lengthCalculator() {
      return this[ql];
    }
    get length() {
      return this[Ii];
    }
    get itemCount() {
      return this[Ir].length;
    }
    rforEach(t, r) {
      r = r || this;
      for (let s = this[Ir].tail; s !== null; ) {
        let n = s.prev;
        t6(this, t, s, r), s = n;
      }
    }
    forEach(t, r) {
      r = r || this;
      for (let s = this[Ir].head; s !== null; ) {
        let n = s.next;
        t6(this, t, s, r), s = n;
      }
    }
    keys() {
      return this[Ir].toArray().map((t) => t.key);
    }
    values() {
      return this[Ir].toArray().map((t) => t.value);
    }
    reset() {
      this[Di] && this[Ir] && this[Ir].length && this[Ir].forEach((t) => this[Di](t.key, t.value)), this[En] = /* @__PURE__ */ new Map(), this[Ir] =
      new pLe(), this[Ii] = 0;
    }
    dump() {
      return this[Ir].map((t) => Em(this, t) ? !1 : {
        k: t.key,
        v: t.value,
        e: t.now + (t.maxAge || 0)
      }).toArray().filter((t) => t);
    }
    dumpLru() {
      return this[Ir];
    }
    set(t, r, s) {
      if (s = s || this[To], s && typeof s != "number")
        throw new TypeError("maxAge must be a number");
      let n = s ? Date.now() : 0, a = this[ql](r, t);
      if (this[En].has(t)) {
        if (a > this[So])
          return $l(this, this[En].get(t)), !1;
        let u = this[En].get(t).value;
        return this[Di] && (this[e6] || this[Di](t, u.value)), u.now = n, u.maxAge = s, u.value = r, this[Ii] += a - u.length, u.length = a,
        this.get(t), cf(this), !0;
      }
      let o = new ix(t, r, a, n, s);
      return o.length > this[So] ? (this[Di] && this[Di](t, r), !1) : (this[Ii] += o.length, this[Ir].unshift(o), this[En].set(t, this[Ir].head),
      cf(this), !0);
    }
    has(t) {
      if (!this[En].has(t)) return !1;
      let r = this[En].get(t).value;
      return !Em(this, r);
    }
    get(t) {
      return sx(this, t, !0);
    }
    peek(t) {
      return sx(this, t, !1);
    }
    pop() {
      let t = this[Ir].tail;
      return t ? ($l(this, t), t.value) : null;
    }
    del(t) {
      $l(this, this[En].get(t));
    }
    load(t) {
      this.reset();
      let r = Date.now();
      for (let s = t.length - 1; s >= 0; s--) {
        let n = t[s], a = n.e || 0;
        if (a === 0)
          this.set(n.k, n.v);
        else {
          let o = a - r;
          o > 0 && this.set(n.k, n.v, o);
        }
      }
    }
    prune() {
      this[En].forEach((t, r) => sx(this, r, !1));
    }
  }, sx = /* @__PURE__ */ i((e, t, r) => {
    let s = e[En].get(t);
    if (s) {
      let n = s.value;
      if (Em(e, n)) {
        if ($l(e, s), !e[ff])
          return;
      } else
        r && (e[r6] && (s.value.now = Date.now()), e[Ir].unshiftNode(s));
      return n.value;
    }
  }, "get"), Em = /* @__PURE__ */ i((e, t) => {
    if (!t || !t.maxAge && !e[To])
      return !1;
    let r = Date.now() - t.now;
    return t.maxAge ? r > t.maxAge : e[To] && r > e[To];
  }, "isStale"), cf = /* @__PURE__ */ i((e) => {
    if (e[Ii] > e[So])
      for (let t = e[Ir].tail; e[Ii] > e[So] && t !== null; ) {
        let r = t.prev;
        $l(e, t), t = r;
      }
  }, "trim"), $l = /* @__PURE__ */ i((e, t) => {
    if (t) {
      let r = t.value;
      e[Di] && e[Di](r.key, r.value), e[Ii] -= r.length, e[En].delete(r.key), e[Ir].removeNode(t);
    }
  }, "del"), ix = class {
    static {
      i(this, "Entry");
    }
    constructor(t, r, s, n, a) {
      this.key = t, this.value = r, this.length = s, this.now = n, this.maxAge = a || 0;
    }
  }, t6 = /* @__PURE__ */ i((e, t, r, s) => {
    let n = r.value;
    Em(e, n) && ($l(e, r), e[ff] || (n = void 0)), n && t.call(s, n.value, n.key, e);
  }, "forEachStep");
  s6.exports = nx;
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/semver/semver.js
var mf = y(($e, u6) => {
  $e = u6.exports = Qe;
  var _t;
  typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? _t = /* @__PURE__ */ i(
  function() {
    var e = Array.prototype.slice.call(arguments, 0);
    e.unshift("SEMVER"), console.log.apply(console, e);
  }, "debug") : _t = /* @__PURE__ */ i(function() {
  }, "debug");
  $e.SEMVER_SPEC_VERSION = "2.0.0";
  var pf = 256, vm = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, ax = 16, dLe = pf - 6, Ul = $e.re = [], It = $e.safeRe = [], ee = $e.src = [], G = $e.tokens = {}, o6 = 0;
  function it(e) {
    G[e] = o6++;
  }
  i(it, "tok");
  var lx = "[a-zA-Z0-9-]", ox = [
    ["\\s", 1],
    ["\\d", pf],
    [lx, dLe]
  ];
  function hf(e) {
    for (var t = 0; t < ox.length; t++) {
      var r = ox[t][0], s = ox[t][1];
      e = e.split(r + "*").join(r + "{0," + s + "}").split(r + "+").join(r + "{1," + s + "}");
    }
    return e;
  }
  i(hf, "makeSafeRe");
  it("NUMERICIDENTIFIER");
  ee[G.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  it("NUMERICIDENTIFIERLOOSE");
  ee[G.NUMERICIDENTIFIERLOOSE] = "\\d+";
  it("NONNUMERICIDENTIFIER");
  ee[G.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + lx + "*";
  it("MAINVERSION");
  ee[G.MAINVERSION] = "(" + ee[G.NUMERICIDENTIFIER] + ")\\.(" + ee[G.NUMERICIDENTIFIER] + ")\\.(" + ee[G.NUMERICIDENTIFIER] + ")";
  it("MAINVERSIONLOOSE");
  ee[G.MAINVERSIONLOOSE] = "(" + ee[G.NUMERICIDENTIFIERLOOSE] + ")\\.(" + ee[G.NUMERICIDENTIFIERLOOSE] + ")\\.(" + ee[G.NUMERICIDENTIFIERLOOSE] +
  ")";
  it("PRERELEASEIDENTIFIER");
  ee[G.PRERELEASEIDENTIFIER] = "(?:" + ee[G.NUMERICIDENTIFIER] + "|" + ee[G.NONNUMERICIDENTIFIER] + ")";
  it("PRERELEASEIDENTIFIERLOOSE");
  ee[G.PRERELEASEIDENTIFIERLOOSE] = "(?:" + ee[G.NUMERICIDENTIFIERLOOSE] + "|" + ee[G.NONNUMERICIDENTIFIER] + ")";
  it("PRERELEASE");
  ee[G.PRERELEASE] = "(?:-(" + ee[G.PRERELEASEIDENTIFIER] + "(?:\\." + ee[G.PRERELEASEIDENTIFIER] + ")*))";
  it("PRERELEASELOOSE");
  ee[G.PRERELEASELOOSE] = "(?:-?(" + ee[G.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + ee[G.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  it("BUILDIDENTIFIER");
  ee[G.BUILDIDENTIFIER] = lx + "+";
  it("BUILD");
  ee[G.BUILD] = "(?:\\+(" + ee[G.BUILDIDENTIFIER] + "(?:\\." + ee[G.BUILDIDENTIFIER] + ")*))";
  it("FULL");
  it("FULLPLAIN");
  ee[G.FULLPLAIN] = "v?" + ee[G.MAINVERSION] + ee[G.PRERELEASE] + "?" + ee[G.BUILD] + "?";
  ee[G.FULL] = "^" + ee[G.FULLPLAIN] + "$";
  it("LOOSEPLAIN");
  ee[G.LOOSEPLAIN] = "[v=\\s]*" + ee[G.MAINVERSIONLOOSE] + ee[G.PRERELEASELOOSE] + "?" + ee[G.BUILD] + "?";
  it("LOOSE");
  ee[G.LOOSE] = "^" + ee[G.LOOSEPLAIN] + "$";
  it("GTLT");
  ee[G.GTLT] = "((?:<|>)?=?)";
  it("XRANGEIDENTIFIERLOOSE");
  ee[G.XRANGEIDENTIFIERLOOSE] = ee[G.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  it("XRANGEIDENTIFIER");
  ee[G.XRANGEIDENTIFIER] = ee[G.NUMERICIDENTIFIER] + "|x|X|\\*";
  it("XRANGEPLAIN");
  ee[G.XRANGEPLAIN] = "[v=\\s]*(" + ee[G.XRANGEIDENTIFIER] + ")(?:\\.(" + ee[G.XRANGEIDENTIFIER] + ")(?:\\.(" + ee[G.XRANGEIDENTIFIER] + ")(\
?:" + ee[G.PRERELEASE] + ")?" + ee[G.BUILD] + "?)?)?";
  it("XRANGEPLAINLOOSE");
  ee[G.XRANGEPLAINLOOSE] = "[v=\\s]*(" + ee[G.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + ee[G.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + ee[G.XRANGEIDENTIFIERLOOSE] +
  ")(?:" + ee[G.PRERELEASELOOSE] + ")?" + ee[G.BUILD] + "?)?)?";
  it("XRANGE");
  ee[G.XRANGE] = "^" + ee[G.GTLT] + "\\s*" + ee[G.XRANGEPLAIN] + "$";
  it("XRANGELOOSE");
  ee[G.XRANGELOOSE] = "^" + ee[G.GTLT] + "\\s*" + ee[G.XRANGEPLAINLOOSE] + "$";
  it("COERCE");
  ee[G.COERCE] = "(^|[^\\d])(\\d{1," + ax + "})(?:\\.(\\d{1," + ax + "}))?(?:\\.(\\d{1," + ax + "}))?(?:$|[^\\d])";
  it("COERCERTL");
  Ul[G.COERCERTL] = new RegExp(ee[G.COERCE], "g");
  It[G.COERCERTL] = new RegExp(hf(ee[G.COERCE]), "g");
  it("LONETILDE");
  ee[G.LONETILDE] = "(?:~>?)";
  it("TILDETRIM");
  ee[G.TILDETRIM] = "(\\s*)" + ee[G.LONETILDE] + "\\s+";
  Ul[G.TILDETRIM] = new RegExp(ee[G.TILDETRIM], "g");
  It[G.TILDETRIM] = new RegExp(hf(ee[G.TILDETRIM]), "g");
  var hLe = "$1~";
  it("TILDE");
  ee[G.TILDE] = "^" + ee[G.LONETILDE] + ee[G.XRANGEPLAIN] + "$";
  it("TILDELOOSE");
  ee[G.TILDELOOSE] = "^" + ee[G.LONETILDE] + ee[G.XRANGEPLAINLOOSE] + "$";
  it("LONECARET");
  ee[G.LONECARET] = "(?:\\^)";
  it("CARETTRIM");
  ee[G.CARETTRIM] = "(\\s*)" + ee[G.LONECARET] + "\\s+";
  Ul[G.CARETTRIM] = new RegExp(ee[G.CARETTRIM], "g");
  It[G.CARETTRIM] = new RegExp(hf(ee[G.CARETTRIM]), "g");
  var mLe = "$1^";
  it("CARET");
  ee[G.CARET] = "^" + ee[G.LONECARET] + ee[G.XRANGEPLAIN] + "$";
  it("CARETLOOSE");
  ee[G.CARETLOOSE] = "^" + ee[G.LONECARET] + ee[G.XRANGEPLAINLOOSE] + "$";
  it("COMPARATORLOOSE");
  ee[G.COMPARATORLOOSE] = "^" + ee[G.GTLT] + "\\s*(" + ee[G.LOOSEPLAIN] + ")$|^$";
  it("COMPARATOR");
  ee[G.COMPARATOR] = "^" + ee[G.GTLT] + "\\s*(" + ee[G.FULLPLAIN] + ")$|^$";
  it("COMPARATORTRIM");
  ee[G.COMPARATORTRIM] = "(\\s*)" + ee[G.GTLT] + "\\s*(" + ee[G.LOOSEPLAIN] + "|" + ee[G.XRANGEPLAIN] + ")";
  Ul[G.COMPARATORTRIM] = new RegExp(ee[G.COMPARATORTRIM], "g");
  It[G.COMPARATORTRIM] = new RegExp(hf(ee[G.COMPARATORTRIM]), "g");
  var yLe = "$1$2$3";
  it("HYPHENRANGE");
  ee[G.HYPHENRANGE] = "^\\s*(" + ee[G.XRANGEPLAIN] + ")\\s+-\\s+(" + ee[G.XRANGEPLAIN] + ")\\s*$";
  it("HYPHENRANGELOOSE");
  ee[G.HYPHENRANGELOOSE] = "^\\s*(" + ee[G.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + ee[G.XRANGEPLAINLOOSE] + ")\\s*$";
  it("STAR");
  ee[G.STAR] = "(<|>)?=?\\s*\\*";
  for (Hn = 0; Hn < o6; Hn++)
    _t(Hn, ee[Hn]), Ul[Hn] || (Ul[Hn] = new RegExp(ee[Hn]), It[Hn] = new RegExp(hf(ee[Hn])));
  var Hn;
  $e.parse = Po;
  function Po(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof Qe)
      return e;
    if (typeof e != "string" || e.length > pf)
      return null;
    var r = t.loose ? It[G.LOOSE] : It[G.FULL];
    if (!r.test(e))
      return null;
    try {
      return new Qe(e, t);
    } catch {
      return null;
    }
  }
  i(Po, "parse");
  $e.valid = gLe;
  function gLe(e, t) {
    var r = Po(e, t);
    return r ? r.version : null;
  }
  i(gLe, "valid");
  $e.clean = bLe;
  function bLe(e, t) {
    var r = Po(e.trim().replace(/^[=v]+/, ""), t);
    return r ? r.version : null;
  }
  i(bLe, "clean");
  $e.SemVer = Qe;
  function Qe(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof Qe) {
      if (e.loose === t.loose)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError("Invalid Version: " + e);
    if (e.length > pf)
      throw new TypeError("version is longer than " + pf + " characters");
    if (!(this instanceof Qe))
      return new Qe(e, t);
    _t("SemVer", e, t), this.options = t, this.loose = !!t.loose;
    var r = e.trim().match(t.loose ? It[G.LOOSE] : It[G.FULL]);
    if (!r)
      throw new TypeError("Invalid Version: " + e);
    if (this.raw = e, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > vm || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > vm || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > vm || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4] ? this.prerelease = r[4].split(".").map(function(s) {
      if (/^[0-9]+$/.test(s)) {
        var n = +s;
        if (n >= 0 && n < vm)
          return n;
      }
      return s;
    }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format();
  }
  i(Qe, "SemVer");
  Qe.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.
    join(".")), this.version;
  };
  Qe.prototype.toString = function() {
    return this.version;
  };
  Qe.prototype.compare = function(e) {
    return _t("SemVer.compare", this.version, this.options, e), e instanceof Qe || (e = new Qe(e, this.options)), this.compareMain(e) || this.
    comparePre(e);
  };
  Qe.prototype.compareMain = function(e) {
    return e instanceof Qe || (e = new Qe(e, this.options)), xo(this.major, e.major) || xo(this.minor, e.minor) || xo(this.patch, e.patch);
  };
  Qe.prototype.comparePre = function(e) {
    if (e instanceof Qe || (e = new Qe(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    var t = 0;
    do {
      var r = this.prerelease[t], s = e.prerelease[t];
      if (_t("prerelease compare", t, r, s), r === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === s)
        continue;
      return xo(r, s);
    } while (++t);
  };
  Qe.prototype.compareBuild = function(e) {
    e instanceof Qe || (e = new Qe(e, this.options));
    var t = 0;
    do {
      var r = this.build[t], s = e.build[t];
      if (_t("prerelease compare", t, r, s), r === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === s)
        continue;
      return xo(r, s);
    } while (++t);
  };
  Qe.prototype.inc = function(e, t) {
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t), this.inc("pre", t);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease =
        [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var r = this.prerelease.length; --r >= 0; )
            typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
          r === -1 && this.prerelease.push(0);
        }
        t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + e);
    }
    return this.format(), this.raw = this.version, this;
  };
  $e.inc = ELe;
  function ELe(e, t, r, s) {
    typeof r == "string" && (s = r, r = void 0);
    try {
      return new Qe(e, r).inc(t, s).version;
    } catch {
      return null;
    }
  }
  i(ELe, "inc");
  $e.diff = vLe;
  function vLe(e, t) {
    if (ux(e, t))
      return null;
    var r = Po(e), s = Po(t), n = "";
    if (r.prerelease.length || s.prerelease.length) {
      n = "pre";
      var a = "prerelease";
    }
    for (var o in r)
      if ((o === "major" || o === "minor" || o === "patch") && r[o] !== s[o])
        return n + o;
    return a;
  }
  i(vLe, "diff");
  $e.compareIdentifiers = xo;
  var i6 = /^[0-9]+$/;
  function xo(e, t) {
    var r = i6.test(e), s = i6.test(t);
    return r && s && (e = +e, t = +t), e === t ? 0 : r && !s ? -1 : s && !r ? 1 : e < t ? -1 : 1;
  }
  i(xo, "compareIdentifiers");
  $e.rcompareIdentifiers = SLe;
  function SLe(e, t) {
    return xo(t, e);
  }
  i(SLe, "rcompareIdentifiers");
  $e.major = TLe;
  function TLe(e, t) {
    return new Qe(e, t).major;
  }
  i(TLe, "major");
  $e.minor = xLe;
  function xLe(e, t) {
    return new Qe(e, t).minor;
  }
  i(xLe, "minor");
  $e.patch = PLe;
  function PLe(e, t) {
    return new Qe(e, t).patch;
  }
  i(PLe, "patch");
  $e.compare = _i;
  function _i(e, t, r) {
    return new Qe(e, r).compare(new Qe(t, r));
  }
  i(_i, "compare");
  $e.compareLoose = ALe;
  function ALe(e, t) {
    return _i(e, t, !0);
  }
  i(ALe, "compareLoose");
  $e.compareBuild = CLe;
  function CLe(e, t, r) {
    var s = new Qe(e, r), n = new Qe(t, r);
    return s.compare(n) || s.compareBuild(n);
  }
  i(CLe, "compareBuild");
  $e.rcompare = wLe;
  function wLe(e, t, r) {
    return _i(t, e, r);
  }
  i(wLe, "rcompare");
  $e.sort = DLe;
  function DLe(e, t) {
    return e.sort(function(r, s) {
      return $e.compareBuild(r, s, t);
    });
  }
  i(DLe, "sort");
  $e.rsort = ILe;
  function ILe(e, t) {
    return e.sort(function(r, s) {
      return $e.compareBuild(s, r, t);
    });
  }
  i(ILe, "rsort");
  $e.gt = df;
  function df(e, t, r) {
    return _i(e, t, r) > 0;
  }
  i(df, "gt");
  $e.lt = Sm;
  function Sm(e, t, r) {
    return _i(e, t, r) < 0;
  }
  i(Sm, "lt");
  $e.eq = ux;
  function ux(e, t, r) {
    return _i(e, t, r) === 0;
  }
  i(ux, "eq");
  $e.neq = l6;
  function l6(e, t, r) {
    return _i(e, t, r) !== 0;
  }
  i(l6, "neq");
  $e.gte = cx;
  function cx(e, t, r) {
    return _i(e, t, r) >= 0;
  }
  i(cx, "gte");
  $e.lte = fx;
  function fx(e, t, r) {
    return _i(e, t, r) <= 0;
  }
  i(fx, "lte");
  $e.cmp = Tm;
  function Tm(e, t, r, s) {
    switch (t) {
      case "===":
        return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
      case "!==":
        return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
      case "":
      case "=":
      case "==":
        return ux(e, r, s);
      case "!=":
        return l6(e, r, s);
      case ">":
        return df(e, r, s);
      case ">=":
        return cx(e, r, s);
      case "<":
        return Sm(e, r, s);
      case "<=":
        return fx(e, r, s);
      default:
        throw new TypeError("Invalid operator: " + t);
    }
  }
  i(Tm, "cmp");
  $e.Comparator = Gs;
  function Gs(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof Gs) {
      if (e.loose === !!t.loose)
        return e;
      e = e.value;
    }
    if (!(this instanceof Gs))
      return new Gs(e, t);
    e = e.trim().split(/\s+/).join(" "), _t("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === Vl ?
    this.value = "" : this.value = this.operator + this.semver.version, _t("comp", this);
  }
  i(Gs, "Comparator");
  var Vl = {};
  Gs.prototype.parse = function(e) {
    var t = this.options.loose ? It[G.COMPARATORLOOSE] : It[G.COMPARATOR], r = e.match(t);
    if (!r)
      throw new TypeError("Invalid comparator: " + e);
    this.operator = r[1] !== void 0 ? r[1] : "", this.operator === "=" && (this.operator = ""), r[2] ? this.semver = new Qe(r[2], this.options.
    loose) : this.semver = Vl;
  };
  Gs.prototype.toString = function() {
    return this.value;
  };
  Gs.prototype.test = function(e) {
    if (_t("Comparator.test", e, this.options.loose), this.semver === Vl || e === Vl)
      return !0;
    if (typeof e == "string")
      try {
        e = new Qe(e, this.options);
      } catch {
        return !1;
      }
    return Tm(e, this.operator, this.semver, this.options);
  };
  Gs.prototype.intersects = function(e, t) {
    if (!(e instanceof Gs))
      throw new TypeError("a Comparator is required");
    (!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    });
    var r;
    if (this.operator === "")
      return this.value === "" ? !0 : (r = new lr(e.value, t), xm(this.value, r, t));
    if (e.operator === "")
      return e.value === "" ? !0 : (r = new lr(this.value, t), xm(e.semver, r, t));
    var s = (this.operator === ">=" || this.operator === ">") && (e.operator === ">=" || e.operator === ">"), n = (this.operator === "<=" ||
    this.operator === "<") && (e.operator === "<=" || e.operator === "<"), a = this.semver.version === e.semver.version, o = (this.operator ===
    ">=" || this.operator === "<=") && (e.operator === ">=" || e.operator === "<="), l = Tm(this.semver, "<", e.semver, t) && (this.operator ===
    ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"), u = Tm(this.semver, ">", e.semver, t) && (this.operator ===
    "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
    return s || n || a && o || l || u;
  };
  $e.Range = lr;
  function lr(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof lr)
      return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new lr(e.raw, t);
    if (e instanceof Gs)
      return new lr(e.value, t);
    if (!(this instanceof lr))
      return new lr(e, t);
    if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e.trim().split(/\s+/).join(" "),
    this.set = this.raw.split("||").map(function(r) {
      return this.parseRange(r.trim());
    }, this).filter(function(r) {
      return r.length;
    }), !this.set.length)
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    this.format();
  }
  i(lr, "Range");
  lr.prototype.format = function() {
    return this.range = this.set.map(function(e) {
      return e.join(" ").trim();
    }).join("||").trim(), this.range;
  };
  lr.prototype.toString = function() {
    return this.range;
  };
  lr.prototype.parseRange = function(e) {
    var t = this.options.loose, r = t ? It[G.HYPHENRANGELOOSE] : It[G.HYPHENRANGE];
    e = e.replace(r, jLe), _t("hyphen replace", e), e = e.replace(It[G.COMPARATORTRIM], yLe), _t("comparator trim", e, It[G.COMPARATORTRIM]),
    e = e.replace(It[G.TILDETRIM], hLe), e = e.replace(It[G.CARETTRIM], mLe), e = e.split(/\s+/).join(" ");
    var s = t ? It[G.COMPARATORLOOSE] : It[G.COMPARATOR], n = e.split(" ").map(function(a) {
      return OLe(a, this.options);
    }, this).join(" ").split(/\s+/);
    return this.options.loose && (n = n.filter(function(a) {
      return !!a.match(s);
    })), n = n.map(function(a) {
      return new Gs(a, this.options);
    }, this), n;
  };
  lr.prototype.intersects = function(e, t) {
    if (!(e instanceof lr))
      throw new TypeError("a Range is required");
    return this.set.some(function(r) {
      return a6(r, t) && e.set.some(function(s) {
        return a6(s, t) && r.every(function(n) {
          return s.every(function(a) {
            return n.intersects(a, t);
          });
        });
      });
    });
  };
  function a6(e, t) {
    for (var r = !0, s = e.slice(), n = s.pop(); r && s.length; )
      r = s.every(function(a) {
        return n.intersects(a, t);
      }), n = s.pop();
    return r;
  }
  i(a6, "isSatisfiable");
  $e.toComparators = _Le;
  function _Le(e, t) {
    return new lr(e, t).set.map(function(r) {
      return r.map(function(s) {
        return s.value;
      }).join(" ").trim().split(" ");
    });
  }
  i(_Le, "toComparators");
  function OLe(e, t) {
    return _t("comp", e, t), e = kLe(e, t), _t("caret", e), e = NLe(e, t), _t("tildes", e), e = LLe(e, t), _t("xrange", e), e = MLe(e, t), _t(
    "stars", e), e;
  }
  i(OLe, "parseComparator");
  function ps(e) {
    return !e || e.toLowerCase() === "x" || e === "*";
  }
  i(ps, "isX");
  function NLe(e, t) {
    return e.trim().split(/\s+/).map(function(r) {
      return RLe(r, t);
    }).join(" ");
  }
  i(NLe, "replaceTildes");
  function RLe(e, t) {
    var r = t.loose ? It[G.TILDELOOSE] : It[G.TILDE];
    return e.replace(r, function(s, n, a, o, l) {
      _t("tilde", e, s, n, a, o, l);
      var u;
      return ps(n) ? u = "" : ps(a) ? u = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : ps(o) ? u = ">=" + n + "." + a + ".0 <" + n + "." + (+a +
      1) + ".0" : l ? (_t("replaceTilde pr", l), u = ">=" + n + "." + a + "." + o + "-" + l + " <" + n + "." + (+a + 1) + ".0") : u = ">=" +
      n + "." + a + "." + o + " <" + n + "." + (+a + 1) + ".0", _t("tilde return", u), u;
    });
  }
  i(RLe, "replaceTilde");
  function kLe(e, t) {
    return e.trim().split(/\s+/).map(function(r) {
      return FLe(r, t);
    }).join(" ");
  }
  i(kLe, "replaceCarets");
  function FLe(e, t) {
    _t("caret", e, t);
    var r = t.loose ? It[G.CARETLOOSE] : It[G.CARET];
    return e.replace(r, function(s, n, a, o, l) {
      _t("caret", e, s, n, a, o, l);
      var u;
      return ps(n) ? u = "" : ps(a) ? u = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : ps(o) ? n === "0" ? u = ">=" + n + "." + a + ".0 <" + n +
      "." + (+a + 1) + ".0" : u = ">=" + n + "." + a + ".0 <" + (+n + 1) + ".0.0" : l ? (_t("replaceCaret pr", l), n === "0" ? a === "0" ? u =
      ">=" + n + "." + a + "." + o + "-" + l + " <" + n + "." + a + "." + (+o + 1) : u = ">=" + n + "." + a + "." + o + "-" + l + " <" + n +
      "." + (+a + 1) + ".0" : u = ">=" + n + "." + a + "." + o + "-" + l + " <" + (+n + 1) + ".0.0") : (_t("no pr"), n === "0" ? a === "0" ?
      u = ">=" + n + "." + a + "." + o + " <" + n + "." + a + "." + (+o + 1) : u = ">=" + n + "." + a + "." + o + " <" + n + "." + (+a + 1) +
      ".0" : u = ">=" + n + "." + a + "." + o + " <" + (+n + 1) + ".0.0"), _t("caret return", u), u;
    });
  }
  i(FLe, "replaceCaret");
  function LLe(e, t) {
    return _t("replaceXRanges", e, t), e.split(/\s+/).map(function(r) {
      return BLe(r, t);
    }).join(" ");
  }
  i(LLe, "replaceXRanges");
  function BLe(e, t) {
    e = e.trim();
    var r = t.loose ? It[G.XRANGELOOSE] : It[G.XRANGE];
    return e.replace(r, function(s, n, a, o, l, u) {
      _t("xRange", e, s, n, a, o, l, u);
      var c = ps(a), f = c || ps(o), p = f || ps(l), d = p;
      return n === "=" && d && (n = ""), u = t.includePrerelease ? "-0" : "", c ? n === ">" || n === "<" ? s = "<0.0.0-0" : s = "*" : n && d ?
      (f && (o = 0), l = 0, n === ">" ? (n = ">=", f ? (a = +a + 1, o = 0, l = 0) : (o = +o + 1, l = 0)) : n === "<=" && (n = "<", f ? a = +a +
      1 : o = +o + 1), s = n + a + "." + o + "." + l + u) : f ? s = ">=" + a + ".0.0" + u + " <" + (+a + 1) + ".0.0" + u : p && (s = ">=" + a +
      "." + o + ".0" + u + " <" + a + "." + (+o + 1) + ".0" + u), _t("xRange return", s), s;
    });
  }
  i(BLe, "replaceXRange");
  function MLe(e, t) {
    return _t("replaceStars", e, t), e.trim().replace(It[G.STAR], "");
  }
  i(MLe, "replaceStars");
  function jLe(e, t, r, s, n, a, o, l, u, c, f, p, d) {
    return ps(r) ? t = "" : ps(s) ? t = ">=" + r + ".0.0" : ps(n) ? t = ">=" + r + "." + s + ".0" : t = ">=" + t, ps(u) ? l = "" : ps(c) ? l =
    "<" + (+u + 1) + ".0.0" : ps(f) ? l = "<" + u + "." + (+c + 1) + ".0" : p ? l = "<=" + u + "." + c + "." + f + "-" + p : l = "<=" + l, (t +
    " " + l).trim();
  }
  i(jLe, "hyphenReplace");
  lr.prototype.test = function(e) {
    if (!e)
      return !1;
    if (typeof e == "string")
      try {
        e = new Qe(e, this.options);
      } catch {
        return !1;
      }
    for (var t = 0; t < this.set.length; t++)
      if (qLe(this.set[t], e, this.options))
        return !0;
    return !1;
  };
  function qLe(e, t, r) {
    for (var s = 0; s < e.length; s++)
      if (!e[s].test(t))
        return !1;
    if (t.prerelease.length && !r.includePrerelease) {
      for (s = 0; s < e.length; s++)
        if (_t(e[s].semver), e[s].semver !== Vl && e[s].semver.prerelease.length > 0) {
          var n = e[s].semver;
          if (n.major === t.major && n.minor === t.minor && n.patch === t.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  }
  i(qLe, "testSet");
  $e.satisfies = xm;
  function xm(e, t, r) {
    try {
      t = new lr(t, r);
    } catch {
      return !1;
    }
    return t.test(e);
  }
  i(xm, "satisfies");
  $e.maxSatisfying = $Le;
  function $Le(e, t, r) {
    var s = null, n = null;
    try {
      var a = new lr(t, r);
    } catch {
      return null;
    }
    return e.forEach(function(o) {
      a.test(o) && (!s || n.compare(o) === -1) && (s = o, n = new Qe(s, r));
    }), s;
  }
  i($Le, "maxSatisfying");
  $e.minSatisfying = ULe;
  function ULe(e, t, r) {
    var s = null, n = null;
    try {
      var a = new lr(t, r);
    } catch {
      return null;
    }
    return e.forEach(function(o) {
      a.test(o) && (!s || n.compare(o) === 1) && (s = o, n = new Qe(s, r));
    }), s;
  }
  i(ULe, "minSatisfying");
  $e.minVersion = VLe;
  function VLe(e, t) {
    e = new lr(e, t);
    var r = new Qe("0.0.0");
    if (e.test(r) || (r = new Qe("0.0.0-0"), e.test(r)))
      return r;
    r = null;
    for (var s = 0; s < e.set.length; ++s) {
      var n = e.set[s];
      n.forEach(function(a) {
        var o = new Qe(a.semver.version);
        switch (a.operator) {
          case ">":
            o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0), o.raw = o.format();
          case "":
          case ">=":
            (!r || df(r, o)) && (r = o);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + a.operator);
        }
      });
    }
    return r && e.test(r) ? r : null;
  }
  i(VLe, "minVersion");
  $e.validRange = WLe;
  function WLe(e, t) {
    try {
      return new lr(e, t).range || "*";
    } catch {
      return null;
    }
  }
  i(WLe, "validRange");
  $e.ltr = HLe;
  function HLe(e, t, r) {
    return px(e, t, "<", r);
  }
  i(HLe, "ltr");
  $e.gtr = GLe;
  function GLe(e, t, r) {
    return px(e, t, ">", r);
  }
  i(GLe, "gtr");
  $e.outside = px;
  function px(e, t, r, s) {
    e = new Qe(e, s), t = new lr(t, s);
    var n, a, o, l, u;
    switch (r) {
      case ">":
        n = df, a = fx, o = Sm, l = ">", u = ">=";
        break;
      case "<":
        n = Sm, a = cx, o = df, l = "<", u = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (xm(e, t, s))
      return !1;
    for (var c = 0; c < t.set.length; ++c) {
      var f = t.set[c], p = null, d = null;
      if (f.forEach(function(m) {
        m.semver === Vl && (m = new Gs(">=0.0.0")), p = p || m, d = d || m, n(m.semver, p.semver, s) ? p = m : o(m.semver, d.semver, s) && (d =
        m);
      }), p.operator === l || p.operator === u || (!d.operator || d.operator === l) && a(e, d.semver))
        return !1;
      if (d.operator === u && o(e, d.semver))
        return !1;
    }
    return !0;
  }
  i(px, "outside");
  $e.prerelease = KLe;
  function KLe(e, t) {
    var r = Po(e, t);
    return r && r.prerelease.length ? r.prerelease : null;
  }
  i(KLe, "prerelease");
  $e.intersects = YLe;
  function YLe(e, t, r) {
    return e = new lr(e, r), t = new lr(t, r), e.intersects(t);
  }
  i(YLe, "intersects");
  $e.coerce = XLe;
  function XLe(e, t) {
    if (e instanceof Qe)
      return e;
    if (typeof e == "number" && (e = String(e)), typeof e != "string")
      return null;
    t = t || {};
    var r = null;
    if (!t.rtl)
      r = e.match(It[G.COERCE]);
    else {
      for (var s; (s = It[G.COERCERTL].exec(e)) && (!r || r.index + r[0].length !== e.length); )
        (!r || s.index + s[0].length !== r.index + r[0].length) && (r = s), It[G.COERCERTL].lastIndex = s.index + s[1].length + s[2].length;
      It[G.COERCERTL].lastIndex = -1;
    }
    return r === null ? null : Po(r[2] + "." + (r[3] || "0") + "." + (r[4] || "0"), t);
  }
  i(XLe, "coerce");
});

// ../node_modules/@babel/helper-compilation-targets/lib/targets.js
var Pm = y((Wl) => {
  "use strict";
  Object.defineProperty(Wl, "__esModule", {
    value: !0
  });
  Wl.unreleasedLabels = Wl.browserNameMap = void 0;
  var Fnt = Wl.unreleasedLabels = {
    safari: "tp"
  }, Lnt = Wl.browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    deno: "deno",
    op_mob: "opera_mobile",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/utils.js
var Am = y((Pa) => {
  "use strict";
  Object.defineProperty(Pa, "__esModule", {
    value: !0
  });
  Pa.getHighestUnreleased = t3e;
  Pa.getLowestImplementedVersion = r3e;
  Pa.getLowestUnreleased = d6;
  Pa.isUnreleasedVersion = e3e;
  Pa.semverMin = p6;
  Pa.semverify = ZLe;
  var c6 = mf(), zLe = bm(), f6 = Pm(), JLe = /^(\d+|\d+.\d+)$/, QLe = new zLe.OptionValidator("@babel/helper-compilation-targets");
  function p6(e, t) {
    return e && c6.lt(e, t) ? e : t;
  }
  i(p6, "semverMin");
  function ZLe(e) {
    if (typeof e == "string" && c6.valid(e))
      return e;
    QLe.invariant(typeof e == "number" || typeof e == "string" && JLe.test(e), `'${e}' is not a valid version`), e = e.toString();
    let t = 0, r = 0;
    for (; (t = e.indexOf(".", t + 1)) > 0; )
      r++;
    return e + ".0".repeat(2 - r);
  }
  i(ZLe, "semverify");
  function e3e(e, t) {
    let r = f6.unreleasedLabels[t];
    return !!r && r === e.toString().toLowerCase();
  }
  i(e3e, "isUnreleasedVersion");
  function d6(e, t, r) {
    let s = f6.unreleasedLabels[r];
    return e === s ? t : t === s ? e : p6(e, t);
  }
  i(d6, "getLowestUnreleased");
  function t3e(e, t, r) {
    return d6(e, t, r) === e ? t : e;
  }
  i(t3e, "getHighestUnreleased");
  function r3e(e, t) {
    let r = e[t];
    return !r && t === "android" ? e.chrome : r;
  }
  i(r3e, "getLowestImplementedVersion");
});

// ../node_modules/@babel/helper-compilation-targets/lib/options.js
var h6 = y((Cm) => {
  "use strict";
  Object.defineProperty(Cm, "__esModule", {
    value: !0
  });
  Cm.TargetNames = void 0;
  var qnt = Cm.TargetNames = {
    node: "node",
    deno: "deno",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung",
    rhino: "rhino",
    opera_mobile: "opera_mobile"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/pretty.js
var dx = y((wm) => {
  "use strict";
  Object.defineProperty(wm, "__esModule", {
    value: !0
  });
  wm.prettifyTargets = i3e;
  wm.prettifyVersion = m6;
  var s3e = mf(), n3e = Pm();
  function m6(e) {
    if (typeof e != "string")
      return e;
    let {
      major: t,
      minor: r,
      patch: s
    } = s3e.parse(e), n = [t];
    return (r || s) && n.push(r), s && n.push(s), n.join(".");
  }
  i(m6, "prettifyVersion");
  function i3e(e) {
    return Object.keys(e).reduce((t, r) => {
      let s = e[r], n = n3e.unreleasedLabels[r];
      return typeof s == "string" && n !== s && (s = m6(s)), t[r] = s, t;
    }, {});
  }
  i(i3e, "prettifyTargets");
});

// ../node_modules/@babel/helper-compilation-targets/lib/debug.js
var g6 = y((hx) => {
  "use strict";
  Object.defineProperty(hx, "__esModule", {
    value: !0
  });
  hx.getInclusionReasons = o3e;
  var a3e = mf(), y6 = dx(), Dm = Am();
  function o3e(e, t, r) {
    let s = r[e] || {};
    return Object.keys(t).reduce((n, a) => {
      let o = (0, Dm.getLowestImplementedVersion)(s, a), l = t[a];
      if (!o)
        n[a] = (0, y6.prettifyVersion)(l);
      else {
        let u = (0, Dm.isUnreleasedVersion)(o, a);
        !(0, Dm.isUnreleasedVersion)(l, a) && (u || a3e.lt(l.toString(), (0, Dm.semverify)(o))) && (n[a] = (0, y6.prettifyVersion)(l));
      }
      return n;
    }, {});
  }
  i(o3e, "getInclusionReasons");
});

// ../node_modules/@babel/compat-data/data/plugins.json
var b6 = y((Gnt, l3e) => {
  l3e.exports = {
    "transform-unicode-sets-regex": {
      chrome: "112",
      opera: "98",
      edge: "112",
      firefox: "116",
      safari: "tp",
      node: "20",
      deno: "1.32",
      opera_mobile: "75",
      electron: "24.0"
    },
    "bugfix/transform-v8-static-class-fields-redefine-readonly": {
      chrome: "98",
      opera: "84",
      edge: "98",
      firefox: "95",
      safari: "15",
      node: "12",
      deno: "1.18",
      ios: "15",
      samsung: "11",
      opera_mobile: "52",
      electron: "17.0"
    },
    "bugfix/transform-firefox-class-in-computed-class-key": {
      chrome: "74",
      opera: "62",
      edge: "79",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "proposal-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "transform-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "proposal-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "proposal-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "transform-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      opera_mobile: "57",
      electron: "8.0"
    },
    "proposal-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      opera_mobile: "57",
      electron: "8.0"
    },
    "transform-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-parameters": {
      chrome: "49",
      opera: "36",
      edge: "18",
      firefox: "53",
      safari: "16.3",
      node: "6",
      deno: "1",
      ios: "16.3",
      samsung: "5",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "proposal-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "proposal-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "transform-dotall-regex": {
      chrome: "62",
      opera: "49",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "8.10",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-named-capturing-groups-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-async-to-generator": {
      chrome: "55",
      opera: "42",
      edge: "15",
      firefox: "52",
      safari: "11",
      node: "7.6",
      deno: "1",
      ios: "11",
      samsung: "6",
      opera_mobile: "42",
      electron: "1.6"
    },
    "transform-exponentiation-operator": {
      chrome: "52",
      opera: "39",
      edge: "14",
      firefox: "52",
      safari: "10.1",
      node: "7",
      deno: "1",
      ios: "10.3",
      samsung: "6",
      rhino: "1.7.14",
      opera_mobile: "41",
      electron: "1.3"
    },
    "transform-template-literals": {
      chrome: "41",
      opera: "28",
      edge: "13",
      firefox: "34",
      safari: "13",
      node: "4",
      deno: "1",
      ios: "13",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-literals": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-function-name": {
      chrome: "51",
      opera: "38",
      edge: "79",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-arrow-functions": {
      chrome: "47",
      opera: "34",
      edge: "13",
      firefox: "43",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.13",
      opera_mobile: "34",
      electron: "0.36"
    },
    "transform-block-scoped-functions": {
      chrome: "41",
      opera: "28",
      edge: "12",
      firefox: "46",
      safari: "10",
      node: "4",
      deno: "1",
      ie: "11",
      ios: "10",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-classes": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-object-super": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-shorthand-properties": {
      chrome: "43",
      opera: "30",
      edge: "12",
      firefox: "33",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.14",
      opera_mobile: "30",
      electron: "0.27"
    },
    "transform-duplicate-keys": {
      chrome: "42",
      opera: "29",
      edge: "12",
      firefox: "34",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "3.4",
      opera_mobile: "29",
      electron: "0.25"
    },
    "transform-computed-properties": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "34",
      safari: "7.1",
      node: "4",
      deno: "1",
      ios: "8",
      samsung: "4",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-for-of": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-sticky-regex": {
      chrome: "49",
      opera: "36",
      edge: "13",
      firefox: "3",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-unicode-escapes": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-unicode-regex": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "46",
      safari: "12",
      node: "6",
      deno: "1",
      ios: "12",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-spread": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-destructuring": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-block-scoping": {
      chrome: "50",
      opera: "37",
      edge: "14",
      firefox: "53",
      safari: "11",
      node: "6",
      deno: "1",
      ios: "11",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-typeof-symbol": {
      chrome: "38",
      opera: "25",
      edge: "12",
      firefox: "36",
      safari: "9",
      node: "0.12",
      deno: "1",
      ios: "9",
      samsung: "3",
      rhino: "1.7.13",
      opera_mobile: "25",
      electron: "0.20"
    },
    "transform-new-target": {
      chrome: "46",
      opera: "33",
      edge: "14",
      firefox: "41",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-regenerator": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "53",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-member-expression-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-property-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-reserved-words": {
      chrome: "13",
      opera: "10.50",
      edge: "12",
      firefox: "2",
      safari: "3.1",
      node: "0.6",
      deno: "1",
      ie: "9",
      android: "4.4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "10.1",
      electron: "0.20"
    },
    "transform-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    },
    "proposal-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    }
  };
});

// ../node_modules/@babel/compat-data/plugins.js
var v6 = y((Knt, E6) => {
  E6.exports = b6();
});

// ../node_modules/@babel/helper-compilation-targets/lib/filter-items.js
var P6 = y((yf) => {
  "use strict";
  Object.defineProperty(yf, "__esModule", {
    value: !0
  });
  yf.default = c3e;
  yf.isRequired = x6;
  yf.targetsSupported = T6;
  var S6 = mf(), u3e = v6(), Im = Am();
  function T6(e, t) {
    let r = Object.keys(e);
    return r.length === 0 ? !1 : r.filter((n) => {
      let a = (0, Im.getLowestImplementedVersion)(t, n);
      if (!a)
        return !0;
      let o = e[n];
      if ((0, Im.isUnreleasedVersion)(o, n))
        return !1;
      if ((0, Im.isUnreleasedVersion)(a, n))
        return !0;
      if (!S6.valid(o.toString()))
        throw new Error(`Invalid version passed for target "${n}": "${o}". Versions must be in semver format (major.minor.patch)`);
      return S6.gt((0, Im.semverify)(a), o.toString());
    }).length === 0;
  }
  i(T6, "targetsSupported");
  function x6(e, t, {
    compatData: r = u3e,
    includes: s,
    excludes: n
  } = {}) {
    return n != null && n.has(e) ? !1 : s != null && s.has(e) ? !0 : !T6(t, r[e]);
  }
  i(x6, "isRequired");
  function c3e(e, t, r, s, n, a, o) {
    let l = /* @__PURE__ */ new Set(), u = {
      compatData: e,
      includes: t,
      excludes: r
    };
    for (let c in e)
      if (x6(c, s, u))
        l.add(c);
      else if (o) {
        let f = o.get(c);
        f && l.add(f);
      }
    return n?.forEach((c) => !r.has(c) && l.add(c)), a?.forEach((c) => !t.has(c) && l.delete(c)), l;
  }
  i(c3e, "filterItems");
});

// ../node_modules/@babel/helper-compilation-targets/lib/index.js
var bx = y((Gn) => {
  "use strict";
  Object.defineProperty(Gn, "__esModule", {
    value: !0
  });
  Object.defineProperty(Gn, "TargetNames", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return yx.TargetNames;
    }, "get")
  });
  Gn.default = P3e;
  Object.defineProperty(Gn, "filterItems", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return I6.default;
    }, "get")
  });
  Object.defineProperty(Gn, "getInclusionReasons", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return h3e.getInclusionReasons;
    }, "get")
  });
  Gn.isBrowsersQueryValid = _6;
  Object.defineProperty(Gn, "isRequired", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return I6.isRequired;
    }, "get")
  });
  Object.defineProperty(Gn, "prettifyTargets", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return d3e.prettifyTargets;
    }, "get")
  });
  Object.defineProperty(Gn, "unreleasedLabels", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return D6.unreleasedLabels;
    }, "get")
  });
  var C6 = W8(), w6 = bm(), f3e = X8(), p3e = n6(), vn = Am(), D6 = Pm(), yx = h6(), d3e = dx(), h3e = g6(), I6 = P6(), mx = f3e["es6.module"],
  gx = new w6.OptionValidator("@babel/helper-compilation-targets");
  function m3e(e) {
    let t = Object.keys(yx.TargetNames);
    for (let r of Object.keys(e))
      if (!(r in yx.TargetNames))
        throw new Error(gx.formatMessage(`'${r}' is not a valid target
- Did you mean '${(0, w6.findSuggestion)(r, t)}'?`));
    return e;
  }
  i(m3e, "validateTargetNames");
  function _6(e) {
    return typeof e == "string" || Array.isArray(e) && e.every((t) => typeof t == "string");
  }
  i(_6, "isBrowsersQueryValid");
  function y3e(e) {
    return gx.invariant(e === void 0 || _6(e), `'${String(e)}' is not a valid browserslist query`), e;
  }
  i(y3e, "validateBrowsers");
  function g3e(e) {
    return e.reduce((t, r) => {
      let [s, n] = r.split(" "), a = D6.browserNameMap[s];
      if (!a)
        return t;
      try {
        let o = n.split("-")[0].toLowerCase(), l = (0, vn.isUnreleasedVersion)(o, a);
        if (!t[a])
          return t[a] = l ? o : (0, vn.semverify)(o), t;
        let u = t[a], c = (0, vn.isUnreleasedVersion)(u, a);
        if (c && l)
          t[a] = (0, vn.getLowestUnreleased)(u, o, a);
        else if (c)
          t[a] = (0, vn.semverify)(o);
        else if (!c && !l) {
          let f = (0, vn.semverify)(o);
          t[a] = (0, vn.semverMin)(u, f);
        }
      } catch {
      }
      return t;
    }, {});
  }
  i(g3e, "getLowestVersions");
  function b3e(e) {
    e.length && (console.warn(`Warning, the following targets are using a decimal version:
`), e.forEach(({
      target: t,
      value: r
    }) => console.warn(`  ${t}: ${r}`)), console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`));
  }
  i(b3e, "outputDecimalWarning");
  function O6(e, t) {
    try {
      return (0, vn.semverify)(t);
    } catch {
      throw new Error(gx.formatMessage(`'${t}' is not a valid value for 'targets.${e}'.`));
    }
  }
  i(O6, "semverifyTarget");
  function E3e(e) {
    return ["node", e === !0 || e === "current" ? process.versions.node : O6("node", e)];
  }
  i(E3e, "nodeTargetParser");
  function v3e(e, t) {
    let r = (0, vn.isUnreleasedVersion)(t, e) ? t.toLowerCase() : O6(e, t);
    return [e, r];
  }
  i(v3e, "defaultTargetParser");
  function S3e(e) {
    let t = Object.assign({}, e);
    return delete t.esmodules, delete t.browsers, t;
  }
  i(S3e, "generateTargets");
  function T3e(e, t) {
    let r = C6(e, {
      mobileToDesktop: !0,
      env: t
    });
    return g3e(r);
  }
  i(T3e, "resolveTargets");
  var A6 = new p3e({
    max: 64
  });
  function x3e(e, t) {
    let r = typeof e == "string" ? e : e.join() + t, s = A6.get(r);
    return s || (s = T3e(e, t), A6.set(r, s)), Object.assign({}, s);
  }
  i(x3e, "resolveTargetsCached");
  function P3e(e = {}, t = {}) {
    var r, s;
    let {
      browsers: n,
      esmodules: a
    } = e, {
      configPath: o = "."
    } = t;
    y3e(n);
    let l = S3e(e), u = m3e(l), f = !!n || Object.keys(u).length > 0, p = !t.ignoreBrowserslistConfig && !f;
    if (!n && p && (n = C6.loadConfig({
      config: t.configFile,
      path: o,
      env: t.browserslistEnv
    }), n == null && (n = [])), a && (a !== "intersect" || !((r = n) != null && r.length)) && (n = Object.keys(mx).map((b) => `${b} >= ${mx[b]}`).
    join(", "), a = !1), (s = n) != null && s.length) {
      let b = x3e(n, t.browserslistEnv);
      if (a === "intersect")
        for (let h of Object.keys(b))
          if (h !== "deno" && h !== "ie") {
            let g = mx[h === "opera_mobile" ? "op_mob" : h];
            if (g) {
              let E = b[h];
              b[h] = (0, vn.getHighestUnreleased)(E, (0, vn.semverify)(g), h);
            } else
              delete b[h];
          } else
            delete b[h];
      u = Object.assign(b, u);
    }
    let d = {}, m = [];
    for (let b of Object.keys(u).sort()) {
      let h = u[b];
      typeof h == "number" && h % 1 !== 0 && m.push({
        target: b,
        value: h
      });
      let [g, E] = b === "node" ? E3e(h) : v3e(b, h);
      E && (d[g] = E);
    }
    return b3e(m), d;
  }
  i(P3e, "getTargets");
});

// ../node_modules/@babel/core/lib/config/resolve-targets.js
var Ex = y((_m) => {
  "use strict";
  Object.defineProperty(_m, "__esModule", {
    value: !0
  });
  _m.resolveBrowserslistConfigFile = A3e;
  _m.resolveTargets = C3e;
  function N6() {
    let e = require("path");
    return N6 = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(N6, "_path");
  function R6() {
    let e = bx();
    return R6 = /* @__PURE__ */ i(function() {
      return e;
    }, "_helperCompilationTargets"), e;
  }
  i(R6, "_helperCompilationTargets");
  function A3e(e, t) {
    return N6().resolve(t, e);
  }
  i(A3e, "resolveBrowserslistConfigFile");
  function C3e(e, t) {
    let r = e.targets, s;
    typeof r == "string" || Array.isArray(r) ? s = {
      browsers: r
    } : r && ("esmodules" in r ? s = Object.assign({}, r, {
      esmodules: "intersect"
    }) : s = r);
    let {
      browserslistConfigFile: n
    } = e, a, o = !1;
    return typeof n == "string" ? a = n : o = n === !1, (0, R6().default)(s, {
      ignoreBrowserslistConfig: o,
      configFile: a,
      configPath: t,
      browserslistEnv: e.browserslistEnv
    });
  }
  i(C3e, "resolveTargets");
});

// ../node_modules/@babel/core/lib/config/config-descriptors.js
var vx = y((bf) => {
  "use strict";
  Object.defineProperty(bf, "__esModule", {
    value: !0
  });
  bf.createCachedDescriptors = _3e;
  bf.createDescriptor = V6;
  bf.createUncachedDescriptors = O3e;
  function B6() {
    let e = As();
    return B6 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(B6, "_gensync");
  var k6 = U4(), F6 = vf(), w3e = Ef(), gf = mo(), D3e = Ex();
  function I3e(e, t) {
    var r, s, n, a;
    return e.name === t.name && e.value === t.value && e.options === t.options && e.dirname === t.dirname && e.alias === t.alias && e.ownPass ===
    t.ownPass && ((r = e.file) == null ? void 0 : r.request) === ((s = t.file) == null ? void 0 : s.request) && ((n = e.file) == null ? void 0 :
    n.resolved) === ((a = t.file) == null ? void 0 : a.resolved);
  }
  i(I3e, "isEqualDescriptor");
  function* L6(e) {
    return e;
  }
  i(L6, "handlerOf");
  function M6(e, t) {
    return typeof e.browserslistConfigFile == "string" && (e.browserslistConfigFile = (0, D3e.resolveBrowserslistConfigFile)(e.browserslistConfigFile,
    t)), e;
  }
  i(M6, "optionsWithResolvedBrowserslistConfigFile");
  function _3e(e, t, r) {
    let {
      plugins: s,
      presets: n,
      passPerPreset: a
    } = t;
    return {
      options: M6(t, e),
      plugins: s ? () => F3e(s, e)(r) : () => L6([]),
      presets: n ? () => R3e(n, e)(r)(!!a) : () => L6([])
    };
  }
  i(_3e, "createCachedDescriptors");
  function O3e(e, t, r) {
    return {
      options: M6(t, e),
      plugins: (0, k6.once)(() => $6(t.plugins || [], e, r)),
      presets: (0, k6.once)(() => q6(t.presets || [], e, r, !!t.passPerPreset))
    };
  }
  i(O3e, "createUncachedDescriptors");
  var N3e = /* @__PURE__ */ new WeakMap(), R3e = (0, gf.makeWeakCacheSync)((e, t) => {
    let r = t.using((s) => s);
    return (0, gf.makeStrongCacheSync)((s) => (0, gf.makeStrongCache)(function* (n) {
      return (yield* q6(e, r, s, n)).map((o) => j6(N3e, o));
    }));
  }), k3e = /* @__PURE__ */ new WeakMap(), F3e = (0, gf.makeWeakCacheSync)((e, t) => {
    let r = t.using((s) => s);
    return (0, gf.makeStrongCache)(function* (s) {
      return (yield* $6(e, r, s)).map((a) => j6(k3e, a));
    });
  }), L3e = {};
  function j6(e, t) {
    let {
      value: r,
      options: s = L3e
    } = t;
    if (s === !1) return t;
    let n = e.get(r);
    n || (n = /* @__PURE__ */ new WeakMap(), e.set(r, n));
    let a = n.get(s);
    if (a || (a = [], n.set(s, a)), a.indexOf(t) === -1) {
      let o = a.filter((l) => I3e(l, t));
      if (o.length > 0)
        return o[0];
      a.push(t);
    }
    return t;
  }
  i(j6, "loadCachedDescriptor");
  function* q6(e, t, r, s) {
    return yield* U6("preset", e, t, r, s);
  }
  i(q6, "createPresetDescriptors");
  function* $6(e, t, r) {
    return yield* U6("plugin", e, t, r);
  }
  i($6, "createPluginDescriptors");
  function* U6(e, t, r, s, n) {
    let a = yield* B6().all(t.map((o, l) => V6(o, r, {
      type: e,
      alias: `${s}$${l}`,
      ownPass: !!n
    })));
    return B3e(a), a;
  }
  i(U6, "createDescriptors");
  function* V6(e, t, {
    type: r,
    alias: s,
    ownPass: n
  }) {
    let a = (0, w3e.getItemDescriptor)(e);
    if (a)
      return a;
    let o, l, u = e;
    Array.isArray(u) && (u.length === 3 ? [u, l, o] = u : [u, l] = u);
    let c, f = null;
    if (typeof u == "string") {
      if (typeof r != "string")
        throw new Error("To resolve a string-based item, the type of item must be given");
      let p = r === "plugin" ? F6.loadPlugin : F6.loadPreset, d = u;
      ({
        filepath: f,
        value: u
      } = yield* p(u, t)), c = {
        request: d,
        resolved: f
      };
    }
    if (!u)
      throw new Error(`Unexpected falsy value: ${String(u)}`);
    if (typeof u == "object" && u.__esModule)
      if (u.default)
        u = u.default;
      else
        throw new Error("Must export a default export when using ES6 modules.");
    if (typeof u != "object" && typeof u != "function")
      throw new Error(`Unsupported format: ${typeof u}. Expected an object or a function.`);
    if (f !== null && typeof u == "object" && u)
      throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${f}`);
    return {
      name: o,
      alias: f || s,
      value: u,
      options: l,
      dirname: t,
      ownPass: n,
      file: c
    };
  }
  i(V6, "createDescriptor");
  function B3e(e) {
    let t = /* @__PURE__ */ new Map();
    for (let r of e) {
      if (typeof r.value != "function") continue;
      let s = t.get(r.value);
      if (s || (s = /* @__PURE__ */ new Set(), t.set(r.value, s)), s.has(r.name)) {
        let n = e.filter((a) => a.value === r.value);
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separat\
e names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detec\
ted are:", `${JSON.stringify(n, null, 2)}`].join(`
`));
      }
      s.add(r.name);
    }
  }
  i(B3e, "assertNoDuplicates");
});

// ../node_modules/@babel/core/lib/config/item.js
var Ef = y((Sf) => {
  "use strict";
  Object.defineProperty(Sf, "__esModule", {
    value: !0
  });
  Sf.createConfigItem = j3e;
  Sf.createItemFromDescriptor = H6;
  Sf.getItemDescriptor = q3e;
  function W6() {
    let e = require("path");
    return W6 = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(W6, "_path");
  var M3e = vx();
  function H6(e) {
    return new Om(e);
  }
  i(H6, "createItemFromDescriptor");
  function* j3e(e, {
    dirname: t = ".",
    type: r
  } = {}) {
    let s = yield* (0, M3e.createDescriptor)(e, W6().resolve(t), {
      type: r,
      alias: "programmatic item"
    });
    return H6(s);
  }
  i(j3e, "createConfigItem");
  var Sx = Symbol.for("@babel/core@7 - ConfigItem");
  function q3e(e) {
    if (e != null && e[Sx])
      return e._descriptor;
  }
  i(q3e, "getItemDescriptor");
  var Om = class {
    static {
      i(this, "ConfigItem");
    }
    constructor(t) {
      this._descriptor = void 0, this[Sx] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.
      file = void 0, this._descriptor = t, Object.defineProperty(this, "_descriptor", {
        enumerable: !1
      }), Object.defineProperty(this, Sx, {
        enumerable: !1
      }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name =
      this._descriptor.name, this.file = this._descriptor.file ? {
        request: this._descriptor.file.request,
        resolved: this._descriptor.file.resolved
      } : void 0, Object.freeze(this);
    }
  };
  Object.freeze(Om.prototype);
});

// ../node_modules/@babel/core/lib/config/validation/removed.js
var G6 = y((Nm) => {
  "use strict";
  Object.defineProperty(Nm, "__esModule", {
    value: !0
  });
  Nm.default = void 0;
  var nit = Nm.default = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.i\
o/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file\
` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.fi\
le` themselves."
    }
  };
});

// ../node_modules/@babel/core/lib/config/validation/option-assertions.js
var Px = y((pr) => {
  "use strict";
  Object.defineProperty(pr, "__esModule", {
    value: !0
  });
  pr.access = ws;
  pr.assertArray = xx;
  pr.assertAssumptions = iBe;
  pr.assertBabelrcSearch = eBe;
  pr.assertBoolean = Tx;
  pr.assertCallerMetadata = G3e;
  pr.assertCompact = W3e;
  pr.assertConfigApplicableTest = Q3e;
  pr.assertConfigFileSearch = Z3e;
  pr.assertFunction = X3e;
  pr.assertIgnoreList = z3e;
  pr.assertInputSourceMap = K3e;
  pr.assertObject = X6;
  pr.assertPluginList = tBe;
  pr.assertRootMode = U3e;
  pr.assertSourceMaps = V3e;
  pr.assertSourceType = H3e;
  pr.assertString = Y3e;
  pr.assertTargets = sBe;
  pr.msg = ft;
  function Tf() {
    let e = bx();
    return Tf = /* @__PURE__ */ i(function() {
      return e;
    }, "_helperCompilationTargets"), e;
  }
  i(Tf, "_helperCompilationTargets");
  var $3e = xf();
  function ft(e) {
    switch (e.type) {
      case "root":
        return "";
      case "env":
        return `${ft(e.parent)}.env["${e.name}"]`;
      case "overrides":
        return `${ft(e.parent)}.overrides[${e.index}]`;
      case "option":
        return `${ft(e.parent)}.${e.name}`;
      case "access":
        return `${ft(e.parent)}[${JSON.stringify(e.name)}]`;
      default:
        throw new Error(`Assertion failure: Unknown type ${e.type}`);
    }
  }
  i(ft, "msg");
  function ws(e, t) {
    return {
      type: "access",
      name: t,
      parent: e
    };
  }
  i(ws, "access");
  function U3e(e, t) {
    if (t !== void 0 && t !== "root" && t !== "upward" && t !== "upward-optional")
      throw new Error(`${ft(e)} must be a "root", "upward", "upward-optional" or undefined`);
    return t;
  }
  i(U3e, "assertRootMode");
  function V3e(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "inline" && t !== "both")
      throw new Error(`${ft(e)} must be a boolean, "inline", "both", or undefined`);
    return t;
  }
  i(V3e, "assertSourceMaps");
  function W3e(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "auto")
      throw new Error(`${ft(e)} must be a boolean, "auto", or undefined`);
    return t;
  }
  i(W3e, "assertCompact");
  function H3e(e, t) {
    if (t !== void 0 && t !== "module" && t !== "script" && t !== "unambiguous")
      throw new Error(`${ft(e)} must be "module", "script", "unambiguous", or undefined`);
    return t;
  }
  i(H3e, "assertSourceType");
  function G3e(e, t) {
    let r = X6(e, t);
    if (r) {
      if (typeof r.name != "string")
        throw new Error(`${ft(e)} set but does not contain "name" property string`);
      for (let s of Object.keys(r)) {
        let n = ws(e, s), a = r[s];
        if (a != null && typeof a != "boolean" && typeof a != "string" && typeof a != "number")
          throw new Error(`${ft(n)} must be null, undefined, a boolean, a string, or a number.`);
      }
    }
    return t;
  }
  i(G3e, "assertCallerMetadata");
  function K3e(e, t) {
    if (t !== void 0 && typeof t != "boolean" && (typeof t != "object" || !t))
      throw new Error(`${ft(e)} must be a boolean, object, or undefined`);
    return t;
  }
  i(K3e, "assertInputSourceMap");
  function Y3e(e, t) {
    if (t !== void 0 && typeof t != "string")
      throw new Error(`${ft(e)} must be a string, or undefined`);
    return t;
  }
  i(Y3e, "assertString");
  function X3e(e, t) {
    if (t !== void 0 && typeof t != "function")
      throw new Error(`${ft(e)} must be a function, or undefined`);
    return t;
  }
  i(X3e, "assertFunction");
  function Tx(e, t) {
    if (t !== void 0 && typeof t != "boolean")
      throw new Error(`${ft(e)} must be a boolean, or undefined`);
    return t;
  }
  i(Tx, "assertBoolean");
  function X6(e, t) {
    if (t !== void 0 && (typeof t != "object" || Array.isArray(t) || !t))
      throw new Error(`${ft(e)} must be an object, or undefined`);
    return t;
  }
  i(X6, "assertObject");
  function xx(e, t) {
    if (t != null && !Array.isArray(t))
      throw new Error(`${ft(e)} must be an array, or undefined`);
    return t;
  }
  i(xx, "assertArray");
  function z3e(e, t) {
    let r = xx(e, t);
    return r?.forEach((s, n) => J3e(ws(e, n), s)), r;
  }
  i(z3e, "assertIgnoreList");
  function J3e(e, t) {
    if (typeof t != "string" && typeof t != "function" && !(t instanceof RegExp))
      throw new Error(`${ft(e)} must be an array of string/Function/RegExp values, or undefined`);
    return t;
  }
  i(J3e, "assertIgnoreItem");
  function Q3e(e, t) {
    if (t === void 0)
      return t;
    if (Array.isArray(t))
      t.forEach((r, s) => {
        if (!Rm(r))
          throw new Error(`${ft(ws(e, s))} must be a string/Function/RegExp.`);
      });
    else if (!Rm(t))
      throw new Error(`${ft(e)} must be a string/Function/RegExp, or an array of those`);
    return t;
  }
  i(Q3e, "assertConfigApplicableTest");
  function Rm(e) {
    return typeof e == "string" || typeof e == "function" || e instanceof RegExp;
  }
  i(Rm, "checkValidTest");
  function Z3e(e, t) {
    if (t !== void 0 && typeof t != "boolean" && typeof t != "string")
      throw new Error(`${ft(e)} must be a undefined, a boolean, a string, got ${JSON.stringify(t)}`);
    return t;
  }
  i(Z3e, "assertConfigFileSearch");
  function eBe(e, t) {
    if (t === void 0 || typeof t == "boolean")
      return t;
    if (Array.isArray(t))
      t.forEach((r, s) => {
        if (!Rm(r))
          throw new Error(`${ft(ws(e, s))} must be a string/Function/RegExp.`);
      });
    else if (!Rm(t))
      throw new Error(`${ft(e)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t)}`);
    return t;
  }
  i(eBe, "assertBabelrcSearch");
  function tBe(e, t) {
    let r = xx(e, t);
    return r && r.forEach((s, n) => rBe(ws(e, n), s)), r;
  }
  i(tBe, "assertPluginList");
  function rBe(e, t) {
    if (Array.isArray(t)) {
      if (t.length === 0)
        throw new Error(`${ft(e)} must include an object`);
      if (t.length > 3)
        throw new Error(`${ft(e)} may only be a two-tuple or three-tuple`);
      if (K6(ws(e, 0), t[0]), t.length > 1) {
        let r = t[1];
        if (r !== void 0 && r !== !1 && (typeof r != "object" || Array.isArray(r) || r === null))
          throw new Error(`${ft(ws(e, 1))} must be an object, false, or undefined`);
      }
      if (t.length === 3) {
        let r = t[2];
        if (r !== void 0 && typeof r != "string")
          throw new Error(`${ft(ws(e, 2))} must be a string, or undefined`);
      }
    } else
      K6(e, t);
    return t;
  }
  i(rBe, "assertPluginItem");
  function K6(e, t) {
    if ((typeof t != "object" || !t) && typeof t != "string" && typeof t != "function")
      throw new Error(`${ft(e)} must be a string, object, function`);
    return t;
  }
  i(K6, "assertPluginTarget");
  function sBe(e, t) {
    if ((0, Tf().isBrowsersQueryValid)(t)) return t;
    if (typeof t != "object" || !t || Array.isArray(t))
      throw new Error(`${ft(e)} must be a string, an array of strings or an object`);
    let r = ws(e, "browsers"), s = ws(e, "esmodules");
    Y6(r, t.browsers), Tx(s, t.esmodules);
    for (let n of Object.keys(t)) {
      let a = t[n], o = ws(e, n);
      if (n === "esmodules") Tx(o, a);
      else if (n === "browsers") Y6(o, a);
      else if (hasOwnProperty.call(Tf().TargetNames, n))
        nBe(o, a);
      else {
        let l = Object.keys(Tf().TargetNames).join(", ");
        throw new Error(`${ft(o)} is not a valid target. Supported targets are ${l}`);
      }
    }
    return t;
  }
  i(sBe, "assertTargets");
  function Y6(e, t) {
    if (t !== void 0 && !(0, Tf().isBrowsersQueryValid)(t))
      throw new Error(`${ft(e)} must be undefined, a string or an array of strings`);
  }
  i(Y6, "assertBrowsersList");
  function nBe(e, t) {
    if (!(typeof t == "number" && Math.round(t) === t) && typeof t != "string")
      throw new Error(`${ft(e)} must be a string or an integer number`);
  }
  i(nBe, "assertBrowserVersion");
  function iBe(e, t) {
    if (t === void 0) return;
    if (typeof t != "object" || t === null)
      throw new Error(`${ft(e)} must be an object or undefined.`);
    let r = e;
    do
      r = r.parent;
    while (r.type !== "root");
    let s = r.source === "preset";
    for (let n of Object.keys(t)) {
      let a = ws(e, n);
      if (!$3e.assumptionsNames.has(n))
        throw new Error(`${ft(a)} is not a supported assumption.`);
      if (typeof t[n] != "boolean")
        throw new Error(`${ft(a)} must be a boolean.`);
      if (s && t[n] === !1)
        throw new Error(`${ft(a)} cannot be set to 'false' inside presets.`);
    }
    return t;
  }
  i(iBe, "assertAssumptions");
});

// ../node_modules/@babel/core/lib/config/validation/options.js
var xf = y((Hl) => {
  "use strict";
  Object.defineProperty(Hl, "__esModule", {
    value: !0
  });
  Hl.assumptionsNames = void 0;
  Hl.checkNoUnwrappedItemOptionPairs = dBe;
  Hl.validate = lBe;
  var z6 = G6(), xe = Px(), aBe = yo(), J6 = {
    cwd: xe.assertString,
    root: xe.assertString,
    rootMode: xe.assertRootMode,
    configFile: xe.assertConfigFileSearch,
    caller: xe.assertCallerMetadata,
    filename: xe.assertString,
    filenameRelative: xe.assertString,
    code: xe.assertBoolean,
    ast: xe.assertBoolean,
    cloneInputAst: xe.assertBoolean,
    envName: xe.assertString
  }, Q6 = {
    babelrc: xe.assertBoolean,
    babelrcRoots: xe.assertBabelrcSearch
  }, Z6 = {
    extends: xe.assertString,
    ignore: xe.assertIgnoreList,
    only: xe.assertIgnoreList,
    targets: xe.assertTargets,
    browserslistConfigFile: xe.assertConfigFileSearch,
    browserslistEnv: xe.assertString
  }, e5 = {
    inputSourceMap: xe.assertInputSourceMap,
    presets: xe.assertPluginList,
    plugins: xe.assertPluginList,
    passPerPreset: xe.assertBoolean,
    assumptions: xe.assertAssumptions,
    env: fBe,
    overrides: pBe,
    test: xe.assertConfigApplicableTest,
    include: xe.assertConfigApplicableTest,
    exclude: xe.assertConfigApplicableTest,
    retainLines: xe.assertBoolean,
    comments: xe.assertBoolean,
    shouldPrintComment: xe.assertFunction,
    compact: xe.assertCompact,
    minified: xe.assertBoolean,
    auxiliaryCommentBefore: xe.assertString,
    auxiliaryCommentAfter: xe.assertString,
    sourceType: xe.assertSourceType,
    wrapPluginVisitorMethod: xe.assertFunction,
    highlightCode: xe.assertBoolean,
    sourceMaps: xe.assertSourceMaps,
    sourceMap: xe.assertSourceMaps,
    sourceFileName: xe.assertString,
    sourceRoot: xe.assertString,
    parserOpts: xe.assertObject,
    generatorOpts: xe.assertObject
  };
  Object.assign(e5, {
    getModuleId: xe.assertFunction,
    moduleRoot: xe.assertString,
    moduleIds: xe.assertBoolean,
    moduleId: xe.assertString
  });
  var oBe = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitive\
Hint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUnini\
tializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods",
  "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"], lit = Hl.
  assumptionsNames = new Set(oBe);
  function t5(e) {
    return e.type === "root" ? e.source : t5(e.parent);
  }
  i(t5, "getSource");
  function lBe(e, t, r) {
    try {
      return Ax({
        type: "root",
        source: e
      }, t);
    } catch (s) {
      let n = new aBe.default(s.message, r);
      throw s.code && (n.code = s.code), n;
    }
  }
  i(lBe, "validate");
  function Ax(e, t) {
    let r = t5(e);
    return cBe(t), Object.keys(t).forEach((s) => {
      let n = {
        type: "option",
        name: s,
        parent: e
      };
      if (r === "preset" && Z6[s])
        throw new Error(`${(0, xe.msg)(n)} is not allowed in preset options`);
      if (r !== "arguments" && J6[s])
        throw new Error(`${(0, xe.msg)(n)} is only allowed in root programmatic options`);
      if (r !== "arguments" && r !== "configfile" && Q6[s])
        throw r === "babelrcfile" || r === "extendsfile" ? new Error(`${(0, xe.msg)(n)} is not allowed in .babelrc or "extends"ed files, onl\
y in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, xe.msg)(n)} is only allowed in root programmatic\
 options, or babel.config.js/config file options`);
      (e5[s] || Z6[s] || Q6[s] || J6[s] || uBe)(n, t[s]);
    }), t;
  }
  i(Ax, "validateNested");
  function uBe(e) {
    let t = e.name;
    if (z6.default[t]) {
      let {
        message: r,
        version: s = 5
      } = z6.default[t];
      throw new Error(`Using removed Babel ${s} option: ${(0, xe.msg)(e)} - ${r}`);
    } else {
      let r = new Error(`Unknown option: ${(0, xe.msg)(e)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information ab\
out options.`);
      throw r.code = "BABEL_UNKNOWN_OPTION", r;
    }
  }
  i(uBe, "throwUnknownError");
  function cBe(e) {
    if (hasOwnProperty.call(e, "sourceMap") && hasOwnProperty.call(e, "sourceMaps"))
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }
  i(cBe, "assertNoDuplicateSourcemap");
  function fBe(e, t) {
    if (e.parent.type === "env")
      throw new Error(`${(0, xe.msg)(e)} is not allowed inside of another .env block`);
    let r = e.parent, s = (0, xe.assertObject)(e, t);
    if (s)
      for (let n of Object.keys(s)) {
        let a = (0, xe.assertObject)((0, xe.access)(e, n), s[n]);
        if (!a) continue;
        Ax({
          type: "env",
          name: n,
          parent: r
        }, a);
      }
    return s;
  }
  i(fBe, "assertEnvSet");
  function pBe(e, t) {
    if (e.parent.type === "env")
      throw new Error(`${(0, xe.msg)(e)} is not allowed inside an .env block`);
    if (e.parent.type === "overrides")
      throw new Error(`${(0, xe.msg)(e)} is not allowed inside an .overrides block`);
    let r = e.parent, s = (0, xe.assertArray)(e, t);
    if (s)
      for (let [n, a] of s.entries()) {
        let o = (0, xe.access)(e, n), l = (0, xe.assertObject)(o, a);
        if (!l) throw new Error(`${(0, xe.msg)(o)} must be an object`);
        Ax({
          type: "overrides",
          index: n,
          parent: r
        }, l);
      }
    return s;
  }
  i(pBe, "assertOverridesList");
  function dBe(e, t, r, s) {
    if (t === 0) return;
    let n = e[t - 1], a = e[t];
    n.file && n.options === void 0 && typeof a.value == "object" && (s.message += `
- Maybe you meant to use
"${r}s": [
  ["${n.file.request}", ${JSON.stringify(a.value, void 0, 2)}]
]
To be a valid ${r}, its name and options should be wrapped in a pair of brackets`);
  }
  i(dBe, "checkNoUnwrappedItemOptionPairs");
});

// ../node_modules/@babel/core/lib/config/pattern-to-regex.js
var _x = y((Ix) => {
  "use strict";
  Object.defineProperty(Ix, "__esModule", {
    value: !0
  });
  Ix.default = yBe;
  function km() {
    let e = require("path");
    return km = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(km, "_path");
  var Pf = `\\${km().sep}`, Cx = `(?:${Pf}|$)`, wx = `[^${Pf}]+`, Dx = `(?:${wx}${Pf})`, s5 = `(?:${wx}${Cx})`, hBe = `${Dx}*?`, mBe = `${Dx}\
*?${s5}?`;
  function r5(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }
  i(r5, "escapeRegExp");
  function yBe(e, t) {
    let r = km().resolve(t, e).split(km().sep);
    return new RegExp(["^", ...r.map((s, n) => {
      let a = n === r.length - 1;
      return s === "**" ? a ? mBe : hBe : s === "*" ? a ? s5 : Dx : s.indexOf("*.") === 0 ? wx + r5(s.slice(1)) + (a ? Cx : Pf) : r5(s) + (a ?
      Cx : Pf);
    })].join(""));
  }
  i(yBe, "pathToPattern");
});

// ../node_modules/@babel/core/lib/config/printer.js
var a5 = y((Gl) => {
  "use strict";
  Object.defineProperty(Gl, "__esModule", {
    value: !0
  });
  Gl.ConfigPrinter = Gl.ChainFormatter = void 0;
  function i5() {
    let e = As();
    return i5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(i5, "_gensync");
  var gBe = Gl.ChainFormatter = {
    Programmatic: 0,
    Config: 1
  }, Ox = {
    title(e, t, r) {
      let s = "";
      return e === gBe.Programmatic ? (s = "programmatic options", t && (s += " from " + t)) : s = "config " + r, s;
    },
    loc(e, t) {
      let r = "";
      return e != null && (r += `.overrides[${e}]`), t != null && (r += `.env["${t}"]`), r;
    },
    *optionsAndDescriptors(e) {
      let t = Object.assign({}, e.options);
      delete t.overrides, delete t.env;
      let r = [...yield* e.plugins()];
      r.length && (t.plugins = r.map((n) => n5(n)));
      let s = [...yield* e.presets()];
      return s.length && (t.presets = [...s].map((n) => n5(n))), JSON.stringify(t, void 0, 2);
    }
  };
  function n5(e) {
    var t;
    let r = (t = e.file) == null ? void 0 : t.request;
    return r == null && (typeof e.value == "object" ? r = e.value : typeof e.value == "function" && (r = `[Function: ${e.value.toString().slice(
    0, 50)} ... ]`)), r == null && (r = "[Unknown]"), e.options === void 0 ? r : e.name == null ? [r, e.options] : [r, e.options, e.name];
  }
  i(n5, "descriptorToConfig");
  var Nx = class e {
    static {
      i(this, "ConfigPrinter");
    }
    constructor() {
      this._stack = [];
    }
    configure(t, r, {
      callerName: s,
      filepath: n
    }) {
      return t ? (a, o, l) => {
        this._stack.push({
          type: r,
          callerName: s,
          filepath: n,
          content: a,
          index: o,
          envName: l
        });
      } : () => {
      };
    }
    static *format(t) {
      let r = Ox.title(t.type, t.callerName, t.filepath), s = Ox.loc(t.index, t.envName);
      s && (r += ` ${s}`);
      let n = yield* Ox.optionsAndDescriptors(t.content);
      return `${r}
${n}`;
    }
    *output() {
      return this._stack.length === 0 ? "" : (yield* i5().all(this._stack.map((r) => e.format(r)))).join(`

`);
    }
  };
  Gl.ConfigPrinter = Nx;
});

// ../node_modules/@babel/core/lib/config/config-chain.js
var Ux = y((Yl) => {
  "use strict";
  Object.defineProperty(Yl, "__esModule", {
    value: !0
  });
  Yl.buildPresetChain = vBe;
  Yl.buildPresetChainWalker = void 0;
  Yl.buildRootChain = CBe;
  function u5() {
    let e = require("path");
    return u5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(u5, "_path");
  function c5() {
    let e = Qa();
    return c5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(c5, "_debug");
  var Lx = xf(), f5 = _x(), Cf = a5(), bBe = xi(), EBe = yo(), Af = vf(), Tr = mo(), Ks = vx(), o5 = c5()("babel:config:config-chain");
  function* vBe(e, t) {
    let r = yield* SBe(e, t);
    return r ? {
      plugins: Bm(r.plugins),
      presets: Bm(r.presets),
      options: r.options.map((s) => p5(s)),
      files: /* @__PURE__ */ new Set()
    } : null;
  }
  i(vBe, "buildPresetChain");
  var SBe = Yl.buildPresetChainWalker = $x({
    root: /* @__PURE__ */ i((e) => TBe(e), "root"),
    env: /* @__PURE__ */ i((e, t) => xBe(e)(t), "env"),
    overrides: /* @__PURE__ */ i((e, t) => PBe(e)(t), "overrides"),
    overridesEnv: /* @__PURE__ */ i((e, t, r) => ABe(e)(t)(r), "overridesEnv"),
    createLogger: /* @__PURE__ */ i(() => () => {
    }, "createLogger")
  }), TBe = (0, Tr.makeWeakCacheSync)((e) => Bx(e, e.alias, Ks.createUncachedDescriptors)), xBe = (0, Tr.makeWeakCacheSync)((e) => (0, Tr.makeStrongCacheSync)(
  (t) => Mx(e, e.alias, Ks.createUncachedDescriptors, t))), PBe = (0, Tr.makeWeakCacheSync)((e) => (0, Tr.makeStrongCacheSync)((t) => jx(e, e.
  alias, Ks.createUncachedDescriptors, t))), ABe = (0, Tr.makeWeakCacheSync)((e) => (0, Tr.makeStrongCacheSync)((t) => (0, Tr.makeStrongCacheSync)(
  (r) => qx(e, e.alias, Ks.createUncachedDescriptors, t, r))));
  function* CBe(e, t) {
    let r, s, n = new Cf.ConfigPrinter(), a = yield* OBe({
      options: e,
      dirname: t.cwd
    }, t, void 0, n);
    if (!a) return null;
    let o = yield* n.output(), l;
    typeof e.configFile == "string" ? l = yield* (0, Af.loadConfig)(e.configFile, t.cwd, t.envName, t.caller) : e.configFile !== !1 && (l = yield* (0, Af.
    findRootConfig)(t.root, t.envName, t.caller));
    let {
      babelrc: u,
      babelrcRoots: c
    } = e, f = t.cwd, p = Lm(), d = new Cf.ConfigPrinter();
    if (l) {
      let D = DBe(l), C = yield* kx(D, t, void 0, d);
      if (!C) return null;
      r = yield* d.output(), u === void 0 && (u = D.options.babelrc), c === void 0 && (f = D.dirname, c = D.options.babelrcRoots), Kl(p, C);
    }
    let m, b, h = !1, g = Lm();
    if ((u === !0 || u === void 0) && typeof t.filename == "string") {
      let D = yield* (0, Af.findPackageData)(t.filename);
      if (D && wBe(t, D, c, f)) {
        if ({
          ignore: m,
          config: b
        } = yield* (0, Af.findRelativeConfig)(D, t.envName, t.caller), m && g.files.add(m.filepath), m && d5(t, m.ignore, null, m.dirname) &&
        (h = !0), b && !h) {
          let C = IBe(b), N = new Cf.ConfigPrinter(), I = yield* kx(C, t, void 0, N);
          I ? (s = yield* N.output(), Kl(g, I)) : h = !0;
        }
        b && h && g.files.add(b.filepath);
      }
    }
    t.showConfig && console.log(`Babel configs on "${t.filename}" (ascending priority):
` + [r, s, o].filter((D) => !!D).join(`

`) + `
-----End Babel configs-----`);
    let E = Kl(Kl(Kl(Lm(), p), g), a);
    return {
      plugins: h ? [] : Bm(E.plugins),
      presets: h ? [] : Bm(E.presets),
      options: h ? [] : E.options.map((D) => p5(D)),
      fileHandling: h ? "ignored" : "transpile",
      ignore: m || void 0,
      babelrc: b || void 0,
      config: l || void 0,
      files: E.files
    };
  }
  i(CBe, "buildRootChain");
  function wBe(e, t, r, s) {
    if (typeof r == "boolean") return r;
    let n = e.root;
    if (r === void 0)
      return t.directories.indexOf(n) !== -1;
    let a = r;
    return Array.isArray(a) || (a = [a]), a = a.map((o) => typeof o == "string" ? u5().resolve(s, o) : o), a.length === 1 && a[0] === n ? t.
    directories.indexOf(n) !== -1 : a.some((o) => (typeof o == "string" && (o = (0, f5.default)(o, s)), t.directories.some((l) => h5(o, s, l,
    e))));
  }
  i(wBe, "babelrcLoadEnabled");
  var DBe = (0, Tr.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, Lx.validate)("configfile", e.options, e.filepath)
  })), IBe = (0, Tr.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, Lx.validate)("babelrcfile", e.options, e.filepath)
  })), _Be = (0, Tr.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, Lx.validate)("extendsfile", e.options, e.filepath)
  })), OBe = $x({
    root: /* @__PURE__ */ i((e) => Bx(e, "base", Ks.createCachedDescriptors), "root"),
    env: /* @__PURE__ */ i((e, t) => Mx(e, "base", Ks.createCachedDescriptors, t), "env"),
    overrides: /* @__PURE__ */ i((e, t) => jx(e, "base", Ks.createCachedDescriptors, t), "overrides"),
    overridesEnv: /* @__PURE__ */ i((e, t, r) => qx(e, "base", Ks.createCachedDescriptors, t, r), "overridesEnv"),
    createLogger: /* @__PURE__ */ i((e, t, r) => MBe(e, t, r), "createLogger")
  }), NBe = $x({
    root: /* @__PURE__ */ i((e) => RBe(e), "root"),
    env: /* @__PURE__ */ i((e, t) => kBe(e)(t), "env"),
    overrides: /* @__PURE__ */ i((e, t) => FBe(e)(t), "overrides"),
    overridesEnv: /* @__PURE__ */ i((e, t, r) => LBe(e)(t)(r), "overridesEnv"),
    createLogger: /* @__PURE__ */ i((e, t, r) => BBe(e.filepath, t, r), "createLogger")
  });
  function* kx(e, t, r, s) {
    let n = yield* NBe(e, t, r, s);
    return n?.files.add(e.filepath), n;
  }
  i(kx, "loadFileChain");
  var RBe = (0, Tr.makeWeakCacheSync)((e) => Bx(e, e.filepath, Ks.createUncachedDescriptors)), kBe = (0, Tr.makeWeakCacheSync)((e) => (0, Tr.
  makeStrongCacheSync)((t) => Mx(e, e.filepath, Ks.createUncachedDescriptors, t))), FBe = (0, Tr.makeWeakCacheSync)((e) => (0, Tr.makeStrongCacheSync)(
  (t) => jx(e, e.filepath, Ks.createUncachedDescriptors, t))), LBe = (0, Tr.makeWeakCacheSync)((e) => (0, Tr.makeStrongCacheSync)((t) => (0, Tr.
  makeStrongCacheSync)((r) => qx(e, e.filepath, Ks.createUncachedDescriptors, t, r))));
  function BBe(e, t, r) {
    return r ? r.configure(t.showConfig, Cf.ChainFormatter.Config, {
      filepath: e
    }) : () => {
    };
  }
  i(BBe, "buildFileLogger");
  function Bx({
    dirname: e,
    options: t
  }, r, s) {
    return s(e, t, r);
  }
  i(Bx, "buildRootDescriptors");
  function MBe(e, t, r) {
    var s;
    return r ? r.configure(t.showConfig, Cf.ChainFormatter.Programmatic, {
      callerName: (s = t.caller) == null ? void 0 : s.name
    }) : () => {
    };
  }
  i(MBe, "buildProgrammaticLogger");
  function Mx({
    dirname: e,
    options: t
  }, r, s, n) {
    var a;
    let o = (a = t.env) == null ? void 0 : a[n];
    return o ? s(e, o, `${r}.env["${n}"]`) : null;
  }
  i(Mx, "buildEnvDescriptors");
  function jx({
    dirname: e,
    options: t
  }, r, s, n) {
    var a;
    let o = (a = t.overrides) == null ? void 0 : a[n];
    if (!o) throw new Error("Assertion failure - missing override");
    return s(e, o, `${r}.overrides[${n}]`);
  }
  i(jx, "buildOverrideDescriptors");
  function qx({
    dirname: e,
    options: t
  }, r, s, n, a) {
    var o, l;
    let u = (o = t.overrides) == null ? void 0 : o[n];
    if (!u) throw new Error("Assertion failure - missing override");
    let c = (l = u.env) == null ? void 0 : l[a];
    return c ? s(e, c, `${r}.overrides[${n}].env["${a}"]`) : null;
  }
  i(qx, "buildOverrideEnvDescriptors");
  function $x({
    root: e,
    env: t,
    overrides: r,
    overridesEnv: s,
    createLogger: n
  }) {
    return /* @__PURE__ */ i(function* (o, l, u = /* @__PURE__ */ new Set(), c) {
      let {
        dirname: f
      } = o, p = [], d = e(o);
      if (Fm(d, f, l, o.filepath)) {
        p.push({
          config: d,
          envName: void 0,
          index: void 0
        });
        let h = t(o, l.envName);
        h && Fm(h, f, l, o.filepath) && p.push({
          config: h,
          envName: l.envName,
          index: void 0
        }), (d.options.overrides || []).forEach((g, E) => {
          let D = r(o, E);
          if (Fm(D, f, l, o.filepath)) {
            p.push({
              config: D,
              index: E,
              envName: void 0
            });
            let C = s(o, E, l.envName);
            C && Fm(C, f, l, o.filepath) && p.push({
              config: C,
              index: E,
              envName: l.envName
            });
          }
        });
      }
      if (p.some(({
        config: {
          options: {
            ignore: h,
            only: g
          }
        }
      }) => d5(l, h, g, f)))
        return null;
      let m = Lm(), b = n(o, l, c);
      for (let {
        config: h,
        index: g,
        envName: E
      } of p) {
        if (!(yield* jBe(m, h.options, f, l, u, c)))
          return null;
        b(h, g, E), yield* qBe(m, h);
      }
      return m;
    }, "chainWalker");
  }
  i($x, "makeChainWalker");
  function* jBe(e, t, r, s, n, a) {
    if (t.extends === void 0) return !0;
    let o = yield* (0, Af.loadConfig)(t.extends, r, s.envName, s.caller);
    if (n.has(o))
      throw new Error(`Configuration cycle detected loading ${o.filepath}.
File already loaded following the config chain:
` + Array.from(n, (u) => ` - ${u.filepath}`).join(`
`));
    n.add(o);
    let l = yield* kx(_Be(o), s, n, a);
    return n.delete(o), l ? (Kl(e, l), !0) : !1;
  }
  i(jBe, "mergeExtendsChain");
  function Kl(e, t) {
    e.options.push(...t.options), e.plugins.push(...t.plugins), e.presets.push(...t.presets);
    for (let r of t.files)
      e.files.add(r);
    return e;
  }
  i(Kl, "mergeChain");
  function* qBe(e, {
    options: t,
    plugins: r,
    presets: s
  }) {
    return e.options.push(t), e.plugins.push(...yield* r()), e.presets.push(...yield* s()), e;
  }
  i(qBe, "mergeChainOpts");
  function Lm() {
    return {
      options: [],
      presets: [],
      plugins: [],
      files: /* @__PURE__ */ new Set()
    };
  }
  i(Lm, "emptyChain");
  function p5(e) {
    let t = Object.assign({}, e);
    return delete t.extends, delete t.env, delete t.overrides, delete t.plugins, delete t.presets, delete t.passPerPreset, delete t.ignore, delete t.
    only, delete t.test, delete t.include, delete t.exclude, hasOwnProperty.call(t, "sourceMap") && (t.sourceMaps = t.sourceMap, delete t.sourceMap),
    t;
  }
  i(p5, "normalizeOptions");
  function Bm(e) {
    let t = /* @__PURE__ */ new Map(), r = [];
    for (let s of e)
      if (typeof s.value == "function") {
        let n = s.value, a = t.get(n);
        a || (a = /* @__PURE__ */ new Map(), t.set(n, a));
        let o = a.get(s.name);
        o ? o.value = s : (o = {
          value: s
        }, r.push(o), s.ownPass || a.set(s.name, o));
      } else
        r.push({
          value: s
        });
    return r.reduce((s, n) => (s.push(n.value), s), []);
  }
  i(Bm, "dedupDescriptors");
  function Fm({
    options: e
  }, t, r, s) {
    return (e.test === void 0 || Rx(r, e.test, t, s)) && (e.include === void 0 || Rx(r, e.include, t, s)) && (e.exclude === void 0 || !Rx(r,
    e.exclude, t, s));
  }
  i(Fm, "configIsApplicable");
  function Rx(e, t, r, s) {
    let n = Array.isArray(t) ? t : [t];
    return Fx(e, n, r, s);
  }
  i(Rx, "configFieldIsApplicable");
  function l5(e, t) {
    return t instanceof RegExp ? String(t) : t;
  }
  i(l5, "ignoreListReplacer");
  function d5(e, t, r, s) {
    if (t && Fx(e, t, s)) {
      var n;
      let o = `No config is applied to "${(n = e.filename) != null ? n : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(
      t, l5)}\` from "${s}"`;
      return o5(o), e.showConfig && console.log(o), !0;
    }
    if (r && !Fx(e, r, s)) {
      var a;
      let o = `No config is applied to "${(a = e.filename) != null ? a : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(
      r, l5)}\` from "${s}"`;
      return o5(o), e.showConfig && console.log(o), !0;
    }
    return !1;
  }
  i(d5, "shouldIgnore");
  function Fx(e, t, r, s) {
    return t.some((n) => h5(n, r, e.filename, e, s));
  }
  i(Fx, "matchesPatterns");
  function h5(e, t, r, s, n) {
    if (typeof e == "function")
      return !!(0, bBe.endHiddenCallStack)(e)(r, {
        dirname: t,
        envName: s.envName,
        caller: s.caller
      });
    if (typeof r != "string")
      throw new EBe.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", n);
    return typeof e == "string" && (e = (0, f5.default)(e, t)), e.test(r);
  }
  i(h5, "matchPattern");
});

// ../node_modules/@babel/core/lib/config/validation/plugins.js
var m5 = y((Vx) => {
  "use strict";
  Object.defineProperty(Vx, "__esModule", {
    value: !0
  });
  Vx.validatePluginObject = WBe;
  var Oi = Px(), $Be = {
    name: Oi.assertString,
    manipulateOptions: Oi.assertFunction,
    pre: Oi.assertFunction,
    post: Oi.assertFunction,
    inherits: Oi.assertFunction,
    visitor: UBe,
    parserOverride: Oi.assertFunction,
    generatorOverride: Oi.assertFunction
  };
  function UBe(e, t) {
    let r = (0, Oi.assertObject)(e, t);
    if (r && (Object.keys(r).forEach((s) => {
      s !== "_exploded" && s !== "_verified" && VBe(s, r[s]);
    }), r.enter || r.exit))
      throw new Error(`${(0, Oi.msg)(e)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
    return r;
  }
  i(UBe, "assertVisitorMap");
  function VBe(e, t) {
    if (t && typeof t == "object")
      Object.keys(t).forEach((r) => {
        if (r !== "enter" && r !== "exit")
          throw new Error(`.visitor["${e}"] may only have .enter and/or .exit handlers.`);
      });
    else if (typeof t != "function")
      throw new Error(`.visitor["${e}"] must be a function`);
  }
  i(VBe, "assertVisitorHandler");
  function WBe(e) {
    let t = {
      type: "root",
      source: "plugin"
    };
    return Object.keys(e).forEach((r) => {
      let s = $Be[r];
      if (s)
        s({
          type: "option",
          name: r,
          parent: t
        }, e[r]);
      else {
        let n = new Error(`.${r} is not a valid Plugin property`);
        throw n.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", n;
      }
    }), e;
  }
  i(WBe, "validatePluginObject");
});

// ../node_modules/@babel/core/lib/config/helpers/environment.js
var Hx = y((Wx) => {
  "use strict";
  Object.defineProperty(Wx, "__esModule", {
    value: !0
  });
  Wx.getEnv = HBe;
  function HBe(e = "development") {
    return process.env.BABEL_ENV || process.env.NODE_ENV || e;
  }
  i(HBe, "getEnv");
});

// ../node_modules/@babel/core/lib/config/partial.js
var Gx = y(($m) => {
  "use strict";
  Object.defineProperty($m, "__esModule", {
    value: !0
  });
  $m.default = g5;
  $m.loadPartialConfig = tMe;
  function Mm() {
    let e = require("path");
    return Mm = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(Mm, "_path");
  var GBe = nm(), KBe = Wh(), y5 = Ef(), YBe = Ux(), XBe = Hx(), zBe = xf(), jm = vf(), JBe = Ex(), QBe = ["showIgnoredFiles"];
  function ZBe(e, t) {
    if (e == null) return {};
    var r = {}, s = Object.keys(e), n, a;
    for (a = 0; a < s.length; a++)
      n = s[a], !(t.indexOf(n) >= 0) && (r[n] = e[n]);
    return r;
  }
  i(ZBe, "_objectWithoutPropertiesLoose");
  function eMe(e, t) {
    switch (t) {
      case "root":
        return e;
      case "upward-optional": {
        let r = (0, jm.findConfigUpwards)(e);
        return r === null ? e : r;
      }
      case "upward": {
        let r = (0, jm.findConfigUpwards)(e);
        if (r !== null) return r;
        throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e}".\

One of the following config files must be in the directory tree: "${jm.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: e
        });
      }
      default:
        throw new Error("Assertion failure - unknown rootMode value.");
    }
  }
  i(eMe, "resolveRootMode");
  function* g5(e) {
    if (e != null && (typeof e != "object" || Array.isArray(e)))
      throw new Error("Babel options must be an object, null, or undefined");
    let t = e ? (0, zBe.validate)("arguments", e) : {}, {
      envName: r = (0, XBe.getEnv)(),
      cwd: s = ".",
      root: n = ".",
      rootMode: a = "root",
      caller: o,
      cloneInputAst: l = !0
    } = t, u = Mm().resolve(s), c = eMe(Mm().resolve(u, n), a), f = typeof t.filename == "string" ? Mm().resolve(s, t.filename) : void 0, p = yield* (0, jm.
    resolveShowConfigPath)(u), d = {
      filename: f,
      cwd: u,
      root: c,
      envName: r,
      caller: o,
      showConfig: p === f
    }, m = yield* (0, YBe.buildRootChain)(t, d);
    if (!m) return null;
    let b = {
      assumptions: {}
    };
    return m.options.forEach((g) => {
      (0, KBe.mergeOptions)(b, g);
    }), {
      options: Object.assign({}, b, {
        targets: (0, JBe.resolveTargets)(b, c),
        cloneInputAst: l,
        babelrc: !1,
        configFile: !1,
        browserslistConfigFile: !1,
        passPerPreset: !1,
        envName: d.envName,
        cwd: d.cwd,
        root: d.root,
        rootMode: "root",
        filename: typeof d.filename == "string" ? d.filename : void 0,
        plugins: m.plugins.map((g) => (0, y5.createItemFromDescriptor)(g)),
        presets: m.presets.map((g) => (0, y5.createItemFromDescriptor)(g))
      }),
      context: d,
      fileHandling: m.fileHandling,
      ignore: m.ignore,
      babelrc: m.babelrc,
      config: m.config,
      files: m.files
    };
  }
  i(g5, "loadPrivatePartialConfig");
  function* tMe(e) {
    let t = !1;
    if (typeof e == "object" && e !== null && !Array.isArray(e)) {
      var r = e;
      ({
        showIgnoredFiles: t
      } = r), e = ZBe(r, QBe);
    }
    let s = yield* g5(e);
    if (!s) return null;
    let {
      options: n,
      babelrc: a,
      ignore: o,
      config: l,
      fileHandling: u,
      files: c
    } = s;
    return u === "ignored" && !t ? null : ((n.plugins || []).forEach((f) => {
      if (f.value instanceof GBe.default)
        throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
    }), new qm(n, a ? a.filepath : void 0, o ? o.filepath : void 0, l ? l.filepath : void 0, u, c));
  }
  i(tMe, "loadPartialConfig");
  var qm = class {
    static {
      i(this, "PartialConfig");
    }
    constructor(t, r, s, n, a, o) {
      this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files =
      void 0, this.options = t, this.babelignore = s, this.babelrc = r, this.config = n, this.fileHandling = a, this.files = o, Object.freeze(
      this);
    }
    hasFilesystemConfig() {
      return this.babelrc !== void 0 || this.config !== void 0;
    }
  };
  Object.freeze(qm.prototype);
});

// ../node_modules/@babel/core/lib/config/full.js
var C5 = y((Um) => {
  "use strict";
  Object.defineProperty(Um, "__esModule", {
    value: !0
  });
  Um.default = void 0;
  function S5() {
    let e = As();
    return S5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(S5, "_gensync");
  var Xx = Nl(), b5 = Wh(), rMe = mr(), T5 = nm(), sMe = Ef(), nMe = Ux(), Qx = rm();
  function zx() {
    let e = Ms();
    return zx = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(zx, "_traverse");
  var Zx = mo(), Jx = xf(), iMe = m5(), x5 = LT(), aMe = Gx(), oMe = yo(), xit = Um.default = S5()(/* @__PURE__ */ i(function* (t) {
    var r;
    let s = yield* (0, aMe.default)(t);
    if (!s)
      return null;
    let {
      options: n,
      context: a,
      fileHandling: o
    } = s;
    if (o === "ignored")
      return null;
    let l = {}, {
      plugins: u,
      presets: c
    } = n;
    if (!u || !c)
      throw new Error("Assertion failure - plugins and presets exist");
    let f = Object.assign({}, a, {
      targets: n.targets
    }), p = /* @__PURE__ */ i((N) => {
      let I = (0, sMe.getItemDescriptor)(N);
      if (!I)
        throw new Error("Assertion failure - must be config item");
      return I;
    }, "toDescriptor"), d = c.map(p), m = u.map(p), b = [[]], h = [], g = [];
    if (yield* E5(a, /* @__PURE__ */ i(function* N(I, M) {
      let q = [];
      for (let W = 0; W < I.length; W++) {
        let Y = I[W];
        if (Y.options !== !1) {
          try {
            var V = yield* dMe(Y, f);
          } catch (j) {
            throw j.code === "BABEL_UNKNOWN_OPTION" && (0, Jx.checkNoUnwrappedItemOptionPairs)(I, W, "preset", j), j;
          }
          g.push(V.externalDependencies), Y.ownPass ? q.push({
            preset: V.chain,
            pass: []
          }) : q.unshift({
            preset: V.chain,
            pass: M
          });
        }
      }
      if (q.length > 0) {
        b.splice(1, 0, ...q.map((W) => W.pass).filter((W) => W !== M));
        for (let {
          preset: W,
          pass: Y
        } of q) {
          if (!W || (Y.push(...W.plugins), yield* N(W.presets, Y))) return !0;
          W.options.forEach((ie) => {
            (0, b5.mergeOptions)(l, ie);
          });
        }
      }
    }, "recursePresetDescriptors"))(d, b[0])) return null;
    let D = l;
    (0, b5.mergeOptions)(D, n);
    let C = Object.assign({}, f, {
      assumptions: (r = D.assumptions) != null ? r : {}
    });
    return yield* E5(a, /* @__PURE__ */ i(function* () {
      b[0].unshift(...m);
      for (let M of b) {
        let q = [];
        h.push(q);
        for (let V = 0; V < M.length; V++) {
          let W = M[V];
          if (W.options !== !1) {
            try {
              var I = yield* A5(W, C);
            } catch (Y) {
              throw Y.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, Jx.checkNoUnwrappedItemOptionPairs)(M, V, "plugin", Y), Y;
            }
            q.push(I), g.push(I.externalDependencies);
          }
        }
      }
    }, "loadPluginDescriptors"))(), D.plugins = h[0], D.presets = h.slice(1).filter((N) => N.length > 0).map((N) => ({
      plugins: N
    })), D.passPerPreset = D.presets.length > 0, {
      options: D,
      passes: h,
      externalDependencies: (0, Qx.finalize)(g)
    };
  }, "loadFullConfig"));
  function E5(e, t) {
    return function* (r, s) {
      try {
        return yield* t(r, s);
      } catch (a) {
        if (!/^\[BABEL\]/.test(a.message)) {
          var n;
          a.message = `[BABEL] ${(n = e.filename) != null ? n : "unknown file"}: ${a.message}`;
        }
        throw a;
      }
    };
  }
  i(E5, "enhanceError");
  var P5 = /* @__PURE__ */ i((e) => (0, Zx.makeWeakCache)(function* ({
    value: t,
    options: r,
    dirname: s,
    alias: n
  }, a) {
    if (r === !1) throw new Error("Assertion failure");
    r = r || {};
    let o = [], l = t;
    if (typeof t == "function") {
      let u = (0, Xx.maybeAsync)(t, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), c = Object.assign(
      {}, rMe, e(a, o));
      try {
        l = yield* u(c, r, s);
      } catch (f) {
        throw n && (f.message += ` (While processing: ${JSON.stringify(n)})`), f;
      }
    }
    if (!l || typeof l != "object")
      throw new Error("Plugin/Preset did not return an object.");
    if ((0, Xx.isThenable)(l))
      throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you\
're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". \
(While processing: ${JSON.stringify(n)})`);
    if (o.length > 0 && (!a.configured() || a.mode() === "forever")) {
      let u = `A plugin/preset has external untracked dependencies (${o[0]}), but the cache `;
      throw a.configured() ? u += " has been configured to never be invalidated. " : u += "has not been configured to be invalidated when th\
e external dependencies change. ", u += `Plugins/presets should configure their cache to be invalidated when the external dependencies chang\
e, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(n)})`, new Error(u);
    }
    return {
      value: l,
      options: r,
      dirname: s,
      alias: n,
      externalDependencies: (0, Qx.finalize)(o)
    };
  }), "makeDescriptorLoader"), lMe = P5(x5.makePluginAPI), uMe = P5(x5.makePresetAPI), cMe = (0, Zx.makeWeakCache)(function* ({
    value: e,
    options: t,
    dirname: r,
    alias: s,
    externalDependencies: n
  }, a) {
    let o = (0, iMe.validatePluginObject)(e), l = Object.assign({}, o);
    if (l.visitor && (l.visitor = zx().default.explode(Object.assign({}, l.visitor))), l.inherits) {
      let u = {
        name: void 0,
        alias: `${s}$inherits`,
        value: l.inherits,
        options: t,
        dirname: r
      }, c = yield* (0, Xx.forwardAsync)(A5, (f) => a.invalidate((p) => f(u, p)));
      l.pre = Yx(c.pre, l.pre), l.post = Yx(c.post, l.post), l.manipulateOptions = Yx(c.manipulateOptions, l.manipulateOptions), l.visitor =
      zx().default.visitors.merge([c.visitor || {}, l.visitor || {}]), c.externalDependencies.length > 0 && (n.length === 0 ? n = c.externalDependencies :
      n = (0, Qx.finalize)([n, c.externalDependencies]));
    }
    return new T5.default(l, t, s, n);
  });
  function* A5(e, t) {
    if (e.value instanceof T5.default) {
      if (e.options)
        throw new Error("Passed options to an existing Plugin instance will not work.");
      return e.value;
    }
    return yield* cMe(yield* lMe(e, t), t);
  }
  i(A5, "loadPluginDescriptor");
  var Kx = /* @__PURE__ */ i((e) => e && typeof e != "function", "needsFilename"), v5 = /* @__PURE__ */ i((e, t) => {
    if (Kx(e.test) || Kx(e.include) || Kx(e.exclude)) {
      let r = t.name ? `"${t.name}"` : "/* your preset */";
      throw new oMe.default([`Preset ${r} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, {\
 filename: 'file.ts', presets: [${r}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
    }
  }, "validateIfOptionNeedsFilename"), fMe = /* @__PURE__ */ i((e, t, r) => {
    if (!t.filename) {
      var s;
      let {
        options: n
      } = e;
      v5(n, r), (s = n.overrides) == null || s.forEach((a) => v5(a, r));
    }
  }, "validatePreset"), pMe = (0, Zx.makeWeakCacheSync)(({
    value: e,
    dirname: t,
    alias: r,
    externalDependencies: s
  }) => ({
    options: (0, Jx.validate)("preset", e),
    alias: r,
    dirname: t,
    externalDependencies: s
  }));
  function* dMe(e, t) {
    let r = pMe(yield* uMe(e, t));
    return fMe(r, t, e), {
      chain: yield* (0, nMe.buildPresetChain)(r, t),
      externalDependencies: r.externalDependencies
    };
  }
  i(dMe, "loadPresetDescriptor");
  function Yx(e, t) {
    let r = [e, t].filter(Boolean);
    return r.length <= 1 ? r[0] : function(...s) {
      for (let n of r)
        n.apply(this, s);
    };
  }
  i(Yx, "chain");
});

// ../node_modules/@babel/core/lib/config/index.js
var Xl = y((Xs) => {
  "use strict";
  Object.defineProperty(Xs, "__esModule", {
    value: !0
  });
  Xs.createConfigItem = TMe;
  Xs.createConfigItemAsync = SMe;
  Xs.createConfigItemSync = _5;
  Object.defineProperty(Xs, "default", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return w5.default;
    }, "get")
  });
  Xs.loadOptions = vMe;
  Xs.loadOptionsAsync = EMe;
  Xs.loadOptionsSync = I5;
  Xs.loadPartialConfig = gMe;
  Xs.loadPartialConfigAsync = yMe;
  Xs.loadPartialConfigSync = D5;
  function Gm() {
    let e = As();
    return Gm = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(Gm, "_gensync");
  var w5 = C5(), hMe = Gx(), mMe = Ef(), Ys = xi(), Vm = Gm()(hMe.loadPartialConfig);
  function yMe(...e) {
    return (0, Ys.beginHiddenCallStack)(Vm.async)(...e);
  }
  i(yMe, "loadPartialConfigAsync");
  function D5(...e) {
    return (0, Ys.beginHiddenCallStack)(Vm.sync)(...e);
  }
  i(D5, "loadPartialConfigSync");
  function gMe(e, t) {
    if (t !== void 0)
      (0, Ys.beginHiddenCallStack)(Vm.errback)(e, t);
    else if (typeof e == "function")
      (0, Ys.beginHiddenCallStack)(Vm.errback)(void 0, e);
    else
      return D5(e);
  }
  i(gMe, "loadPartialConfig");
  function* bMe(e) {
    var t;
    let r = yield* (0, w5.default)(e);
    return (t = r?.options) != null ? t : null;
  }
  i(bMe, "loadOptionsImpl");
  var Wm = Gm()(bMe);
  function EMe(...e) {
    return (0, Ys.beginHiddenCallStack)(Wm.async)(...e);
  }
  i(EMe, "loadOptionsAsync");
  function I5(...e) {
    return (0, Ys.beginHiddenCallStack)(Wm.sync)(...e);
  }
  i(I5, "loadOptionsSync");
  function vMe(e, t) {
    if (t !== void 0)
      (0, Ys.beginHiddenCallStack)(Wm.errback)(e, t);
    else if (typeof e == "function")
      (0, Ys.beginHiddenCallStack)(Wm.errback)(void 0, e);
    else
      return I5(e);
  }
  i(vMe, "loadOptions");
  var Hm = Gm()(mMe.createConfigItem);
  function SMe(...e) {
    return (0, Ys.beginHiddenCallStack)(Hm.async)(...e);
  }
  i(SMe, "createConfigItemAsync");
  function _5(...e) {
    return (0, Ys.beginHiddenCallStack)(Hm.sync)(...e);
  }
  i(_5, "createConfigItemSync");
  function TMe(e, t, r) {
    if (r !== void 0)
      (0, Ys.beginHiddenCallStack)(Hm.errback)(e, t, r);
    else if (typeof t == "function")
      (0, Ys.beginHiddenCallStack)(Hm.errback)(e, void 0, r);
    else
      return _5(e, t);
  }
  i(TMe, "createConfigItem");
});

// ../node_modules/@babel/core/lib/transformation/plugin-pass.js
var O5 = y((Km) => {
  "use strict";
  Object.defineProperty(Km, "__esModule", {
    value: !0
  });
  Km.default = void 0;
  var wf = class {
    static {
      i(this, "PluginPass");
    }
    constructor(t, r, s) {
      this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0,
      this.key = r, this.file = t, this.opts = s || {}, this.cwd = t.opts.cwd, this.filename = t.opts.filename;
    }
    set(t, r) {
      this._map.set(t, r);
    }
    get(t) {
      return this._map.get(t);
    }
    availableHelper(t, r) {
      return this.file.availableHelper(t, r);
    }
    addHelper(t) {
      return this.file.addHelper(t);
    }
    buildCodeFrameError(t, r, s) {
      return this.file.buildCodeFrameError(t, r, s);
    }
  };
  Km.default = wf;
  wf.prototype.getModuleName = /* @__PURE__ */ i(function() {
    return this.file.getModuleName();
  }, "getModuleName"), wf.prototype.addImport = /* @__PURE__ */ i(function() {
    this.file.addImport();
  }, "addImport");
});

// ../node_modules/@babel/core/lib/transformation/block-hoist-plugin.js
var L5 = y((tP) => {
  "use strict";
  Object.defineProperty(tP, "__esModule", {
    value: !0
  });
  tP.default = PMe;
  function k5() {
    let e = Ms();
    return k5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(k5, "_traverse");
  var xMe = nm(), eP, N5 = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit({
          node: e
        }) {
          e.body = R5(e.body);
        }
      },
      SwitchCase: {
        exit({
          node: e
        }) {
          e.consequent = R5(e.consequent);
        }
      }
    }
  };
  function R5(e) {
    let t = Math.pow(2, 30) - 1, r = !1;
    for (let s = 0; s < e.length; s++) {
      let n = e[s], a = F5(n);
      if (a > t) {
        r = !0;
        break;
      }
      t = a;
    }
    return r ? AMe(e.slice()) : e;
  }
  i(R5, "performHoisting");
  function PMe() {
    return eP || (eP = new xMe.default(Object.assign({}, N5, {
      visitor: k5().default.explode(N5.visitor)
    }), {})), eP;
  }
  i(PMe, "loadBlockHoistPlugin");
  function F5(e) {
    let t = e?._blockHoist;
    return t == null ? 1 : t === !0 ? 2 : t;
  }
  i(F5, "priority");
  function AMe(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let n = 0; n < e.length; n++) {
      let a = e[n], o = F5(a);
      (t[o] || (t[o] = [])).push(a);
    }
    let r = Object.keys(t).map((n) => +n).sort((n, a) => a - n), s = 0;
    for (let n of r) {
      let a = t[n];
      for (let o of a)
        e[s++] = o;
    }
    return e;
  }
  i(AMe, "stableSort");
});

// ../node_modules/@babel/core/lib/transformation/normalize-opts.js
var sP = y((rP) => {
  "use strict";
  Object.defineProperty(rP, "__esModule", {
    value: !0
  });
  rP.default = CMe;
  function Ym() {
    let e = require("path");
    return Ym = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(Ym, "_path");
  function CMe(e) {
    let {
      filename: t,
      cwd: r,
      filenameRelative: s = typeof t == "string" ? Ym().relative(r, t) : "unknown",
      sourceType: n = "module",
      inputSourceMap: a,
      sourceMaps: o = !!a,
      sourceRoot: l = e.options.moduleRoot,
      sourceFileName: u = Ym().basename(s),
      comments: c = !0,
      compact: f = "auto"
    } = e.options, p = e.options, d = Object.assign({}, p, {
      parserOpts: Object.assign({
        sourceType: Ym().extname(s) === ".mjs" ? "module" : n,
        sourceFileName: t,
        plugins: []
      }, p.parserOpts),
      generatorOpts: Object.assign({
        filename: t,
        auxiliaryCommentBefore: p.auxiliaryCommentBefore,
        auxiliaryCommentAfter: p.auxiliaryCommentAfter,
        retainLines: p.retainLines,
        comments: c,
        shouldPrintComment: p.shouldPrintComment,
        compact: f,
        minified: p.minified,
        sourceMaps: o,
        sourceRoot: l,
        sourceFileName: u
      }, p.generatorOpts)
    });
    for (let m of e.passes)
      for (let b of m)
        b.manipulateOptions && b.manipulateOptions(d, d.parserOpts);
    return d;
  }
  i(CMe, "normalizeOptions");
});

// ../node_modules/convert-source-map/index.js
var nP = y((dr) => {
  "use strict";
  Object.defineProperty(dr, "commentRegex", {
    get: /* @__PURE__ */ i(function() {
      return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
    }, "getCommentRegex")
  });
  Object.defineProperty(dr, "mapFileCommentRegex", {
    get: /* @__PURE__ */ i(function() {
      return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
    }, "getMapFileCommentRegex")
  });
  var Xm;
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? Xm = wMe : Xm = DMe : Xm = IMe;
  function wMe(e) {
    return Buffer.from(e, "base64").toString();
  }
  i(wMe, "decodeBase64WithBufferFrom");
  function DMe(e) {
    if (typeof value == "number")
      throw new TypeError("The value to decode must not be of type number.");
    return new Buffer(e, "base64").toString();
  }
  i(DMe, "decodeBase64WithNewBuffer");
  function IMe(e) {
    return decodeURIComponent(escape(atob(e)));
  }
  i(IMe, "decodeBase64WithAtob");
  function _Me(e) {
    return e.split(",").pop();
  }
  i(_Me, "stripComment");
  function OMe(e, t) {
    var r = dr.mapFileCommentRegex.exec(e), s = r[1] || r[2];
    try {
      var e = t(s);
      return e != null && typeof e.catch == "function" ? e.catch(n) : e;
    } catch (a) {
      n(a);
    }
    function n(a) {
      throw new Error("An error occurred while trying to read the map file at " + s + `
` + a.stack);
    }
    i(n, "throwError");
  }
  i(OMe, "readFromFileMap");
  function Wr(e, t) {
    t = t || {}, t.hasComment && (e = _Me(e)), t.encoding === "base64" ? e = Xm(e) : t.encoding === "uri" && (e = decodeURIComponent(e)), (t.
    isJSON || t.encoding) && (e = JSON.parse(e)), this.sourcemap = e;
  }
  i(Wr, "Converter");
  Wr.prototype.toJSON = function(e) {
    return JSON.stringify(this.sourcemap, null, e);
  };
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? Wr.prototype.toBase64 = NMe : Wr.prototype.toBase64 = RMe : Wr.prototype.toBase64 =
  kMe;
  function NMe() {
    var e = this.toJSON();
    return Buffer.from(e, "utf8").toString("base64");
  }
  i(NMe, "encodeBase64WithBufferFrom");
  function RMe() {
    var e = this.toJSON();
    if (typeof e == "number")
      throw new TypeError("The json to encode must not be of type number.");
    return new Buffer(e, "utf8").toString("base64");
  }
  i(RMe, "encodeBase64WithNewBuffer");
  function kMe() {
    var e = this.toJSON();
    return btoa(unescape(encodeURIComponent(e)));
  }
  i(kMe, "encodeBase64WithBtoa");
  Wr.prototype.toURI = function() {
    var e = this.toJSON();
    return encodeURIComponent(e);
  };
  Wr.prototype.toComment = function(e) {
    var t, r, s;
    return e != null && e.encoding === "uri" ? (t = "", r = this.toURI()) : (t = ";base64", r = this.toBase64()), s = "sourceMappingURL=data\
:application/json;charset=utf-8" + t + "," + r, e != null && e.multiline ? "/*# " + s + " */" : "//# " + s;
  };
  Wr.prototype.toObject = function() {
    return JSON.parse(this.toJSON());
  };
  Wr.prototype.addProperty = function(e, t) {
    if (this.sourcemap.hasOwnProperty(e)) throw new Error('property "' + e + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(e, t);
  };
  Wr.prototype.setProperty = function(e, t) {
    return this.sourcemap[e] = t, this;
  };
  Wr.prototype.getProperty = function(e) {
    return this.sourcemap[e];
  };
  dr.fromObject = function(e) {
    return new Wr(e);
  };
  dr.fromJSON = function(e) {
    return new Wr(e, { isJSON: !0 });
  };
  dr.fromURI = function(e) {
    return new Wr(e, { encoding: "uri" });
  };
  dr.fromBase64 = function(e) {
    return new Wr(e, { encoding: "base64" });
  };
  dr.fromComment = function(e) {
    var t, r;
    return e = e.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), t = dr.commentRegex.exec(e), r = t && t[4] || "uri", new Wr(e, { encoding: r,
    hasComment: !0 });
  };
  function B5(e) {
    return new Wr(e, { isJSON: !0 });
  }
  i(B5, "makeConverter");
  dr.fromMapFileComment = function(e, t) {
    if (typeof t == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://githu\
b.com/thlorenz/convert-source-map#upgrading"
      );
    var r = OMe(e, t);
    return r != null && typeof r.then == "function" ? r.then(B5) : B5(r);
  };
  dr.fromSource = function(e) {
    var t = e.match(dr.commentRegex);
    return t ? dr.fromComment(t.pop()) : null;
  };
  dr.fromMapFileSource = function(e, t) {
    if (typeof t == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github\
.com/thlorenz/convert-source-map#upgrading"
      );
    var r = e.match(dr.mapFileCommentRegex);
    return r ? dr.fromMapFileComment(r.pop(), t) : null;
  };
  dr.removeComments = function(e) {
    return e.replace(dr.commentRegex, "");
  };
  dr.removeMapFileComments = function(e) {
    return e.replace(dr.mapFileCommentRegex, "");
  };
  dr.generateMapFileComment = function(e, t) {
    var r = "sourceMappingURL=" + e;
    return t && t.multiline ? "/*# " + r + " */" : "//# " + r;
  };
});

// ../node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js
var q5 = y((iP) => {
  "use strict";
  Object.defineProperty(iP, "__esModule", {
    value: !0
  });
  iP.default = FMe;
  var j5 = {
    asyncDoExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-async-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
      }
    },
    decimal: {
      syntax: {
        name: "@babel/plugin-syntax-decimal",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
      },
      transform: {
        name: "@babel/preset-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
      },
      transform: {
        name: "@babel/preset-react",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
      }
    },
    importAttributes: {
      syntax: {
        name: "@babel/plugin-syntax-import-attributes",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
      },
      transform: {
        name: "@babel/preset-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
      }
    }
  };
  Object.assign(j5, {
    asyncGenerators: {
      syntax: {
        name: "@babel/plugin-syntax-async-generators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
      },
      transform: {
        name: "@babel/plugin-transform-async-generator-functions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
      }
    },
    classProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateMethods: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-private-methods",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
      }
    },
    classStaticBlock: {
      syntax: {
        name: "@babel/plugin-syntax-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
      },
      transform: {
        name: "@babel/plugin-transform-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
      }
    },
    dynamicImport: {
      syntax: {
        name: "@babel/plugin-syntax-dynamic-import",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
      }
    },
    exportNamespaceFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
      },
      transform: {
        name: "@babel/plugin-transform-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
      }
    },
    importAssertions: {
      syntax: {
        name: "@babel/plugin-syntax-import-assertions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
      }
    },
    importMeta: {
      syntax: {
        name: "@babel/plugin-syntax-import-meta",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
      }
    },
    logicalAssignment: {
      syntax: {
        name: "@babel/plugin-syntax-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
      },
      transform: {
        name: "@babel/plugin-transform-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
      }
    },
    moduleStringNames: {
      syntax: {
        name: "@babel/plugin-syntax-module-string-names",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
      }
    },
    numericSeparator: {
      syntax: {
        name: "@babel/plugin-syntax-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
      },
      transform: {
        name: "@babel/plugin-transform-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
      }
    },
    nullishCoalescingOperator: {
      syntax: {
        name: "@babel/plugin-syntax-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
      },
      transform: {
        name: "@babel/plugin-transform-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
      }
    },
    objectRestSpread: {
      syntax: {
        name: "@babel/plugin-syntax-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
      },
      transform: {
        name: "@babel/plugin-transform-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
      }
    },
    optionalCatchBinding: {
      syntax: {
        name: "@babel/plugin-syntax-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
      },
      transform: {
        name: "@babel/plugin-transform-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
      }
    },
    optionalChaining: {
      syntax: {
        name: "@babel/plugin-syntax-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
      },
      transform: {
        name: "@babel/plugin-transform-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
      }
    },
    privateIn: {
      syntax: {
        name: "@babel/plugin-syntax-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
      },
      transform: {
        name: "@babel/plugin-transform-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
      }
    },
    regexpUnicodeSets: {
      syntax: {
        name: "@babel/plugin-syntax-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
      },
      transform: {
        name: "@babel/plugin-transform-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
      }
    }
  });
  var M5 = /* @__PURE__ */ i(({
    name: e,
    url: t
  }) => `${e} (${t})`, "getNameURLCombination");
  function FMe(e, t, r, s) {
    let n = `Support for the experimental syntax '${e}' isn't currently enabled (${t.line}:${t.column + 1}):

` + r, a = j5[e];
    if (a) {
      let {
        syntax: l,
        transform: u
      } = a;
      if (l) {
        let c = M5(l);
        if (u) {
          let f = M5(u), p = u.name.startsWith("@babel/plugin") ? "plugins" : "presets";
          n += `

Add ${f} to the '${p}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${c} to the 'plugins' section to enable parsing.`;
        } else
          n += `

Add ${c} to the 'plugins' section of your Babel config to enable parsing.`;
      }
    }
    return n += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${s === "unknown" ? "<name of the input file>" : s} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, n;
  }
  i(FMe, "generateMissingPluginMessage");
});

// ../node_modules/@babel/core/lib/parser/index.js
var lP = y((oP) => {
  "use strict";
  Object.defineProperty(oP, "__esModule", {
    value: !0
  });
  oP.default = BMe;
  function aP() {
    let e = ao();
    return aP = /* @__PURE__ */ i(function() {
      return e;
    }, "_parser"), e;
  }
  i(aP, "_parser");
  function $5() {
    let e = xc();
    return $5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_codeFrame"), e;
  }
  i($5, "_codeFrame");
  var LMe = q5();
  function* BMe(e, {
    parserOpts: t,
    highlightCode: r = !0,
    filename: s = "unknown"
  }, n) {
    try {
      let a = [];
      for (let o of e)
        for (let l of o) {
          let {
            parserOverride: u
          } = l;
          if (u) {
            let c = u(n, t, aP().parse);
            c !== void 0 && a.push(c);
          }
        }
      if (a.length === 0)
        return (0, aP().parse)(n, t);
      if (a.length === 1) {
        if (yield* [], typeof a[0].then == "function")
          throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're us\
ing a published plugin, you may need to upgrade your @babel/core version.");
        return a[0];
      }
      throw new Error("More than one plugin attempted to override parsing.");
    } catch (a) {
      a.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (a.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
      let {
        loc: o,
        missingPlugin: l
      } = a;
      if (o) {
        let u = (0, $5().codeFrameColumns)(n, {
          start: {
            line: o.line,
            column: o.column + 1
          }
        }, {
          highlightCode: r
        });
        l ? a.message = `${s}: ` + (0, LMe.default)(l[0], o, u, s) : a.message = `${s}: ${a.message}

` + u, a.code = "BABEL_PARSE_ERROR";
      }
      throw a;
    }
  }
  i(BMe, "parser");
});

// ../node_modules/@babel/core/lib/transformation/util/clone-deep.js
var U5 = y((cP) => {
  "use strict";
  Object.defineProperty(cP, "__esModule", {
    value: !0
  });
  cP.default = MMe;
  function uP(e, t) {
    if (e !== null) {
      if (t.has(e)) return t.get(e);
      let r;
      if (Array.isArray(e)) {
        r = new Array(e.length), t.set(e, r);
        for (let s = 0; s < e.length; s++)
          r[s] = typeof e[s] != "object" ? e[s] : uP(e[s], t);
      } else {
        r = {}, t.set(e, r);
        let s = Object.keys(e);
        for (let n = 0; n < s.length; n++) {
          let a = s[n];
          r[a] = typeof e[a] != "object" ? e[a] : uP(e[a], t);
        }
      }
      return r;
    }
    return e;
  }
  i(uP, "deepClone");
  function MMe(e) {
    return typeof e != "object" ? e : uP(e, /* @__PURE__ */ new Map());
  }
  i(MMe, "_default");
});

// ../node_modules/@babel/core/lib/transformation/normalize-file.js
var Y5 = y((hP) => {
  "use strict";
  Object.defineProperty(hP, "__esModule", {
    value: !0
  });
  hP.default = HMe;
  function H5() {
    let e = require("fs");
    return H5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(H5, "_fs");
  function dP() {
    let e = require("path");
    return dP = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(dP, "_path");
  function G5() {
    let e = Qa();
    return G5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(G5, "_debug");
  function K5() {
    let e = Ne();
    return K5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_t"), e;
  }
  i(K5, "_t");
  function zm() {
    let e = nP();
    return zm = /* @__PURE__ */ i(function() {
      return e;
    }, "_convertSourceMap"), e;
  }
  i(zm, "_convertSourceMap");
  var jMe = Mh(), qMe = lP(), $Me = U5(), {
    file: UMe,
    traverseFast: VMe
  } = K5(), fP = G5()("babel:transform:file"), WMe = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/,
  V5 = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
  function* HMe(e, t, r, s) {
    if (r = `${r || ""}`, s) {
      if (s.type === "Program")
        s = UMe(s, [], []);
      else if (s.type !== "File")
        throw new Error("AST root must be a Program or File node");
      t.cloneInputAst && (s = (0, $Me.default)(s));
    } else
      s = yield* (0, qMe.default)(e, t, r);
    let n = null;
    if (t.inputSourceMap !== !1) {
      if (typeof t.inputSourceMap == "object" && (n = zm().fromObject(t.inputSourceMap)), !n) {
        let a = W5(WMe, s);
        if (a)
          try {
            n = zm().fromComment("//" + a);
          } catch {
            fP("discarding unknown inline input sourcemap");
          }
      }
      if (!n) {
        let a = W5(V5, s);
        if (typeof t.filename == "string" && a)
          try {
            let o = V5.exec(a), l = H5().readFileSync(dP().resolve(dP().dirname(t.filename), o[1]), "utf8");
            n = zm().fromJSON(l);
          } catch (o) {
            fP("discarding unknown file input sourcemap", o);
          }
        else a && fP("discarding un-loadable file input sourcemap");
      }
    }
    return new jMe.default(t, {
      code: r,
      ast: s,
      inputMap: n
    });
  }
  i(HMe, "normalizeFile");
  function pP(e, t, r) {
    return t && (t = t.filter(({
      value: s
    }) => e.test(s) ? (r = s, !1) : !0)), [t, r];
  }
  i(pP, "extractCommentsFromList");
  function W5(e, t) {
    let r = null;
    return VMe(t, (s) => {
      [s.leadingComments, r] = pP(e, s.leadingComments, r), [s.innerComments, r] = pP(e, s.innerComments, r), [s.trailingComments, r] = pP(e,
      s.trailingComments, r);
    }), r;
  }
  i(W5, "extractComments");
});

// ../node_modules/@ampproject/remapping/dist/remapping.umd.js
var X5 = y((mP, yP) => {
  (function(e, t) {
    typeof mP == "object" && typeof yP < "u" ? yP.exports = t(Ed(), Av()) : typeof define == "function" && define.amd ? define(["@jridgewell\
/trace-mapping", "@jridgewell/gen-mapping"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, e.remapping = t(e.traceMapping, e.genMapping));
  })(mP, function(e, t) {
    "use strict";
    let r = /* @__PURE__ */ n("", -1, -1, "", null, !1), s = [];
    function n(h, g, E, D, C, N) {
      return { source: h, line: g, column: E, name: D, content: C, ignore: N };
    }
    i(n, "SegmentObject");
    function a(h, g, E, D, C) {
      return {
        map: h,
        sources: g,
        source: E,
        content: D,
        ignore: C
      };
    }
    i(a, "Source");
    function o(h, g) {
      return a(h, g, "", null, !1);
    }
    i(o, "MapSource");
    function l(h, g, E) {
      return a(null, s, h, g, E);
    }
    i(l, "OriginalSource");
    function u(h) {
      let g = new t.GenMapping({ file: h.map.file }), { sources: E, map: D } = h, C = D.names, N = e.decodedMappings(D);
      for (let I = 0; I < N.length; I++) {
        let M = N[I];
        for (let q = 0; q < M.length; q++) {
          let V = M[q], W = V[0], Y = r;
          if (V.length !== 1) {
            let re = E[V[1]];
            if (Y = c(re, V[2], V[3], V.length === 5 ? C[V[4]] : ""), Y == null)
              continue;
          }
          let { column: j, line: ie, name: fe, content: De, source: F, ignore: L } = Y;
          t.maybeAddSegment(g, I, W, F, ie, j, fe), F && De != null && t.setSourceContent(g, F, De), L && t.setIgnore(g, F, !0);
        }
      }
      return g;
    }
    i(u, "traceMappings");
    function c(h, g, E, D) {
      if (!h.map)
        return n(h.source, g, E, D, h.content, h.ignore);
      let C = e.traceSegment(h.map, g, E);
      return C == null ? null : C.length === 1 ? r : c(h.sources[C[1]], C[2], C[3], C.length === 5 ? h.map.names[C[4]] : D);
    }
    i(c, "originalPositionFor");
    function f(h) {
      return Array.isArray(h) ? h : [h];
    }
    i(f, "asArray");
    function p(h, g) {
      let E = f(h).map((N) => new e.TraceMap(N, "")), D = E.pop();
      for (let N = 0; N < E.length; N++)
        if (E[N].sources.length > 1)
          throw new Error(`Transformation map ${N} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
      let C = d(D, g, "", 0);
      for (let N = E.length - 1; N >= 0; N--)
        C = o(E[N], [C]);
      return C;
    }
    i(p, "buildSourceMapTree");
    function d(h, g, E, D) {
      let { resolvedSources: C, sourcesContent: N, ignoreList: I } = h, M = D + 1, q = C.map((V, W) => {
        let Y = {
          importer: E,
          depth: M,
          source: V || "",
          content: void 0,
          ignore: void 0
        }, j = g(Y.source, Y), { source: ie, content: fe, ignore: De } = Y;
        if (j)
          return d(new e.TraceMap(j, ie), g, ie, M);
        let F = fe !== void 0 ? fe : N ? N[W] : null, L = De !== void 0 ? De : I ? I.includes(W) : !1;
        return l(ie, F, L);
      });
      return o(h, q);
    }
    i(d, "build");
    class m {
      static {
        i(this, "SourceMap");
      }
      constructor(g, E) {
        let D = E.decodedMappings ? t.toDecodedMap(g) : t.toEncodedMap(g);
        this.version = D.version, this.file = D.file, this.mappings = D.mappings, this.names = D.names, this.ignoreList = D.ignoreList, this.
        sourceRoot = D.sourceRoot, this.sources = D.sources, E.excludeContent || (this.sourcesContent = D.sourcesContent);
      }
      toString() {
        return JSON.stringify(this);
      }
    }
    function b(h, g, E) {
      let D = typeof E == "object" ? E : { excludeContent: !!E, decodedMappings: !1 }, C = p(h, g);
      return new m(u(C), D);
    }
    return i(b, "remapping"), b;
  });
});

// ../node_modules/@babel/core/lib/transformation/file/merge-map.js
var Q5 = y((gP) => {
  "use strict";
  Object.defineProperty(gP, "__esModule", {
    value: !0
  });
  gP.default = GMe;
  function J5() {
    let e = X5();
    return J5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_remapping"), e;
  }
  i(J5, "_remapping");
  function GMe(e, t, r) {
    let s = r.replace(/\\/g, "/"), n = !1, a = J5()(z5(t), (o, l) => o === s && !n ? (n = !0, l.source = "", z5(e)) : null);
    return typeof e.sourceRoot == "string" && (a.sourceRoot = e.sourceRoot), Object.assign({}, a);
  }
  i(GMe, "mergeSourceMap");
  function z5(e) {
    return Object.assign({}, e, {
      sourceRoot: null
    });
  }
  i(z5, "rootless");
});

// ../node_modules/@babel/core/lib/transformation/file/generate.js
var e9 = y((EP) => {
  "use strict";
  Object.defineProperty(EP, "__esModule", {
    value: !0
  });
  EP.default = YMe;
  function Z5() {
    let e = nP();
    return Z5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_convertSourceMap"), e;
  }
  i(Z5, "_convertSourceMap");
  function bP() {
    let e = Nd();
    return bP = /* @__PURE__ */ i(function() {
      return e;
    }, "_generator"), e;
  }
  i(bP, "_generator");
  var KMe = Q5();
  function YMe(e, t) {
    let {
      opts: r,
      ast: s,
      code: n,
      inputMap: a
    } = t, {
      generatorOpts: o
    } = r;
    o.inputSourceMap = a?.toObject();
    let l = [];
    for (let p of e)
      for (let d of p) {
        let {
          generatorOverride: m
        } = d;
        if (m) {
          let b = m(s, o, n, bP().default);
          b !== void 0 && l.push(b);
        }
      }
    let u;
    if (l.length === 0)
      u = (0, bP().default)(s, o, n);
    else if (l.length === 1) {
      if (u = l[0], typeof u.then == "function")
        throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're usi\
ng a published plugin, you may need to upgrade your @babel/core version.");
    } else
      throw new Error("More than one plugin attempted to override codegen.");
    let {
      code: c,
      decodedMap: f = u.map
    } = u;
    return u.__mergedMap ? f = Object.assign({}, u.map) : f && (a ? f = (0, KMe.default)(a.toObject(), f, o.sourceFileName) : f = u.map), (r.
    sourceMaps === "inline" || r.sourceMaps === "both") && (c += `
` + Z5().fromObject(f).toComment()), r.sourceMaps === "inline" && (f = null), {
      outputCode: c,
      outputMap: f
    };
  }
  i(YMe, "generateCode");
});

// ../node_modules/@babel/core/lib/transformation/index.js
var Jm = y((SP) => {
  "use strict";
  Object.defineProperty(SP, "__esModule", {
    value: !0
  });
  SP.run = tje;
  function vP() {
    let e = Ms();
    return vP = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(vP, "_traverse");
  var XMe = O5(), zMe = L5(), JMe = sP(), QMe = Y5(), ZMe = e9(), eje = rm();
  function* tje(e, t, r) {
    let s = yield* (0, QMe.default)(e.passes, (0, JMe.default)(e), t, r), n = s.opts;
    try {
      yield* rje(s, e.passes);
    } catch (c) {
      var a;
      throw c.message = `${(a = n.filename) != null ? a : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_TRANSFORM_ERROR"), c;
    }
    let o, l;
    try {
      n.code !== !1 && ({
        outputCode: o,
        outputMap: l
      } = (0, ZMe.default)(e.passes, s));
    } catch (c) {
      var u;
      throw c.message = `${(u = n.filename) != null ? u : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_GENERATE_ERROR"), c;
    }
    return {
      metadata: s.metadata,
      options: n,
      ast: n.ast === !0 ? s.ast : null,
      code: o === void 0 ? null : o,
      map: l === void 0 ? null : l,
      sourceType: s.ast.program.sourceType,
      externalDependencies: (0, eje.flattenToSet)(e.externalDependencies)
    };
  }
  i(tje, "run");
  function* rje(e, t) {
    for (let r of t) {
      let s = [], n = [], a = [];
      for (let l of r.concat([(0, zMe.default)()])) {
        let u = new XMe.default(e, l.key, l.options);
        s.push([l, u]), n.push(u), a.push(l.visitor);
      }
      for (let [l, u] of s) {
        let c = l.pre;
        if (c) {
          let f = c.call(u, e);
          if (yield* [], t9(f))
            throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If y\
ou're using a published plugin, you may need to upgrade your @babel/core version.");
        }
      }
      let o = vP().default.visitors.merge(a, n, e.opts.wrapPluginVisitorMethod);
      (0, vP().default)(e.ast, o, e.scope);
      for (let [l, u] of s) {
        let c = l.post;
        if (c) {
          let f = c.call(u, e);
          if (yield* [], t9(f))
            throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If \
you're using a published plugin, you may need to upgrade your @babel/core version.");
        }
      }
    }
  }
  i(rje, "transformFile");
  function t9(e) {
    return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
  }
  i(t9, "isThenable");
});

// ../node_modules/@babel/core/lib/transform-file.js
var xP = y((Df) => {
  "use strict";
  Object.defineProperty(Df, "__esModule", {
    value: !0
  });
  Df.transformFile = aje;
  Df.transformFileAsync = lje;
  Df.transformFileSync = oje;
  function r9() {
    let e = As();
    return r9 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(r9, "_gensync");
  var sje = Xl(), nje = Jm(), ije = Gh(), TP = r9()(function* (e, t) {
    let r = Object.assign({}, t, {
      filename: e
    }), s = yield* (0, sje.default)(r);
    if (s === null) return null;
    let n = yield* ije.readFile(e, "utf8");
    return yield* (0, nje.run)(s, n);
  });
  function aje(...e) {
    TP.errback(...e);
  }
  i(aje, "transformFile");
  function oje(...e) {
    return TP.sync(...e);
  }
  i(oje, "transformFileSync");
  function lje(...e) {
    return TP.async(...e);
  }
  i(lje, "transformFileAsync");
});

// ../node_modules/@babel/core/lib/config/files/import.cjs
var n9 = y((Zit, s9) => {
  s9.exports = /* @__PURE__ */ i(function(t) {
    return import(t);
  }, "import_");
});

// ../node_modules/@babel/preset-typescript/package.json
var i9 = y((tat, uje) => {
  uje.exports = {
    name: "@babel/preset-typescript",
    version: "7.24.1",
    description: "Babel preset for TypeScript.",
    repository: {
      type: "git",
      url: "https://github.com/babel/babel.git",
      directory: "packages/babel-preset-typescript"
    },
    license: "MIT",
    publishConfig: {
      access: "public"
    },
    main: "./lib/index.js",
    keywords: [
      "babel-preset",
      "typescript"
    ],
    dependencies: {
      "@babel/helper-plugin-utils": "^7.24.0",
      "@babel/helper-validator-option": "^7.23.5",
      "@babel/plugin-syntax-jsx": "^7.24.1",
      "@babel/plugin-transform-modules-commonjs": "^7.24.1",
      "@babel/plugin-transform-typescript": "^7.24.1"
    },
    peerDependencies: {
      "@babel/core": "^7.0.0-0"
    },
    devDependencies: {
      "@babel/core": "^7.24.1",
      "@babel/helper-plugin-test-runner": "^7.24.1"
    },
    homepage: "https://babel.dev/docs/en/next/babel-preset-typescript",
    bugs: "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen",
    engines: {
      node: ">=6.9.0"
    },
    author: "The Babel Team (https://babel.dev/team)",
    type: "commonjs"
  };
});

// ../node_modules/@babel/helper-plugin-utils/lib/index.js
var zl = y((If) => {
  "use strict";
  Object.defineProperty(If, "__esModule", {
    value: !0
  });
  If.declare = a9;
  If.declarePreset = void 0;
  var PP = {
    assertVersion: /* @__PURE__ */ i((e) => (t) => {
      fje(t, e.version);
    }, "assertVersion")
  };
  Object.assign(PP, {
    targets: /* @__PURE__ */ i(() => () => ({}), "targets"),
    assumption: /* @__PURE__ */ i(() => () => {
    }, "assumption")
  });
  function a9(e) {
    return (t, r, s) => {
      var n;
      let a;
      for (let l of Object.keys(PP)) {
        var o;
        t[l] || ((o = a) != null || (a = cje(t)), a[l] = PP[l](a));
      }
      return e((n = a) != null ? n : t, r || {}, s);
    };
  }
  i(a9, "declare");
  var rat = If.declarePreset = a9;
  function cje(e) {
    let t = null;
    return typeof e.version == "string" && /^7\./.test(e.version) && (t = Object.getPrototypeOf(e), t && (!hasOwnProperty.call(t, "version") ||
    !hasOwnProperty.call(t, "transform") || !hasOwnProperty.call(t, "template") || !hasOwnProperty.call(t, "types")) && (t = null)), Object.
    assign({}, t, e);
  }
  i(cje, "copyApiObject");
  function fje(e, t) {
    if (typeof e == "number") {
      if (!Number.isInteger(e))
        throw new Error("Expected string or integer value.");
      e = `^${e}.0.0-0`;
    }
    if (typeof e != "string")
      throw new Error("Expected string or integer value.");
    let r = Error.stackTraceLimit;
    typeof r == "number" && r < 25 && (Error.stackTraceLimit = 25);
    let s;
    throw t.slice(0, 2) === "7." ? s = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". You'll need to update your @b\
abel/core version.`) : s = new Error(`Requires Babel "${e}", but was loaded with "${t}". If you are sure you have a compatible version of @b\
abel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for\
 the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof r == "number" && (Error.stackTraceLimit =
    r), Object.assign(s, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: t,
      range: e
    });
  }
  i(fje, "throwVersionError");
});

// ../node_modules/@babel/plugin-syntax-typescript/lib/index.js
var o9 = y((Qm) => {
  "use strict";
  Object.defineProperty(Qm, "__esModule", {
    value: !0
  });
  Qm.default = void 0;
  var pje = zl();
  AP = /* @__PURE__ */ i(function(e, t) {
    let r = [];
    e.forEach((s, n) => {
      (Array.isArray(s) ? s[0] : s) === t && r.unshift(n);
    });
    for (let s of r)
      e.splice(s, 1);
  }, "removePlugin");
  var AP, iat = Qm.default = (0, pje.declare)((e, t) => {
    e.assertVersion(7);
    let {
      disallowAmbiguousJSXLike: r,
      dts: s
    } = t;
    var {
      isTSX: n
    } = t;
    return {
      name: "syntax-typescript",
      manipulateOptions(a, o) {
        {
          let {
            plugins: l
          } = o;
          AP(l, "flow"), AP(l, "jsx"), l.push("objectRestSpread", "classProperties"), n && l.push("jsx");
        }
        o.plugins.push(["typescript", {
          disallowAmbiguousJSXLike: r,
          dts: s
        }]);
      }
    };
  });
});

// ../node_modules/@babel/helper-member-expression-to-functions/lib/index.js
var _P = y((IP) => {
  "use strict";
  Object.defineProperty(IP, "__esModule", { value: !0 });
  var dje = Ne();
  function hje(e) {
    if (e && e.__esModule) return e;
    var t = /* @__PURE__ */ Object.create(null);
    return e && Object.keys(e).forEach(function(r) {
      if (r !== "default") {
        var s = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(t, r, s.get ? s : {
          enumerable: !0,
          get: /* @__PURE__ */ i(function() {
            return e[r];
          }, "get")
        });
      }
    }), t.default = e, Object.freeze(t);
  }
  i(hje, "_interopNamespace");
  var mje = /* @__PURE__ */ hje(dje);
  function wP(e) {
    let t = e, {
      node: r,
      parentPath: s
    } = t;
    if (s.isLogicalExpression()) {
      let {
        operator: n,
        right: a
      } = s.node;
      if (n === "&&" || n === "||" || n === "??" && r === a)
        return wP(s);
    }
    if (s.isSequenceExpression()) {
      let {
        expressions: n
      } = s.node;
      return n[n.length - 1] === r ? wP(s) : !0;
    }
    return s.isConditional({
      test: r
    }) || s.isUnaryExpression({
      operator: "!"
    }) || s.isLoop({
      test: r
    });
  }
  i(wP, "willPathCastToBoolean");
  var {
    LOGICAL_OPERATORS: yje,
    arrowFunctionExpression: l9,
    assignmentExpression: Jl,
    binaryExpression: Ao,
    booleanLiteral: gje,
    callExpression: ty,
    cloneNode: zs,
    conditionalExpression: bje,
    identifier: d9,
    isMemberExpression: Eje,
    isOptionalCallExpression: vje,
    isOptionalMemberExpression: h9,
    isUpdateExpression: Sje,
    logicalExpression: ey,
    memberExpression: u9,
    nullLiteral: Zm,
    optionalCallExpression: Tje,
    optionalMemberExpression: xje,
    sequenceExpression: CP,
    updateExpression: c9
  } = mje, DP = class {
    static {
      i(this, "AssignmentMemoiser");
    }
    constructor() {
      this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
    }
    has(t) {
      return this._map.has(t);
    }
    get(t) {
      if (!this.has(t)) return;
      let r = this._map.get(t), {
        value: s
      } = r;
      return r.count--, r.count === 0 ? Jl("=", s, t) : s;
    }
    set(t, r, s) {
      return this._map.set(t, {
        count: s,
        value: r
      });
    }
  };
  function f9(e, t) {
    let {
      node: r
    } = e;
    if (h9(r))
      return u9(t, r.property, r.computed);
    if (e.isOptionalCallExpression()) {
      let s = e.get("callee");
      if (e.node.optional && s.isOptionalMemberExpression()) {
        let n = s.node.object, a = e.scope.maybeGenerateMemoised(n);
        return s.get("object").replaceWith(Jl("=", a, n)), ty(u9(t, d9("call")), [a, ...e.node.arguments]);
      }
      return ty(t, e.node.arguments);
    }
    return e.node;
  }
  i(f9, "toNonOptional");
  function Pje(e) {
    for (; e && !e.isProgram(); ) {
      let {
        parentPath: t,
        container: r,
        listKey: s
      } = e, n = t.node;
      if (s) {
        if (r !== n[s])
          return !0;
      } else if (r !== n) return !0;
      e = t;
    }
    return !1;
  }
  i(Pje, "isInDetachedTree");
  var Aje = {
    memoise() {
    },
    handle(e, t) {
      let {
        node: r,
        parent: s,
        parentPath: n,
        scope: a
      } = e;
      if (e.isOptionalMemberExpression()) {
        if (Pje(e)) return;
        let o = e.find(({
          node: q,
          parent: V
        }) => h9(V) ? V.optional || V.object !== q : vje(V) ? q !== e.node && V.optional || V.callee !== q : !0);
        if (a.path.isPattern()) {
          o.replaceWith(ty(l9([], o.node), []));
          return;
        }
        let l = wP(o), u = o.parentPath;
        if (u.isUpdateExpression({
          argument: r
        }))
          throw e.buildCodeFrameError("can't handle update expression");
        let c = u.isAssignmentExpression({
          left: o.node
        }), f = u.isUnaryExpression({
          operator: "delete"
        });
        if (f && o.isOptionalMemberExpression() && o.get("property").isPrivateName())
          throw e.buildCodeFrameError("can't delete a private class element");
        let p = e;
        for (; ; ) {
          if (p.isOptionalMemberExpression()) {
            if (p.node.optional) break;
            p = p.get("object");
            continue;
          } else if (p.isOptionalCallExpression()) {
            if (p.node.optional) break;
            p = p.get("callee");
            continue;
          }
          throw new Error(`Internal error: unexpected ${p.node.type}`);
        }
        let d = p.isOptionalMemberExpression() ? p.node.object : p.node.callee, m = a.maybeGenerateMemoised(d), b = m ?? d, h = n.isOptionalCallExpression(
        {
          callee: r
        }), g = /* @__PURE__ */ i((q) => h, "isOptionalCall"), E = n.isCallExpression({
          callee: r
        });
        p.replaceWith(f9(p, b)), g() ? s.optional ? n.replaceWith(this.optionalCall(e, s.arguments)) : n.replaceWith(this.call(e, s.arguments)) :
        E ? e.replaceWith(this.boundGet(e)) : this.delete && n.isUnaryExpression({
          operator: "delete"
        }) ? n.replaceWith(this.delete(e)) : n.isAssignmentExpression() ? p9(this, e, n) : e.replaceWith(this.get(e));
        let D = e.node;
        for (let q = e; q !== o; ) {
          let V = q.parentPath;
          if (V === o && g() && s.optional) {
            D = V.node;
            break;
          }
          D = f9(V, D), q = V;
        }
        let C, N = o.parentPath;
        if (Eje(D) && N.isOptionalCallExpression({
          callee: o.node,
          optional: !0
        })) {
          let {
            object: q
          } = D;
          C = e.scope.maybeGenerateMemoised(q), C && (D.object = Jl("=", C, q));
        }
        let I = o;
        (f || c) && (I = N, D = N.node);
        let M = m ? Jl("=", zs(b), zs(d)) : zs(b);
        if (l) {
          let q;
          t ? q = Ao("!=", M, Zm()) : q = ey("&&", Ao("!==", M, Zm()), Ao("!==", zs(b), a.buildUndefinedNode())), I.replaceWith(ey("&&", q, D));
        } else {
          let q;
          t ? q = Ao("==", M, Zm()) : q = ey("||", Ao("===", M, Zm()), Ao("===", zs(b), a.buildUndefinedNode())), I.replaceWith(bje(q, f ? gje(
          !0) : a.buildUndefinedNode(), D));
        }
        if (C) {
          let q = N.node;
          N.replaceWith(Tje(xje(q.callee, d9("call"), !1, !0), [zs(C), ...q.arguments], !1));
        }
        return;
      }
      if (Sje(s, {
        argument: r
      })) {
        if (this.simpleSet) {
          e.replaceWith(this.simpleSet(e));
          return;
        }
        let {
          operator: o,
          prefix: l
        } = s;
        this.memoise(e, 2);
        let u = a.generateUidIdentifierBasedOnNode(r);
        a.push({
          id: u
        });
        let c = [Jl("=", zs(u), this.get(e))];
        if (l) {
          c.push(c9(o, zs(u), l));
          let f = CP(c);
          n.replaceWith(this.set(e, f));
          return;
        } else {
          let f = a.generateUidIdentifierBasedOnNode(r);
          a.push({
            id: f
          }), c.push(Jl("=", zs(f), c9(o, zs(u), l)), zs(u));
          let p = CP(c);
          n.replaceWith(CP([this.set(e, p), zs(f)]));
          return;
        }
      }
      if (n.isAssignmentExpression({
        left: r
      })) {
        p9(this, e, n);
        return;
      }
      if (n.isCallExpression({
        callee: r
      })) {
        n.replaceWith(this.call(e, n.node.arguments));
        return;
      }
      if (n.isOptionalCallExpression({
        callee: r
      })) {
        if (a.path.isPattern()) {
          n.replaceWith(ty(l9([], n.node), []));
          return;
        }
        n.replaceWith(this.optionalCall(e, n.node.arguments));
        return;
      }
      if (this.delete && n.isUnaryExpression({
        operator: "delete"
      })) {
        n.replaceWith(this.delete(e));
        return;
      }
      if (n.isForXStatement({
        left: r
      }) || n.isObjectProperty({
        value: r
      }) && n.parentPath.isObjectPattern() || n.isAssignmentPattern({
        left: r
      }) && n.parentPath.isObjectProperty({
        value: s
      }) && n.parentPath.parentPath.isObjectPattern() || n.isArrayPattern() || n.isAssignmentPattern({
        left: r
      }) && n.parentPath.isArrayPattern() || n.isRestElement()) {
        e.replaceWith(this.destructureSet(e));
        return;
      }
      n.isTaggedTemplateExpression() ? e.replaceWith(this.boundGet(e)) : e.replaceWith(this.get(e));
    }
  };
  function p9(e, t, r) {
    if (e.simpleSet) {
      t.replaceWith(e.simpleSet(t));
      return;
    }
    let {
      operator: s,
      right: n
    } = r.node;
    if (s === "=")
      r.replaceWith(e.set(t, n));
    else {
      let a = s.slice(0, -1);
      yje.includes(a) ? (e.memoise(t, 1), r.replaceWith(ey(a, e.get(t), e.set(t, n)))) : (e.memoise(t, 2), r.replaceWith(e.set(t, Ao(a, e.get(
      t), n))));
    }
  }
  i(p9, "handleAssignment");
  function Cje(e, t, r) {
    e.traverse(t, Object.assign({}, Aje, r, {
      memoiser: new DP()
    }));
  }
  i(Cje, "memberExpressionToFunctions");
  IP.default = Cje;
});

// ../node_modules/@babel/helper-optimise-call-expression/lib/index.js
var NP = y((OP) => {
  "use strict";
  Object.defineProperty(OP, "__esModule", {
    value: !0
  });
  OP.default = _je;
  var wje = Ne(), {
    callExpression: m9,
    identifier: ry,
    isIdentifier: Dje,
    isSpreadElement: Ije,
    memberExpression: y9,
    optionalCallExpression: g9,
    optionalMemberExpression: b9
  } = wje;
  function _je(e, t, r, s) {
    return r.length === 1 && Ije(r[0]) && Dje(r[0].argument, {
      name: "arguments"
    }) ? s ? g9(b9(e, ry("apply"), !1, !0), [t, r[0].argument], !1) : m9(y9(e, ry("apply")), [t, r[0].argument]) : s ? g9(b9(e, ry("call"), !1,
    !0), [t, ...r], !1) : m9(y9(e, ry("call")), [t, ...r]);
  }
  i(_je, "optimiseCallExpression");
});

// ../node_modules/@babel/helper-replace-supers/lib/index.js
var iy = y((Zl) => {
  "use strict";
  Object.defineProperty(Zl, "__esModule", {
    value: !0
  });
  Zl.default = void 0;
  var S9 = sa(), Oje = _P(), ny = NP(), Nf = mr(), {
    assignmentExpression: Nje,
    booleanLiteral: Rje,
    callExpression: sy,
    cloneNode: Sn,
    identifier: _f,
    memberExpression: Ql,
    sequenceExpression: RP,
    stringLiteral: kje,
    thisExpression: Of
  } = Nf.types;
  {
    let e = sa();
    Zl.environmentVisitor = e.default, Zl.skipAllButComputedKey = e.skipAllButComputedKey;
  }
  function E9(e, t, r, s) {
    e = Sn(e);
    let n = t || s ? e : Ql(e, _f("prototype"));
    return sy(r.addHelper("getPrototypeOf"), [n]);
  }
  i(E9, "getPrototypeOfExpression");
  var v9 = Nf.traverse.visitors.merge([S9.default, {
    Super(e, t) {
      let {
        node: r,
        parentPath: s
      } = e;
      s.isMemberExpression({
        object: r
      }) && t.handle(s);
    }
  }]), Fje = Nf.traverse.visitors.merge([S9.default, {
    Scopable(e, {
      refName: t
    }) {
      let r = e.scope.getOwnBinding(t);
      r && r.identifier.name === t && e.scope.rename(t);
    }
  }]), T9 = {
    memoise(e, t) {
      let {
        scope: r,
        node: s
      } = e, {
        computed: n,
        property: a
      } = s;
      if (!n)
        return;
      let o = r.maybeGenerateMemoised(a);
      o && this.memoiser.set(a, o, t);
    },
    prop(e) {
      let {
        computed: t,
        property: r
      } = e.node;
      return this.memoiser.has(r) ? Sn(this.memoiser.get(r)) : t ? Sn(r) : kje(r.name);
    },
    get(e) {
      return this._get(e, this._getThisRefs());
    },
    _get(e, t) {
      let r = E9(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return sy(this.file.addHelper("get"), [t.needAccessFirst ? RP([t.this, r]) : r, this.prop(e), t.this]);
    },
    _getThisRefs() {
      return {
        needAccessFirst: this.isDerivedConstructor,
        this: Of()
      };
    },
    set(e, t) {
      let r = this._getThisRefs(), s = E9(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return sy(this.file.addHelper("set"), [r.needAccessFirst ? RP([r.this, s]) : s, this.prop(e), t, r.this, Rje(e.isInStrictMode())]);
    },
    destructureSet(e) {
      throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call(e, t) {
      let r = this._getThisRefs();
      return (0, ny.default)(this._get(e, r), Sn(r.this), t, !1);
    },
    optionalCall(e, t) {
      let r = this._getThisRefs();
      return (0, ny.default)(this._get(e, r), Sn(r.this), t, !0);
    },
    delete(e) {
      return e.node.computed ? RP([sy(this.file.addHelper("toPropertyKey"), [Sn(e.node.property)]), Nf.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : Nf.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
    }
  }, Lje = Object.assign({}, T9, {
    prop(e) {
      let {
        property: t
      } = e.node;
      return this.memoiser.has(t) ? Sn(this.memoiser.get(t)) : Sn(t);
    },
    get(e) {
      let {
        isStatic: t,
        getSuperRef: r
      } = this, {
        computed: s
      } = e.node, n = this.prop(e), a;
      if (t) {
        var o;
        a = (o = r()) != null ? o : Ql(_f("Function"), _f("prototype"));
      } else {
        var l;
        a = Ql((l = r()) != null ? l : _f("Object"), _f("prototype"));
      }
      return Ql(a, n, s);
    },
    set(e, t) {
      let {
        computed: r
      } = e.node, s = this.prop(e);
      return Nje("=", Ql(Of(), s, r), t);
    },
    destructureSet(e) {
      let {
        computed: t
      } = e.node, r = this.prop(e);
      return Ql(Of(), r, t);
    },
    call(e, t) {
      return (0, ny.default)(this.get(e), Of(), t, !1);
    },
    optionalCall(e, t) {
      return (0, ny.default)(this.get(e), Of(), t, !0);
    }
  }), kP = class {
    static {
      i(this, "ReplaceSupers");
    }
    constructor(t) {
      var r;
      let s = t.methodPath;
      this.methodPath = s, this.isDerivedConstructor = s.isClassMethod({
        kind: "constructor"
      }) && !!t.superRef, this.isStatic = s.isObjectMethod() || s.node.static || (s.isStaticBlock == null ? void 0 : s.isStaticBlock()), this.
      isPrivateMethod = s.isPrivate() && s.isMethod(), this.file = t.file, this.constantSuper = (r = t.constantSuper) != null ? r : t.isLoose,
      this.opts = t;
    }
    getObjectRef() {
      return Sn(this.opts.objectRef || this.opts.getObjectRef());
    }
    getSuperRef() {
      if (this.opts.superRef) return Sn(this.opts.superRef);
      if (this.opts.getSuperRef)
        return Sn(this.opts.getSuperRef());
    }
    replace() {
      let {
        methodPath: t
      } = this;
      this.opts.refToPreserve && t.traverse(Fje, {
        refName: this.opts.refToPreserve.name
      });
      let r = this.constantSuper ? Lje : T9;
      v9.shouldSkip = (s) => {
        if (s.parentPath === t && (s.parentKey === "decorators" || s.parentKey === "key"))
          return !0;
      }, (0, Oje.default)(t, v9, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this),
        boundGet: r.get
      }, r));
    }
  };
  Zl.default = kP;
});

// ../node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js
var LP = y((Rf) => {
  "use strict";
  Object.defineProperty(Rf, "__esModule", {
    value: !0
  });
  Rf.isTransparentExprWrapper = FP;
  Rf.skipTransparentExprWrapperNodes = Hje;
  Rf.skipTransparentExprWrappers = Wje;
  var Bje = Ne(), {
    isParenthesizedExpression: Mje,
    isTSAsExpression: jje,
    isTSNonNullExpression: qje,
    isTSSatisfiesExpression: $je,
    isTSTypeAssertion: Uje,
    isTypeCastExpression: Vje
  } = Bje;
  function FP(e) {
    return jje(e) || $je(e) || Uje(e) || qje(e) || Vje(e) || Mje(e);
  }
  i(FP, "isTransparentExprWrapper");
  function Wje(e) {
    for (; FP(e.node); )
      e = e.get("expression");
    return e;
  }
  i(Wje, "skipTransparentExprWrappers");
  function Hje(e) {
    for (; FP(e); )
      e = e.expression;
    return e;
  }
  i(Hje, "skipTransparentExprWrapperNodes");
});

// ../node_modules/@babel/helper-annotate-as-pure/lib/index.js
var MP = y((BP) => {
  "use strict";
  Object.defineProperty(BP, "__esModule", {
    value: !0
  });
  BP.default = zje;
  var Gje = Ne(), {
    addComment: Kje
  } = Gje, Yje = "#__PURE__", Xje = /* @__PURE__ */ i(({
    leadingComments: e
  }) => !!e && e.some((t) => /[@#]__PURE__/.test(t.value)), "isPureAnnotated");
  function zje(e) {
    let t = e.node || e;
    Xje(t) || Kje(t, "leading", Yje);
  }
  i(zje, "annotateAsPure");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js
var qP = y((jP) => {
  "use strict";
  Object.defineProperty(jP, "__esModule", {
    value: !0
  });
  jP.assertFieldTransformed = Jje;
  function Jje(e) {
    if (e.node.declare)
      throw e.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional clas\
s features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`);
  }
  i(Jje, "assertFieldTransformed");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/fields.js
var WP = y((Aa) => {
  "use strict";
  Object.defineProperty(Aa, "__esModule", {
    value: !0
  });
  Aa.buildCheckInRHS = ly;
  Aa.buildFieldsInitNodes = S4e;
  Aa.buildPrivateNamesMap = s4e;
  Aa.buildPrivateNamesNodes = n4e;
  Aa.privateNameVisitorFactory = VP;
  Aa.transformPrivateNamesUsage = c4e;
  var R = mr(), Qje = iy(), w9 = sa(), Zje = _P(), x9 = NP(), e4e = MP(), t4e = LP(), r4e = qP();
  Hr = /* @__PURE__ */ i((e) => e.availableHelper("classPrivateFieldGet2"), "newHelpers");
  var Hr;
  function s4e(e, t, r, s) {
    let n = /* @__PURE__ */ new Map(), a;
    for (let l of r)
      if (l.isPrivate()) {
        let {
          name: u
        } = l.node.key.id, c = n.get(u);
        if (!c) {
          let f = !l.isProperty(), p = l.node.static, d = !1, m;
          if (!t && Hr(s) && f && !p) {
            var o;
            d = !!a, (o = a) != null || (a = l.scope.generateUidIdentifier(`${e}_brand`)), m = a;
          } else
            m = l.scope.generateUidIdentifier(u);
          c = {
            id: m,
            static: p,
            method: f,
            initAdded: d
          }, n.set(u, c);
        }
        if (l.isClassPrivateMethod())
          if (l.node.kind === "get") {
            let {
              body: f
            } = l.node.body, p;
            f.length === 1 && R.types.isReturnStatement(p = f[0]) && R.types.isCallExpression(p = p.argument) && p.arguments.length === 1 &&
            R.types.isThisExpression(p.arguments[0]) && R.types.isIdentifier(p = p.callee) ? (c.getId = R.types.cloneNode(p), c.getterDeclared =
            !0) : c.getId = l.scope.generateUidIdentifier(`get_${u}`);
          } else if (l.node.kind === "set") {
            let {
              params: f
            } = l.node, {
              body: p
            } = l.node.body, d;
            p.length === 1 && R.types.isExpressionStatement(d = p[0]) && R.types.isCallExpression(d = d.expression) && d.arguments.length ===
            2 && R.types.isThisExpression(d.arguments[0]) && R.types.isIdentifier(d.arguments[1], {
              name: f[0].name
            }) && R.types.isIdentifier(d = d.callee) ? (c.setId = R.types.cloneNode(d), c.setterDeclared = !0) : c.setId = l.scope.generateUidIdentifier(
            `set_${u}`);
          } else l.node.kind === "method" && (c.methodId = l.scope.generateUidIdentifier(u));
        n.set(u, c);
      }
    return n;
  }
  i(s4e, "buildPrivateNamesMap");
  function n4e(e, t, r, s) {
    let n = [], a = /* @__PURE__ */ new Set();
    for (let [o, l] of e) {
      let {
        static: u,
        method: c,
        getId: f,
        setId: p
      } = l, d = f || p, m = R.types.cloneNode(l.id), b;
      if (t)
        b = R.types.callExpression(s.addHelper("classPrivateFieldLooseKey"), [R.types.stringLiteral(o)]);
      else if (r)
        b = R.types.callExpression(R.types.identifier("Symbol"), [R.types.stringLiteral(o)]);
      else if (!u) {
        if (a.has(m.name)) continue;
        a.add(m.name), b = R.types.newExpression(R.types.identifier(c && (!d || Hr(s)) ? "WeakSet" : "WeakMap"), []);
      }
      b && (r || (0, e4e.default)(b), n.push(R.template.statement.ast`var ${m} = ${b}`));
    }
    return n;
  }
  i(n4e, "buildPrivateNamesNodes");
  function VP(e) {
    let t = R.traverse.visitors.merge([Object.assign({}, e), w9.default]), r = Object.assign({}, e, {
      Class(s) {
        let {
          privateNamesMap: n
        } = this, a = s.get("body.body"), o = new Map(n), l = [];
        for (let u of a) {
          if (!u.isPrivate()) continue;
          let {
            name: c
          } = u.node.key.id;
          o.delete(c), l.push(c);
        }
        l.length && (s.get("body").traverse(t, Object.assign({}, this, {
          redeclared: l
        })), s.traverse(r, Object.assign({}, this, {
          privateNamesMap: o
        })), s.skipKey("body"));
      }
    });
    return r;
  }
  i(VP, "privateNameVisitorFactory");
  var i4e = VP({
    PrivateName(e, {
      noDocumentAll: t
    }) {
      let {
        privateNamesMap: r,
        redeclared: s
      } = this, {
        node: n,
        parentPath: a
      } = e;
      if (!a.isMemberExpression({
        property: n
      }) && !a.isOptionalMemberExpression({
        property: n
      }))
        return;
      let {
        name: o
      } = n.id;
      r.has(o) && (s && s.includes(o) || this.handle(a, t));
    }
  });
  function D9(e, t, r) {
    for (; (s = t) != null && s.hasBinding(e) && !t.bindingIdentifierEquals(e, r); ) {
      var s;
      t.rename(e), t = t.parent;
    }
  }
  i(D9, "unshadow");
  function ly(e, t, r) {
    return r || !(t.availableHelper != null && t.availableHelper("checkInRHS")) ? e : R.types.callExpression(t.addHelper("checkInRHS"), [e]);
  }
  i(ly, "buildCheckInRHS");
  var a4e = VP({
    BinaryExpression(e, {
      file: t
    }) {
      let {
        operator: r,
        left: s,
        right: n
      } = e.node;
      if (r !== "in" || !R.types.isPrivateName(s)) return;
      let {
        privateFieldsAsProperties: a,
        privateNamesMap: o,
        redeclared: l
      } = this, {
        name: u
      } = s.id;
      if (!o.has(u) || l && l.includes(u)) return;
      if (D9(this.classRef.name, e.scope, this.innerBinding), a) {
        let {
          id: p
        } = o.get(u);
        e.replaceWith(R.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${ly(n, t)}, ${R.types.cloneNode(p)})
      `);
        return;
      }
      let {
        id: c,
        static: f
      } = o.get(u);
      if (f) {
        e.replaceWith(R.template.expression.ast`${ly(n, t)} === ${R.types.cloneNode(this.classRef)}`);
        return;
      }
      e.replaceWith(R.template.expression.ast`${R.types.cloneNode(c)}.has(${ly(n, t)})`);
    }
  });
  function ay(e, t) {
    return R.types.callExpression(e.addHelper("readOnlyError"), [R.types.stringLiteral(`#${t}`)]);
  }
  i(ay, "readOnlyError");
  function o4e(e, t) {
    return e.availableHelper("writeOnlyError") ? R.types.callExpression(e.addHelper("writeOnlyError"), [R.types.stringLiteral(`#${t}`)]) : (console.
    warn("@babel/helpers is outdated, update it to silence this warning."), R.types.buildUndefinedNode());
  }
  i(o4e, "writeOnlyError");
  function $P(e, t) {
    return t ? e : R.types.memberExpression(e, R.types.identifier("_"));
  }
  i($P, "buildStaticPrivateFieldAccess");
  var l4e = {
    memoise(e, t) {
      let {
        scope: r
      } = e, {
        object: s
      } = e.node, n = r.maybeGenerateMemoised(s);
      n && this.memoiser.set(s, n, t);
    },
    receiver(e) {
      let {
        object: t
      } = e.node;
      return this.memoiser.has(t) ? R.types.cloneNode(this.memoiser.get(t)) : R.types.cloneNode(t);
    },
    get(e) {
      let {
        classRef: t,
        privateNamesMap: r,
        file: s,
        innerBinding: n,
        noUninitializedPrivateFieldAccess: a
      } = this, {
        name: o
      } = e.node.property.id, {
        id: l,
        static: u,
        method: c,
        methodId: f,
        getId: p,
        setId: d
      } = r.get(o), m = p || d;
      if (u) {
        if (D9(t.name, e.scope, n), !Hr(s)) {
          let g = c && !m ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
          return R.types.callExpression(s.addHelper(g), [this.receiver(e), R.types.cloneNode(t), R.types.cloneNode(l)]);
        }
        let b = this.receiver(e), h = R.types.isIdentifier(b) && b.name === t.name;
        if (!c)
          return $P(h ? R.types.cloneNode(l) : R.types.callExpression(s.addHelper("assertClassBrand"), [R.types.cloneNode(t), b, R.types.cloneNode(
          l)]), a);
        if (p)
          return h ? R.types.callExpression(R.types.cloneNode(p), [b]) : R.types.callExpression(s.addHelper("classPrivateGetter"), [R.types.
          cloneNode(t), b, R.types.cloneNode(p)]);
        if (d) {
          let g = R.types.buildUndefinedNode();
          return h ? g : R.types.sequenceExpression([R.types.callExpression(s.addHelper("assertClassBrand"), [R.types.cloneNode(t), b]), g]);
        }
        return h ? R.types.cloneNode(l) : R.types.callExpression(s.addHelper("assertClassBrand"), [R.types.cloneNode(t), b, R.types.cloneNode(
        l)]);
      }
      return c ? m ? p ? Hr(s) ? R.types.callExpression(s.addHelper("classPrivateGetter"), [R.types.cloneNode(l), this.receiver(e), R.types.
      cloneNode(p)]) : R.types.callExpression(s.addHelper("classPrivateFieldGet"), [this.receiver(e), R.types.cloneNode(l)]) : R.types.sequenceExpression(
      [this.receiver(e), o4e(s, o)]) : Hr(s) ? R.types.callExpression(s.addHelper("assertClassBrand"), [R.types.cloneNode(l), this.receiver(
      e), R.types.cloneNode(f)]) : R.types.callExpression(s.addHelper("classPrivateMethodGet"), [this.receiver(e), R.types.cloneNode(l), R.types.
      cloneNode(f)]) : Hr(s) ? R.types.callExpression(s.addHelper("classPrivateFieldGet2"), [R.types.cloneNode(l), this.receiver(e)]) : R.types.
      callExpression(s.addHelper("classPrivateFieldGet"), [this.receiver(e), R.types.cloneNode(l)]);
    },
    boundGet(e) {
      return this.memoise(e, 1), R.types.callExpression(R.types.memberExpression(this.get(e), R.types.identifier("bind")), [this.receiver(e)]);
    },
    set(e, t) {
      let {
        classRef: r,
        privateNamesMap: s,
        file: n,
        noUninitializedPrivateFieldAccess: a
      } = this, {
        name: o
      } = e.node.property.id, {
        id: l,
        static: u,
        method: c,
        setId: f,
        getId: p
      } = s.get(o), d = p || f;
      if (u) {
        if (!Hr(n)) {
          let h = c && !d ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
          return R.types.callExpression(n.addHelper(h), [this.receiver(e), R.types.cloneNode(r), R.types.cloneNode(l), t]);
        }
        let m = this.receiver(e), b = R.types.isIdentifier(m) && m.name === r.name;
        if (c && !f) {
          let h = ay(n, o);
          return b ? R.types.sequenceExpression([t, h]) : R.types.sequenceExpression([t, R.types.callExpression(n.addHelper("assertClassBran\
d"), [R.types.cloneNode(r), m]), ay(n, o)]);
        }
        return f ? b ? R.types.callExpression(R.types.cloneNode(f), [m, t]) : R.types.callExpression(n.addHelper("classPrivateSetter"), [R.types.
        cloneNode(r), R.types.cloneNode(f), m, t]) : R.types.assignmentExpression("=", $P(R.types.cloneNode(l), a), b ? t : R.types.callExpression(
        n.addHelper("assertClassBrand"), [R.types.cloneNode(r), m, t]));
      }
      return c ? f ? Hr(n) ? R.types.callExpression(n.addHelper("classPrivateSetter"), [R.types.cloneNode(l), R.types.cloneNode(f), this.receiver(
      e), t]) : R.types.callExpression(n.addHelper("classPrivateFieldSet"), [this.receiver(e), R.types.cloneNode(l), t]) : R.types.sequenceExpression(
      [this.receiver(e), t, ay(n, o)]) : Hr(n) ? R.types.callExpression(n.addHelper("classPrivateFieldSet2"), [R.types.cloneNode(l), this.receiver(
      e), t]) : R.types.callExpression(n.addHelper("classPrivateFieldSet"), [this.receiver(e), R.types.cloneNode(l), t]);
    },
    destructureSet(e) {
      let {
        classRef: t,
        privateNamesMap: r,
        file: s,
        noUninitializedPrivateFieldAccess: n
      } = this, {
        name: a
      } = e.node.property.id, {
        id: o,
        static: l,
        method: u,
        setId: c
      } = r.get(a);
      if (!Hr(s)) {
        if (l) {
          try {
            var f = s.addHelper("classStaticPrivateFieldDestructureSet");
          } catch {
            throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the late\
st version.");
          }
          return R.types.memberExpression(R.types.callExpression(f, [this.receiver(e), R.types.cloneNode(t), R.types.cloneNode(o)]), R.types.
          identifier("value"));
        }
        return R.types.memberExpression(R.types.callExpression(s.addHelper("classPrivateFieldDestructureSet"), [this.receiver(e), R.types.cloneNode(
        o)]), R.types.identifier("value"));
      }
      if (u && !c)
        return R.types.memberExpression(R.types.sequenceExpression([e.node.object, ay(s, a)]), R.types.identifier("_"));
      if (l && !u) {
        let m = this.get(e);
        if (!n || !R.types.isCallExpression(m))
          return m;
        let b = m.arguments.pop();
        return m.arguments.push(R.template.expression.ast`(_) => ${b} = _`), R.types.memberExpression(R.types.callExpression(s.addHelper("to\
Setter"), [m]), R.types.identifier("_"));
      }
      let p = this.set(e, R.types.identifier("_"));
      if (!R.types.isCallExpression(p) || !R.types.isIdentifier(p.arguments[p.arguments.length - 1], {
        name: "_"
      }))
        throw e.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github\
.com/babel/babel/issues.");
      let d;
      return R.types.isMemberExpression(p.callee, {
        computed: !1
      }) && R.types.isIdentifier(p.callee.property) && p.callee.property.name === "call" ? d = [p.callee.object, R.types.arrayExpression(p.arguments.
      slice(1, -1)), p.arguments[0]] : d = [p.callee, R.types.arrayExpression(p.arguments.slice(0, -1))], R.types.memberExpression(R.types.callExpression(
      s.addHelper("toSetter"), d), R.types.identifier("_"));
    },
    call(e, t) {
      return this.memoise(e, 1), (0, x9.default)(this.get(e), this.receiver(e), t, !1);
    },
    optionalCall(e, t) {
      return this.memoise(e, 1), (0, x9.default)(this.get(e), this.receiver(e), t, !0);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  }, u4e = {
    get(e) {
      let {
        privateNamesMap: t,
        file: r
      } = this, {
        object: s
      } = e.node, {
        name: n
      } = e.node.property.id;
      return R.template.expression`BASE(REF, PROP)[PROP]`({
        BASE: r.addHelper("classPrivateFieldLooseBase"),
        REF: R.types.cloneNode(s),
        PROP: R.types.cloneNode(t.get(n).id)
      });
    },
    set() {
      throw new Error("private name handler with loose = true don't need set()");
    },
    boundGet(e) {
      return R.types.callExpression(R.types.memberExpression(this.get(e), R.types.identifier("bind")), [R.types.cloneNode(e.node.object)]);
    },
    simpleSet(e) {
      return this.get(e);
    },
    destructureSet(e) {
      return this.get(e);
    },
    call(e, t) {
      return R.types.callExpression(this.get(e), t);
    },
    optionalCall(e, t) {
      return R.types.optionalCallExpression(this.get(e), t, !0);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  };
  function c4e(e, t, r, {
    privateFieldsAsProperties: s,
    noUninitializedPrivateFieldAccess: n,
    noDocumentAll: a,
    innerBinding: o
  }, l) {
    if (!r.size) return;
    let u = t.get("body"), c = s ? u4e : l4e;
    (0, Zje.default)(u, i4e, Object.assign({
      privateNamesMap: r,
      classRef: e,
      file: l
    }, c, {
      noDocumentAll: a,
      noUninitializedPrivateFieldAccess: n,
      innerBinding: o
    })), u.traverse(a4e, {
      privateNamesMap: r,
      classRef: e,
      file: l,
      privateFieldsAsProperties: s,
      innerBinding: o
    });
  }
  i(c4e, "transformPrivateNamesUsage");
  function P9(e, t, r) {
    let {
      id: s
    } = r.get(t.node.key.id.name), n = t.node.value || t.scope.buildUndefinedNode();
    return _r(R.template.statement.ast`
      Object.defineProperty(${e}, ${R.types.cloneNode(s)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${n}
      });
    `, t);
  }
  i(P9, "buildPrivateFieldInitLoose");
  function f4e(e, t, r, s) {
    let {
      id: n
    } = r.get(t.node.key.id.name), a = t.node.value || t.scope.buildUndefinedNode();
    if (!s.availableHelper("classPrivateFieldInitSpec"))
      return _r(R.template.statement.ast`${R.types.cloneNode(n)}.set(${e}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${a},
        })`, t);
    let o = s.addHelper("classPrivateFieldInitSpec");
    return _r(R.types.expressionStatement(R.types.callExpression(o, [R.types.thisExpression(), R.types.cloneNode(n), Hr(s) ? a : R.template.
    expression.ast`{ writable: true, value: ${a} }`])), t);
  }
  i(f4e, "buildPrivateInstanceFieldInitSpec");
  function p4e(e, t, r) {
    let s = t.get(e.node.key.id.name), n = r ? e.node.value : R.template.expression.ast`{
        _: ${e.node.value || R.types.buildUndefinedNode()}
      }`;
    return _r(R.types.variableDeclaration("var", [R.types.variableDeclarator(R.types.cloneNode(s.id), n)]), e);
  }
  i(p4e, "buildPrivateStaticFieldInitSpec");
  UP = /* @__PURE__ */ i(function(e, t) {
    let r = t.get(e.node.key.id.name), {
      id: s,
      getId: n,
      setId: a,
      initAdded: o
    } = r, l = n || a;
    if (!e.isProperty() && (o || !l)) return;
    if (l)
      return t.set(e.node.key.id.name, Object.assign({}, r, {
        initAdded: !0
      })), _r(R.template.statement.ast`
          var ${R.types.cloneNode(s)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${n ? n.name : e.scope.buildUndefinedNode()},
            set: ${a ? a.name : e.scope.buildUndefinedNode()}
          }
        `, e);
    let u = e.node.value || e.scope.buildUndefinedNode();
    return _r(R.template.statement.ast`
        var ${R.types.cloneNode(s)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${u}
        };
      `, e);
  }, "buildPrivateStaticFieldInitSpecOld");
  var UP;
  function d4e(e, t, r) {
    let s = r.get(t.node.key.id.name), {
      methodId: n,
      id: a,
      getId: o,
      setId: l,
      initAdded: u
    } = s;
    if (u) return;
    if (n)
      return _r(R.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${n.name}
        });
      `, t);
    if (o || l)
      return r.set(t.node.key.id.name, Object.assign({}, s, {
        initAdded: !0
      })), _r(R.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${o ? o.name : t.scope.buildUndefinedNode()},
          set: ${l ? l.name : t.scope.buildUndefinedNode()}
        });
      `, t);
  }
  i(d4e, "buildPrivateMethodInitLoose");
  function h4e(e, t, r, s) {
    let n = r.get(t.node.key.id.name);
    if (!n.initAdded)
      return !Hr(s) && (n.getId || n.setId) ? m4e(e, t, r, s) : y4e(e, t, r, s);
  }
  i(h4e, "buildPrivateInstanceMethodInitSpec");
  function m4e(e, t, r, s) {
    let n = r.get(t.node.key.id.name), {
      id: a,
      getId: o,
      setId: l
    } = n;
    if (r.set(t.node.key.id.name, Object.assign({}, n, {
      initAdded: !0
    })), !s.availableHelper("classPrivateFieldInitSpec"))
      return _r(R.template.statement.ast`
          ${a}.set(${e}, {
            get: ${o ? o.name : t.scope.buildUndefinedNode()},
            set: ${l ? l.name : t.scope.buildUndefinedNode()}
          });
        `, t);
    let u = s.addHelper("classPrivateFieldInitSpec");
    return _r(R.template.statement.ast`${u}(
      ${R.types.thisExpression()},
      ${R.types.cloneNode(a)},
      {
        get: ${o ? o.name : t.scope.buildUndefinedNode()},
        set: ${l ? l.name : t.scope.buildUndefinedNode()}
      },
    )`, t);
  }
  i(m4e, "buildPrivateAccessorInitialization");
  function y4e(e, t, r, s) {
    let n = r.get(t.node.key.id.name), {
      id: a
    } = n;
    if (!s.availableHelper("classPrivateMethodInitSpec"))
      return _r(R.template.statement.ast`${a}.add(${e})`, t);
    let o = s.addHelper("classPrivateMethodInitSpec");
    return _r(R.template.statement.ast`${o}(
      ${R.types.thisExpression()},
      ${R.types.cloneNode(a)}
    )`, t);
  }
  i(y4e, "buildPrivateInstanceMethodInitialization");
  function A9(e, t) {
    let {
      key: r,
      computed: s
    } = t.node, n = t.node.value || t.scope.buildUndefinedNode();
    return _r(R.types.expressionStatement(R.types.assignmentExpression("=", R.types.memberExpression(e, r, s || R.types.isLiteral(r)), n)), t);
  }
  i(A9, "buildPublicFieldInitLoose");
  function C9(e, t, r) {
    let {
      key: s,
      computed: n
    } = t.node, a = t.node.value || t.scope.buildUndefinedNode();
    return _r(R.types.expressionStatement(R.types.callExpression(r.addHelper("defineProperty"), [e, n || R.types.isLiteral(s) ? s : R.types.
    stringLiteral(s.name), a])), t);
  }
  i(C9, "buildPublicFieldInitSpec");
  function g4e(e, t, r, s) {
    let n = s.get(t.node.key.id.name), {
      id: a,
      methodId: o,
      getId: l,
      setId: u,
      initAdded: c
    } = n;
    return c ? void 0 : l || u ? (s.set(t.node.key.id.name, Object.assign({}, n, {
      initAdded: !0
    })), _r(R.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${l ? l.name : t.scope.buildUndefinedNode()},
          set: ${u ? u.name : t.scope.buildUndefinedNode()}
        })
      `, t)) : _r(R.template.statement.ast`
      Object.defineProperty(${e}, ${a}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${o.name}
      });
    `, t);
  }
  i(g4e, "buildPrivateStaticMethodInitLoose");
  function oy(e, t, r, s = !1) {
    let n = r.get(t.node.key.id.name), {
      id: a,
      methodId: o,
      getId: l,
      setId: u,
      getterDeclared: c,
      setterDeclared: f,
      static: p
    } = n, {
      params: d,
      body: m,
      generator: b,
      async: h
    } = t.node, g = l && d.length === 0, E = u && d.length > 0;
    if (g && c || E && f)
      return r.set(t.node.key.id.name, Object.assign({}, n, {
        initAdded: !0
      })), null;
    if (Hr(e) && (g || E) && !s) {
      let C = t.get("body").scope, N = C.generateUidIdentifier("this"), I = {
        thisRef: N,
        argumentsPath: []
      };
      if (t.traverse(I9, I), I.argumentsPath.length) {
        let M = C.generateUidIdentifier("arguments");
        C.push({
          id: M,
          init: R.template.expression.ast`[].slice.call(arguments, 1)`
        });
        for (let q of I.argumentsPath)
          q.replaceWith(R.types.cloneNode(M));
      }
      d.unshift(R.types.cloneNode(N));
    }
    let D = o;
    return g ? (r.set(t.node.key.id.name, Object.assign({}, n, {
      getterDeclared: !0,
      initAdded: !0
    })), D = l) : E ? (r.set(t.node.key.id.name, Object.assign({}, n, {
      setterDeclared: !0,
      initAdded: !0
    })), D = u) : p && !s && (D = a), _r(R.types.functionDeclaration(R.types.cloneNode(D), d, m, b, h), t);
  }
  i(oy, "buildPrivateMethodDeclaration");
  var I9 = R.traverse.visitors.merge([{
    Identifier(e, t) {
      t.argumentsPath && e.node.name === "arguments" && t.argumentsPath.push(e);
    },
    UnaryExpression(e) {
      let {
        node: t
      } = e;
      if (t.operator === "delete") {
        let r = (0, t4e.skipTransparentExprWrapperNodes)(t.argument);
        R.types.isThisExpression(r) && e.replaceWith(R.types.booleanLiteral(!0));
      }
    },
    ThisExpression(e, t) {
      t.needsClassRef = !0, e.replaceWith(R.types.cloneNode(t.thisRef));
    },
    MetaProperty(e) {
      let {
        node: t,
        scope: r
      } = e;
      t.meta.name === "new" && t.property.name === "target" && e.replaceWith(r.buildUndefinedNode());
    }
  }, w9.default]), b4e = {
    ReferencedIdentifier(e, t) {
      e.scope.bindingIdentifierEquals(e.node.name, t.innerBinding) && (t.needsClassRef = !0, e.node.name = t.thisRef.name);
    }
  };
  function E4e(e, t, r) {
    var s;
    let n = {
      thisRef: t,
      needsClassRef: !1,
      innerBinding: r
    };
    return e.isMethod() || e.traverse(I9, n), r != null && (s = n.thisRef) != null && s.name && n.thisRef.name !== r.name && e.traverse(b4e,
    n), n.needsClassRef;
  }
  i(E4e, "replaceThisContext");
  function v4e({
    key: e,
    computed: t
  }) {
    return e.type === "Identifier" ? !t && (e.name === "name" || e.name === "length") : e.type === "StringLiteral" ? e.value === "name" || e.
    value === "length" : !1;
  }
  i(v4e, "isNameOrLength");
  function _r(e, t) {
    return R.types.inheritLeadingComments(e, t.node), R.types.inheritInnerComments(e, t.node), e;
  }
  i(_r, "inheritPropComments");
  function S4e(e, t, r, s, n, a, o, l, u, c) {
    var f, p;
    let d = 0, m, b = [], h = [], g = !1, E = [], D = null, C = R.types.isIdentifier(t) ? () => t : () => {
      var I;
      return (I = m) != null || (m = r[0].scope.generateUidIdentifierBasedOnNode(t)), m;
    }, N = (f = e) != null ? f : r[0].scope.generateUidIdentifier(c?.name || "Class");
    (p = e) != null || (e = R.types.cloneNode(c));
    for (let I of r) {
      I.isClassProperty() && r4e.assertFieldTransformed(I);
      let M = !(R.types.isStaticBlock != null && R.types.isStaticBlock(I.node)) && I.node.static, q = !M, V = I.isPrivate(), W = !V, Y = I.isProperty(),
      j = !Y, ie = I.isStaticBlock == null ? void 0 : I.isStaticBlock();
      switch (M && (d |= 1), (M || j && V || ie) && (new Qje.default({
        methodPath: I,
        constantSuper: u,
        file: n,
        refToPreserve: c,
        getSuperRef: C,
        getObjectRef() {
          return d |= 2, M || ie ? N : R.types.memberExpression(N, R.types.identifier("prototype"));
        }
      }).replace(), E4e(I, N, c) && (d |= 2)), g = !1, !0) {
        case ie: {
          let fe = I.node.body;
          fe.length === 1 && R.types.isExpressionStatement(fe[0]) ? b.push(_r(fe[0], I)) : b.push(R.types.inheritsComments(R.template.statement.
          ast`(() => { ${fe} })()`, I.node));
          break;
        }
        case (M && V && Y && o):
          b.push(P9(R.types.cloneNode(e), I, s));
          break;
        case (M && V && Y && !o):
          Hr(n) ? b.push(p4e(I, s, l)) : b.push(UP(I, s));
          break;
        case (M && W && Y && a):
          if (!v4e(I.node)) {
            b.push(A9(R.types.cloneNode(e), I));
            break;
          }
        case (M && W && Y && !a):
          b.push(C9(R.types.cloneNode(e), I, n));
          break;
        case (q && V && Y && o):
          h.push(P9(R.types.thisExpression(), I, s));
          break;
        case (q && V && Y && !o):
          h.push(f4e(R.types.thisExpression(), I, s, n));
          break;
        case (q && V && j && o):
          h.unshift(d4e(R.types.thisExpression(), I, s)), E.push(oy(n, I, s, o));
          break;
        case (q && V && j && !o):
          h.unshift(h4e(R.types.thisExpression(), I, s, n)), E.push(oy(n, I, s, o));
          break;
        case (M && V && j && !o):
          Hr(n) || b.unshift(UP(I, s)), E.push(oy(n, I, s, o));
          break;
        case (M && V && j && o):
          b.unshift(g4e(R.types.cloneNode(e), I, n, s)), E.push(oy(n, I, s, o));
          break;
        case (q && W && Y && a):
          h.push(A9(R.types.thisExpression(), I));
          break;
        case (q && W && Y && !a):
          g = !0, h.push(C9(R.types.thisExpression(), I, n));
          break;
        default:
          throw new Error("Unreachable.");
      }
    }
    return d & 2 && c != null && (D = R.types.expressionStatement(R.types.assignmentExpression("=", R.types.cloneNode(N), R.types.cloneNode(
    c)))), {
      staticNodes: b.filter(Boolean),
      instanceNodes: h.filter(Boolean),
      lastInstanceNodeReturnsThis: g,
      pureStaticNodes: E.filter(Boolean),
      classBindingNode: D,
      wrapClass(I) {
        for (let M of r)
          M.node.leadingComments = null, M.remove();
        return m && (I.scope.push({
          id: R.types.cloneNode(m)
        }), I.set("superClass", R.types.assignmentExpression("=", m, I.node.superClass))), d !== 0 && (I.isClassExpression() ? (I.scope.push(
        {
          id: e
        }), I.replaceWith(R.types.assignmentExpression("=", R.types.cloneNode(e), I.node))) : (c == null && (I.node.id = e), D != null && I.
        scope.push({
          id: N
        }))), I;
      }
    };
  }
  i(S4e, "buildFieldsInitNodes");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/misc.js
var HP = y((kf) => {
  "use strict";
  Object.defineProperty(kf, "__esModule", {
    value: !0
  });
  kf.extractComputedKeys = w4e;
  kf.injectInitialization = C4e;
  kf.memoiseComputedKey = O9;
  var ur = mr(), T4e = sa(), x4e = ur.traverse.visitors.merge([{
    Super(e) {
      let {
        node: t,
        parentPath: r
      } = e;
      r.isCallExpression({
        callee: t
      }) && this.push(r);
    }
  }, T4e.default]), P4e = {
    "TSTypeAnnotation|TypeAnnotation"(e) {
      e.skip();
    },
    ReferencedIdentifier(e, {
      scope: t
    }) {
      t.hasOwnBinding(e.node.name) && (t.rename(e.node.name), e.skip());
    }
  };
  function _9(e, t) {
    if (t.classBinding && t.classBinding === e.scope.getBinding(e.node.name)) {
      let r = t.file.addHelper("classNameTDZError"), s = ur.types.callExpression(r, [ur.types.stringLiteral(e.node.name)]);
      e.replaceWith(ur.types.sequenceExpression([s, e.node])), e.skip();
    }
  }
  i(_9, "handleClassTDZ");
  var A4e = {
    ReferencedIdentifier: _9
  };
  function C4e(e, t, r, s, n) {
    if (!r.length) return;
    let a = !!e.node.superClass;
    if (!t) {
      let o = ur.types.classMethod("constructor", ur.types.identifier("constructor"), [], ur.types.blockStatement([]));
      a && (o.params = [ur.types.restElement(ur.types.identifier("args"))], o.body.body.push(ur.template.statement.ast`super(...args)`)), [t] =
      e.get("body").unshiftContainer("body", o);
    }
    if (s && s(P4e, {
      scope: t.scope
    }), a) {
      let o = [];
      t.traverse(x4e, o);
      let l = !0;
      for (let u of o)
        if (l ? l = !1 : r = r.map((c) => ur.types.cloneNode(c)), u.parentPath.isExpressionStatement())
          u.insertAfter(r);
        else {
          let c = [u.node, ...r.map((f) => ur.types.toExpression(f))];
          n || c.push(ur.types.thisExpression()), u.replaceWith(ur.types.sequenceExpression(c));
        }
    } else
      t.get("body").unshiftContainer("body", r);
  }
  i(C4e, "injectInitialization");
  function O9(e, t, r) {
    if (ur.types.isIdentifier(e) && t.hasUid(e.name))
      return;
    if (ur.types.isAssignmentExpression(e, {
      operator: "="
    }) && ur.types.isIdentifier(e.left) && t.hasUid(e.left.name))
      return ur.types.cloneNode(e);
    {
      let a = ur.types.identifier(r);
      return t.push({
        id: a,
        kind: "let"
      }), ur.types.assignmentExpression("=", ur.types.cloneNode(a), e);
    }
  }
  i(O9, "memoiseComputedKey");
  function w4e(e, t, r) {
    let {
      scope: s
    } = e, n = [], a = {
      classBinding: e.node.id && s.getBinding(e.node.id.name),
      file: r
    };
    for (let o of t) {
      let l = o.get("key");
      l.isReferencedIdentifier() ? _9(l, a) : l.traverse(A4e, a);
      let u = o.node;
      if (!l.isConstantExpression()) {
        let c = O9(l.node, s, s.generateUidBasedOnNode(l.node));
        c && (n.push(ur.types.expressionStatement(c)), u.key = ur.types.cloneNode(c.left));
      }
    }
    return n;
  }
  i(w4e, "extractComputedKeys");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js
var H9 = y((JP) => {
  "use strict";
  Object.defineProperty(JP, "__esModule", {
    value: !0
  });
  JP.default = l8e;
  var w = mr(), N9 = iy(), R9 = pc(), Ca = LP(), U9 = WP(), uy = HP();
  function V9(e, t = e.length - 1) {
    if (t === -1) {
      e.unshift(65);
      return;
    }
    let r = e[t];
    r === 90 ? e[t] = 97 : r === 122 ? (e[t] = 65, V9(e, t - 1)) : e[t] = r + 1;
  }
  i(V9, "incrementId");
  function D4e(e) {
    let t = [], r = /* @__PURE__ */ new Set();
    return e.traverse({
      PrivateName(s) {
        r.add(s.node.id.name);
      }
    }), () => {
      let s;
      do
        V9(t), s = String.fromCharCode(...t);
      while (r.has(s));
      return w.types.privateName(w.types.identifier(s));
    };
  }
  i(D4e, "createPrivateUidGeneratorForClass");
  function I4e(e) {
    let t;
    return () => (t || (t = D4e(e)), t());
  }
  i(I4e, "createLazyPrivateUidGeneratorForClass");
  function _4e(e, t) {
    let r = e.node.id, s = e.scope;
    if (e.type === "ClassDeclaration") {
      let n = r.name, a = s.generateUidIdentifierBasedOnNode(r), o = w.types.identifier(n);
      return s.rename(n, a.name), e.get("id").replaceWith(o), {
        id: w.types.cloneNode(a),
        path: e
      };
    } else {
      let n;
      r ? (t = r.name, n = Ds(s.parent, t), s.rename(t, n.name)) : n = Ds(s.parent, typeof t == "string" ? t : "decorated_class");
      let a = w.types.classExpression(typeof t == "string" ? w.types.identifier(t) : null, e.node.superClass, e.node.body), [o] = e.replaceWith(
      w.types.sequenceExpression([a, n]));
      return {
        id: w.types.cloneNode(n),
        path: o.get("expressions.0")
      };
    }
  }
  i(_4e, "replaceClassWithVar");
  function k9(e, t, r) {
    return e.type === "PrivateName" ? w.types.classPrivateProperty(e, t, void 0, r) : w.types.classProperty(e, t, void 0, void 0, r);
  }
  i(k9, "generateClassProperty");
  function F9(e, t, r, s, n, a, o, l) {
    let u = (l === "2023-11" || l === "2023-05") && o ? e : w.types.thisExpression(), c = w.types.blockStatement([w.types.returnStatement(w.
    types.memberExpression(w.types.cloneNode(u), w.types.cloneNode(n)))]), f = w.types.blockStatement([w.types.expressionStatement(w.types.assignmentExpression(
    "=", w.types.memberExpression(w.types.cloneNode(u), w.types.cloneNode(n)), w.types.identifier("v")))]), p, d;
    r.type === "PrivateName" ? (p = w.types.classPrivateMethod("get", r, [], c, o), d = w.types.classPrivateMethod("set", s, [w.types.identifier(
    "v")], f, o)) : (p = w.types.classMethod("get", r, [], c, a, o), d = w.types.classMethod("set", s, [w.types.identifier("v")], f, a, o)),
    t.insertAfter(d), t.insertAfter(p);
  }
  i(F9, "addProxyAccessorsFor");
  function L9(e, t) {
    return t !== "2023-11" && t !== "2023-05" && t !== "2023-01" ? [w.template.expression.ast`
        function () {
          return this.${w.types.cloneNode(e)};
        }
      `, w.template.expression.ast`
        function (value) {
          this.${w.types.cloneNode(e)} = value;
        }
      `] : [w.template.expression.ast`
      o => o.${w.types.cloneNode(e)}
    `, w.template.expression.ast`
      (o, v) => o.${w.types.cloneNode(e)} = v
    `];
  }
  i(L9, "extractProxyAccessorsFor");
  function zP(e) {
    if (e = (0, Ca.skipTransparentExprWrappers)(e), e.isSequenceExpression()) {
      let t = e.get("expressions");
      return zP(t[t.length - 1]);
    }
    return e;
  }
  i(zP, "getComputedKeyLastElement");
  function O4e(e) {
    let t = zP(e);
    if (t.isConstantExpression())
      return w.types.cloneNode(e.node);
    if (t.isIdentifier() && e.scope.hasUid(t.node.name))
      return w.types.cloneNode(e.node);
    if (t.isAssignmentExpression() && t.get("left").isIdentifier())
      return w.types.cloneNode(t.node.left);
    throw new Error(`Internal Error: the computed key ${e.toString()} has not yet been memoised.`);
  }
  i(O4e, "getComputedKeyMemoiser");
  function Ff(e, t) {
    let r = t.get("key");
    r.isSequenceExpression() ? e.push(...r.node.expressions) : e.push(r.node), r.replaceWith(Da(e));
  }
  i(Ff, "prependExpressionsToComputedKey");
  function N4e(e, t) {
    let r = t.get("key"), s = zP(r);
    if (s.isConstantExpression())
      Ff(e, t);
    else {
      let n = r.scope.parent, a = (0, uy.memoiseComputedKey)(s.node, n, n.generateUid("computedKey"));
      if (!a)
        Ff(e, t);
      else {
        let o = [...e, w.types.cloneNode(a.left)], l = s.parentPath;
        l.isSequenceExpression() ? l.pushContainer("expressions", o) : s.replaceWith(Da([w.types.cloneNode(a), ...o]));
      }
    }
  }
  i(N4e, "appendExpressionsToComputedKey");
  function GP(e, t) {
    let r = t.get("value");
    r.node ? e.push(r.node) : e.length > 0 && (e[e.length - 1] = w.types.unaryExpression("void", e[e.length - 1])), r.replaceWith(Da(e));
  }
  i(GP, "prependExpressionsToFieldInitializer");
  function R4e(e, t) {
    t.unshiftContainer("body", w.types.expressionStatement(Da(e)));
  }
  i(R4e, "prependExpressionsToStaticBlock");
  function k4e(e, t) {
    t.node.body.body.unshift(w.types.expressionStatement(Da(e)));
  }
  i(k4e, "prependExpressionsToConstructor");
  function B9(e, t) {
    return w.types.isCallExpression(e) && w.types.isIdentifier(e.callee, {
      name: t.name
    });
  }
  i(B9, "isProtoInitCallExpression");
  function F4e(e, t) {
    if (t) {
      if (e.length >= 2 && B9(e[1], t)) {
        let r = w.types.callExpression(w.types.cloneNode(t), [e[0]]);
        e.splice(0, 2, r);
      }
      e.length >= 2 && w.types.isThisExpression(e[e.length - 1]) && B9(e[e.length - 2], t) && e.splice(e.length - 1, 1);
    }
    return Da(e);
  }
  i(F4e, "optimizeSuperCallAndExpressions");
  function L4e(e, t, r) {
    t.traverse({
      CallExpression: {
        exit(s) {
          if (!s.get("callee").isSuper()) return;
          let n = [s.node, ...e.map((a) => w.types.cloneNode(a))];
          s.isCompletionRecord() && n.push(w.types.thisExpression()), s.replaceWith(F4e(n, r)), s.skip();
        }
      },
      ClassMethod(s) {
        s.node.kind === "constructor" && s.skip();
      }
    });
  }
  i(L4e, "insertExpressionsAfterSuperCallAndOptimize");
  function M9(e, t) {
    let r = [w.types.expressionStatement(Da(e))];
    return t && r.unshift(w.types.expressionStatement(w.types.callExpression(w.types.super(), [w.types.spreadElement(w.types.identifier("arg\
s"))]))), w.types.classMethod("constructor", w.types.identifier("constructor"), t ? [w.types.restElement(w.types.identifier("args"))] : [], w.
    types.blockStatement(r));
  }
  i(M9, "createConstructorFromExpressions");
  function B4e(e) {
    return w.types.staticBlock([w.types.expressionStatement(Da(e))]);
  }
  i(B4e, "createStaticBlockFromExpressions");
  var Co = 0, wa = 1, M4e = 2, W9 = 3, cy = 4, j4e = 5, q4e = 8, $4e = 16;
  function U4e(e) {
    switch (e.node.type) {
      case "ClassProperty":
      case "ClassPrivateProperty":
        return Co;
      case "ClassAccessorProperty":
        return wa;
      case "ClassMethod":
      case "ClassPrivateMethod":
        return e.node.kind === "get" ? W9 : e.node.kind === "set" ? cy : M4e;
    }
  }
  i(U4e, "getElementKind");
  function V4e(e) {
    return [...e.filter((t) => t.isStatic && t.kind >= wa && t.kind <= cy), ...e.filter((t) => !t.isStatic && t.kind >= wa && t.kind <= cy),
    ...e.filter((t) => t.isStatic && t.kind === Co), ...e.filter((t) => !t.isStatic && t.kind === Co)];
  }
  i(V4e, "toSortedDecoratorInfo");
  function j9(e, t, r) {
    let s = e.length, n = t.some(Boolean), a = [];
    for (let o = 0; o < s; o++)
      (r === "2023-11" || r === "2023-05") && n && a.push(t[o] || w.types.unaryExpression("void", w.types.numericLiteral(0))), a.push(e[o]);
    return {
      haveThis: n,
      decs: a
    };
  }
  i(j9, "generateDecorationList");
  function W4e(e, t) {
    return w.types.arrayExpression(e.map((r) => {
      let s = r.kind;
      return r.isStatic && (s += t === "2023-11" || t === "2023-05" ? q4e : j4e), r.decoratorsHaveThis && (s += $4e), w.types.arrayExpression(
      [r.decoratorsArray, w.types.numericLiteral(s), r.name, ...r.privateMethods || []]);
    }));
  }
  i(W4e, "generateDecorationExprs");
  function H4e(e) {
    let t = [];
    for (let r of e) {
      let {
        locals: s
      } = r;
      Array.isArray(s) ? t.push(...s) : s !== void 0 && t.push(s);
    }
    return t;
  }
  i(H4e, "extractElementLocalAssignments");
  function G4e(e, t, r, s, n, a) {
    t.insertAfter(w.types.classPrivateMethod("get", w.types.cloneNode(r), [], w.types.blockStatement([w.types.returnStatement(w.types.callExpression(
    w.types.cloneNode(s), e === "2023-11" && a ? [] : [w.types.thisExpression()]))]), a)), t.insertAfter(w.types.classPrivateMethod("set", w.
    types.cloneNode(r), [w.types.identifier("v")], w.types.blockStatement([w.types.expressionStatement(w.types.callExpression(w.types.cloneNode(
    n), e === "2023-11" && a ? [w.types.identifier("v")] : [w.types.thisExpression(), w.types.identifier("v")]))]), a));
  }
  i(G4e, "addCallAccessorsFor");
  function K4e(e, t, r, s) {
    let n, a;
    e.node.kind === "set" ? (n = [w.types.identifier("v")], a = [w.types.expressionStatement(w.types.callExpression(r, [w.types.thisExpression(),
    w.types.identifier("v")]))]) : (n = [], a = [w.types.returnStatement(w.types.callExpression(r, [w.types.thisExpression()]))]), e.replaceWith(
    w.types.classPrivateMethod(e.node.kind, w.types.cloneNode(t), n, w.types.blockStatement(a), s));
  }
  i(K4e, "movePrivateAccessor");
  function q9(e) {
    let {
      type: t
    } = e;
    return t !== "TSDeclareMethod" && t !== "TSIndexSignature" && t !== "StaticBlock";
  }
  i(q9, "isClassDecoratableElementPath");
  function Y4e(e) {
    return w.types.callExpression(w.types.arrowFunctionExpression([], w.types.blockStatement(e.body)), []);
  }
  i(Y4e, "staticBlockToIIFE");
  function X4e(e) {
    return w.types.functionExpression(null, [], w.types.blockStatement(e.body));
  }
  i(X4e, "staticBlockToFunctionClosure");
  function z4e(e) {
    return w.types.functionExpression(null, [], w.types.blockStatement([w.types.returnStatement(e)]));
  }
  i(z4e, "fieldInitializerToClosure");
  function Da(e) {
    return e.length === 0 ? w.types.unaryExpression("void", w.types.numericLiteral(0)) : e.length === 1 ? e[0] : w.types.sequenceExpression(
    e);
  }
  i(Da, "maybeSequenceExpression");
  function $9(e) {
    let {
      params: t,
      body: r,
      generator: s,
      async: n
    } = e;
    return w.types.functionExpression(void 0, t, r, s, n);
  }
  i($9, "createFunctionExpressionFromPrivateMethod");
  function J4e(e, t) {
    return w.types.callExpression(e.addHelper("setFunctionName"), [w.types.thisExpression(), t]);
  }
  i(J4e, "createSetFunctionNameCall");
  function XP(e, t) {
    return w.types.callExpression(e.addHelper("toPropertyKey"), [t]);
  }
  i(XP, "createToPropertyKeyCall");
  function KP(e) {
    return w.types.arrowFunctionExpression([w.types.identifier("_")], w.types.binaryExpression("in", w.types.cloneNode(e), w.types.identifier(
    "_")));
  }
  i(KP, "createPrivateBrandCheckClosure");
  function Q4e(e) {
    try {
      return w.types.traverseFast(e, (t) => {
        if (w.types.isPrivateName(t))
          throw null;
      }), !1;
    } catch {
      return !0;
    }
  }
  i(Q4e, "usesPrivateField");
  function Z4e(e) {
    let {
      node: t
    } = e;
    t.computed = !0, w.types.isIdentifier(t.key) && (t.key = w.types.stringLiteral(t.key.name));
  }
  i(Z4e, "convertToComputedKey");
  function YP(e, t) {
    let r = !1;
    if (t.length > 0) {
      let s = (0, U9.privateNameVisitorFactory)({
        PrivateName(a, o) {
          o.privateNamesMap.has(a.node.id.name) && (r = !0, a.stop());
        }
      }), n = /* @__PURE__ */ new Map();
      for (let a of t)
        n.set(a, null);
      e.traverse(s, {
        privateNamesMap: n
      });
    }
    return r;
  }
  i(YP, "hasInstancePrivateAccess");
  function e8e(e, t) {
    let r = (0, U9.privateNameVisitorFactory)({
      PrivateName(n, a) {
        if (!a.privateNamesMap.has(n.node.id.name)) return;
        let o = n.parentPath, l = o.parentPath;
        if (l.node.type === "AssignmentExpression" && l.node.left === o.node || l.node.type === "UpdateExpression" || l.node.type === "RestE\
lement" || l.node.type === "ArrayPattern" || l.node.type === "ObjectProperty" && l.node.value === o.node && l.parentPath.type === "ObjectPat\
tern" || l.node.type === "ForOfStatement" && l.node.left === o.node)
          throw n.buildCodeFrameError(`Decorated private methods are read-only, but "#${n.node.id.name}" is updated via this expression.`);
      }
    }), s = /* @__PURE__ */ new Map();
    for (let n of t)
      s.set(n, null);
    e.traverse(r, {
      privateNamesMap: s
    });
  }
  i(e8e, "checkPrivateMethodUpdateError");
  function t8e(e, t, r, s, n, a, o) {
    var l, u;
    let c = e.get("body.body"), f = e.node.decorators, p = !1, d = !1, m = !1, b = I4e(e), h = [], g = e.scope.parent, E = /* @__PURE__ */ i(
    (ye, ce, Ge) => {
      let U = Ds(g, ce);
      return Ge.push(w.types.assignmentExpression("=", U, ye)), w.types.cloneNode(U);
    }, "memoiseExpression"), D, C, N = (l = e.node.id) == null ? void 0 : l.name, I = /* @__PURE__ */ i((ye) => {
      try {
        return w.types.traverseFast(ye, (ce) => {
          if (w.types.isThisExpression(ce) || w.types.isSuper(ce) || w.types.isYieldExpression(ce) || w.types.isAwaitExpression(ce) || w.types.
          isIdentifier(ce, {
            name: "arguments"
          }) || N && w.types.isIdentifier(ce, {
            name: N
          }) || w.types.isMetaProperty(ce) && ce.meta.name !== "import")
            throw null;
        }), !1;
      } catch {
        return !0;
      }
    }, "usesFunctionContextOrYieldAwait"), M = [];
    for (let ye of c) {
      if (!q9(ye))
        continue;
      let ce = ye.node;
      if (!ce.static && w.types.isPrivateName(ce.key) && M.push(ce.key.id.name), Lf(ce)) {
        switch (ce.type) {
          case "ClassProperty":
            a.ClassProperty(ye, t);
            break;
          case "ClassPrivateProperty":
            a.ClassPrivateProperty(ye, t);
            break;
          case "ClassAccessorProperty":
            if (a.ClassAccessorProperty(ye, t), o === "2023-11")
              break;
          default:
            if (ce.static) {
              var q;
              (q = C) != null || (C = Ds(g, "initStatic"));
            } else {
              var V;
              (V = D) != null || (D = Ds(g, "initProto"));
            }
            break;
        }
        p = !0, m || (m = ce.decorators.some(I));
      } else if (ce.type === "ClassAccessorProperty") {
        a.ClassAccessorProperty(ye, t);
        let {
          key: Ge,
          value: U,
          static: z,
          computed: J
        } = ce, ae = b(), Re = k9(ae, U, z), ge = ye.get("key"), [Be] = ye.replaceWith(Re), Xe, Fe;
        J && !ge.isConstantExpression() ? (Xe = (0, uy.memoiseComputedKey)(XP(t, Ge), g, g.generateUid("computedKey")), Fe = w.types.cloneNode(
        Xe.left)) : (Xe = w.types.cloneNode(Ge), Fe = w.types.cloneNode(Ge)), F9(e.node.id, Be, Xe, Fe, ae, J, z, o);
      }
      "computed" in ye.node && ye.node.computed && (d || (d = !g.isStatic(ye.node.key)));
    }
    if (!f && !p)
      return;
    let W = [], Y, j = /* @__PURE__ */ new Set(), ie, fe, De = null;
    function F(ye) {
      let ce = !1, Ge = !1, U = [];
      for (let J of ye) {
        let ae;
        if ((o === "2023-11" || o === "2023-05") && w.types.isMemberExpression(J))
          if (w.types.isSuper(J.object))
            ae = w.types.thisExpression();
          else if (g.isStatic(J.object))
            ae = w.types.cloneNode(J.object);
          else {
            var z;
            (z = De) != null || (De = Ds(g, "obj")), ae = w.types.assignmentExpression("=", w.types.cloneNode(De), J.object), J.object = w.types.
            cloneNode(De);
          }
        U.push(ae), ce || (ce = !g.isStatic(J)), Ge || (Ge = I(J));
      }
      return {
        hasSideEffects: ce,
        usesFnContext: Ge,
        decoratorsThis: U
      };
    }
    i(F, "handleDecoratorExpressions");
    let L = d || m || o !== "2023-11", re = !1, se = 0, be = [], je, Pe = [];
    if (f) {
      ie = Ds(g, "initClass"), re = e.isClassDeclaration(), {
        id: fe,
        path: e
      } = _4e(e, n), e.node.decorators = null;
      let ye = f.map((ae) => ae.expression), ce = ye.some(Q4e), {
        hasSideEffects: Ge,
        decoratorsThis: U
      } = F(ye), {
        haveThis: z,
        decs: J
      } = j9(ye, U, o);
      if (se = z ? 1 : 0, be = J, (Ge && L || ce) && (je = E(w.types.arrayExpression(be), "classDecs", h)), !p)
        for (let ae of e.get("body.body")) {
          let {
            node: Re
          } = ae;
          if ("computed" in Re && Re.computed)
            if (ae.isClassProperty({
              static: !0
            })) {
              if (!ae.get("key").isConstantExpression()) {
                let Be = Re.key, Xe = (0, uy.memoiseComputedKey)(Be, g, g.generateUid("computedKey"));
                Xe != null && (Re.key = w.types.cloneNode(Xe.left), Pe.push(Xe));
              }
            } else Pe.length > 0 && (Ff(Pe, ae), Pe = []);
        }
    } else
      e.node.id || (e.node.id = e.scope.generateUidIdentifier("Class")), fe = w.types.cloneNode(e.node.id);
    let Rt, Bt = !1, qt = [], Ie = [];
    if (p) {
      if (D) {
        let ye = w.types.callExpression(w.types.cloneNode(D), [w.types.thisExpression()]);
        qt.push(ye);
      }
      for (let ye of c) {
        if (!q9(ye)) {
          Ie.length > 0 && ye.isStaticBlock() && (R4e(Ie, ye), Ie = []);
          continue;
        }
        let {
          node: ce
        } = ye, Ge = ce.decorators, U = !!(Ge != null && Ge.length), z = "computed" in ce && ce.computed, J = "computedKey";
        ce.key.type === "PrivateName" ? J = ce.key.id.name : !z && ce.key.type === "Identifier" && (J = ce.key.name);
        let ae, Re;
        if (U) {
          let Mt = Ge.map((Dn) => Dn.expression), {
            hasSideEffects: ot,
            usesFnContext: mt,
            decoratorsThis: Vt
          } = F(Mt), {
            decs: Zt,
            haveThis: Ss
          } = j9(Mt, Vt, o);
          Re = Ss, ae = Zt.length === 1 ? Zt[0] : w.types.arrayExpression(Zt), (mt || ot && L) && (ae = E(ae, J + "Decs", Pe));
        }
        if (z && !ye.get("key").isConstantExpression()) {
          let Mt = ce.key, ot = (0, uy.memoiseComputedKey)(U ? XP(t, Mt) : Mt, g, g.generateUid("computedKey"));
          ot != null && (f && ye.isClassProperty({
            static: !0
          }) ? (ce.key = w.types.cloneNode(ot.left), Pe.push(ot)) : ce.key = ot);
        }
        let {
          key: ge,
          static: Be
        } = ce, Xe = ge.type === "PrivateName", Fe = U4e(ye);
        Xe && !Be && (U && (Bt = !0), (w.types.isClassPrivateProperty(ce) || !Rt) && (Rt = ge)), ye.isClassMethod({
          kind: "constructor"
        }) && (Y = ye);
        let ht;
        if (U) {
          let Mt, ot;
          if (z ? ot = O4e(ye.get("key")) : ge.type === "PrivateName" ? ot = w.types.stringLiteral(ge.id.name) : ge.type === "Identifier" ? ot =
          w.types.stringLiteral(ge.name) : ot = w.types.cloneNode(ge), Fe === wa) {
            let {
              value: mt
            } = ye.node, Vt = o === "2023-11" && Be ? [] : [w.types.thisExpression()];
            mt && Vt.push(w.types.cloneNode(mt));
            let Zt = b(), Ss = Ds(g, `init_${J}`), Dn = w.types.callExpression(w.types.cloneNode(Ss), Vt), $i = k9(Zt, Dn, Be), [jo] = ye.replaceWith(
            $i);
            if (Xe) {
              Mt = L9(Zt, o);
              let zr = Ds(g, `get_${J}`), qo = Ds(g, `set_${J}`);
              G4e(o, jo, ge, zr, qo, Be), ht = [Ss, zr, qo];
            } else
              F9(e.node.id, jo, w.types.cloneNode(ge), w.types.isAssignmentExpression(ge) ? w.types.cloneNode(ge.left) : w.types.cloneNode(ge),
              Zt, z, Be, o), ht = [Ss];
          } else if (Fe === Co) {
            let mt = Ds(g, `init_${J}`), Vt = ye.get("value"), Zt = o === "2023-11" && Be ? [] : [w.types.thisExpression()];
            Vt.node && Zt.push(Vt.node), Vt.replaceWith(w.types.callExpression(w.types.cloneNode(mt), Zt)), ht = [mt], Xe && (Mt = L9(ge, o));
          } else if (Xe) {
            let mt = Ds(g, `call_${J}`);
            if (ht = [mt], new N9.default({
              constantSuper: r,
              methodPath: ye,
              objectRef: fe,
              superRef: e.node.superClass,
              file: t.file,
              refToPreserve: fe
            }).replace(), Mt = [$9(ye.node)], Fe === W9 || Fe === cy)
              K4e(ye, w.types.cloneNode(ge), w.types.cloneNode(mt), Be);
            else {
              let Zt = ye.node;
              e.node.body.body.unshift(w.types.classPrivateProperty(ge, w.types.cloneNode(mt), [], Zt.static)), j.add(ge.id.name), ye.remove();
            }
          }
          W.push({
            kind: Fe,
            decoratorsArray: ae,
            decoratorsHaveThis: Re,
            name: ot,
            isStatic: Be,
            privateMethods: Mt,
            locals: ht
          }), ye.node && (ye.node.decorators = null);
        }
        if (z && Pe.length > 0 && (f && ye.isClassProperty({
          static: !0
        }) || (Ff(Pe, Fe === wa ? ye.getNextSibling() : ye), Pe = [])), qt.length > 0 && !Be && (Fe === Co || Fe === wa) && (GP(qt, ye), qt =
        []), Ie.length > 0 && Be && (Fe === Co || Fe === wa) && (GP(Ie, ye), Ie = []), U && o === "2023-11" && (Fe === Co || Fe === wa)) {
          let Mt = Ds(g, `init_extra_${J}`);
          ht.push(Mt);
          let ot = w.types.callExpression(w.types.cloneNode(Mt), Be ? [] : [w.types.thisExpression()]);
          Be ? Ie.push(ot) : qt.push(ot);
        }
      }
    }
    if (Pe.length > 0) {
      let ye = e.get("body.body"), ce;
      for (let Ge = ye.length - 1; Ge >= 0; Ge--) {
        let U = ye[Ge], z = U.node;
        if (z.computed) {
          if (f && w.types.isClassProperty(z, {
            static: !0
          }))
            continue;
          ce = U;
          break;
        }
      }
      ce != null && (N4e(Pe, ce), Pe = []);
    }
    if (qt.length > 0) {
      let ye = !!e.node.superClass;
      Y ? ye ? L4e(qt, Y, D) : k4e(qt, Y) : e.node.body.body.unshift(M9(qt, ye)), qt = [];
    }
    Ie.length > 0 && (e.node.body.body.push(B4e(Ie)), Ie = []);
    let _e = V4e(W), Jt = W4e(o === "2023-11" ? W : _e, o), Sr = H4e(_e);
    D && Sr.push(D), C && Sr.push(C);
    let pe = [], ut = !1, oe = ie && w.types.callExpression(w.types.cloneNode(ie), []), He = e, Pt = e.node, Qt = [];
    if (f) {
      pe.push(fe, ie);
      let ye = [];
      if (e.get("body.body").forEach((ce) => {
        if (ce.isStaticBlock()) {
          if (YP(ce, M)) {
            let Ge = E(X4e(ce.node), "staticBlock", Qt);
            Ie.push(w.types.callExpression(w.types.memberExpression(Ge, w.types.identifier("call")), [w.types.thisExpression()]));
          } else
            Ie.push(Y4e(ce.node));
          ce.remove();
          return;
        }
        if ((ce.isClassProperty() || ce.isClassPrivateProperty()) && ce.node.static) {
          let Ge = ce.get("value");
          if (YP(Ge, M)) {
            let U = E(z4e(Ge.node), "fieldValue", Qt);
            Ge.replaceWith(w.types.callExpression(w.types.memberExpression(U, w.types.identifier("call")), [w.types.thisExpression()]));
          }
          Ie.length > 0 && (GP(Ie, ce), Ie = []), ce.node.static = !1, ye.push(ce.node), ce.remove();
        } else if (ce.isClassPrivateMethod({
          static: !0
        })) {
          if (YP(ce, M)) {
            new N9.default({
              constantSuper: r,
              methodPath: ce,
              objectRef: fe,
              superRef: e.node.superClass,
              file: t.file,
              refToPreserve: fe
            }).replace();
            let U = E($9(ce.node), ce.get("key.id").node.name, Qt);
            s ? (ce.node.params = [w.types.restElement(w.types.identifier("arg"))], ce.node.body = w.types.blockStatement([w.types.returnStatement(
            w.types.callExpression(w.types.memberExpression(U, w.types.identifier("apply")), [w.types.thisExpression(), w.types.identifier("\
arg")]))])) : (ce.node.params = ce.node.params.map((z, J) => w.types.isRestElement(z) ? w.types.restElement(w.types.identifier("arg")) : w.types.
            identifier("_" + J)), ce.node.body = w.types.blockStatement([w.types.returnStatement(w.types.callExpression(w.types.memberExpression(
            U, w.types.identifier("apply")), [w.types.thisExpression(), w.types.identifier("arguments")]))]));
          }
          ce.node.static = !1, ye.push(ce.node), ce.remove();
        }
      }), ye.length > 0 || Ie.length > 0) {
        let ce = w.template.expression.ast`
        class extends ${t.addHelper("identity")} {}
      `;
        ce.body.body = [w.types.classProperty(w.types.toExpression(Pt), void 0, void 0, void 0, !0, !0), ...ye];
        let Ge = [], U = w.types.newExpression(ce, []);
        Ie.length > 0 && Ge.push(...Ie), oe && (ut = !0, Ge.push(oe)), Ge.length > 0 ? (Ge.unshift(w.types.callExpression(w.types.super(), [
        w.types.cloneNode(fe)])), ce.body.body.push(M9(Ge, !1))) : U.arguments.push(w.types.cloneNode(fe));
        let [z] = e.replaceWith(U);
        He = z.get("callee").get("body").get("body")[0].get("key");
      }
    }
    !ut && oe && e.node.body.body.push(w.types.staticBlock([w.types.expressionStatement(oe)]));
    let {
      superClass: kt
    } = Pt;
    if (kt && (o === "2023-11" || o === "2023-05")) {
      let ye = e.scope.maybeGenerateMemoised(kt);
      ye && (Pt.superClass = w.types.assignmentExpression("=", ye, kt), kt = ye);
    }
    let sn = w.types.staticBlock([]);
    Pt.body.body.unshift(sn);
    let Xr = sn.body;
    if (Pe.length > 0) {
      let ye = He.get("body.body"), ce;
      for (let Ge of ye)
        if ((Ge.isClassProperty() || Ge.isClassMethod()) && Ge.node.kind !== "constructor") {
          ce = Ge;
          break;
        }
      ce != null ? (Z4e(ce), Ff(Pe, ce)) : (Pt.body.body.unshift(w.types.classProperty(w.types.sequenceExpression([...Pe, w.types.stringLiteral(
      "_")]), void 0, void 0, void 0, !0, !0)), Xr.push(w.types.expressionStatement(w.types.unaryExpression("delete", w.types.memberExpression(
      w.types.thisExpression(), w.types.identifier("_")))))), Pe = [];
    }
    if (Xr.push(w.types.expressionStatement(r8e(Sr, pe, Jt, (u = je) != null ? u : w.types.arrayExpression(be), w.types.numericLiteral(se), Bt ?
    Rt : null, typeof n == "object" ? n : void 0, w.types.cloneNode(kt), t, o))), C && Xr.push(w.types.expressionStatement(w.types.callExpression(
    w.types.cloneNode(C), [w.types.thisExpression()]))), Qt.length > 0 && Xr.push(...Qt.map((ye) => w.types.expressionStatement(ye))), e.insertBefore(
    h.map((ye) => w.types.expressionStatement(ye))), re)
      if (!g.getBinding(fe.name).constantViolations.length)
        e.insertBefore(w.types.variableDeclaration("let", [w.types.variableDeclarator(w.types.cloneNode(fe))]));
      else {
        let ce = g.generateUidIdentifier("t" + fe.name), Ge = fe;
        e.replaceWithMultiple([w.types.variableDeclaration("let", [w.types.variableDeclarator(w.types.cloneNode(Ge)), w.types.variableDeclarator(
        ce)]), w.types.blockStatement([w.types.variableDeclaration("let", [w.types.variableDeclarator(w.types.cloneNode(fe))]), e.node, w.types.
        expressionStatement(w.types.assignmentExpression("=", w.types.cloneNode(ce), w.types.cloneNode(fe)))]), w.types.expressionStatement(
        w.types.assignmentExpression("=", w.types.cloneNode(Ge), w.types.cloneNode(ce)))]);
      }
    return j.size > 0 && e8e(e, j), e.scope.crawl(), e;
  }
  i(t8e, "transformClass");
  function r8e(e, t, r, s, n, a, o, l, u, c) {
    let f, p, d = [o ? J4e(u, o) : w.types.thisExpression(), s, r];
    {
      if (c !== "2023-11" && d.splice(1, 2, r, s), c === "2021-12" || c === "2022-03" && !u.availableHelper("applyDecs2203R"))
        return f = w.types.arrayPattern([...e, ...t]), p = w.types.callExpression(u.addHelper(c === "2021-12" ? "applyDecs" : "applyDecs2203"),
        d), w.types.assignmentExpression("=", f, p);
      c === "2022-03" ? p = w.types.callExpression(u.addHelper("applyDecs2203R"), d) : c === "2023-01" ? (a && d.push(KP(a)), p = w.types.callExpression(
      u.addHelper("applyDecs2301"), d)) : c === "2023-05" && ((a || l || n.value !== 0) && d.push(n), a ? d.push(KP(a)) : l && d.push(w.types.
      unaryExpression("void", w.types.numericLiteral(0))), l && d.push(l), p = w.types.callExpression(u.addHelper("applyDecs2305"), d));
    }
    return c === "2023-11" && ((a || l || n.value !== 0) && d.push(n), a ? d.push(KP(a)) : l && d.push(w.types.unaryExpression("void", w.types.
    numericLiteral(0))), l && d.push(l), p = w.types.callExpression(u.addHelper("applyDecs2311"), d)), e.length > 0 ? t.length > 0 ? f = w.types.
    objectPattern([w.types.objectProperty(w.types.identifier("e"), w.types.arrayPattern(e)), w.types.objectProperty(w.types.identifier("c"),
    w.types.arrayPattern(t))]) : (f = w.types.arrayPattern(e), p = w.types.memberExpression(p, w.types.identifier("e"), !1, !1)) : (f = w.types.
    arrayPattern(t), p = w.types.memberExpression(p, w.types.identifier("c"), !1, !1)), w.types.assignmentExpression("=", f, p);
  }
  i(r8e, "createLocalsAssignment");
  function s8e(e) {
    return e.type === "Identifier" ? e.name === "__proto__" : e.value === "__proto__";
  }
  i(s8e, "isProtoKey");
  function Lf(e) {
    return e.decorators && e.decorators.length > 0;
  }
  i(Lf, "isDecorated");
  function n8e(e) {
    switch (e.type) {
      case "ClassAccessorProperty":
        return !0;
      case "ClassMethod":
      case "ClassProperty":
      case "ClassPrivateMethod":
      case "ClassPrivateProperty":
        return Lf(e);
      default:
        return !1;
    }
  }
  i(n8e, "shouldTransformElement");
  function i8e(e) {
    return Lf(e) || e.body.body.some(n8e);
  }
  i(i8e, "shouldTransformClass");
  function a8e(e, t) {
    function r(s, n, a) {
      switch (n.type) {
        case "StringLiteral":
          return w.types.stringLiteral(n.value);
        case "NumericLiteral":
        case "BigIntLiteral": {
          let o = n.value + "";
          return s.get("key").replaceWith(w.types.stringLiteral(o)), w.types.stringLiteral(o);
        }
        default: {
          let o = s.scope.maybeGenerateMemoised(n);
          return s.get("key").replaceWith(w.types.assignmentExpression("=", o, XP(a, n))), w.types.cloneNode(o);
        }
      }
    }
    return i(r, "handleComputedProperty"), {
      VariableDeclarator(s, n) {
        let a = s.node.id;
        if (a.type === "Identifier") {
          let o = (0, Ca.skipTransparentExprWrappers)(s.get("init"));
          if (e(o)) {
            let l = a.name;
            t(o, n, l);
          }
        }
      },
      AssignmentExpression(s, n) {
        let a = s.node.left;
        if (a.type === "Identifier") {
          let o = (0, Ca.skipTransparentExprWrappers)(s.get("right"));
          if (e(o))
            switch (s.node.operator) {
              case "=":
              case "&&=":
              case "||=":
              case "??=":
                t(o, n, a.name);
            }
        }
      },
      AssignmentPattern(s, n) {
        let a = s.node.left;
        if (a.type === "Identifier") {
          let o = (0, Ca.skipTransparentExprWrappers)(s.get("right"));
          if (e(o)) {
            let l = a.name;
            t(o, n, l);
          }
        }
      },
      ObjectExpression(s, n) {
        for (let a of s.get("properties")) {
          let {
            node: o
          } = a;
          if (o.type !== "ObjectProperty") continue;
          let l = o.key, u = (0, Ca.skipTransparentExprWrappers)(a.get("value"));
          if (e(u)) {
            if (o.computed) {
              let c = r(a, l, n);
              t(u, n, c);
            } else if (!s8e(l))
              if (l.type === "Identifier")
                t(u, n, l.name);
              else {
                let c = w.types.stringLiteral(l.value + "");
                t(u, n, c);
              }
          }
        }
      },
      ClassPrivateProperty(s, n) {
        let {
          node: a
        } = s, o = (0, Ca.skipTransparentExprWrappers)(s.get("value"));
        if (e(o)) {
          let l = w.types.stringLiteral("#" + a.key.id.name);
          t(o, n, l);
        }
      },
      ClassAccessorProperty(s, n) {
        let {
          node: a
        } = s, o = a.key, l = (0, Ca.skipTransparentExprWrappers)(s.get("value"));
        if (e(l))
          if (a.computed) {
            let u = r(s, o, n);
            t(l, n, u);
          } else if (o.type === "Identifier")
            t(l, n, o.name);
          else if (o.type === "PrivateName") {
            let u = w.types.stringLiteral("#" + o.id.name);
            t(l, n, u);
          } else {
            let u = w.types.stringLiteral(o.value + "");
            t(l, n, u);
          }
      },
      ClassProperty(s, n) {
        let {
          node: a
        } = s, o = a.key, l = (0, Ca.skipTransparentExprWrappers)(s.get("value"));
        if (e(l))
          if (a.computed) {
            let u = r(s, o, n);
            t(l, n, u);
          } else if (o.type === "Identifier")
            t(l, n, o.name);
          else {
            let u = w.types.stringLiteral(o.value + "");
            t(l, n, u);
          }
      }
    };
  }
  i(a8e, "NamedEvaluationVisitoryFactory");
  function o8e(e) {
    return e.isClassExpression({
      id: null
    }) && i8e(e.node);
  }
  i(o8e, "isDecoratedAnonymousClassExpression");
  function Ds(e, t) {
    let r = e.generateUidIdentifier(t);
    return e.push({
      id: r,
      kind: "let"
    }), w.types.cloneNode(r);
  }
  i(Ds, "generateLetUidIdentifier");
  function l8e({
    assertVersion: e,
    assumption: t
  }, {
    loose: r
  }, s, n) {
    var a, o;
    e(s === "2023-11" || s === "2023-05" || s === "2023-01" ? "^7.21.0" : s === "2021-12" ? "^7.16.0" : "^7.19.0");
    let l = /* @__PURE__ */ new WeakSet(), u = (a = t("constantSuper")) != null ? a : r, c = (o = t("ignoreFunctionLength")) != null ? o : r,
    f = a8e(o8e, p);
    function p(d, m, b) {
      var h, g;
      if (l.has(d)) return;
      let {
        node: E
      } = d;
      (h = b) != null || (b = (g = E.id) == null ? void 0 : g.name);
      let D = t8e(d, m, u, c, b, f, s);
      if (D) {
        l.add(D);
        return;
      }
      l.add(d);
    }
    return i(p, "visitClass"), {
      name: "proposal-decorators",
      inherits: n,
      visitor: Object.assign({
        ExportDefaultDeclaration(d, m) {
          let {
            declaration: b
          } = d.node;
          if (b?.type === "ClassDeclaration" && Lf(b)) {
            let h = !b.id, g = (0, R9.default)(d);
            h && p(g, m, w.types.stringLiteral("default"));
          }
        },
        ExportNamedDeclaration(d) {
          let {
            declaration: m
          } = d.node;
          m?.type === "ClassDeclaration" && Lf(m) && (0, R9.default)(d);
        },
        Class(d, m) {
          p(d, m, void 0);
        }
      }, f)
    };
  }
  i(l8e, "_default");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/semver/semver.js
var J9 = y((Ue, z9) => {
  Ue = z9.exports = Ze;
  var Nt;
  typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? Nt = /* @__PURE__ */ i(
  function() {
    var e = Array.prototype.slice.call(arguments, 0);
    e.unshift("SEMVER"), console.log.apply(console, e);
  }, "debug") : Nt = /* @__PURE__ */ i(function() {
  }, "debug");
  Ue.SEMVER_SPEC_VERSION = "2.0.0";
  var Bf = 256, fy = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, QP = 16, u8e = Bf - 6, eu = Ue.re = [], Ot = Ue.safeRe = [], te = Ue.src = [], K = Ue.tokens = {}, Y9 = 0;
  function at(e) {
    K[e] = Y9++;
  }
  i(at, "tok");
  var eA = "[a-zA-Z0-9-]", ZP = [
    ["\\s", 1],
    ["\\d", Bf],
    [eA, u8e]
  ];
  function jf(e) {
    for (var t = 0; t < ZP.length; t++) {
      var r = ZP[t][0], s = ZP[t][1];
      e = e.split(r + "*").join(r + "{0," + s + "}").split(r + "+").join(r + "{1," + s + "}");
    }
    return e;
  }
  i(jf, "makeSafeRe");
  at("NUMERICIDENTIFIER");
  te[K.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  at("NUMERICIDENTIFIERLOOSE");
  te[K.NUMERICIDENTIFIERLOOSE] = "\\d+";
  at("NONNUMERICIDENTIFIER");
  te[K.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + eA + "*";
  at("MAINVERSION");
  te[K.MAINVERSION] = "(" + te[K.NUMERICIDENTIFIER] + ")\\.(" + te[K.NUMERICIDENTIFIER] + ")\\.(" + te[K.NUMERICIDENTIFIER] + ")";
  at("MAINVERSIONLOOSE");
  te[K.MAINVERSIONLOOSE] = "(" + te[K.NUMERICIDENTIFIERLOOSE] + ")\\.(" + te[K.NUMERICIDENTIFIERLOOSE] + ")\\.(" + te[K.NUMERICIDENTIFIERLOOSE] +
  ")";
  at("PRERELEASEIDENTIFIER");
  te[K.PRERELEASEIDENTIFIER] = "(?:" + te[K.NUMERICIDENTIFIER] + "|" + te[K.NONNUMERICIDENTIFIER] + ")";
  at("PRERELEASEIDENTIFIERLOOSE");
  te[K.PRERELEASEIDENTIFIERLOOSE] = "(?:" + te[K.NUMERICIDENTIFIERLOOSE] + "|" + te[K.NONNUMERICIDENTIFIER] + ")";
  at("PRERELEASE");
  te[K.PRERELEASE] = "(?:-(" + te[K.PRERELEASEIDENTIFIER] + "(?:\\." + te[K.PRERELEASEIDENTIFIER] + ")*))";
  at("PRERELEASELOOSE");
  te[K.PRERELEASELOOSE] = "(?:-?(" + te[K.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + te[K.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  at("BUILDIDENTIFIER");
  te[K.BUILDIDENTIFIER] = eA + "+";
  at("BUILD");
  te[K.BUILD] = "(?:\\+(" + te[K.BUILDIDENTIFIER] + "(?:\\." + te[K.BUILDIDENTIFIER] + ")*))";
  at("FULL");
  at("FULLPLAIN");
  te[K.FULLPLAIN] = "v?" + te[K.MAINVERSION] + te[K.PRERELEASE] + "?" + te[K.BUILD] + "?";
  te[K.FULL] = "^" + te[K.FULLPLAIN] + "$";
  at("LOOSEPLAIN");
  te[K.LOOSEPLAIN] = "[v=\\s]*" + te[K.MAINVERSIONLOOSE] + te[K.PRERELEASELOOSE] + "?" + te[K.BUILD] + "?";
  at("LOOSE");
  te[K.LOOSE] = "^" + te[K.LOOSEPLAIN] + "$";
  at("GTLT");
  te[K.GTLT] = "((?:<|>)?=?)";
  at("XRANGEIDENTIFIERLOOSE");
  te[K.XRANGEIDENTIFIERLOOSE] = te[K.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  at("XRANGEIDENTIFIER");
  te[K.XRANGEIDENTIFIER] = te[K.NUMERICIDENTIFIER] + "|x|X|\\*";
  at("XRANGEPLAIN");
  te[K.XRANGEPLAIN] = "[v=\\s]*(" + te[K.XRANGEIDENTIFIER] + ")(?:\\.(" + te[K.XRANGEIDENTIFIER] + ")(?:\\.(" + te[K.XRANGEIDENTIFIER] + ")(\
?:" + te[K.PRERELEASE] + ")?" + te[K.BUILD] + "?)?)?";
  at("XRANGEPLAINLOOSE");
  te[K.XRANGEPLAINLOOSE] = "[v=\\s]*(" + te[K.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + te[K.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + te[K.XRANGEIDENTIFIERLOOSE] +
  ")(?:" + te[K.PRERELEASELOOSE] + ")?" + te[K.BUILD] + "?)?)?";
  at("XRANGE");
  te[K.XRANGE] = "^" + te[K.GTLT] + "\\s*" + te[K.XRANGEPLAIN] + "$";
  at("XRANGELOOSE");
  te[K.XRANGELOOSE] = "^" + te[K.GTLT] + "\\s*" + te[K.XRANGEPLAINLOOSE] + "$";
  at("COERCE");
  te[K.COERCE] = "(^|[^\\d])(\\d{1," + QP + "})(?:\\.(\\d{1," + QP + "}))?(?:\\.(\\d{1," + QP + "}))?(?:$|[^\\d])";
  at("COERCERTL");
  eu[K.COERCERTL] = new RegExp(te[K.COERCE], "g");
  Ot[K.COERCERTL] = new RegExp(jf(te[K.COERCE]), "g");
  at("LONETILDE");
  te[K.LONETILDE] = "(?:~>?)";
  at("TILDETRIM");
  te[K.TILDETRIM] = "(\\s*)" + te[K.LONETILDE] + "\\s+";
  eu[K.TILDETRIM] = new RegExp(te[K.TILDETRIM], "g");
  Ot[K.TILDETRIM] = new RegExp(jf(te[K.TILDETRIM]), "g");
  var c8e = "$1~";
  at("TILDE");
  te[K.TILDE] = "^" + te[K.LONETILDE] + te[K.XRANGEPLAIN] + "$";
  at("TILDELOOSE");
  te[K.TILDELOOSE] = "^" + te[K.LONETILDE] + te[K.XRANGEPLAINLOOSE] + "$";
  at("LONECARET");
  te[K.LONECARET] = "(?:\\^)";
  at("CARETTRIM");
  te[K.CARETTRIM] = "(\\s*)" + te[K.LONECARET] + "\\s+";
  eu[K.CARETTRIM] = new RegExp(te[K.CARETTRIM], "g");
  Ot[K.CARETTRIM] = new RegExp(jf(te[K.CARETTRIM]), "g");
  var f8e = "$1^";
  at("CARET");
  te[K.CARET] = "^" + te[K.LONECARET] + te[K.XRANGEPLAIN] + "$";
  at("CARETLOOSE");
  te[K.CARETLOOSE] = "^" + te[K.LONECARET] + te[K.XRANGEPLAINLOOSE] + "$";
  at("COMPARATORLOOSE");
  te[K.COMPARATORLOOSE] = "^" + te[K.GTLT] + "\\s*(" + te[K.LOOSEPLAIN] + ")$|^$";
  at("COMPARATOR");
  te[K.COMPARATOR] = "^" + te[K.GTLT] + "\\s*(" + te[K.FULLPLAIN] + ")$|^$";
  at("COMPARATORTRIM");
  te[K.COMPARATORTRIM] = "(\\s*)" + te[K.GTLT] + "\\s*(" + te[K.LOOSEPLAIN] + "|" + te[K.XRANGEPLAIN] + ")";
  eu[K.COMPARATORTRIM] = new RegExp(te[K.COMPARATORTRIM], "g");
  Ot[K.COMPARATORTRIM] = new RegExp(jf(te[K.COMPARATORTRIM]), "g");
  var p8e = "$1$2$3";
  at("HYPHENRANGE");
  te[K.HYPHENRANGE] = "^\\s*(" + te[K.XRANGEPLAIN] + ")\\s+-\\s+(" + te[K.XRANGEPLAIN] + ")\\s*$";
  at("HYPHENRANGELOOSE");
  te[K.HYPHENRANGELOOSE] = "^\\s*(" + te[K.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + te[K.XRANGEPLAINLOOSE] + ")\\s*$";
  at("STAR");
  te[K.STAR] = "(<|>)?=?\\s*\\*";
  for (Kn = 0; Kn < Y9; Kn++)
    Nt(Kn, te[Kn]), eu[Kn] || (eu[Kn] = new RegExp(te[Kn]), Ot[Kn] = new RegExp(jf(te[Kn])));
  var Kn;
  Ue.parse = Do;
  function Do(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof Ze)
      return e;
    if (typeof e != "string" || e.length > Bf)
      return null;
    var r = t.loose ? Ot[K.LOOSE] : Ot[K.FULL];
    if (!r.test(e))
      return null;
    try {
      return new Ze(e, t);
    } catch {
      return null;
    }
  }
  i(Do, "parse");
  Ue.valid = d8e;
  function d8e(e, t) {
    var r = Do(e, t);
    return r ? r.version : null;
  }
  i(d8e, "valid");
  Ue.clean = h8e;
  function h8e(e, t) {
    var r = Do(e.trim().replace(/^[=v]+/, ""), t);
    return r ? r.version : null;
  }
  i(h8e, "clean");
  Ue.SemVer = Ze;
  function Ze(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof Ze) {
      if (e.loose === t.loose)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError("Invalid Version: " + e);
    if (e.length > Bf)
      throw new TypeError("version is longer than " + Bf + " characters");
    if (!(this instanceof Ze))
      return new Ze(e, t);
    Nt("SemVer", e, t), this.options = t, this.loose = !!t.loose;
    var r = e.trim().match(t.loose ? Ot[K.LOOSE] : Ot[K.FULL]);
    if (!r)
      throw new TypeError("Invalid Version: " + e);
    if (this.raw = e, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > fy || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > fy || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > fy || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4] ? this.prerelease = r[4].split(".").map(function(s) {
      if (/^[0-9]+$/.test(s)) {
        var n = +s;
        if (n >= 0 && n < fy)
          return n;
      }
      return s;
    }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format();
  }
  i(Ze, "SemVer");
  Ze.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.
    join(".")), this.version;
  };
  Ze.prototype.toString = function() {
    return this.version;
  };
  Ze.prototype.compare = function(e) {
    return Nt("SemVer.compare", this.version, this.options, e), e instanceof Ze || (e = new Ze(e, this.options)), this.compareMain(e) || this.
    comparePre(e);
  };
  Ze.prototype.compareMain = function(e) {
    return e instanceof Ze || (e = new Ze(e, this.options)), wo(this.major, e.major) || wo(this.minor, e.minor) || wo(this.patch, e.patch);
  };
  Ze.prototype.comparePre = function(e) {
    if (e instanceof Ze || (e = new Ze(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    var t = 0;
    do {
      var r = this.prerelease[t], s = e.prerelease[t];
      if (Nt("prerelease compare", t, r, s), r === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === s)
        continue;
      return wo(r, s);
    } while (++t);
  };
  Ze.prototype.compareBuild = function(e) {
    e instanceof Ze || (e = new Ze(e, this.options));
    var t = 0;
    do {
      var r = this.build[t], s = e.build[t];
      if (Nt("prerelease compare", t, r, s), r === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === s)
        continue;
      return wo(r, s);
    } while (++t);
  };
  Ze.prototype.inc = function(e, t) {
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t), this.inc("pre", t);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease =
        [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var r = this.prerelease.length; --r >= 0; )
            typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
          r === -1 && this.prerelease.push(0);
        }
        t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + e);
    }
    return this.format(), this.raw = this.version, this;
  };
  Ue.inc = m8e;
  function m8e(e, t, r, s) {
    typeof r == "string" && (s = r, r = void 0);
    try {
      return new Ze(e, r).inc(t, s).version;
    } catch {
      return null;
    }
  }
  i(m8e, "inc");
  Ue.diff = y8e;
  function y8e(e, t) {
    if (tA(e, t))
      return null;
    var r = Do(e), s = Do(t), n = "";
    if (r.prerelease.length || s.prerelease.length) {
      n = "pre";
      var a = "prerelease";
    }
    for (var o in r)
      if ((o === "major" || o === "minor" || o === "patch") && r[o] !== s[o])
        return n + o;
    return a;
  }
  i(y8e, "diff");
  Ue.compareIdentifiers = wo;
  var G9 = /^[0-9]+$/;
  function wo(e, t) {
    var r = G9.test(e), s = G9.test(t);
    return r && s && (e = +e, t = +t), e === t ? 0 : r && !s ? -1 : s && !r ? 1 : e < t ? -1 : 1;
  }
  i(wo, "compareIdentifiers");
  Ue.rcompareIdentifiers = g8e;
  function g8e(e, t) {
    return wo(t, e);
  }
  i(g8e, "rcompareIdentifiers");
  Ue.major = b8e;
  function b8e(e, t) {
    return new Ze(e, t).major;
  }
  i(b8e, "major");
  Ue.minor = E8e;
  function E8e(e, t) {
    return new Ze(e, t).minor;
  }
  i(E8e, "minor");
  Ue.patch = v8e;
  function v8e(e, t) {
    return new Ze(e, t).patch;
  }
  i(v8e, "patch");
  Ue.compare = Ni;
  function Ni(e, t, r) {
    return new Ze(e, r).compare(new Ze(t, r));
  }
  i(Ni, "compare");
  Ue.compareLoose = S8e;
  function S8e(e, t) {
    return Ni(e, t, !0);
  }
  i(S8e, "compareLoose");
  Ue.compareBuild = T8e;
  function T8e(e, t, r) {
    var s = new Ze(e, r), n = new Ze(t, r);
    return s.compare(n) || s.compareBuild(n);
  }
  i(T8e, "compareBuild");
  Ue.rcompare = x8e;
  function x8e(e, t, r) {
    return Ni(t, e, r);
  }
  i(x8e, "rcompare");
  Ue.sort = P8e;
  function P8e(e, t) {
    return e.sort(function(r, s) {
      return Ue.compareBuild(r, s, t);
    });
  }
  i(P8e, "sort");
  Ue.rsort = A8e;
  function A8e(e, t) {
    return e.sort(function(r, s) {
      return Ue.compareBuild(s, r, t);
    });
  }
  i(A8e, "rsort");
  Ue.gt = Mf;
  function Mf(e, t, r) {
    return Ni(e, t, r) > 0;
  }
  i(Mf, "gt");
  Ue.lt = py;
  function py(e, t, r) {
    return Ni(e, t, r) < 0;
  }
  i(py, "lt");
  Ue.eq = tA;
  function tA(e, t, r) {
    return Ni(e, t, r) === 0;
  }
  i(tA, "eq");
  Ue.neq = X9;
  function X9(e, t, r) {
    return Ni(e, t, r) !== 0;
  }
  i(X9, "neq");
  Ue.gte = rA;
  function rA(e, t, r) {
    return Ni(e, t, r) >= 0;
  }
  i(rA, "gte");
  Ue.lte = sA;
  function sA(e, t, r) {
    return Ni(e, t, r) <= 0;
  }
  i(sA, "lte");
  Ue.cmp = dy;
  function dy(e, t, r, s) {
    switch (t) {
      case "===":
        return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
      case "!==":
        return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
      case "":
      case "=":
      case "==":
        return tA(e, r, s);
      case "!=":
        return X9(e, r, s);
      case ">":
        return Mf(e, r, s);
      case ">=":
        return rA(e, r, s);
      case "<":
        return py(e, r, s);
      case "<=":
        return sA(e, r, s);
      default:
        throw new TypeError("Invalid operator: " + t);
    }
  }
  i(dy, "cmp");
  Ue.Comparator = Js;
  function Js(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof Js) {
      if (e.loose === !!t.loose)
        return e;
      e = e.value;
    }
    if (!(this instanceof Js))
      return new Js(e, t);
    e = e.trim().split(/\s+/).join(" "), Nt("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === tu ?
    this.value = "" : this.value = this.operator + this.semver.version, Nt("comp", this);
  }
  i(Js, "Comparator");
  var tu = {};
  Js.prototype.parse = function(e) {
    var t = this.options.loose ? Ot[K.COMPARATORLOOSE] : Ot[K.COMPARATOR], r = e.match(t);
    if (!r)
      throw new TypeError("Invalid comparator: " + e);
    this.operator = r[1] !== void 0 ? r[1] : "", this.operator === "=" && (this.operator = ""), r[2] ? this.semver = new Ze(r[2], this.options.
    loose) : this.semver = tu;
  };
  Js.prototype.toString = function() {
    return this.value;
  };
  Js.prototype.test = function(e) {
    if (Nt("Comparator.test", e, this.options.loose), this.semver === tu || e === tu)
      return !0;
    if (typeof e == "string")
      try {
        e = new Ze(e, this.options);
      } catch {
        return !1;
      }
    return dy(e, this.operator, this.semver, this.options);
  };
  Js.prototype.intersects = function(e, t) {
    if (!(e instanceof Js))
      throw new TypeError("a Comparator is required");
    (!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    });
    var r;
    if (this.operator === "")
      return this.value === "" ? !0 : (r = new cr(e.value, t), hy(this.value, r, t));
    if (e.operator === "")
      return e.value === "" ? !0 : (r = new cr(this.value, t), hy(e.semver, r, t));
    var s = (this.operator === ">=" || this.operator === ">") && (e.operator === ">=" || e.operator === ">"), n = (this.operator === "<=" ||
    this.operator === "<") && (e.operator === "<=" || e.operator === "<"), a = this.semver.version === e.semver.version, o = (this.operator ===
    ">=" || this.operator === "<=") && (e.operator === ">=" || e.operator === "<="), l = dy(this.semver, "<", e.semver, t) && (this.operator ===
    ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"), u = dy(this.semver, ">", e.semver, t) && (this.operator ===
    "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
    return s || n || a && o || l || u;
  };
  Ue.Range = cr;
  function cr(e, t) {
    if ((!t || typeof t != "object") && (t = {
      loose: !!t,
      includePrerelease: !1
    }), e instanceof cr)
      return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new cr(e.raw, t);
    if (e instanceof Js)
      return new cr(e.value, t);
    if (!(this instanceof cr))
      return new cr(e, t);
    if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e.trim().split(/\s+/).join(" "),
    this.set = this.raw.split("||").map(function(r) {
      return this.parseRange(r.trim());
    }, this).filter(function(r) {
      return r.length;
    }), !this.set.length)
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    this.format();
  }
  i(cr, "Range");
  cr.prototype.format = function() {
    return this.range = this.set.map(function(e) {
      return e.join(" ").trim();
    }).join("||").trim(), this.range;
  };
  cr.prototype.toString = function() {
    return this.range;
  };
  cr.prototype.parseRange = function(e) {
    var t = this.options.loose, r = t ? Ot[K.HYPHENRANGELOOSE] : Ot[K.HYPHENRANGE];
    e = e.replace(r, F8e), Nt("hyphen replace", e), e = e.replace(Ot[K.COMPARATORTRIM], p8e), Nt("comparator trim", e, Ot[K.COMPARATORTRIM]),
    e = e.replace(Ot[K.TILDETRIM], c8e), e = e.replace(Ot[K.CARETTRIM], f8e), e = e.split(/\s+/).join(" ");
    var s = t ? Ot[K.COMPARATORLOOSE] : Ot[K.COMPARATOR], n = e.split(" ").map(function(a) {
      return w8e(a, this.options);
    }, this).join(" ").split(/\s+/);
    return this.options.loose && (n = n.filter(function(a) {
      return !!a.match(s);
    })), n = n.map(function(a) {
      return new Js(a, this.options);
    }, this), n;
  };
  cr.prototype.intersects = function(e, t) {
    if (!(e instanceof cr))
      throw new TypeError("a Range is required");
    return this.set.some(function(r) {
      return K9(r, t) && e.set.some(function(s) {
        return K9(s, t) && r.every(function(n) {
          return s.every(function(a) {
            return n.intersects(a, t);
          });
        });
      });
    });
  };
  function K9(e, t) {
    for (var r = !0, s = e.slice(), n = s.pop(); r && s.length; )
      r = s.every(function(a) {
        return n.intersects(a, t);
      }), n = s.pop();
    return r;
  }
  i(K9, "isSatisfiable");
  Ue.toComparators = C8e;
  function C8e(e, t) {
    return new cr(e, t).set.map(function(r) {
      return r.map(function(s) {
        return s.value;
      }).join(" ").trim().split(" ");
    });
  }
  i(C8e, "toComparators");
  function w8e(e, t) {
    return Nt("comp", e, t), e = _8e(e, t), Nt("caret", e), e = D8e(e, t), Nt("tildes", e), e = N8e(e, t), Nt("xrange", e), e = k8e(e, t), Nt(
    "stars", e), e;
  }
  i(w8e, "parseComparator");
  function ds(e) {
    return !e || e.toLowerCase() === "x" || e === "*";
  }
  i(ds, "isX");
  function D8e(e, t) {
    return e.trim().split(/\s+/).map(function(r) {
      return I8e(r, t);
    }).join(" ");
  }
  i(D8e, "replaceTildes");
  function I8e(e, t) {
    var r = t.loose ? Ot[K.TILDELOOSE] : Ot[K.TILDE];
    return e.replace(r, function(s, n, a, o, l) {
      Nt("tilde", e, s, n, a, o, l);
      var u;
      return ds(n) ? u = "" : ds(a) ? u = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : ds(o) ? u = ">=" + n + "." + a + ".0 <" + n + "." + (+a +
      1) + ".0" : l ? (Nt("replaceTilde pr", l), u = ">=" + n + "." + a + "." + o + "-" + l + " <" + n + "." + (+a + 1) + ".0") : u = ">=" +
      n + "." + a + "." + o + " <" + n + "." + (+a + 1) + ".0", Nt("tilde return", u), u;
    });
  }
  i(I8e, "replaceTilde");
  function _8e(e, t) {
    return e.trim().split(/\s+/).map(function(r) {
      return O8e(r, t);
    }).join(" ");
  }
  i(_8e, "replaceCarets");
  function O8e(e, t) {
    Nt("caret", e, t);
    var r = t.loose ? Ot[K.CARETLOOSE] : Ot[K.CARET];
    return e.replace(r, function(s, n, a, o, l) {
      Nt("caret", e, s, n, a, o, l);
      var u;
      return ds(n) ? u = "" : ds(a) ? u = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : ds(o) ? n === "0" ? u = ">=" + n + "." + a + ".0 <" + n +
      "." + (+a + 1) + ".0" : u = ">=" + n + "." + a + ".0 <" + (+n + 1) + ".0.0" : l ? (Nt("replaceCaret pr", l), n === "0" ? a === "0" ? u =
      ">=" + n + "." + a + "." + o + "-" + l + " <" + n + "." + a + "." + (+o + 1) : u = ">=" + n + "." + a + "." + o + "-" + l + " <" + n +
      "." + (+a + 1) + ".0" : u = ">=" + n + "." + a + "." + o + "-" + l + " <" + (+n + 1) + ".0.0") : (Nt("no pr"), n === "0" ? a === "0" ?
      u = ">=" + n + "." + a + "." + o + " <" + n + "." + a + "." + (+o + 1) : u = ">=" + n + "." + a + "." + o + " <" + n + "." + (+a + 1) +
      ".0" : u = ">=" + n + "." + a + "." + o + " <" + (+n + 1) + ".0.0"), Nt("caret return", u), u;
    });
  }
  i(O8e, "replaceCaret");
  function N8e(e, t) {
    return Nt("replaceXRanges", e, t), e.split(/\s+/).map(function(r) {
      return R8e(r, t);
    }).join(" ");
  }
  i(N8e, "replaceXRanges");
  function R8e(e, t) {
    e = e.trim();
    var r = t.loose ? Ot[K.XRANGELOOSE] : Ot[K.XRANGE];
    return e.replace(r, function(s, n, a, o, l, u) {
      Nt("xRange", e, s, n, a, o, l, u);
      var c = ds(a), f = c || ds(o), p = f || ds(l), d = p;
      return n === "=" && d && (n = ""), u = t.includePrerelease ? "-0" : "", c ? n === ">" || n === "<" ? s = "<0.0.0-0" : s = "*" : n && d ?
      (f && (o = 0), l = 0, n === ">" ? (n = ">=", f ? (a = +a + 1, o = 0, l = 0) : (o = +o + 1, l = 0)) : n === "<=" && (n = "<", f ? a = +a +
      1 : o = +o + 1), s = n + a + "." + o + "." + l + u) : f ? s = ">=" + a + ".0.0" + u + " <" + (+a + 1) + ".0.0" + u : p && (s = ">=" + a +
      "." + o + ".0" + u + " <" + a + "." + (+o + 1) + ".0" + u), Nt("xRange return", s), s;
    });
  }
  i(R8e, "replaceXRange");
  function k8e(e, t) {
    return Nt("replaceStars", e, t), e.trim().replace(Ot[K.STAR], "");
  }
  i(k8e, "replaceStars");
  function F8e(e, t, r, s, n, a, o, l, u, c, f, p, d) {
    return ds(r) ? t = "" : ds(s) ? t = ">=" + r + ".0.0" : ds(n) ? t = ">=" + r + "." + s + ".0" : t = ">=" + t, ds(u) ? l = "" : ds(c) ? l =
    "<" + (+u + 1) + ".0.0" : ds(f) ? l = "<" + u + "." + (+c + 1) + ".0" : p ? l = "<=" + u + "." + c + "." + f + "-" + p : l = "<=" + l, (t +
    " " + l).trim();
  }
  i(F8e, "hyphenReplace");
  cr.prototype.test = function(e) {
    if (!e)
      return !1;
    if (typeof e == "string")
      try {
        e = new Ze(e, this.options);
      } catch {
        return !1;
      }
    for (var t = 0; t < this.set.length; t++)
      if (L8e(this.set[t], e, this.options))
        return !0;
    return !1;
  };
  function L8e(e, t, r) {
    for (var s = 0; s < e.length; s++)
      if (!e[s].test(t))
        return !1;
    if (t.prerelease.length && !r.includePrerelease) {
      for (s = 0; s < e.length; s++)
        if (Nt(e[s].semver), e[s].semver !== tu && e[s].semver.prerelease.length > 0) {
          var n = e[s].semver;
          if (n.major === t.major && n.minor === t.minor && n.patch === t.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  }
  i(L8e, "testSet");
  Ue.satisfies = hy;
  function hy(e, t, r) {
    try {
      t = new cr(t, r);
    } catch {
      return !1;
    }
    return t.test(e);
  }
  i(hy, "satisfies");
  Ue.maxSatisfying = B8e;
  function B8e(e, t, r) {
    var s = null, n = null;
    try {
      var a = new cr(t, r);
    } catch {
      return null;
    }
    return e.forEach(function(o) {
      a.test(o) && (!s || n.compare(o) === -1) && (s = o, n = new Ze(s, r));
    }), s;
  }
  i(B8e, "maxSatisfying");
  Ue.minSatisfying = M8e;
  function M8e(e, t, r) {
    var s = null, n = null;
    try {
      var a = new cr(t, r);
    } catch {
      return null;
    }
    return e.forEach(function(o) {
      a.test(o) && (!s || n.compare(o) === 1) && (s = o, n = new Ze(s, r));
    }), s;
  }
  i(M8e, "minSatisfying");
  Ue.minVersion = j8e;
  function j8e(e, t) {
    e = new cr(e, t);
    var r = new Ze("0.0.0");
    if (e.test(r) || (r = new Ze("0.0.0-0"), e.test(r)))
      return r;
    r = null;
    for (var s = 0; s < e.set.length; ++s) {
      var n = e.set[s];
      n.forEach(function(a) {
        var o = new Ze(a.semver.version);
        switch (a.operator) {
          case ">":
            o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0), o.raw = o.format();
          case "":
          case ">=":
            (!r || Mf(r, o)) && (r = o);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + a.operator);
        }
      });
    }
    return r && e.test(r) ? r : null;
  }
  i(j8e, "minVersion");
  Ue.validRange = q8e;
  function q8e(e, t) {
    try {
      return new cr(e, t).range || "*";
    } catch {
      return null;
    }
  }
  i(q8e, "validRange");
  Ue.ltr = $8e;
  function $8e(e, t, r) {
    return nA(e, t, "<", r);
  }
  i($8e, "ltr");
  Ue.gtr = U8e;
  function U8e(e, t, r) {
    return nA(e, t, ">", r);
  }
  i(U8e, "gtr");
  Ue.outside = nA;
  function nA(e, t, r, s) {
    e = new Ze(e, s), t = new cr(t, s);
    var n, a, o, l, u;
    switch (r) {
      case ">":
        n = Mf, a = sA, o = py, l = ">", u = ">=";
        break;
      case "<":
        n = py, a = rA, o = Mf, l = "<", u = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (hy(e, t, s))
      return !1;
    for (var c = 0; c < t.set.length; ++c) {
      var f = t.set[c], p = null, d = null;
      if (f.forEach(function(m) {
        m.semver === tu && (m = new Js(">=0.0.0")), p = p || m, d = d || m, n(m.semver, p.semver, s) ? p = m : o(m.semver, d.semver, s) && (d =
        m);
      }), p.operator === l || p.operator === u || (!d.operator || d.operator === l) && a(e, d.semver))
        return !1;
      if (d.operator === u && o(e, d.semver))
        return !1;
    }
    return !0;
  }
  i(nA, "outside");
  Ue.prerelease = V8e;
  function V8e(e, t) {
    var r = Do(e, t);
    return r && r.prerelease.length ? r.prerelease : null;
  }
  i(V8e, "prerelease");
  Ue.intersects = W8e;
  function W8e(e, t, r) {
    return e = new cr(e, r), t = new cr(t, r), e.intersects(t);
  }
  i(W8e, "intersects");
  Ue.coerce = H8e;
  function H8e(e, t) {
    if (e instanceof Ze)
      return e;
    if (typeof e == "number" && (e = String(e)), typeof e != "string")
      return null;
    t = t || {};
    var r = null;
    if (!t.rtl)
      r = e.match(Ot[K.COERCE]);
    else {
      for (var s; (s = Ot[K.COERCERTL].exec(e)) && (!r || r.index + r[0].length !== e.length); )
        (!r || s.index + s[0].length !== r.index + r[0].length) && (r = s), Ot[K.COERCERTL].lastIndex = s.index + s[1].length + s[2].length;
      Ot[K.COERCERTL].lastIndex = -1;
    }
    return r === null ? null : Do(r[2] + "." + (r[3] || "0") + "." + (r[4] || "0"), t);
  }
  i(H8e, "coerce");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js
var aA = y((qf) => {
  "use strict";
  Object.defineProperty(qf, "__esModule", {
    value: !0
  });
  qf.buildDecoratedClass = Z8e;
  qf.hasDecorators = Y8e;
  qf.hasOwnDecorators = iA;
  var jt = mr(), G8e = iy(), K8e = nh();
  function iA(e) {
    var t;
    return !!((t = e.decorators) != null && t.length);
  }
  i(iA, "hasOwnDecorators");
  function Y8e(e) {
    return iA(e) || e.body.body.some(iA);
  }
  i(Y8e, "hasDecorators");
  function ru(e, t) {
    return t ? jt.types.objectProperty(jt.types.identifier(e), t) : null;
  }
  i(ru, "prop");
  function X8e(e, t) {
    return jt.types.objectMethod("method", jt.types.identifier(e), [], jt.types.blockStatement(t));
  }
  i(X8e, "method");
  function Q9(e) {
    let t;
    return e.decorators && e.decorators.length > 0 && (t = jt.types.arrayExpression(e.decorators.map((r) => r.expression))), e.decorators = void 0,
    t;
  }
  i(Q9, "takeDecorators");
  function z8e(e) {
    return e.computed ? e.key : jt.types.isIdentifier(e.key) ? jt.types.stringLiteral(e.key.name) : jt.types.stringLiteral(String(e.key.value));
  }
  i(z8e, "getKey");
  function J8e(e, t, r, s) {
    let n = s.isClassMethod();
    if (s.isPrivate())
      throw s.buildCodeFrameError(`Private ${n ? "methods" : "fields"} in decorated classes are not supported yet.`);
    if (s.node.type === "ClassAccessorProperty")
      throw s.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-1\
2" } instead.');
    if (s.node.type === "StaticBlock")
      throw s.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } i\
nstead.');
    let {
      node: a,
      scope: o
    } = s;
    s.isTSDeclareMethod() || new G8e.default({
      methodPath: s,
      objectRef: t,
      superRef: r,
      file: e,
      refToPreserve: t
    }).replace();
    let l = [ru("kind", jt.types.stringLiteral(jt.types.isClassMethod(a) ? a.kind : "field")), ru("decorators", Q9(a)), ru("static", a.static &&
    jt.types.booleanLiteral(!0)), ru("key", z8e(a))].filter(Boolean);
    if (jt.types.isClassMethod(a)) {
      let u = a.computed ? null : a.key, c = jt.types.toExpression(a);
      l.push(ru("value", (0, K8e.default)({
        node: c,
        id: u,
        scope: o
      }) || c));
    } else jt.types.isClassProperty(a) && a.value ? l.push(X8e("value", jt.template.statements.ast`return ${a.value}`)) : l.push(ru("value",
    o.buildUndefinedNode()));
    return s.remove(), jt.types.objectExpression(l);
  }
  i(J8e, "extractElementDescriptor");
  function Q8e(e) {
    return e.addHelper("decorate");
  }
  i(Q8e, "addDecorateHelper");
  function Z8e(e, t, r, s) {
    let {
      node: n,
      scope: a
    } = t, o = a.generateUidIdentifier("initialize"), l = n.id && t.isDeclaration(), u = t.isInStrictMode(), {
      superClass: c
    } = n;
    n.type = "ClassDeclaration", n.id || (n.id = jt.types.cloneNode(e));
    let f;
    c && (f = a.generateUidIdentifierBasedOnNode(n.superClass, "super"), n.superClass = f);
    let p = Q9(n), d = jt.types.arrayExpression(r.filter((g) => !g.node.abstract && g.node.type !== "TSIndexSignature").map((g) => J8e(s, n.
    id, f, g))), m = jt.template.expression.ast`
    ${Q8e(s)}(
      ${p || jt.types.nullLiteral()},
      function (${o}, ${c ? jt.types.cloneNode(f) : null}) {
        ${n}
        return { F: ${jt.types.cloneNode(n.id)}, d: ${d} };
      },
      ${c}
    )
  `;
    u || m.arguments[1].body.directives.push(jt.types.directive(jt.types.directiveLiteral("use strict")));
    let b = m, h = "arguments.1.body.body.0";
    return l && (b = jt.template.statement.ast`let ${e} = ${m}`, h = "declarations.0.init." + h), {
      instanceNodes: [jt.template.statement.ast`
        ${jt.types.cloneNode(o)}(this)
      `],
      wrapClass(g) {
        return g.replaceWith(b), g.get(h);
      }
    };
  }
  i(Z8e, "buildDecoratedClass");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/features.js
var r7 = y((Io) => {
  "use strict";
  Object.defineProperty(Io, "__esModule", {
    value: !0
  });
  Io.FEATURES = void 0;
  Io.enableFeature = e6e;
  Io.isLoose = uA;
  Io.shouldTransform = t6e;
  var Z9 = aA(), Ri = Io.FEATURES = Object.freeze({
    fields: 2,
    privateMethods: 4,
    decorators: 8,
    privateIn: 16,
    staticBlocks: 32
  }), e7 = /* @__PURE__ */ new Map([[Ri.fields, "@babel/plugin-transform-class-properties"], [Ri.privateMethods, "@babel/plugin-transform-pr\
ivate-methods"], [Ri.privateIn, "@babel/plugin-transform-private-property-in-object"]]), oA = "@babel/plugin-class-features/featuresKey", $f = "\
@babel/plugin-class-features/looseKey";
  Ia = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
  var Ia;
  lA = /* @__PURE__ */ i(function(e, t) {
    return !!(e.get(Ia) & t);
  }, "canIgnoreLoose");
  var lA;
  function e6e(e, t, r) {
    (!ki(e, t) || lA(e, t)) && (e.set(oA, e.get(oA) | t), r === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-\
an-error" ? (my(e, t, !0), e.set(Ia, e.get(Ia) | t)) : r === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-\
error" ? (my(e, t, !1), e.set(Ia, e.get(Ia) | t)) : my(e, t, r));
    let s;
    for (let [a, o] of e7) {
      if (!ki(e, a) || lA(e, a)) continue;
      let l = uA(e, a);
      if (s === !l)
        throw new Error(`'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-p\
rivate-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).

` + t7(e));
      s = l;
      var n = o;
    }
    if (s !== void 0)
      for (let [a, o] of e7)
        ki(e, a) && uA(e, a) !== s && (my(e, a, s), console.warn(`Though the "loose" option was set to "${!s}" in your @babel/preset-env con\
fig, it will not be used for ${o} since the "loose" mode option was set to "${s}" for ${n}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-\
transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${o}", { "loose": ${s} }]
to the "plugins" section of your Babel config.

` + t7(e)));
  }
  i(e6e, "enableFeature");
  function t7(e) {
    let {
      filename: t
    } = e.opts;
    return (!t || t === "unknown") && (t = "[name of the input file]"), `If you already set the same 'loose' mode for these plugins in your \
config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${t} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
  }
  i(t7, "getBabelShowConfigForHint");
  function ki(e, t) {
    return !!(e.get(oA) & t);
  }
  i(ki, "hasFeature");
  function uA(e, t) {
    return !!(e.get($f) & t);
  }
  i(uA, "isLoose");
  function my(e, t, r) {
    r ? e.set($f, e.get($f) | t) : e.set($f, e.get($f) & ~t), e.set(Ia, e.get(Ia) & ~t);
  }
  i(my, "setLoose");
  function t6e(e, t) {
    let r = null, s = null, n = null, a = null, o = null;
    (0, Z9.hasOwnDecorators)(e.node) && (r = e.get("decorators.0"));
    for (let l of e.get("body.body"))
      !r && (0, Z9.hasOwnDecorators)(l.node) && (r = l.get("decorators.0")), !s && l.isClassProperty() && (s = l), !n && l.isClassPrivateProperty() &&
      (n = l), !a && l.isClassPrivateMethod != null && l.isClassPrivateMethod() && (a = l), !o && l.isStaticBlock != null && l.isStaticBlock() &&
      (o = l);
    if (r && n)
      throw n.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
    if (r && a)
      throw a.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
    if (r && !ki(t, Ri.decorators))
      throw e.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-\
properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);
    if (a && !ki(t, Ri.privateMethods))
      throw a.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your confi\
guration.");
    if ((s || n) && !ki(t, Ri.fields) && !ki(t, Ri.privateMethods))
      throw e.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration\
.");
    if (o && !ki(t, Ri.staticBlocks))
      throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your conf\
iguration.");
    return !!(r || a || o || (s || n) && ki(t, Ri.fields));
  }
  i(t6e, "shouldTransform");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/index.js
var s7 = y((Oo) => {
  "use strict";
  Object.defineProperty(Oo, "__esModule", {
    value: !0
  });
  Object.defineProperty(Oo, "FEATURES", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return su.FEATURES;
    }, "get")
  });
  Object.defineProperty(Oo, "buildCheckInRHS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Uf.buildCheckInRHS;
    }, "get")
  });
  Oo.createClassFeaturePlugin = o6e;
  Object.defineProperty(Oo, "enableFeature", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return su.enableFeature;
    }, "get")
  });
  Object.defineProperty(Oo, "injectInitialization", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return pA.injectInitialization;
    }, "get")
  });
  var cA = mr(), r6e = nh(), s6e = pc(), n6e = H9(), i6e = J9(), Uf = WP(), fA = aA(), pA = HP(), su = r7(), a6e = qP(), _o = "@babel/plugin\
-class-features/version";
  function o6e({
    name: e,
    feature: t,
    loose: r,
    manipulateOptions: s,
    api: n,
    inherits: a,
    decoratorVersion: o
  }) {
    var l;
    if (t & su.FEATURES.decorators && (o === "2023-11" || o === "2023-05" || o === "2023-01" || o === "2022-03" || o === "2021-12"))
      return (0, n6e.default)(n, {
        loose: r
      }, o, a);
    {
      var u;
      (u = n) != null || (n = {
        assumption: /* @__PURE__ */ i(() => {
        }, "assumption")
      });
    }
    let c = n.assumption("setPublicClassFields"), f = n.assumption("privateFieldsAsSymbols"), p = n.assumption("privateFieldsAsProperties"),
    d = (l = n.assumption("noUninitializedPrivateFieldAccess")) != null ? l : !1, m = n.assumption("constantSuper"), b = n.assumption("noDoc\
umentAll");
    if (p && f)
      throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
    let h = p || f;
    if (r === !0) {
      let g = [];
      c !== void 0 && g.push('"setPublicClassFields"'), p !== void 0 && g.push('"privateFieldsAsProperties"'), f !== void 0 && g.push('"priv\
ateFieldsAsSymbols"'), g.length !== 0 && console.warn(`[${e}]: You are using the "loose: true" option and you are explicitly setting a value\
 for the ${g.join(" and ")} assumption${g.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class featur\
es plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
    }
    return {
      name: e,
      manipulateOptions: s,
      inherits: a,
      pre(g) {
        if ((0, su.enableFeature)(g, t, r), typeof g.get(_o) == "number") {
          g.set(_o, "7.24.4");
          return;
        }
        (!g.get(_o) || i6e.lt(g.get(_o), "7.24.4")) && g.set(_o, "7.24.4");
      },
      visitor: {
        Class(g, {
          file: E
        }) {
          var D;
          if (E.get(_o) !== "7.24.4" || !(0, su.shouldTransform)(g, E)) return;
          let C = g.isClassDeclaration();
          C && (0, a6e.assertFieldTransformed)(g);
          let N = (0, su.isLoose)(E, t), I, M = (0, fA.hasDecorators)(g.node), q = [], V = [], W = [], Y = /* @__PURE__ */ new Set(), j = g.
          get("body");
          for (let Ie of j.get("body")) {
            if ((Ie.isClassProperty() || Ie.isClassMethod()) && Ie.node.computed && W.push(Ie), Ie.isPrivate()) {
              let {
                name: _e
              } = Ie.node.key.id, Jt = `get ${_e}`, Sr = `set ${_e}`;
              if (Ie.isClassPrivateMethod()) {
                if (Ie.node.kind === "get") {
                  if (Y.has(Jt) || Y.has(_e) && !Y.has(Sr))
                    throw Ie.buildCodeFrameError("Duplicate private field");
                  Y.add(Jt).add(_e);
                } else if (Ie.node.kind === "set") {
                  if (Y.has(Sr) || Y.has(_e) && !Y.has(Jt))
                    throw Ie.buildCodeFrameError("Duplicate private field");
                  Y.add(Sr).add(_e);
                }
              } else {
                if (Y.has(_e) && !Y.has(Jt) && !Y.has(Sr) || Y.has(_e) && (Y.has(Jt) || Y.has(Sr)))
                  throw Ie.buildCodeFrameError("Duplicate private field");
                Y.add(_e);
              }
            }
            Ie.isClassMethod({
              kind: "constructor"
            }) ? I = Ie : (V.push(Ie), (Ie.isProperty() || Ie.isPrivate() || Ie.isStaticBlock != null && Ie.isStaticBlock()) && q.push(Ie));
          }
          if (!q.length && !M) return;
          let ie = g.node.id, fe;
          (!ie || !C) && ((0, r6e.default)(g), fe = g.scope.generateUidIdentifier(ie?.name || "Class"));
          let De = (D = fe) != null ? D : cA.types.cloneNode(ie), F = (0, Uf.buildPrivateNamesMap)(De.name, h ?? N, q, E), L = (0, Uf.buildPrivateNamesNodes)(
          F, p ?? N, f ?? !1, E);
          (0, Uf.transformPrivateNamesUsage)(De, g, F, {
            privateFieldsAsProperties: h ?? N,
            noUninitializedPrivateFieldAccess: d,
            noDocumentAll: b,
            innerBinding: ie
          }, E);
          let re, se, be, je, Pe, Rt, Bt;
          M ? (se = Pe = re = [], {
            instanceNodes: be,
            wrapClass: Bt
          } = (0, fA.buildDecoratedClass)(De, g, V, E)) : (re = (0, pA.extractComputedKeys)(g, W, E), {
            staticNodes: se,
            pureStaticNodes: Pe,
            instanceNodes: be,
            lastInstanceNodeReturnsThis: je,
            classBindingNode: Rt,
            wrapClass: Bt
          } = (0, Uf.buildFieldsInitNodes)(fe, g.node.superClass, q, F, E, c ?? N, h ?? N, d, m ?? N, ie)), be.length > 0 && (0, pA.injectInitialization)(
          g, I, be, (Ie, _e) => {
            if (!M)
              for (let Jt of q)
                cA.types.isStaticBlock != null && cA.types.isStaticBlock(Jt.node) || Jt.node.static || Jt.traverse(Ie, _e);
          }, je);
          let qt = Bt(g);
          qt.insertBefore([...L, ...re]), se.length > 0 && qt.insertAfter(se), Pe.length > 0 && qt.find((Ie) => Ie.isStatement() || Ie.isDeclaration()).
          insertAfter(Pe), Rt != null && C && qt.insertAfter(Rt);
        },
        ExportDefaultDeclaration(g, {
          file: E
        }) {
          {
            if (E.get(_o) !== "7.24.4") return;
            let D = g.get("declaration");
            D.isClassDeclaration() && (0, fA.hasDecorators)(D.node) && (D.node.id ? (0, s6e.default)(g) : D.node.type = "ClassExpression");
          }
        }
      }
    };
  }
  i(o6e, "createClassFeaturePlugin");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/enum.js
var hA = y((yy) => {
  "use strict";
  Object.defineProperty(yy, "__esModule", {
    value: !0
  });
  yy.default = f6e;
  yy.translateEnumValues = i7;
  var nu = mr(), l6e = require("assert"), u6e = MP(), dA = /* @__PURE__ */ new WeakMap(), c6e = nu.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);
  function f6e(e, t) {
    let {
      node: r,
      parentPath: s
    } = e;
    if (r.declare) {
      e.remove();
      return;
    }
    let n = r.id.name, {
      fill: a,
      data: o,
      isPure: l
    } = m6e(e, t, r.id);
    switch (s.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program": {
        let c = t.isProgram(e.parent), f = u(s), p = t.objectExpression([]);
        (f || c) && (p = t.logicalExpression("||", t.cloneNode(a.ID), p));
        let d = c6e(Object.assign({}, a, {
          INIT: p
        }));
        l && (0, u6e.default)(d), f ? (s.isExportDeclaration() ? s : e).replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(
        r.id), d))) : e.scope.registerDeclaration(e.replaceWith(t.variableDeclaration(c ? "var" : "let", [t.variableDeclarator(r.id, d)]))[0]),
        dA.set(e.scope.getBindingIdentifier(n), o);
        break;
      }
      default:
        throw new Error(`Unexpected enum parent '${e.parent.type}`);
    }
    function u(c) {
      return c.isExportDeclaration() ? u(c.parentPath) : c.getData(n) ? !0 : (c.setData(n, !0), !1);
    }
    i(u, "seen");
  }
  i(f6e, "transpileEnum");
  var p6e = (0, nu.template)(`
  ENUM["NAME"] = VALUE;
`), d6e = (0, nu.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`), h6e = /* @__PURE__ */ i((e, t) => (e ? p6e : d6e)(t), "buildEnumMember");
  function m6e(e, t, r) {
    let {
      enumValues: s,
      data: n,
      isPure: a
    } = i7(e, t), o = s.map(([l, u]) => h6e(t.isStringLiteral(u), {
      ENUM: t.cloneNode(r),
      NAME: l,
      VALUE: u
    }));
    return {
      fill: {
        ID: t.cloneNode(r),
        ASSIGNMENTS: o
      },
      data: n,
      isPure: a
    };
  }
  i(m6e, "enumFill");
  function n7(e, t) {
    let {
      seen: r,
      path: s,
      t: n
    } = t, a = e.node.name;
    r.has(a) && !e.scope.hasOwnBinding(a) && (e.replaceWith(n.memberExpression(n.cloneNode(s.node.id), n.cloneNode(e.node))), e.skip());
  }
  i(n7, "ReferencedIdentifier");
  var y6e = {
    ReferencedIdentifier: n7
  };
  function i7(e, t) {
    var r;
    let s = e.scope.getBindingIdentifier(e.node.id.name), n = (r = dA.get(s)) != null ? r : /* @__PURE__ */ new Map(), a = -1, o, l = !0, u = e.
    get("members").map((c) => {
      let f = c.node, p = t.isIdentifier(f.id) ? f.id.name : f.id.value, d = c.get("initializer"), m = f.initializer, b;
      if (m)
        a = a7(d, n), a !== void 0 ? (n.set(p, a), l6e(typeof a == "number" || typeof a == "string"), a === 1 / 0 || Number.isNaN(a) ? b = t.
        identifier(String(a)) : a === -1 / 0 ? b = t.unaryExpression("-", t.identifier("Infinity")) : b = t.valueToNode(a)) : (l && (l = d.isPure()),
        d.isReferencedIdentifier() ? n7(d, {
          t,
          seen: n,
          path: e
        }) : d.traverse(y6e, {
          t,
          seen: n,
          path: e
        }), b = d.node, n.set(p, void 0));
      else if (typeof a == "number")
        a += 1, b = t.numericLiteral(a), n.set(p, a);
      else {
        if (typeof a == "string")
          throw e.buildCodeFrameError("Enum member must have initializer.");
        {
          let h = t.memberExpression(t.cloneNode(e.node.id), t.stringLiteral(o), !0);
          b = t.binaryExpression("+", t.numericLiteral(1), h), n.set(p, void 0);
        }
      }
      return o = p, [p, b];
    });
    return {
      isPure: l,
      data: n,
      enumValues: u
    };
  }
  i(i7, "translateEnumValues");
  function a7(e, t, r = /* @__PURE__ */ new Set()) {
    return s(e);
    function s(l) {
      let u = l.node;
      switch (u.type) {
        case "MemberExpression":
          return n(l, t, r);
        case "StringLiteral":
          return u.value;
        case "UnaryExpression":
          return a(l);
        case "BinaryExpression":
          return o(l);
        case "NumericLiteral":
          return u.value;
        case "ParenthesizedExpression":
          return s(l.get("expression"));
        case "Identifier":
          return n(l, t, r);
        case "TemplateLiteral": {
          if (u.quasis.length === 1)
            return u.quasis[0].value.cooked;
          let c = l.get("expressions"), f = u.quasis, p = "";
          for (let d = 0; d < f.length; d++)
            if (p += f[d].value.cooked, d + 1 < f.length) {
              let m = n(c[d], t, r);
              if (m === void 0) return;
              p += m;
            }
          return p;
        }
        default:
          return;
      }
    }
    function n(l, u, c) {
      if (l.isMemberExpression()) {
        let f = l.node, p = f.object, d = f.property;
        if (!nu.types.isIdentifier(p) || (f.computed ? !nu.types.isStringLiteral(d) : !nu.types.isIdentifier(d)))
          return;
        let m = l.scope.getBindingIdentifier(p.name), b = dA.get(m);
        return b ? b.get(d.computed ? d.value : d.name) : void 0;
      } else if (l.isIdentifier()) {
        let f = l.node.name;
        if (["Infinity", "NaN"].includes(f))
          return Number(f);
        let p = u?.get(f);
        return p !== void 0 ? p : c.has(l.node) ? void 0 : (c.add(l.node), p = a7(l.resolve(), u, c), u?.set(f, p), p);
      }
    }
    function a(l) {
      let u = s(l.get("argument"));
      if (u !== void 0)
        switch (l.node.operator) {
          case "+":
            return u;
          case "-":
            return -u;
          case "~":
            return ~u;
          default:
            return;
        }
    }
    function o(l) {
      let u = s(l.get("left"));
      if (u === void 0)
        return;
      let c = s(l.get("right"));
      if (c !== void 0)
        switch (l.node.operator) {
          case "|":
            return u | c;
          case "&":
            return u & c;
          case ">>":
            return u >> c;
          case ">>>":
            return u >>> c;
          case "<<":
            return u << c;
          case "^":
            return u ^ c;
          case "*":
            return u * c;
          case "/":
            return u / c;
          case "+":
            return u + c;
          case "-":
            return u - c;
          case "%":
            return u % c;
          case "**":
            return Math.pow(u, c);
          default:
            return;
        }
    }
  }
  i(a7, "computeConstantValue");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/const-enum.js
var o7 = y((mA) => {
  "use strict";
  Object.defineProperty(mA, "__esModule", {
    value: !0
  });
  mA.default = b6e;
  var g6e = hA();
  function b6e(e, t) {
    let {
      name: r
    } = e.node.id, s = e.parentPath.isExportNamedDeclaration(), n = s;
    !n && t.isProgram(e.parent) && (n = e.parent.body.some((l) => t.isExportNamedDeclaration(l) && l.exportKind !== "type" && !l.source && l.
    specifiers.some((u) => t.isExportSpecifier(u) && u.exportKind !== "type" && u.local.name === r)));
    let {
      enumValues: a
    } = (0, g6e.translateEnumValues)(e, t);
    if (n) {
      let l = t.objectExpression(a.map(([u, c]) => t.objectProperty(t.isValidIdentifier(u) ? t.identifier(u) : t.stringLiteral(u), c)));
      e.scope.hasOwnBinding(r) ? (s ? e.parentPath : e).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("\
Object"), t.identifier("assign")), [e.node.id, l]))) : (e.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(e.node.id, l)])), e.
      scope.registerDeclaration(e));
      return;
    }
    let o = new Map(a);
    e.scope.path.traverse({
      Scope(l) {
        l.scope.hasOwnBinding(r) && l.skip();
      },
      MemberExpression(l) {
        if (!t.isIdentifier(l.node.object, {
          name: r
        })) return;
        let u;
        if (l.node.computed)
          if (t.isStringLiteral(l.node.property))
            u = l.node.property.value;
          else
            return;
        else if (t.isIdentifier(l.node.property))
          u = l.node.property.name;
        else
          return;
        o.has(u) && l.replaceWith(t.cloneNode(o.get(u)));
      }
    }), e.remove();
  }
  i(b6e, "transpileConstEnum");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/global-types.js
var yA = y((iu) => {
  "use strict";
  Object.defineProperty(iu, "__esModule", {
    value: !0
  });
  iu.GLOBAL_TYPES = void 0;
  iu.isGlobalType = E6e;
  iu.registerGlobalType = v6e;
  var l7 = iu.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
  function E6e({
    scope: e
  }, t) {
    return e.hasBinding(t) ? !1 : l7.get(e).has(t) ? !0 : (console.warn(`The exported identifier "${t}" is not declared in Babel's scope tra\
cker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${t}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), !1);
  }
  i(E6e, "isGlobalType");
  function v6e(e, t) {
    l7.get(e).add(t);
  }
  i(v6e, "registerGlobalType");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/namespace.js
var c7 = y((vA) => {
  "use strict";
  Object.defineProperty(vA, "__esModule", {
    value: !0
  });
  vA.default = T6e;
  var bt = mr(), S6e = yA();
  function T6e(e, t) {
    if (e.node.declare || e.node.id.type === "StringLiteral") {
      e.remove();
      return;
    }
    if (!t)
      throw e.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimen\
tally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    let r = e.node.id.name, s = EA(e, bt.types.cloneNode(e.node, !0));
    if (s === null) {
      let n = e.findParent((a) => a.isProgram());
      (0, S6e.registerGlobalType)(n.scope, r), e.remove();
    } else e.scope.hasOwnBinding(r) ? e.replaceWith(s) : e.scope.registerDeclaration(e.replaceWithMultiple([gA(r), s])[0]);
  }
  i(T6e, "transpileNamespace");
  function gA(e) {
    return bt.types.variableDeclaration("let", [bt.types.variableDeclarator(bt.types.identifier(e))]);
  }
  i(gA, "getDeclaration");
  function bA(e, t) {
    return bt.types.memberExpression(bt.types.identifier(e), bt.types.identifier(t));
  }
  i(bA, "getMemberExpression");
  function x6e(e, t, r) {
    if (e.kind !== "const")
      throw r.file.buildCodeFrameError(e, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babelj\
s.io/docs/en/babel-plugin-transform-typescript");
    let {
      declarations: s
    } = e;
    if (s.every((o) => bt.types.isIdentifier(o.id))) {
      for (let o of s)
        o.init = bt.types.assignmentExpression("=", bA(t, o.id.name), o.init);
      return [e];
    }
    let n = bt.types.getBindingIdentifiers(e), a = [];
    for (let o in n)
      a.push(bt.types.assignmentExpression("=", bA(t, o), bt.types.cloneNode(n[o])));
    return [e, bt.types.expressionStatement(bt.types.sequenceExpression(a))];
  }
  i(x6e, "handleVariableDeclaration");
  function u7(e, t) {
    return e.hub.buildError(t, "Ambient modules cannot be nested in other modules or namespaces.", Error);
  }
  i(u7, "buildNestedAmbientModuleError");
  function EA(e, t, r) {
    let s = /* @__PURE__ */ new Set(), n = t.id;
    bt.types.assertIdentifier(n);
    let a = e.scope.generateUid(n.name), o = bt.types.isTSModuleBlock(t.body) ? t.body.body : [bt.types.exportNamedDeclaration(t.body)], l = !0;
    for (let c = 0; c < o.length; c++) {
      let f = o[c];
      switch (f.type) {
        case "TSModuleDeclaration": {
          if (!bt.types.isIdentifier(f.id))
            throw u7(e, f);
          let p = EA(e, f);
          if (p !== null) {
            l = !1;
            let d = f.id.name;
            s.has(d) ? o[c] = p : (s.add(d), o.splice(c++, 1, gA(d), p));
          }
          continue;
        }
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          l = !1, s.add(f.id.name);
          continue;
        case "VariableDeclaration": {
          l = !1;
          for (let p in bt.types.getBindingIdentifiers(f))
            s.add(p);
          continue;
        }
        default:
          l && (l = bt.types.isTypeScript(f));
          continue;
        case "ExportNamedDeclaration":
      }
      if (!("declare" in f.declaration && f.declaration.declare))
        switch (f.declaration.type) {
          case "TSEnumDeclaration":
          case "FunctionDeclaration":
          case "ClassDeclaration": {
            l = !1;
            let p = f.declaration.id.name;
            s.add(p), o.splice(c++, 1, f.declaration, bt.types.expressionStatement(bt.types.assignmentExpression("=", bA(a, p), bt.types.identifier(
            p))));
            break;
          }
          case "VariableDeclaration": {
            l = !1;
            let p = x6e(f.declaration, a, e.hub);
            o.splice(c, p.length, ...p), c += p.length - 1;
            break;
          }
          case "TSModuleDeclaration": {
            if (!bt.types.isIdentifier(f.declaration.id))
              throw u7(e, f.declaration);
            let p = EA(e, f.declaration, bt.types.identifier(a));
            if (p !== null) {
              l = !1;
              let d = f.declaration.id.name;
              s.has(d) ? o[c] = p : (s.add(d), o.splice(c++, 1, gA(d), p));
            } else
              o.splice(c, 1), c--;
          }
        }
    }
    if (l) return null;
    let u = bt.types.objectExpression([]);
    if (r) {
      let c = bt.types.memberExpression(r, n);
      u = bt.template.expression.ast`
      ${bt.types.cloneNode(c)} ||
        (${bt.types.cloneNode(c)} = ${u})
    `;
    }
    return bt.template.statement.ast`
    (function (${bt.types.identifier(a)}) {
      ${o}
    })(${n} || (${bt.types.cloneNode(n)} = ${u}));
  `;
  }
  i(EA, "handleNested");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/index.js
var d7 = y((by) => {
  "use strict";
  Object.defineProperty(by, "__esModule", {
    value: !0
  });
  by.default = void 0;
  var P6e = zl(), A6e = o9(), C6e = s7(), w6e = o7(), D6e = hA(), Fi = yA(), I6e = c7();
  function _6e(e) {
    switch (e.parent.type) {
      case "TSTypeReference":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return !0;
      case "TSQualifiedName":
        return e.parentPath.findParent((t) => t.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
      case "ExportSpecifier":
        return e.parent.exportKind === "type" || e.parentPath.parent.exportKind === "type";
      default:
        return !1;
    }
  }
  i(_6e, "isInType");
  var Qs = /* @__PURE__ */ new WeakMap(), f7 = /* @__PURE__ */ new WeakSet();
  function gy(e) {
    let t = e.getBindingIdentifiers();
    for (let r of Object.keys(t)) {
      let s = e.scope.getBinding(r);
      s && s.identifier === t[r] && s.scope.removeBinding(r);
    }
    e.opts.noScope = !0, e.remove(), e.opts.noScope = !1;
  }
  i(gy, "safeRemove");
  function p7(e, t, r, s, n = "") {
    if (t.file.get("@babel/plugin-transform-modules-*") !== "commonjs")
      throw e.buildCodeFrameError(`\`${r}\` is only supported when compiling modules to CommonJS.
Please consider using \`${s}\`${n}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
  }
  i(p7, "assertCjsTransformEnabled");
  var $at = by.default = (0, P6e.declare)((e, t) => {
    let {
      types: r,
      template: s
    } = e;
    e.assertVersion(7);
    let n = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/, {
      allowNamespaces: a = !0,
      jsxPragma: o = "React.createElement",
      jsxPragmaFrag: l = "React.Fragment",
      onlyRemoveTypeImports: u = !1,
      optimizeConstEnums: c = !1
    } = t;
    var {
      allowDeclareFields: f = !1
    } = t;
    let p = {
      field(h) {
        let {
          node: g
        } = h;
        if (!f && g.declare)
          throw h.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transfor\
m-typescript or @babel/preset-typescript is enabled.");
        if (g.declare) {
          if (g.value)
            throw h.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
          g.decorators || h.remove();
        } else if (g.definite) {
          if (g.value)
            throw h.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
          !f && !g.decorators && !r.isClassPrivateProperty(g) && h.remove();
        } else (g.abstract || !f && !g.value && !g.decorators && !r.isClassPrivateProperty(g)) && h.remove();
        g.accessibility && (g.accessibility = null), g.abstract && (g.abstract = null), g.readonly && (g.readonly = null), g.optional && (g.
        optional = null), g.typeAnnotation && (g.typeAnnotation = null), g.definite && (g.definite = null), g.declare && (g.declare = null),
        g.override && (g.override = null);
      },
      method({
        node: h
      }) {
        h.accessibility && (h.accessibility = null), h.abstract && (h.abstract = null), h.optional && (h.optional = null), h.override && (h.
        override = null);
      },
      constructor(h, g) {
        h.node.accessibility && (h.node.accessibility = null);
        let E = [], {
          scope: D
        } = h;
        for (let C of h.get("params")) {
          let N = C.node;
          if (N.type === "TSParameterProperty") {
            let I = N.parameter;
            if (f7.has(I)) continue;
            f7.add(I);
            let M;
            if (r.isIdentifier(I))
              M = I;
            else if (r.isAssignmentPattern(I) && r.isIdentifier(I.left))
              M = I.left;
            else
              throw C.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            E.push(s.statement.ast`
              this.${r.cloneNode(M)} = ${r.cloneNode(M)}
            `), C.replaceWith(C.get("parameter")), D.registerBinding("param", C);
          }
        }
        (0, C6e.injectInitialization)(g, h, E);
      }
    };
    return {
      name: "transform-typescript",
      inherits: A6e.default,
      visitor: {
        Pattern: m,
        Identifier: m,
        RestElement: m,
        Program: {
          enter(h, g) {
            let {
              file: E
            } = g, D = null, C = null, N = h.scope;
            if (Fi.GLOBAL_TYPES.has(N) || Fi.GLOBAL_TYPES.set(N, /* @__PURE__ */ new Set()), E.ast.comments)
              for (let q of E.ast.comments) {
                let V = n.exec(q.value);
                V && (V[1] ? C = V[2] : D = V[2]);
              }
            let I = D || o;
            I && ([I] = I.split("."));
            let M = C || l;
            M && ([M] = M.split("."));
            for (let q of h.get("body")) {
              if (q.isImportDeclaration()) {
                if (Qs.has(g.file.ast.program) || Qs.set(g.file.ast.program, !0), q.node.importKind === "type") {
                  for (let j of q.node.specifiers)
                    (0, Fi.registerGlobalType)(N, j.local.name);
                  q.remove();
                  continue;
                }
                let V = /* @__PURE__ */ new Set(), W = q.node.specifiers.length, Y = /* @__PURE__ */ i(() => W > 0 && W === V.size, "isAllSp\
ecifiersElided");
                for (let j of q.node.specifiers)
                  if (j.type === "ImportSpecifier" && j.importKind === "type") {
                    (0, Fi.registerGlobalType)(N, j.local.name);
                    let ie = q.scope.getBinding(j.local.name);
                    ie && V.add(ie.path);
                  }
                if (u)
                  Qs.set(h.node, !1);
                else {
                  if (q.node.specifiers.length === 0) {
                    Qs.set(h.node, !1);
                    continue;
                  }
                  for (let j of q.node.specifiers) {
                    let ie = q.scope.getBinding(j.local.name);
                    ie && !V.has(ie.path) && (b({
                      binding: ie,
                      programPath: h,
                      pragmaImportName: I,
                      pragmaFragImportName: M
                    }) ? V.add(ie.path) : Qs.set(h.node, !1));
                  }
                }
                if (Y() && !u)
                  q.remove();
                else
                  for (let j of V)
                    j.remove();
                continue;
              }
              if (q.isExportDeclaration() && (q = q.get("declaration")), q.isVariableDeclaration({
                declare: !0
              }))
                for (let V of Object.keys(q.getBindingIdentifiers()))
                  (0, Fi.registerGlobalType)(N, V);
              else (q.isTSTypeAliasDeclaration() || q.isTSDeclareFunction() && q.get("id").isIdentifier() || q.isTSInterfaceDeclaration() ||
              q.isClassDeclaration({
                declare: !0
              }) || q.isTSEnumDeclaration({
                declare: !0
              }) || q.isTSModuleDeclaration({
                declare: !0
              }) && q.get("id").isIdentifier()) && (0, Fi.registerGlobalType)(N, q.node.id.name);
            }
          },
          exit(h) {
            h.node.sourceType === "module" && Qs.get(h.node) && h.pushContainer("body", r.exportNamedDeclaration());
          }
        },
        ExportNamedDeclaration(h, g) {
          if (Qs.has(g.file.ast.program) || Qs.set(g.file.ast.program, !0), h.node.exportKind === "type") {
            h.remove();
            return;
          }
          if (h.node.source && h.node.specifiers.length > 0 && h.node.specifiers.every((E) => E.type === "ExportSpecifier" && E.exportKind ===
          "type")) {
            h.remove();
            return;
          }
          if (!h.node.source && h.node.specifiers.length > 0 && h.node.specifiers.every((E) => r.isExportSpecifier(E) && (0, Fi.isGlobalType)(
          h, E.local.name))) {
            h.remove();
            return;
          }
          if (r.isTSModuleDeclaration(h.node.declaration)) {
            let E = h.node.declaration, {
              id: D
            } = E;
            if (r.isIdentifier(D))
              if (h.scope.hasOwnBinding(D.name))
                h.replaceWith(E);
              else {
                let [C] = h.replaceWithMultiple([r.exportNamedDeclaration(r.variableDeclaration("let", [r.variableDeclarator(r.cloneNode(D))])),
                E]);
                h.scope.registerDeclaration(C);
              }
          }
          Qs.set(g.file.ast.program, !1);
        },
        ExportAllDeclaration(h) {
          h.node.exportKind === "type" && h.remove();
        },
        ExportSpecifier(h) {
          (!h.parent.source && (0, Fi.isGlobalType)(h, h.node.local.name) || h.node.exportKind === "type") && h.remove();
        },
        ExportDefaultDeclaration(h, g) {
          if (Qs.has(g.file.ast.program) || Qs.set(g.file.ast.program, !0), r.isIdentifier(h.node.declaration) && (0, Fi.isGlobalType)(h, h.
          node.declaration.name)) {
            h.remove();
            return;
          }
          Qs.set(g.file.ast.program, !1);
        },
        TSDeclareFunction(h) {
          gy(h);
        },
        TSDeclareMethod(h) {
          gy(h);
        },
        VariableDeclaration(h) {
          h.node.declare && gy(h);
        },
        VariableDeclarator({
          node: h
        }) {
          h.definite && (h.definite = null);
        },
        TSIndexSignature(h) {
          h.remove();
        },
        ClassDeclaration(h) {
          let {
            node: g
          } = h;
          g.declare && gy(h);
        },
        Class(h) {
          let {
            node: g
          } = h;
          g.typeParameters && (g.typeParameters = null), g.superTypeParameters && (g.superTypeParameters = null), g.implements && (g.implements =
          null), g.abstract && (g.abstract = null), h.get("body.body").forEach((E) => {
            E.isClassMethod() || E.isClassPrivateMethod() ? E.node.kind === "constructor" ? p.constructor(E, h) : p.method(E) : (E.isClassProperty() ||
            E.isClassPrivateProperty() || E.isClassAccessorProperty()) && p.field(E);
          });
        },
        Function(h) {
          let {
            node: g
          } = h;
          g.typeParameters && (g.typeParameters = null), g.returnType && (g.returnType = null);
          let E = g.params;
          E.length > 0 && r.isIdentifier(E[0], {
            name: "this"
          }) && E.shift();
        },
        TSModuleDeclaration(h) {
          (0, I6e.default)(h, a);
        },
        TSInterfaceDeclaration(h) {
          h.remove();
        },
        TSTypeAliasDeclaration(h) {
          h.remove();
        },
        TSEnumDeclaration(h) {
          c && h.node.const ? (0, w6e.default)(h, r) : (0, D6e.default)(h, r);
        },
        TSImportEqualsDeclaration(h, g) {
          let {
            id: E,
            moduleReference: D
          } = h.node, C, N;
          r.isTSExternalModuleReference(D) ? (p7(h, g, `import ${E.name} = require(...);`, `import ${E.name} from '...';`, " alongside Types\
cript's --allowSyntheticDefaultImports option"), C = r.callExpression(r.identifier("require"), [D.expression]), N = "const") : (C = d(D), N =
          "var"), h.replaceWith(r.variableDeclaration(N, [r.variableDeclarator(E, C)])), h.scope.registerDeclaration(h);
        },
        TSExportAssignment(h, g) {
          p7(h, g, "export = <value>;", "export default <value>;"), h.replaceWith(s.statement.ast`module.exports = ${h.node.expression}`);
        },
        TSTypeAssertion(h) {
          h.replaceWith(h.node.expression);
        },
        [`TSAsExpression${r.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`](h) {
          let {
            node: g
          } = h;
          do
            g = g.expression;
          while (r.isTSAsExpression(g) || r.isTSSatisfiesExpression != null && r.isTSSatisfiesExpression(g));
          h.replaceWith(g);
        },
        [e.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](h) {
          h.replaceWith(h.node.expression);
        },
        CallExpression(h) {
          h.node.typeParameters = null;
        },
        OptionalCallExpression(h) {
          h.node.typeParameters = null;
        },
        NewExpression(h) {
          h.node.typeParameters = null;
        },
        JSXOpeningElement(h) {
          h.node.typeParameters = null;
        },
        TaggedTemplateExpression(h) {
          h.node.typeParameters = null;
        }
      }
    };
    function d(h) {
      return r.isTSQualifiedName(h) ? r.memberExpression(d(h.left), h.right) : h;
    }
    function m({
      node: h
    }) {
      h.typeAnnotation && (h.typeAnnotation = null), r.isIdentifier(h) && h.optional && (h.optional = null);
    }
    function b({
      binding: h,
      programPath: g,
      pragmaImportName: E,
      pragmaFragImportName: D
    }) {
      for (let N of h.referencePaths)
        if (!_6e(N))
          return !1;
      if (h.identifier.name !== E && h.identifier.name !== D)
        return !0;
      let C = !1;
      return g.traverse({
        "JSXElement|JSXFragment"(N) {
          C = !0, N.stop();
        }
      }), !C;
    }
  });
});

// ../node_modules/@babel/plugin-syntax-jsx/lib/index.js
var h7 = y((Ey) => {
  "use strict";
  Object.defineProperty(Ey, "__esModule", {
    value: !0
  });
  Ey.default = void 0;
  var O6e = zl(), Wat = Ey.default = (0, O6e.declare)((e) => (e.assertVersion(7), {
    name: "syntax-jsx",
    manipulateOptions(t, r) {
      r.plugins.some((s) => (Array.isArray(s) ? s[0] : s) === "typescript") || r.plugins.push("jsx");
    }
  }));
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js
var g7 = y((SA) => {
  "use strict";
  Object.defineProperty(SA, "__esModule", {
    value: !0
  });
  SA.transformDynamicImport = k6e;
  var m7 = mr(), N6e = Jc(), y7 = /* @__PURE__ */ i((e) => m7.template.expression.ast`require(${e})`, "requireNoInterop"), R6e = /* @__PURE__ */ i(
  (e, t) => m7.types.callExpression(t.addHelper("interopRequireWildcard"), [y7(e)]), "requireInterop");
  function k6e(e, t, r) {
    let s = t ? y7 : R6e;
    e.replaceWith((0, N6e.buildDynamicImport)(e.node, !0, !1, (n) => s(n, r)));
  }
  i(k6e, "transformDynamicImport");
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js
var E7 = y((vy) => {
  "use strict";
  Object.defineProperty(vy, "__esModule", {
    value: !0
  });
  vy.lazyImportsHook = void 0;
  var b7 = mr(), F6e = Jc(), L6e = /* @__PURE__ */ i((e) => ({
    name: "@babel/plugin-transform-modules-commonjs/lazy",
    version: "7.24.1",
    getWrapperPayload(t, r) {
      if ((0, F6e.isSideEffectImport)(r) || r.reexportAll)
        return null;
      if (e === !0)
        return /\./.test(t) ? null : "lazy/function";
      if (Array.isArray(e))
        return e.indexOf(t) === -1 ? null : "lazy/function";
      if (typeof e == "function")
        return e(t) ? "lazy/function" : null;
    },
    buildRequireWrapper(t, r, s, n) {
      if (s === "lazy/function")
        return n ? b7.template.statement.ast`
        function ${t}() {
          const data = ${r};
          ${t} = function(){ return data; };
          return data;
        }
      ` : !1;
    },
    wrapReference(t, r) {
      if (r === "lazy/function") return b7.types.callExpression(t, []);
    }
  }), "lazyImportsHook");
  vy.lazyImportsHook = L6e;
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js
var v7 = y((Sy) => {
  "use strict";
  Object.defineProperty(Sy, "__esModule", {
    value: !0
  });
  Sy.defineCommonJSHook = B6e;
  Sy.makeInvokers = M6e;
  var xA = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
  function B6e(e, t) {
    let r = e.get(xA);
    r || e.set(xA, r = []), r.push(t);
  }
  i(B6e, "defineCommonJSHook");
  function TA(e, t) {
    if (e)
      for (let r of e) {
        let s = t(r);
        if (s != null) return s;
      }
  }
  i(TA, "findMap");
  function M6e(e) {
    let t = e.get(xA);
    return {
      getWrapperPayload(...r) {
        return TA(t, (s) => s.getWrapperPayload == null ? void 0 : s.getWrapperPayload(...r));
      },
      wrapReference(...r) {
        return TA(t, (s) => s.wrapReference == null ? void 0 : s.wrapReference(...r));
      },
      buildRequireWrapper(...r) {
        return TA(t, (s) => s.buildRequireWrapper == null ? void 0 : s.buildRequireWrapper(...r));
      }
    };
  }
  i(M6e, "makeInvokers");
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js
var S7 = y((Vf) => {
  "use strict";
  Object.defineProperty(Vf, "__esModule", {
    value: !0
  });
  Vf.default = void 0;
  Object.defineProperty(Vf, "defineCommonJSHook", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return PA.defineCommonJSHook;
    }, "get")
  });
  var j6e = zl(), No = Jc(), q6e = X1(), Tn = mr(), $6e = g7(), U6e = E7(), PA = v7(), Qat = Vf.default = (0, j6e.declare)((e, t) => {
    var r, s, n;
    e.assertVersion(7);
    let {
      strictNamespace: a = !1,
      mjsStrictNamespace: o = a,
      allowTopLevelThis: l,
      strict: u,
      strictMode: c,
      noInterop: f,
      importInterop: p,
      lazy: d = !1,
      allowCommonJSExports: m = !0,
      loose: b = !1
    } = t, h = (r = e.assumption("constantReexports")) != null ? r : b, g = (s = e.assumption("enumerableModuleMeta")) != null ? s : b, E = (n =
    e.assumption("noIncompleteNsImportDetection")) != null ? n : !1;
    if (typeof d != "boolean" && typeof d != "function" && (!Array.isArray(d) || !d.every((N) => typeof N == "string")))
      throw new Error(".lazy must be a boolean, array of strings, or a function");
    if (typeof a != "boolean")
      throw new Error(".strictNamespace must be a boolean, or undefined");
    if (typeof o != "boolean")
      throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    let D = /* @__PURE__ */ i((N) => Tn.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${N}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, "getAssertion"), C = {
      ReferencedIdentifier(N) {
        let I = N.node.name;
        if (I !== "module" && I !== "exports") return;
        let M = N.scope.getBinding(I);
        this.scope.getBinding(I) !== M || N.parentPath.isObjectProperty({
          value: N.node
        }) && N.parentPath.parentPath.isObjectPattern() || N.parentPath.isAssignmentExpression({
          left: N.node
        }) || N.isAssignmentExpression({
          left: N.node
        }) || N.replaceWith(D(I));
      },
      UpdateExpression(N) {
        let I = N.get("argument");
        if (!I.isIdentifier()) return;
        let M = I.node.name;
        if (M !== "module" && M !== "exports") return;
        let q = N.scope.getBinding(M);
        this.scope.getBinding(M) === q && N.replaceWith(Tn.types.assignmentExpression(N.node.operator[0] + "=", I.node, D(M)));
      },
      AssignmentExpression(N) {
        let I = N.get("left");
        if (I.isIdentifier()) {
          let M = I.node.name;
          if (M !== "module" && M !== "exports") return;
          let q = N.scope.getBinding(M);
          if (this.scope.getBinding(M) !== q) return;
          let W = N.get("right");
          W.replaceWith(Tn.types.sequenceExpression([W.node, D(M)]));
        } else if (I.isPattern()) {
          let M = I.getOuterBindingIdentifiers(), q = Object.keys(M).filter((V) => V !== "module" && V !== "exports" ? !1 : this.scope.getBinding(
          V) === N.scope.getBinding(V))[0];
          if (q) {
            let V = N.get("right");
            V.replaceWith(Tn.types.sequenceExpression([V.node, D(q)]));
          }
        }
      }
    };
    return {
      name: "transform-modules-commonjs",
      pre() {
        this.file.set("@babel/plugin-transform-modules-*", "commonjs"), d && (0, PA.defineCommonJSHook)(this.file, (0, U6e.lazyImportsHook)(
        d));
      },
      visitor: {
        ["CallExpression" + (e.types.importExpression ? "|ImportExpression" : "")](N) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import") || N.isCallExpression() && !Tn.types.isImport(N.node.callee)) return;
          let {
            scope: I
          } = N;
          do
            I.rename("require");
          while (I = I.parent);
          (0, $6e.transformDynamicImport)(N, f, this.file);
        },
        Program: {
          exit(N, I) {
            if (!(0, No.isModule)(N)) return;
            N.scope.rename("exports"), N.scope.rename("module"), N.scope.rename("require"), N.scope.rename("__filename"), N.scope.rename("__\
dirname"), m || ((0, q6e.default)(N, /* @__PURE__ */ new Set(["module", "exports"]), !1), N.traverse(C, {
              scope: N.scope
            }));
            let M = (0, No.getModuleName)(this.file.opts, t);
            M && (M = Tn.types.stringLiteral(M));
            let q = (0, PA.makeInvokers)(this.file), {
              meta: V,
              headers: W
            } = (0, No.rewriteModuleStatementsAndPrepareHeader)(N, {
              exportName: "exports",
              constantReexports: h,
              enumerableModuleMeta: g,
              strict: u,
              strictMode: c,
              allowTopLevelThis: l,
              noInterop: f,
              importInterop: p,
              wrapReference: q.wrapReference,
              getWrapperPayload: q.getWrapperPayload,
              esNamespaceOnly: typeof I.filename == "string" && /\.mjs$/.test(I.filename) ? o : a,
              noIncompleteNsImportDetection: E,
              filename: this.file.opts.filename
            });
            for (let [j, ie] of V.source) {
              let fe = Tn.types.callExpression(Tn.types.identifier("require"), [Tn.types.stringLiteral(j)]), De;
              if ((0, No.isSideEffectImport)(ie)) {
                if (d && ie.wrap === "function")
                  throw new Error("Assertion failure");
                De = Tn.types.expressionStatement(fe);
              } else {
                var Y;
                let F = (0, No.wrapInterop)(N, fe, ie.interop) || fe;
                if (ie.wrap) {
                  let L = q.buildRequireWrapper(ie.name, F, ie.wrap, ie.referenced);
                  if (L === !1) continue;
                  De = L;
                }
                (Y = De) != null || (De = Tn.template.statement.ast`
                var ${ie.name} = ${F};
              `);
              }
              De.loc = ie.loc, W.push(De), W.push(...(0, No.buildNamespaceInitStatements)(V, ie, h, q.wrapReference));
            }
            (0, No.ensureStatementsHoisted)(W), N.unshiftContainer("body", W), N.get("body").forEach((j) => {
              W.indexOf(j.node) !== -1 && j.isVariableDeclaration() && j.scope.registerDeclaration(j);
            });
          }
        }
      }
    };
  });
});

// ../node_modules/@babel/preset-typescript/lib/index.js
var A7 = y((AA) => {
  "use strict";
  Object.defineProperty(AA, "__esModule", { value: !0 });
  var x7 = zl(), V6e = d7();
  h7();
  var W6e = S7(), H6e = bm();
  function P7(e) {
    return e && e.__esModule ? e : { default: e };
  }
  i(P7, "_interopDefault");
  var T7 = /* @__PURE__ */ P7(V6e), G6e = /* @__PURE__ */ P7(W6e), Li = new H6e.OptionValidator("@babel/preset-typescript");
  function K6e(e = {}) {
    let {
      allowNamespaces: t = !0,
      jsxPragma: r,
      onlyRemoveTypeImports: s
    } = e, n = {
      ignoreExtensions: "ignoreExtensions",
      allowNamespaces: "allowNamespaces",
      disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
      jsxPragma: "jsxPragma",
      jsxPragmaFrag: "jsxPragmaFrag",
      onlyRemoveTypeImports: "onlyRemoveTypeImports",
      optimizeConstEnums: "optimizeConstEnums",
      rewriteImportExtensions: "rewriteImportExtensions",
      allExtensions: "allExtensions",
      isTSX: "isTSX"
    }, a = Li.validateStringOption(n.jsxPragmaFrag, e.jsxPragmaFrag, "React.Fragment");
    {
      var o = Li.validateBooleanOption(n.allExtensions, e.allExtensions, !1), l = Li.validateBooleanOption(n.isTSX, e.isTSX, !1);
      l && Li.invariant(o, "isTSX:true requires allExtensions:true");
    }
    let u = Li.validateBooleanOption(n.ignoreExtensions, e.ignoreExtensions, !1), c = Li.validateBooleanOption(n.disallowAmbiguousJSXLike, e.
    disallowAmbiguousJSXLike, !1);
    c && Li.invariant(o, "disallowAmbiguousJSXLike:true requires allExtensions:true");
    let f = Li.validateBooleanOption(n.optimizeConstEnums, e.optimizeConstEnums, !1), p = Li.validateBooleanOption(n.rewriteImportExtensions,
    e.rewriteImportExtensions, !1), d = {
      ignoreExtensions: u,
      allowNamespaces: t,
      disallowAmbiguousJSXLike: c,
      jsxPragma: r,
      jsxPragmaFrag: a,
      onlyRemoveTypeImports: s,
      optimizeConstEnums: f,
      rewriteImportExtensions: p
    };
    return d.allExtensions = o, d.isTSX = l, d;
  }
  i(K6e, "normalizeOptions");
  var Y6e = x7.declare(function({
    types: e
  }) {
    return {
      name: "preset-typescript/plugin-rewrite-ts-imports",
      visitor: {
        "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"({
          node: t
        }) {
          let {
            source: r
          } = t;
          (e.isImportDeclaration(t) ? t.importKind : t.exportKind) === "value" && r && /[\\/]/.test(r.value) && (r.value = r.value.replace(/(\.[mc]?)ts$/,
          "$1js").replace(/\.tsx$/, ".js"));
        }
      }
    };
  }), X6e = x7.declarePreset((e, t) => {
    e.assertVersion(7);
    let {
      allExtensions: r,
      ignoreExtensions: s,
      allowNamespaces: n,
      disallowAmbiguousJSXLike: a,
      isTSX: o,
      jsxPragma: l,
      jsxPragmaFrag: u,
      onlyRemoveTypeImports: c,
      optimizeConstEnums: f,
      rewriteImportExtensions: p
    } = K6e(t), d = /* @__PURE__ */ i((h) => ({
      allowDeclareFields: t.allowDeclareFields,
      allowNamespaces: n,
      disallowAmbiguousJSXLike: h,
      jsxPragma: l,
      jsxPragmaFrag: u,
      onlyRemoveTypeImports: c,
      optimizeConstEnums: f
    }), "pluginOptions"), m = /* @__PURE__ */ i((h, g) => [[T7.default, Object.assign({
      isTSX: h
    }, d(g))]], "getPlugins");
    return {
      plugins: p ? [Y6e] : [],
      overrides: r || s ? [{
        plugins: m(o, a)
      }] : [{
        test: /\.ts$/,
        plugins: m(!1, !1)
      }, {
        test: /\.mts$/,
        sourceType: "module",
        plugins: m(!1, !0)
      }, {
        test: /\.cts$/,
        sourceType: "unambiguous",
        plugins: [[G6e.default, {
          allowTopLevelThis: !0
        }], [T7.default, d(!0)]]
      }, {
        test: /\.tsx$/,
        plugins: m(!0, !1)
      }]
    };
  });
  AA.default = X6e;
});

// ../node_modules/@babel/core/lib/config/files/module-types.js
var NA = y((Wf) => {
  "use strict";
  Object.defineProperty(Wf, "__esModule", {
    value: !0
  });
  Wf.default = Z6e;
  Wf.supportsESM = void 0;
  var C7 = Nl();
  function IA() {
    let e = require("path");
    return IA = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(IA, "_path");
  function D7() {
    let e = require("url");
    return D7 = /* @__PURE__ */ i(function() {
      return e;
    }, "_url"), e;
  }
  i(D7, "_url");
  function _A() {
    let e = Fh();
    return _A = /* @__PURE__ */ i(function() {
      return e;
    }, "_semver"), e;
  }
  i(_A, "_semver");
  function I7() {
    let e = Qa();
    return I7 = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(I7, "_debug");
  var _7 = xi(), OA = yo(), z6e = xP();
  function w7(e, t, r, s, n, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      r(c);
      return;
    }
    l.done ? t(u) : Promise.resolve(u).then(s, n);
  }
  i(w7, "asyncGeneratorStep");
  function J6e(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(s, n) {
        var a = e.apply(t, r);
        function o(u) {
          w7(a, s, n, o, l, "next", u);
        }
        i(o, "_next");
        function l(u) {
          w7(a, s, n, o, l, "throw", u);
        }
        i(l, "_throw"), o(void 0);
      });
    };
  }
  i(J6e, "_asyncToGenerator");
  var Q6e = I7()("babel:config:loading:files:module-types");
  try {
    wA = n9();
  } catch {
  }
  var wA, sot = Wf.supportsESM = _A().satisfies(process.versions.node, "^12.17 || >=13.2");
  function* Z6e(e, t) {
    switch (IA().extname(e)) {
      case ".cjs":
        return DA(e, arguments[2]);
      case ".mjs":
        break;
      case ".cts":
        return e5e(e);
      default:
        try {
          return DA(e, arguments[2]);
        } catch (r) {
          if (r.code !== "ERR_REQUIRE_ESM") throw r;
        }
    }
    if (yield* (0, C7.isAsync)())
      return yield* (0, C7.waitFor)(t5e(e));
    throw new OA.default(t, e);
  }
  i(Z6e, "loadCodeDefault");
  function e5e(e) {
    let t = ".cts", r = !!(require.extensions[".ts"] || require.extensions[".cts"] || require.extensions[".mts"]), s;
    if (!r) {
      let n = {
        babelrc: !1,
        configFile: !1,
        sourceType: "unambiguous",
        sourceMaps: "inline",
        sourceFileName: IA().basename(e),
        presets: [[r5e(e), Object.assign({
          onlyRemoveTypeImports: !0,
          optimizeConstEnums: !0
        }, {
          allowDeclareFields: !0
        })]]
      };
      s = /* @__PURE__ */ i(function(a, o) {
        if (s && o.endsWith(t))
          try {
            return a._compile((0, z6e.transformFileSync)(o, Object.assign({}, n, {
              filename: o
            })).code, o);
          } catch (l) {
            if (!r) {
              let u = i9();
              _A().lt(u.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-t\
ypescript`.");
            }
            throw l;
          }
        return require.extensions[".js"](a, o);
      }, "handler"), require.extensions[t] = s;
    }
    try {
      return DA(e);
    } finally {
      r || (require.extensions[t] === s && delete require.extensions[t], s = void 0);
    }
  }
  i(e5e, "loadCtsDefault");
  var CA = /* @__PURE__ */ new Set();
  function DA(e) {
    if (CA.has(e))
      return Q6e("Auto-ignoring usage of config %o.", e), {};
    let t;
    try {
      CA.add(e), t = (0, _7.endHiddenCallStack)(require)(e);
    } finally {
      CA.delete(e);
    }
    {
      var r;
      return (r = t) != null && r.__esModule ? t.default || (arguments[1] ? t : void 0) : t;
    }
  }
  i(DA, "loadCjsDefault");
  var t5e = (0, _7.endHiddenCallStack)(function() {
    var e = J6e(function* (r) {
      let s = (0, D7().pathToFileURL)(r).toString();
      {
        if (!wA)
          throw new OA.default(`Internal error: Native ECMAScript modules aren't supported by this platform.
`, r);
        return (yield wA(s)).default;
      }
    });
    function t(r) {
      return e.apply(this, arguments);
    }
    return i(t, "loadMjsDefault"), t;
  }());
  function r5e(e) {
    try {
      return A7();
    } catch (t) {
      if (t.code !== "MODULE_NOT_FOUND") throw t;
      let r = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please i\
nstall it!";
      throw process.versions.pnp && (r += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new OA.default(r, e);
    }
  }
  i(r5e, "getTSPreset");
});

// ../node_modules/@babel/core/lib/config/files/configuration.js
var q7 = y((Bi) => {
  "use strict";
  Object.defineProperty(Bi, "__esModule", {
    value: !0
  });
  Bi.ROOT_CONFIG_FILENAMES = void 0;
  Bi.findConfigUpwards = y5e;
  Bi.findRelativeConfig = g5e;
  Bi.findRootConfig = b5e;
  Bi.loadConfig = E5e;
  Bi.resolveShowConfigPath = v5e;
  function N7() {
    let e = Qa();
    return N7 = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(N7, "_debug");
  function RA() {
    let e = require("fs");
    return RA = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(RA, "_fs");
  function Is() {
    let e = require("path");
    return Is = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(Is, "_path");
  function R7() {
    let e = L4();
    return R7 = /* @__PURE__ */ i(function() {
      return e;
    }, "_json"), e;
  }
  i(R7, "_json");
  function k7() {
    let e = As();
    return k7 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(k7, "_gensync");
  var F7 = mo(), s5e = LT(), L7 = PT(), n5e = NA(), i5e = _x(), xn = yo(), a5e = Gh(), o5e = xi(), kA = N7()("babel:config:loading:files:con\
figuration"), B7 = Bi.ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config\
.cts"], l5e = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], u5e = ".babelignore", c5e = (0, F7.
  makeWeakCache)(/* @__PURE__ */ i(function* (t, r) {
    return yield* [], {
      options: (0, o5e.endHiddenCallStack)(t)((0, s5e.makeConfigAPI)(r)),
      cacheNeedsConfiguration: !r.configured()
    };
  }, "runConfig"));
  function* f5e(e, t) {
    if (!RA().existsSync(e)) return null;
    let r = yield* (0, n5e.default)(e, "You appear to be using a native ECMAScript module configuration file, which is only supported when r\
unning Babel asynchronously."), s = !1;
    if (typeof r == "function" && ({
      options: r,
      cacheNeedsConfiguration: s
    } = yield* c5e(r, t)), !r || typeof r != "object" || Array.isArray(r))
      throw new xn.default("Configuration should be an exported JavaScript object.", e);
    if (typeof r.then == "function")
      throw r.catch == null || r.catch(() => {
      }), new xn.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add su\
pport for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synch\
ronously return your config.", e);
    return s && S5e(e), p5e(r, e);
  }
  i(f5e, "readConfigCode");
  var O7 = /* @__PURE__ */ new WeakMap();
  function p5e(e, t) {
    let r = O7.get(e);
    r || O7.set(e, r = /* @__PURE__ */ new Map());
    let s = r.get(t);
    return s || (s = {
      filepath: t,
      dirname: Is().dirname(t),
      options: e
    }, r.set(t, s)), s;
  }
  i(p5e, "buildConfigFileObject");
  var d5e = (0, F7.makeWeakCacheSync)((e) => {
    let t = e.options.babel;
    if (typeof t > "u") return null;
    if (typeof t != "object" || Array.isArray(t) || t === null)
      throw new xn.default(".babel property must be an object", e.filepath);
    return {
      filepath: e.filepath,
      dirname: e.dirname,
      options: t
    };
  }), h5e = (0, L7.makeStaticFileCache)((e, t) => {
    let r;
    try {
      r = R7().parse(t);
    } catch (s) {
      throw new xn.default(`Error while parsing config - ${s.message}`, e);
    }
    if (!r) throw new xn.default("No config detected", e);
    if (typeof r != "object")
      throw new xn.default(`Config returned typeof ${typeof r}`, e);
    if (Array.isArray(r))
      throw new xn.default("Expected config object but found array", e);
    return delete r.$schema, {
      filepath: e,
      dirname: Is().dirname(e),
      options: r
    };
  }), m5e = (0, L7.makeStaticFileCache)((e, t) => {
    let r = Is().dirname(e), s = t.split(`
`).map((n) => n.replace(/#(.*?)$/, "").trim()).filter((n) => !!n);
    for (let n of s)
      if (n[0] === "!")
        throw new xn.default("Negation of file paths is not supported.", e);
    return {
      filepath: e,
      dirname: Is().dirname(e),
      ignore: s.map((n) => (0, i5e.default)(n, r))
    };
  });
  function y5e(e) {
    let t = e;
    for (; ; ) {
      for (let s of B7)
        if (RA().existsSync(Is().join(t, s)))
          return t;
      let r = Is().dirname(t);
      if (t === r) break;
      t = r;
    }
    return null;
  }
  i(y5e, "findConfigUpwards");
  function* g5e(e, t, r) {
    let s = null, n = null, a = Is().dirname(e.filepath);
    for (let l of e.directories) {
      if (!s) {
        var o;
        s = yield* M7(l5e, l, t, r, ((o = e.pkg) == null ? void 0 : o.dirname) === l ? d5e(e.pkg) : null);
      }
      if (!n) {
        let u = Is().join(l, u5e);
        n = yield* m5e(u), n && kA("Found ignore %o from %o.", n.filepath, a);
      }
    }
    return {
      config: s,
      ignore: n
    };
  }
  i(g5e, "findRelativeConfig");
  function b5e(e, t, r) {
    return M7(B7, e, t, r);
  }
  i(b5e, "findRootConfig");
  function* M7(e, t, r, s, n = null) {
    let o = (yield* k7().all(e.map((l) => j7(Is().join(t, l), r, s)))).reduce((l, u) => {
      if (u && l)
        throw new xn.default(`Multiple configuration files found. Please remove one:
 - ${Is().basename(l.filepath)}
 - ${u.filepath}
from ${t}`);
      return u || l;
    }, n);
    return o && kA("Found configuration %o from %o.", o.filepath, t), o;
  }
  i(M7, "loadOneConfig");
  function* E5e(e, t, r, s) {
    let n = (((o, l) => (o = o.split("."), l = l.split("."), +o[0] > +l[0] || o[0] == l[0] && +o[1] >= +l[1]))(process.versions.node, "8.9") ?
    require.resolve : (o, {
      paths: [l]
    }, u = require("module")) => {
      let c = u._findPath(o, u._nodeModulePaths(l).concat(l));
      if (c) return c;
      throw c = new Error(`Cannot resolve module '${o}'`), c.code = "MODULE_NOT_FOUND", c;
    })(e, {
      paths: [t]
    }), a = yield* j7(n, r, s);
    if (!a)
      throw new xn.default("Config file contains no configuration data", n);
    return kA("Loaded config %o from %o.", e, t), a;
  }
  i(E5e, "loadConfig");
  function j7(e, t, r) {
    switch (Is().extname(e)) {
      case ".js":
      case ".cjs":
      case ".mjs":
      case ".cts":
        return f5e(e, {
          envName: t,
          caller: r
        });
      default:
        return h5e(e);
    }
  }
  i(j7, "readConfig");
  function* v5e(e) {
    let t = process.env.BABEL_SHOW_CONFIG_FOR;
    if (t != null) {
      let r = Is().resolve(e, t);
      if (!(yield* a5e.stat(r)).isFile())
        throw new Error(`${r}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
      return r;
    }
    return null;
  }
  i(v5e, "resolveShowConfigPath");
  function S5e(e) {
    throw new xn.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, e);
  }
  i(S5e, "throwConfigError");
});

// ../node_modules/@babel/core/lib/vendor/import-meta-resolve.js
var cq = y((Cy) => {
  "use strict";
  Object.defineProperty(Cy, "__esModule", {
    value: !0
  });
  Cy.moduleResolve = uq;
  Cy.resolve = m9e;
  function Yn() {
    let e = require("assert");
    return Yn = /* @__PURE__ */ i(function() {
      return e;
    }, "_assert"), e;
  }
  i(Yn, "_assert");
  function au() {
    let e = T5e(require("fs"), !0);
    return au = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(au, "_fs");
  function _a() {
    let e = require("process");
    return _a = /* @__PURE__ */ i(function() {
      return e;
    }, "_process"), e;
  }
  i(_a, "_process");
  function we() {
    let e = require("url");
    return we = /* @__PURE__ */ i(function() {
      return e;
    }, "_url"), e;
  }
  i(we, "_url");
  function Py() {
    let e = require("path");
    return Py = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(Py, "_path");
  function qA() {
    let e = require("module");
    return qA = /* @__PURE__ */ i(function() {
      return e;
    }, "_module"), e;
  }
  i(qA, "_module");
  function Q7() {
    let e = require("v8");
    return Q7 = /* @__PURE__ */ i(function() {
      return e;
    }, "_v"), e;
  }
  i(Q7, "_v");
  function Kf() {
    let e = require("util");
    return Kf = /* @__PURE__ */ i(function() {
      return e;
    }, "_util"), e;
  }
  i(Kf, "_util");
  function Z7(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (Z7 = /* @__PURE__ */ i(function(s) {
      return s ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  i(Z7, "_getRequireWildcardCache");
  function T5e(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = Z7(t);
    if (r && r.has(e)) return r.get(e);
    var s = { __proto__: null }, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in e) if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var o = n ? Object.getOwnPropertyDescriptor(e, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = e[a];
    }
    return s.default = e, r && r.set(e, s), s;
  }
  i(T5e, "_interopRequireWildcard");
  var x5e = {}.hasOwnProperty, P5e = /^([A-Z][a-z\d]*)+$/, A5e = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Functio\
n", "Object", "boolean", "bigint", "symbol"]), Gr = {};
  function FA(e, t = "and") {
    return e.length < 3 ? e.join(` ${t} `) : `${e.slice(0, -1).join(", ")}, ${t} ${e[e.length - 1]}`;
  }
  i(FA, "formatList");
  var eq = /* @__PURE__ */ new Map(), C5e = "__node_internal_", $7;
  Gr.ERR_INVALID_ARG_TYPE = Pn("ERR_INVALID_ARG_TYPE", (e, t, r) => {
    Yn()(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let s = "The ";
    if (e.endsWith(" argument"))
      s += `${e} `;
    else {
      let l = e.includes(".") ? "property" : "argument";
      s += `"${e}" ${l} `;
    }
    s += "must be ";
    let n = [], a = [], o = [];
    for (let l of t)
      Yn()(typeof l == "string", "All expected entries have to be of type string"), A5e.has(l) ? n.push(l.toLowerCase()) : P5e.exec(l) === null ?
      (Yn()(l !== "object", 'The value "object" should be written as "Object"'), o.push(l)) : a.push(l);
    if (a.length > 0) {
      let l = n.indexOf("object");
      l !== -1 && (n.slice(l, 1), a.push("Object"));
    }
    return n.length > 0 && (s += `${n.length > 1 ? "one of type" : "of type"} ${FA(n, "or")}`, (a.length > 0 || o.length > 0) && (s += " or ")),
    a.length > 0 && (s += `an instance of ${FA(a, "or")}`, o.length > 0 && (s += " or ")), o.length > 0 && (o.length > 1 ? s += `one of ${FA(
    o, "or")}` : (o[0].toLowerCase() !== o[0] && (s += "an "), s += `${o[0]}`)), s += `. Received ${O5e(r)}`, s;
  }, TypeError);
  Gr.ERR_INVALID_MODULE_SPECIFIER = Pn("ERR_INVALID_MODULE_SPECIFIER", (e, t, r = void 0) => `Invalid module "${e}" ${t}${r ? ` imported fro\
m ${r}` : ""}`, TypeError);
  Gr.ERR_INVALID_PACKAGE_CONFIG = Pn("ERR_INVALID_PACKAGE_CONFIG", (e, t, r) => `Invalid package config ${e}${t ? ` while importing ${t}` : ""}${r ?
  `. ${r}` : ""}`, Error);
  Gr.ERR_INVALID_PACKAGE_TARGET = Pn("ERR_INVALID_PACKAGE_TARGET", (e, t, r, s = !1, n = void 0) => {
    let a = typeof r == "string" && !s && r.length > 0 && !r.startsWith("./");
    return t === "." ? (Yn()(s === !1), `Invalid "exports" main target ${JSON.stringify(r)} defined in the package config ${e}package.json${n ?
    ` imported from ${n}` : ""}${a ? '; targets must start with "./"' : ""}`) : `Invalid "${s ? "imports" : "exports"}" target ${JSON.stringify(
    r)} defined for '${t}' in the package config ${e}package.json${n ? ` imported from ${n}` : ""}${a ? '; targets must start with "./"' : ""}`;
  }, Error);
  Gr.ERR_MODULE_NOT_FOUND = Pn("ERR_MODULE_NOT_FOUND", (e, t, r = !1) => `Cannot find ${r ? "module" : "package"} '${e}' imported from ${t}`,
  Error);
  Gr.ERR_NETWORK_IMPORT_DISALLOWED = Pn("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
  Gr.ERR_PACKAGE_IMPORT_NOT_DEFINED = Pn("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e, t, r) => `Package import specifier "${e}" is not defined${t ?
  ` in package ${t}package.json` : ""} imported from ${r}`, TypeError);
  Gr.ERR_PACKAGE_PATH_NOT_EXPORTED = Pn("ERR_PACKAGE_PATH_NOT_EXPORTED", (e, t, r = void 0) => t === "." ? `No "exports" main defined in ${e}\
package.json${r ? ` imported from ${r}` : ""}` : `Package subpath '${t}' is not defined by "exports" in ${e}package.json${r ? ` imported fro\
m ${r}` : ""}`, Error);
  Gr.ERR_UNSUPPORTED_DIR_IMPORT = Pn("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported fro\
m %s", Error);
  Gr.ERR_UNKNOWN_FILE_EXTENSION = Pn("ERR_UNKNOWN_FILE_EXTENSION", (e, t) => `Unknown file extension "${e}" for ${t}`, TypeError);
  Gr.ERR_INVALID_ARG_VALUE = Pn("ERR_INVALID_ARG_VALUE", (e, t, r = "is invalid") => {
    let s = (0, Kf().inspect)(t);
    return s.length > 128 && (s = `${s.slice(0, 128)}...`), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${s}`;
  }, TypeError);
  function Pn(e, t, r) {
    return eq.set(e, t), w5e(r, e);
  }
  i(Pn, "createError");
  function w5e(e, t) {
    return r;
    function r(...s) {
      let n = Error.stackTraceLimit;
      jA() && (Error.stackTraceLimit = 0);
      let a = new e();
      jA() && (Error.stackTraceLimit = n);
      let o = _5e(t, s, a);
      return Object.defineProperties(a, {
        message: {
          value: o,
          enumerable: !1,
          writable: !0,
          configurable: !0
        },
        toString: {
          value() {
            return `${this.name} [${t}]: ${this.message}`;
          },
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), I5e(a), a.code = t, a;
    }
  }
  i(w5e, "makeNodeErrorWithCode");
  function jA() {
    try {
      if (Q7().startupSnapshot.isBuildingSnapshot())
        return !1;
    } catch {
    }
    let e = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
    return e === void 0 ? Object.isExtensible(Error) : x5e.call(e, "writable") && e.writable !== void 0 ? e.writable : e.set !== void 0;
  }
  i(jA, "isErrorStackTraceLimitWritable");
  function D5e(e) {
    let t = C5e + e.name;
    return Object.defineProperty(e, "name", {
      value: t
    }), e;
  }
  i(D5e, "hideStackFrames");
  var I5e = D5e(function(e) {
    let t = jA();
    return t && ($7 = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(e), t && (Error.stackTraceLimit =
    $7), e;
  });
  function _5e(e, t, r) {
    let s = eq.get(e);
    if (Yn()(s !== void 0, "expected `message` to be found"), typeof s == "function")
      return Yn()(s.length <= t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${s.length}\
).`), Reflect.apply(s, r, t);
    let n = /%[dfijoOs]/g, a = 0;
    for (; n.exec(s) !== null; ) a++;
    return Yn()(a === t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${a}).`), t.length ===
    0 ? s : (t.unshift(s), Reflect.apply(Kf().format, null, t));
  }
  i(_5e, "getMessage");
  function O5e(e) {
    if (e == null)
      return String(e);
    if (typeof e == "function" && e.name)
      return `function ${e.name}`;
    if (typeof e == "object")
      return e.constructor && e.constructor.name ? `an instance of ${e.constructor.name}` : `${(0, Kf().inspect)(e, {
        depth: -1
      })}`;
    let t = (0, Kf().inspect)(e, {
      colors: !1
    });
    return t.length > 28 && (t = `${t.slice(0, 25)}...`), `type ${typeof e} (${t})`;
  }
  i(O5e, "determineSpecificType");
  var Hf = {}.hasOwnProperty, {
    ERR_INVALID_PACKAGE_CONFIG: N5e
  } = Gr, U7 = /* @__PURE__ */ new Map(), R5e = {
    read: k5e
  }, tq = R5e;
  function k5e(e, {
    base: t,
    specifier: r
  }) {
    let s = U7.get(e);
    if (s)
      return s;
    let n;
    try {
      n = au().default.readFileSync(Py().toNamespacedPath(e), "utf8");
    } catch (o) {
      let l = o;
      if (l.code !== "ENOENT")
        throw l;
    }
    let a = {
      exists: !1,
      pjsonPath: e,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    if (n !== void 0) {
      let o;
      try {
        o = JSON.parse(n);
      } catch (l) {
        let u = l, c = new N5e(e, (t ? `"${r}" from ` : "") + (0, we().fileURLToPath)(t || r), u.message);
        throw c.cause = u, c;
      }
      a.exists = !0, Hf.call(o, "name") && typeof o.name == "string" && (a.name = o.name), Hf.call(o, "main") && typeof o.main == "string" &&
      (a.main = o.main), Hf.call(o, "exports") && (a.exports = o.exports), Hf.call(o, "imports") && (a.imports = o.imports), Hf.call(o, "typ\
e") && (o.type === "commonjs" || o.type === "module") && (a.type = o.type);
    }
    return U7.set(e, a), a;
  }
  i(k5e, "read");
  function $A(e) {
    let t = new (we()).URL("package.json", e);
    for (; !t.pathname.endsWith("node_modules/package.json"); ) {
      let n = tq.read((0, we().fileURLToPath)(t), {
        specifier: e
      });
      if (n.exists)
        return n;
      let a = t;
      if (t = new (we()).URL("../package.json", t), t.pathname === a.pathname)
        break;
    }
    return {
      pjsonPath: (0, we().fileURLToPath)(t),
      exists: !1,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
  }
  i($A, "getPackageScopeConfig");
  function V7(e) {
    return $A(e).type;
  }
  i(V7, "getPackageType");
  var {
    ERR_UNKNOWN_FILE_EXTENSION: F5e
  } = Gr, L5e = {}.hasOwnProperty, B5e = {
    __proto__: null,
    ".cjs": "commonjs",
    ".js": "module",
    ".json": "json",
    ".mjs": "module"
  };
  function M5e(e) {
    return e && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e) ? "module" : e === "application/json" ? "json" : null;
  }
  i(M5e, "mimeToFormat");
  var W7 = {
    __proto__: null,
    "data:": j5e,
    "file:": $5e,
    "http:": H7,
    "https:": H7,
    "node:"() {
      return "builtin";
    }
  };
  function j5e(e) {
    let {
      1: t
    } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e.pathname) || [null, null, null];
    return M5e(t);
  }
  i(j5e, "getDataProtocolModuleFormat");
  function q5e(e) {
    let t = e.pathname, r = t.length;
    for (; r--; ) {
      let s = t.codePointAt(r);
      if (s === 47)
        return "";
      if (s === 46)
        return t.codePointAt(r - 1) === 47 ? "" : t.slice(r);
    }
    return "";
  }
  i(q5e, "extname");
  function $5e(e, t, r) {
    let s = q5e(e);
    if (s === ".js") {
      let o = V7(e);
      return o !== "none" ? o : "commonjs";
    }
    if (s === "") {
      let o = V7(e);
      return o === "none" || o === "commonjs" ? "commonjs" : "module";
    }
    let n = B5e[s];
    if (n) return n;
    if (r)
      return;
    let a = (0, we().fileURLToPath)(e);
    throw new F5e(s, a);
  }
  i($5e, "getFileProtocolModuleFormat");
  function H7() {
  }
  i(H7, "getHttpProtocolModuleFormat");
  function rq(e, t) {
    let r = e.protocol;
    return L5e.call(W7, r) && W7[r](e, t, !0) || null;
  }
  i(rq, "defaultGetFormatWithoutErrors");
  var {
    ERR_INVALID_ARG_VALUE: U5e
  } = Gr, sq = Object.freeze(["node", "import"]), V5e = new Set(sq);
  function W5e() {
    return sq;
  }
  i(W5e, "getDefaultConditions");
  function H5e() {
    return V5e;
  }
  i(H5e, "getDefaultConditionsSet");
  function G5e(e) {
    if (e !== void 0 && e !== W5e()) {
      if (!Array.isArray(e))
        throw new U5e("conditions", e, "expected an array");
      return new Set(e);
    }
    return H5e();
  }
  i(G5e, "getConditionsSet");
  var Ty = RegExp.prototype[Symbol.replace], {
    ERR_NETWORK_IMPORT_DISALLOWED: LA,
    ERR_INVALID_MODULE_SPECIFIER: Ay,
    ERR_INVALID_PACKAGE_CONFIG: nq,
    ERR_INVALID_PACKAGE_TARGET: K5e,
    ERR_MODULE_NOT_FOUND: UA,
    ERR_PACKAGE_IMPORT_NOT_DEFINED: Y5e,
    ERR_PACKAGE_PATH_NOT_EXPORTED: X5e,
    ERR_UNSUPPORTED_DIR_IMPORT: z5e
  } = Gr, iq = {}.hasOwnProperty, G7 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,
  K7 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,
  J5e = /^\.|%|\\/, xy = /\*/g, Q5e = /%2f|%5c/i, Y7 = /* @__PURE__ */ new Set(), Z5e = /[/\\]{2}/;
  function X7(e, t, r, s, n, a, o) {
    if (_a().noDeprecation)
      return;
    let l = (0, we().fileURLToPath)(s), u = Z5e.exec(o ? e : t) !== null;
    _a().emitWarning(`Use of deprecated ${u ? "double slash" : "leading or trailing slash matching"} resolving "${e}" for module request "${t}\
" ${t === r ? "" : `matched to "${r}" `}in the "${n ? "imports" : "exports"}" field module resolution of the package at ${l}${a ? ` imported\
 from ${(0, we().fileURLToPath)(a)}` : ""}.`, "DeprecationWarning", "DEP0166");
  }
  i(X7, "emitInvalidSegmentDeprecation");
  function z7(e, t, r, s) {
    if (_a().noDeprecation || rq(e, {
      parentURL: r.href
    }) !== "module") return;
    let a = (0, we().fileURLToPath)(e.href), o = (0, we().fileURLToPath)(new (we()).URL(".", t)), l = (0, we().fileURLToPath)(r);
    s ? Py().resolve(o, s) !== a && _a().emitWarning(`Package ${o} has a "main" field set to "${s}", excluding the full filename and extensi\
on to the resolved file at "${a.slice(o.length)}", imported from ${l}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : _a().emitWarning(`No \
"main" or "exports" field defined in the package.json for ${o} resolving the main entry point "${a.slice(o.length)}", imported from ${l}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
  }
  i(z7, "emitLegacyIndexDeprecation");
  function aq(e) {
    try {
      return (0, au().statSync)(e);
    } catch {
      return new (au()).Stats();
    }
  }
  i(aq, "tryStatSync");
  function BA(e) {
    let t = (0, au().statSync)(e, {
      throwIfNoEntry: !1
    }), r = t ? t.isFile() : void 0;
    return r ?? !1;
  }
  i(BA, "fileExists");
  function e9e(e, t, r) {
    let s;
    if (t.main !== void 0) {
      if (s = new (we()).URL(t.main, e), BA(s)) return s;
      let o = [`./${t.main}.js`, `./${t.main}.json`, `./${t.main}.node`, `./${t.main}/index.js`, `./${t.main}/index.json`, `./${t.main}/inde\
x.node`], l = -1;
      for (; ++l < o.length && (s = new (we()).URL(o[l], e), !BA(s)); )
        s = void 0;
      if (s)
        return z7(s, e, r, t.main), s;
    }
    let n = ["./index.js", "./index.json", "./index.node"], a = -1;
    for (; ++a < n.length && (s = new (we()).URL(n[a], e), !BA(s)); )
      s = void 0;
    if (s)
      return z7(s, e, r, t.main), s;
    throw new UA((0, we().fileURLToPath)(new (we()).URL(".", e)), (0, we().fileURLToPath)(r));
  }
  i(e9e, "legacyMainResolve");
  function t9e(e, t, r) {
    if (Q5e.exec(e.pathname) !== null)
      throw new Ay(e.pathname, 'must not include encoded "/" or "\\" characters', (0, we().fileURLToPath)(t));
    let s;
    try {
      s = (0, we().fileURLToPath)(e);
    } catch (a) {
      let o = a;
      throw Object.defineProperty(o, "input", {
        value: String(e)
      }), Object.defineProperty(o, "module", {
        value: String(t)
      }), o;
    }
    let n = aq(s.endsWith("/") ? s.slice(-1) : s);
    if (n.isDirectory()) {
      let a = new z5e(s, (0, we().fileURLToPath)(t));
      throw a.url = String(e), a;
    }
    if (!n.isFile()) {
      let a = new UA(s || e.pathname, t && (0, we().fileURLToPath)(t), !0);
      throw a.url = String(e), a;
    }
    if (!r) {
      let a = (0, au().realpathSync)(s), {
        search: o,
        hash: l
      } = e;
      e = (0, we().pathToFileURL)(a + (s.endsWith(Py().sep) ? "/" : "")), e.search = o, e.hash = l;
    }
    return e;
  }
  i(t9e, "finalizeResolution");
  function r9e(e, t, r) {
    return new Y5e(e, t && (0, we().fileURLToPath)(new (we()).URL(".", t)), (0, we().fileURLToPath)(r));
  }
  i(r9e, "importNotDefined");
  function MA(e, t, r) {
    return new X5e((0, we().fileURLToPath)(new (we()).URL(".", t)), e, r && (0, we().fileURLToPath)(r));
  }
  i(MA, "exportsNotFound");
  function s9e(e, t, r, s, n) {
    let a = `request is not a valid match in pattern "${t}" for the "${s ? "imports" : "exports"}" resolution of ${(0, we().fileURLToPath)(r)}`;
    throw new Ay(e, a, n && (0, we().fileURLToPath)(n));
  }
  i(s9e, "throwInvalidSubpath");
  function Gf(e, t, r, s, n) {
    return t = typeof t == "object" && t !== null ? JSON.stringify(t, null, "") : `${t}`, new K5e((0, we().fileURLToPath)(new (we()).URL(".",
    r)), e, t, s, n && (0, we().fileURLToPath)(n));
  }
  i(Gf, "invalidPackageTarget");
  function n9e(e, t, r, s, n, a, o, l, u) {
    if (t !== "" && !a && e[e.length - 1] !== "/") throw Gf(r, e, s, o, n);
    if (!e.startsWith("./")) {
      if (o && !e.startsWith("../") && !e.startsWith("/")) {
        let d = !1;
        try {
          new (we()).URL(e), d = !0;
        } catch {
        }
        if (!d) {
          let m = a ? Ty.call(xy, e, () => t) : e + t;
          return lq(m, s, u);
        }
      }
      throw Gf(r, e, s, o, n);
    }
    if (G7.exec(e.slice(2)) !== null)
      if (K7.exec(e.slice(2)) === null) {
        if (!l) {
          let d = a ? r.replace("*", () => t) : r + t, m = a ? Ty.call(xy, e, () => t) : e;
          X7(m, d, r, s, o, n, !0);
        }
      } else
        throw Gf(r, e, s, o, n);
    let c = new (we()).URL(e, s), f = c.pathname, p = new (we()).URL(".", s).pathname;
    if (!f.startsWith(p)) throw Gf(r, e, s, o, n);
    if (t === "") return c;
    if (G7.exec(t) !== null) {
      let d = a ? r.replace("*", () => t) : r + t;
      if (K7.exec(t) === null) {
        if (!l) {
          let m = a ? Ty.call(xy, e, () => t) : e;
          X7(m, d, r, s, o, n, !1);
        }
      } else
        s9e(d, r, s, o, n);
    }
    return a ? new (we()).URL(Ty.call(xy, c.href, () => t)) : new (we()).URL(t, c);
  }
  i(n9e, "resolvePackageTargetString");
  function i9e(e) {
    let t = Number(e);
    return `${t}` !== e ? !1 : t >= 0 && t < 4294967295;
  }
  i(i9e, "isArrayIndex");
  function ou(e, t, r, s, n, a, o, l, u) {
    if (typeof t == "string")
      return n9e(t, r, s, e, n, a, o, l, u);
    if (Array.isArray(t)) {
      let c = t;
      if (c.length === 0) return null;
      let f, p = -1;
      for (; ++p < c.length; ) {
        let d = c[p], m;
        try {
          m = ou(e, d, r, s, n, a, o, l, u);
        } catch (b) {
          let h = b;
          if (f = h, h.code === "ERR_INVALID_PACKAGE_TARGET") continue;
          throw b;
        }
        if (m !== void 0) {
          if (m === null) {
            f = null;
            continue;
          }
          return m;
        }
      }
      if (f == null)
        return null;
      throw f;
    }
    if (typeof t == "object" && t !== null) {
      let c = Object.getOwnPropertyNames(t), f = -1;
      for (; ++f < c.length; ) {
        let p = c[f];
        if (i9e(p))
          throw new nq((0, we().fileURLToPath)(e), n, '"exports" cannot contain numeric property keys.');
      }
      for (f = -1; ++f < c.length; ) {
        let p = c[f];
        if (p === "default" || u && u.has(p)) {
          let d = t[p], m = ou(e, d, r, s, n, a, o, l, u);
          if (m === void 0) continue;
          return m;
        }
      }
      return null;
    }
    if (t === null)
      return null;
    throw Gf(s, t, e, o, n);
  }
  i(ou, "resolvePackageTarget");
  function a9e(e, t, r) {
    if (typeof e == "string" || Array.isArray(e)) return !0;
    if (typeof e != "object" || e === null) return !1;
    let s = Object.getOwnPropertyNames(e), n = !1, a = 0, o = -1;
    for (; ++o < s.length; ) {
      let l = s[o], u = l === "" || l[0] !== ".";
      if (a++ === 0)
        n = u;
      else if (n !== u)
        throw new nq((0, we().fileURLToPath)(t), r, `"exports" cannot contain some keys starting with '.' and some not. The exports object m\
ust either be an object of package subpath keys or an object of main entry condition name keys only.`);
    }
    return n;
  }
  i(a9e, "isConditionalExportsMainSugar");
  function o9e(e, t, r) {
    if (_a().noDeprecation)
      return;
    let s = (0, we().fileURLToPath)(t);
    Y7.has(s + "|" + e) || (Y7.add(s + "|" + e), _a().emitWarning(`Use of deprecated trailing slash pattern mapping "${e}" in the "exports" \
field module resolution of the package at ${s}${r ? ` imported from ${(0, we().fileURLToPath)(r)}` : ""}. Mapping specifiers ending in "/" i\
s no longer supported.`, "DeprecationWarning", "DEP0155"));
  }
  i(o9e, "emitTrailingSlashPatternDeprecation");
  function J7(e, t, r, s, n) {
    let a = r.exports;
    if (a9e(a, e, s) && (a = {
      ".": a
    }), iq.call(a, t) && !t.includes("*") && !t.endsWith("/")) {
      let f = a[t], p = ou(e, f, "", t, s, !1, !1, !1, n);
      if (p == null)
        throw MA(t, e, s);
      return p;
    }
    let o = "", l = "", u = Object.getOwnPropertyNames(a), c = -1;
    for (; ++c < u.length; ) {
      let f = u[c], p = f.indexOf("*");
      if (p !== -1 && t.startsWith(f.slice(0, p))) {
        t.endsWith("/") && o9e(t, e, s);
        let d = f.slice(p + 1);
        t.length >= f.length && t.endsWith(d) && oq(o, f) === 1 && f.lastIndexOf("*") === p && (o = f, l = t.slice(p, t.length - d.length));
      }
    }
    if (o) {
      let f = a[o], p = ou(e, f, l, o, s, !0, !1, t.endsWith("/"), n);
      if (p == null)
        throw MA(t, e, s);
      return p;
    }
    throw MA(t, e, s);
  }
  i(J7, "packageExportsResolve");
  function oq(e, t) {
    let r = e.indexOf("*"), s = t.indexOf("*"), n = r === -1 ? e.length : r + 1, a = s === -1 ? t.length : s + 1;
    return n > a ? -1 : a > n || r === -1 ? 1 : s === -1 || e.length > t.length ? -1 : t.length > e.length ? 1 : 0;
  }
  i(oq, "patternKeyCompare");
  function l9e(e, t, r) {
    if (e === "#" || e.startsWith("#/") || e.endsWith("/")) {
      let a = "is not a valid internal imports specifier name";
      throw new Ay(e, a, (0, we().fileURLToPath)(t));
    }
    let s, n = $A(t);
    if (n.exists) {
      s = (0, we().pathToFileURL)(n.pjsonPath);
      let a = n.imports;
      if (a)
        if (iq.call(a, e) && !e.includes("*")) {
          let o = ou(s, a[e], "", e, t, !1, !0, !1, r);
          if (o != null)
            return o;
        } else {
          let o = "", l = "", u = Object.getOwnPropertyNames(a), c = -1;
          for (; ++c < u.length; ) {
            let f = u[c], p = f.indexOf("*");
            if (p !== -1 && e.startsWith(f.slice(0, -1))) {
              let d = f.slice(p + 1);
              e.length >= f.length && e.endsWith(d) && oq(o, f) === 1 && f.lastIndexOf("*") === p && (o = f, l = e.slice(p, e.length - d.length));
            }
          }
          if (o) {
            let f = a[o], p = ou(s, f, l, o, t, !0, !0, !1, r);
            if (p != null)
              return p;
          }
        }
    }
    throw r9e(e, s, t);
  }
  i(l9e, "packageImportsResolve");
  function u9e(e, t) {
    let r = e.indexOf("/"), s = !0, n = !1;
    e[0] === "@" && (n = !0, r === -1 || e.length === 0 ? s = !1 : r = e.indexOf("/", r + 1));
    let a = r === -1 ? e : e.slice(0, r);
    if (J5e.exec(a) !== null && (s = !1), !s)
      throw new Ay(e, "is not a valid package name", (0, we().fileURLToPath)(t));
    let o = "." + (r === -1 ? "" : e.slice(r));
    return {
      packageName: a,
      packageSubpath: o,
      isScoped: n
    };
  }
  i(u9e, "parsePackageName");
  function lq(e, t, r) {
    if (qA().builtinModules.includes(e))
      return new (we()).URL("node:" + e);
    let {
      packageName: s,
      packageSubpath: n,
      isScoped: a
    } = u9e(e, t), o = $A(t);
    if (o.exists) {
      let f = (0, we().pathToFileURL)(o.pjsonPath);
      if (o.name === s && o.exports !== void 0 && o.exports !== null)
        return J7(f, n, o, t, r);
    }
    let l = new (we()).URL("./node_modules/" + s + "/package.json", t), u = (0, we().fileURLToPath)(l), c;
    do {
      if (!aq(u.slice(0, -13)).isDirectory()) {
        c = u, l = new (we()).URL((a ? "../../../../node_modules/" : "../../../node_modules/") + s + "/package.json", l), u = (0, we().fileURLToPath)(
        l);
        continue;
      }
      let p = tq.read(u, {
        base: t,
        specifier: e
      });
      return p.exports !== void 0 && p.exports !== null ? J7(l, n, p, t, r) : n === "." ? e9e(l, p, t) : new (we()).URL(n, l);
    } while (u.length !== c.length);
    throw new UA(s, (0, we().fileURLToPath)(t), !1);
  }
  i(lq, "packageResolve");
  function c9e(e) {
    return e[0] === "." && (e.length === 1 || e[1] === "/" || e[1] === "." && (e.length === 2 || e[2] === "/"));
  }
  i(c9e, "isRelativeSpecifier");
  function VA(e) {
    return e === "" ? !1 : e[0] === "/" ? !0 : c9e(e);
  }
  i(VA, "shouldBeTreatedAsRelativeOrAbsolutePath");
  function uq(e, t, r, s) {
    let n = t.protocol, a = n === "http:" || n === "https:", o;
    if (VA(e))
      o = new (we()).URL(e, t);
    else if (!a && e[0] === "#")
      o = l9e(e, t, r);
    else
      try {
        o = new (we()).URL(e);
      } catch {
        a || (o = lq(e, t, r));
      }
    return Yn()(o !== void 0, "expected to be defined"), o.protocol !== "file:" ? o : t9e(o, t, s);
  }
  i(uq, "moduleResolve");
  function f9e(e, t, r) {
    if (r) {
      let s = r.protocol;
      if (s === "http:" || s === "https:") {
        if (VA(e)) {
          let n = t?.protocol;
          if (n && n !== "https:" && n !== "http:")
            throw new LA(e, r, "remote imports cannot import from a local location.");
          return {
            url: t?.href || ""
          };
        }
        throw qA().builtinModules.includes(e) ? new LA(e, r, "remote imports cannot import from a local location.") : new LA(e, r, "only rel\
ative and absolute specifiers are supported.");
      }
    }
  }
  i(f9e, "checkIfDisallowedImport");
  function p9e(e) {
    return !!(e && typeof e == "object" && "href" in e && typeof e.href == "string" && "protocol" in e && typeof e.protocol == "string" && e.
    href && e.protocol);
  }
  i(p9e, "isURL");
  function d9e(e) {
    if (e !== void 0 && typeof e != "string" && !p9e(e))
      throw new Gr.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], e);
  }
  i(d9e, "throwIfInvalidParentURL");
  function h9e(e, t = {}) {
    let {
      parentURL: r
    } = t;
    Yn()(r !== void 0, "expected `parentURL` to be defined"), d9e(r);
    let s;
    if (r)
      try {
        s = new (we()).URL(r);
      } catch {
      }
    let n;
    try {
      if (n = VA(e) ? new (we()).URL(e, s) : new (we()).URL(e), n.protocol === "data:")
        return {
          url: n.href,
          format: null
        };
    } catch {
    }
    let a = f9e(e, n, s);
    if (a) return a;
    if (n && n.protocol === "node:") return {
      url: e
    };
    let o = G5e(t.conditions), l = uq(e, new (we()).URL(r), o, !1);
    return {
      url: l.href,
      format: rq(l, {
        parentURL: r
      })
    };
  }
  i(h9e, "defaultResolve");
  function m9e(e, t) {
    if (!t)
      throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
    try {
      return h9e(e, {
        parentURL: t
      }).url;
    } catch (r) {
      let s = r;
      if ((s.code === "ERR_UNSUPPORTED_DIR_IMPORT" || s.code === "ERR_MODULE_NOT_FOUND") && typeof s.url == "string")
        return s.url;
      throw r;
    }
  }
  i(m9e, "resolve");
});

// ../node_modules/@babel/core/lib/config/files/plugins.js
var Eq = y((Oa) => {
  "use strict";
  Object.defineProperty(Oa, "__esModule", {
    value: !0
  });
  Oa.loadPlugin = w9e;
  Oa.loadPreset = D9e;
  Oa.resolvePreset = Oa.resolvePlugin = void 0;
  function pq() {
    let e = Qa();
    return pq = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(pq, "_debug");
  function GA() {
    let e = require("path");
    return GA = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(GA, "_path");
  var KA = Nl(), dq = NA();
  function HA() {
    let e = require("url");
    return HA = /* @__PURE__ */ i(function() {
      return e;
    }, "_url"), e;
  }
  i(HA, "_url");
  var y9e = cq();
  function hq() {
    let e = require("fs");
    return hq = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(hq, "_fs");
  var mq = pq()("babel:config:loading:files:plugins"), g9e = /^module:/, b9e = /^(?!@|module:|[^/]+\/|babel-plugin-)/, E9e = /^(?!@|module:|[^/]+\/|babel-preset-)/,
  v9e = /^(@babel\/)(?!plugin-|[^/]+\/)/, S9e = /^(@babel\/)(?!preset-|[^/]+\/)/, T9e = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,
  x9e = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, P9e = /^(@(?!babel$)[^/]+)$/, A9e = Oa.resolvePlugin = gq.bind(null,
  "plugin"), C9e = Oa.resolvePreset = gq.bind(null, "preset");
  function* w9e(e, t) {
    let r = A9e(e, t, yield* (0, KA.isAsync)()), s = yield* bq("plugin", r);
    return mq("Loaded plugin %o from %o.", e, t), {
      filepath: r,
      value: s
    };
  }
  i(w9e, "loadPlugin");
  function* D9e(e, t) {
    let r = C9e(e, t, yield* (0, KA.isAsync)()), s = yield* bq("preset", r);
    return mq("Loaded preset %o from %o.", e, t), {
      filepath: r,
      value: s
    };
  }
  i(D9e, "loadPreset");
  function WA(e, t) {
    if (GA().isAbsolute(t)) return t;
    let r = e === "preset";
    return t.replace(r ? E9e : b9e, `babel-${e}-`).replace(r ? S9e : v9e, `$1${e}-`).replace(r ? x9e : T9e, `$1babel-${e}-`).replace(P9e, `$\
1/babel-${e}`).replace(g9e, "");
  }
  i(WA, "standardizeName");
  function* yq(e, t) {
    let r = WA(e, t), {
      error: s,
      value: n
    } = yield r;
    if (!s) return n;
    if (s.code !== "MODULE_NOT_FOUND") throw s;
    r !== t && !(yield t).error && (s.message += `
- If you want to resolve "${t}", use "module:${t}"`), (yield WA(e, "@babel/" + t)).error || (s.message += `
- Did you mean "@babel/${t}"?`);
    let a = e === "preset" ? "plugin" : "preset";
    if ((yield WA(a, t)).error || (s.message += `
- Did you accidentally pass a ${a} as a ${e}?`), e === "plugin") {
      let o = r.replace("-proposal-", "-transform-");
      o !== r && !(yield o).error && (s.message += `
- Did you mean "${o}"?`);
    }
    throw s.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`, s;
  }
  i(yq, "resolveAlternativesHelper");
  function I9e(e, t) {
    try {
      return t ? {
        error: null,
        value: (((r, s) => (r = r.split("."), s = s.split("."), +r[0] > +s[0] || r[0] == s[0] && +r[1] >= +s[1]))(process.versions.node, "8.\
9") ? require.resolve : (r, {
          paths: [s]
        }, n = require("module")) => {
          let a = n._findPath(r, n._nodeModulePaths(s).concat(s));
          if (a) return a;
          throw a = new Error(`Cannot resolve module '${r}'`), a.code = "MODULE_NOT_FOUND", a;
        })(e, {
          paths: [t]
        })
      } : {
        error: null,
        value: require.resolve(e)
      };
    } catch (r) {
      return {
        error: r,
        value: null
      };
    }
  }
  i(I9e, "tryRequireResolve");
  function _9e(e, t) {
    try {
      return {
        error: null,
        value: (0, y9e.resolve)(e, t)
      };
    } catch (r) {
      return {
        error: r,
        value: null
      };
    }
  }
  i(_9e, "tryImportMetaResolve");
  function fq(e, t, r) {
    let s = yq(e, t), n = s.next();
    for (; !n.done; )
      n = s.next(I9e(n.value, r));
    return n.value;
  }
  i(fq, "resolveStandardizedNameForRequire");
  function O9e(e, t, r) {
    let s = (0, HA().pathToFileURL)(GA().join(r, "./babel-virtual-resolve-base.js")).href, n = yq(e, t), a = n.next();
    for (; !a.done; )
      a = n.next(_9e(a.value, s));
    return (0, HA().fileURLToPath)(a.value);
  }
  i(O9e, "resolveStandardizedNameForImport");
  function gq(e, t, r, s) {
    if (!dq.supportsESM || !s)
      return fq(e, t, r);
    try {
      let n = O9e(e, t, r);
      if (!(0, hq().existsSync)(n))
        throw Object.assign(new Error(`Could not resolve "${t}" in file ${r}.`), {
          type: "MODULE_NOT_FOUND"
        });
      return n;
    } catch (n) {
      try {
        return fq(e, t, r);
      } catch (a) {
        throw n.type === "MODULE_NOT_FOUND" ? n : a.type === "MODULE_NOT_FOUND" ? a : n;
      }
    }
  }
  i(gq, "resolveStandardizedName");
  wy = /* @__PURE__ */ new Set();
  var wy;
  function* bq(e, t) {
    if (!(yield* (0, KA.isAsync)()) && wy.has(t))
      throw new Error(`Reentrant ${e} detected trying to load "${t}". This module is not ignored and is trying to load itself while compilin\
g itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
    try {
      return wy.add(t), yield* (0, dq.default)(t, `You appear to be using a native ECMAScript module ${e}, which is only supported when runn\
ing Babel asynchronously.`, !0);
    } catch (r) {
      throw r.message = `[BABEL]: ${r.message} (While processing: ${t})`, r;
    } finally {
      wy.delete(t);
    }
  }
  i(bq, "requireModule");
});

// ../node_modules/@babel/core/lib/config/files/index.js
var vf = y((_s) => {
  "use strict";
  Object.defineProperty(_s, "__esModule", {
    value: !0
  });
  Object.defineProperty(_s, "ROOT_CONFIG_FILENAMES", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return lu.ROOT_CONFIG_FILENAMES;
    }, "get")
  });
  Object.defineProperty(_s, "findConfigUpwards", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return lu.findConfigUpwards;
    }, "get")
  });
  Object.defineProperty(_s, "findPackageData", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return N9e.findPackageData;
    }, "get")
  });
  Object.defineProperty(_s, "findRelativeConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return lu.findRelativeConfig;
    }, "get")
  });
  Object.defineProperty(_s, "findRootConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return lu.findRootConfig;
    }, "get")
  });
  Object.defineProperty(_s, "loadConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return lu.loadConfig;
    }, "get")
  });
  Object.defineProperty(_s, "loadPlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Dy.loadPlugin;
    }, "get")
  });
  Object.defineProperty(_s, "loadPreset", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Dy.loadPreset;
    }, "get")
  });
  Object.defineProperty(_s, "resolvePlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Dy.resolvePlugin;
    }, "get")
  });
  Object.defineProperty(_s, "resolvePreset", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Dy.resolvePreset;
    }, "get")
  });
  Object.defineProperty(_s, "resolveShowConfigPath", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return lu.resolveShowConfigPath;
    }, "get")
  });
  var N9e = A4(), lu = q7(), Dy = Eq();
});

// ../node_modules/@babel/core/lib/transform.js
var Sq = y((uu) => {
  "use strict";
  Object.defineProperty(uu, "__esModule", {
    value: !0
  });
  uu.transform = void 0;
  uu.transformAsync = L9e;
  uu.transformSync = F9e;
  function vq() {
    let e = As();
    return vq = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(vq, "_gensync");
  var R9e = Xl(), k9e = Jm(), Iy = xi(), _y = vq()(/* @__PURE__ */ i(function* (t, r) {
    let s = yield* (0, R9e.default)(r);
    return s === null ? null : yield* (0, k9e.run)(s, t);
  }, "transform")), hot = uu.transform = /* @__PURE__ */ i(function(t, r, s) {
    let n, a;
    if (typeof r == "function" ? (a = r, n = void 0) : (n = r, a = s), a === void 0)
      return (0, Iy.beginHiddenCallStack)(_y.sync)(t, n);
    (0, Iy.beginHiddenCallStack)(_y.errback)(t, n, a);
  }, "transform");
  function F9e(...e) {
    return (0, Iy.beginHiddenCallStack)(_y.sync)(...e);
  }
  i(F9e, "transformSync");
  function L9e(...e) {
    return (0, Iy.beginHiddenCallStack)(_y.async)(...e);
  }
  i(L9e, "transformAsync");
});

// ../node_modules/@babel/core/lib/transform-ast.js
var xq = y((cu) => {
  "use strict";
  Object.defineProperty(cu, "__esModule", {
    value: !0
  });
  cu.transformFromAst = void 0;
  cu.transformFromAstAsync = q9e;
  cu.transformFromAstSync = j9e;
  function Tq() {
    let e = As();
    return Tq = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(Tq, "_gensync");
  var B9e = Xl(), M9e = Jm(), Oy = xi(), Ny = Tq()(function* (e, t, r) {
    let s = yield* (0, B9e.default)(r);
    if (s === null) return null;
    if (!e) throw new Error("No AST given");
    return yield* (0, M9e.run)(s, t, e);
  }), got = cu.transformFromAst = /* @__PURE__ */ i(function(t, r, s, n) {
    let a, o;
    if (typeof s == "function" ? (o = s, a = void 0) : (a = s, o = n), o === void 0)
      return (0, Oy.beginHiddenCallStack)(Ny.sync)(t, r, a);
    (0, Oy.beginHiddenCallStack)(Ny.errback)(t, r, a, o);
  }, "transformFromAst");
  function j9e(...e) {
    return (0, Oy.beginHiddenCallStack)(Ny.sync)(...e);
  }
  i(j9e, "transformFromAstSync");
  function q9e(...e) {
    return (0, Oy.beginHiddenCallStack)(Ny.async)(...e);
  }
  i(q9e, "transformFromAstAsync");
});

// ../node_modules/@babel/core/lib/parse.js
var Aq = y((fu) => {
  "use strict";
  Object.defineProperty(fu, "__esModule", {
    value: !0
  });
  fu.parse = void 0;
  fu.parseAsync = H9e;
  fu.parseSync = W9e;
  function Pq() {
    let e = As();
    return Pq = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(Pq, "_gensync");
  var $9e = Xl(), U9e = lP(), V9e = sP(), Ry = xi(), ky = Pq()(/* @__PURE__ */ i(function* (t, r) {
    let s = yield* (0, $9e.default)(r);
    return s === null ? null : yield* (0, U9e.default)(s.passes, (0, V9e.default)(s), t);
  }, "parse")), vot = fu.parse = /* @__PURE__ */ i(function(t, r, s) {
    if (typeof r == "function" && (s = r, r = void 0), s === void 0)
      return (0, Ry.beginHiddenCallStack)(ky.sync)(t, r);
    (0, Ry.beginHiddenCallStack)(ky.errback)(t, r, s);
  }, "parse");
  function W9e(...e) {
    return (0, Ry.beginHiddenCallStack)(ky.sync)(...e);
  }
  i(W9e, "parseSync");
  function H9e(...e) {
    return (0, Ry.beginHiddenCallStack)(ky.async)(...e);
  }
  i(H9e, "parseAsync");
});

// ../node_modules/@babel/core/lib/index.js
var mr = y((rt) => {
  "use strict";
  Object.defineProperty(rt, "__esModule", {
    value: !0
  });
  rt.DEFAULT_EXTENSIONS = void 0;
  Object.defineProperty(rt, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return G9e.default;
    }, "get")
  });
  Object.defineProperty(rt, "buildExternalHelpers", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return K9e.default;
    }, "get")
  });
  Object.defineProperty(rt, "createConfigItem", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xn.createConfigItem;
    }, "get")
  });
  Object.defineProperty(rt, "createConfigItemAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xn.createConfigItemAsync;
    }, "get")
  });
  Object.defineProperty(rt, "createConfigItemSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xn.createConfigItemSync;
    }, "get")
  });
  Object.defineProperty(rt, "getEnv", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Y9e.getEnv;
    }, "get")
  });
  Object.defineProperty(rt, "loadOptions", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xn.loadOptions;
    }, "get")
  });
  Object.defineProperty(rt, "loadOptionsAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xn.loadOptionsAsync;
    }, "get")
  });
  Object.defineProperty(rt, "loadOptionsSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xn.loadOptionsSync;
    }, "get")
  });
  Object.defineProperty(rt, "loadPartialConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xn.loadPartialConfig;
    }, "get")
  });
  Object.defineProperty(rt, "loadPartialConfigAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xn.loadPartialConfigAsync;
    }, "get")
  });
  Object.defineProperty(rt, "loadPartialConfigSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Xn.loadPartialConfigSync;
    }, "get")
  });
  Object.defineProperty(rt, "parse", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return JA.parse;
    }, "get")
  });
  Object.defineProperty(rt, "parseAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return JA.parseAsync;
    }, "get")
  });
  Object.defineProperty(rt, "parseSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return JA.parseSync;
    }, "get")
  });
  Object.defineProperty(rt, "resolvePlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Cq.resolvePlugin;
    }, "get")
  });
  Object.defineProperty(rt, "resolvePreset", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Cq.resolvePreset;
    }, "get")
  });
  Object.defineProperty(rt, "template", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return _q().default;
    }, "get")
  });
  Object.defineProperty(rt, "tokTypes", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Dq().tokTypes;
    }, "get")
  });
  Object.defineProperty(rt, "transform", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return YA.transform;
    }, "get")
  });
  Object.defineProperty(rt, "transformAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return YA.transformAsync;
    }, "get")
  });
  Object.defineProperty(rt, "transformFile", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return XA.transformFile;
    }, "get")
  });
  Object.defineProperty(rt, "transformFileAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return XA.transformFileAsync;
    }, "get")
  });
  Object.defineProperty(rt, "transformFileSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return XA.transformFileSync;
    }, "get")
  });
  Object.defineProperty(rt, "transformFromAst", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return zA.transformFromAst;
    }, "get")
  });
  Object.defineProperty(rt, "transformFromAstAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return zA.transformFromAstAsync;
    }, "get")
  });
  Object.defineProperty(rt, "transformFromAstSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return zA.transformFromAstSync;
    }, "get")
  });
  Object.defineProperty(rt, "transformSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return YA.transformSync;
    }, "get")
  });
  Object.defineProperty(rt, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Iq().default;
    }, "get")
  });
  rt.version = rt.types = void 0;
  var G9e = Mh(), K9e = Qj(), Cq = vf(), Y9e = Hx();
  function wq() {
    let e = Ne();
    return wq = /* @__PURE__ */ i(function() {
      return e;
    }, "_types"), e;
  }
  i(wq, "_types");
  Object.defineProperty(rt, "types", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return wq();
    }, "get")
  });
  function Dq() {
    let e = ao();
    return Dq = /* @__PURE__ */ i(function() {
      return e;
    }, "_parser"), e;
  }
  i(Dq, "_parser");
  function Iq() {
    let e = Ms();
    return Iq = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(Iq, "_traverse");
  function _q() {
    let e = Al();
    return _q = /* @__PURE__ */ i(function() {
      return e;
    }, "_template"), e;
  }
  i(_q, "_template");
  var Xn = Xl(), YA = Sq(), XA = xP(), zA = xq(), JA = Aq(), xot = mr(), Pot = rt.version = "7.24.4", Aot = rt.DEFAULT_EXTENSIONS = Object.freeze(
  [".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
  rt.OptionManager = class {
    static {
      i(this, "OptionManager");
    }
    init(t) {
      return (0, Xn.loadOptionsSync)(t);
    }
  }, rt.Plugin = /* @__PURE__ */ i(function(t) {
    throw new Error(`The (${t}) Babel 5 plugin is being run with an unsupported Babel version.`);
  }, "Plugin");
});

// ../node_modules/@sindresorhus/merge-streams/index.js
function rC(e) {
  if (!Array.isArray(e))
    throw new TypeError(`Expected an array, got \`${typeof e}\`.`);
  for (let n of e)
    ZA(n);
  let t = e.some(({ readableObjectMode: n }) => n), r = X9e(e, t), s = new QA({
    objectMode: t,
    writableHighWaterMark: r,
    readableHighWaterMark: r
  });
  for (let n of e)
    s.add(n);
  return e.length === 0 && Mq(s), s;
}
var By, Fq, tC, X9e, QA, z9e, J9e, Q9e, ZA, Z9e, Lq, e7e, t7e, r7e, Bq, Mq, eC, jq, s7e, Ly, Rq, kq, qq = ei(() => {
  By = require("node:events"), Fq = require("node:stream"), tC = require("node:stream/promises");
  i(rC, "mergeStreams");
  X9e = /* @__PURE__ */ i((e, t) => {
    if (e.length === 0)
      return 16384;
    let r = e.filter(({ readableObjectMode: s }) => s === t).map(({ readableHighWaterMark: s }) => s);
    return Math.max(...r);
  }, "getHighWaterMark"), QA = class extends Fq.PassThrough {
    static {
      i(this, "MergedStream");
    }
    #e = /* @__PURE__ */ new Set([]);
    #r = /* @__PURE__ */ new Set([]);
    #s = /* @__PURE__ */ new Set([]);
    #t;
    add(t) {
      ZA(t), !this.#e.has(t) && (this.#e.add(t), this.#t ??= z9e(this, this.#e), Z9e({
        passThroughStream: this,
        stream: t,
        streams: this.#e,
        ended: this.#r,
        aborted: this.#s,
        onFinished: this.#t
      }), t.pipe(this, { end: !1 }));
    }
    remove(t) {
      return ZA(t), this.#e.has(t) ? (t.unpipe(this), !0) : !1;
    }
  }, z9e = /* @__PURE__ */ i(async (e, t) => {
    Ly(e, Rq);
    let r = new AbortController();
    try {
      await Promise.race([
        J9e(e, r),
        Q9e(e, t, r)
      ]);
    } finally {
      r.abort(), Ly(e, -Rq);
    }
  }, "onMergedStreamFinished"), J9e = /* @__PURE__ */ i(async (e, { signal: t }) => {
    await (0, tC.finished)(e, { signal: t, cleanup: !0 });
  }, "onMergedStreamEnd"), Q9e = /* @__PURE__ */ i(async (e, t, { signal: r }) => {
    for await (let [s] of (0, By.on)(e, "unpipe", { signal: r }))
      t.has(s) && s.emit(Bq);
  }, "onInputStreamsUnpipe"), ZA = /* @__PURE__ */ i((e) => {
    if (typeof e?.pipe != "function")
      throw new TypeError(`Expected a readable stream, got: \`${typeof e}\`.`);
  }, "validateStream"), Z9e = /* @__PURE__ */ i(async ({ passThroughStream: e, stream: t, streams: r, ended: s, aborted: n, onFinished: a }) => {
    Ly(e, kq);
    let o = new AbortController();
    try {
      await Promise.race([
        e7e(a, t),
        t7e({ passThroughStream: e, stream: t, streams: r, ended: s, aborted: n, controller: o }),
        r7e({ stream: t, streams: r, ended: s, aborted: n, controller: o })
      ]);
    } finally {
      o.abort(), Ly(e, -kq);
    }
    r.size === s.size + n.size && (s.size === 0 && n.size > 0 ? eC(e) : Mq(e));
  }, "endWhenStreamsDone"), Lq = /* @__PURE__ */ i((e) => e?.code === "ERR_STREAM_PREMATURE_CLOSE", "isAbortError"), e7e = /* @__PURE__ */ i(
  async (e, t) => {
    try {
      await e, eC(t);
    } catch (r) {
      Lq(r) ? eC(t) : jq(t, r);
    }
  }, "afterMergedStreamFinished"), t7e = /* @__PURE__ */ i(async ({ passThroughStream: e, stream: t, streams: r, ended: s, aborted: n, controller: {
  signal: a } }) => {
    try {
      await (0, tC.finished)(t, { signal: a, cleanup: !0, readable: !0, writable: !1 }), r.has(t) && s.add(t);
    } catch (o) {
      if (a.aborted || !r.has(t))
        return;
      Lq(o) ? n.add(t) : jq(e, o);
    }
  }, "onInputStreamEnd"), r7e = /* @__PURE__ */ i(async ({ stream: e, streams: t, ended: r, aborted: s, controller: { signal: n } }) => {
    await (0, By.once)(e, Bq, { signal: n }), t.delete(e), r.delete(e), s.delete(e);
  }, "onInputStreamUnpipe"), Bq = Symbol("unpipe"), Mq = /* @__PURE__ */ i((e) => {
    e.writable && e.end();
  }, "endStream"), eC = /* @__PURE__ */ i((e) => {
    (e.readable || e.writable) && e.destroy();
  }, "abortStream"), jq = /* @__PURE__ */ i((e, t) => {
    e.destroyed || (e.once("error", s7e), e.destroy(t));
  }, "errorStream"), s7e = /* @__PURE__ */ i(() => {
  }, "noop"), Ly = /* @__PURE__ */ i((e, t) => {
    let r = e.getMaxListeners();
    r !== 0 && r !== Number.POSITIVE_INFINITY && e.setMaxListeners(r + t);
  }, "updateMaxListeners"), Rq = 2, kq = 1;
});

// ../node_modules/fast-glob/out/utils/array.js
var $q = y((pu) => {
  "use strict";
  Object.defineProperty(pu, "__esModule", { value: !0 });
  pu.splitWhen = pu.flatten = void 0;
  function n7e(e) {
    return e.reduce((t, r) => [].concat(t, r), []);
  }
  i(n7e, "flatten");
  pu.flatten = n7e;
  function i7e(e, t) {
    let r = [[]], s = 0;
    for (let n of e)
      t(n) ? (s++, r[s] = []) : r[s].push(n);
    return r;
  }
  i(i7e, "splitWhen");
  pu.splitWhen = i7e;
});

// ../node_modules/fast-glob/out/utils/errno.js
var Uq = y((My) => {
  "use strict";
  Object.defineProperty(My, "__esModule", { value: !0 });
  My.isEnoentCodeError = void 0;
  function a7e(e) {
    return e.code === "ENOENT";
  }
  i(a7e, "isEnoentCodeError");
  My.isEnoentCodeError = a7e;
});

// ../node_modules/fast-glob/out/utils/fs.js
var Vq = y((jy) => {
  "use strict";
  Object.defineProperty(jy, "__esModule", { value: !0 });
  jy.createDirentFromStats = void 0;
  var sC = class {
    static {
      i(this, "DirentFromStats");
    }
    constructor(t, r) {
      this.name = t, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.
      isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink =
      r.isSymbolicLink.bind(r);
    }
  };
  function o7e(e, t) {
    return new sC(e, t);
  }
  i(o7e, "createDirentFromStats");
  jy.createDirentFromStats = o7e;
});

// ../node_modules/fast-glob/out/utils/path.js
var Kq = y((vr) => {
  "use strict";
  Object.defineProperty(vr, "__esModule", { value: !0 });
  vr.convertPosixPathToPattern = vr.convertWindowsPathToPattern = vr.convertPathToPattern = vr.escapePosixPath = vr.escapeWindowsPath = vr.escape =
  vr.removeLeadingDotSegment = vr.makeAbsolute = vr.unixify = void 0;
  var l7e = require("os"), u7e = require("path"), Wq = l7e.platform() === "win32", c7e = 2, f7e = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g,
  p7e = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, d7e = /^\\\\([.?])/, h7e = /\\(?![!()+@[\]{}])/g;
  function m7e(e) {
    return e.replace(/\\/g, "/");
  }
  i(m7e, "unixify");
  vr.unixify = m7e;
  function y7e(e, t) {
    return u7e.resolve(e, t);
  }
  i(y7e, "makeAbsolute");
  vr.makeAbsolute = y7e;
  function g7e(e) {
    if (e.charAt(0) === ".") {
      let t = e.charAt(1);
      if (t === "/" || t === "\\")
        return e.slice(c7e);
    }
    return e;
  }
  i(g7e, "removeLeadingDotSegment");
  vr.removeLeadingDotSegment = g7e;
  vr.escape = Wq ? nC : iC;
  function nC(e) {
    return e.replace(p7e, "\\$2");
  }
  i(nC, "escapeWindowsPath");
  vr.escapeWindowsPath = nC;
  function iC(e) {
    return e.replace(f7e, "\\$2");
  }
  i(iC, "escapePosixPath");
  vr.escapePosixPath = iC;
  vr.convertPathToPattern = Wq ? Hq : Gq;
  function Hq(e) {
    return nC(e).replace(d7e, "//$1").replace(h7e, "/");
  }
  i(Hq, "convertWindowsPathToPattern");
  vr.convertWindowsPathToPattern = Hq;
  function Gq(e) {
    return iC(e);
  }
  i(Gq, "convertPosixPathToPattern");
  vr.convertPosixPathToPattern = Gq;
});

// ../node_modules/is-extglob/index.js
var Xq = y((Wot, Yq) => {
  Yq.exports = /* @__PURE__ */ i(function(t) {
    if (typeof t != "string" || t === "")
      return !1;
    for (var r; r = /(\\).|([@?!+*]\(.*\))/g.exec(t); ) {
      if (r[2]) return !0;
      t = t.slice(r.index + r[0].length);
    }
    return !1;
  }, "isExtglob");
});

// ../node_modules/is-glob/index.js
var Qq = y((Got, Jq) => {
  var b7e = Xq(), zq = { "{": "}", "(": ")", "[": "]" }, E7e = /* @__PURE__ */ i(function(e) {
    if (e[0] === "!")
      return !0;
    for (var t = 0, r = -2, s = -2, n = -2, a = -2, o = -2; t < e.length; ) {
      if (e[t] === "*" || e[t + 1] === "?" && /[\].+)]/.test(e[t]) || s !== -1 && e[t] === "[" && e[t + 1] !== "]" && (s < t && (s = e.indexOf(
      "]", t)), s > t && (o === -1 || o > s || (o = e.indexOf("\\", t), o === -1 || o > s))) || n !== -1 && e[t] === "{" && e[t + 1] !== "}" &&
      (n = e.indexOf("}", t), n > t && (o = e.indexOf("\\", t), o === -1 || o > n)) || a !== -1 && e[t] === "(" && e[t + 1] === "?" && /[:!=]/.
      test(e[t + 2]) && e[t + 3] !== ")" && (a = e.indexOf(")", t), a > t && (o = e.indexOf("\\", t), o === -1 || o > a)) || r !== -1 && e[t] ===
      "(" && e[t + 1] !== "|" && (r < t && (r = e.indexOf("|", t)), r !== -1 && e[r + 1] !== ")" && (a = e.indexOf(")", r), a > r && (o = e.
      indexOf("\\", r), o === -1 || o > a))))
        return !0;
      if (e[t] === "\\") {
        var l = e[t + 1];
        t += 2;
        var u = zq[l];
        if (u) {
          var c = e.indexOf(u, t);
          c !== -1 && (t = c + 1);
        }
        if (e[t] === "!")
          return !0;
      } else
        t++;
    }
    return !1;
  }, "strictCheck"), v7e = /* @__PURE__ */ i(function(e) {
    if (e[0] === "!")
      return !0;
    for (var t = 0; t < e.length; ) {
      if (/[*?{}()[\]]/.test(e[t]))
        return !0;
      if (e[t] === "\\") {
        var r = e[t + 1];
        t += 2;
        var s = zq[r];
        if (s) {
          var n = e.indexOf(s, t);
          n !== -1 && (t = n + 1);
        }
        if (e[t] === "!")
          return !0;
      } else
        t++;
    }
    return !1;
  }, "relaxedCheck");
  Jq.exports = /* @__PURE__ */ i(function(t, r) {
    if (typeof t != "string" || t === "")
      return !1;
    if (b7e(t))
      return !0;
    var s = E7e;
    return r && r.strict === !1 && (s = v7e), s(t);
  }, "isGlob");
});

// ../node_modules/glob-parent/index.js
var e$ = y((Yot, Zq) => {
  "use strict";
  var S7e = Qq(), T7e = require("path").posix.dirname, x7e = require("os").platform() === "win32", aC = "/", P7e = /\\/g, A7e = /[\{\[].*[\}\]]$/,
  C7e = /(^|[^\\])([\{\[]|\([^\)]+$)/, w7e = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  Zq.exports = /* @__PURE__ */ i(function(t, r) {
    var s = Object.assign({ flipBackslashes: !0 }, r);
    s.flipBackslashes && x7e && t.indexOf(aC) < 0 && (t = t.replace(P7e, aC)), A7e.test(t) && (t += aC), t += "a";
    do
      t = T7e(t);
    while (S7e(t) || C7e.test(t));
    return t.replace(w7e, "$1");
  }, "globParent");
});

// ../node_modules/braces/lib/utils.js
var qy = y((en) => {
  "use strict";
  en.isInteger = (e) => typeof e == "number" ? Number.isInteger(e) : typeof e == "string" && e.trim() !== "" ? Number.isInteger(Number(e)) :
  !1;
  en.find = (e, t) => e.nodes.find((r) => r.type === t);
  en.exceedsLimit = (e, t, r = 1, s) => s === !1 || !en.isInteger(e) || !en.isInteger(t) ? !1 : (Number(t) - Number(e)) / Number(r) >= s;
  en.escapeNode = (e, t = 0, r) => {
    let s = e.nodes[t];
    s && (r && s.type === r || s.type === "open" || s.type === "close") && s.escaped !== !0 && (s.value = "\\" + s.value, s.escaped = !0);
  };
  en.encloseBrace = (e) => e.type !== "brace" || e.commas >> 0 + e.ranges >> 0 ? !1 : (e.invalid = !0, !0);
  en.isInvalidBrace = (e) => e.type !== "brace" ? !1 : e.invalid === !0 || e.dollar ? !0 : !(e.commas >> 0 + e.ranges >> 0) || e.open !== !0 ||
  e.close !== !0 ? (e.invalid = !0, !0) : !1;
  en.isOpenOrClose = (e) => e.type === "open" || e.type === "close" ? !0 : e.open === !0 || e.close === !0;
  en.reduce = (e) => e.reduce((t, r) => (r.type === "text" && t.push(r.value), r.type === "range" && (r.type = "text"), t), []);
  en.flatten = (...e) => {
    let t = [], r = /* @__PURE__ */ i((s) => {
      for (let n = 0; n < s.length; n++) {
        let a = s[n];
        Array.isArray(a) ? r(a, t) : a !== void 0 && t.push(a);
      }
      return t;
    }, "flat");
    return r(e), t;
  };
});

// ../node_modules/braces/lib/stringify.js
var $y = y((Qot, r$) => {
  "use strict";
  var t$ = qy();
  r$.exports = (e, t = {}) => {
    let r = /* @__PURE__ */ i((s, n = {}) => {
      let a = t.escapeInvalid && t$.isInvalidBrace(n), o = s.invalid === !0 && t.escapeInvalid === !0, l = "";
      if (s.value)
        return (a || o) && t$.isOpenOrClose(s) ? "\\" + s.value : s.value;
      if (s.value)
        return s.value;
      if (s.nodes)
        for (let u of s.nodes)
          l += r(u);
      return l;
    }, "stringify");
    return r(e);
  };
});

// ../node_modules/to-regex-range/node_modules/is-number/index.js
var n$ = y((elt, s$) => {
  "use strict";
  s$.exports = function(e) {
    return typeof e == "number" ? e - e === 0 : typeof e == "string" && e.trim() !== "" ? Number.isFinite ? Number.isFinite(+e) : isFinite(+e) :
    !1;
  };
});

// ../node_modules/to-regex-range/index.js
var d$ = y((tlt, p$) => {
  "use strict";
  var i$ = n$(), Ro = /* @__PURE__ */ i((e, t, r) => {
    if (i$(e) === !1)
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    if (t === void 0 || e === t)
      return String(e);
    if (i$(t) === !1)
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    let s = { relaxZeros: !0, ...r };
    typeof s.strictZeros == "boolean" && (s.relaxZeros = s.strictZeros === !1);
    let n = String(s.relaxZeros), a = String(s.shorthand), o = String(s.capture), l = String(s.wrap), u = e + ":" + t + "=" + n + a + o + l;
    if (Ro.cache.hasOwnProperty(u))
      return Ro.cache[u].result;
    let c = Math.min(e, t), f = Math.max(e, t);
    if (Math.abs(c - f) === 1) {
      let h = e + "|" + t;
      return s.capture ? `(${h})` : s.wrap === !1 ? h : `(?:${h})`;
    }
    let p = f$(e) || f$(t), d = { min: e, max: t, a: c, b: f }, m = [], b = [];
    if (p && (d.isPadded = p, d.maxLen = String(d.max).length), c < 0) {
      let h = f < 0 ? Math.abs(f) : 1;
      b = a$(h, Math.abs(c), d, s), c = d.a = 0;
    }
    return f >= 0 && (m = a$(c, f, d, s)), d.negatives = b, d.positives = m, d.result = D7e(b, m, s), s.capture === !0 ? d.result = `(${d.result}\
)` : s.wrap !== !1 && m.length + b.length > 1 && (d.result = `(?:${d.result})`), Ro.cache[u] = d, d.result;
  }, "toRegexRange");
  function D7e(e, t, r) {
    let s = oC(e, t, "-", !1, r) || [], n = oC(t, e, "", !1, r) || [], a = oC(e, t, "-?", !0, r) || [];
    return s.concat(a).concat(n).join("|");
  }
  i(D7e, "collatePatterns");
  function I7e(e, t) {
    let r = 1, s = 1, n = l$(e, r), a = /* @__PURE__ */ new Set([t]);
    for (; e <= n && n <= t; )
      a.add(n), r += 1, n = l$(e, r);
    for (n = u$(t + 1, s) - 1; e < n && n <= t; )
      a.add(n), s += 1, n = u$(t + 1, s) - 1;
    return a = [...a], a.sort(N7e), a;
  }
  i(I7e, "splitToRanges");
  function _7e(e, t, r) {
    if (e === t)
      return { pattern: e, count: [], digits: 0 };
    let s = O7e(e, t), n = s.length, a = "", o = 0;
    for (let l = 0; l < n; l++) {
      let [u, c] = s[l];
      u === c ? a += u : u !== "0" || c !== "9" ? a += R7e(u, c, r) : o++;
    }
    return o && (a += r.shorthand === !0 ? "\\d" : "[0-9]"), { pattern: a, count: [o], digits: n };
  }
  i(_7e, "rangeToPattern");
  function a$(e, t, r, s) {
    let n = I7e(e, t), a = [], o = e, l;
    for (let u = 0; u < n.length; u++) {
      let c = n[u], f = _7e(String(o), String(c), s), p = "";
      if (!r.isPadded && l && l.pattern === f.pattern) {
        l.count.length > 1 && l.count.pop(), l.count.push(f.count[0]), l.string = l.pattern + c$(l.count), o = c + 1;
        continue;
      }
      r.isPadded && (p = k7e(c, r, s)), f.string = p + f.pattern + c$(f.count), a.push(f), o = c + 1, l = f;
    }
    return a;
  }
  i(a$, "splitToPatterns");
  function oC(e, t, r, s, n) {
    let a = [];
    for (let o of e) {
      let { string: l } = o;
      !s && !o$(t, "string", l) && a.push(r + l), s && o$(t, "string", l) && a.push(r + l);
    }
    return a;
  }
  i(oC, "filterPatterns");
  function O7e(e, t) {
    let r = [];
    for (let s = 0; s < e.length; s++) r.push([e[s], t[s]]);
    return r;
  }
  i(O7e, "zip");
  function N7e(e, t) {
    return e > t ? 1 : t > e ? -1 : 0;
  }
  i(N7e, "compare");
  function o$(e, t, r) {
    return e.some((s) => s[t] === r);
  }
  i(o$, "contains");
  function l$(e, t) {
    return Number(String(e).slice(0, -t) + "9".repeat(t));
  }
  i(l$, "countNines");
  function u$(e, t) {
    return e - e % Math.pow(10, t);
  }
  i(u$, "countZeros");
  function c$(e) {
    let [t = 0, r = ""] = e;
    return r || t > 1 ? `{${t + (r ? "," + r : "")}}` : "";
  }
  i(c$, "toQuantifier");
  function R7e(e, t, r) {
    return `[${e}${t - e === 1 ? "" : "-"}${t}]`;
  }
  i(R7e, "toCharacterClass");
  function f$(e) {
    return /^-?(0+)\d/.test(e);
  }
  i(f$, "hasPadding");
  function k7e(e, t, r) {
    if (!t.isPadded)
      return e;
    let s = Math.abs(t.maxLen - String(e).length), n = r.relaxZeros !== !1;
    switch (s) {
      case 0:
        return "";
      case 1:
        return n ? "0?" : "0";
      case 2:
        return n ? "0{0,2}" : "00";
      default:
        return n ? `0{0,${s}}` : `0{${s}}`;
    }
  }
  i(k7e, "padZeros");
  Ro.cache = {};
  Ro.clearCache = () => Ro.cache = {};
  p$.exports = Ro;
});

// ../node_modules/fill-range/index.js
var cC = y((slt, S$) => {
  "use strict";
  var F7e = require("util"), y$ = d$(), h$ = /* @__PURE__ */ i((e) => e !== null && typeof e == "object" && !Array.isArray(e), "isObject"), L7e = /* @__PURE__ */ i(
  (e) => (t) => e === !0 ? Number(t) : String(t), "transform"), lC = /* @__PURE__ */ i((e) => typeof e == "number" || typeof e == "string" &&
  e !== "", "isValidValue"), Yf = /* @__PURE__ */ i((e) => Number.isInteger(+e), "isNumber"), uC = /* @__PURE__ */ i((e) => {
    let t = `${e}`, r = -1;
    if (t[0] === "-" && (t = t.slice(1)), t === "0") return !1;
    for (; t[++r] === "0"; ) ;
    return r > 0;
  }, "zeros"), B7e = /* @__PURE__ */ i((e, t, r) => typeof e == "string" || typeof t == "string" ? !0 : r.stringify === !0, "stringify"), M7e = /* @__PURE__ */ i(
  (e, t, r) => {
    if (t > 0) {
      let s = e[0] === "-" ? "-" : "";
      s && (e = e.slice(1)), e = s + e.padStart(s ? t - 1 : t, "0");
    }
    return r === !1 ? String(e) : e;
  }, "pad"), m$ = /* @__PURE__ */ i((e, t) => {
    let r = e[0] === "-" ? "-" : "";
    for (r && (e = e.slice(1), t--); e.length < t; ) e = "0" + e;
    return r ? "-" + e : e;
  }, "toMaxLen"), j7e = /* @__PURE__ */ i((e, t) => {
    e.negatives.sort((o, l) => o < l ? -1 : o > l ? 1 : 0), e.positives.sort((o, l) => o < l ? -1 : o > l ? 1 : 0);
    let r = t.capture ? "" : "?:", s = "", n = "", a;
    return e.positives.length && (s = e.positives.join("|")), e.negatives.length && (n = `-(${r}${e.negatives.join("|")})`), s && n ? a = `${s}\
|${n}` : a = s || n, t.wrap ? `(${r}${a})` : a;
  }, "toSequence"), g$ = /* @__PURE__ */ i((e, t, r, s) => {
    if (r)
      return y$(e, t, { wrap: !1, ...s });
    let n = String.fromCharCode(e);
    if (e === t) return n;
    let a = String.fromCharCode(t);
    return `[${n}-${a}]`;
  }, "toRange"), b$ = /* @__PURE__ */ i((e, t, r) => {
    if (Array.isArray(e)) {
      let s = r.wrap === !0, n = r.capture ? "" : "?:";
      return s ? `(${n}${e.join("|")})` : e.join("|");
    }
    return y$(e, t, r);
  }, "toRegex"), E$ = /* @__PURE__ */ i((...e) => new RangeError("Invalid range arguments: " + F7e.inspect(...e)), "rangeError"), v$ = /* @__PURE__ */ i(
  (e, t, r) => {
    if (r.strictRanges === !0) throw E$([e, t]);
    return [];
  }, "invalidRange"), q7e = /* @__PURE__ */ i((e, t) => {
    if (t.strictRanges === !0)
      throw new TypeError(`Expected step "${e}" to be a number`);
    return [];
  }, "invalidStep"), $7e = /* @__PURE__ */ i((e, t, r = 1, s = {}) => {
    let n = Number(e), a = Number(t);
    if (!Number.isInteger(n) || !Number.isInteger(a)) {
      if (s.strictRanges === !0) throw E$([e, t]);
      return [];
    }
    n === 0 && (n = 0), a === 0 && (a = 0);
    let o = n > a, l = String(e), u = String(t), c = String(r);
    r = Math.max(Math.abs(r), 1);
    let f = uC(l) || uC(u) || uC(c), p = f ? Math.max(l.length, u.length, c.length) : 0, d = f === !1 && B7e(e, t, s) === !1, m = s.transform ||
    L7e(d);
    if (s.toRegex && r === 1)
      return g$(m$(e, p), m$(t, p), !0, s);
    let b = { negatives: [], positives: [] }, h = /* @__PURE__ */ i((D) => b[D < 0 ? "negatives" : "positives"].push(Math.abs(D)), "push"), g = [],
    E = 0;
    for (; o ? n >= a : n <= a; )
      s.toRegex === !0 && r > 1 ? h(n) : g.push(M7e(m(n, E), p, d)), n = o ? n - r : n + r, E++;
    return s.toRegex === !0 ? r > 1 ? j7e(b, s) : b$(g, null, { wrap: !1, ...s }) : g;
  }, "fillNumbers"), U7e = /* @__PURE__ */ i((e, t, r = 1, s = {}) => {
    if (!Yf(e) && e.length > 1 || !Yf(t) && t.length > 1)
      return v$(e, t, s);
    let n = s.transform || ((d) => String.fromCharCode(d)), a = `${e}`.charCodeAt(0), o = `${t}`.charCodeAt(0), l = a > o, u = Math.min(a, o),
    c = Math.max(a, o);
    if (s.toRegex && r === 1)
      return g$(u, c, !1, s);
    let f = [], p = 0;
    for (; l ? a >= o : a <= o; )
      f.push(n(a, p)), a = l ? a - r : a + r, p++;
    return s.toRegex === !0 ? b$(f, null, { wrap: !1, options: s }) : f;
  }, "fillLetters"), Uy = /* @__PURE__ */ i((e, t, r, s = {}) => {
    if (t == null && lC(e))
      return [e];
    if (!lC(e) || !lC(t))
      return v$(e, t, s);
    if (typeof r == "function")
      return Uy(e, t, 1, { transform: r });
    if (h$(r))
      return Uy(e, t, 0, r);
    let n = { ...s };
    return n.capture === !0 && (n.wrap = !0), r = r || n.step || 1, Yf(r) ? Yf(e) && Yf(t) ? $7e(e, t, r, n) : U7e(e, t, Math.max(Math.abs(r),
    1), n) : r != null && !h$(r) ? q7e(r, n) : Uy(e, t, 1, r);
  }, "fill");
  S$.exports = Uy;
});

// ../node_modules/braces/lib/compile.js
var P$ = y((ilt, x$) => {
  "use strict";
  var V7e = cC(), T$ = qy(), W7e = /* @__PURE__ */ i((e, t = {}) => {
    let r = /* @__PURE__ */ i((s, n = {}) => {
      let a = T$.isInvalidBrace(n), o = s.invalid === !0 && t.escapeInvalid === !0, l = a === !0 || o === !0, u = t.escapeInvalid === !0 ? "\
\\" : "", c = "";
      if (s.isOpen === !0 || s.isClose === !0)
        return u + s.value;
      if (s.type === "open")
        return l ? u + s.value : "(";
      if (s.type === "close")
        return l ? u + s.value : ")";
      if (s.type === "comma")
        return s.prev.type === "comma" ? "" : l ? s.value : "|";
      if (s.value)
        return s.value;
      if (s.nodes && s.ranges > 0) {
        let f = T$.reduce(s.nodes), p = V7e(...f, { ...t, wrap: !1, toRegex: !0 });
        if (p.length !== 0)
          return f.length > 1 && p.length > 1 ? `(${p})` : p;
      }
      if (s.nodes)
        for (let f of s.nodes)
          c += r(f, s);
      return c;
    }, "walk");
    return r(e);
  }, "compile");
  x$.exports = W7e;
});

// ../node_modules/braces/lib/expand.js
var w$ = y((olt, C$) => {
  "use strict";
  var H7e = cC(), A$ = $y(), du = qy(), ko = /* @__PURE__ */ i((e = "", t = "", r = !1) => {
    let s = [];
    if (e = [].concat(e), t = [].concat(t), !t.length) return e;
    if (!e.length)
      return r ? du.flatten(t).map((n) => `{${n}}`) : t;
    for (let n of e)
      if (Array.isArray(n))
        for (let a of n)
          s.push(ko(a, t, r));
      else
        for (let a of t)
          r === !0 && typeof a == "string" && (a = `{${a}}`), s.push(Array.isArray(a) ? ko(n, a, r) : n + a);
    return du.flatten(s);
  }, "append"), G7e = /* @__PURE__ */ i((e, t = {}) => {
    let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit, s = /* @__PURE__ */ i((n, a = {}) => {
      n.queue = [];
      let o = a, l = a.queue;
      for (; o.type !== "brace" && o.type !== "root" && o.parent; )
        o = o.parent, l = o.queue;
      if (n.invalid || n.dollar) {
        l.push(ko(l.pop(), A$(n, t)));
        return;
      }
      if (n.type === "brace" && n.invalid !== !0 && n.nodes.length === 2) {
        l.push(ko(l.pop(), ["{}"]));
        return;
      }
      if (n.nodes && n.ranges > 0) {
        let p = du.reduce(n.nodes);
        if (du.exceedsLimit(...p, t.step, r))
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        let d = H7e(...p, t);
        d.length === 0 && (d = A$(n, t)), l.push(ko(l.pop(), d)), n.nodes = [];
        return;
      }
      let u = du.encloseBrace(n), c = n.queue, f = n;
      for (; f.type !== "brace" && f.type !== "root" && f.parent; )
        f = f.parent, c = f.queue;
      for (let p = 0; p < n.nodes.length; p++) {
        let d = n.nodes[p];
        if (d.type === "comma" && n.type === "brace") {
          p === 1 && c.push(""), c.push("");
          continue;
        }
        if (d.type === "close") {
          l.push(ko(l.pop(), c, u));
          continue;
        }
        if (d.value && d.type !== "open") {
          c.push(ko(c.pop(), d.value));
          continue;
        }
        d.nodes && s(d, n);
      }
      return c;
    }, "walk");
    return du.flatten(s(e));
  }, "expand");
  C$.exports = G7e;
});

// ../node_modules/braces/lib/constants.js
var I$ = y((ult, D$) => {
  "use strict";
  D$.exports = {
    MAX_LENGTH: 1024 * 64,
    // Digits
    CHAR_0: "0",
    /* 0 */
    CHAR_9: "9",
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: "A",
    /* A */
    CHAR_LOWERCASE_A: "a",
    /* a */
    CHAR_UPPERCASE_Z: "Z",
    /* Z */
    CHAR_LOWERCASE_Z: "z",
    /* z */
    CHAR_LEFT_PARENTHESES: "(",
    /* ( */
    CHAR_RIGHT_PARENTHESES: ")",
    /* ) */
    CHAR_ASTERISK: "*",
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: "&",
    /* & */
    CHAR_AT: "@",
    /* @ */
    CHAR_BACKSLASH: "\\",
    /* \ */
    CHAR_BACKTICK: "`",
    /* ` */
    CHAR_CARRIAGE_RETURN: "\r",
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: "^",
    /* ^ */
    CHAR_COLON: ":",
    /* : */
    CHAR_COMMA: ",",
    /* , */
    CHAR_DOLLAR: "$",
    /* . */
    CHAR_DOT: ".",
    /* . */
    CHAR_DOUBLE_QUOTE: '"',
    /* " */
    CHAR_EQUAL: "=",
    /* = */
    CHAR_EXCLAMATION_MARK: "!",
    /* ! */
    CHAR_FORM_FEED: "\f",
    /* \f */
    CHAR_FORWARD_SLASH: "/",
    /* / */
    CHAR_HASH: "#",
    /* # */
    CHAR_HYPHEN_MINUS: "-",
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: "<",
    /* < */
    CHAR_LEFT_CURLY_BRACE: "{",
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: "[",
    /* [ */
    CHAR_LINE_FEED: `
`,
    /* \n */
    CHAR_NO_BREAK_SPACE: "\xA0",
    /* \u00A0 */
    CHAR_PERCENT: "%",
    /* % */
    CHAR_PLUS: "+",
    /* + */
    CHAR_QUESTION_MARK: "?",
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    /* > */
    CHAR_RIGHT_CURLY_BRACE: "}",
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    /* ] */
    CHAR_SEMICOLON: ";",
    /* ; */
    CHAR_SINGLE_QUOTE: "'",
    /* ' */
    CHAR_SPACE: " ",
    /*   */
    CHAR_TAB: "	",
    /* \t */
    CHAR_UNDERSCORE: "_",
    /* _ */
    CHAR_VERTICAL_LINE: "|",
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    /* \uFEFF */
  };
});

// ../node_modules/braces/lib/parse.js
var k$ = y((clt, R$) => {
  "use strict";
  var K7e = $y(), {
    MAX_LENGTH: _$,
    CHAR_BACKSLASH: fC,
    /* \ */
    CHAR_BACKTICK: Y7e,
    /* ` */
    CHAR_COMMA: X7e,
    /* , */
    CHAR_DOT: z7e,
    /* . */
    CHAR_LEFT_PARENTHESES: J7e,
    /* ( */
    CHAR_RIGHT_PARENTHESES: Q7e,
    /* ) */
    CHAR_LEFT_CURLY_BRACE: Z7e,
    /* { */
    CHAR_RIGHT_CURLY_BRACE: eqe,
    /* } */
    CHAR_LEFT_SQUARE_BRACKET: O$,
    /* [ */
    CHAR_RIGHT_SQUARE_BRACKET: N$,
    /* ] */
    CHAR_DOUBLE_QUOTE: tqe,
    /* " */
    CHAR_SINGLE_QUOTE: rqe,
    /* ' */
    CHAR_NO_BREAK_SPACE: sqe,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: nqe
  } = I$(), iqe = /* @__PURE__ */ i((e, t = {}) => {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    let r = t || {}, s = typeof r.maxLength == "number" ? Math.min(_$, r.maxLength) : _$;
    if (e.length > s)
      throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${s})`);
    let n = { type: "root", input: e, nodes: [] }, a = [n], o = n, l = n, u = 0, c = e.length, f = 0, p = 0, d, m = {}, b = /* @__PURE__ */ i(
    () => e[f++], "advance"), h = /* @__PURE__ */ i((g) => {
      if (g.type === "text" && l.type === "dot" && (l.type = "text"), l && l.type === "text" && g.type === "text") {
        l.value += g.value;
        return;
      }
      return o.nodes.push(g), g.parent = o, g.prev = l, l = g, g;
    }, "push");
    for (h({ type: "bos" }); f < c; )
      if (o = a[a.length - 1], d = b(), !(d === nqe || d === sqe)) {
        if (d === fC) {
          h({ type: "text", value: (t.keepEscaping ? d : "") + b() });
          continue;
        }
        if (d === N$) {
          h({ type: "text", value: "\\" + d });
          continue;
        }
        if (d === O$) {
          u++;
          let g = !0, E;
          for (; f < c && (E = b()); ) {
            if (d += E, E === O$) {
              u++;
              continue;
            }
            if (E === fC) {
              d += b();
              continue;
            }
            if (E === N$ && (u--, u === 0))
              break;
          }
          h({ type: "text", value: d });
          continue;
        }
        if (d === J7e) {
          o = h({ type: "paren", nodes: [] }), a.push(o), h({ type: "text", value: d });
          continue;
        }
        if (d === Q7e) {
          if (o.type !== "paren") {
            h({ type: "text", value: d });
            continue;
          }
          o = a.pop(), h({ type: "text", value: d }), o = a[a.length - 1];
          continue;
        }
        if (d === tqe || d === rqe || d === Y7e) {
          let g = d, E;
          for (t.keepQuotes !== !0 && (d = ""); f < c && (E = b()); ) {
            if (E === fC) {
              d += E + b();
              continue;
            }
            if (E === g) {
              t.keepQuotes === !0 && (d += E);
              break;
            }
            d += E;
          }
          h({ type: "text", value: d });
          continue;
        }
        if (d === Z7e) {
          p++;
          let E = {
            type: "brace",
            open: !0,
            close: !1,
            dollar: l.value && l.value.slice(-1) === "$" || o.dollar === !0,
            depth: p,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          o = h(E), a.push(o), h({ type: "open", value: d });
          continue;
        }
        if (d === eqe) {
          if (o.type !== "brace") {
            h({ type: "text", value: d });
            continue;
          }
          let g = "close";
          o = a.pop(), o.close = !0, h({ type: g, value: d }), p--, o = a[a.length - 1];
          continue;
        }
        if (d === X7e && p > 0) {
          if (o.ranges > 0) {
            o.ranges = 0;
            let g = o.nodes.shift();
            o.nodes = [g, { type: "text", value: K7e(o) }];
          }
          h({ type: "comma", value: d }), o.commas++;
          continue;
        }
        if (d === z7e && p > 0 && o.commas === 0) {
          let g = o.nodes;
          if (p === 0 || g.length === 0) {
            h({ type: "text", value: d });
            continue;
          }
          if (l.type === "dot") {
            if (o.range = [], l.value += d, l.type = "range", o.nodes.length !== 3 && o.nodes.length !== 5) {
              o.invalid = !0, o.ranges = 0, l.type = "text";
              continue;
            }
            o.ranges++, o.args = [];
            continue;
          }
          if (l.type === "range") {
            g.pop();
            let E = g[g.length - 1];
            E.value += l.value + d, l = E, o.ranges--;
            continue;
          }
          h({ type: "dot", value: d });
          continue;
        }
        h({ type: "text", value: d });
      }
    do
      if (o = a.pop(), o.type !== "root") {
        o.nodes.forEach((D) => {
          D.nodes || (D.type === "open" && (D.isOpen = !0), D.type === "close" && (D.isClose = !0), D.nodes || (D.type = "text"), D.invalid =
          !0);
        });
        let g = a[a.length - 1], E = g.nodes.indexOf(o);
        g.nodes.splice(E, 1, ...o.nodes);
      }
    while (a.length > 0);
    return h({ type: "eos" }), n;
  }, "parse");
  R$.exports = iqe;
});

// ../node_modules/braces/index.js
var B$ = y((plt, L$) => {
  "use strict";
  var F$ = $y(), aqe = P$(), oqe = w$(), lqe = k$(), Os = /* @__PURE__ */ i((e, t = {}) => {
    let r = [];
    if (Array.isArray(e))
      for (let s of e) {
        let n = Os.create(s, t);
        Array.isArray(n) ? r.push(...n) : r.push(n);
      }
    else
      r = [].concat(Os.create(e, t));
    return t && t.expand === !0 && t.nodupes === !0 && (r = [...new Set(r)]), r;
  }, "braces");
  Os.parse = (e, t = {}) => lqe(e, t);
  Os.stringify = (e, t = {}) => F$(typeof e == "string" ? Os.parse(e, t) : e, t);
  Os.compile = (e, t = {}) => (typeof e == "string" && (e = Os.parse(e, t)), aqe(e, t));
  Os.expand = (e, t = {}) => {
    typeof e == "string" && (e = Os.parse(e, t));
    let r = oqe(e, t);
    return t.noempty === !0 && (r = r.filter(Boolean)), t.nodupes === !0 && (r = [...new Set(r)]), r;
  };
  Os.create = (e, t = {}) => e === "" || e.length < 3 ? [e] : t.expand !== !0 ? Os.compile(e, t) : Os.expand(e, t);
  L$.exports = Os;
});

// ../node_modules/picomatch/lib/constants.js
var Xf = y((hlt, U$) => {
  "use strict";
  var uqe = require("path"), zn = "\\\\/", M$ = `[^${zn}]`, Mi = "\\.", cqe = "\\+", fqe = "\\?", Vy = "\\/", pqe = "(?=.)", j$ = "[^/]", pC = `\
(?:${Vy}|$)`, q$ = `(?:^|${Vy})`, dC = `${Mi}{1,2}${pC}`, dqe = `(?!${Mi})`, hqe = `(?!${q$}${dC})`, mqe = `(?!${Mi}{0,1}${pC})`, yqe = `(?!${dC}\
)`, gqe = `[^.${Vy}]`, bqe = `${j$}*?`, $$ = {
    DOT_LITERAL: Mi,
    PLUS_LITERAL: cqe,
    QMARK_LITERAL: fqe,
    SLASH_LITERAL: Vy,
    ONE_CHAR: pqe,
    QMARK: j$,
    END_ANCHOR: pC,
    DOTS_SLASH: dC,
    NO_DOT: dqe,
    NO_DOTS: hqe,
    NO_DOT_SLASH: mqe,
    NO_DOTS_SLASH: yqe,
    QMARK_NO_DOT: gqe,
    STAR: bqe,
    START_ANCHOR: q$
  }, Eqe = {
    ...$$,
    SLASH_LITERAL: `[${zn}]`,
    QMARK: M$,
    STAR: `${M$}*?`,
    DOTS_SLASH: `${Mi}{1,2}(?:[${zn}]|$)`,
    NO_DOT: `(?!${Mi})`,
    NO_DOTS: `(?!(?:^|[${zn}])${Mi}{1,2}(?:[${zn}]|$))`,
    NO_DOT_SLASH: `(?!${Mi}{0,1}(?:[${zn}]|$))`,
    NO_DOTS_SLASH: `(?!${Mi}{1,2}(?:[${zn}]|$))`,
    QMARK_NO_DOT: `[^.${zn}]`,
    START_ANCHOR: `(?:^|[${zn}])`,
    END_ANCHOR: `(?:[${zn}]|$)`
  }, vqe = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  U$.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: vqe,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */
    CHAR_9: 57,
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */
    CHAR_LOWERCASE_A: 97,
    /* a */
    CHAR_UPPERCASE_Z: 90,
    /* Z */
    CHAR_LOWERCASE_Z: 122,
    /* z */
    CHAR_LEFT_PARENTHESES: 40,
    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,
    /* ) */
    CHAR_ASTERISK: 42,
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */
    CHAR_AT: 64,
    /* @ */
    CHAR_BACKWARD_SLASH: 92,
    /* \ */
    CHAR_CARRIAGE_RETURN: 13,
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */
    CHAR_COLON: 58,
    /* : */
    CHAR_COMMA: 44,
    /* , */
    CHAR_DOT: 46,
    /* . */
    CHAR_DOUBLE_QUOTE: 34,
    /* " */
    CHAR_EQUAL: 61,
    /* = */
    CHAR_EXCLAMATION_MARK: 33,
    /* ! */
    CHAR_FORM_FEED: 12,
    /* \f */
    CHAR_FORWARD_SLASH: 47,
    /* / */
    CHAR_GRAVE_ACCENT: 96,
    /* ` */
    CHAR_HASH: 35,
    /* # */
    CHAR_HYPHEN_MINUS: 45,
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */
    CHAR_LINE_FEED: 10,
    /* \n */
    CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */
    CHAR_PERCENT: 37,
    /* % */
    CHAR_PLUS: 43,
    /* + */
    CHAR_QUESTION_MARK: 63,
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */
    CHAR_SEMICOLON: 59,
    /* ; */
    CHAR_SINGLE_QUOTE: 39,
    /* ' */
    CHAR_SPACE: 32,
    /*   */
    CHAR_TAB: 9,
    /* \t */
    CHAR_UNDERSCORE: 95,
    /* _ */
    CHAR_VERTICAL_LINE: 124,
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */
    SEP: uqe.sep,
    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(e) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${e.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    /**
     * Create GLOB_CHARS
     */
    globChars(e) {
      return e === !0 ? Eqe : $$;
    }
  };
});

// ../node_modules/picomatch/lib/utils.js
var zf = y((vs) => {
  "use strict";
  var Sqe = require("path"), Tqe = process.platform === "win32", {
    REGEX_BACKSLASH: xqe,
    REGEX_REMOVE_BACKSLASH: Pqe,
    REGEX_SPECIAL_CHARS: Aqe,
    REGEX_SPECIAL_CHARS_GLOBAL: Cqe
  } = Xf();
  vs.isObject = (e) => e !== null && typeof e == "object" && !Array.isArray(e);
  vs.hasRegexChars = (e) => Aqe.test(e);
  vs.isRegexChar = (e) => e.length === 1 && vs.hasRegexChars(e);
  vs.escapeRegex = (e) => e.replace(Cqe, "\\$1");
  vs.toPosixSlashes = (e) => e.replace(xqe, "/");
  vs.removeBackslashes = (e) => e.replace(Pqe, (t) => t === "\\" ? "" : t);
  vs.supportsLookbehinds = () => {
    let e = process.version.slice(1).split(".").map(Number);
    return e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10;
  };
  vs.isWindows = (e) => e && typeof e.windows == "boolean" ? e.windows : Tqe === !0 || Sqe.sep === "\\";
  vs.escapeLast = (e, t, r) => {
    let s = e.lastIndexOf(t, r);
    return s === -1 ? e : e[s - 1] === "\\" ? vs.escapeLast(e, t, s - 1) : `${e.slice(0, s)}\\${e.slice(s)}`;
  };
  vs.removePrefix = (e, t = {}) => {
    let r = e;
    return r.startsWith("./") && (r = r.slice(2), t.prefix = "./"), r;
  };
  vs.wrapOutput = (e, t = {}, r = {}) => {
    let s = r.contains ? "" : "^", n = r.contains ? "" : "$", a = `${s}(?:${e})${n}`;
    return t.negated === !0 && (a = `(?:^(?!${a}).*$)`), a;
  };
});

// ../node_modules/picomatch/lib/scan.js
var z$ = y((ylt, X$) => {
  "use strict";
  var V$ = zf(), {
    CHAR_ASTERISK: hC,
    /* * */
    CHAR_AT: wqe,
    /* @ */
    CHAR_BACKWARD_SLASH: Jf,
    /* \ */
    CHAR_COMMA: Dqe,
    /* , */
    CHAR_DOT: mC,
    /* . */
    CHAR_EXCLAMATION_MARK: yC,
    /* ! */
    CHAR_FORWARD_SLASH: Y$,
    /* / */
    CHAR_LEFT_CURLY_BRACE: gC,
    /* { */
    CHAR_LEFT_PARENTHESES: bC,
    /* ( */
    CHAR_LEFT_SQUARE_BRACKET: Iqe,
    /* [ */
    CHAR_PLUS: _qe,
    /* + */
    CHAR_QUESTION_MARK: W$,
    /* ? */
    CHAR_RIGHT_CURLY_BRACE: Oqe,
    /* } */
    CHAR_RIGHT_PARENTHESES: H$,
    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET: Nqe
    /* ] */
  } = Xf(), G$ = /* @__PURE__ */ i((e) => e === Y$ || e === Jf, "isPathSeparator"), K$ = /* @__PURE__ */ i((e) => {
    e.isPrefix !== !0 && (e.depth = e.isGlobstar ? 1 / 0 : 1);
  }, "depth"), Rqe = /* @__PURE__ */ i((e, t) => {
    let r = t || {}, s = e.length - 1, n = r.parts === !0 || r.scanToEnd === !0, a = [], o = [], l = [], u = e, c = -1, f = 0, p = 0, d = !1,
    m = !1, b = !1, h = !1, g = !1, E = !1, D = !1, C = !1, N = !1, I = !1, M = 0, q, V, W = { value: "", depth: 0, isGlob: !1 }, Y = /* @__PURE__ */ i(
    () => c >= s, "eos"), j = /* @__PURE__ */ i(() => u.charCodeAt(c + 1), "peek"), ie = /* @__PURE__ */ i(() => (q = V, u.charCodeAt(++c)),
    "advance");
    for (; c < s; ) {
      V = ie();
      let re;
      if (V === Jf) {
        D = W.backslashes = !0, V = ie(), V === gC && (E = !0);
        continue;
      }
      if (E === !0 || V === gC) {
        for (M++; Y() !== !0 && (V = ie()); ) {
          if (V === Jf) {
            D = W.backslashes = !0, ie();
            continue;
          }
          if (V === gC) {
            M++;
            continue;
          }
          if (E !== !0 && V === mC && (V = ie()) === mC) {
            if (d = W.isBrace = !0, b = W.isGlob = !0, I = !0, n === !0)
              continue;
            break;
          }
          if (E !== !0 && V === Dqe) {
            if (d = W.isBrace = !0, b = W.isGlob = !0, I = !0, n === !0)
              continue;
            break;
          }
          if (V === Oqe && (M--, M === 0)) {
            E = !1, d = W.isBrace = !0, I = !0;
            break;
          }
        }
        if (n === !0)
          continue;
        break;
      }
      if (V === Y$) {
        if (a.push(c), o.push(W), W = { value: "", depth: 0, isGlob: !1 }, I === !0) continue;
        if (q === mC && c === f + 1) {
          f += 2;
          continue;
        }
        p = c + 1;
        continue;
      }
      if (r.noext !== !0 && (V === _qe || V === wqe || V === hC || V === W$ || V === yC) === !0 && j() === bC) {
        if (b = W.isGlob = !0, h = W.isExtglob = !0, I = !0, V === yC && c === f && (N = !0), n === !0) {
          for (; Y() !== !0 && (V = ie()); ) {
            if (V === Jf) {
              D = W.backslashes = !0, V = ie();
              continue;
            }
            if (V === H$) {
              b = W.isGlob = !0, I = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (V === hC) {
        if (q === hC && (g = W.isGlobstar = !0), b = W.isGlob = !0, I = !0, n === !0)
          continue;
        break;
      }
      if (V === W$) {
        if (b = W.isGlob = !0, I = !0, n === !0)
          continue;
        break;
      }
      if (V === Iqe) {
        for (; Y() !== !0 && (re = ie()); ) {
          if (re === Jf) {
            D = W.backslashes = !0, ie();
            continue;
          }
          if (re === Nqe) {
            m = W.isBracket = !0, b = W.isGlob = !0, I = !0;
            break;
          }
        }
        if (n === !0)
          continue;
        break;
      }
      if (r.nonegate !== !0 && V === yC && c === f) {
        C = W.negated = !0, f++;
        continue;
      }
      if (r.noparen !== !0 && V === bC) {
        if (b = W.isGlob = !0, n === !0) {
          for (; Y() !== !0 && (V = ie()); ) {
            if (V === bC) {
              D = W.backslashes = !0, V = ie();
              continue;
            }
            if (V === H$) {
              I = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (b === !0) {
        if (I = !0, n === !0)
          continue;
        break;
      }
    }
    r.noext === !0 && (h = !1, b = !1);
    let fe = u, De = "", F = "";
    f > 0 && (De = u.slice(0, f), u = u.slice(f), p -= f), fe && b === !0 && p > 0 ? (fe = u.slice(0, p), F = u.slice(p)) : b === !0 ? (fe =
    "", F = u) : fe = u, fe && fe !== "" && fe !== "/" && fe !== u && G$(fe.charCodeAt(fe.length - 1)) && (fe = fe.slice(0, -1)), r.unescape ===
    !0 && (F && (F = V$.removeBackslashes(F)), fe && D === !0 && (fe = V$.removeBackslashes(fe)));
    let L = {
      prefix: De,
      input: e,
      start: f,
      base: fe,
      glob: F,
      isBrace: d,
      isBracket: m,
      isGlob: b,
      isExtglob: h,
      isGlobstar: g,
      negated: C,
      negatedExtglob: N
    };
    if (r.tokens === !0 && (L.maxDepth = 0, G$(V) || o.push(W), L.tokens = o), r.parts === !0 || r.tokens === !0) {
      let re;
      for (let se = 0; se < a.length; se++) {
        let be = re ? re + 1 : f, je = a[se], Pe = e.slice(be, je);
        r.tokens && (se === 0 && f !== 0 ? (o[se].isPrefix = !0, o[se].value = De) : o[se].value = Pe, K$(o[se]), L.maxDepth += o[se].depth),
        (se !== 0 || Pe !== "") && l.push(Pe), re = je;
      }
      if (re && re + 1 < e.length) {
        let se = e.slice(re + 1);
        l.push(se), r.tokens && (o[o.length - 1].value = se, K$(o[o.length - 1]), L.maxDepth += o[o.length - 1].depth);
      }
      L.slashes = a, L.parts = l;
    }
    return L;
  }, "scan");
  X$.exports = Rqe;
});

// ../node_modules/picomatch/lib/parse.js
var Z$ = y((blt, Q$) => {
  "use strict";
  var Wy = Xf(), Ns = zf(), {
    MAX_LENGTH: Hy,
    POSIX_REGEX_SOURCE: kqe,
    REGEX_NON_SPECIAL_CHARS: Fqe,
    REGEX_SPECIAL_CHARS_BACKREF: Lqe,
    REPLACEMENTS: J$
  } = Wy, Bqe = /* @__PURE__ */ i((e, t) => {
    if (typeof t.expandRange == "function")
      return t.expandRange(...e, t);
    e.sort();
    let r = `[${e.join("-")}]`;
    try {
      new RegExp(r);
    } catch {
      return e.map((n) => Ns.escapeRegex(n)).join("..");
    }
    return r;
  }, "expandRange"), hu = /* @__PURE__ */ i((e, t) => `Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`, "syntaxError"), EC = /* @__PURE__ */ i(
  (e, t) => {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    e = J$[e] || e;
    let r = { ...t }, s = typeof r.maxLength == "number" ? Math.min(Hy, r.maxLength) : Hy, n = e.length;
    if (n > s)
      throw new SyntaxError(`Input length: ${n}, exceeds maximum allowed length: ${s}`);
    let a = { type: "bos", value: "", output: r.prepend || "" }, o = [a], l = r.capture ? "" : "?:", u = Ns.isWindows(t), c = Wy.globChars(u),
    f = Wy.extglobChars(c), {
      DOT_LITERAL: p,
      PLUS_LITERAL: d,
      SLASH_LITERAL: m,
      ONE_CHAR: b,
      DOTS_SLASH: h,
      NO_DOT: g,
      NO_DOT_SLASH: E,
      NO_DOTS_SLASH: D,
      QMARK: C,
      QMARK_NO_DOT: N,
      STAR: I,
      START_ANCHOR: M
    } = c, q = /* @__PURE__ */ i((pe) => `(${l}(?:(?!${M}${pe.dot ? h : p}).)*?)`, "globstar"), V = r.dot ? "" : g, W = r.dot ? C : N, Y = r.
    bash === !0 ? q(r) : I;
    r.capture && (Y = `(${Y})`), typeof r.noext == "boolean" && (r.noextglob = r.noext);
    let j = {
      input: e,
      index: -1,
      start: 0,
      dot: r.dot === !0,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: !1,
      negated: !1,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: !1,
      tokens: o
    };
    e = Ns.removePrefix(e, j), n = e.length;
    let ie = [], fe = [], De = [], F = a, L, re = /* @__PURE__ */ i(() => j.index === n - 1, "eos"), se = j.peek = (pe = 1) => e[j.index + pe],
    be = j.advance = () => e[++j.index] || "", je = /* @__PURE__ */ i(() => e.slice(j.index + 1), "remaining"), Pe = /* @__PURE__ */ i((pe = "", ut = 0) => {
      j.consumed += pe, j.index += ut;
    }, "consume"), Rt = /* @__PURE__ */ i((pe) => {
      j.output += pe.output != null ? pe.output : pe.value, Pe(pe.value);
    }, "append"), Bt = /* @__PURE__ */ i(() => {
      let pe = 1;
      for (; se() === "!" && (se(2) !== "(" || se(3) === "?"); )
        be(), j.start++, pe++;
      return pe % 2 === 0 ? !1 : (j.negated = !0, j.start++, !0);
    }, "negate"), qt = /* @__PURE__ */ i((pe) => {
      j[pe]++, De.push(pe);
    }, "increment"), Ie = /* @__PURE__ */ i((pe) => {
      j[pe]--, De.pop();
    }, "decrement"), _e = /* @__PURE__ */ i((pe) => {
      if (F.type === "globstar") {
        let ut = j.braces > 0 && (pe.type === "comma" || pe.type === "brace"), oe = pe.extglob === !0 || ie.length && (pe.type === "pipe" ||
        pe.type === "paren");
        pe.type !== "slash" && pe.type !== "paren" && !ut && !oe && (j.output = j.output.slice(0, -F.output.length), F.type = "star", F.value =
        "*", F.output = Y, j.output += F.output);
      }
      if (ie.length && pe.type !== "paren" && (ie[ie.length - 1].inner += pe.value), (pe.value || pe.output) && Rt(pe), F && F.type === "tex\
t" && pe.type === "text") {
        F.value += pe.value, F.output = (F.output || "") + pe.value;
        return;
      }
      pe.prev = F, o.push(pe), F = pe;
    }, "push"), Jt = /* @__PURE__ */ i((pe, ut) => {
      let oe = { ...f[ut], conditions: 1, inner: "" };
      oe.prev = F, oe.parens = j.parens, oe.output = j.output;
      let He = (r.capture ? "(" : "") + oe.open;
      qt("parens"), _e({ type: pe, value: ut, output: j.output ? "" : b }), _e({ type: "paren", extglob: !0, value: be(), output: He }), ie.
      push(oe);
    }, "extglobOpen"), Sr = /* @__PURE__ */ i((pe) => {
      let ut = pe.close + (r.capture ? ")" : ""), oe;
      if (pe.type === "negate") {
        let He = Y;
        if (pe.inner && pe.inner.length > 1 && pe.inner.includes("/") && (He = q(r)), (He !== Y || re() || /^\)+$/.test(je())) && (ut = pe.close =
        `)$))${He}`), pe.inner.includes("*") && (oe = je()) && /^\.[^\\/.]+$/.test(oe)) {
          let Pt = EC(oe, { ...t, fastpaths: !1 }).output;
          ut = pe.close = `)${Pt})${He})`;
        }
        pe.prev.type === "bos" && (j.negatedExtglob = !0);
      }
      _e({ type: "paren", extglob: !0, value: L, output: ut }), Ie("parens");
    }, "extglobClose");
    if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(e)) {
      let pe = !1, ut = e.replace(Lqe, (oe, He, Pt, Qt, kt, sn) => Qt === "\\" ? (pe = !0, oe) : Qt === "?" ? He ? He + Qt + (kt ? C.repeat(
      kt.length) : "") : sn === 0 ? W + (kt ? C.repeat(kt.length) : "") : C.repeat(Pt.length) : Qt === "." ? p.repeat(Pt.length) : Qt === "*" ?
      He ? He + Qt + (kt ? Y : "") : Y : He ? oe : `\\${oe}`);
      return pe === !0 && (r.unescape === !0 ? ut = ut.replace(/\\/g, "") : ut = ut.replace(/\\+/g, (oe) => oe.length % 2 === 0 ? "\\\\" : oe ?
      "\\" : "")), ut === e && r.contains === !0 ? (j.output = e, j) : (j.output = Ns.wrapOutput(ut, j, t), j);
    }
    for (; !re(); ) {
      if (L = be(), L === "\0")
        continue;
      if (L === "\\") {
        let oe = se();
        if (oe === "/" && r.bash !== !0 || oe === "." || oe === ";")
          continue;
        if (!oe) {
          L += "\\", _e({ type: "text", value: L });
          continue;
        }
        let He = /^\\+/.exec(je()), Pt = 0;
        if (He && He[0].length > 2 && (Pt = He[0].length, j.index += Pt, Pt % 2 !== 0 && (L += "\\")), r.unescape === !0 ? L = be() : L += be(),
        j.brackets === 0) {
          _e({ type: "text", value: L });
          continue;
        }
      }
      if (j.brackets > 0 && (L !== "]" || F.value === "[" || F.value === "[^")) {
        if (r.posix !== !1 && L === ":") {
          let oe = F.value.slice(1);
          if (oe.includes("[") && (F.posix = !0, oe.includes(":"))) {
            let He = F.value.lastIndexOf("["), Pt = F.value.slice(0, He), Qt = F.value.slice(He + 2), kt = kqe[Qt];
            if (kt) {
              F.value = Pt + kt, j.backtrack = !0, be(), !a.output && o.indexOf(F) === 1 && (a.output = b);
              continue;
            }
          }
        }
        (L === "[" && se() !== ":" || L === "-" && se() === "]") && (L = `\\${L}`), L === "]" && (F.value === "[" || F.value === "[^") && (L =
        `\\${L}`), r.posix === !0 && L === "!" && F.value === "[" && (L = "^"), F.value += L, Rt({ value: L });
        continue;
      }
      if (j.quotes === 1 && L !== '"') {
        L = Ns.escapeRegex(L), F.value += L, Rt({ value: L });
        continue;
      }
      if (L === '"') {
        j.quotes = j.quotes === 1 ? 0 : 1, r.keepQuotes === !0 && _e({ type: "text", value: L });
        continue;
      }
      if (L === "(") {
        qt("parens"), _e({ type: "paren", value: L });
        continue;
      }
      if (L === ")") {
        if (j.parens === 0 && r.strictBrackets === !0)
          throw new SyntaxError(hu("opening", "("));
        let oe = ie[ie.length - 1];
        if (oe && j.parens === oe.parens + 1) {
          Sr(ie.pop());
          continue;
        }
        _e({ type: "paren", value: L, output: j.parens ? ")" : "\\)" }), Ie("parens");
        continue;
      }
      if (L === "[") {
        if (r.nobracket === !0 || !je().includes("]")) {
          if (r.nobracket !== !0 && r.strictBrackets === !0)
            throw new SyntaxError(hu("closing", "]"));
          L = `\\${L}`;
        } else
          qt("brackets");
        _e({ type: "bracket", value: L });
        continue;
      }
      if (L === "]") {
        if (r.nobracket === !0 || F && F.type === "bracket" && F.value.length === 1) {
          _e({ type: "text", value: L, output: `\\${L}` });
          continue;
        }
        if (j.brackets === 0) {
          if (r.strictBrackets === !0)
            throw new SyntaxError(hu("opening", "["));
          _e({ type: "text", value: L, output: `\\${L}` });
          continue;
        }
        Ie("brackets");
        let oe = F.value.slice(1);
        if (F.posix !== !0 && oe[0] === "^" && !oe.includes("/") && (L = `/${L}`), F.value += L, Rt({ value: L }), r.literalBrackets === !1 ||
        Ns.hasRegexChars(oe))
          continue;
        let He = Ns.escapeRegex(F.value);
        if (j.output = j.output.slice(0, -F.value.length), r.literalBrackets === !0) {
          j.output += He, F.value = He;
          continue;
        }
        F.value = `(${l}${He}|${F.value})`, j.output += F.value;
        continue;
      }
      if (L === "{" && r.nobrace !== !0) {
        qt("braces");
        let oe = {
          type: "brace",
          value: L,
          output: "(",
          outputIndex: j.output.length,
          tokensIndex: j.tokens.length
        };
        fe.push(oe), _e(oe);
        continue;
      }
      if (L === "}") {
        let oe = fe[fe.length - 1];
        if (r.nobrace === !0 || !oe) {
          _e({ type: "text", value: L, output: L });
          continue;
        }
        let He = ")";
        if (oe.dots === !0) {
          let Pt = o.slice(), Qt = [];
          for (let kt = Pt.length - 1; kt >= 0 && (o.pop(), Pt[kt].type !== "brace"); kt--)
            Pt[kt].type !== "dots" && Qt.unshift(Pt[kt].value);
          He = Bqe(Qt, r), j.backtrack = !0;
        }
        if (oe.comma !== !0 && oe.dots !== !0) {
          let Pt = j.output.slice(0, oe.outputIndex), Qt = j.tokens.slice(oe.tokensIndex);
          oe.value = oe.output = "\\{", L = He = "\\}", j.output = Pt;
          for (let kt of Qt)
            j.output += kt.output || kt.value;
        }
        _e({ type: "brace", value: L, output: He }), Ie("braces"), fe.pop();
        continue;
      }
      if (L === "|") {
        ie.length > 0 && ie[ie.length - 1].conditions++, _e({ type: "text", value: L });
        continue;
      }
      if (L === ",") {
        let oe = L, He = fe[fe.length - 1];
        He && De[De.length - 1] === "braces" && (He.comma = !0, oe = "|"), _e({ type: "comma", value: L, output: oe });
        continue;
      }
      if (L === "/") {
        if (F.type === "dot" && j.index === j.start + 1) {
          j.start = j.index + 1, j.consumed = "", j.output = "", o.pop(), F = a;
          continue;
        }
        _e({ type: "slash", value: L, output: m });
        continue;
      }
      if (L === ".") {
        if (j.braces > 0 && F.type === "dot") {
          F.value === "." && (F.output = p);
          let oe = fe[fe.length - 1];
          F.type = "dots", F.output += L, F.value += L, oe.dots = !0;
          continue;
        }
        if (j.braces + j.parens === 0 && F.type !== "bos" && F.type !== "slash") {
          _e({ type: "text", value: L, output: p });
          continue;
        }
        _e({ type: "dot", value: L, output: p });
        continue;
      }
      if (L === "?") {
        if (!(F && F.value === "(") && r.noextglob !== !0 && se() === "(" && se(2) !== "?") {
          Jt("qmark", L);
          continue;
        }
        if (F && F.type === "paren") {
          let He = se(), Pt = L;
          if (He === "<" && !Ns.supportsLookbehinds())
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          (F.value === "(" && !/[!=<:]/.test(He) || He === "<" && !/<([!=]|\w+>)/.test(je())) && (Pt = `\\${L}`), _e({ type: "text", value: L,
          output: Pt });
          continue;
        }
        if (r.dot !== !0 && (F.type === "slash" || F.type === "bos")) {
          _e({ type: "qmark", value: L, output: N });
          continue;
        }
        _e({ type: "qmark", value: L, output: C });
        continue;
      }
      if (L === "!") {
        if (r.noextglob !== !0 && se() === "(" && (se(2) !== "?" || !/[!=<:]/.test(se(3)))) {
          Jt("negate", L);
          continue;
        }
        if (r.nonegate !== !0 && j.index === 0) {
          Bt();
          continue;
        }
      }
      if (L === "+") {
        if (r.noextglob !== !0 && se() === "(" && se(2) !== "?") {
          Jt("plus", L);
          continue;
        }
        if (F && F.value === "(" || r.regex === !1) {
          _e({ type: "plus", value: L, output: d });
          continue;
        }
        if (F && (F.type === "bracket" || F.type === "paren" || F.type === "brace") || j.parens > 0) {
          _e({ type: "plus", value: L });
          continue;
        }
        _e({ type: "plus", value: d });
        continue;
      }
      if (L === "@") {
        if (r.noextglob !== !0 && se() === "(" && se(2) !== "?") {
          _e({ type: "at", extglob: !0, value: L, output: "" });
          continue;
        }
        _e({ type: "text", value: L });
        continue;
      }
      if (L !== "*") {
        (L === "$" || L === "^") && (L = `\\${L}`);
        let oe = Fqe.exec(je());
        oe && (L += oe[0], j.index += oe[0].length), _e({ type: "text", value: L });
        continue;
      }
      if (F && (F.type === "globstar" || F.star === !0)) {
        F.type = "star", F.star = !0, F.value += L, F.output = Y, j.backtrack = !0, j.globstar = !0, Pe(L);
        continue;
      }
      let pe = je();
      if (r.noextglob !== !0 && /^\([^?]/.test(pe)) {
        Jt("star", L);
        continue;
      }
      if (F.type === "star") {
        if (r.noglobstar === !0) {
          Pe(L);
          continue;
        }
        let oe = F.prev, He = oe.prev, Pt = oe.type === "slash" || oe.type === "bos", Qt = He && (He.type === "star" || He.type === "globsta\
r");
        if (r.bash === !0 && (!Pt || pe[0] && pe[0] !== "/")) {
          _e({ type: "star", value: L, output: "" });
          continue;
        }
        let kt = j.braces > 0 && (oe.type === "comma" || oe.type === "brace"), sn = ie.length && (oe.type === "pipe" || oe.type === "paren");
        if (!Pt && oe.type !== "paren" && !kt && !sn) {
          _e({ type: "star", value: L, output: "" });
          continue;
        }
        for (; pe.slice(0, 3) === "/**"; ) {
          let Xr = e[j.index + 4];
          if (Xr && Xr !== "/")
            break;
          pe = pe.slice(3), Pe("/**", 3);
        }
        if (oe.type === "bos" && re()) {
          F.type = "globstar", F.value += L, F.output = q(r), j.output = F.output, j.globstar = !0, Pe(L);
          continue;
        }
        if (oe.type === "slash" && oe.prev.type !== "bos" && !Qt && re()) {
          j.output = j.output.slice(0, -(oe.output + F.output).length), oe.output = `(?:${oe.output}`, F.type = "globstar", F.output = q(r) +
          (r.strictSlashes ? ")" : "|$)"), F.value += L, j.globstar = !0, j.output += oe.output + F.output, Pe(L);
          continue;
        }
        if (oe.type === "slash" && oe.prev.type !== "bos" && pe[0] === "/") {
          let Xr = pe[1] !== void 0 ? "|$" : "";
          j.output = j.output.slice(0, -(oe.output + F.output).length), oe.output = `(?:${oe.output}`, F.type = "globstar", F.output = `${q(
          r)}${m}|${m}${Xr})`, F.value += L, j.output += oe.output + F.output, j.globstar = !0, Pe(L + be()), _e({ type: "slash", value: "/",
          output: "" });
          continue;
        }
        if (oe.type === "bos" && pe[0] === "/") {
          F.type = "globstar", F.value += L, F.output = `(?:^|${m}|${q(r)}${m})`, j.output = F.output, j.globstar = !0, Pe(L + be()), _e({ type: "\
slash", value: "/", output: "" });
          continue;
        }
        j.output = j.output.slice(0, -F.output.length), F.type = "globstar", F.output = q(r), F.value += L, j.output += F.output, j.globstar =
        !0, Pe(L);
        continue;
      }
      let ut = { type: "star", value: L, output: Y };
      if (r.bash === !0) {
        ut.output = ".*?", (F.type === "bos" || F.type === "slash") && (ut.output = V + ut.output), _e(ut);
        continue;
      }
      if (F && (F.type === "bracket" || F.type === "paren") && r.regex === !0) {
        ut.output = L, _e(ut);
        continue;
      }
      (j.index === j.start || F.type === "slash" || F.type === "dot") && (F.type === "dot" ? (j.output += E, F.output += E) : r.dot === !0 ?
      (j.output += D, F.output += D) : (j.output += V, F.output += V), se() !== "*" && (j.output += b, F.output += b)), _e(ut);
    }
    for (; j.brackets > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(hu("closing", "]"));
      j.output = Ns.escapeLast(j.output, "["), Ie("brackets");
    }
    for (; j.parens > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(hu("closing", ")"));
      j.output = Ns.escapeLast(j.output, "("), Ie("parens");
    }
    for (; j.braces > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(hu("closing", "}"));
      j.output = Ns.escapeLast(j.output, "{"), Ie("braces");
    }
    if (r.strictSlashes !== !0 && (F.type === "star" || F.type === "bracket") && _e({ type: "maybe_slash", value: "", output: `${m}?` }), j.
    backtrack === !0) {
      j.output = "";
      for (let pe of j.tokens)
        j.output += pe.output != null ? pe.output : pe.value, pe.suffix && (j.output += pe.suffix);
    }
    return j;
  }, "parse");
  EC.fastpaths = (e, t) => {
    let r = { ...t }, s = typeof r.maxLength == "number" ? Math.min(Hy, r.maxLength) : Hy, n = e.length;
    if (n > s)
      throw new SyntaxError(`Input length: ${n}, exceeds maximum allowed length: ${s}`);
    e = J$[e] || e;
    let a = Ns.isWindows(t), {
      DOT_LITERAL: o,
      SLASH_LITERAL: l,
      ONE_CHAR: u,
      DOTS_SLASH: c,
      NO_DOT: f,
      NO_DOTS: p,
      NO_DOTS_SLASH: d,
      STAR: m,
      START_ANCHOR: b
    } = Wy.globChars(a), h = r.dot ? p : f, g = r.dot ? d : f, E = r.capture ? "" : "?:", D = { negated: !1, prefix: "" }, C = r.bash === !0 ?
    ".*?" : m;
    r.capture && (C = `(${C})`);
    let N = /* @__PURE__ */ i((V) => V.noglobstar === !0 ? C : `(${E}(?:(?!${b}${V.dot ? c : o}).)*?)`, "globstar"), I = /* @__PURE__ */ i((V) => {
      switch (V) {
        case "*":
          return `${h}${u}${C}`;
        case ".*":
          return `${o}${u}${C}`;
        case "*.*":
          return `${h}${C}${o}${u}${C}`;
        case "*/*":
          return `${h}${C}${l}${u}${g}${C}`;
        case "**":
          return h + N(r);
        case "**/*":
          return `(?:${h}${N(r)}${l})?${g}${u}${C}`;
        case "**/*.*":
          return `(?:${h}${N(r)}${l})?${g}${C}${o}${u}${C}`;
        case "**/.*":
          return `(?:${h}${N(r)}${l})?${o}${u}${C}`;
        default: {
          let W = /^(.*?)\.(\w+)$/.exec(V);
          if (!W) return;
          let Y = I(W[1]);
          return Y ? Y + o + W[2] : void 0;
        }
      }
    }, "create"), M = Ns.removePrefix(e, D), q = I(M);
    return q && r.strictSlashes !== !0 && (q += `${l}?`), q;
  };
  Q$.exports = EC;
});

// ../node_modules/picomatch/lib/picomatch.js
var tU = y((vlt, eU) => {
  "use strict";
  var Mqe = require("path"), jqe = z$(), vC = Z$(), SC = zf(), qqe = Xf(), $qe = /* @__PURE__ */ i((e) => e && typeof e == "object" && !Array.
  isArray(e), "isObject"), yr = /* @__PURE__ */ i((e, t, r = !1) => {
    if (Array.isArray(e)) {
      let f = e.map((d) => yr(d, t, r));
      return /* @__PURE__ */ i((d) => {
        for (let m of f) {
          let b = m(d);
          if (b) return b;
        }
        return !1;
      }, "arrayMatcher");
    }
    let s = $qe(e) && e.tokens && e.input;
    if (e === "" || typeof e != "string" && !s)
      throw new TypeError("Expected pattern to be a non-empty string");
    let n = t || {}, a = SC.isWindows(t), o = s ? yr.compileRe(e, t) : yr.makeRe(e, t, !1, !0), l = o.state;
    delete o.state;
    let u = /* @__PURE__ */ i(() => !1, "isIgnored");
    if (n.ignore) {
      let f = { ...t, ignore: null, onMatch: null, onResult: null };
      u = yr(n.ignore, f, r);
    }
    let c = /* @__PURE__ */ i((f, p = !1) => {
      let { isMatch: d, match: m, output: b } = yr.test(f, o, t, { glob: e, posix: a }), h = { glob: e, state: l, regex: o, posix: a, input: f,
      output: b, match: m, isMatch: d };
      return typeof n.onResult == "function" && n.onResult(h), d === !1 ? (h.isMatch = !1, p ? h : !1) : u(f) ? (typeof n.onIgnore == "funct\
ion" && n.onIgnore(h), h.isMatch = !1, p ? h : !1) : (typeof n.onMatch == "function" && n.onMatch(h), p ? h : !0);
    }, "matcher");
    return r && (c.state = l), c;
  }, "picomatch");
  yr.test = (e, t, r, { glob: s, posix: n } = {}) => {
    if (typeof e != "string")
      throw new TypeError("Expected input to be a string");
    if (e === "")
      return { isMatch: !1, output: "" };
    let a = r || {}, o = a.format || (n ? SC.toPosixSlashes : null), l = e === s, u = l && o ? o(e) : e;
    return l === !1 && (u = o ? o(e) : e, l = u === s), (l === !1 || a.capture === !0) && (a.matchBase === !0 || a.basename === !0 ? l = yr.
    matchBase(e, t, r, n) : l = t.exec(u)), { isMatch: !!l, match: l, output: u };
  };
  yr.matchBase = (e, t, r, s = SC.isWindows(r)) => (t instanceof RegExp ? t : yr.makeRe(t, r)).test(Mqe.basename(e));
  yr.isMatch = (e, t, r) => yr(t, r)(e);
  yr.parse = (e, t) => Array.isArray(e) ? e.map((r) => yr.parse(r, t)) : vC(e, { ...t, fastpaths: !1 });
  yr.scan = (e, t) => jqe(e, t);
  yr.compileRe = (e, t, r = !1, s = !1) => {
    if (r === !0)
      return e.output;
    let n = t || {}, a = n.contains ? "" : "^", o = n.contains ? "" : "$", l = `${a}(?:${e.output})${o}`;
    e && e.negated === !0 && (l = `^(?!${l}).*$`);
    let u = yr.toRegex(l, t);
    return s === !0 && (u.state = e), u;
  };
  yr.makeRe = (e, t = {}, r = !1, s = !1) => {
    if (!e || typeof e != "string")
      throw new TypeError("Expected a non-empty string");
    let n = { negated: !1, fastpaths: !0 };
    return t.fastpaths !== !1 && (e[0] === "." || e[0] === "*") && (n.output = vC.fastpaths(e, t)), n.output || (n = vC(e, t)), yr.compileRe(
    n, t, r, s);
  };
  yr.toRegex = (e, t) => {
    try {
      let r = t || {};
      return new RegExp(e, r.flags || (r.nocase ? "i" : ""));
    } catch (r) {
      if (t && t.debug === !0) throw r;
      return /$^/;
    }
  };
  yr.constants = qqe;
  eU.exports = yr;
});

// ../node_modules/picomatch/index.js
var sU = y((Tlt, rU) => {
  "use strict";
  rU.exports = tU();
});

// ../node_modules/micromatch/index.js
var lU = y((xlt, oU) => {
  "use strict";
  var iU = require("util"), aU = B$(), Jn = sU(), TC = zf(), nU = /* @__PURE__ */ i((e) => e === "" || e === "./", "isEmptyString"), zt = /* @__PURE__ */ i(
  (e, t, r) => {
    t = [].concat(t), e = [].concat(e);
    let s = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), o = 0, l = /* @__PURE__ */ i((f) => {
      a.add(f.output), r && r.onResult && r.onResult(f);
    }, "onResult");
    for (let f = 0; f < t.length; f++) {
      let p = Jn(String(t[f]), { ...r, onResult: l }, !0), d = p.state.negated || p.state.negatedExtglob;
      d && o++;
      for (let m of e) {
        let b = p(m, !0);
        (d ? !b.isMatch : b.isMatch) && (d ? s.add(b.output) : (s.delete(b.output), n.add(b.output)));
      }
    }
    let c = (o === t.length ? [...a] : [...n]).filter((f) => !s.has(f));
    if (r && c.length === 0) {
      if (r.failglob === !0)
        throw new Error(`No matches found for "${t.join(", ")}"`);
      if (r.nonull === !0 || r.nullglob === !0)
        return r.unescape ? t.map((f) => f.replace(/\\/g, "")) : t;
    }
    return c;
  }, "micromatch");
  zt.match = zt;
  zt.matcher = (e, t) => Jn(e, t);
  zt.isMatch = (e, t, r) => Jn(t, r)(e);
  zt.any = zt.isMatch;
  zt.not = (e, t, r = {}) => {
    t = [].concat(t).map(String);
    let s = /* @__PURE__ */ new Set(), n = [], a = /* @__PURE__ */ i((l) => {
      r.onResult && r.onResult(l), n.push(l.output);
    }, "onResult"), o = new Set(zt(e, t, { ...r, onResult: a }));
    for (let l of n)
      o.has(l) || s.add(l);
    return [...s];
  };
  zt.contains = (e, t, r) => {
    if (typeof e != "string")
      throw new TypeError(`Expected a string: "${iU.inspect(e)}"`);
    if (Array.isArray(t))
      return t.some((s) => zt.contains(e, s, r));
    if (typeof t == "string") {
      if (nU(e) || nU(t))
        return !1;
      if (e.includes(t) || e.startsWith("./") && e.slice(2).includes(t))
        return !0;
    }
    return zt.isMatch(e, t, { ...r, contains: !0 });
  };
  zt.matchKeys = (e, t, r) => {
    if (!TC.isObject(e))
      throw new TypeError("Expected the first argument to be an object");
    let s = zt(Object.keys(e), t, r), n = {};
    for (let a of s) n[a] = e[a];
    return n;
  };
  zt.some = (e, t, r) => {
    let s = [].concat(e);
    for (let n of [].concat(t)) {
      let a = Jn(String(n), r);
      if (s.some((o) => a(o)))
        return !0;
    }
    return !1;
  };
  zt.every = (e, t, r) => {
    let s = [].concat(e);
    for (let n of [].concat(t)) {
      let a = Jn(String(n), r);
      if (!s.every((o) => a(o)))
        return !1;
    }
    return !0;
  };
  zt.all = (e, t, r) => {
    if (typeof e != "string")
      throw new TypeError(`Expected a string: "${iU.inspect(e)}"`);
    return [].concat(t).every((s) => Jn(s, r)(e));
  };
  zt.capture = (e, t, r) => {
    let s = TC.isWindows(r), a = Jn.makeRe(String(e), { ...r, capture: !0 }).exec(s ? TC.toPosixSlashes(t) : t);
    if (a)
      return a.slice(1).map((o) => o === void 0 ? "" : o);
  };
  zt.makeRe = (...e) => Jn.makeRe(...e);
  zt.scan = (...e) => Jn.scan(...e);
  zt.parse = (e, t) => {
    let r = [];
    for (let s of [].concat(e || []))
      for (let n of aU(String(s), t))
        r.push(Jn.parse(n, t));
    return r;
  };
  zt.braces = (e, t) => {
    if (typeof e != "string") throw new TypeError("Expected a string");
    return t && t.nobrace === !0 || !/\{.*\}/.test(e) ? [e] : aU(e, t);
  };
  zt.braceExpand = (e, t) => {
    if (typeof e != "string") throw new TypeError("Expected a string");
    return zt.braces(e, { ...t, expand: !0 });
  };
  oU.exports = zt;
});

// ../node_modules/fast-glob/out/utils/pattern.js
var yU = y((We) => {
  "use strict";
  Object.defineProperty(We, "__esModule", { value: !0 });
  We.removeDuplicateSlashes = We.matchAny = We.convertPatternsToRe = We.makeRe = We.getPatternParts = We.expandBraceExpansion = We.expandPatternsWithBraceExpansion =
  We.isAffectDepthOfReadingPattern = We.endsWithSlashGlobStar = We.hasGlobStar = We.getBaseDirectory = We.isPatternRelatedToParentDirectory =
  We.getPatternsOutsideCurrentDirectory = We.getPatternsInsideCurrentDirectory = We.getPositivePatterns = We.getNegativePatterns = We.isPositivePattern =
  We.isNegativePattern = We.convertToNegativePattern = We.convertToPositivePattern = We.isDynamicPattern = We.isStaticPattern = void 0;
  var Uqe = require("path"), Vqe = e$(), xC = lU(), uU = "**", Wqe = "\\", Hqe = /[*?]|^!/, Gqe = /\[[^[]*]/, Kqe = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/,
  Yqe = /[!*+?@]\([^(]*\)/, Xqe = /,|\.\./, zqe = /(?!^)\/{2,}/g;
  function cU(e, t = {}) {
    return !fU(e, t);
  }
  i(cU, "isStaticPattern");
  We.isStaticPattern = cU;
  function fU(e, t = {}) {
    return e === "" ? !1 : !!(t.caseSensitiveMatch === !1 || e.includes(Wqe) || Hqe.test(e) || Gqe.test(e) || Kqe.test(e) || t.extglob !== !1 &&
    Yqe.test(e) || t.braceExpansion !== !1 && Jqe(e));
  }
  i(fU, "isDynamicPattern");
  We.isDynamicPattern = fU;
  function Jqe(e) {
    let t = e.indexOf("{");
    if (t === -1)
      return !1;
    let r = e.indexOf("}", t + 1);
    if (r === -1)
      return !1;
    let s = e.slice(t, r);
    return Xqe.test(s);
  }
  i(Jqe, "hasBraceExpansion");
  function Qqe(e) {
    return Gy(e) ? e.slice(1) : e;
  }
  i(Qqe, "convertToPositivePattern");
  We.convertToPositivePattern = Qqe;
  function Zqe(e) {
    return "!" + e;
  }
  i(Zqe, "convertToNegativePattern");
  We.convertToNegativePattern = Zqe;
  function Gy(e) {
    return e.startsWith("!") && e[1] !== "(";
  }
  i(Gy, "isNegativePattern");
  We.isNegativePattern = Gy;
  function pU(e) {
    return !Gy(e);
  }
  i(pU, "isPositivePattern");
  We.isPositivePattern = pU;
  function e$e(e) {
    return e.filter(Gy);
  }
  i(e$e, "getNegativePatterns");
  We.getNegativePatterns = e$e;
  function t$e(e) {
    return e.filter(pU);
  }
  i(t$e, "getPositivePatterns");
  We.getPositivePatterns = t$e;
  function r$e(e) {
    return e.filter((t) => !PC(t));
  }
  i(r$e, "getPatternsInsideCurrentDirectory");
  We.getPatternsInsideCurrentDirectory = r$e;
  function s$e(e) {
    return e.filter(PC);
  }
  i(s$e, "getPatternsOutsideCurrentDirectory");
  We.getPatternsOutsideCurrentDirectory = s$e;
  function PC(e) {
    return e.startsWith("..") || e.startsWith("./..");
  }
  i(PC, "isPatternRelatedToParentDirectory");
  We.isPatternRelatedToParentDirectory = PC;
  function n$e(e) {
    return Vqe(e, { flipBackslashes: !1 });
  }
  i(n$e, "getBaseDirectory");
  We.getBaseDirectory = n$e;
  function i$e(e) {
    return e.includes(uU);
  }
  i(i$e, "hasGlobStar");
  We.hasGlobStar = i$e;
  function dU(e) {
    return e.endsWith("/" + uU);
  }
  i(dU, "endsWithSlashGlobStar");
  We.endsWithSlashGlobStar = dU;
  function a$e(e) {
    let t = Uqe.basename(e);
    return dU(e) || cU(t);
  }
  i(a$e, "isAffectDepthOfReadingPattern");
  We.isAffectDepthOfReadingPattern = a$e;
  function o$e(e) {
    return e.reduce((t, r) => t.concat(hU(r)), []);
  }
  i(o$e, "expandPatternsWithBraceExpansion");
  We.expandPatternsWithBraceExpansion = o$e;
  function hU(e) {
    let t = xC.braces(e, { expand: !0, nodupes: !0, keepEscaping: !0 });
    return t.sort((r, s) => r.length - s.length), t.filter((r) => r !== "");
  }
  i(hU, "expandBraceExpansion");
  We.expandBraceExpansion = hU;
  function l$e(e, t) {
    let { parts: r } = xC.scan(e, Object.assign(Object.assign({}, t), { parts: !0 }));
    return r.length === 0 && (r = [e]), r[0].startsWith("/") && (r[0] = r[0].slice(1), r.unshift("")), r;
  }
  i(l$e, "getPatternParts");
  We.getPatternParts = l$e;
  function mU(e, t) {
    return xC.makeRe(e, t);
  }
  i(mU, "makeRe");
  We.makeRe = mU;
  function u$e(e, t) {
    return e.map((r) => mU(r, t));
  }
  i(u$e, "convertPatternsToRe");
  We.convertPatternsToRe = u$e;
  function c$e(e, t) {
    return t.some((r) => r.test(e));
  }
  i(c$e, "matchAny");
  We.matchAny = c$e;
  function f$e(e) {
    return e.replace(zqe, "/");
  }
  i(f$e, "removeDuplicateSlashes");
  We.removeDuplicateSlashes = f$e;
});

// ../node_modules/merge2/index.js
var vU = y((wlt, EU) => {
  "use strict";
  var p$e = require("stream"), gU = p$e.PassThrough, d$e = Array.prototype.slice;
  EU.exports = h$e;
  function h$e() {
    let e = [], t = d$e.call(arguments), r = !1, s = t[t.length - 1];
    s && !Array.isArray(s) && s.pipe == null ? t.pop() : s = {};
    let n = s.end !== !1, a = s.pipeError === !0;
    s.objectMode == null && (s.objectMode = !0), s.highWaterMark == null && (s.highWaterMark = 64 * 1024);
    let o = gU(s);
    function l() {
      for (let f = 0, p = arguments.length; f < p; f++)
        e.push(bU(arguments[f], s));
      return u(), this;
    }
    i(l, "addStream");
    function u() {
      if (r)
        return;
      r = !0;
      let f = e.shift();
      if (!f) {
        process.nextTick(c);
        return;
      }
      Array.isArray(f) || (f = [f]);
      let p = f.length + 1;
      function d() {
        --p > 0 || (r = !1, u());
      }
      i(d, "next");
      function m(b) {
        function h() {
          b.removeListener("merge2UnpipeEnd", h), b.removeListener("end", h), a && b.removeListener("error", g), d();
        }
        i(h, "onend");
        function g(E) {
          o.emit("error", E);
        }
        if (i(g, "onerror"), b._readableState.endEmitted)
          return d();
        b.on("merge2UnpipeEnd", h), b.on("end", h), a && b.on("error", g), b.pipe(o, { end: !1 }), b.resume();
      }
      i(m, "pipe");
      for (let b = 0; b < f.length; b++)
        m(f[b]);
      d();
    }
    i(u, "mergeStream");
    function c() {
      r = !1, o.emit("queueDrain"), n && o.end();
    }
    return i(c, "endStream"), o.setMaxListeners(0), o.add = l, o.on("unpipe", function(f) {
      f.emit("merge2UnpipeEnd");
    }), t.length && l.apply(null, t), o;
  }
  i(h$e, "merge2");
  function bU(e, t) {
    if (Array.isArray(e))
      for (let r = 0, s = e.length; r < s; r++)
        e[r] = bU(e[r], t);
    else {
      if (!e._readableState && e.pipe && (e = e.pipe(gU(t))), !e._readableState || !e.pause || !e.pipe)
        throw new Error("Only readable stream can be merged.");
      e.pause();
    }
    return e;
  }
  i(bU, "pauseStreams");
});

// ../node_modules/fast-glob/out/utils/stream.js
var TU = y((Ky) => {
  "use strict";
  Object.defineProperty(Ky, "__esModule", { value: !0 });
  Ky.merge = void 0;
  var m$e = vU();
  function y$e(e) {
    let t = m$e(e);
    return e.forEach((r) => {
      r.once("error", (s) => t.emit("error", s));
    }), t.once("close", () => SU(e)), t.once("end", () => SU(e)), t;
  }
  i(y$e, "merge");
  Ky.merge = y$e;
  function SU(e) {
    e.forEach((t) => t.emit("close"));
  }
  i(SU, "propagateCloseEventToSources");
});

// ../node_modules/fast-glob/out/utils/string.js
var xU = y((mu) => {
  "use strict";
  Object.defineProperty(mu, "__esModule", { value: !0 });
  mu.isEmpty = mu.isString = void 0;
  function g$e(e) {
    return typeof e == "string";
  }
  i(g$e, "isString");
  mu.isString = g$e;
  function b$e(e) {
    return e === "";
  }
  i(b$e, "isEmpty");
  mu.isEmpty = b$e;
});

// ../node_modules/fast-glob/out/utils/index.js
var ji = y((Kr) => {
  "use strict";
  Object.defineProperty(Kr, "__esModule", { value: !0 });
  Kr.string = Kr.stream = Kr.pattern = Kr.path = Kr.fs = Kr.errno = Kr.array = void 0;
  var E$e = $q();
  Kr.array = E$e;
  var v$e = Uq();
  Kr.errno = v$e;
  var S$e = Vq();
  Kr.fs = S$e;
  var T$e = Kq();
  Kr.path = T$e;
  var x$e = yU();
  Kr.pattern = x$e;
  var P$e = TU();
  Kr.stream = P$e;
  var A$e = xU();
  Kr.string = A$e;
});

// ../node_modules/fast-glob/out/managers/tasks.js
var wU = y((Yr) => {
  "use strict";
  Object.defineProperty(Yr, "__esModule", { value: !0 });
  Yr.convertPatternGroupToTask = Yr.convertPatternGroupsToTasks = Yr.groupPatternsByBaseDirectory = Yr.getNegativePatternsAsPositive = Yr.getPositivePatterns =
  Yr.convertPatternsToTasks = Yr.generate = void 0;
  var An = ji();
  function C$e(e, t) {
    let r = PU(e, t), s = PU(t.ignore, t), n = AU(r), a = CU(r, s), o = n.filter((f) => An.pattern.isStaticPattern(f, t)), l = n.filter((f) => An.
    pattern.isDynamicPattern(f, t)), u = AC(
      o,
      a,
      /* dynamic */
      !1
    ), c = AC(
      l,
      a,
      /* dynamic */
      !0
    );
    return u.concat(c);
  }
  i(C$e, "generate");
  Yr.generate = C$e;
  function PU(e, t) {
    let r = e;
    return t.braceExpansion && (r = An.pattern.expandPatternsWithBraceExpansion(r)), t.baseNameMatch && (r = r.map((s) => s.includes("/") ? s :
    `**/${s}`)), r.map((s) => An.pattern.removeDuplicateSlashes(s));
  }
  i(PU, "processPatterns");
  function AC(e, t, r) {
    let s = [], n = An.pattern.getPatternsOutsideCurrentDirectory(e), a = An.pattern.getPatternsInsideCurrentDirectory(e), o = CC(n), l = CC(
    a);
    return s.push(...wC(o, t, r)), "." in l ? s.push(DC(".", a, t, r)) : s.push(...wC(l, t, r)), s;
  }
  i(AC, "convertPatternsToTasks");
  Yr.convertPatternsToTasks = AC;
  function AU(e) {
    return An.pattern.getPositivePatterns(e);
  }
  i(AU, "getPositivePatterns");
  Yr.getPositivePatterns = AU;
  function CU(e, t) {
    return An.pattern.getNegativePatterns(e).concat(t).map(An.pattern.convertToPositivePattern);
  }
  i(CU, "getNegativePatternsAsPositive");
  Yr.getNegativePatternsAsPositive = CU;
  function CC(e) {
    let t = {};
    return e.reduce((r, s) => {
      let n = An.pattern.getBaseDirectory(s);
      return n in r ? r[n].push(s) : r[n] = [s], r;
    }, t);
  }
  i(CC, "groupPatternsByBaseDirectory");
  Yr.groupPatternsByBaseDirectory = CC;
  function wC(e, t, r) {
    return Object.keys(e).map((s) => DC(s, e[s], t, r));
  }
  i(wC, "convertPatternGroupsToTasks");
  Yr.convertPatternGroupsToTasks = wC;
  function DC(e, t, r, s) {
    return {
      dynamic: s,
      positive: t,
      negative: r,
      base: e,
      patterns: [].concat(t, r.map(An.pattern.convertToNegativePattern))
    };
  }
  i(DC, "convertPatternGroupToTask");
  Yr.convertPatternGroupToTask = DC;
});

// ../node_modules/@nodelib/fs.stat/out/providers/async.js
var IU = y((Yy) => {
  "use strict";
  Object.defineProperty(Yy, "__esModule", { value: !0 });
  Yy.read = void 0;
  function w$e(e, t, r) {
    t.fs.lstat(e, (s, n) => {
      if (s !== null) {
        DU(r, s);
        return;
      }
      if (!n.isSymbolicLink() || !t.followSymbolicLink) {
        IC(r, n);
        return;
      }
      t.fs.stat(e, (a, o) => {
        if (a !== null) {
          if (t.throwErrorOnBrokenSymbolicLink) {
            DU(r, a);
            return;
          }
          IC(r, n);
          return;
        }
        t.markSymbolicLink && (o.isSymbolicLink = () => !0), IC(r, o);
      });
    });
  }
  i(w$e, "read");
  Yy.read = w$e;
  function DU(e, t) {
    e(t);
  }
  i(DU, "callFailureCallback");
  function IC(e, t) {
    e(null, t);
  }
  i(IC, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.stat/out/providers/sync.js
var _U = y((Xy) => {
  "use strict";
  Object.defineProperty(Xy, "__esModule", { value: !0 });
  Xy.read = void 0;
  function D$e(e, t) {
    let r = t.fs.lstatSync(e);
    if (!r.isSymbolicLink() || !t.followSymbolicLink)
      return r;
    try {
      let s = t.fs.statSync(e);
      return t.markSymbolicLink && (s.isSymbolicLink = () => !0), s;
    } catch (s) {
      if (!t.throwErrorOnBrokenSymbolicLink)
        return r;
      throw s;
    }
  }
  i(D$e, "read");
  Xy.read = D$e;
});

// ../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var OU = y((Na) => {
  "use strict";
  Object.defineProperty(Na, "__esModule", { value: !0 });
  Na.createFileSystemAdapter = Na.FILE_SYSTEM_ADAPTER = void 0;
  var zy = require("fs");
  Na.FILE_SYSTEM_ADAPTER = {
    lstat: zy.lstat,
    stat: zy.stat,
    lstatSync: zy.lstatSync,
    statSync: zy.statSync
  };
  function I$e(e) {
    return e === void 0 ? Na.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, Na.FILE_SYSTEM_ADAPTER), e);
  }
  i(I$e, "createFileSystemAdapter");
  Na.createFileSystemAdapter = I$e;
});

// ../node_modules/@nodelib/fs.stat/out/settings.js
var NU = y((OC) => {
  "use strict";
  Object.defineProperty(OC, "__esModule", { value: !0 });
  var _$e = OU(), _C = class {
    static {
      i(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = _$e.createFileSystemAdapter(
      this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this.
      _getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
    }
    _getValue(t, r) {
      return t ?? r;
    }
  };
  OC.default = _C;
});

// ../node_modules/@nodelib/fs.stat/out/index.js
var Fo = y((Ra) => {
  "use strict";
  Object.defineProperty(Ra, "__esModule", { value: !0 });
  Ra.statSync = Ra.stat = Ra.Settings = void 0;
  var RU = IU(), O$e = _U(), NC = NU();
  Ra.Settings = NC.default;
  function N$e(e, t, r) {
    if (typeof t == "function") {
      RU.read(e, RC(), t);
      return;
    }
    RU.read(e, RC(t), r);
  }
  i(N$e, "stat");
  Ra.stat = N$e;
  function R$e(e, t) {
    let r = RC(t);
    return O$e.read(e, r);
  }
  i(R$e, "statSync");
  Ra.statSync = R$e;
  function RC(e = {}) {
    return e instanceof NC.default ? e : new NC.default(e);
  }
  i(RC, "getSettings");
});

// ../node_modules/queue-microtask/index.js
var LU = y((Glt, FU) => {
  var kU;
  FU.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : global) : (e) => (kU || (kU = Promise.
  resolve())).then(e).catch((t) => setTimeout(() => {
    throw t;
  }, 0));
});

// ../node_modules/run-parallel/index.js
var MU = y((Klt, BU) => {
  BU.exports = F$e;
  var k$e = LU();
  function F$e(e, t) {
    let r, s, n, a = !0;
    Array.isArray(e) ? (r = [], s = e.length) : (n = Object.keys(e), r = {}, s = n.length);
    function o(u) {
      function c() {
        t && t(u, r), t = null;
      }
      i(c, "end"), a ? k$e(c) : c();
    }
    i(o, "done");
    function l(u, c, f) {
      r[u] = f, (--s === 0 || c) && o(c);
    }
    i(l, "each"), s ? n ? n.forEach(function(u) {
      e[u](function(c, f) {
        l(u, c, f);
      });
    }) : e.forEach(function(u, c) {
      u(function(f, p) {
        l(c, f, p);
      });
    }) : o(null), a = !1;
  }
  i(F$e, "runParallel");
});

// ../node_modules/@nodelib/fs.scandir/out/constants.js
var kC = y((Qy) => {
  "use strict";
  Object.defineProperty(Qy, "__esModule", { value: !0 });
  Qy.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
  var Jy = process.versions.node.split(".");
  if (Jy[0] === void 0 || Jy[1] === void 0)
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
  var jU = Number.parseInt(Jy[0], 10), L$e = Number.parseInt(Jy[1], 10), qU = 10, B$e = 10, M$e = jU > qU, j$e = jU === qU && L$e >= B$e;
  Qy.IS_SUPPORT_READDIR_WITH_FILE_TYPES = M$e || j$e;
});

// ../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var $U = y((Zy) => {
  "use strict";
  Object.defineProperty(Zy, "__esModule", { value: !0 });
  Zy.createDirentFromStats = void 0;
  var FC = class {
    static {
      i(this, "DirentFromStats");
    }
    constructor(t, r) {
      this.name = t, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.
      isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink =
      r.isSymbolicLink.bind(r);
    }
  };
  function q$e(e, t) {
    return new FC(e, t);
  }
  i(q$e, "createDirentFromStats");
  Zy.createDirentFromStats = q$e;
});

// ../node_modules/@nodelib/fs.scandir/out/utils/index.js
var LC = y((e0) => {
  "use strict";
  Object.defineProperty(e0, "__esModule", { value: !0 });
  e0.fs = void 0;
  var $$e = $U();
  e0.fs = $$e;
});

// ../node_modules/@nodelib/fs.scandir/out/providers/common.js
var BC = y((t0) => {
  "use strict";
  Object.defineProperty(t0, "__esModule", { value: !0 });
  t0.joinPathSegments = void 0;
  function U$e(e, t, r) {
    return e.endsWith(r) ? e + t : e + r + t;
  }
  i(U$e, "joinPathSegments");
  t0.joinPathSegments = U$e;
});

// ../node_modules/@nodelib/fs.scandir/out/providers/async.js
var KU = y((ka) => {
  "use strict";
  Object.defineProperty(ka, "__esModule", { value: !0 });
  ka.readdir = ka.readdirWithFileTypes = ka.read = void 0;
  var V$e = Fo(), UU = MU(), W$e = kC(), VU = LC(), WU = BC();
  function H$e(e, t, r) {
    if (!t.stats && W$e.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      HU(e, t, r);
      return;
    }
    GU(e, t, r);
  }
  i(H$e, "read");
  ka.read = H$e;
  function HU(e, t, r) {
    t.fs.readdir(e, { withFileTypes: !0 }, (s, n) => {
      if (s !== null) {
        r0(r, s);
        return;
      }
      let a = n.map((l) => ({
        dirent: l,
        name: l.name,
        path: WU.joinPathSegments(e, l.name, t.pathSegmentSeparator)
      }));
      if (!t.followSymbolicLinks) {
        MC(r, a);
        return;
      }
      let o = a.map((l) => G$e(l, t));
      UU(o, (l, u) => {
        if (l !== null) {
          r0(r, l);
          return;
        }
        MC(r, u);
      });
    });
  }
  i(HU, "readdirWithFileTypes");
  ka.readdirWithFileTypes = HU;
  function G$e(e, t) {
    return (r) => {
      if (!e.dirent.isSymbolicLink()) {
        r(null, e);
        return;
      }
      t.fs.stat(e.path, (s, n) => {
        if (s !== null) {
          if (t.throwErrorOnBrokenSymbolicLink) {
            r(s);
            return;
          }
          r(null, e);
          return;
        }
        e.dirent = VU.fs.createDirentFromStats(e.name, n), r(null, e);
      });
    };
  }
  i(G$e, "makeRplTaskEntry");
  function GU(e, t, r) {
    t.fs.readdir(e, (s, n) => {
      if (s !== null) {
        r0(r, s);
        return;
      }
      let a = n.map((o) => {
        let l = WU.joinPathSegments(e, o, t.pathSegmentSeparator);
        return (u) => {
          V$e.stat(l, t.fsStatSettings, (c, f) => {
            if (c !== null) {
              u(c);
              return;
            }
            let p = {
              name: o,
              path: l,
              dirent: VU.fs.createDirentFromStats(o, f)
            };
            t.stats && (p.stats = f), u(null, p);
          });
        };
      });
      UU(a, (o, l) => {
        if (o !== null) {
          r0(r, o);
          return;
        }
        MC(r, l);
      });
    });
  }
  i(GU, "readdir");
  ka.readdir = GU;
  function r0(e, t) {
    e(t);
  }
  i(r0, "callFailureCallback");
  function MC(e, t) {
    e(null, t);
  }
  i(MC, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var QU = y((Fa) => {
  "use strict";
  Object.defineProperty(Fa, "__esModule", { value: !0 });
  Fa.readdir = Fa.readdirWithFileTypes = Fa.read = void 0;
  var K$e = Fo(), Y$e = kC(), YU = LC(), XU = BC();
  function X$e(e, t) {
    return !t.stats && Y$e.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? zU(e, t) : JU(e, t);
  }
  i(X$e, "read");
  Fa.read = X$e;
  function zU(e, t) {
    return t.fs.readdirSync(e, { withFileTypes: !0 }).map((s) => {
      let n = {
        dirent: s,
        name: s.name,
        path: XU.joinPathSegments(e, s.name, t.pathSegmentSeparator)
      };
      if (n.dirent.isSymbolicLink() && t.followSymbolicLinks)
        try {
          let a = t.fs.statSync(n.path);
          n.dirent = YU.fs.createDirentFromStats(n.name, a);
        } catch (a) {
          if (t.throwErrorOnBrokenSymbolicLink)
            throw a;
        }
      return n;
    });
  }
  i(zU, "readdirWithFileTypes");
  Fa.readdirWithFileTypes = zU;
  function JU(e, t) {
    return t.fs.readdirSync(e).map((s) => {
      let n = XU.joinPathSegments(e, s, t.pathSegmentSeparator), a = K$e.statSync(n, t.fsStatSettings), o = {
        name: s,
        path: n,
        dirent: YU.fs.createDirentFromStats(s, a)
      };
      return t.stats && (o.stats = a), o;
    });
  }
  i(JU, "readdir");
  Fa.readdir = JU;
});

// ../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var ZU = y((La) => {
  "use strict";
  Object.defineProperty(La, "__esModule", { value: !0 });
  La.createFileSystemAdapter = La.FILE_SYSTEM_ADAPTER = void 0;
  var yu = require("fs");
  La.FILE_SYSTEM_ADAPTER = {
    lstat: yu.lstat,
    stat: yu.stat,
    lstatSync: yu.lstatSync,
    statSync: yu.statSync,
    readdir: yu.readdir,
    readdirSync: yu.readdirSync
  };
  function z$e(e) {
    return e === void 0 ? La.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, La.FILE_SYSTEM_ADAPTER), e);
  }
  i(z$e, "createFileSystemAdapter");
  La.createFileSystemAdapter = z$e;
});

// ../node_modules/@nodelib/fs.scandir/out/settings.js
var eV = y((qC) => {
  "use strict";
  Object.defineProperty(qC, "__esModule", { value: !0 });
  var J$e = require("path"), Q$e = Fo(), Z$e = ZU(), jC = class {
    static {
      i(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = Z$e.createFileSystemAdapter(
      this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, J$e.sep), this.stats = this._getValue(
      this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.
      fsStatSettings = new Q$e.Settings({
        followSymbolicLink: this.followSymbolicLinks,
        fs: this.fs,
        throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(t, r) {
      return t ?? r;
    }
  };
  qC.default = jC;
});

// ../node_modules/@nodelib/fs.scandir/out/index.js
var s0 = y((Ba) => {
  "use strict";
  Object.defineProperty(Ba, "__esModule", { value: !0 });
  Ba.Settings = Ba.scandirSync = Ba.scandir = void 0;
  var tV = KU(), eUe = QU(), $C = eV();
  Ba.Settings = $C.default;
  function tUe(e, t, r) {
    if (typeof t == "function") {
      tV.read(e, UC(), t);
      return;
    }
    tV.read(e, UC(t), r);
  }
  i(tUe, "scandir");
  Ba.scandir = tUe;
  function rUe(e, t) {
    let r = UC(t);
    return eUe.read(e, r);
  }
  i(rUe, "scandirSync");
  Ba.scandirSync = rUe;
  function UC(e = {}) {
    return e instanceof $C.default ? e : new $C.default(e);
  }
  i(UC, "getSettings");
});

// ../node_modules/reusify/reusify.js
var sV = y((fut, rV) => {
  "use strict";
  function sUe(e) {
    var t = new e(), r = t;
    function s() {
      var a = t;
      return a.next ? t = a.next : (t = new e(), r = t), a.next = null, a;
    }
    i(s, "get");
    function n(a) {
      r.next = a, r = a;
    }
    return i(n, "release"), {
      get: s,
      release: n
    };
  }
  i(sUe, "reusify");
  rV.exports = sUe;
});

// ../node_modules/fastq/queue.js
var iV = y((dut, VC) => {
  "use strict";
  var nUe = sV();
  function nV(e, t, r) {
    if (typeof e == "function" && (r = t, t = e, e = null), r < 1)
      throw new Error("fastqueue concurrency must be greater than 1");
    var s = nUe(iUe), n = null, a = null, o = 0, l = null, u = {
      push: h,
      drain: tn,
      saturated: tn,
      pause: f,
      paused: !1,
      concurrency: r,
      running: c,
      resume: m,
      idle: b,
      length: p,
      getQueue: d,
      unshift: g,
      empty: tn,
      kill: D,
      killAndDrain: C,
      error: N
    };
    return u;
    function c() {
      return o;
    }
    function f() {
      u.paused = !0;
    }
    function p() {
      for (var I = n, M = 0; I; )
        I = I.next, M++;
      return M;
    }
    function d() {
      for (var I = n, M = []; I; )
        M.push(I.value), I = I.next;
      return M;
    }
    function m() {
      if (u.paused) {
        u.paused = !1;
        for (var I = 0; I < u.concurrency; I++)
          o++, E();
      }
    }
    function b() {
      return o === 0 && u.length() === 0;
    }
    function h(I, M) {
      var q = s.get();
      q.context = e, q.release = E, q.value = I, q.callback = M || tn, q.errorHandler = l, o === u.concurrency || u.paused ? a ? (a.next = q,
      a = q) : (n = q, a = q, u.saturated()) : (o++, t.call(e, q.value, q.worked));
    }
    function g(I, M) {
      var q = s.get();
      q.context = e, q.release = E, q.value = I, q.callback = M || tn, o === u.concurrency || u.paused ? n ? (q.next = n, n = q) : (n = q, a =
      q, u.saturated()) : (o++, t.call(e, q.value, q.worked));
    }
    function E(I) {
      I && s.release(I);
      var M = n;
      M ? u.paused ? o-- : (a === n && (a = null), n = M.next, M.next = null, t.call(e, M.value, M.worked), a === null && u.empty()) : --o ===
      0 && u.drain();
    }
    function D() {
      n = null, a = null, u.drain = tn;
    }
    function C() {
      n = null, a = null, u.drain(), u.drain = tn;
    }
    function N(I) {
      l = I;
    }
  }
  i(nV, "fastqueue");
  function tn() {
  }
  i(tn, "noop");
  function iUe() {
    this.value = null, this.callback = tn, this.next = null, this.release = tn, this.context = null, this.errorHandler = null;
    var e = this;
    this.worked = /* @__PURE__ */ i(function(r, s) {
      var n = e.callback, a = e.errorHandler, o = e.value;
      e.value = null, e.callback = tn, e.errorHandler && a(r, o), n.call(e.context, r, s), e.release(e);
    }, "worked");
  }
  i(iUe, "Task");
  function aUe(e, t, r) {
    typeof e == "function" && (r = t, t = e, e = null);
    function s(f, p) {
      t.call(this, f).then(function(d) {
        p(null, d);
      }, p);
    }
    i(s, "asyncWrapper");
    var n = nV(e, s, r), a = n.push, o = n.unshift;
    return n.push = l, n.unshift = u, n.drained = c, n;
    function l(f) {
      var p = new Promise(function(d, m) {
        a(f, function(b, h) {
          if (b) {
            m(b);
            return;
          }
          d(h);
        });
      });
      return p.catch(tn), p;
    }
    i(l, "push");
    function u(f) {
      var p = new Promise(function(d, m) {
        o(f, function(b, h) {
          if (b) {
            m(b);
            return;
          }
          d(h);
        });
      });
      return p.catch(tn), p;
    }
    i(u, "unshift");
    function c() {
      if (n.idle())
        return new Promise(function(d) {
          d();
        });
      var f = n.drain, p = new Promise(function(d) {
        n.drain = function() {
          f(), d();
        };
      });
      return p;
    }
    i(c, "drained");
  }
  i(aUe, "queueAsPromised");
  VC.exports = nV;
  VC.exports.promise = aUe;
});

// ../node_modules/@nodelib/fs.walk/out/readers/common.js
var n0 = y((Qn) => {
  "use strict";
  Object.defineProperty(Qn, "__esModule", { value: !0 });
  Qn.joinPathSegments = Qn.replacePathSegmentSeparator = Qn.isAppliedFilter = Qn.isFatalError = void 0;
  function oUe(e, t) {
    return e.errorFilter === null ? !0 : !e.errorFilter(t);
  }
  i(oUe, "isFatalError");
  Qn.isFatalError = oUe;
  function lUe(e, t) {
    return e === null || e(t);
  }
  i(lUe, "isAppliedFilter");
  Qn.isAppliedFilter = lUe;
  function uUe(e, t) {
    return e.split(/[/\\]/).join(t);
  }
  i(uUe, "replacePathSegmentSeparator");
  Qn.replacePathSegmentSeparator = uUe;
  function cUe(e, t, r) {
    return e === "" ? t : e.endsWith(r) ? e + t : e + r + t;
  }
  i(cUe, "joinPathSegments");
  Qn.joinPathSegments = cUe;
});

// ../node_modules/@nodelib/fs.walk/out/readers/reader.js
var GC = y((HC) => {
  "use strict";
  Object.defineProperty(HC, "__esModule", { value: !0 });
  var fUe = n0(), WC = class {
    static {
      i(this, "Reader");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._root = fUe.replacePathSegmentSeparator(t, r.pathSegmentSeparator);
    }
  };
  HC.default = WC;
});

// ../node_modules/@nodelib/fs.walk/out/readers/async.js
var XC = y((YC) => {
  "use strict";
  Object.defineProperty(YC, "__esModule", { value: !0 });
  var pUe = require("events"), dUe = s0(), hUe = iV(), i0 = n0(), mUe = GC(), KC = class extends mUe.default {
    static {
      i(this, "AsyncReader");
    }
    constructor(t, r) {
      super(t, r), this._settings = r, this._scandir = dUe.scandir, this._emitter = new pUe.EventEmitter(), this._queue = hUe(this._worker.bind(
      this), this._settings.concurrency), this._isFatalError = !1, this._isDestroyed = !1, this._queue.drain = () => {
        this._isFatalError || this._emitter.emit("end");
      };
    }
    read() {
      return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(() => {
        this._pushToQueue(this._root, this._settings.basePath);
      }), this._emitter;
    }
    get isDestroyed() {
      return this._isDestroyed;
    }
    destroy() {
      if (this._isDestroyed)
        throw new Error("The reader is already destroyed");
      this._isDestroyed = !0, this._queue.killAndDrain();
    }
    onEntry(t) {
      this._emitter.on("entry", t);
    }
    onError(t) {
      this._emitter.once("error", t);
    }
    onEnd(t) {
      this._emitter.once("end", t);
    }
    _pushToQueue(t, r) {
      let s = { directory: t, base: r };
      this._queue.push(s, (n) => {
        n !== null && this._handleError(n);
      });
    }
    _worker(t, r) {
      this._scandir(t.directory, this._settings.fsScandirSettings, (s, n) => {
        if (s !== null) {
          r(s, void 0);
          return;
        }
        for (let a of n)
          this._handleEntry(a, t.base);
        r(null, void 0);
      });
    }
    _handleError(t) {
      this._isDestroyed || !i0.isFatalError(this._settings, t) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("erro\
r", t));
    }
    _handleEntry(t, r) {
      if (this._isDestroyed || this._isFatalError)
        return;
      let s = t.path;
      r !== void 0 && (t.path = i0.joinPathSegments(r, t.name, this._settings.pathSegmentSeparator)), i0.isAppliedFilter(this._settings.entryFilter,
      t) && this._emitEntry(t), t.dirent.isDirectory() && i0.isAppliedFilter(this._settings.deepFilter, t) && this._pushToQueue(s, r === void 0 ?
      void 0 : t.path);
    }
    _emitEntry(t) {
      this._emitter.emit("entry", t);
    }
  };
  YC.default = KC;
});

// ../node_modules/@nodelib/fs.walk/out/providers/async.js
var aV = y((JC) => {
  "use strict";
  Object.defineProperty(JC, "__esModule", { value: !0 });
  var yUe = XC(), zC = class {
    static {
      i(this, "AsyncProvider");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._reader = new yUe.default(this._root, this._settings), this._storage = [];
    }
    read(t) {
      this._reader.onError((r) => {
        gUe(t, r);
      }), this._reader.onEntry((r) => {
        this._storage.push(r);
      }), this._reader.onEnd(() => {
        bUe(t, this._storage);
      }), this._reader.read();
    }
  };
  JC.default = zC;
  function gUe(e, t) {
    e(t);
  }
  i(gUe, "callFailureCallback");
  function bUe(e, t) {
    e(null, t);
  }
  i(bUe, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.walk/out/providers/stream.js
var oV = y((ZC) => {
  "use strict";
  Object.defineProperty(ZC, "__esModule", { value: !0 });
  var EUe = require("stream"), vUe = XC(), QC = class {
    static {
      i(this, "StreamProvider");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._reader = new vUe.default(this._root, this._settings), this._stream = new EUe.Readable({
        objectMode: !0,
        read: /* @__PURE__ */ i(() => {
        }, "read"),
        destroy: /* @__PURE__ */ i(() => {
          this._reader.isDestroyed || this._reader.destroy();
        }, "destroy")
      });
    }
    read() {
      return this._reader.onError((t) => {
        this._stream.emit("error", t);
      }), this._reader.onEntry((t) => {
        this._stream.push(t);
      }), this._reader.onEnd(() => {
        this._stream.push(null);
      }), this._reader.read(), this._stream;
    }
  };
  ZC.default = QC;
});

// ../node_modules/@nodelib/fs.walk/out/readers/sync.js
var lV = y((tw) => {
  "use strict";
  Object.defineProperty(tw, "__esModule", { value: !0 });
  var SUe = s0(), a0 = n0(), TUe = GC(), ew = class extends TUe.default {
    static {
      i(this, "SyncReader");
    }
    constructor() {
      super(...arguments), this._scandir = SUe.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
    }
    read() {
      return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
    }
    _pushToQueue(t, r) {
      this._queue.add({ directory: t, base: r });
    }
    _handleQueue() {
      for (let t of this._queue.values())
        this._handleDirectory(t.directory, t.base);
    }
    _handleDirectory(t, r) {
      try {
        let s = this._scandir(t, this._settings.fsScandirSettings);
        for (let n of s)
          this._handleEntry(n, r);
      } catch (s) {
        this._handleError(s);
      }
    }
    _handleError(t) {
      if (a0.isFatalError(this._settings, t))
        throw t;
    }
    _handleEntry(t, r) {
      let s = t.path;
      r !== void 0 && (t.path = a0.joinPathSegments(r, t.name, this._settings.pathSegmentSeparator)), a0.isAppliedFilter(this._settings.entryFilter,
      t) && this._pushToStorage(t), t.dirent.isDirectory() && a0.isAppliedFilter(this._settings.deepFilter, t) && this._pushToQueue(s, r ===
      void 0 ? void 0 : t.path);
    }
    _pushToStorage(t) {
      this._storage.push(t);
    }
  };
  tw.default = ew;
});

// ../node_modules/@nodelib/fs.walk/out/providers/sync.js
var uV = y((sw) => {
  "use strict";
  Object.defineProperty(sw, "__esModule", { value: !0 });
  var xUe = lV(), rw = class {
    static {
      i(this, "SyncProvider");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._reader = new xUe.default(this._root, this._settings);
    }
    read() {
      return this._reader.read();
    }
  };
  sw.default = rw;
});

// ../node_modules/@nodelib/fs.walk/out/settings.js
var cV = y((iw) => {
  "use strict";
  Object.defineProperty(iw, "__esModule", { value: !0 });
  var PUe = require("path"), AUe = s0(), nw = class {
    static {
      i(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency,
      Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.
      entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this.
      _options.pathSegmentSeparator, PUe.sep), this.fsScandirSettings = new AUe.Settings({
        followSymbolicLinks: this._options.followSymbolicLinks,
        fs: this._options.fs,
        pathSegmentSeparator: this._options.pathSegmentSeparator,
        stats: this._options.stats,
        throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(t, r) {
      return t ?? r;
    }
  };
  iw.default = nw;
});

// ../node_modules/@nodelib/fs.walk/out/index.js
var l0 = y((Zn) => {
  "use strict";
  Object.defineProperty(Zn, "__esModule", { value: !0 });
  Zn.Settings = Zn.walkStream = Zn.walkSync = Zn.walk = void 0;
  var fV = aV(), CUe = oV(), wUe = uV(), aw = cV();
  Zn.Settings = aw.default;
  function DUe(e, t, r) {
    if (typeof t == "function") {
      new fV.default(e, o0()).read(t);
      return;
    }
    new fV.default(e, o0(t)).read(r);
  }
  i(DUe, "walk");
  Zn.walk = DUe;
  function IUe(e, t) {
    let r = o0(t);
    return new wUe.default(e, r).read();
  }
  i(IUe, "walkSync");
  Zn.walkSync = IUe;
  function _Ue(e, t) {
    let r = o0(t);
    return new CUe.default(e, r).read();
  }
  i(_Ue, "walkStream");
  Zn.walkStream = _Ue;
  function o0(e = {}) {
    return e instanceof aw.default ? e : new aw.default(e);
  }
  i(o0, "getSettings");
});

// ../node_modules/fast-glob/out/readers/reader.js
var u0 = y((lw) => {
  "use strict";
  Object.defineProperty(lw, "__esModule", { value: !0 });
  var OUe = require("path"), NUe = Fo(), pV = ji(), ow = class {
    static {
      i(this, "Reader");
    }
    constructor(t) {
      this._settings = t, this._fsStatSettings = new NUe.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }
    _getFullEntryPath(t) {
      return OUe.resolve(this._settings.cwd, t);
    }
    _makeEntry(t, r) {
      let s = {
        name: r,
        path: r,
        dirent: pV.fs.createDirentFromStats(r, t)
      };
      return this._settings.stats && (s.stats = t), s;
    }
    _isFatalError(t) {
      return !pV.errno.isEnoentCodeError(t) && !this._settings.suppressErrors;
    }
  };
  lw.default = ow;
});

// ../node_modules/fast-glob/out/readers/stream.js
var fw = y((cw) => {
  "use strict";
  Object.defineProperty(cw, "__esModule", { value: !0 });
  var RUe = require("stream"), kUe = Fo(), FUe = l0(), LUe = u0(), uw = class extends LUe.default {
    static {
      i(this, "ReaderStream");
    }
    constructor() {
      super(...arguments), this._walkStream = FUe.walkStream, this._stat = kUe.stat;
    }
    dynamic(t, r) {
      return this._walkStream(t, r);
    }
    static(t, r) {
      let s = t.map(this._getFullEntryPath, this), n = new RUe.PassThrough({ objectMode: !0 });
      n._write = (a, o, l) => this._getEntry(s[a], t[a], r).then((u) => {
        u !== null && r.entryFilter(u) && n.push(u), a === s.length - 1 && n.end(), l();
      }).catch(l);
      for (let a = 0; a < s.length; a++)
        n.write(a);
      return n;
    }
    _getEntry(t, r, s) {
      return this._getStat(t).then((n) => this._makeEntry(n, r)).catch((n) => {
        if (s.errorFilter(n))
          return null;
        throw n;
      });
    }
    _getStat(t) {
      return new Promise((r, s) => {
        this._stat(t, this._fsStatSettings, (n, a) => n === null ? r(a) : s(n));
      });
    }
  };
  cw.default = uw;
});

// ../node_modules/fast-glob/out/readers/async.js
var dV = y((dw) => {
  "use strict";
  Object.defineProperty(dw, "__esModule", { value: !0 });
  var BUe = l0(), MUe = u0(), jUe = fw(), pw = class extends MUe.default {
    static {
      i(this, "ReaderAsync");
    }
    constructor() {
      super(...arguments), this._walkAsync = BUe.walk, this._readerStream = new jUe.default(this._settings);
    }
    dynamic(t, r) {
      return new Promise((s, n) => {
        this._walkAsync(t, r, (a, o) => {
          a === null ? s(o) : n(a);
        });
      });
    }
    async static(t, r) {
      let s = [], n = this._readerStream.static(t, r);
      return new Promise((a, o) => {
        n.once("error", o), n.on("data", (l) => s.push(l)), n.once("end", () => a(s));
      });
    }
  };
  dw.default = pw;
});

// ../node_modules/fast-glob/out/providers/matchers/matcher.js
var hV = y((mw) => {
  "use strict";
  Object.defineProperty(mw, "__esModule", { value: !0 });
  var Qf = ji(), hw = class {
    static {
      i(this, "Matcher");
    }
    constructor(t, r, s) {
      this._patterns = t, this._settings = r, this._micromatchOptions = s, this._storage = [], this._fillStorage();
    }
    _fillStorage() {
      for (let t of this._patterns) {
        let r = this._getPatternSegments(t), s = this._splitSegmentsIntoSections(r);
        this._storage.push({
          complete: s.length <= 1,
          pattern: t,
          segments: r,
          sections: s
        });
      }
    }
    _getPatternSegments(t) {
      return Qf.pattern.getPatternParts(t, this._micromatchOptions).map((s) => Qf.pattern.isDynamicPattern(s, this._settings) ? {
        dynamic: !0,
        pattern: s,
        patternRe: Qf.pattern.makeRe(s, this._micromatchOptions)
      } : {
        dynamic: !1,
        pattern: s
      });
    }
    _splitSegmentsIntoSections(t) {
      return Qf.array.splitWhen(t, (r) => r.dynamic && Qf.pattern.hasGlobStar(r.pattern));
    }
  };
  mw.default = hw;
});

// ../node_modules/fast-glob/out/providers/matchers/partial.js
var mV = y((gw) => {
  "use strict";
  Object.defineProperty(gw, "__esModule", { value: !0 });
  var qUe = hV(), yw = class extends qUe.default {
    static {
      i(this, "PartialMatcher");
    }
    match(t) {
      let r = t.split("/"), s = r.length, n = this._storage.filter((a) => !a.complete || a.segments.length > s);
      for (let a of n) {
        let o = a.sections[0];
        if (!a.complete && s > o.length || r.every((u, c) => {
          let f = a.segments[c];
          return !!(f.dynamic && f.patternRe.test(u) || !f.dynamic && f.pattern === u);
        }))
          return !0;
      }
      return !1;
    }
  };
  gw.default = yw;
});

// ../node_modules/fast-glob/out/providers/filters/deep.js
var yV = y((Ew) => {
  "use strict";
  Object.defineProperty(Ew, "__esModule", { value: !0 });
  var c0 = ji(), $Ue = mV(), bw = class {
    static {
      i(this, "DeepFilter");
    }
    constructor(t, r) {
      this._settings = t, this._micromatchOptions = r;
    }
    getFilter(t, r, s) {
      let n = this._getMatcher(r), a = this._getNegativePatternsRe(s);
      return (o) => this._filter(t, o, n, a);
    }
    _getMatcher(t) {
      return new $Ue.default(t, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(t) {
      let r = t.filter(c0.pattern.isAffectDepthOfReadingPattern);
      return c0.pattern.convertPatternsToRe(r, this._micromatchOptions);
    }
    _filter(t, r, s, n) {
      if (this._isSkippedByDeep(t, r.path) || this._isSkippedSymbolicLink(r))
        return !1;
      let a = c0.path.removeLeadingDotSegment(r.path);
      return this._isSkippedByPositivePatterns(a, s) ? !1 : this._isSkippedByNegativePatterns(a, n);
    }
    _isSkippedByDeep(t, r) {
      return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(t, r) >= this._settings.deep;
    }
    _getEntryLevel(t, r) {
      let s = r.split("/").length;
      if (t === "")
        return s;
      let n = t.split("/").length;
      return s - n;
    }
    _isSkippedSymbolicLink(t) {
      return !this._settings.followSymbolicLinks && t.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(t, r) {
      return !this._settings.baseNameMatch && !r.match(t);
    }
    _isSkippedByNegativePatterns(t, r) {
      return !c0.pattern.matchAny(t, r);
    }
  };
  Ew.default = bw;
});

// ../node_modules/fast-glob/out/providers/filters/entry.js
var gV = y((Sw) => {
  "use strict";
  Object.defineProperty(Sw, "__esModule", { value: !0 });
  var Lo = ji(), vw = class {
    static {
      i(this, "EntryFilter");
    }
    constructor(t, r) {
      this._settings = t, this._micromatchOptions = r, this.index = /* @__PURE__ */ new Map();
    }
    getFilter(t, r) {
      let s = Lo.pattern.convertPatternsToRe(t, this._micromatchOptions), n = Lo.pattern.convertPatternsToRe(r, Object.assign(Object.assign(
      {}, this._micromatchOptions), { dot: !0 }));
      return (a) => this._filter(a, s, n);
    }
    _filter(t, r, s) {
      let n = Lo.path.removeLeadingDotSegment(t.path);
      if (this._settings.unique && this._isDuplicateEntry(n) || this._onlyFileFilter(t) || this._onlyDirectoryFilter(t) || this._isSkippedByAbsoluteNegativePatterns(
      n, s))
        return !1;
      let a = t.dirent.isDirectory(), o = this._isMatchToPatterns(n, r, a) && !this._isMatchToPatterns(n, s, a);
      return this._settings.unique && o && this._createIndexRecord(n), o;
    }
    _isDuplicateEntry(t) {
      return this.index.has(t);
    }
    _createIndexRecord(t) {
      this.index.set(t, void 0);
    }
    _onlyFileFilter(t) {
      return this._settings.onlyFiles && !t.dirent.isFile();
    }
    _onlyDirectoryFilter(t) {
      return this._settings.onlyDirectories && !t.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(t, r) {
      if (!this._settings.absolute)
        return !1;
      let s = Lo.path.makeAbsolute(this._settings.cwd, t);
      return Lo.pattern.matchAny(s, r);
    }
    _isMatchToPatterns(t, r, s) {
      let n = Lo.pattern.matchAny(t, r);
      return !n && s ? Lo.pattern.matchAny(t + "/", r) : n;
    }
  };
  Sw.default = vw;
});

// ../node_modules/fast-glob/out/providers/filters/error.js
var bV = y((xw) => {
  "use strict";
  Object.defineProperty(xw, "__esModule", { value: !0 });
  var UUe = ji(), Tw = class {
    static {
      i(this, "ErrorFilter");
    }
    constructor(t) {
      this._settings = t;
    }
    getFilter() {
      return (t) => this._isNonFatalError(t);
    }
    _isNonFatalError(t) {
      return UUe.errno.isEnoentCodeError(t) || this._settings.suppressErrors;
    }
  };
  xw.default = Tw;
});

// ../node_modules/fast-glob/out/providers/transformers/entry.js
var vV = y((Aw) => {
  "use strict";
  Object.defineProperty(Aw, "__esModule", { value: !0 });
  var EV = ji(), Pw = class {
    static {
      i(this, "EntryTransformer");
    }
    constructor(t) {
      this._settings = t;
    }
    getTransformer() {
      return (t) => this._transform(t);
    }
    _transform(t) {
      let r = t.path;
      return this._settings.absolute && (r = EV.path.makeAbsolute(this._settings.cwd, r), r = EV.path.unixify(r)), this._settings.markDirectories &&
      t.dirent.isDirectory() && (r += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, t), { path: r }) : r;
    }
  };
  Aw.default = Pw;
});

// ../node_modules/fast-glob/out/providers/provider.js
var f0 = y((ww) => {
  "use strict";
  Object.defineProperty(ww, "__esModule", { value: !0 });
  var VUe = require("path"), WUe = yV(), HUe = gV(), GUe = bV(), KUe = vV(), Cw = class {
    static {
      i(this, "Provider");
    }
    constructor(t) {
      this._settings = t, this.errorFilter = new GUe.default(this._settings), this.entryFilter = new HUe.default(this._settings, this._getMicromatchOptions()),
      this.deepFilter = new WUe.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new KUe.default(this._settings);
    }
    _getRootDirectory(t) {
      return VUe.resolve(this._settings.cwd, t.base);
    }
    _getReaderOptions(t) {
      let r = t.base === "." ? "" : t.base;
      return {
        basePath: r,
        pathSegmentSeparator: "/",
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(r, t.positive, t.negative),
        entryFilter: this.entryFilter.getFilter(t.positive, t.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }
    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: !0,
        strictSlashes: !1
      };
    }
  };
  ww.default = Cw;
});

// ../node_modules/fast-glob/out/providers/async.js
var SV = y((Iw) => {
  "use strict";
  Object.defineProperty(Iw, "__esModule", { value: !0 });
  var YUe = dV(), XUe = f0(), Dw = class extends XUe.default {
    static {
      i(this, "ProviderAsync");
    }
    constructor() {
      super(...arguments), this._reader = new YUe.default(this._settings);
    }
    async read(t) {
      let r = this._getRootDirectory(t), s = this._getReaderOptions(t);
      return (await this.api(r, t, s)).map((a) => s.transform(a));
    }
    api(t, r, s) {
      return r.dynamic ? this._reader.dynamic(t, s) : this._reader.static(r.patterns, s);
    }
  };
  Iw.default = Dw;
});

// ../node_modules/fast-glob/out/providers/stream.js
var TV = y((Ow) => {
  "use strict";
  Object.defineProperty(Ow, "__esModule", { value: !0 });
  var zUe = require("stream"), JUe = fw(), QUe = f0(), _w = class extends QUe.default {
    static {
      i(this, "ProviderStream");
    }
    constructor() {
      super(...arguments), this._reader = new JUe.default(this._settings);
    }
    read(t) {
      let r = this._getRootDirectory(t), s = this._getReaderOptions(t), n = this.api(r, t, s), a = new zUe.Readable({ objectMode: !0, read: /* @__PURE__ */ i(
      () => {
      }, "read") });
      return n.once("error", (o) => a.emit("error", o)).on("data", (o) => a.emit("data", s.transform(o))).once("end", () => a.emit("end")), a.
      once("close", () => n.destroy()), a;
    }
    api(t, r, s) {
      return r.dynamic ? this._reader.dynamic(t, s) : this._reader.static(r.patterns, s);
    }
  };
  Ow.default = _w;
});

// ../node_modules/fast-glob/out/readers/sync.js
var xV = y((Rw) => {
  "use strict";
  Object.defineProperty(Rw, "__esModule", { value: !0 });
  var ZUe = Fo(), eVe = l0(), tVe = u0(), Nw = class extends tVe.default {
    static {
      i(this, "ReaderSync");
    }
    constructor() {
      super(...arguments), this._walkSync = eVe.walkSync, this._statSync = ZUe.statSync;
    }
    dynamic(t, r) {
      return this._walkSync(t, r);
    }
    static(t, r) {
      let s = [];
      for (let n of t) {
        let a = this._getFullEntryPath(n), o = this._getEntry(a, n, r);
        o === null || !r.entryFilter(o) || s.push(o);
      }
      return s;
    }
    _getEntry(t, r, s) {
      try {
        let n = this._getStat(t);
        return this._makeEntry(n, r);
      } catch (n) {
        if (s.errorFilter(n))
          return null;
        throw n;
      }
    }
    _getStat(t) {
      return this._statSync(t, this._fsStatSettings);
    }
  };
  Rw.default = Nw;
});

// ../node_modules/fast-glob/out/providers/sync.js
var PV = y((Fw) => {
  "use strict";
  Object.defineProperty(Fw, "__esModule", { value: !0 });
  var rVe = xV(), sVe = f0(), kw = class extends sVe.default {
    static {
      i(this, "ProviderSync");
    }
    constructor() {
      super(...arguments), this._reader = new rVe.default(this._settings);
    }
    read(t) {
      let r = this._getRootDirectory(t), s = this._getReaderOptions(t);
      return this.api(r, t, s).map(s.transform);
    }
    api(t, r, s) {
      return r.dynamic ? this._reader.dynamic(t, s) : this._reader.static(r.patterns, s);
    }
  };
  Fw.default = kw;
});

// ../node_modules/fast-glob/out/settings.js
var AV = y((bu) => {
  "use strict";
  Object.defineProperty(bu, "__esModule", { value: !0 });
  bu.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  var gu = require("fs"), nVe = require("os"), iVe = Math.max(nVe.cpus().length, 1);
  bu.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: gu.lstat,
    lstatSync: gu.lstatSync,
    stat: gu.stat,
    statSync: gu.statSync,
    readdir: gu.readdir,
    readdirSync: gu.readdirSync
  };
  var Lw = class {
    static {
      i(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch,
      !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch,
      !0), this.concurrency = this._getValue(this._options.concurrency, iVe), this.cwd = this._getValue(this._options.cwd, process.cwd()), this.
      deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this.
      _options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(
      this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []),
      this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1),
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0),
      this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink =
      this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories &&
      (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
    }
    _getValue(t, r) {
      return t === void 0 ? r : t;
    }
    _getFileSystemMethods(t = {}) {
      return Object.assign(Object.assign({}, bu.DEFAULT_FILE_SYSTEM_ADAPTER), t);
    }
  };
  bu.default = Lw;
});

// ../node_modules/fast-glob/out/index.js
var qw = y((uct, wV) => {
  "use strict";
  var CV = wU(), aVe = SV(), oVe = TV(), lVe = PV(), Bw = AV(), rn = ji();
  async function Mw(e, t) {
    Cn(e);
    let r = jw(e, aVe.default, t), s = await Promise.all(r);
    return rn.array.flatten(s);
  }
  i(Mw, "FastGlob");
  (function(e) {
    e.glob = e, e.globSync = t, e.globStream = r, e.async = e;
    function t(c, f) {
      Cn(c);
      let p = jw(c, lVe.default, f);
      return rn.array.flatten(p);
    }
    i(t, "sync"), e.sync = t;
    function r(c, f) {
      Cn(c);
      let p = jw(c, oVe.default, f);
      return rn.stream.merge(p);
    }
    i(r, "stream"), e.stream = r;
    function s(c, f) {
      Cn(c);
      let p = [].concat(c), d = new Bw.default(f);
      return CV.generate(p, d);
    }
    i(s, "generateTasks"), e.generateTasks = s;
    function n(c, f) {
      Cn(c);
      let p = new Bw.default(f);
      return rn.pattern.isDynamicPattern(c, p);
    }
    i(n, "isDynamicPattern"), e.isDynamicPattern = n;
    function a(c) {
      return Cn(c), rn.path.escape(c);
    }
    i(a, "escapePath"), e.escapePath = a;
    function o(c) {
      return Cn(c), rn.path.convertPathToPattern(c);
    }
    i(o, "convertPathToPattern"), e.convertPathToPattern = o;
    let l;
    (function(c) {
      function f(d) {
        return Cn(d), rn.path.escapePosixPath(d);
      }
      i(f, "escapePath"), c.escapePath = f;
      function p(d) {
        return Cn(d), rn.path.convertPosixPathToPattern(d);
      }
      i(p, "convertPathToPattern"), c.convertPathToPattern = p;
    })(l = e.posix || (e.posix = {}));
    let u;
    (function(c) {
      function f(d) {
        return Cn(d), rn.path.escapeWindowsPath(d);
      }
      i(f, "escapePath"), c.escapePath = f;
      function p(d) {
        return Cn(d), rn.path.convertWindowsPathToPattern(d);
      }
      i(p, "convertPathToPattern"), c.convertPathToPattern = p;
    })(u = e.win32 || (e.win32 = {}));
  })(Mw || (Mw = {}));
  function jw(e, t, r) {
    let s = [].concat(e), n = new Bw.default(r), a = CV.generate(s, n), o = new t(n);
    return a.map(o.read, o);
  }
  i(jw, "getWorks");
  function Cn(e) {
    if (![].concat(e).every((s) => rn.string.isString(s) && !rn.string.isEmpty(s)))
      throw new TypeError("Patterns must be a string (non empty) or an array of strings");
  }
  i(Cn, "assertPatternsInput");
  wV.exports = Mw;
});

// ../node_modules/globby/node_modules/path-type/index.js
async function $w(e, t, r) {
  if (typeof r != "string")
    throw new TypeError(`Expected a string, got ${typeof r}`);
  try {
    return (await p0.promises[e](r))[t]();
  } catch (s) {
    if (s.code === "ENOENT")
      return !1;
    throw s;
  }
}
function Uw(e, t, r) {
  if (typeof r != "string")
    throw new TypeError(`Expected a string, got ${typeof r}`);
  try {
    return p0.default[e](r)[t]();
  } catch (s) {
    if (s.code === "ENOENT")
      return !1;
    throw s;
  }
}
var p0, fct, DV, pct, dct, IV, hct, _V = ei(() => {
  p0 = Ve(require("fs"), 1);
  i($w, "isType");
  i(Uw, "isTypeSync");
  fct = $w.bind(null, "stat", "isFile"), DV = $w.bind(null, "stat", "isDirectory"), pct = $w.bind(null, "lstat", "isSymbolicLink"), dct = Uw.
  bind(null, "statSync", "isFile"), IV = Uw.bind(null, "statSync", "isDirectory"), hct = Uw.bind(null, "lstatSync", "isSymbolicLink");
});

// ../node_modules/unicorn-magic/default.js
var OV = ei(() => {
});

// ../node_modules/unicorn-magic/node.js
function Zf(e) {
  return e instanceof URL ? (0, NV.fileURLToPath)(e) : e;
}
var NV, Vw = ei(() => {
  NV = require("node:url");
  OV();
  i(Zf, "toPath");
});

// ../node_modules/ignore/index.js
var $V = y((Tct, qV) => {
  function RV(e) {
    return Array.isArray(e) ? e : [e];
  }
  i(RV, "makeArray");
  var Gw = "", kV = " ", Ww = "\\", uVe = /^\s+$/, cVe = /(?:[^\\]|^)\\$/, fVe = /^\\!/, pVe = /^\\#/, dVe = /\r?\n/g, hVe = /^\.*\/|^\.+$/,
  Hw = "/", BV = "node-ignore";
  typeof Symbol < "u" && (BV = Symbol.for("node-ignore"));
  var FV = BV, mVe = /* @__PURE__ */ i((e, t, r) => Object.defineProperty(e, t, { value: r }), "define"), yVe = /([0-z])-([0-z])/g, MV = /* @__PURE__ */ i(
  () => !1, "RETURN_FALSE"), gVe = /* @__PURE__ */ i((e) => e.replace(
    yVe,
    (t, r, s) => r.charCodeAt(0) <= s.charCodeAt(0) ? t : Gw
  ), "sanitizeRange"), bVe = /* @__PURE__ */ i((e) => {
    let { length: t } = e;
    return e.slice(0, t - t % 2);
  }, "cleanRangeBackSlash"), EVe = [
    [
      // remove BOM
      // TODO:
      // Other similar zero-width characters?
      /^\uFEFF/,
      () => Gw
    ],
    // > Trailing spaces are ignored unless they are quoted with backslash ("\")
    [
      // (a\ ) -> (a )
      // (a  ) -> (a)
      // (a \ ) -> (a  )
      /\\?\s+$/,
      (e) => e.indexOf("\\") === 0 ? kV : Gw
    ],
    // replace (\ ) with ' '
    [
      /\\\s/g,
      () => kV
    ],
    // Escape metacharacters
    // which is written down by users but means special for regular expressions.
    // > There are 12 characters with special meanings:
    // > - the backslash \,
    // > - the caret ^,
    // > - the dollar sign $,
    // > - the period or dot .,
    // > - the vertical bar or pipe symbol |,
    // > - the question mark ?,
    // > - the asterisk or star *,
    // > - the plus sign +,
    // > - the opening parenthesis (,
    // > - the closing parenthesis ),
    // > - and the opening square bracket [,
    // > - the opening curly brace {,
    // > These special characters are often called "metacharacters".
    [
      /[\\$.|*+(){^]/g,
      (e) => `\\${e}`
    ],
    [
      // > a question mark (?) matches a single character
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    // leading slash
    [
      // > A leading slash matches the beginning of the pathname.
      // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
      // A leading slash matches the beginning of the pathname
      /^\//,
      () => "^"
    ],
    // replace special metacharacter slash after the leading slash
    [
      /\//g,
      () => "\\/"
    ],
    [
      // > A leading "**" followed by a slash means match in all directories.
      // > For example, "**/foo" matches file or directory "foo" anywhere,
      // > the same as pattern "foo".
      // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
      // >   under directory "foo".
      // Notice that the '*'s have been replaced as '\\*'
      /^\^*\\\*\\\*\\\//,
      // '**/foo' <-> 'foo'
      () => "^(?:.*\\/)?"
    ],
    // starting
    [
      // there will be no leading '/'
      //   (which has been replaced by section "leading slash")
      // If starts with '**', adding a '^' to the regular expression also works
      /^(?=[^^])/,
      /* @__PURE__ */ i(function() {
        return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
      }, "startingReplacer")
    ],
    // two globstars
    [
      // Use lookahead assertions so that we could match more than one `'/**'`
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      // Zero, one or several directories
      // should not use '*', or it will be replaced by the next replacer
      // Check if it is not the last `'/**'`
      (e, t, r) => t + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    // normal intermediate wildcards
    [
      // Never replace escaped '*'
      // ignore rule '\*' will match the path '*'
      // 'abc.*/' -> go
      // 'abc.*'  -> skip this rule,
      //    coz trailing single wildcard will be handed by [trailing wildcard]
      /(^|[^\\]+)(\\\*)+(?=.+)/g,
      // '*.js' matches '.js'
      // '*.js' doesn't match 'abc'
      (e, t, r) => {
        let s = r.replace(/\\\*/g, "[^\\/]*");
        return t + s;
      }
    ],
    [
      // unescape, revert step 3 except for back slash
      // For example, if a user escape a '\\*',
      // after step 3, the result will be '\\\\\\*'
      /\\\\\\(?=[$.|*+(){^])/g,
      () => Ww
    ],
    [
      // '\\\\' -> '\\'
      /\\\\/g,
      () => Ww
    ],
    [
      // > The range notation, e.g. [a-zA-Z],
      // > can be used to match one of the characters in a range.
      // `\` is escaped by step 3
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (e, t, r, s, n) => t === Ww ? `\\[${r}${bVe(s)}${n}` : n === "]" && s.length % 2 === 0 ? `[${gVe(r)}${s}]` : "[]"
    ],
    // ending
    [
      // 'js' will not match 'js.'
      // 'ab' will not match 'abc'
      /(?:[^*])$/,
      // WTF!
      // https://git-scm.com/docs/gitignore
      // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
      // which re-fixes #24, #38
      // > If there is a separator at the end of the pattern then the pattern
      // > will only match directories, otherwise the pattern can match both
      // > files and directories.
      // 'js*' will not match 'a.js'
      // 'js/' will not match 'a.js'
      // 'js' will match 'a.js' and 'a.js/'
      (e) => /\/$/.test(e) ? `${e}$` : `${e}(?=$|\\/$)`
    ],
    // trailing wildcard
    [
      /(\^|\\\/)?\\\*$/,
      (e, t) => `${t ? `${t}[^/]+` : "[^/]*"}(?=$|\\/$)`
    ]
  ], LV = /* @__PURE__ */ Object.create(null), vVe = /* @__PURE__ */ i((e, t) => {
    let r = LV[e];
    return r || (r = EVe.reduce(
      (s, n) => s.replace(n[0], n[1].bind(e)),
      e
    ), LV[e] = r), t ? new RegExp(r, "i") : new RegExp(r);
  }, "makeRegex"), Xw = /* @__PURE__ */ i((e) => typeof e == "string", "isString"), SVe = /* @__PURE__ */ i((e) => e && Xw(e) && !uVe.test(e) &&
  !cVe.test(e) && e.indexOf("#") !== 0, "checkPattern"), TVe = /* @__PURE__ */ i((e) => e.split(dVe), "splitPattern"), Kw = class {
    static {
      i(this, "IgnoreRule");
    }
    constructor(t, r, s, n) {
      this.origin = t, this.pattern = r, this.negative = s, this.regex = n;
    }
  }, xVe = /* @__PURE__ */ i((e, t) => {
    let r = e, s = !1;
    e.indexOf("!") === 0 && (s = !0, e = e.substr(1)), e = e.replace(fVe, "!").replace(pVe, "#");
    let n = vVe(e, t);
    return new Kw(
      r,
      e,
      s,
      n
    );
  }, "createRule"), PVe = /* @__PURE__ */ i((e, t) => {
    throw new t(e);
  }, "throwError"), qi = /* @__PURE__ */ i((e, t, r) => Xw(e) ? e ? qi.isNotRelative(e) ? r(
    `path should be a \`path.relative()\`d string, but got "${t}"`,
    RangeError
  ) : !0 : r("path must not be empty", TypeError) : r(
    `path must be a string, but got \`${t}\``,
    TypeError
  ), "checkPath"), jV = /* @__PURE__ */ i((e) => hVe.test(e), "isNotRelative");
  qi.isNotRelative = jV;
  qi.convert = (e) => e;
  var Yw = class {
    static {
      i(this, "Ignore");
    }
    constructor({
      ignorecase: t = !0,
      ignoreCase: r = t,
      allowRelativePaths: s = !1
    } = {}) {
      mVe(this, FV, !0), this._rules = [], this._ignoreCase = r, this._allowRelativePaths = s, this._initCache();
    }
    _initCache() {
      this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
    }
    _addPattern(t) {
      if (t && t[FV]) {
        this._rules = this._rules.concat(t._rules), this._added = !0;
        return;
      }
      if (SVe(t)) {
        let r = xVe(t, this._ignoreCase);
        this._added = !0, this._rules.push(r);
      }
    }
    // @param {Array<string> | string | Ignore} pattern
    add(t) {
      return this._added = !1, RV(
        Xw(t) ? TVe(t) : t
      ).forEach(this._addPattern, this), this._added && this._initCache(), this;
    }
    // legacy
    addPattern(t) {
      return this.add(t);
    }
    //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X
    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen
    // @param {boolean} whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // @returns {TestResult} true if a file is ignored
    _testOne(t, r) {
      let s = !1, n = !1;
      return this._rules.forEach((a) => {
        let { negative: o } = a;
        if (n === o && s !== n || o && !s && !n && !r)
          return;
        a.regex.test(t) && (s = !o, n = o);
      }), {
        ignored: s,
        unignored: n
      };
    }
    // @returns {TestResult}
    _test(t, r, s, n) {
      let a = t && qi.convert(t);
      return qi(
        a,
        t,
        this._allowRelativePaths ? MV : PVe
      ), this._t(a, r, s, n);
    }
    _t(t, r, s, n) {
      if (t in r)
        return r[t];
      if (n || (n = t.split(Hw)), n.pop(), !n.length)
        return r[t] = this._testOne(t, s);
      let a = this._t(
        n.join(Hw) + Hw,
        r,
        s,
        n
      );
      return r[t] = a.ignored ? a : this._testOne(t, s);
    }
    ignores(t) {
      return this._test(t, this._ignoreCache, !1).ignored;
    }
    createFilter() {
      return (t) => !this.ignores(t);
    }
    filter(t) {
      return RV(t).filter(this.createFilter());
    }
    // @returns {TestResult}
    test(t) {
      return this._test(t, this._testCache, !0);
    }
  }, d0 = /* @__PURE__ */ i((e) => new Yw(e), "factory"), AVe = /* @__PURE__ */ i((e) => qi(e && qi.convert(e), e, MV), "isPathValid");
  d0.isPathValid = AVe;
  d0.default = d0;
  qV.exports = d0;
  if (
    // Detect `process` so that it can run in browsers.
    typeof process < "u" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
  ) {
    let e = /* @__PURE__ */ i((r) => /^\\\\\?\\/.test(r) || /["<>|\u0000-\u001F]+/u.test(r) ? r : r.replace(/\\/g, "/"), "makePosix");
    qi.convert = e;
    let t = /^[a-z]:\//i;
    qi.isNotRelative = (r) => t.test(r) || jV(r);
  }
});

// ../node_modules/slash/index.js
function Eu(e) {
  return e.startsWith("\\\\?\\") ? e : e.replace(/\\/g, "/");
}
var UV = ei(() => {
  i(Eu, "slash");
});

// ../node_modules/globby/utilities.js
var ep, zw = ei(() => {
  ep = /* @__PURE__ */ i((e) => e[0] === "!", "isNegativePattern");
});

// ../node_modules/globby/ignore.js
var VV, WV, HV, Bo, Jw, GV, CVe, KV, h0, wVe, DVe, IVe, YV, XV, Qw, Zw, zV, JV, eD = ei(() => {
  VV = Ve(require("node:process"), 1), WV = Ve(require("node:fs"), 1), HV = Ve(require("node:fs/promises"), 1), Bo = Ve(require("node:path"), 1),
  Jw = Ve(qw(), 1), GV = Ve($V(), 1);
  UV();
  Vw();
  zw();
  CVe = [
    "**/node_modules",
    "**/flow-typed",
    "**/coverage",
    "**/.git"
  ], KV = {
    absolute: !0,
    dot: !0
  }, h0 = "**/.gitignore", wVe = /* @__PURE__ */ i((e, t) => ep(e) ? "!" + Bo.default.posix.join(t, e.slice(1)) : Bo.default.posix.join(t, e),
  "applyBaseToPattern"), DVe = /* @__PURE__ */ i((e, t) => {
    let r = Eu(Bo.default.relative(t, Bo.default.dirname(e.filePath)));
    return e.content.split(/\r?\n/).filter((s) => s && !s.startsWith("#")).map((s) => wVe(s, r));
  }, "parseIgnoreFile"), IVe = /* @__PURE__ */ i((e, t) => {
    if (t = Eu(t), Bo.default.isAbsolute(e)) {
      if (Eu(e).startsWith(t))
        return Bo.default.relative(t, e);
      throw new Error(`Path ${e} is not in cwd ${t}`);
    }
    return e;
  }, "toRelativePath"), YV = /* @__PURE__ */ i((e, t) => {
    let r = e.flatMap((n) => DVe(n, t)), s = (0, GV.default)().add(r);
    return (n) => (n = Zf(n), n = IVe(n, t), n ? s.ignores(Eu(n)) : !1);
  }, "getIsIgnoredPredicate"), XV = /* @__PURE__ */ i((e = {}) => ({
    cwd: Zf(e.cwd) ?? VV.default.cwd(),
    suppressErrors: !!e.suppressErrors,
    deep: typeof e.deep == "number" ? e.deep : Number.POSITIVE_INFINITY,
    ignore: [...e.ignore ?? [], ...CVe]
  }), "normalizeOptions"), Qw = /* @__PURE__ */ i(async (e, t) => {
    let { cwd: r, suppressErrors: s, deep: n, ignore: a } = XV(t), o = await (0, Jw.default)(e, {
      cwd: r,
      suppressErrors: s,
      deep: n,
      ignore: a,
      ...KV
    }), l = await Promise.all(
      o.map(async (u) => ({
        filePath: u,
        content: await HV.default.readFile(u, "utf8")
      }))
    );
    return YV(l, r);
  }, "isIgnoredByIgnoreFiles"), Zw = /* @__PURE__ */ i((e, t) => {
    let { cwd: r, suppressErrors: s, deep: n, ignore: a } = XV(t), l = Jw.default.sync(e, {
      cwd: r,
      suppressErrors: s,
      deep: n,
      ignore: a,
      ...KV
    }).map((u) => ({
      filePath: u,
      content: WV.default.readFileSync(u, "utf8")
    }));
    return YV(l, r);
  }, "isIgnoredByIgnoreFilesSync"), zV = /* @__PURE__ */ i((e) => Qw(h0, e), "isGitIgnored"), JV = /* @__PURE__ */ i((e) => Zw(h0, e), "isGi\
tIgnoredSync");
});

// ../node_modules/globby/index.js
var pW = {};
S0(pW, {
  convertPathToPattern: () => jVe,
  generateGlobTasks: () => BVe,
  generateGlobTasksSync: () => MVe,
  globby: () => RVe,
  globbyStream: () => FVe,
  globbySync: () => kVe,
  isDynamicPattern: () => LVe,
  isGitIgnored: () => zV,
  isGitIgnoredSync: () => JV
});
var tD, eW, Mo, vu, _Ve, tW, rW, QV, ZV, rD, OVe, sW, nW, m0, iW, NVe, aW, oW, lW, uW, cW, fW, sD, RVe, kVe, FVe, LVe, BVe, MVe, jVe, dW = ei(
() => {
  tD = Ve(require("node:process"), 1), eW = Ve(require("node:fs"), 1), Mo = Ve(require("node:path"), 1);
  qq();
  vu = Ve(qw(), 1);
  _V();
  Vw();
  eD();
  zw();
  eD();
  _Ve = /* @__PURE__ */ i((e) => {
    if (e.some((t) => typeof t != "string"))
      throw new TypeError("Patterns must be a string or an array of strings");
  }, "assertPatternsInput"), tW = /* @__PURE__ */ i((e, t) => {
    let r = ep(e) ? e.slice(1) : e;
    return Mo.default.isAbsolute(r) ? r : Mo.default.join(t, r);
  }, "normalizePathForDirectoryGlob"), rW = /* @__PURE__ */ i(({ directoryPath: e, files: t, extensions: r }) => {
    let s = r?.length > 0 ? `.${r.length > 1 ? `{${r.join(",")}}` : r[0]}` : "";
    return t ? t.map((n) => Mo.default.posix.join(e, `**/${Mo.default.extname(n) ? n : `${n}${s}`}`)) : [Mo.default.posix.join(e, `**${s ? `\
/*${s}` : ""}`)];
  }, "getDirectoryGlob"), QV = /* @__PURE__ */ i(async (e, {
    cwd: t = tD.default.cwd(),
    files: r,
    extensions: s
  } = {}) => (await Promise.all(
    e.map(async (a) => await DV(tW(a, t)) ? rW({ directoryPath: a, files: r, extensions: s }) : a)
  )).flat(), "directoryToGlob"), ZV = /* @__PURE__ */ i((e, {
    cwd: t = tD.default.cwd(),
    files: r,
    extensions: s
  } = {}) => e.flatMap((n) => IV(tW(n, t)) ? rW({ directoryPath: n, files: r, extensions: s }) : n), "directoryToGlobSync"), rD = /* @__PURE__ */ i(
  (e) => (e = [...new Set([e].flat())], _Ve(e), e), "toPatternsArray"), OVe = /* @__PURE__ */ i((e) => {
    if (!e)
      return;
    let t;
    try {
      t = eW.default.statSync(e);
    } catch {
      return;
    }
    if (!t.isDirectory())
      throw new Error("The `cwd` option must be a path to a directory");
  }, "checkCwdOption"), sW = /* @__PURE__ */ i((e = {}) => (e = {
    ...e,
    ignore: e.ignore ?? [],
    expandDirectories: e.expandDirectories ?? !0,
    cwd: Zf(e.cwd)
  }, OVe(e.cwd), e), "normalizeOptions"), nW = /* @__PURE__ */ i((e) => async (t, r) => e(rD(t), sW(r)), "normalizeArguments"), m0 = /* @__PURE__ */ i(
  (e) => (t, r) => e(rD(t), sW(r)), "normalizeArgumentsSync"), iW = /* @__PURE__ */ i((e) => {
    let { ignoreFiles: t, gitignore: r } = e, s = t ? rD(t) : [];
    return r && s.push(h0), s;
  }, "getIgnoreFilesPatterns"), NVe = /* @__PURE__ */ i(async (e) => {
    let t = iW(e);
    return oW(
      t.length > 0 && await Qw(t, e)
    );
  }, "getFilter"), aW = /* @__PURE__ */ i((e) => {
    let t = iW(e);
    return oW(
      t.length > 0 && Zw(t, e)
    );
  }, "getFilterSync"), oW = /* @__PURE__ */ i((e) => {
    let t = /* @__PURE__ */ new Set();
    return (r) => {
      let s = Mo.default.normalize(r.path ?? r);
      return t.has(s) || e && e(s) ? !1 : (t.add(s), !0);
    };
  }, "createFilterFunction"), lW = /* @__PURE__ */ i((e, t) => e.flat().filter((r) => t(r)), "unionFastGlobResults"), uW = /* @__PURE__ */ i(
  (e, t) => {
    let r = [];
    for (; e.length > 0; ) {
      let s = e.findIndex((a) => ep(a));
      if (s === -1) {
        r.push({ patterns: e, options: t });
        break;
      }
      let n = e[s].slice(1);
      for (let a of r)
        a.options.ignore.push(n);
      s !== 0 && r.push({
        patterns: e.slice(0, s),
        options: {
          ...t,
          ignore: [
            ...t.ignore,
            n
          ]
        }
      }), e = e.slice(s + 1);
    }
    return r;
  }, "convertNegativePatterns"), cW = /* @__PURE__ */ i((e, t) => ({
    ...t ? { cwd: t } : {},
    ...Array.isArray(e) ? { files: e } : e
  }), "normalizeExpandDirectoriesOption"), fW = /* @__PURE__ */ i(async (e, t) => {
    let r = uW(e, t), { cwd: s, expandDirectories: n } = t;
    if (!n)
      return r;
    let a = cW(n, s);
    return Promise.all(
      r.map(async (o) => {
        let { patterns: l, options: u } = o;
        return [
          l,
          u.ignore
        ] = await Promise.all([
          QV(l, a),
          QV(u.ignore, { cwd: s })
        ]), { patterns: l, options: u };
      })
    );
  }, "generateTasks"), sD = /* @__PURE__ */ i((e, t) => {
    let r = uW(e, t), { cwd: s, expandDirectories: n } = t;
    if (!n)
      return r;
    let a = cW(n, s);
    return r.map((o) => {
      let { patterns: l, options: u } = o;
      return l = ZV(l, a), u.ignore = ZV(u.ignore, { cwd: s }), { patterns: l, options: u };
    });
  }, "generateTasksSync"), RVe = nW(async (e, t) => {
    let [
      r,
      s
    ] = await Promise.all([
      fW(e, t),
      NVe(t)
    ]), n = await Promise.all(r.map((a) => (0, vu.default)(a.patterns, a.options)));
    return lW(n, s);
  }), kVe = m0((e, t) => {
    let r = sD(e, t), s = aW(t), n = r.map((a) => vu.default.sync(a.patterns, a.options));
    return lW(n, s);
  }), FVe = m0((e, t) => {
    let r = sD(e, t), s = aW(t), n = r.map((o) => vu.default.stream(o.patterns, o.options));
    return rC(n).filter((o) => s(o));
  }), LVe = m0(
    (e, t) => e.some((r) => vu.default.isDynamicPattern(r, t))
  ), BVe = nW(fW), MVe = m0(sD), { convertPathToPattern: jVe } = vu.default;
});

// ../node_modules/camelcase/index.js
var vW = {};
S0(vW, {
  default: () => EW
});
function EW(e, t) {
  if (!(typeof e == "string" || Array.isArray(e)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (t = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...t
  }, Array.isArray(e) ? e = e.map((a) => a.trim()).filter((a) => a.length).join("-") : e = e.trim(), e.length === 0)
    return "";
  let r = t.locale === !1 ? (a) => a.toLowerCase() : (a) => a.toLocaleLowerCase(t.locale), s = t.locale === !1 ? (a) => a.toUpperCase() : (a) => a.
  toLocaleUpperCase(t.locale);
  return e.length === 1 ? nD.test(e) ? "" : t.pascalCase ? s(e) : r(e) : (e !== r(e) && (e = HVe(e, r, s, t.preserveConsecutiveUppercase)), e =
  e.replace(WVe, ""), e = t.preserveConsecutiveUppercase ? GVe(e, r) : r(e), t.pascalCase && (e = s(e.charAt(0)) + e.slice(1)), KVe(e, s));
}
var UVe, VVe, mW, bW, nD, WVe, yW, gW, HVe, GVe, KVe, SW = ei(() => {
  UVe = /[\p{Lu}]/u, VVe = /[\p{Ll}]/u, mW = /^[\p{Lu}](?![\p{Lu}])/gu, bW = /([\p{Alpha}\p{N}_]|$)/u, nD = /[_.\- ]+/, WVe = new RegExp("^" +
  nD.source), yW = new RegExp(nD.source + bW.source, "gu"), gW = new RegExp("\\d+" + bW.source, "gu"), HVe = /* @__PURE__ */ i((e, t, r, s) => {
    let n = !1, a = !1, o = !1, l = !1;
    for (let u = 0; u < e.length; u++) {
      let c = e[u];
      l = u > 2 ? e[u - 3] === "-" : !0, n && UVe.test(c) ? (e = e.slice(0, u) + "-" + e.slice(u), n = !1, o = a, a = !0, u++) : a && o && VVe.
      test(c) && (!l || s) ? (e = e.slice(0, u - 1) + "-" + e.slice(u - 1), o = a, a = !1, n = !0) : (n = t(c) === c && r(c) !== c, o = a, a =
      r(c) === c && t(c) !== c);
    }
    return e;
  }, "preserveCamelCase"), GVe = /* @__PURE__ */ i((e, t) => (mW.lastIndex = 0, e.replaceAll(mW, (r) => t(r))), "preserveConsecutiveUppercas\
e"), KVe = /* @__PURE__ */ i((e, t) => (yW.lastIndex = 0, gW.lastIndex = 0, e.replaceAll(gW, (r, s, n) => ["_", "-"].includes(e.charAt(n + r.
  length)) ? r : t(r)).replaceAll(yW, (r, s) => t(s))), "postProcess");
  i(EW, "camelCase");
});

// src/core-server/presets/common-preset.ts
var yWe = {};
S0(yWe, {
  babel: () => JVe,
  core: () => aWe,
  csfIndexer: () => UW,
  docs: () => cWe,
  env: () => tWe,
  experimental_indexers: () => lWe,
  experimental_serverAPI: () => iWe,
  experimental_serverChannel: () => pWe,
  favicon: () => zVe,
  features: () => oWe,
  frameworkOptions: () => uWe,
  logLevel: () => ZVe,
  managerEntries: () => mWe,
  managerHead: () => fWe,
  previewBody: () => rWe,
  previewHead: () => eWe,
  resolvedReact: () => dWe,
  staticDirs: () => XVe,
  tags: () => hWe,
  title: () => QVe,
  typescript: () => sWe
});
module.exports = XW(yWe);
var Pu = Ve(mp(), 1), MW = require("@storybook/core/node-logger"), jW = require("@storybook/core/telemetry"), wn = require("@storybook/core/common"),
qW = require("@storybook/core/csf-tools"), ks = require("node:path"), $W = Ve(Go(), 1);

// src/core-server/utils/server-statics.ts
var fK = require("@storybook/core/node-logger"), pK = require("@storybook/core/common");

// node_modules/chalk/source/vendor/ansi-styles/index.js
var uI = /* @__PURE__ */ i((e = 0) => (t) => `\x1B[${t + e}m`, "wrapAnsi16"), cI = /* @__PURE__ */ i((e = 0) => (t) => `\x1B[${38 + e};5;${t}\
m`, "wrapAnsi256"), fI = /* @__PURE__ */ i((e = 0) => (t, r, s) => `\x1B[${38 + e};2;${t};${r};${s}m`, "wrapAnsi16m"), Yt = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, AHe = Object.keys(Yt.modifier), JG = Object.keys(Yt.color), QG = Object.keys(Yt.bgColor), CHe = [...JG, ...QG];
function ZG() {
  let e = /* @__PURE__ */ new Map();
  for (let [t, r] of Object.entries(Yt)) {
    for (let [s, n] of Object.entries(r))
      Yt[s] = {
        open: `\x1B[${n[0]}m`,
        close: `\x1B[${n[1]}m`
      }, r[s] = Yt[s], e.set(n[0], n[1]);
    Object.defineProperty(Yt, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(Yt, "codes", {
    value: e,
    enumerable: !1
  }), Yt.color.close = "\x1B[39m", Yt.bgColor.close = "\x1B[49m", Yt.color.ansi = uI(), Yt.color.ansi256 = cI(), Yt.color.ansi16m = fI(), Yt.
  bgColor.ansi = uI(10), Yt.bgColor.ansi256 = cI(10), Yt.bgColor.ansi16m = fI(10), Object.defineProperties(Yt, {
    rgbToAnsi256: {
      value(t, r, s) {
        return t === r && r === s ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 *
        Math.round(r / 255 * 5) + Math.round(s / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(t) {
        let r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [s] = r;
        s.length === 3 && (s = [...s].map((a) => a + a).join(""));
        let n = Number.parseInt(s, 16);
        return [
          /* eslint-disable no-bitwise */
          n >> 16 & 255,
          n >> 8 & 255,
          n & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ i((t) => Yt.rgbToAnsi256(...Yt.hexToRgb(t)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(t) {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, s, n;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, s = r, n = r;
        else {
          t -= 16;
          let l = t % 36;
          r = Math.floor(t / 36) / 5, s = Math.floor(l / 6) / 5, n = l % 6 / 5;
        }
        let a = Math.max(r, s, n) * 2;
        if (a === 0)
          return 30;
        let o = 30 + (Math.round(n) << 2 | Math.round(s) << 1 | Math.round(r));
        return a === 2 && (o += 60), o;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ i((t, r, s) => Yt.ansi256ToAnsi(Yt.rgbToAnsi256(t, r, s)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ i((t) => Yt.ansi256ToAnsi(Yt.hexToAnsi256(t)), "value"),
      enumerable: !1
    }
  }), Yt;
}
i(ZG, "assembleStyles");
var eK = ZG(), an = eK;

// node_modules/chalk/source/vendor/supports-color/index.js
var gp = Ve(require("node:process"), 1), dI = Ve(require("node:os"), 1), L0 = Ve(require("node:tty"), 1);
function Fs(e, t = globalThis.Deno ? globalThis.Deno.args : gp.default.argv) {
  let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", s = t.indexOf(r + e), n = t.indexOf("--");
  return s !== -1 && (n === -1 || s < n);
}
i(Fs, "hasFlag");
var { env: tr } = gp.default, yp;
Fs("no-color") || Fs("no-colors") || Fs("color=false") || Fs("color=never") ? yp = 0 : (Fs("color") || Fs("colors") || Fs("color=true") || Fs(
"color=always")) && (yp = 1);
function tK() {
  if ("FORCE_COLOR" in tr)
    return tr.FORCE_COLOR === "true" ? 1 : tr.FORCE_COLOR === "false" ? 0 : tr.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(tr.FORCE_COLOR,
    10), 3);
}
i(tK, "envForceColor");
function rK(e) {
  return e === 0 ? !1 : {
    level: e,
    hasBasic: !0,
    has256: e >= 2,
    has16m: e >= 3
  };
}
i(rK, "translateLevel");
function sK(e, { streamIsTTY: t, sniffFlags: r = !0 } = {}) {
  let s = tK();
  s !== void 0 && (yp = s);
  let n = r ? yp : s;
  if (n === 0)
    return 0;
  if (r) {
    if (Fs("color=16m") || Fs("color=full") || Fs("color=truecolor"))
      return 3;
    if (Fs("color=256"))
      return 2;
  }
  if ("TF_BUILD" in tr && "AGENT_NAME" in tr)
    return 1;
  if (e && !t && n === void 0)
    return 0;
  let a = n || 0;
  if (tr.TERM === "dumb")
    return a;
  if (gp.default.platform === "win32") {
    let o = dI.default.release().split(".");
    return Number(o[0]) >= 10 && Number(o[2]) >= 10586 ? Number(o[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in tr)
    return "GITHUB_ACTIONS" in tr || "GITEA_ACTIONS" in tr ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some(
    (o) => o in tr) || tr.CI_NAME === "codeship" ? 1 : a;
  if ("TEAMCITY_VERSION" in tr)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(tr.TEAMCITY_VERSION) ? 1 : 0;
  if (tr.COLORTERM === "truecolor" || tr.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in tr) {
    let o = Number.parseInt((tr.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (tr.TERM_PROGRAM) {
      case "iTerm.app":
        return o >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(tr.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(tr.TERM) || "COLORTERM" in tr ?
  1 : a;
}
i(sK, "_supportsColor");
function pI(e, t = {}) {
  let r = sK(e, {
    streamIsTTY: e && e.isTTY,
    ...t
  });
  return rK(r);
}
i(pI, "createSupportsColor");
var nK = {
  stdout: pI({ isTTY: L0.default.isatty(1) }),
  stderr: pI({ isTTY: L0.default.isatty(2) })
}, hI = nK;

// node_modules/chalk/source/utilities.js
function mI(e, t, r) {
  let s = e.indexOf(t);
  if (s === -1)
    return e;
  let n = t.length, a = 0, o = "";
  do
    o += e.slice(a, s) + t + r, a = s + n, s = e.indexOf(t, a);
  while (s !== -1);
  return o += e.slice(a), o;
}
i(mI, "stringReplaceAll");
function yI(e, t, r, s) {
  let n = 0, a = "";
  do {
    let o = e[s - 1] === "\r";
    a += e.slice(n, o ? s - 1 : s) + t + (o ? `\r
` : `
`) + r, n = s + 1, s = e.indexOf(`
`, n);
  } while (s !== -1);
  return a += e.slice(n), a;
}
i(yI, "stringEncaseCRLFWithFirstIndex");

// node_modules/chalk/source/index.js
var { stdout: gI, stderr: bI } = hI, B0 = Symbol("GENERATOR"), Ko = Symbol("STYLER"), ku = Symbol("IS_EMPTY"), EI = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], Yo = /* @__PURE__ */ Object.create(null), iK = /* @__PURE__ */ i((e, t = {}) => {
  if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  let r = gI ? gI.level : 0;
  e.level = t.level === void 0 ? r : t.level;
}, "applyOptions");
var aK = /* @__PURE__ */ i((e) => {
  let t = /* @__PURE__ */ i((...r) => r.join(" "), "chalk");
  return iK(t, e), Object.setPrototypeOf(t, Fu.prototype), t;
}, "chalkFactory");
function Fu(e) {
  return aK(e);
}
i(Fu, "createChalk");
Object.setPrototypeOf(Fu.prototype, Function.prototype);
for (let [e, t] of Object.entries(an))
  Yo[e] = {
    get() {
      let r = bp(this, j0(t.open, t.close, this[Ko]), this[ku]);
      return Object.defineProperty(this, e, { value: r }), r;
    }
  };
Yo.visible = {
  get() {
    let e = bp(this, this[Ko], !0);
    return Object.defineProperty(this, "visible", { value: e }), e;
  }
};
var M0 = /* @__PURE__ */ i((e, t, r, ...s) => e === "rgb" ? t === "ansi16m" ? an[r].ansi16m(...s) : t === "ansi256" ? an[r].ansi256(an.rgbToAnsi256(
...s)) : an[r].ansi(an.rgbToAnsi(...s)) : e === "hex" ? M0("rgb", t, r, ...an.hexToRgb(...s)) : an[r][e](...s), "getModelAnsi"), oK = ["rgb",
"hex", "ansi256"];
for (let e of oK) {
  Yo[e] = {
    get() {
      let { level: r } = this;
      return function(...s) {
        let n = j0(M0(e, EI[r], "color", ...s), an.color.close, this[Ko]);
        return bp(this, n, this[ku]);
      };
    }
  };
  let t = "bg" + e[0].toUpperCase() + e.slice(1);
  Yo[t] = {
    get() {
      let { level: r } = this;
      return function(...s) {
        let n = j0(M0(e, EI[r], "bgColor", ...s), an.bgColor.close, this[Ko]);
        return bp(this, n, this[ku]);
      };
    }
  };
}
var lK = Object.defineProperties(() => {
}, {
  ...Yo,
  level: {
    enumerable: !0,
    get() {
      return this[B0].level;
    },
    set(e) {
      this[B0].level = e;
    }
  }
}), j0 = /* @__PURE__ */ i((e, t, r) => {
  let s, n;
  return r === void 0 ? (s = e, n = t) : (s = r.openAll + e, n = t + r.closeAll), {
    open: e,
    close: t,
    openAll: s,
    closeAll: n,
    parent: r
  };
}, "createStyler"), bp = /* @__PURE__ */ i((e, t, r) => {
  let s = /* @__PURE__ */ i((...n) => uK(s, n.length === 1 ? "" + n[0] : n.join(" ")), "builder");
  return Object.setPrototypeOf(s, lK), s[B0] = e, s[Ko] = t, s[ku] = r, s;
}, "createBuilder"), uK = /* @__PURE__ */ i((e, t) => {
  if (e.level <= 0 || !t)
    return e[ku] ? "" : t;
  let r = e[Ko];
  if (r === void 0)
    return t;
  let { openAll: s, closeAll: n } = r;
  if (t.includes("\x1B"))
    for (; r !== void 0; )
      t = mI(t, r.close, r.open), r = r.parent;
  let a = t.indexOf(`
`);
  return a !== -1 && (t = yI(t, n, s, a)), s + t + n;
}, "applyStyle");
Object.defineProperties(Fu.prototype, Yo);
var cK = Fu(), LHe = Fu({ level: bI ? bI.level : 0 });
var vI = cK;

// src/core-server/utils/server-statics.ts
var dK = Ve(require("express"), 1), SI = Ve(mp(), 1), Gi = Ve(require("node:path"), 1), TI = Ve(Go(), 1);
var xI = /* @__PURE__ */ i(async (e) => {
  let t = e.lastIndexOf(":"), s = Gi.default.win32.isAbsolute(e) && t === 1, n = t !== -1 && !s ? t : e.length, o = (e.substring(n + 1) || "\
/").split(Gi.default.sep).join(Gi.default.posix.sep), l = e.substring(0, n), u = Gi.default.isAbsolute(l) ? l : `./${l}`, c = Gi.default.resolve(
  u), f = o.replace(/^\/?/, "./"), p = f.substring(1);
  if (!await (0, SI.pathExists)(c))
    throw new Error(
      TI.dedent`
        Failed to load static files, no such directory: ${vI.cyan(c)}
        Make sure this directory exists.
      `
    );
  return { staticDir: u, staticPath: c, targetDir: f, targetEndpoint: p };
}, "parseStaticDir");

// src/core-server/utils/constants.ts
var Ep = require("node:path");
var PI = [
  {
    from: (0, Ep.join)((0, Ep.dirname)(require.resolve("@storybook/core/package.json")), "assets", "browser"),
    to: "/sb-common-assets"
  }
];

// src/core-server/utils/whats-new.ts
var rR = Ve(mp(), 1), tb = require("@storybook/core/node-logger"), sR = require("@storybook/core/telemetry"), rb = require("@storybook/core/common"),
Ku = require("@storybook/core/csf-tools"), un = require("@storybook/core/core-events");

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var hK = process.env.NODE_ENV === "production", q0 = "Invariant failed";
function $0(e, t) {
  if (!e) {
    if (hK)
      throw new Error(q0);
    var r = typeof t == "function" ? t() : t, s = r ? "".concat(q0, ": ").concat(r) : q0;
    throw new Error(s);
  }
}
i($0, "invariant");

// src/core-server/withTelemetry.ts
var tR = Ve(eR(), 1), Zo = require("@storybook/core/common"), el = require("@storybook/core/telemetry"), Ez = require("@storybook/core/node-logger");
var vz = /* @__PURE__ */ i(async () => {
  if (process.env.CI)
    return;
  let { enableCrashReports: e } = await (0, tR.default)({
    type: "confirm",
    name: "enableCrashReports",
    message: "Would you like to help improve Storybook by sending anonymous crash reports?",
    initial: !0
  });
  return await Zo.cache.set("enableCrashReports", e), e;
}, "promptCrashReports");
async function Sz({
  cliOptions: e,
  presetOptions: t,
  skipPrompt: r
}) {
  if (e.disableTelemetry) return "none";
  if (!t) return "full";
  let n = await (await (0, Zo.loadAllPresets)(t)).apply("core");
  if (n?.enableCrashReports !== void 0) return n.enableCrashReports ? "full" : "error";
  if (n?.disableTelemetry) return "none";
  let a = await Zo.cache.get("enableCrashReports") ?? await Zo.cache.get("enableCrashreports");
  if (a !== void 0) return a ? "full" : "error";
  if (r)
    return "error";
  let o = await vz();
  return o !== void 0 ? o ? "full" : "error" : "full";
}
i(Sz, "getErrorLevel");
async function Zg(e, t, r) {
  try {
    let s = "error";
    try {
      s = await Sz(r);
    } catch {
    }
    if (s !== "none") {
      let n = await (0, el.getPrecedingUpgrade)(), a = e, o;
      "message" in a ? o = a.message ? (0, el.oneWayHash)(a.message) : "EMPTY_MESSAGE" : o = "NO_MESSAGE";
      let { code: l, name: u, category: c } = a;
      await (0, el.telemetry)(
        "error",
        {
          code: l,
          name: u,
          category: c,
          eventType: t,
          precedingUpgrade: n,
          error: s === "full" ? a : void 0,
          errorHash: o,
          // if we ever end up sending a non-error instance, we'd like to know
          isErrorInstance: a instanceof Error
        },
        {
          immediate: !0,
          configDir: r.cliOptions.configDir || r.presetOptions?.configDir,
          enableCrashReports: s === "full"
        }
      );
    }
  } catch {
  }
}
i(Zg, "sendTelemetryError");

// src/core-server/utils/whats-new.ts
var eb = "whats-new-cache", Tz = "https://storybook.js.org/whats-new/v1";
function nR(e, t, r) {
  e.on(un.SET_WHATS_NEW_CACHE, async (s) => {
    let n = await t.cache.get(eb).catch((a) => (tb.logger.verbose(a), {}));
    await t.cache.set(eb, { ...n, ...s });
  }), e.on(un.REQUEST_WHATS_NEW_DATA, async () => {
    try {
      let s = await fetch(Tz).then(async (c) => {
        if (c.ok) return c.json();
        throw c;
      }), n = (0, rb.findConfigFile)("main", t.configDir);
      if (!n)
        throw new Error(`unable to find storybook main file in ${t.configDir}`);
      let o = (await (0, Ku.readConfig)(n)).getFieldValue([
        "core",
        "disableWhatsNewNotifications"
      ]), l = await t.cache.get(eb) ?? {}, u = {
        ...s,
        status: "SUCCESS",
        postIsRead: s.url === l.lastReadPost,
        showNotification: s.url !== l.lastDismissedPost && s.url !== l.lastReadPost,
        disableWhatsNewNotifications: o
      };
      e.emit(un.RESULT_WHATS_NEW_DATA, { data: u });
    } catch (s) {
      tb.logger.verbose(s instanceof Error ? s.message : String(s)), e.emit(un.RESULT_WHATS_NEW_DATA, {
        data: { status: "ERROR" }
      });
    }
  }), e.on(
    un.TOGGLE_WHATS_NEW_NOTIFICATIONS,
    async ({ disableWhatsNewNotifications: s }) => {
      let n = r.disableTelemetry !== !0;
      try {
        let a = (0, rb.findConfigFile)("main", t.configDir);
        $0(a, `unable to find storybook main file in ${t.configDir}`);
        let o = await (0, Ku.readConfig)(a);
        o.setFieldValue(["core", "disableWhatsNewNotifications"], s), await rR.default.writeFile(a, (0, Ku.printConfig)(o).code), n && await (0, sR.telemetry)(
        "core-config", { disableWhatsNewNotifications: s });
      } catch (a) {
        $0(a instanceof Error), n && await Zg(a, "core-config", {
          cliOptions: t,
          presetOptions: { ...t, corePresets: [], overridePresets: [] },
          skipPrompt: !0
        });
      }
    }
  ), e.on(un.TELEMETRY_ERROR, async (s) => {
    r.disableTelemetry !== !0 && await Zg(s, "browser", {
      cliOptions: t,
      presetOptions: { ...t, corePresets: [], overridePresets: [] },
      skipPrompt: !0
    });
  });
}
i(nR, "initializeWhatsNew");

// src/core-server/utils/save-story/save-story.ts
var ZM = Ve(require("node:fs/promises"), 1), ya = require("@storybook/core/core-events"), Vc = require("@storybook/csf"), fh = require("@storybook/core/csf-tools"),
ej = require("@storybook/core/node-logger"), N1 = require("@storybook/core/telemetry"), ph = require("node:path");

// src/core-server/utils/save-story/update-args-in-csf-file.ts
var Ct = Ve(Ne(), 1), _1 = Ve(Ms(), 1);

// src/core-server/utils/save-story/valueToAST.ts
var kr = Ve(Ne(), 1), XM = Ve(ao(), 1);
function ch(e) {
  if (e === null)
    return kr.nullLiteral();
  switch (typeof e) {
    case "function":
      return XM.parse(e.toString(), {
        allowReturnOutsideFunction: !0,
        allowSuperOutsideMethod: !0
      }).program.body[0]?.expression;
    case "number":
      return kr.numericLiteral(e);
    case "string":
      return kr.stringLiteral(e);
    case "boolean":
      return kr.booleanLiteral(e);
    case "undefined":
      return kr.identifier("undefined");
    default:
      return Array.isArray(e) ? kr.arrayExpression(e.map(ch)) : kr.objectExpression(
        Object.keys(e).filter((r) => typeof e[r] < "u").map((r) => {
          let s = e[r];
          return kr.objectProperty(kr.stringLiteral(r), ch(s));
        })
      );
  }
}
i(ch, "valueToAST");

// src/core-server/utils/save-story/utils.ts
var Ws = class extends Error {
  static {
    i(this, "SaveStoryError");
  }
};

// src/core-server/utils/save-story/update-args-in-csf-file.ts
var VOe = _1.default.default || _1.default, zM = /* @__PURE__ */ i(async (e, t) => {
  let r = !1, s = Object.fromEntries(
    Object.entries(t).map(([n, a]) => [n, ch(a)])
  );
  if (Ct.isArrowFunctionExpression(e) || Ct.isCallExpression(e))
    throw new Ws("Updating a CSF2 story is not supported");
  if (Ct.isObjectExpression(e)) {
    let n = e.properties, a = n.find((o) => {
      if (Ct.isObjectProperty(o)) {
        let l = o.key;
        return Ct.isIdentifier(l) && l.name === "args";
      }
      return !1;
    });
    if (a) {
      if (Ct.isObjectProperty(a)) {
        let o = a.value;
        if (Ct.isObjectExpression(o)) {
          o.properties.forEach((u) => {
            if (Ct.isObjectProperty(u)) {
              let c = u.key;
              Ct.isIdentifier(c) && c.name in s && (u.value = s[c.name], delete s[c.name]);
            }
          });
          let l = Object.entries(s);
          Object.keys(s).length && l.forEach(([u, c]) => {
            o.properties.push(Ct.objectProperty(Ct.identifier(u), c));
          });
        }
      }
    } else
      n.unshift(
        Ct.objectProperty(
          Ct.identifier("args"),
          Ct.objectExpression(
            Object.entries(s).map(([o, l]) => Ct.objectProperty(Ct.identifier(o), l))
          )
        )
      );
    return;
  }
  VOe(e, {
    ObjectExpression(n) {
      if (r)
        return;
      r = !0;
      let o = n.get("properties").find((l) => {
        if (l.isObjectProperty()) {
          let u = l.get("key");
          return u.isIdentifier() && u.node.name === "args";
        }
        return !1;
      });
      if (o) {
        if (o.isObjectProperty()) {
          let l = o.get("value");
          if (l.isObjectExpression()) {
            l.traverse({
              ObjectProperty(c) {
                let f = c.get("key");
                f.isIdentifier() && f.node.name in s && (c.get("value").replaceWith(s[f.node.name]), delete s[f.node.name]);
              },
              // @ts-expect-error noScope works but is not typed properly
              noScope: !0
            });
            let u = Object.entries(s);
            Object.keys(s).length && u.forEach(([c, f]) => {
              l.pushContainer("properties", Ct.objectProperty(Ct.identifier(c), f));
            });
          }
        }
      } else
        n.unshiftContainer(
          "properties",
          Ct.objectProperty(
            Ct.identifier("args"),
            Ct.objectExpression(
              Object.entries(s).map(([l, u]) => Ct.objectProperty(Ct.identifier(l), u))
            )
          )
        );
    },
    noScope: !0
  });
}, "updateArgsInCsfFile");

// src/core-server/utils/save-story/duplicate-story-with-new-name.ts
var $n = Ve(Ne(), 1), O1 = Ve(Ms(), 1);
var JM = O1.default.default || O1.default, QM = /* @__PURE__ */ i((e, t, r) => {
  let s = e._storyExports[t], n = $n.cloneNode(s);
  if (!n)
    throw new Ws("cannot clone Node");
  let a = !1;
  if (JM(n, {
    Identifier(o) {
      a || o.node.name === t && (a = !0, o.node.name = r);
    },
    ObjectProperty(o) {
      let l = o.get("key");
      l.isIdentifier() && l.node.name === "args" && o.remove();
    },
    noScope: !0
  }), $n.isArrowFunctionExpression(n.init) || $n.isCallExpression(n.init))
    throw new Ws("Creating a new story based on a CSF2 story is not supported");
  return JM(e._ast, {
    Program(o) {
      o.pushContainer(
        "body",
        $n.exportNamedDeclaration($n.variableDeclaration("const", [n]))
      );
    }
  }), n;
}, "duplicateStoryWithNewName");

// src/core-server/utils/save-story/save-story.ts
var tj = require("@storybook/core/common");
var WOe = /* @__PURE__ */ i((e) => JSON.parse(e, (t, r) => r === "__sb_empty_function_arg__" ? () => {
} : r), "parseArgs"), HOe = /* @__PURE__ */ i((e, t) => {
  let r = "([\\s\\S])", s = "(\\r\\n|\\r|\\n)", n = s + "};" + s, a = new RegExp(
    // Looks for an export by the given name, considers the first closing brace on its own line
    // to be the end of the story definition.
    `^(?<before>${r}*)(?<story>export const ${t} =${r}+?${n})(?<after>${r}*)$`
  ), { before: o, story: l, after: u } = e.match(a)?.groups || {};
  return l ? o + l.replaceAll(/(\r\n|\r|\n)(\r\n|\r|\n)([ \t]*[a-z0-9_]+): /gi, "$2$3:") + u : e;
}, "removeExtraNewlines");
function rj(e, t, r) {
  e.on(ya.SAVE_STORY_REQUEST, async ({ id: s, payload: n }) => {
    let { csfId: a, importPath: o, args: l, name: u } = n, c, f, p, d, m;
    try {
      p = (0, ph.basename)(o), d = (0, ph.join)(process.cwd(), o);
      let b = await (0, fh.readCsf)(d, {
        makeTitle: /* @__PURE__ */ i((I) => I || "myTitle", "makeTitle")
      }), h = b.parse(), g = Object.entries(h._stories), [E, D] = a.split("--");
      f = u && (0, Vc.storyNameFromExport)(u), c = f && (0, Vc.toId)(E, f);
      let [C] = g.find(([I, M]) => M.id.endsWith(`--${D}`)) || [];
      if (!C)
        throw new Ws("Source story not found.");
      if (u && b.getStoryExport(u))
        throw new Ws("Story already exists.");
      m = (0, Vc.storyNameFromExport)(C), await zM(
        u ? QM(h, C, u) : b.getStoryExport(C),
        l ? WOe(l) : {}
      );
      let N = await (0, tj.formatFileContent)(
        d,
        HOe((0, fh.printCsf)(b).code, u || C)
      );
      await Promise.all([
        new Promise((I) => {
          e.on(ya.STORY_RENDERED, I), setTimeout(() => I(e.off(ya.STORY_RENDERED, I)), 3e3);
        }),
        ZM.default.writeFile(d, N)
      ]), e.emit(ya.SAVE_STORY_RESPONSE, {
        id: s,
        success: !0,
        payload: {
          csfId: a,
          newStoryId: c,
          newStoryName: f,
          sourceFileContent: N,
          sourceFileName: p,
          sourceStoryName: m
        },
        error: null
      }), r.disableTelemetry || await (0, N1.telemetry)("save-story", {
        action: u ? "createStory" : "updateStory",
        success: !0
      });
    } catch (b) {
      e.emit(ya.SAVE_STORY_RESPONSE, {
        id: s,
        success: !1,
        error: b instanceof Ws ? b.message : "Unknown error"
      }), ej.logger.error(
        `Error writing to ${d}:
${b.stack || b.message || b.toString()}`
      ), !r.disableTelemetry && !(b instanceof Ws) && await (0, N1.telemetry)("save-story", {
        action: u ? "createStory" : "updateStory",
        success: !1,
        error: b
      });
    }
  });
}
i(rj, "initializeSaveStory");

// src/core-server/server-channel/file-search-channel.ts
var Su = require("@storybook/core/common"), rp = Ve(require("node:path"), 1), wW = Ve(require("fs/promises"), 1);

// src/core-server/utils/parser/generic-parser.ts
var Oq = Ve(ao(), 1), Zs = Ve(mr(), 1);
var Fy = class {
  static {
    i(this, "GenericParser");
  }
  /**
   * Parse the content of a file and return the exports
   * @param content The content of the file
   * @returns The exports of the file
   */
  async parse(t) {
    let r = Oq.parse(t, {
      allowImportExportEverywhere: !0,
      allowAwaitOutsideFunction: !0,
      allowNewTargetOutsideFunction: !0,
      allowReturnOutsideFunction: !0,
      allowUndeclaredExports: !0,
      plugins: [
        // Language features
        "typescript",
        "jsx",
        // Latest ECMAScript features
        "asyncGenerators",
        "bigInt",
        "classProperties",
        "classPrivateProperties",
        "classPrivateMethods",
        "classStaticBlock",
        "dynamicImport",
        "exportNamespaceFrom",
        "logicalAssignment",
        "moduleStringNames",
        "nullishCoalescingOperator",
        "numericSeparator",
        "objectRestSpread",
        "optionalCatchBinding",
        "optionalChaining",
        "privateIn",
        "regexpUnicodeSets",
        "topLevelAwait",
        // ECMAScript proposals
        "asyncDoExpressions",
        "decimal",
        "decorators",
        "decoratorAutoAccessors",
        "deferredImportEvaluation",
        "destructuringPrivate",
        "doExpressions",
        "explicitResourceManagement",
        "exportDefaultFrom",
        "functionBind",
        "functionSent",
        "importAttributes",
        "importReflection",
        "moduleBlocks",
        "partialApplication",
        "recordAndTuple",
        "sourcePhaseImports",
        "throwExpressions"
      ]
    }), s = [];
    return r.program.body.forEach(/* @__PURE__ */ i(function(a) {
      Zs.types.isExportNamedDeclaration(a) ? (Zs.types.isFunctionDeclaration(a.declaration) && Zs.types.isIdentifier(a.declaration.id) && s.
      push({
        name: a.declaration.id.name,
        default: !1
      }), Zs.types.isClassDeclaration(a.declaration) && Zs.types.isIdentifier(a.declaration.id) && s.push({
        name: a.declaration.id.name,
        default: !1
      }), a.declaration === null && a.specifiers.length > 0 && a.specifiers.forEach((o) => {
        Zs.types.isExportSpecifier(o) && Zs.types.isIdentifier(o.exported) && s.push({
          name: o.exported.name,
          default: !1
        });
      }), Zs.types.isVariableDeclaration(a.declaration) && a.declaration.declarations.forEach((o) => {
        Zs.types.isVariableDeclarator(o) && Zs.types.isIdentifier(o.id) && s.push({
          name: o.id.name,
          default: !1
        });
      })) : Zs.types.isExportDefaultDeclaration(a) && s.push({
        name: "default",
        default: !0
      });
    }, "traverse")), { exports: s };
  }
};

// src/core-server/utils/parser/index.ts
function Nq(e) {
  switch (e) {
    default:
      return new Fy();
  }
}
i(Nq, "getParser");

// src/core-server/utils/search-files.ts
var qVe = ["js", "mjs", "cjs", "jsx", "mts", "ts", "tsx", "cts"], $Ve = [
  "**/node_modules/**",
  "**/*.spec.*",
  "**/*.test.*",
  "**/*.stories.*",
  "**/storybook-static/**"
];
async function hW({
  searchQuery: e,
  cwd: t,
  ignoredFiles: r = $Ve,
  fileExtensions: s = qVe
}) {
  let { globby: n, isDynamicPattern: a } = await Promise.resolve().then(() => (dW(), pW)), o = a(e, { cwd: t }), u = /(\.[a-z]+)$/i.test(e),
  c = `{${s.join(",")}}`, f = o ? e : u ? [`**/*${e}*`, `**/*${e}*/**`] : [
    `**/*${e}*.${c}`,
    `**/*${e}*/**/*.${c}`
  ];
  return (await n(f, {
    ignore: r,
    gitignore: !0,
    caseSensitiveMatch: !1,
    cwd: t,
    objectMode: !0
  })).map((d) => d.path).filter((d) => s.some((m) => d.endsWith(`.${m}`)));
}
i(hW, "searchFiles");

// src/core-server/server-channel/file-search-channel.ts
var sp = require("@storybook/core/core-events");

// src/core-server/utils/get-new-story-file.ts
var Ma = require("@storybook/core/common"), Rs = Ve(require("node:path"), 1), tp = Ve(require("node:fs"), 1);

// src/core-server/utils/new-story-templates/typescript.ts
var TW = Ve(Go(), 1);

// src/core-server/utils/get-component-variable-name.ts
var y0 = /* @__PURE__ */ i(async (e) => (await Promise.resolve().then(() => (SW(), vW))).default(e.replace(/^[^a-zA-Z_$]*/, ""), { pascalCase: !0 }).
replace(/[^a-zA-Z_$]+/, ""), "getComponentVariableName");

// src/core-server/utils/new-story-templates/typescript.ts
async function xW(e) {
  let t = e.componentIsDefaultExport ? await y0(e.basenameWithoutExtension) : e.componentExportName, r = e.componentIsDefaultExport ? `impor\
t ${t} from './${e.basenameWithoutExtension}'` : `import { ${t} } from './${e.basenameWithoutExtension}'`;
  return TW.dedent`
  import type { Meta, StoryObj } from '${e.rendererPackage}';

  ${r};

  const meta = {
    component: ${t},
  } satisfies Meta<typeof ${t}>;

  export default meta;

  type Story = StoryObj<typeof meta>;

  export const ${e.exportedStoryName}: Story = {};
  `;
}
i(xW, "getTypeScriptTemplateForNewStoryFile");

// src/core-server/utils/new-story-templates/javascript.ts
var PW = Ve(Go(), 1);
async function AW(e) {
  let t = e.componentIsDefaultExport ? await y0(e.basenameWithoutExtension) : e.componentExportName, r = e.componentIsDefaultExport ? `impor\
t ${t} from './${e.basenameWithoutExtension}';` : `import { ${t} } from './${e.basenameWithoutExtension}';`;
  return PW.dedent`
  ${r}

  const meta = {
    component: ${t},
  };
  
  export default meta;
  
  export const ${e.exportedStoryName} = {};
  `;
}
i(AW, "getJavaScriptTemplateForNewStoryFile");

// src/core-server/utils/get-new-story-file.ts
async function CW({
  componentFilePath: e,
  componentExportName: t,
  componentIsDefaultExport: r,
  componentExportCount: s
}, n) {
  let a = (0, Ma.getProjectRoot)(), o = await (0, Ma.getFrameworkName)(n), l = await (0, Ma.extractProperRendererNameFromFramework)(o), u = Object.
  entries(Ma.rendererPackages).find(
    ([, I]) => I === l
  )?.[0], c = Rs.default.basename(e), f = Rs.default.extname(e), p = c.replace(f, ""), d = Rs.default.dirname(e), { storyFileName: m, isTypescript: b,
  storyFileExtension: h } = iD(e), g = `${m}.${h}`, E = `${p}.${t}.stories.${h}`, D = "Default", C = b && u ? await xW({
    basenameWithoutExtension: p,
    componentExportName: t,
    componentIsDefaultExport: r,
    rendererPackage: u,
    exportedStoryName: D
  }) : await AW({
    basenameWithoutExtension: p,
    componentExportName: t,
    componentIsDefaultExport: r,
    exportedStoryName: D
  });
  return { storyFilePath: aD(Rs.default.join(a, d), m) && s > 1 ? Rs.default.join(a, d, E) : Rs.default.join(a, d, g), exportedStoryName: D,
  storyFileContent: C, dirname: d };
}
i(CW, "getNewStoryFile");
var iD = /* @__PURE__ */ i((e) => {
  let t = /\.(ts|tsx|mts|cts)$/.test(e), r = Rs.default.basename(e), s = Rs.default.extname(e), n = r.replace(s, ""), a = t ? "tsx" : "jsx";
  return {
    storyFileName: `${n}.stories`,
    storyFileExtension: a,
    isTypescript: t
  };
}, "getStoryMetadata"), aD = /* @__PURE__ */ i((e, t) => tp.default.existsSync(Rs.default.join(e, `${t}.ts`)) || tp.default.existsSync(Rs.default.
join(e, `${t}.tsx`)) || tp.default.existsSync(Rs.default.join(e, `${t}.js`)) || tp.default.existsSync(Rs.default.join(e, `${t}.jsx`)), "does\
StoryFileExist");

// src/core-server/server-channel/file-search-channel.ts
var g0 = require("@storybook/core/telemetry");
async function DW(e, t, r) {
  return e.on(
    sp.FILE_COMPONENT_SEARCH_REQUEST,
    async (s) => {
      let n = s.id;
      try {
        if (!n)
          return;
        let a = await (0, Su.getFrameworkName)(t), o = await (0, Su.extractProperRendererNameFromFramework)(
          a
        ), l = (0, Su.getProjectRoot)(), c = (await hW({
          searchQuery: n,
          cwd: l
        })).map(async (f) => {
          let p = Nq(o);
          try {
            let d = await wW.default.readFile(rp.default.join(l, f), "utf-8"), { storyFileName: m } = iD(rp.default.join(l, f)), b = rp.default.
            dirname(f), h = aD(
              rp.default.join(l, b),
              m
            ), g = await p.parse(d);
            return {
              filepath: f,
              exportedComponents: g.exports,
              storyFileExists: h
            };
          } catch (d) {
            return r.disableTelemetry || (0, g0.telemetry)("create-new-story-file-search", {
              success: !1,
              error: `Could not parse file: ${d}`
            }), {
              filepath: f,
              storyFileExists: !1,
              exportedComponents: null
            };
          }
        });
        r.disableTelemetry || (0, g0.telemetry)("create-new-story-file-search", {
          success: !0,
          payload: {
            fileCount: c.length
          }
        }), e.emit(sp.FILE_COMPONENT_SEARCH_RESPONSE, {
          success: !0,
          id: n,
          payload: {
            files: await Promise.all(c)
          },
          error: null
        });
      } catch (a) {
        e.emit(sp.FILE_COMPONENT_SEARCH_RESPONSE, {
          success: !1,
          id: n ?? "",
          error: `An error occurred while searching for components in the project.
${a?.message}`
        }), r.disableTelemetry || (0, g0.telemetry)("create-new-story-file-search", {
          success: !1,
          error: `An error occured while searching for components: ${a}`
        });
      }
    }
  ), e;
}
i(DW, "initFileSearchChannel");

// src/core-server/server-channel/create-new-story-channel.ts
var E0 = require("@storybook/core/telemetry"), xu = require("@storybook/core/core-events"), kW = require("node:fs/promises"), FW = require("node:fs");

// src/core-server/utils/get-story-id.ts
var _W = Ve(Go(), 1), b0 = require("@storybook/core/common"), OW = Ve(require("node:path"), 1), Tu = require("@storybook/csf"), NW = require("@storybook/core/preview-api");

// src/core-server/utils/posix.ts
var oD = Ve(require("node:path"), 1);
var IW = /* @__PURE__ */ i((e, t = oD.default.sep) => e.split(t).filter(Boolean).join(oD.default.posix.sep), "posix");

// src/core-server/utils/get-story-id.ts
async function RW(e, t) {
  let r = await t.presets.apply("stories", [], t), s = process.cwd(), n = (0, b0.normalizeStories)(r, {
    configDir: t.configDir,
    workingDir: s
  }), a = OW.default.relative(s, e.storyFilePath), o = IW((0, b0.normalizeStoryPath)(a)), l = n.map((p) => (0, NW.userOrAutoTitleFromSpecifier)(
  o, p)).filter(Boolean)[0];
  if (l === void 0)
    throw new Error(_W.dedent`
    The new story file was successfully generated, but we are unable to index it. Please ensure that the new Story file is matched by the 'stories' glob pattern in your Storybook configuration.
    `);
  let u = (0, Tu.storyNameFromExport)(e.exportedStoryName), c = (0, Tu.toId)(l, u), f = (0, Tu.sanitize)(l);
  return { storyId: c, kind: f };
}
i(RW, "getStoryId");

// src/core-server/server-channel/create-new-story-channel.ts
var lD = Ve(require("node:path"), 1);
function LW(e, t, r) {
  return e.on(
    xu.CREATE_NEW_STORYFILE_REQUEST,
    async (s) => {
      try {
        let { storyFilePath: n, exportedStoryName: a, storyFileContent: o } = await CW(
          s.payload,
          t
        ), l = lD.default.relative(process.cwd(), n), { storyId: u, kind: c } = await RW({ storyFilePath: n, exportedStoryName: a }, t);
        if ((0, FW.existsSync)(n)) {
          e.emit(xu.CREATE_NEW_STORYFILE_RESPONSE, {
            success: !1,
            id: s.id,
            payload: {
              type: "STORY_FILE_EXISTS",
              kind: c
            },
            error: `A story file already exists at ${l}`
          }), r.disableTelemetry || (0, E0.telemetry)("create-new-story-file", {
            success: !1,
            error: "STORY_FILE_EXISTS"
          });
          return;
        }
        await (0, kW.writeFile)(n, o, "utf-8"), e.emit(xu.CREATE_NEW_STORYFILE_RESPONSE, {
          success: !0,
          id: s.id,
          payload: {
            storyId: u,
            storyFilePath: lD.default.relative(process.cwd(), n),
            exportedStoryName: a
          },
          error: null
        }), r.disableTelemetry || (0, E0.telemetry)("create-new-story-file", {
          success: !0
        });
      } catch (n) {
        e.emit(xu.CREATE_NEW_STORYFILE_RESPONSE, {
          success: !1,
          id: s.id,
          error: n?.message
        }), r.disableTelemetry || await (0, E0.telemetry)("create-new-story-file", {
          success: !1,
          error: n
        });
      }
    }
  ), e;
}
i(LW, "initCreateNewStoryChannel");

// src/core-server/presets/common-preset.ts
var YVe = /* @__PURE__ */ i((e, t = {}) => Object.entries(t).reduce((r, [s, n]) => r.replace(new RegExp(`%${s}%`, "g"), n), e), "interpolate"),
BW = (0, ks.join)(
  (0, ks.dirname)(require.resolve("@storybook/core/package.json")),
  "/assets/browser/favicon.svg"
), XVe = /* @__PURE__ */ i(async (e = []) => [
  ...PI,
  ...e
], "staticDirs"), zVe = /* @__PURE__ */ i(async (e, t) => {
  if (e)
    return e;
  let r = await t.presets.apply("staticDirs"), s = r ? r.map((n) => typeof n == "string" ? n : `${n.from}:${n.to}`) : [];
  if (s && s.length > 0) {
    let a = (await Promise.all(
      s.map(async (o) => {
        let l = [], u = r && !(0, ks.isAbsolute)(o) ? (0, wn.getDirectoryFromWorkingDir)({
          configDir: t.configDir,
          workingDir: process.cwd(),
          directory: o
        }) : o, { staticPath: c, targetEndpoint: f } = await xI(u);
        if (f === "/") {
          let d = (0, ks.join)(c, "favicon.svg");
          await (0, Pu.pathExists)(d) && l.push(d);
        }
        if (f === "/") {
          let d = (0, ks.join)(c, "favicon.ico");
          await (0, Pu.pathExists)(d) && l.push(d);
        }
        return l;
      })
    )).reduce((o, l) => o.concat(l), []);
    return a.length > 1 && MW.logger.warn($W.dedent`
        Looks like multiple favicons were detected. Using the first one.

        ${a.join(", ")}
        `), a[0] || BW;
  }
  return BW;
}, "favicon"), JVe = /* @__PURE__ */ i(async (e, t) => {
  let { presets: r } = t, s = await r.apply("babelDefault", {}, t) ?? {};
  return {
    ...s,
    // This override makes sure that we will never transpile babel further down then the browsers that storybook supports.
    // This is needed to support the mount property of the context described here:
    // https://storybook.js.org/docs/writing-tests/interaction-testing#run-code-before-each-test
    overrides: [
      ...s?.overrides ?? [],
      {
        include: /\.(story|stories)\.[cm]?[jt]sx?$/,
        presets: [
          [
            "@babel/preset-env",
            {
              bugfixes: !0,
              targets: {
                // This is the same browser supports that we use to bundle our manager and preview code.
                chrome: 100,
                safari: 15,
                firefox: 91
              }
            }
          ]
        ]
      }
    ]
  };
}, "babel"), QVe = /* @__PURE__ */ i((e, t) => e || t.packageJson.name || !1, "title"), ZVe = /* @__PURE__ */ i((e, t) => e || t.loglevel ||
"info", "logLevel"), eWe = /* @__PURE__ */ i(async (e, { configDir: t, presets: r }) => {
  let s = await r.apply("env");
  return (0, wn.getPreviewHeadTemplate)(t, s);
}, "previewHead"), tWe = /* @__PURE__ */ i(async () => (0, wn.loadEnvs)({ production: !0 }).raw, "env"), rWe = /* @__PURE__ */ i(async (e, {
configDir: t, presets: r }) => {
  let s = await r.apply("env");
  return (0, wn.getPreviewBodyTemplate)(t, s);
}, "previewBody"), sWe = /* @__PURE__ */ i(() => ({
  check: !1,
  // 'react-docgen' faster than `react-docgen-typescript` but produces lower quality results
  reactDocgen: "react-docgen",
  reactDocgenTypescriptOptions: {
    shouldExtractLiteralValuesFromEnum: !0,
    shouldRemoveUndefinedFromOptional: !0,
    propFilter: /* @__PURE__ */ i((e) => e.parent ? !/node_modules/.test(e.parent.fileName) : !0, "propFilter"),
    // NOTE: this default cannot be changed
    savePropValueAsString: !0
  }
}), "typescript"), nWe = /* @__PURE__ */ i((e) => {
  if (e !== void 0) {
    if (e.toUpperCase() === "FALSE")
      return !1;
    if (e.toUpperCase() === "TRUE" || typeof e == "string")
      return !0;
  }
}, "optionalEnvToBoolean"), iWe = /* @__PURE__ */ i((e, t) => {
  let r = wn.removeAddon;
  return t.disableTelemetry || (r = /* @__PURE__ */ i(async (s, n) => (await (0, jW.telemetry)("remove", { addon: s, source: "api" }), (0, wn.removeAddon)(
  s, n)), "removeAddon")), { ...e, removeAddon: r };
}, "experimental_serverAPI"), aWe = /* @__PURE__ */ i(async (e, t) => ({
  ...e,
  disableTelemetry: t.disableTelemetry === !0 || t.test === !0,
  enableCrashReports: t.enableCrashReports || nWe(process.env.STORYBOOK_ENABLE_CRASH_REPORTS)
}), "core"), oWe = /* @__PURE__ */ i(async (e) => ({
  ...e,
  argTypeTargetsV7: !0,
  legacyDecoratorFileOrder: !1,
  disallowImplicitActionsInRenderV8: !0
}), "features"), UW = {
  test: /(stories|story)\.(m?js|ts)x?$/,
  createIndex: /* @__PURE__ */ i(async (e, t) => (await (0, qW.readCsf)(e, t)).parse().indexInputs, "createIndex")
}, lWe = /* @__PURE__ */ i((e) => [UW].concat(e || []), "experimental_indexers"), uWe = /* @__PURE__ */ i(async (e, t) => {
  let r = await t.presets.apply("framework");
  return typeof r == "string" ? {} : typeof r > "u" ? null : r.options;
}, "frameworkOptions"), cWe = /* @__PURE__ */ i((e, { docs: t }) => e && t !== void 0 ? {
  ...e,
  docsMode: t
} : e, "docs"), fWe = /* @__PURE__ */ i(async (e, t) => {
  let r = (0, ks.join)(t.configDir, "manager-head.html");
  if (await (0, Pu.pathExists)(r)) {
    let s = (0, Pu.readFile)(r, "utf-8"), n = t.presets.apply("env");
    return YVe(await s, await n);
  }
  return "";
}, "managerHead"), pWe = /* @__PURE__ */ i(async (e, t) => {
  let r = await t.presets.apply("core");
  return nR(e, t, r), rj(e, t, r), DW(e, t, r), LW(e, t, r), e;
}, "experimental_serverChannel"), dWe = /* @__PURE__ */ i(async (e) => {
  try {
    return {
      ...e,
      react: (0, ks.dirname)(require.resolve("react/package.json")),
      reactDom: (0, ks.dirname)(require.resolve("react-dom/package.json"))
    };
  } catch {
    return e;
  }
}, "resolvedReact"), hWe = /* @__PURE__ */ i(async (e) => ({
  ...e,
  "dev-only": { excludeFromDocsStories: !0 },
  "docs-only": { excludeFromSidebar: !0 },
  "test-only": { excludeFromSidebar: !0, excludeFromDocsStories: !0 }
}), "tags"), mWe = /* @__PURE__ */ i(async (e, t) => [
  (0, ks.join)(
    (0, ks.dirname)(require.resolve("@storybook/core/package.json")),
    "dist/core-server/presets/common-manager.js"
  ),
  ...e || []
], "managerEntries");
