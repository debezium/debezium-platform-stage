"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeCreateContainerFunction = exports.createContainer = exports.combineContainerMixins = void 0;
var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));
var _flow2 = _interopRequireDefault(require("lodash/flow"));
var _forOwn2 = _interopRequireDefault(require("lodash/forOwn"));
var _groupBy2 = _interopRequireDefault(require("lodash/groupBy"));
var _toPairs2 = _interopRequireDefault(require("lodash/toPairs"));
var _victoryCore = require("victory-core");
var _victoryVoronoiContainer = require("victory-voronoi-container");
var _victoryZoomContainer = require("victory-zoom-container");
var _victorySelectionContainer = require("victory-selection-container");
var _victoryBrushContainer = require("victory-brush-container");
var _victoryCursorContainer = require("victory-cursor-container");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ensureArray(thing) {
  if (!thing) {
    return [];
  } else if (!Array.isArray(thing)) {
    return [thing];
  }
  return thing;
}
const combineEventHandlers = eventHandlersArray => {
  // takes an array of event handler objects and produces one eventHandlers object
  // creates a custom combinedHandler() for events with multiple conflicting handlers
  return eventHandlersArray.reduce((localHandlers, finalHandlers) => {
    (0, _forOwn2.default)(localHandlers, (localHandler, eventName) => {
      const existingHandler = finalHandlers[eventName];
      if (existingHandler) {
        // create new handler for event that concats the existing handler's mutations with new ones
        finalHandlers[eventName] = function combinedHandler() {
          // named for debug clarity
          // sometimes handlers return undefined; use empty array instead, for concat()
          const existingMutations = ensureArray(existingHandler(...arguments));
          const localMutations = ensureArray(localHandler(...arguments));
          return existingMutations.concat(localMutations);
        };
      } else {
        finalHandlers[eventName] = localHandler;
      }
    });
    return finalHandlers;
  });
};
const combineDefaultEvents = defaultEvents => {
  // takes a defaultEvents array and returns one equal or lesser length,
  // by combining any events that have the same target
  const eventsByTarget = (0, _groupBy2.default)(defaultEvents, "target");
  const events = (0, _toPairs2.default)(eventsByTarget).map(_ref => {
    let [target, eventsArray] = _ref;
    const newEventsArray = eventsArray.filter(Boolean);
    return (0, _isEmpty2.default)(newEventsArray) ? null : {
      target,
      eventHandlers: combineEventHandlers(eventsArray.map(event => event.eventHandlers))
      // note: does not currently handle eventKey or childName
    };
  });
  return events.filter(Boolean);
};
const combineContainerMixins = (mixins, Container) => {
  // similar to Object.assign(A, B), this function will decide conflicts in favor mixinB.
  // this applies to propTypes and defaultProps.
  // getChildren will call A's getChildren() and pass the resulting children to B's.
  // defaultEvents attempts to resolve any conflicts between A and B's defaultEvents.
  const Classes = mixins.map(mixin => mixin(Container));
  const instances = Classes.map(Class => new Class());
  const NaiveCombinedContainer = (0, _flow2.default)(mixins)(Container);
  const displayType = Classes.map(Class => {
    const match = Class.displayName.match(/Victory(.*)Container/);
    return match[1] || "";
  }).join("");
  return class VictoryCombinedContainer extends NaiveCombinedContainer {
    static displayName = `Victory${displayType}Container`;
    static propTypes = Classes.reduce((propTypes, Class) => ({
      ...propTypes,
      ...Class.propTypes
    }), {});
    static defaultProps = Classes.reduce((defaultProps, Class) => ({
      ...defaultProps,
      ...Class.defaultProps
    }), {});
    static defaultEvents(props) {
      return combineDefaultEvents(Classes.reduce((defaultEvents, Class) => {
        const events = _victoryCore.Helpers.isFunction(Class.defaultEvents) ? Class.defaultEvents(props) : Class.defaultEvents;
        return [...defaultEvents, ...events];
      }, []));
    }
    getChildren(props) {
      return instances.reduce((children, instance) => instance.getChildren({
        ...props,
        children
      }), props.children);
    }
  };
};
exports.combineContainerMixins = combineContainerMixins;
const checkBehaviorName = (behavior, behaviors) => {
  if (behavior && !behaviors.includes(behavior)) {
    _victoryCore.Log.warn(`"${behavior}" is not a valid behavior. Choose from [${behaviors.join(", ")}].`);
  }
};
const makeCreateContainerFunction = (mixinMap, Container) => function (behaviorA, behaviorB) {
  const behaviors = Object.keys(mixinMap);
  checkBehaviorName(behaviorA, behaviors);
  checkBehaviorName(behaviorB, behaviors);
  if (arguments.length <= 2 ? 0 : arguments.length - 2) {
    _victoryCore.Log.warn("too many arguments given to createContainer (maximum accepted: 2).");
  }
  const firstMixins = mixinMap[behaviorA];
  const secondMixins = mixinMap[behaviorB] || [];
  if (!firstMixins) {
    return Container;
  }
  return combineContainerMixins([...firstMixins, ...secondMixins], Container);
};
exports.makeCreateContainerFunction = makeCreateContainerFunction;
const createContainer = exports.createContainer = makeCreateContainerFunction({
  zoom: [_victoryZoomContainer.zoomContainerMixin],
  voronoi: [_victoryVoronoiContainer.voronoiContainerMixin],
  selection: [_victorySelectionContainer.selectionContainerMixin],
  cursor: [_victoryCursorContainer.cursorContainerMixin],
  brush: [_victoryBrushContainer.brushContainerMixin]
}, _victoryCore.VictoryContainer);