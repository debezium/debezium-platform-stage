"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhenDecorator = exports.DEFAULT_WHEN_OFFSET = exports.DEFAULT_WHEN_SIZE = void 0;
const tslib_1 = require("tslib");
const React = tslib_1.__importStar(require("react"));
const react_core_1 = require("@patternfly/react-core");
const react_styles_1 = require("@patternfly/react-styles");
const topology_pipelines_1 = tslib_1.__importDefault(require("../../css/topology-pipelines"));
const topology_components_1 = tslib_1.__importDefault(require("../../css/topology-components"));
const mobx_exports_1 = require("../../mobx-exports");
const utils_1 = require("../utils");
const layouts_1 = require("../../layouts");
exports.DEFAULT_WHEN_SIZE = 12;
exports.DEFAULT_WHEN_OFFSET = 12;
exports.WhenDecorator = (0, mobx_exports_1.observer)(({ element, width = exports.DEFAULT_WHEN_SIZE, height = exports.DEFAULT_WHEN_SIZE, className, status, leftOffset = exports.DEFAULT_WHEN_OFFSET, topOffset = exports.DEFAULT_WHEN_OFFSET, edgeLength = exports.DEFAULT_WHEN_OFFSET, toolTip, disableTooltip = false }) => {
    var _a, _b, _c;
    const nodeElement = element;
    const diamondNodeRef = React.useRef();
    const { height: taskHeight, width: taskWidth } = nodeElement.getBounds();
    const verticalLayout = ((_c = (_b = (_a = element.getGraph()).getLayoutOptions) === null || _b === void 0 ? void 0 : _b.call(_a)) === null || _c === void 0 ? void 0 : _c.rankdir) === layouts_1.TOP_TO_BOTTOM;
    const points = React.useMemo(() => {
        if (verticalLayout) {
            const y = -topOffset;
            const startX = taskWidth / 2;
            return `
        ${startX} ${y}
        ${startX - width / 2} ${y - height / 2}
        ${startX} ${y - height}
        ${startX + width / 2} ${y - height / 2}
      `;
        }
        const y = taskHeight / 2 - height / 2;
        const startX = -width - leftOffset;
        return `
      ${startX + width / 2} ${y}
      ${startX + width} ${y + height / 2}
      ${startX + width / 2} ${y + height}
      ${startX} ${y + height / 2}
    `;
    }, [height, leftOffset, taskHeight, taskWidth, topOffset, verticalLayout, width]);
    const linePoints = verticalLayout
        ? {
            x1: taskWidth / 2,
            y1: -topOffset,
            x2: taskWidth / 2,
            y2: -topOffset + edgeLength
        }
        : {
            x1: -leftOffset,
            y1: taskHeight / 2,
            x2: -leftOffset + edgeLength,
            y2: taskHeight / 2
        };
    const diamondNode = (React.createElement("g", { className: className, ref: diamondNodeRef },
        React.createElement("line", Object.assign({ className: (0, react_styles_1.css)(topology_components_1.default.topologyEdgeBackground) }, linePoints)),
        React.createElement("line", Object.assign({ className: (0, react_styles_1.css)(topology_components_1.default.topologyEdge, topology_pipelines_1.default.topologyPipelinesWhenExpressionEdge) }, linePoints)),
        React.createElement("polygon", { "data-test": "diamond-decorator", className: (0, react_styles_1.css)(topology_pipelines_1.default.topologyPipelinesWhenExpressionBackground, (0, utils_1.getWhenStatusModifier)(status)), points: points })));
    return toolTip && !disableTooltip ? (React.createElement(react_core_1.Tooltip, { triggerRef: diamondNodeRef, position: "bottom", enableFlip: false, content: React.createElement("div", { "data-test": "when-expression-tooltip" }, toolTip) }, diamondNode)) : (diamondNode);
});
exports.WhenDecorator.displayName = 'WhenDecorator';
exports.default = exports.WhenDecorator;
//# sourceMappingURL=WhenDecorator.js.map