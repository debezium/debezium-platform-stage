"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const React = tslib_1.__importStar(require("react"));
const mobx_1 = require("mobx");
const react_styles_1 = require("@patternfly/react-styles");
const topology_pipelines_1 = tslib_1.__importDefault(require("../../../css/topology-pipelines"));
const react_core_1 = require("@patternfly/react-core");
const mobx_exports_1 = require("../../../mobx-exports");
const types_1 = require("../../../types");
const types_2 = require("../../types");
const behavior_1 = require("../../../behavior");
const utils_1 = require("../../../utils");
const anchors_1 = require("../anchors");
const hooks_1 = require("../../../hooks");
const layouts_1 = require("../../../layouts");
const TaskPill_1 = tslib_1.__importDefault(require("./TaskPill"));
const STATUS_ICON_SIZE = 16;
const SCALE_UP_TIME = 200;
const TaskNodeInner = (0, mobx_exports_1.observer)((_a) => {
    var _b, _c, _d;
    var { element, className, statusIconSize = STATUS_ICON_SIZE, scaleNode, toolTip, toolTipProps, disableTooltip = false, whenSize = 0, whenOffset = 0 } = _a, rest = tslib_1.__rest(_a, ["element", "className", "statusIconSize", "scaleNode", "toolTip", "toolTipProps", "disableTooltip", "whenSize", "whenOffset"]);
    const [hovered, hoverRef] = (0, utils_1.useHover)();
    // const isHover = hover !== undefined ? hover : hovered;
    const taskRef = React.useRef();
    const [pillSize, pillRef] = (0, utils_1.useSize)();
    const pillWidth = (pillSize === null || pillSize === void 0 ? void 0 : pillSize.width) || 0;
    const { width } = element.getBounds();
    const detailsLevel = element.getGraph().getDetailsLevel();
    const verticalLayout = ((_d = (_c = (_b = element.getGraph()).getLayoutOptions) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.rankdir) === layouts_1.TOP_TO_BOTTOM;
    (0, behavior_1.useAnchor)(React.useCallback((node) => new anchors_1.TaskNodeSourceAnchor(node, detailsLevel, statusIconSize + 4, verticalLayout), 
    // Include scaleNode to cause an update when it changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [detailsLevel, statusIconSize, scaleNode, verticalLayout]), types_1.AnchorEnd.source);
    (0, behavior_1.useAnchor)(React.useCallback((node) => new anchors_1.TaskNodeTargetAnchor(node, whenSize + whenOffset, detailsLevel, statusIconSize + 4, verticalLayout), 
    // Include scaleNode to cause an update when it changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [whenSize, whenOffset, detailsLevel, statusIconSize, scaleNode, verticalLayout]), types_1.AnchorEnd.target);
    React.useEffect(() => {
        const sourceEdges = element.getSourceEdges();
        (0, mobx_1.action)(() => {
            const indent = detailsLevel === types_1.ScaleDetailsLevel.high && !verticalLayout ? width - pillWidth : 0;
            sourceEdges.forEach((edge) => {
                var _a;
                const data = edge.getData();
                if (((_a = data === null || data === void 0 ? void 0 : data.indent) !== null && _a !== void 0 ? _a : 0) !== indent) {
                    edge.setData(Object.assign(Object.assign({}, (data || {})), { indent }));
                }
            });
        })();
        return (0, mobx_1.action)(() => {
            sourceEdges.forEach((edge) => {
                const data = edge.getData();
                if (data === null || data === void 0 ? void 0 : data.indent) {
                    edge.setData(Object.assign(Object.assign({}, (data || {})), { indent: 0 }));
                }
            });
        });
    }, [detailsLevel, element, pillWidth, verticalLayout, width]);
    const scale = element.getGraph().getScale();
    const nodeScale = (0, hooks_1.useScaleNode)(scaleNode, scale, SCALE_UP_TIME);
    const { translateX, translateY } = (0, utils_1.getNodeScaleTranslation)(element, nodeScale, scaleNode);
    const taskPill = (React.createElement(TaskPill_1.default, Object.assign({ x: verticalLayout ? 0 : whenOffset, y: 0, className: (0, react_styles_1.css)('pf-topology__pipelines__task-node', className), scaleNode: scaleNode, hover: hovered, statusIconSize: statusIconSize, pillRef: pillRef, width: width, taskRef: taskRef, element: element }, rest)));
    return (React.createElement("g", { className: (0, react_styles_1.css)('pf-topology__pipelines__task-node', className), transform: `${scaleNode ? `translate(${translateX}, ${translateY})` : ''} scale(${nodeScale})`, ref: hoverRef }, !toolTip || disableTooltip ? (taskPill) : (React.createElement(react_core_1.Tooltip, Object.assign({ triggerRef: taskRef, position: "bottom", enableFlip: false }, (toolTipProps !== null && toolTipProps !== void 0 ? toolTipProps : {}), { content: toolTip }), taskPill))));
});
const TaskNode = (_a) => {
    var { element, paddingX = 8, paddingY = 8, statusIconSize = STATUS_ICON_SIZE, showStatusState = true, hiddenDetailsShownStatuses = [types_2.RunStatus.Failed, types_2.RunStatus.FailedToStart, types_2.RunStatus.Cancelled], badgeClassName = topology_pipelines_1.default.topologyPipelinesPillBadge, taskIconPadding = 4, truncateLength = 14, disableTooltip = false, whenSize = 0, whenOffset = 0 } = _a, rest = tslib_1.__rest(_a, ["element", "paddingX", "paddingY", "statusIconSize", "showStatusState", "hiddenDetailsShownStatuses", "badgeClassName", "taskIconPadding", "truncateLength", "disableTooltip", "whenSize", "whenOffset"]);
    if (!(0, types_1.isNode)(element)) {
        throw new Error('TaskNode must be used only on Node elements');
    }
    return (React.createElement(TaskNodeInner, Object.assign({ element: element, paddingX: paddingX, paddingY: paddingY, statusIconSize: statusIconSize, showStatusState: showStatusState, hiddenDetailsShownStatuses: hiddenDetailsShownStatuses, badgeClassName: badgeClassName, taskIconPadding: taskIconPadding, truncateLength: truncateLength, disableTooltip: disableTooltip, whenSize: whenSize, whenOffset: whenOffset }, rest)));
};
exports.default = TaskNode;
//# sourceMappingURL=TaskNode.js.map