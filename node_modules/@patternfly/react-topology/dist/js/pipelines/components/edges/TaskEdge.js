"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const React = tslib_1.__importStar(require("react"));
const mobx_react_1 = require("mobx-react");
const react_styles_1 = require("@patternfly/react-styles");
const topology_components_1 = tslib_1.__importDefault(require("../../../css/topology-components"));
const types_1 = require("../../../types");
const utils_1 = require("../../utils");
const layouts_1 = require("../../../layouts");
const components_1 = require("../../../components");
const Layer_1 = tslib_1.__importDefault(require("../../../components/layers/Layer"));
const const_1 = require("../../../const");
const TaskEdgeInner = (0, mobx_react_1.observer)(({ element, startTerminalType = types_1.EdgeTerminalType.none, startTerminalClass, startTerminalStatus, startTerminalSize = 14, endTerminalType = types_1.EdgeTerminalType.none, endTerminalClass, endTerminalStatus, endTerminalSize = 14, className, nodeSeparation, selected, onSelect }) => {
    var _a, _b, _c, _d;
    const startPoint = element.getStartPoint();
    const endPoint = element.getEndPoint();
    const groupClassName = (0, react_styles_1.css)(topology_components_1.default.topologyEdge, className, selected && 'pf-m-selected', onSelect && 'pf-m-selectable');
    const startIndent = ((_a = element.getData()) === null || _a === void 0 ? void 0 : _a.indent) || 0;
    const verticalLayout = ((_d = (_c = (_b = element.getGraph()).getLayoutOptions) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.rankdir) === layouts_1.TOP_TO_BOTTOM;
    const edgePath = (0, utils_1.integralShapePath)(startPoint, endPoint, startIndent, nodeSeparation, verticalLayout);
    const edgeBackground = (React.createElement("path", { onClick: onSelect, className: (0, react_styles_1.css)(topology_components_1.default.topologyEdgeBackground, onSelect && 'pf-m-selectable'), d: edgePath }));
    return (React.createElement("g", { "data-test-id": "task-handler", className: groupClassName },
        selected ? edgeBackground : React.createElement(Layer_1.default, { id: const_1.TOP_LAYER }, edgeBackground),
        React.createElement("path", { d: edgePath, transform: "translate(0.5,0.5)", shapeRendering: "geometricPrecision", fillOpacity: 0 }),
        React.createElement(components_1.DefaultConnectorTerminal, { className: startTerminalClass, isTarget: false, edge: element, size: startTerminalSize, terminalType: startTerminalType, status: startTerminalStatus }),
        React.createElement(components_1.DefaultConnectorTerminal, { className: endTerminalClass, isTarget: true, edge: element, size: endTerminalSize, terminalType: endTerminalType, status: endTerminalStatus, startPoint: verticalLayout ? endPoint.clone().translate(0, -1) : endPoint.clone().translate(-1, 0) })));
});
const TaskEdge = (_a) => {
    var { element } = _a, rest = tslib_1.__rest(_a, ["element"]);
    if (!(0, types_1.isEdge)(element)) {
        throw new Error('TaskEdge must be used only on Edge elements');
    }
    return React.createElement(TaskEdgeInner, Object.assign({ element: element }, rest));
};
exports.default = TaskEdge;
//# sourceMappingURL=TaskEdge.js.map