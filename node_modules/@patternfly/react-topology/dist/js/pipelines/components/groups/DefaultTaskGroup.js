"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const React = tslib_1.__importStar(require("react"));
const mobx_react_1 = require("mobx-react");
const geom_1 = require("../../../geom");
const types_1 = require("../../../types");
const mobx_exports_1 = require("../../../mobx-exports");
const utils_1 = require("../../utils");
const DefaultTaskGroupCollapsed_1 = tslib_1.__importDefault(require("./DefaultTaskGroupCollapsed"));
const DefaultTaskGroupExpanded_1 = tslib_1.__importDefault(require("./DefaultTaskGroupExpanded"));
const const_1 = require("../../const");
const DefaultTaskGroupInner = (0, mobx_react_1.observer)((_a) => {
    var { element, badge, onCollapseChange, collapsedShadowCount, recreateLayoutOnCollapseChange, getEdgeCreationTypes } = _a, rest = tslib_1.__rest(_a, ["element", "badge", "onCollapseChange", "collapsedShadowCount", "recreateLayoutOnCollapseChange", "getEdgeCreationTypes"]);
    const childCount = element.getAllNodeChildren().length;
    const handleCollapse = (0, mobx_exports_1.action)((group, collapsed) => {
        if (collapsed && rest.collapsedWidth !== undefined && rest.collapsedHeight !== undefined) {
            group.setDimensions(new geom_1.Dimensions(rest.collapsedWidth, rest.collapsedHeight));
        }
        group.setCollapsed(collapsed);
        if (recreateLayoutOnCollapseChange) {
            const controller = group.hasController() && group.getController();
            if (controller) {
                const model = controller.toModel();
                const creationTypes = getEdgeCreationTypes ? getEdgeCreationTypes() : {};
                const pipelineNodes = model.nodes
                    .filter((n) => n.type !== (creationTypes.spacerNodeType || const_1.DEFAULT_SPACER_NODE_TYPE))
                    .map((n) => (Object.assign(Object.assign({}, n), { visible: true })));
                const spacerNodes = (0, utils_1.getSpacerNodes)(pipelineNodes, creationTypes.spacerNodeType, creationTypes.finallyNodeTypes);
                const nodes = [...pipelineNodes, ...spacerNodes];
                const edges = (0, utils_1.getEdgesFromNodes)(pipelineNodes, creationTypes.spacerNodeType, creationTypes.edgeType, creationTypes.edgeType, creationTypes.finallyNodeTypes, creationTypes.finallyEdgeType);
                controller.fromModel({ nodes, edges }, true);
                controller.getGraph().layout();
            }
        }
        const graph = group.getGraph();
        if (graph) {
            if (!collapsed) {
                graph.fit(80, group);
            }
            else {
                // Get the current graph required size
                let rect;
                graph.getNodes().forEach((c) => {
                    const b = c.getBounds();
                    if (!rect) {
                        rect = b.clone();
                    }
                    else {
                        rect.union(b);
                    }
                });
                // If the required size is smaller, zoom in to fit the current graph
                const graphBounds = graph.getBounds();
                if (rect.width < graphBounds.width || rect.height < graphBounds.height) {
                    graph.fit(80);
                }
                // Center the graph on the group that was collapsed
                graph.centerInView(group);
            }
        }
        onCollapseChange && onCollapseChange(group, collapsed);
    });
    if (element.isCollapsed()) {
        return (React.createElement(DefaultTaskGroupCollapsed_1.default, Object.assign({ element: element, shadowCount: collapsedShadowCount, onCollapseChange: handleCollapse, badge: badge || `${childCount}` }, rest)));
    }
    return React.createElement(DefaultTaskGroupExpanded_1.default, Object.assign({ element: element, badge: badge, onCollapseChange: handleCollapse }, rest));
});
const DefaultTaskGroup = (_a) => {
    var { element, badgeColor = '#f5f5f5', badgeBorderColor = '#d2d2d2', badgeTextColor = '#000000' } = _a, rest = tslib_1.__rest(_a, ["element", "badgeColor", "badgeBorderColor", "badgeTextColor"]);
    if (!(0, types_1.isNode)(element)) {
        throw new Error('DefaultTaskGroup must be used only on Node elements');
    }
    return (React.createElement(DefaultTaskGroupInner, Object.assign({ element: element, badgeColor: badgeColor, badgeBorderColor: badgeBorderColor, badgeTextColor: badgeTextColor }, rest)));
};
exports.default = DefaultTaskGroup;
//# sourceMappingURL=DefaultTaskGroup.js.map