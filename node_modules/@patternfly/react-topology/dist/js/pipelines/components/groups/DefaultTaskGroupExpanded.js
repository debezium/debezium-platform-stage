"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const React = tslib_1.__importStar(require("react"));
const mobx_react_1 = require("mobx-react");
const react_styles_1 = require("@patternfly/react-styles");
const topology_components_1 = tslib_1.__importDefault(require("../../../css/topology-components"));
const compress_alt_icon_1 = tslib_1.__importDefault(require("@patternfly/react-icons/dist/esm/icons/compress-alt-icon"));
const NodeLabel_1 = tslib_1.__importDefault(require("../../../components/nodes/labels/NodeLabel"));
const layers_1 = require("../../../components/layers");
const const_1 = require("../../../const");
const utils_1 = require("../../../utils");
const types_1 = require("../../../types");
const behavior_1 = require("../../../behavior");
const layouts_1 = require("../../../layouts");
const TaskGroupSourceAnchor_1 = tslib_1.__importDefault(require("../anchors/TaskGroupSourceAnchor"));
const TaskGroupTargetAnchor_1 = tslib_1.__importDefault(require("../anchors/TaskGroupTargetAnchor"));
const DefaultTaskGroupExpanded = (0, mobx_react_1.observer)(({ className, element, collapsible, selected, onSelect, hover, label, secondaryLabel, showLabel = true, showLabelOnHover, hideDetailsAtMedium, status, GroupLabelComponent = NodeLabel_1.default, truncateLength, canDrop, dropTarget, onContextMenu, contextMenuOpen, dragging, dragNodeRef, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, labelOffset = 17, centerLabelOnEdge, labelIconClass, labelIcon, labelIconPadding, onCollapseChange, labelPosition, borderRadius = 16 }) => {
    var _a, _b, _c, _d;
    const [hovered, hoverRef] = (0, utils_1.useHover)(200, 500);
    const [labelHover, labelHoverRef] = (0, utils_1.useHover)(0);
    const dragLabelRef = (0, behavior_1.useDragNode)()[1];
    const refs = (0, utils_1.useCombineRefs)(hoverRef, dragNodeRef);
    const isHover = hover !== undefined ? hover : hovered || labelHover;
    const [labelSize, labelRef] = (0, utils_1.useSize)([centerLabelOnEdge]);
    const verticalLayout = ((_c = (_b = (_a = element.getGraph()).getLayoutOptions) === null || _b === void 0 ? void 0 : _b.call(_a)) === null || _c === void 0 ? void 0 : _c.rankdir) === layouts_1.TOP_TO_BOTTOM;
    const groupLabelPosition = (_d = labelPosition !== null && labelPosition !== void 0 ? labelPosition : element.getLabelPosition()) !== null && _d !== void 0 ? _d : types_1.LabelPosition.bottom;
    let parent = element.getParent();
    const detailsLevel = element.getGraph().getDetailsLevel();
    let altGroup = false;
    while (!(0, types_1.isGraph)(parent)) {
        altGroup = !altGroup;
        parent = parent.getParent();
    }
    const labelShown = showLabel &&
        (!hideDetailsAtMedium || detailsLevel === types_1.ScaleDetailsLevel.high || (isHover && showLabelOnHover)) &&
        (label || element.getLabel());
    const anchorOffset = verticalLayout ? (labelSize === null || labelSize === void 0 ? void 0 : labelSize.height) / 2 : (labelSize === null || labelSize === void 0 ? void 0 : labelSize.width) / 2;
    (0, behavior_1.useAnchor)(React.useCallback((node) => new TaskGroupSourceAnchor_1.default(node, verticalLayout, labelShown &&
        ((centerLabelOnEdge && labelPosition === types_1.LabelPosition.bottom && verticalLayout) ||
            (labelPosition === types_1.LabelPosition.right && !verticalLayout)) &&
        labelSize
        ? anchorOffset
        : 0), [labelShown, anchorOffset, centerLabelOnEdge, labelPosition, labelSize, verticalLayout]), types_1.AnchorEnd.source);
    (0, behavior_1.useAnchor)(React.useCallback((node) => new TaskGroupTargetAnchor_1.default(node, verticalLayout, labelShown &&
        ((centerLabelOnEdge && labelPosition === types_1.LabelPosition.top && verticalLayout) ||
            (labelPosition === types_1.LabelPosition.left && !verticalLayout)) &&
        labelSize
        ? anchorOffset
        : 0), [labelShown, anchorOffset, centerLabelOnEdge, labelPosition, labelSize, verticalLayout]), types_1.AnchorEnd.target);
    const bounds = element.getBounds();
    const [labelX, labelY] = React.useMemo(() => {
        if (!showLabel || !(label || element.getLabel())) {
            return [0, 0];
        }
        switch (groupLabelPosition) {
            case types_1.LabelPosition.top:
                return [bounds.x + bounds.width / 2, -bounds.y + (centerLabelOnEdge ? 0 : labelOffset)];
            case types_1.LabelPosition.right:
                return [bounds.x + bounds.width + (centerLabelOnEdge ? 0 : labelOffset), bounds.y + bounds.height / 2];
            case types_1.LabelPosition.left:
                return [centerLabelOnEdge ? bounds.x : labelOffset, bounds.y + bounds.height / 2];
            case types_1.LabelPosition.bottom:
            default:
                return [bounds.x + bounds.width / 2, bounds.y + bounds.height + (centerLabelOnEdge ? 0 : labelOffset)];
        }
    }, [
        showLabel,
        label,
        element,
        groupLabelPosition,
        bounds.x,
        bounds.width,
        bounds.y,
        bounds.height,
        centerLabelOnEdge,
        labelOffset
    ]);
    const children = element.getNodes().filter((c) => c.isVisible());
    if (children.length === 0) {
        return null;
    }
    const groupClassName = (0, react_styles_1.css)(topology_components_1.default.topologyGroup, className, altGroup && 'pf-m-alt-group', canDrop && 'pf-m-highlight', dragging && 'pf-m-dragging', selected && 'pf-m-selected');
    const innerGroupClassName = (0, react_styles_1.css)(topology_components_1.default.topologyGroup, className, altGroup && 'pf-m-alt-group', canDrop && 'pf-m-highlight', dragging && 'pf-m-dragging', selected && 'pf-m-selected', isHover && 'pf-m-hover', canDrop && dropTarget && 'pf-m-drop-target');
    const scale = element.getGraph().getScale();
    const medScale = element.getGraph().getDetailsLevelThresholds().medium;
    const labelScale = detailsLevel !== types_1.ScaleDetailsLevel.high ? Math.min(1 / scale, 1 / medScale) : 1;
    const labelPositionScale = detailsLevel !== types_1.ScaleDetailsLevel.high ? 1 / labelScale : 1;
    const groupLabel = labelShown ? (React.createElement("g", { ref: labelHoverRef, transform: isHover ? `scale(${labelScale})` : undefined },
        React.createElement(GroupLabelComponent, { element: element, boxRef: labelRef, className: topology_components_1.default.topologyGroupLabel, x: labelX * labelPositionScale, y: labelY * labelPositionScale, position: labelPosition, centerLabelOnEdge: centerLabelOnEdge, runStatus: status, paddingX: 8, paddingY: 5, dragRef: dragNodeRef ? dragLabelRef : undefined, status: element.getNodeStatus(), selected: selected, secondaryLabel: secondaryLabel, truncateLength: truncateLength, badge: badge, badgeColor: badgeColor, badgeTextColor: badgeTextColor, badgeBorderColor: badgeBorderColor, badgeClassName: badgeClassName, badgeLocation: badgeLocation, labelIconClass: labelIconClass, labelIcon: labelIcon, labelIconPadding: labelIconPadding, onContextMenu: onContextMenu, contextMenuOpen: contextMenuOpen, hover: isHover || labelHover, actionIcon: collapsible ? React.createElement(compress_alt_icon_1.default, null) : undefined, onActionIconClick: () => onCollapseChange(element, true) }, label || element.getLabel()))) : null;
    return (React.createElement("g", { onContextMenu: onContextMenu, onClick: onSelect, className: groupClassName },
        React.createElement(layers_1.Layer, { id: const_1.GROUPS_LAYER },
            React.createElement("g", { ref: refs, onContextMenu: onContextMenu, onClick: onSelect, className: innerGroupClassName },
                React.createElement("rect", { x: bounds.x, y: bounds.y, width: bounds.width, height: bounds.height, className: topology_components_1.default.topologyGroupBackground, rx: borderRadius, ry: borderRadius })),
            groupLabel && isHover ? (React.createElement(layers_1.Layer, { id: const_1.TOP_LAYER },
                React.createElement("g", { className: innerGroupClassName }, groupLabel))) : (groupLabel))));
});
exports.default = DefaultTaskGroupExpanded;
//# sourceMappingURL=DefaultTaskGroupExpanded.js.map