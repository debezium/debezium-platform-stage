"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DagreLayout = exports.LEFT_TO_RIGHT = exports.TOP_TO_BOTTOM = void 0;
const tslib_1 = require("tslib");
const dagre = tslib_1.__importStar(require("@dagrejs/dagre"));
const types_1 = require("../types");
const BaseLayout_1 = require("./BaseLayout");
const DagreNode_1 = require("./DagreNode");
const DagreGroup_1 = require("./DagreGroup");
const DagreLink_1 = require("./DagreLink");
exports.TOP_TO_BOTTOM = 'TB';
exports.LEFT_TO_RIGHT = 'LR';
class DagreLayout extends BaseLayout_1.BaseLayout {
    constructor(graph, options) {
        super(graph, options);
        this.dagreOptions = Object.assign(Object.assign(Object.assign({}, this.options), { layoutOnDrag: false, marginx: 0, marginy: 0, nodesep: this.options.nodeDistance, edgesep: this.options.linkDistance, ranker: 'tight-tree', rankdir: exports.TOP_TO_BOTTOM }), options);
    }
    createLayoutNode(node, nodeDistance, index) {
        return new DagreNode_1.DagreNode(node, nodeDistance, index);
    }
    createLayoutLink(edge, source, target, isFalse) {
        return new DagreLink_1.DagreLink(edge, source, target, isFalse);
    }
    createLayoutGroup(node, padding, index) {
        return new DagreGroup_1.DagreGroup(node, padding, index);
    }
    updateEdgeBendpoints(edges) {
        edges.forEach((edge) => {
            const link = edge;
            link.updateBendpoints();
        });
    }
    getFauxEdges() {
        return [];
    }
    startLayout(graph, initialRun, addingNodes) {
        var _a, _b;
        if (initialRun || addingNodes) {
            const dagreGraph = new dagre.graphlib.Graph({ compound: true });
            const options = Object.assign({}, this.dagreOptions);
            Object.keys(BaseLayout_1.LAYOUT_DEFAULTS).forEach((key) => delete options[key]);
            dagreGraph.setGraph(options);
            if (!this.dagreOptions.ignoreGroups) {
                this.groups.forEach((group) => {
                    dagreGraph.setNode(group.id, group);
                    dagreGraph.setParent(group.id, group.element.getParent().getId());
                });
            }
            (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
                const updateNode = node.getUpdatableNode();
                dagreGraph.setNode(node.id, updateNode);
                if (!this.dagreOptions.ignoreGroups) {
                    dagreGraph.setParent(node.id, node.element.getParent().getId());
                }
            });
            (_b = this.edges) === null || _b === void 0 ? void 0 : _b.forEach((dagreEdge) => {
                dagreGraph.setEdge(dagreEdge.source.id, dagreEdge.target.id, dagreEdge);
            });
            dagre.layout(dagreGraph);
            this.nodes.forEach((node) => {
                node.updateToNode(dagreGraph.node(node.id));
            });
            this.updateEdgeBendpoints(this.edges);
        }
        if (this.dagreOptions.layoutOnDrag) {
            this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
        }
        else {
            this.graph.getController().fireEvent(types_1.GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
        }
    }
}
exports.DagreLayout = DagreLayout;
//# sourceMappingURL=DagreLayout.js.map