"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGroupChildrenDimensions = exports.getGroupPadding = exports.getElementPadding = exports.getClosestVisibleParent = exports.getTopCollapsedParent = exports.leafNodeElements = exports.groupNodeElements = void 0;
const tslib_1 = require("tslib");
const types_1 = require("../types");
const Rect_1 = tslib_1.__importDefault(require("../geom/Rect"));
const geom_1 = require("../geom");
const groupNodeElements = (nodes) => {
    if (!nodes.length) {
        return [];
    }
    const groupNodes = [];
    nodes.forEach((nextNode) => {
        if ((0, types_1.isNode)(nextNode) && nextNode.isGroup() && !nextNode.isCollapsed()) {
            groupNodes.push(nextNode);
            groupNodes.push(...groupNodeElements(nextNode.getChildren()));
        }
    });
    return groupNodes;
};
exports.groupNodeElements = groupNodeElements;
const leafNodeElements = (nodeElements) => {
    const nodes = [];
    if (!nodeElements) {
        return nodes;
    }
    if (Array.isArray(nodeElements)) {
        nodeElements.forEach((nodeElement) => {
            nodes.push(...leafNodeElements(nodeElement));
        });
        return nodes;
    }
    if (nodeElements.isGroup() && !nodeElements.isCollapsed()) {
        const leafNodes = [];
        const children = nodeElements.getChildren().filter((e) => (0, types_1.isNode)(e));
        children.forEach((element) => leafNodes.push(...leafNodeElements(element)));
        return leafNodes;
    }
    return [nodeElements];
};
exports.leafNodeElements = leafNodeElements;
const getTopCollapsedParent = (node) => {
    let returnNode = node;
    try {
        let parent = !(0, types_1.isGraph)(node) && node.getParent();
        while (parent && !(0, types_1.isGraph)(parent)) {
            if (parent.isCollapsed()) {
                returnNode = parent;
            }
            parent = parent.getParent();
        }
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    return returnNode;
};
exports.getTopCollapsedParent = getTopCollapsedParent;
const getClosestVisibleParent = (node) => {
    if (!node) {
        return null;
    }
    let returnNode = null;
    try {
        let parent = node.getParent();
        while (parent) {
            if (!parent.isVisible()) {
                // parent isn't visible so no descendant could be visible
                returnNode = null;
            }
            else if (parent.isCollapsed() || !returnNode) {
                // parent is collapsed, no descendant is visible, but parent is
                returnNode = parent;
            }
            parent = parent.getParent();
        }
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    return returnNode;
};
exports.getClosestVisibleParent = getClosestVisibleParent;
const getElementPadding = (element) => {
    const stylePadding = element.getStyle().padding;
    if (!stylePadding) {
        return 0;
    }
    if (Array.isArray(stylePadding)) {
        // For a padding that is not consistent on all sides, use the max padding
        return stylePadding.reduce((val, current) => Math.max(val, current), 0);
    }
    return stylePadding;
};
exports.getElementPadding = getElementPadding;
const getGroupPadding = (element, padding = 0) => {
    if ((0, types_1.isGraph)(element)) {
        return padding;
    }
    let newPadding = padding;
    if ((0, types_1.isNode)(element) && element.isGroup() && !element.isCollapsed()) {
        newPadding += getElementPadding(element);
    }
    if (element.getParent()) {
        return getGroupPadding(element.getParent(), newPadding);
    }
    return newPadding;
};
exports.getGroupPadding = getGroupPadding;
const getGroupChildrenDimensions = (group) => {
    const children = group
        .getChildren()
        .filter(types_1.isNode)
        .filter((n) => n.isVisible());
    if (!children.length) {
        return new geom_1.Dimensions(0, 0);
    }
    let rect;
    children.forEach((c) => {
        if ((0, types_1.isNode)(c)) {
            const { padding } = c.getStyle();
            const b = c.getBounds();
            // Currently non-group nodes do not include their padding in the bounds
            if (!c.isGroup() && padding) {
                b.padding(c.getStyle().padding);
            }
            if (!rect) {
                rect = b.clone();
            }
            else {
                rect.union(b);
            }
        }
    });
    if (!rect) {
        rect = new Rect_1.default();
    }
    const { padding } = group.getStyle();
    const paddedRect = rect.padding(padding);
    return new geom_1.Dimensions(paddedRect.width, paddedRect.height);
};
exports.getGroupChildrenDimensions = getGroupChildrenDimensions;
//# sourceMappingURL=element-utils.js.map