"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const React = tslib_1.__importStar(require("react"));
const mobx_react_1 = require("mobx-react");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const layers_1 = require("../layers");
const react_styles_1 = require("@patternfly/react-styles");
const topology_components_1 = tslib_1.__importDefault(require("../../css/topology-components"));
const style_utils_1 = require("../../utils/style-utils");
const DefaultConnectorTerminal_1 = tslib_1.__importDefault(require("./terminals/DefaultConnectorTerminal"));
const const_1 = require("../../const");
const DefaultConnectorTag_1 = tslib_1.__importDefault(require("./DefaultConnectorTag"));
const terminalUtils_1 = require("./terminals/terminalUtils");
const DefaultEdgeInner = (0, mobx_react_1.observer)(({ element, dragging, sourceDragRef, targetDragRef, edgeStyle, animationDuration, onShowRemoveConnector, onHideRemoveConnector, startTerminalType = types_1.EdgeTerminalType.none, startTerminalClass, startTerminalStatus, startTerminalSize = 14, endTerminalType = types_1.EdgeTerminalType.directional, endTerminalClass, endTerminalStatus, endTerminalSize = 14, tag, tagClass, tagStatus, children, className, selected, onSelect, onContextMenu }) => {
    const [hover, hoverRef] = (0, utils_1.useHover)();
    const startPoint = element.getStartPoint();
    const endPoint = element.getEndPoint();
    // eslint-disable-next-line patternfly-react/no-layout-effect
    React.useLayoutEffect(() => {
        if (hover && !dragging) {
            onShowRemoveConnector && onShowRemoveConnector();
        }
        else {
            onHideRemoveConnector && onHideRemoveConnector();
        }
    }, [hover, dragging, onShowRemoveConnector, onHideRemoveConnector]);
    // If the edge connects to nodes in a collapsed group don't draw
    const sourceParent = (0, utils_1.getClosestVisibleParent)(element.getSource());
    const targetParent = (0, utils_1.getClosestVisibleParent)(element.getTarget());
    if ((0, types_1.isNode)(sourceParent) && sourceParent.isCollapsed() && sourceParent === targetParent) {
        return null;
    }
    const detailsLevel = element.getGraph().getDetailsLevel();
    const groupClassName = (0, react_styles_1.css)(topology_components_1.default.topologyEdge, className, dragging && 'pf-m-dragging', hover && !dragging && 'pf-m-hover', selected && !dragging && 'pf-m-selected', style_utils_1.StatusModifier[endTerminalStatus]);
    const edgeAnimationDuration = animationDuration !== null && animationDuration !== void 0 ? animationDuration : (0, style_utils_1.getEdgeAnimationDuration)(element.getEdgeAnimationSpeed());
    const linkClassName = (0, react_styles_1.css)(topology_components_1.default.topologyEdgeLink, (0, style_utils_1.getEdgeStyleClassModifier)(edgeStyle || element.getEdgeStyle()));
    const bendpoints = element.getBendpoints();
    const d = `M${startPoint.x} ${startPoint.y} ${bendpoints.map((b) => `L${b.x} ${b.y} `).join('')}L${endPoint.x} ${endPoint.y}`;
    const bgStartPoint = !startTerminalType || startTerminalType === types_1.EdgeTerminalType.none
        ? [startPoint.x, startPoint.y]
        : (0, terminalUtils_1.getConnectorStartPoint)((bendpoints === null || bendpoints === void 0 ? void 0 : bendpoints[0]) || endPoint, startPoint, startTerminalSize);
    const bgEndPoint = !endTerminalType || endTerminalType === types_1.EdgeTerminalType.none
        ? [endPoint.x, endPoint.y]
        : (0, terminalUtils_1.getConnectorStartPoint)((bendpoints === null || bendpoints === void 0 ? void 0 : bendpoints[bendpoints.length - 1]) || startPoint, endPoint, endTerminalSize);
    const backgroundPath = `M${bgStartPoint[0]} ${bgStartPoint[1]} ${bendpoints
        .map((b) => `L${b.x} ${b.y} `)
        .join('')}L${bgEndPoint[0]} ${bgEndPoint[1]}`;
    const showTag = tag && (detailsLevel === types_1.ScaleDetailsLevel.high || hover);
    const scale = element.getGraph().getScale();
    const tagScale = hover && !(detailsLevel === types_1.ScaleDetailsLevel.high) ? Math.max(1, 1 / scale) : 1;
    const tagPositionScale = hover && !(detailsLevel === types_1.ScaleDetailsLevel.high) ? Math.min(1, scale) : 1;
    return (React.createElement(layers_1.Layer, { id: dragging || hover ? const_1.TOP_LAYER : undefined },
        React.createElement("g", { ref: hoverRef, "data-test-id": "edge-handler", className: groupClassName, onClick: onSelect, onContextMenu: onContextMenu },
            React.createElement("path", { className: (0, react_styles_1.css)(topology_components_1.default.topologyEdgeBackground), d: backgroundPath, onMouseEnter: onShowRemoveConnector, onMouseLeave: onHideRemoveConnector }),
            React.createElement("path", { className: linkClassName, d: d, style: { animationDuration: `${edgeAnimationDuration}s` } }),
            showTag && (React.createElement("g", { transform: `scale(${hover ? tagScale : 1})` },
                React.createElement(DefaultConnectorTag_1.default, { className: tagClass, startPoint: element.getStartPoint().scale(tagPositionScale), endPoint: element.getEndPoint().scale(tagPositionScale), tag: tag, status: tagStatus }))),
            React.createElement(DefaultConnectorTerminal_1.default, { className: startTerminalClass, isTarget: false, edge: element, size: startTerminalSize, dragRef: sourceDragRef, terminalType: startTerminalType, status: startTerminalStatus, highlight: dragging || hover }),
            React.createElement(DefaultConnectorTerminal_1.default, { className: endTerminalClass, isTarget: true, dragRef: targetDragRef, edge: element, size: endTerminalSize, terminalType: endTerminalType, status: endTerminalStatus, highlight: dragging || hover }),
            children)));
});
const DefaultEdge = (_a) => {
    var { element, startTerminalType = types_1.EdgeTerminalType.none, startTerminalSize = 14, endTerminalType = types_1.EdgeTerminalType.directional, endTerminalSize = 14 } = _a, rest = tslib_1.__rest(_a, ["element", "startTerminalType", "startTerminalSize", "endTerminalType", "endTerminalSize"]);
    if (!(0, types_1.isEdge)(element)) {
        throw new Error('DefaultEdge must be used only on Edge elements');
    }
    return (React.createElement(DefaultEdgeInner, Object.assign({ element: element, startTerminalType: startTerminalType, startTerminalSize: startTerminalSize, endTerminalType: endTerminalType, endTerminalSize: endTerminalSize }, rest)));
};
exports.default = DefaultEdge;
//# sourceMappingURL=DefaultEdge.js.map