"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeLabelLocation = void 0;
const tslib_1 = require("tslib");
const React = tslib_1.__importStar(require("react"));
const mobx_react_1 = require("mobx-react");
const d3_polygon_1 = require("d3-polygon");
const react_styles_1 = require("@patternfly/react-styles");
const topology_components_1 = tslib_1.__importDefault(require("../../css/topology-components"));
const compress_alt_icon_1 = tslib_1.__importDefault(require("@patternfly/react-icons/dist/esm/icons/compress-alt-icon"));
const NodeLabel_1 = tslib_1.__importDefault(require("../nodes/labels/NodeLabel"));
const layers_1 = require("../layers");
const const_1 = require("../../const");
const utils_1 = require("../../utils");
const types_1 = require("../../types");
const behavior_1 = require("../../behavior");
// Return the point whose Y is the largest or smallest based on the labelPosition value.
// If multiple points are found, compute the center X between them
// export for testing only
function computeLabelLocation(points, labelPosition) {
    let lowPoints;
    let highPoints;
    const threshold = 5;
    if (labelPosition === types_1.LabelPosition.top) {
        points.forEach((p) => {
            const delta = !highPoints ? -Infinity : Math.round(p[1]) - Math.round(highPoints[0][1]);
            // If the difference is greater than the threshold, update the highest point
            if (delta < -threshold) {
                highPoints = [p];
            }
            else if (Math.abs(delta) <= threshold) {
                if (!highPoints) {
                    highPoints = [];
                }
                highPoints.push(p);
            }
        });
        // find min and max by x and y coordinates
        const minX = highPoints.reduce((min, p) => Math.min(min, p[0]), Infinity);
        const maxX = highPoints.reduce((max, p) => Math.max(max, p[0]), -Infinity);
        const minY = highPoints.reduce((min, p) => Math.min(min, p[1]), Infinity);
        // find max by size value
        const maxSize = highPoints.reduce((max, p) => Math.max(max, p[2]), -Infinity);
        return [
            (minX + maxX) / 2,
            minY,
            // use the max size value
            maxSize
        ];
    }
    points.forEach((p) => {
        const delta = !lowPoints ? Infinity : Math.round(p[1]) - Math.round(lowPoints[0][1]);
        if (delta > threshold) {
            lowPoints = [p];
        }
        else if (Math.abs(delta) <= threshold) {
            lowPoints.push(p);
        }
    });
    const minX = lowPoints.reduce((acc, point) => {
        return Math.min(acc, point[0]);
    }, Number.POSITIVE_INFINITY);
    const maxX = lowPoints.reduce((acc, point) => {
        return Math.max(acc, point[0]);
    }, Number.NEGATIVE_INFINITY);
    const maxSize = lowPoints.reduce((acc, point) => {
        return Math.max(acc, point[2]);
    }, Number.NEGATIVE_INFINITY);
    return [(minX + maxX) / 2, lowPoints[0][1], maxSize];
}
exports.computeLabelLocation = computeLabelLocation;
const DefaultGroupExpanded = ({ className, element, collapsible, selected, onSelect, hover, label, secondaryLabel, showLabel = true, showLabelOnHover, truncateLength, dndDropRef, droppable, canDrop, dropTarget, onContextMenu, contextMenuOpen, dragging, dragNodeRef, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, labelIconClass, labelIcon, labelPosition, labelIconPadding, onCollapseChange, hulledOutline = true, borderRadius = 16 }) => {
    var _a;
    const [hovered, hoverRef] = (0, utils_1.useHover)(200, 500);
    const [labelHover, labelHoverRef] = (0, utils_1.useHover)(0);
    const dragLabelRef = (0, behavior_1.useDragNode)()[1];
    const refs = (0, utils_1.useCombineRefs)(hoverRef, dragNodeRef);
    const isHover = hover !== undefined ? hover : hovered || labelHover;
    const anchorRef = (0, behavior_1.useSvgAnchor)();
    const outlineRef = (0, utils_1.useCombineRefs)(dndDropRef, anchorRef);
    const labelLocation = React.useRef();
    const pathRef = React.useRef();
    const boxRef = React.useRef(null);
    let parent = element.getParent();
    let altGroup = false;
    while (!(0, types_1.isGraph)(parent)) {
        altGroup = !altGroup;
        parent = parent.getParent();
    }
    // cast to number and coerce
    const padding = (0, utils_1.maxPadding)((_a = element.getStyle().padding) !== null && _a !== void 0 ? _a : 17);
    const hullPadding = (point) => (point[2] || 0) + padding;
    if (!droppable ||
        (hulledOutline && !pathRef.current) ||
        (!hulledOutline && !boxRef.current) ||
        !labelLocation.current) {
        const children = element.getNodes().filter((c) => c.isVisible());
        if (children.length === 0) {
            return null;
        }
        const points = [];
        children.forEach((c) => {
            if (c.getNodeShape() === types_1.NodeShape.circle) {
                const bounds = c.getBounds();
                const { width, height } = bounds;
                const { x, y } = bounds.getCenter();
                const radius = Math.max(width, height) / 2;
                points.push([x, y, radius]);
            }
            else {
                // add all 4 corners
                const { width, height, x, y } = c.getBounds();
                points.push([x, y, 0]);
                points.push([x + width, y, 0]);
                points.push([x, y + height, 0]);
                points.push([x + width, y + height, 0]);
            }
        });
        if (hulledOutline) {
            const hullPoints = points.length > 2 ? (0, d3_polygon_1.polygonHull)(points) : points;
            if (!hullPoints) {
                return null;
            }
            // change the box only when not dragging
            pathRef.current = (0, utils_1.hullPath)(hullPoints, hullPadding);
            // Compute the location of the group label.
            labelLocation.current = computeLabelLocation(hullPoints, labelPosition);
        }
        else {
            boxRef.current = element.getBounds();
            labelLocation.current =
                labelPosition === types_1.LabelPosition.top
                    ? [boxRef.current.x + boxRef.current.width / 2, boxRef.current.y, 0]
                    : [boxRef.current.x + boxRef.current.width / 2, boxRef.current.y + boxRef.current.height, 0];
        }
    }
    const groupClassName = (0, react_styles_1.css)(topology_components_1.default.topologyGroup, className, altGroup && 'pf-m-alt-group', canDrop && 'pf-m-highlight', dragging && 'pf-m-dragging', selected && 'pf-m-selected');
    const innerGroupClassName = (0, react_styles_1.css)(topology_components_1.default.topologyGroup, className, altGroup && 'pf-m-alt-group', canDrop && 'pf-m-highlight', dragging && 'pf-m-dragging', selected && 'pf-m-selected', (isHover || labelHover) && 'pf-m-hover', canDrop && dropTarget && 'pf-m-drop-target');
    const outlinePadding = hulledOutline ? hullPadding(labelLocation.current) : 0;
    const labelGap = 24;
    const startX = labelLocation.current[0];
    const startY = labelPosition === types_1.LabelPosition.top
        ? labelLocation.current[1] - outlinePadding - labelGap * 2
        : labelLocation.current[1] + outlinePadding + labelGap;
    const scale = element.getGraph().getScale();
    const medScale = element.getGraph().getDetailsLevelThresholds().medium;
    const labelScale = !showLabel && showLabelOnHover && isHover ? Math.min(1 / scale, 1 / medScale) : 1;
    const labelPositionScale = 1 / labelScale;
    const groupLabel = (showLabel || (showLabelOnHover && isHover)) && (label || element.getLabel()) ? (React.createElement("g", { ref: labelHoverRef, transform: isHover ? `scale(${labelScale})` : undefined },
        React.createElement(NodeLabel_1.default, { className: topology_components_1.default.topologyGroupLabel, x: startX * labelPositionScale, y: startY * labelPositionScale, paddingX: 8, paddingY: 5, dragRef: dragNodeRef ? dragLabelRef : undefined, status: element.getNodeStatus(), secondaryLabel: secondaryLabel, truncateLength: truncateLength, badge: badge, badgeColor: badgeColor, badgeTextColor: badgeTextColor, badgeBorderColor: badgeBorderColor, badgeClassName: badgeClassName, badgeLocation: badgeLocation, labelIconClass: labelIconClass, labelIcon: labelIcon, labelIconPadding: labelIconPadding, onContextMenu: onContextMenu, contextMenuOpen: contextMenuOpen, hover: isHover || labelHover, actionIcon: collapsible ? React.createElement(compress_alt_icon_1.default, null) : undefined, onActionIconClick: () => onCollapseChange(element, true) }, label || element.getLabel()))) : null;
    return (React.createElement("g", { onContextMenu: onContextMenu, onClick: onSelect, className: groupClassName },
        React.createElement(layers_1.Layer, { id: const_1.GROUPS_LAYER },
            React.createElement("g", { ref: refs, onContextMenu: onContextMenu, onClick: onSelect, className: innerGroupClassName }, hulledOutline ? (React.createElement("path", { ref: outlineRef, className: topology_components_1.default.topologyGroupBackground, d: pathRef.current })) : (React.createElement("rect", { ref: outlineRef, className: topology_components_1.default.topologyGroupBackground, x: boxRef.current.x, y: boxRef.current.y, width: boxRef.current.width, height: boxRef.current.height, rx: borderRadius, ry: borderRadius }))),
            groupLabel && isHover ? (React.createElement(layers_1.Layer, { id: const_1.TOP_LAYER },
                React.createElement("g", { className: innerGroupClassName }, groupLabel))) : (groupLabel))));
};
exports.default = (0, mobx_react_1.observer)(DefaultGroupExpanded);
//# sourceMappingURL=DefaultGroupExpanded.js.map