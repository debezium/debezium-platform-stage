import { isNode, isGraph } from '../types';
import Rect from '../geom/Rect';
import { Dimensions } from '../geom';
const groupNodeElements = (nodes) => {
    if (!nodes.length) {
        return [];
    }
    const groupNodes = [];
    nodes.forEach((nextNode) => {
        if (isNode(nextNode) && nextNode.isGroup() && !nextNode.isCollapsed()) {
            groupNodes.push(nextNode);
            groupNodes.push(...groupNodeElements(nextNode.getChildren()));
        }
    });
    return groupNodes;
};
const leafNodeElements = (nodeElements) => {
    const nodes = [];
    if (!nodeElements) {
        return nodes;
    }
    if (Array.isArray(nodeElements)) {
        nodeElements.forEach((nodeElement) => {
            nodes.push(...leafNodeElements(nodeElement));
        });
        return nodes;
    }
    if (nodeElements.isGroup() && !nodeElements.isCollapsed()) {
        const leafNodes = [];
        const children = nodeElements.getChildren().filter((e) => isNode(e));
        children.forEach((element) => leafNodes.push(...leafNodeElements(element)));
        return leafNodes;
    }
    return [nodeElements];
};
const getTopCollapsedParent = (node) => {
    let returnNode = node;
    try {
        let parent = !isGraph(node) && node.getParent();
        while (parent && !isGraph(parent)) {
            if (parent.isCollapsed()) {
                returnNode = parent;
            }
            parent = parent.getParent();
        }
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    return returnNode;
};
const getClosestVisibleParent = (node) => {
    if (!node) {
        return null;
    }
    let returnNode = null;
    try {
        let parent = node.getParent();
        while (parent) {
            if (!parent.isVisible()) {
                // parent isn't visible so no descendant could be visible
                returnNode = null;
            }
            else if (parent.isCollapsed() || !returnNode) {
                // parent is collapsed, no descendant is visible, but parent is
                returnNode = parent;
            }
            parent = parent.getParent();
        }
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    return returnNode;
};
const getElementPadding = (element) => {
    const stylePadding = element.getStyle().padding;
    if (!stylePadding) {
        return 0;
    }
    if (Array.isArray(stylePadding)) {
        // For a padding that is not consistent on all sides, use the max padding
        return stylePadding.reduce((val, current) => Math.max(val, current), 0);
    }
    return stylePadding;
};
const getGroupPadding = (element, padding = 0) => {
    if (isGraph(element)) {
        return padding;
    }
    let newPadding = padding;
    if (isNode(element) && element.isGroup() && !element.isCollapsed()) {
        newPadding += getElementPadding(element);
    }
    if (element.getParent()) {
        return getGroupPadding(element.getParent(), newPadding);
    }
    return newPadding;
};
const getGroupChildrenDimensions = (group) => {
    const children = group
        .getChildren()
        .filter(isNode)
        .filter((n) => n.isVisible());
    if (!children.length) {
        return new Dimensions(0, 0);
    }
    let rect;
    children.forEach((c) => {
        if (isNode(c)) {
            const { padding } = c.getStyle();
            const b = c.getBounds();
            // Currently non-group nodes do not include their padding in the bounds
            if (!c.isGroup() && padding) {
                b.padding(c.getStyle().padding);
            }
            if (!rect) {
                rect = b.clone();
            }
            else {
                rect.union(b);
            }
        }
    });
    if (!rect) {
        rect = new Rect();
    }
    const { padding } = group.getStyle();
    const paddedRect = rect.padding(padding);
    return new Dimensions(paddedRect.width, paddedRect.height);
};
export { groupNodeElements, leafNodeElements, getTopCollapsedParent, getClosestVisibleParent, getElementPadding, getGroupPadding, getGroupChildrenDimensions };
//# sourceMappingURL=element-utils.js.map