import { __rest } from "tslib";
import * as React from 'react';
import { observer } from 'mobx-react';
import { EdgeTerminalType, isEdge, isNode, ScaleDetailsLevel } from '../../types';
import { getClosestVisibleParent, useHover } from '../../utils';
import { Layer } from '../layers';
import { css } from '@patternfly/react-styles';
import styles from '../../css/topology-components';
import { getEdgeAnimationDuration, getEdgeStyleClassModifier, StatusModifier } from '../../utils/style-utils';
import DefaultConnectorTerminal from './terminals/DefaultConnectorTerminal';
import { TOP_LAYER } from '../../const';
import DefaultConnectorTag from './DefaultConnectorTag';
import { getConnectorStartPoint } from './terminals/terminalUtils';
const DefaultEdgeInner = observer(({ element, dragging, sourceDragRef, targetDragRef, edgeStyle, animationDuration, onShowRemoveConnector, onHideRemoveConnector, startTerminalType = EdgeTerminalType.none, startTerminalClass, startTerminalStatus, startTerminalSize = 14, endTerminalType = EdgeTerminalType.directional, endTerminalClass, endTerminalStatus, endTerminalSize = 14, tag, tagClass, tagStatus, children, className, selected, onSelect, onContextMenu }) => {
    const [hover, hoverRef] = useHover();
    const startPoint = element.getStartPoint();
    const endPoint = element.getEndPoint();
    // eslint-disable-next-line patternfly-react/no-layout-effect
    React.useLayoutEffect(() => {
        if (hover && !dragging) {
            onShowRemoveConnector && onShowRemoveConnector();
        }
        else {
            onHideRemoveConnector && onHideRemoveConnector();
        }
    }, [hover, dragging, onShowRemoveConnector, onHideRemoveConnector]);
    // If the edge connects to nodes in a collapsed group don't draw
    const sourceParent = getClosestVisibleParent(element.getSource());
    const targetParent = getClosestVisibleParent(element.getTarget());
    if (isNode(sourceParent) && sourceParent.isCollapsed() && sourceParent === targetParent) {
        return null;
    }
    const detailsLevel = element.getGraph().getDetailsLevel();
    const groupClassName = css(styles.topologyEdge, className, dragging && 'pf-m-dragging', hover && !dragging && 'pf-m-hover', selected && !dragging && 'pf-m-selected', StatusModifier[endTerminalStatus]);
    const edgeAnimationDuration = animationDuration !== null && animationDuration !== void 0 ? animationDuration : getEdgeAnimationDuration(element.getEdgeAnimationSpeed());
    const linkClassName = css(styles.topologyEdgeLink, getEdgeStyleClassModifier(edgeStyle || element.getEdgeStyle()));
    const bendpoints = element.getBendpoints();
    const d = `M${startPoint.x} ${startPoint.y} ${bendpoints.map((b) => `L${b.x} ${b.y} `).join('')}L${endPoint.x} ${endPoint.y}`;
    const bgStartPoint = !startTerminalType || startTerminalType === EdgeTerminalType.none
        ? [startPoint.x, startPoint.y]
        : getConnectorStartPoint((bendpoints === null || bendpoints === void 0 ? void 0 : bendpoints[0]) || endPoint, startPoint, startTerminalSize);
    const bgEndPoint = !endTerminalType || endTerminalType === EdgeTerminalType.none
        ? [endPoint.x, endPoint.y]
        : getConnectorStartPoint((bendpoints === null || bendpoints === void 0 ? void 0 : bendpoints[bendpoints.length - 1]) || startPoint, endPoint, endTerminalSize);
    const backgroundPath = `M${bgStartPoint[0]} ${bgStartPoint[1]} ${bendpoints
        .map((b) => `L${b.x} ${b.y} `)
        .join('')}L${bgEndPoint[0]} ${bgEndPoint[1]}`;
    const showTag = tag && (detailsLevel === ScaleDetailsLevel.high || hover);
    const scale = element.getGraph().getScale();
    const tagScale = hover && !(detailsLevel === ScaleDetailsLevel.high) ? Math.max(1, 1 / scale) : 1;
    const tagPositionScale = hover && !(detailsLevel === ScaleDetailsLevel.high) ? Math.min(1, scale) : 1;
    return (React.createElement(Layer, { id: dragging || hover ? TOP_LAYER : undefined },
        React.createElement("g", { ref: hoverRef, "data-test-id": "edge-handler", className: groupClassName, onClick: onSelect, onContextMenu: onContextMenu },
            React.createElement("path", { className: css(styles.topologyEdgeBackground), d: backgroundPath, onMouseEnter: onShowRemoveConnector, onMouseLeave: onHideRemoveConnector }),
            React.createElement("path", { className: linkClassName, d: d, style: { animationDuration: `${edgeAnimationDuration}s` } }),
            showTag && (React.createElement("g", { transform: `scale(${hover ? tagScale : 1})` },
                React.createElement(DefaultConnectorTag, { className: tagClass, startPoint: element.getStartPoint().scale(tagPositionScale), endPoint: element.getEndPoint().scale(tagPositionScale), tag: tag, status: tagStatus }))),
            React.createElement(DefaultConnectorTerminal, { className: startTerminalClass, isTarget: false, edge: element, size: startTerminalSize, dragRef: sourceDragRef, terminalType: startTerminalType, status: startTerminalStatus, highlight: dragging || hover }),
            React.createElement(DefaultConnectorTerminal, { className: endTerminalClass, isTarget: true, dragRef: targetDragRef, edge: element, size: endTerminalSize, terminalType: endTerminalType, status: endTerminalStatus, highlight: dragging || hover }),
            children)));
});
const DefaultEdge = (_a) => {
    var { element, startTerminalType = EdgeTerminalType.none, startTerminalSize = 14, endTerminalType = EdgeTerminalType.directional, endTerminalSize = 14 } = _a, rest = __rest(_a, ["element", "startTerminalType", "startTerminalSize", "endTerminalType", "endTerminalSize"]);
    if (!isEdge(element)) {
        throw new Error('DefaultEdge must be used only on Edge elements');
    }
    return (React.createElement(DefaultEdgeInner, Object.assign({ element: element, startTerminalType: startTerminalType, startTerminalSize: startTerminalSize, endTerminalType: endTerminalType, endTerminalSize: endTerminalSize }, rest)));
};
export default DefaultEdge;
//# sourceMappingURL=DefaultEdge.js.map