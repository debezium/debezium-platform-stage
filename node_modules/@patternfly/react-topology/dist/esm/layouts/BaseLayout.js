import { action, makeObservable } from 'mobx';
import { ADD_CHILD_EVENT, REMOVE_CHILD_EVENT, GRAPH_LAYOUT_END_EVENT, NODE_COLLAPSE_CHANGE_EVENT, ELEMENT_VISIBILITY_CHANGE_EVENT, isNode } from '../types';
import { leafNodeElements, groupNodeElements, getClosestVisibleParent } from '../utils';
import { DRAG_MOVE_OPERATION, DRAG_NODE_END_EVENT, DRAG_NODE_START_EVENT } from '../behavior';
import { BaseEdge } from '../elements';
import { ForceSimulation } from './ForceSimulation';
import { LayoutNode } from './LayoutNode';
import { LayoutGroup } from './LayoutGroup';
import { LayoutLink } from './LayoutLink';
export const LAYOUT_DEFAULTS = {
    linkDistance: 60,
    nodeDistance: 35,
    groupDistance: 35,
    collideDistance: 0,
    simulationSpeed: 10,
    chargeStrength: 0,
    allowDrag: true,
    layoutOnDrag: true
};
export class BaseLayout {
    constructor(graph, options) {
        this.scheduleRestart = false;
        this.nodes = [];
        this.edges = [];
        this.groups = [];
        this.nodesMap = {};
        this.onSimulationEnd = () => { };
        this.handleDragStart = (element, event, operation) => {
            this.initDrag(element, event, operation);
            if (!this.options.layoutOnDrag) {
                return;
            }
            if (operation.type !== DRAG_MOVE_OPERATION) {
                this.forceSimulation.stopSimulation();
                return;
            }
            const id = element.getId();
            let found = false;
            const dragNode = this.nodes.find((node) => node.id === id);
            if (dragNode) {
                dragNode.isFixed = true;
                found = true;
            }
            else {
                const dragGroup = this.groups.find((group) => group.id === id);
                if (dragGroup) {
                    const groupNodes = dragGroup.leaves;
                    groupNodes.forEach((node) => {
                        node.isFixed = true;
                    });
                    found = true;
                }
            }
            if (found) {
                this.forceSimulation.alphaTarget(0.1);
                this.forceSimulation.restart();
            }
        };
        this.handleDragEnd = (element, event, operation) => {
            this.endDrag(element, event, operation);
            if (!this.options.layoutOnDrag) {
                return;
            }
            if (operation.type !== DRAG_MOVE_OPERATION) {
                this.forceSimulation.restart();
                return;
            }
            const id = element.getId();
            const dragNode = this.nodes.find((node) => node.id === id);
            if (dragNode) {
                dragNode.isFixed = false;
            }
            else {
                const dragGroup = this.groups.find((group) => group.id === id);
                if (dragGroup) {
                    const groupNodes = dragGroup.leaves;
                    groupNodes.forEach((node) => {
                        node.isFixed = false;
                    });
                }
            }
            this.forceSimulation.alphaTarget(0);
        };
        this.layout = () => {
            this.stopListening();
            this.runLayout(true);
            this.startListening();
        };
        this.handleChildAdded = ({ child }) => {
            if (!this.nodesMap[child.getId()]) {
                this.scheduleRestart = true;
                this.scheduleLayout();
            }
        };
        this.handleChildRemoved = ({ child }) => {
            if (this.nodesMap[child.getId()]) {
                this.scheduleRestart = true;
                this.scheduleLayout();
            }
        };
        this.handleElementVisibilityChange = (event) => {
            if (event.visible === (this.nodesMap[event.target.getId()] === undefined)) {
                this.scheduleRestart = true;
                this.scheduleLayout();
            }
        };
        this.handleNodeCollapse = ({ node }) => {
            if (!node.isCollapsed()) {
                this.scheduleRestart = true;
                this.scheduleLayout();
            }
        };
        this.scheduleLayout = () => {
            if (!this.scheduleHandle) {
                this.scheduleHandle = requestAnimationFrame(() => {
                    delete this.scheduleHandle;
                    try {
                        this.runLayout(false, this.scheduleRestart);
                        this.scheduleRestart = false;
                        // eslint-disable-next-line no-empty
                    }
                    catch (e) { }
                });
            }
        };
        this.getFixedNodeDistance = (link) => Math.sqrt(Math.pow((link.sourceNode.x - link.targetNode.x), 2) + Math.pow((link.sourceNode.y - link.targetNode.y), 2));
        // Default is to clear any initial bend points
        this.initializeEdgeBendpoints = (edge) => {
            // remove any bendpoints
            if (edge.getBendpoints().length > 0) {
                edge.setBendpoints([]);
            }
        };
        this.getLeafNodes = () => leafNodeElements(this.graph.getNodes()).filter((n) => n.isVisible());
        this.getGroupNodes = () => groupNodeElements(this.graph.getNodes()).filter((g) => g.isVisible());
        this.hasVisibleChildren = (group) => !!group.getNodes().find((c) => isNode(c) && c.isVisible());
        makeObservable(this, { runLayout: action });
        this.graph = graph;
        this.options = Object.assign(Object.assign(Object.assign({}, LAYOUT_DEFAULTS), { onSimulationEnd: this.onSimulationEnd, listenForChanges: true }), options);
        if (this.options.allowDrag) {
            graph
                .getController()
                .addEventListener(DRAG_NODE_START_EVENT, this.handleDragStart)
                .addEventListener(DRAG_NODE_END_EVENT, this.handleDragEnd);
        }
        this.forceSimulation = new ForceSimulation(this.options);
        this.startListening();
    }
    getLayoutOptions() {
        return this.options;
    }
    destroy() {
        if (this.options.allowDrag) {
            this.graph
                .getController()
                .removeEventListener(DRAG_NODE_START_EVENT, this.handleDragStart)
                .removeEventListener(DRAG_NODE_END_EVENT, this.handleDragEnd);
        }
        this.stopListening();
        this.forceSimulation.destroy();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    initDrag(element, event, operation) { }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    endDrag(element, event, operation) { }
    startListening() {
        const controller = this.graph.getController();
        if (controller && this.options.listenForChanges) {
            controller.addEventListener(ADD_CHILD_EVENT, this.handleChildAdded);
            controller.addEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);
            controller.addEventListener(ELEMENT_VISIBILITY_CHANGE_EVENT, this.handleElementVisibilityChange);
            controller.addEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);
        }
    }
    stop() {
        this.stopSimulation();
    }
    stopListening() {
        const controller = this.graph.getController();
        if (this.scheduleHandle) {
            cancelAnimationFrame(this.scheduleHandle);
        }
        if (controller) {
            controller.removeEventListener(ADD_CHILD_EVENT, this.handleChildAdded);
            controller.removeEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);
            controller.removeEventListener(ELEMENT_VISIBILITY_CHANGE_EVENT, this.handleElementVisibilityChange);
            controller.removeEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);
        }
    }
    getLayoutNode(nodes, node) {
        if (!node) {
            return undefined;
        }
        let layoutNode = nodes.find((n) => n.id === node.getId());
        if (!layoutNode && node.getNodes().length) {
            const id = node.getChildren()[0].getId();
            layoutNode = nodes.find((n) => n.id === id);
        }
        if (!layoutNode) {
            layoutNode = this.getLayoutNode(nodes, getClosestVisibleParent(node));
        }
        return layoutNode;
    }
    // Faux Edges are used to layout nodes in a group together, as if they had links between them
    getFauxEdges(groups, nodes) {
        const fauxEdges = [];
        groups.forEach((group) => {
            const groupNodes = group.element.getNodes();
            for (let i = 0; i < groupNodes.length; i++) {
                for (let j = i + 1; j < groupNodes.length; j++) {
                    const fauxEdge = new BaseEdge();
                    const source = this.getLayoutNode(nodes, groupNodes[i]);
                    const target = this.getLayoutNode(nodes, groupNodes[j]);
                    if (source && target) {
                        const link = this.createLayoutLink(fauxEdge, source, target, true);
                        fauxEdge.setController(target.element.getController());
                        fauxEdges.push(link);
                    }
                }
            }
        });
        return fauxEdges;
    }
    createLayoutNode(node, nodeDistance, index) {
        return new LayoutNode(node, nodeDistance, index);
    }
    createLayoutLink(edge, source, target, isFalse = false) {
        return new LayoutLink(edge, source, target, isFalse);
    }
    createLayoutGroup(node, padding, index) {
        return new LayoutGroup(node, padding, index);
    }
    getNodes(leafNodes, nodeDistance) {
        return leafNodes.map((n, index) => this.createLayoutNode(n, nodeDistance, index));
    }
    getLinks(edges) {
        const links = [];
        edges.forEach((e) => {
            const source = this.getLayoutNode(this.nodes, e.getSource());
            const target = this.getLayoutNode(this.nodes, e.getTarget());
            if (source && target) {
                this.initializeEdgeBendpoints(e);
                links.push(this.createLayoutLink(e, source, target));
            }
        });
        return links;
    }
    // Turn empty groups into nodes
    getNodesFromGroups(groups, nodeDistance, nodeCount) {
        let count = 0;
        const groupNodes = [];
        groups.forEach((group) => {
            if (!this.hasVisibleChildren(group)) {
                groupNodes.push(this.createLayoutNode(group, nodeDistance, nodeCount + count++));
            }
        });
        return groupNodes;
    }
    getGroups(groups, nodes, padding) {
        let nodeIndex = 2 * nodes.length;
        // Create groups only for those with children
        const layoutGroups = groups
            .filter((g) => this.hasVisibleChildren(g))
            .map((group) => this.createLayoutGroup(group, padding, nodeIndex++));
        layoutGroups.forEach((groupNode) => {
            const leaves = [];
            const leafElements = groupNode.element
                .getNodes()
                .filter((node) => !node.isGroup() || !this.hasVisibleChildren(node));
            leafElements.forEach((leaf) => {
                const layoutLeaf = nodes.find((n) => n.id === leaf.getId());
                if (layoutLeaf) {
                    leaves.push(layoutLeaf);
                    layoutLeaf.parent = groupNode;
                }
            });
            groupNode.leaves = leaves;
            const childGroups = [];
            const groupElements = groupNode.element
                .getNodes()
                .filter((node) => node.isGroup() && node.isVisible() && !node.isCollapsed());
            groupElements.forEach((group) => {
                const layoutGroup = layoutGroups.find((g) => g.id === group.getId());
                if (layoutGroup) {
                    childGroups.push(layoutGroup);
                    layoutGroup.parent = groupNode;
                }
            });
            groupNode.groups = childGroups;
        });
        return layoutGroups;
    }
    initializeNodePositions(nodes, graph, force) {
        const { width, height } = graph.getBounds();
        const cx = width / 2;
        const cy = height / 2;
        nodes.forEach((node) => {
            // only init position for nodes that have not been positioned
            if (force || !node.element.isPositioned()) {
                node.setPosition(cx, cy);
            }
            else {
                node.setFixed(true);
            }
        });
    }
    setupLayout(graph, // eslint-disable-line @typescript-eslint/no-unused-vars
    nodes, // eslint-disable-line @typescript-eslint/no-unused-vars
    edges, // eslint-disable-line @typescript-eslint/no-unused-vars
    groups // eslint-disable-line @typescript-eslint/no-unused-vars
    ) { }
    stopSimulation() {
        this.forceSimulation.haltForceSimulation();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    startLayout(graph, initialRun, addingNodes, onEnd) { }
    // Interim, remove and update startLayout to public in next breaking change build
    doStartLayout(graph, initialRun, addingNodes, onEnd) {
        return this.startLayout(graph, initialRun, addingNodes, onEnd);
    }
    updateLayout() {
        this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
        this.forceSimulation.alpha(0.2);
    }
    runLayout(initialRun, restart = true) {
        const prevGroups = this.groups;
        // create datum
        const leafNodes = this.getLeafNodes();
        const groups = this.getGroupNodes();
        this.nodes = this.getNodes(leafNodes, this.options.nodeDistance);
        const groupNodes = this.getNodesFromGroups(groups, this.options.nodeDistance, this.nodes.length);
        if (groupNodes) {
            this.nodes.push(...groupNodes);
        }
        this.groups = this.getGroups(groups, this.nodes, this.options.groupDistance);
        const newNodes = initialRun
            ? this.nodes
            : this.nodes.filter((node) => !this.nodesMap[node.element.getId()]);
        let addingNodes = restart && newNodes.length > 0;
        if (!initialRun && restart && !addingNodes) {
            this.groups.forEach((group) => {
                const prevGroup = prevGroups.find((g) => g.element.getId() === group.element.getId());
                if (!prevGroup) {
                    addingNodes = true;
                    newNodes.push(...group.leaves);
                }
                else {
                    group.leaves.forEach((node) => {
                        if (!prevGroup.leaves.find((l) => l.element.getId() === node.element.getId())) {
                            newNodes.push(node);
                        }
                    });
                }
            });
            addingNodes = newNodes.length > 0;
        }
        this.edges = this.getLinks(this.graph.getEdges());
        // initialize new node positions
        this.initializeNodePositions(this.nodes, this.graph, initialRun);
        // re-create the nodes map
        this.nodesMap = this.nodes.reduce((acc, n) => {
            acc[n.id] = n;
            return acc;
        }, {});
        // Add faux edges to keep grouped items together
        this.edges.push(...this.getFauxEdges(this.groups, this.nodes));
        this.setupLayout(this.graph, this.nodes, this.edges, this.groups);
        if (initialRun || addingNodes) {
            // Reset the force simulation
            this.stopSimulation();
            this.startLayout(this.graph, initialRun, addingNodes, () => {
                this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
            });
        }
        else if (restart && this.options.layoutOnDrag) {
            this.updateLayout();
        }
    }
}
//# sourceMappingURL=BaseLayout.js.map