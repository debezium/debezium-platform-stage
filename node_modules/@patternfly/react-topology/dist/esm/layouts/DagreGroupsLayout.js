import * as dagre from '@dagrejs/dagre';
import { GRAPH_LAYOUT_END_EVENT } from '../types';
import { BaseLayout, LAYOUT_DEFAULTS } from './BaseLayout';
import { DagreNode } from './DagreNode';
import { DagreLink } from './DagreLink';
import { LEFT_TO_RIGHT } from './DagreLayout';
import { Point } from '../geom';
import { getClosestVisibleParent, getGroupChildrenDimensions } from '../utils';
export class DagreGroupsLayout extends BaseLayout {
    constructor(graph, options) {
        super(graph, options);
        this.dagreOptions = Object.assign(Object.assign(Object.assign({}, this.options), { layoutOnDrag: false, marginx: 0, marginy: 0, nodesep: this.options.nodeDistance, edgesep: this.options.linkDistance, rankdir: LEFT_TO_RIGHT, ranker: 'tight-tree' }), options);
    }
    createLayoutNode(node, nodeDistance, index) {
        return new DagreNode(node, nodeDistance, index);
    }
    createLayoutLink(edge, source, target, isFalse = false) {
        return new DagreLink(edge, source, target, isFalse);
    }
    updateEdgeBendpoints(edges) {
        edges.forEach((edge) => {
            const link = edge;
            link.updateBendpoints();
        });
    }
    getFauxEdges() {
        return [];
    }
    getAllLeaves(group) {
        var _a;
        const leaves = [...group.leaves];
        (_a = group.groups) === null || _a === void 0 ? void 0 : _a.forEach((subGroup) => leaves.push(...this.getAllLeaves(subGroup)));
        return leaves;
    }
    getAllSubGroups(group) {
        var _a;
        const groups = [...group.groups];
        (_a = group.groups) === null || _a === void 0 ? void 0 : _a.forEach((subGroup) => groups.push(...this.getAllSubGroups(subGroup)));
        return groups;
    }
    isNodeInGroups(node, groups) {
        return !!groups.find((group) => group.leaves.includes(node) || this.isNodeInGroups(node, group.groups));
    }
    getEdgeLayoutNode(nodes, groups, node) {
        if (!node) {
            return undefined;
        }
        let layoutNode = nodes.find((n) => n.id === node.getId());
        if (!layoutNode) {
            const groupNode = groups.find((n) => n.id === node.getId());
            if (groupNode) {
                const dagreNode = new DagreNode(groupNode.element, groupNode.padding);
                if (dagreNode) {
                    return dagreNode;
                }
            }
        }
        if (!layoutNode && node.getNodes().length) {
            const id = node.getChildren()[0].getId();
            layoutNode = nodes.find((n) => n.id === id);
        }
        if (!layoutNode) {
            layoutNode = this.getEdgeLayoutNode(nodes, groups, getClosestVisibleParent(node));
        }
        return layoutNode;
    }
    getLinks(edges) {
        const links = [];
        edges.forEach((e) => {
            const source = this.getEdgeLayoutNode(this.nodes, this.groups, e.getSource());
            const target = this.getEdgeLayoutNode(this.nodes, this.groups, e.getTarget());
            if (source && target) {
                this.initializeEdgeBendpoints(e);
                links.push(this.createLayoutLink(e, source, target));
            }
        });
        return links;
    }
    startLayout(graph, initialRun, addingNodes) {
        if (initialRun || addingNodes) {
            const doLayout = (parentGroup) => {
                const dagreGraph = new dagre.graphlib.Graph({ compound: true });
                const options = Object.assign({}, this.dagreOptions);
                Object.keys(LAYOUT_DEFAULTS).forEach((key) => delete options[key]);
                dagreGraph.setGraph(options);
                // Determine the groups, nodes, and edges that belong in this layout
                const layerGroups = this.groups.filter((group) => { var _a, _b; return ((_a = group.parent) === null || _a === void 0 ? void 0 : _a.id) === (parentGroup === null || parentGroup === void 0 ? void 0 : parentGroup.id) || (!parentGroup && ((_b = group.parent) === null || _b === void 0 ? void 0 : _b.id) === graph.getId()); });
                const layerNodes = this.nodes.filter((n) => {
                    var _a, _b;
                    return ((_a = n.element.getParent()) === null || _a === void 0 ? void 0 : _a.getId()) === (parentGroup === null || parentGroup === void 0 ? void 0 : parentGroup.id) ||
                        (!parentGroup && ((_b = n.element.getParent()) === null || _b === void 0 ? void 0 : _b.getId()) === graph.getId());
                });
                const layerEdges = this.edges.filter((edge) => (layerGroups.find((n) => n.id === edge.sourceNode.id) ||
                    layerNodes.find((n) => n.id === edge.sourceNode.id)) &&
                    (layerGroups.find((n) => n.id === edge.targetNode.id) ||
                        layerNodes.find((n) => n.id === edge.targetNode.id)));
                // Layout any child groups first
                layerGroups.forEach((group) => {
                    doLayout(group);
                    // Add the child group node (now with the correct dimensions) to the graph
                    const dagreNode = new DagreNode(group.element, group.padding);
                    const updateNode = dagreNode.getUpdatableNode();
                    dagreGraph.setNode(group.id, updateNode);
                });
                layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.forEach((node) => {
                    const updateNode = node.getUpdatableNode();
                    dagreGraph.setNode(node.id, updateNode);
                });
                layerEdges === null || layerEdges === void 0 ? void 0 : layerEdges.forEach((dagreEdge) => {
                    dagreGraph.setEdge(dagreEdge.source.id, dagreEdge.target.id, dagreEdge);
                });
                dagre.layout(dagreGraph);
                // Update the node element positions
                layerNodes.forEach((node) => {
                    node.updateToNode(dagreGraph.node(node.id));
                });
                // Update the group element positions (setting the group's positions updates its children)
                layerGroups.forEach((node) => {
                    const dagreNode = dagreGraph.node(node.id);
                    node.element.setPosition(new Point(dagreNode.x, dagreNode.y));
                });
                this.updateEdgeBendpoints(this.edges);
                // now that we've laid out the children, set the dimensions on the group (not on the graph)
                if (parentGroup) {
                    parentGroup.element.setDimensions(getGroupChildrenDimensions(parentGroup.element));
                }
            };
            doLayout();
        }
        if (this.dagreOptions.layoutOnDrag) {
            this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
        }
        else {
            this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
        }
    }
}
//# sourceMappingURL=DagreGroupsLayout.js.map