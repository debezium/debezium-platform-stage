import { __rest } from "tslib";
import * as React from 'react';
import { observer } from 'mobx-react';
import { css } from '@patternfly/react-styles';
import styles from '../../../css/topology-components';
import { EdgeTerminalType, isEdge } from '../../../types';
import { integralShapePath } from '../../utils';
import { TOP_TO_BOTTOM } from '../../../layouts';
import { DefaultConnectorTerminal } from '../../../components';
import Layer from '../../../components/layers/Layer';
import { TOP_LAYER } from '../../../const';
const TaskEdgeInner = observer(({ element, startTerminalType = EdgeTerminalType.none, startTerminalClass, startTerminalStatus, startTerminalSize = 14, endTerminalType = EdgeTerminalType.none, endTerminalClass, endTerminalStatus, endTerminalSize = 14, className, nodeSeparation, selected, onSelect }) => {
    var _a, _b, _c, _d;
    const startPoint = element.getStartPoint();
    const endPoint = element.getEndPoint();
    const groupClassName = css(styles.topologyEdge, className, selected && 'pf-m-selected', onSelect && 'pf-m-selectable');
    const startIndent = ((_a = element.getData()) === null || _a === void 0 ? void 0 : _a.indent) || 0;
    const verticalLayout = ((_d = (_c = (_b = element.getGraph()).getLayoutOptions) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.rankdir) === TOP_TO_BOTTOM;
    const edgePath = integralShapePath(startPoint, endPoint, startIndent, nodeSeparation, verticalLayout);
    const edgeBackground = (React.createElement("path", { onClick: onSelect, className: css(styles.topologyEdgeBackground, onSelect && 'pf-m-selectable'), d: edgePath }));
    return (React.createElement("g", { "data-test-id": "task-handler", className: groupClassName },
        selected ? edgeBackground : React.createElement(Layer, { id: TOP_LAYER }, edgeBackground),
        React.createElement("path", { d: edgePath, transform: "translate(0.5,0.5)", shapeRendering: "geometricPrecision", fillOpacity: 0 }),
        React.createElement(DefaultConnectorTerminal, { className: startTerminalClass, isTarget: false, edge: element, size: startTerminalSize, terminalType: startTerminalType, status: startTerminalStatus }),
        React.createElement(DefaultConnectorTerminal, { className: endTerminalClass, isTarget: true, edge: element, size: endTerminalSize, terminalType: endTerminalType, status: endTerminalStatus, startPoint: verticalLayout ? endPoint.clone().translate(0, -1) : endPoint.clone().translate(-1, 0) })));
});
const TaskEdge = (_a) => {
    var { element } = _a, rest = __rest(_a, ["element"]);
    if (!isEdge(element)) {
        throw new Error('TaskEdge must be used only on Edge elements');
    }
    return React.createElement(TaskEdgeInner, Object.assign({ element: element }, rest));
};
export default TaskEdge;
//# sourceMappingURL=TaskEdge.js.map