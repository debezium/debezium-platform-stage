import { __rest } from "tslib";
import * as React from 'react';
import { action } from 'mobx';
import { css } from '@patternfly/react-styles';
import styles from '../../../css/topology-pipelines';
import { Tooltip } from '@patternfly/react-core';
import { observer } from '../../../mobx-exports';
import { AnchorEnd, isNode, ScaleDetailsLevel } from '../../../types';
import { RunStatus } from '../../types';
import { useAnchor } from '../../../behavior';
import { getNodeScaleTranslation, useHover, useSize } from '../../../utils';
import { TaskNodeSourceAnchor, TaskNodeTargetAnchor } from '../anchors';
import { useScaleNode } from '../../../hooks';
import { TOP_TO_BOTTOM } from '../../../layouts';
import TaskPill from './TaskPill';
const STATUS_ICON_SIZE = 16;
const SCALE_UP_TIME = 200;
const TaskNodeInner = observer((_a) => {
    var _b, _c, _d;
    var { element, className, statusIconSize = STATUS_ICON_SIZE, scaleNode, toolTip, toolTipProps, disableTooltip = false, whenSize = 0, whenOffset = 0 } = _a, rest = __rest(_a, ["element", "className", "statusIconSize", "scaleNode", "toolTip", "toolTipProps", "disableTooltip", "whenSize", "whenOffset"]);
    const [hovered, hoverRef] = useHover();
    // const isHover = hover !== undefined ? hover : hovered;
    const taskRef = React.useRef();
    const [pillSize, pillRef] = useSize();
    const pillWidth = (pillSize === null || pillSize === void 0 ? void 0 : pillSize.width) || 0;
    const { width } = element.getBounds();
    const detailsLevel = element.getGraph().getDetailsLevel();
    const verticalLayout = ((_d = (_c = (_b = element.getGraph()).getLayoutOptions) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.rankdir) === TOP_TO_BOTTOM;
    useAnchor(React.useCallback((node) => new TaskNodeSourceAnchor(node, detailsLevel, statusIconSize + 4, verticalLayout), 
    // Include scaleNode to cause an update when it changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [detailsLevel, statusIconSize, scaleNode, verticalLayout]), AnchorEnd.source);
    useAnchor(React.useCallback((node) => new TaskNodeTargetAnchor(node, whenSize + whenOffset, detailsLevel, statusIconSize + 4, verticalLayout), 
    // Include scaleNode to cause an update when it changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [whenSize, whenOffset, detailsLevel, statusIconSize, scaleNode, verticalLayout]), AnchorEnd.target);
    React.useEffect(() => {
        const sourceEdges = element.getSourceEdges();
        action(() => {
            const indent = detailsLevel === ScaleDetailsLevel.high && !verticalLayout ? width - pillWidth : 0;
            sourceEdges.forEach((edge) => {
                var _a;
                const data = edge.getData();
                if (((_a = data === null || data === void 0 ? void 0 : data.indent) !== null && _a !== void 0 ? _a : 0) !== indent) {
                    edge.setData(Object.assign(Object.assign({}, (data || {})), { indent }));
                }
            });
        })();
        return action(() => {
            sourceEdges.forEach((edge) => {
                const data = edge.getData();
                if (data === null || data === void 0 ? void 0 : data.indent) {
                    edge.setData(Object.assign(Object.assign({}, (data || {})), { indent: 0 }));
                }
            });
        });
    }, [detailsLevel, element, pillWidth, verticalLayout, width]);
    const scale = element.getGraph().getScale();
    const nodeScale = useScaleNode(scaleNode, scale, SCALE_UP_TIME);
    const { translateX, translateY } = getNodeScaleTranslation(element, nodeScale, scaleNode);
    const taskPill = (React.createElement(TaskPill, Object.assign({ x: verticalLayout ? 0 : whenOffset, y: 0, className: css('pf-topology__pipelines__task-node', className), scaleNode: scaleNode, hover: hovered, statusIconSize: statusIconSize, pillRef: pillRef, width: width, taskRef: taskRef, element: element }, rest)));
    return (React.createElement("g", { className: css('pf-topology__pipelines__task-node', className), transform: `${scaleNode ? `translate(${translateX}, ${translateY})` : ''} scale(${nodeScale})`, ref: hoverRef }, !toolTip || disableTooltip ? (taskPill) : (React.createElement(Tooltip, Object.assign({ triggerRef: taskRef, position: "bottom", enableFlip: false }, (toolTipProps !== null && toolTipProps !== void 0 ? toolTipProps : {}), { content: toolTip }), taskPill))));
});
const TaskNode = (_a) => {
    var { element, paddingX = 8, paddingY = 8, statusIconSize = STATUS_ICON_SIZE, showStatusState = true, hiddenDetailsShownStatuses = [RunStatus.Failed, RunStatus.FailedToStart, RunStatus.Cancelled], badgeClassName = styles.topologyPipelinesPillBadge, taskIconPadding = 4, truncateLength = 14, disableTooltip = false, whenSize = 0, whenOffset = 0 } = _a, rest = __rest(_a, ["element", "paddingX", "paddingY", "statusIconSize", "showStatusState", "hiddenDetailsShownStatuses", "badgeClassName", "taskIconPadding", "truncateLength", "disableTooltip", "whenSize", "whenOffset"]);
    if (!isNode(element)) {
        throw new Error('TaskNode must be used only on Node elements');
    }
    return (React.createElement(TaskNodeInner, Object.assign({ element: element, paddingX: paddingX, paddingY: paddingY, statusIconSize: statusIconSize, showStatusState: showStatusState, hiddenDetailsShownStatuses: hiddenDetailsShownStatuses, badgeClassName: badgeClassName, taskIconPadding: taskIconPadding, truncateLength: truncateLength, disableTooltip: disableTooltip, whenSize: whenSize, whenOffset: whenOffset }, rest)));
};
export default TaskNode;
//# sourceMappingURL=TaskNode.js.map