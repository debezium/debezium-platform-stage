import { __rest } from "tslib";
import * as React from 'react';
import { observer } from 'mobx-react';
import { Dimensions } from '../../../geom';
import { isNode } from '../../../types';
import { action } from '../../../mobx-exports';
import { getEdgesFromNodes, getSpacerNodes } from '../../utils';
import DefaultTaskGroupCollapsed from './DefaultTaskGroupCollapsed';
import DefaultTaskGroupExpanded from './DefaultTaskGroupExpanded';
import { DEFAULT_SPACER_NODE_TYPE } from '../../const';
const DefaultTaskGroupInner = observer((_a) => {
    var { element, badge, onCollapseChange, collapsedShadowCount, recreateLayoutOnCollapseChange, getEdgeCreationTypes } = _a, rest = __rest(_a, ["element", "badge", "onCollapseChange", "collapsedShadowCount", "recreateLayoutOnCollapseChange", "getEdgeCreationTypes"]);
    const childCount = element.getAllNodeChildren().length;
    const handleCollapse = action((group, collapsed) => {
        if (collapsed && rest.collapsedWidth !== undefined && rest.collapsedHeight !== undefined) {
            group.setDimensions(new Dimensions(rest.collapsedWidth, rest.collapsedHeight));
        }
        group.setCollapsed(collapsed);
        if (recreateLayoutOnCollapseChange) {
            const controller = group.hasController() && group.getController();
            if (controller) {
                const model = controller.toModel();
                const creationTypes = getEdgeCreationTypes ? getEdgeCreationTypes() : {};
                const pipelineNodes = model.nodes
                    .filter((n) => n.type !== (creationTypes.spacerNodeType || DEFAULT_SPACER_NODE_TYPE))
                    .map((n) => (Object.assign(Object.assign({}, n), { visible: true })));
                const spacerNodes = getSpacerNodes(pipelineNodes, creationTypes.spacerNodeType, creationTypes.finallyNodeTypes);
                const nodes = [...pipelineNodes, ...spacerNodes];
                const edges = getEdgesFromNodes(pipelineNodes, creationTypes.spacerNodeType, creationTypes.edgeType, creationTypes.edgeType, creationTypes.finallyNodeTypes, creationTypes.finallyEdgeType);
                controller.fromModel({ nodes, edges }, true);
                controller.getGraph().layout();
            }
        }
        const graph = group.getGraph();
        if (graph) {
            if (!collapsed) {
                graph.fit(80, group);
            }
            else {
                // Get the current graph required size
                let rect;
                graph.getNodes().forEach((c) => {
                    const b = c.getBounds();
                    if (!rect) {
                        rect = b.clone();
                    }
                    else {
                        rect.union(b);
                    }
                });
                // If the required size is smaller, zoom in to fit the current graph
                const graphBounds = graph.getBounds();
                if (rect.width < graphBounds.width || rect.height < graphBounds.height) {
                    graph.fit(80);
                }
                // Center the graph on the group that was collapsed
                graph.centerInView(group);
            }
        }
        onCollapseChange && onCollapseChange(group, collapsed);
    });
    if (element.isCollapsed()) {
        return (React.createElement(DefaultTaskGroupCollapsed, Object.assign({ element: element, shadowCount: collapsedShadowCount, onCollapseChange: handleCollapse, badge: badge || `${childCount}` }, rest)));
    }
    return React.createElement(DefaultTaskGroupExpanded, Object.assign({ element: element, badge: badge, onCollapseChange: handleCollapse }, rest));
});
const DefaultTaskGroup = (_a) => {
    var { element, badgeColor = '#f5f5f5', badgeBorderColor = '#d2d2d2', badgeTextColor = '#000000' } = _a, rest = __rest(_a, ["element", "badgeColor", "badgeBorderColor", "badgeTextColor"]);
    if (!isNode(element)) {
        throw new Error('DefaultTaskGroup must be used only on Node elements');
    }
    return (React.createElement(DefaultTaskGroupInner, Object.assign({ element: element, badgeColor: badgeColor, badgeBorderColor: badgeBorderColor, badgeTextColor: badgeTextColor }, rest)));
};
export default DefaultTaskGroup;
//# sourceMappingURL=DefaultTaskGroup.js.map