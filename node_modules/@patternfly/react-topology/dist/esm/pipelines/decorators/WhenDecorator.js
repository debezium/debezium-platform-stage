import * as React from 'react';
import { Tooltip } from '@patternfly/react-core';
import { css } from '@patternfly/react-styles';
import styles from '../../css/topology-pipelines';
import topologyStyles from '../../css/topology-components';
import { observer } from '../../mobx-exports';
import { getWhenStatusModifier } from '../utils';
import { TOP_TO_BOTTOM } from '../../layouts';
export const DEFAULT_WHEN_SIZE = 12;
export const DEFAULT_WHEN_OFFSET = 12;
export const WhenDecorator = observer(({ element, width = DEFAULT_WHEN_SIZE, height = DEFAULT_WHEN_SIZE, className, status, leftOffset = DEFAULT_WHEN_OFFSET, topOffset = DEFAULT_WHEN_OFFSET, edgeLength = DEFAULT_WHEN_OFFSET, toolTip, disableTooltip = false }) => {
    var _a, _b, _c;
    const nodeElement = element;
    const diamondNodeRef = React.useRef();
    const { height: taskHeight, width: taskWidth } = nodeElement.getBounds();
    const verticalLayout = ((_c = (_b = (_a = element.getGraph()).getLayoutOptions) === null || _b === void 0 ? void 0 : _b.call(_a)) === null || _c === void 0 ? void 0 : _c.rankdir) === TOP_TO_BOTTOM;
    const points = React.useMemo(() => {
        if (verticalLayout) {
            const y = -topOffset;
            const startX = taskWidth / 2;
            return `
        ${startX} ${y}
        ${startX - width / 2} ${y - height / 2}
        ${startX} ${y - height}
        ${startX + width / 2} ${y - height / 2}
      `;
        }
        const y = taskHeight / 2 - height / 2;
        const startX = -width - leftOffset;
        return `
      ${startX + width / 2} ${y}
      ${startX + width} ${y + height / 2}
      ${startX + width / 2} ${y + height}
      ${startX} ${y + height / 2}
    `;
    }, [height, leftOffset, taskHeight, taskWidth, topOffset, verticalLayout, width]);
    const linePoints = verticalLayout
        ? {
            x1: taskWidth / 2,
            y1: -topOffset,
            x2: taskWidth / 2,
            y2: -topOffset + edgeLength
        }
        : {
            x1: -leftOffset,
            y1: taskHeight / 2,
            x2: -leftOffset + edgeLength,
            y2: taskHeight / 2
        };
    const diamondNode = (React.createElement("g", { className: className, ref: diamondNodeRef },
        React.createElement("line", Object.assign({ className: css(topologyStyles.topologyEdgeBackground) }, linePoints)),
        React.createElement("line", Object.assign({ className: css(topologyStyles.topologyEdge, styles.topologyPipelinesWhenExpressionEdge) }, linePoints)),
        React.createElement("polygon", { "data-test": "diamond-decorator", className: css(styles.topologyPipelinesWhenExpressionBackground, getWhenStatusModifier(status)), points: points })));
    return toolTip && !disableTooltip ? (React.createElement(Tooltip, { triggerRef: diamondNodeRef, position: "bottom", enableFlip: false, content: React.createElement("div", { "data-test": "when-expression-tooltip" }, toolTip) }, diamondNode)) : (diamondNode);
});
WhenDecorator.displayName = 'WhenDecorator';
export default WhenDecorator;
//# sourceMappingURL=WhenDecorator.js.map