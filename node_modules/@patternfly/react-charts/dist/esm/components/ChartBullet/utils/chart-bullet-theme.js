import { getPrimaryDotMeasureData, getComparativeErrorMeasureData, getComparativeWarningMeasureData, getPrimarySegmentedMeasureData, getQualitativeRangeData } from './chart-bullet-data';
import { getBulletTheme } from '../../ChartUtils/chart-theme-types';
import { ChartThemeColor } from '../../ChartTheme/ChartThemeColor';
import { SkeletonColorTheme } from '../../ChartTheme/themes/colors/skeleton-theme';
/**
 * Returns legend color scale
 * @private
 */
const getLegendColorScale = (computedData, legendData) => {
    const colorScale = [];
    legendData.forEach((data, index) => {
        for (const i of computedData) {
            if (index === i._index) {
                colorScale.push(i._color);
            }
        }
    });
    return colorScale;
};
/**
 * Returns color scale
 * @private
 */
export const getColorScale = ({ comparativeErrorMeasureData, comparativeErrorMeasureLegendData, comparativeWarningMeasureData, comparativeWarningMeasureLegendData, invert, primaryDotMeasureData, primaryDotMeasureLegendData, primarySegmentedMeasureData, primarySegmentedMeasureLegendData, qualitativeRangeData, qualitativeRangeLegendData, themeColor }) => {
    const colorScale = [];
    if (primaryDotMeasureLegendData && primaryDotMeasureLegendData.length) {
        const computedData = getPrimaryDotMeasureData({
            data: primaryDotMeasureData,
            invert
        });
        colorScale.push(...getLegendColorScale(computedData, primaryDotMeasureLegendData));
    }
    if (primarySegmentedMeasureLegendData && primarySegmentedMeasureLegendData.length) {
        const computedData = getPrimarySegmentedMeasureData({
            data: primarySegmentedMeasureData,
            invert,
            themeColor
        });
        colorScale.push(...getLegendColorScale(computedData, primarySegmentedMeasureLegendData));
    }
    if (comparativeWarningMeasureLegendData && comparativeWarningMeasureLegendData.length) {
        const computedData = getComparativeWarningMeasureData({
            data: comparativeWarningMeasureData,
            invert,
            themeColor
        });
        colorScale.push(...getLegendColorScale(computedData, comparativeWarningMeasureLegendData));
    }
    if (comparativeErrorMeasureLegendData && comparativeErrorMeasureLegendData.length) {
        const computedData = getComparativeErrorMeasureData({
            data: comparativeErrorMeasureData,
            invert,
            themeColor
        });
        colorScale.push(...getLegendColorScale(computedData, comparativeErrorMeasureLegendData));
    }
    if (qualitativeRangeLegendData && qualitativeRangeLegendData.length) {
        const computedData = getQualitativeRangeData({
            data: qualitativeRangeData,
            invert
        });
        colorScale.push(...getLegendColorScale(computedData, qualitativeRangeLegendData));
    }
    return colorScale;
};
/**
 * Returns bullet chart theme with legend color scale
 * @private
 */
export const getBulletThemeWithLegendColorScale = ({ comparativeErrorMeasureData, comparativeErrorMeasureLegendData, comparativeWarningMeasureData, comparativeWarningMeasureLegendData, invert, primaryDotMeasureData, primaryDotMeasureLegendData, primarySegmentedMeasureData, primarySegmentedMeasureLegendData, qualitativeRangeData, qualitativeRangeLegendData, themeColor }) => {
    const colorScale = getColorScale({
        comparativeErrorMeasureData,
        comparativeErrorMeasureLegendData,
        comparativeWarningMeasureData,
        comparativeWarningMeasureLegendData,
        invert,
        primaryDotMeasureData,
        primaryDotMeasureLegendData,
        primarySegmentedMeasureData,
        primarySegmentedMeasureLegendData,
        qualitativeRangeData,
        qualitativeRangeLegendData,
        themeColor
    });
    const theme = getBulletTheme(themeColor);
    theme.legend.colorScale = [...colorScale];
    if (themeColor === ChartThemeColor.skeleton) {
        theme.legend.colorScale = SkeletonColorTheme.legend.colorScale;
    }
    return theme;
};
//# sourceMappingURL=chart-bullet-theme.js.map