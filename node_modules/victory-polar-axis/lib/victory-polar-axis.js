"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VictoryPolarAxis = void 0;
var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));
var _react = _interopRequireDefault(require("react"));
var _victoryCore = require("victory-core");
var _helperMethods = require("./helper-methods");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const fallbackProps = {
  width: 450,
  height: 300,
  padding: 50
};

// eslint-disable-next-line @typescript-eslint/no-empty-interface

class VictoryPolarAxisBase extends _react.default.Component {
  static animationWhitelist = ["style", "domain", "range", "tickCount", "tickValues", "padding", "width", "height"];
  static displayName = "VictoryAxis";
  static role = "axis";
  static defaultTransitions = {
    onExit: {
      duration: 500
    },
    onEnter: {
      duration: 500
    }
  };
  static defaultProps = {
    axisComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.LineSegment, null),
    axisLabelComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryLabel, null),
    circularAxisComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.Arc, null),
    circularGridComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.Arc, null),
    containerComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryContainer, null),
    endAngle: 360,
    gridComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.LineSegment, null),
    groupComponent: /*#__PURE__*/_react.default.createElement("g", {
      role: "presentation"
    }),
    labelPlacement: "parallel",
    startAngle: 0,
    standalone: true,
    theme: _victoryCore.VictoryTheme.grayscale,
    tickComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.LineSegment, null),
    tickLabelComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryLabel, null)
  };
  static getDomain = _victoryCore.Axis.getDomain;
  static getAxis = _victoryCore.Axis.getAxis;
  static getScale(props) {
    return (0, _helperMethods.getScale)(props);
  }
  static getStyles(props) {
    return (0, _helperMethods.getStyles)(props, fallbackProps.style);
  }
  static getBaseProps(props) {
    return (0, _helperMethods.getBaseProps)(props, fallbackProps);
  }
  static expectedComponents = ["axisComponent", "circularAxisComponent", "groupComponent", "containerComponent", "tickComponent", "tickLabelComponent", "gridComponent", "circularGridComponent"];
  renderAxisLine(props) {
    const {
      dependentAxis
    } = props;
    const axisComponent = dependentAxis ? props.axisComponent : props.circularAxisComponent;
    const axisProps = this.getComponentProps(axisComponent, "axis", 0);
    return /*#__PURE__*/_react.default.cloneElement(axisComponent, axisProps);
  }
  renderLabel(props) {
    const {
      axisLabelComponent,
      dependentAxis,
      label
    } = props;
    if (!label || !dependentAxis) {
      return null;
    }
    const axisLabelProps = this.getComponentProps(axisLabelComponent, "axisLabel", 0);
    return /*#__PURE__*/_react.default.cloneElement(axisLabelComponent, axisLabelProps);
  }
  renderAxis(props) {
    const {
      tickComponent,
      tickLabelComponent,
      name
    } = props;
    const shouldRender = componentProps => {
      const {
        style = {},
        events = {}
      } = componentProps;
      const visible = style.stroke !== "transparent" && style.stroke !== "none" && style.strokeWidth !== 0;
      return visible || !(0, _isEmpty2.default)(events);
    };
    const axisType = props.dependentAxis ? "radial" : "angular";
    const gridComponent = axisType === "radial" ? props.circularGridComponent : props.gridComponent;
    const tickComponents = this.dataKeys.map((key, index) => {
      const tickProps = Object.assign({
        key: `${name}-tick-${key}`
      }, this.getComponentProps(tickComponent, "ticks", index));
      const TickComponent = /*#__PURE__*/_react.default.cloneElement(tickComponent, tickProps);
      return shouldRender(TickComponent.props) ? TickComponent : undefined;
    }).filter(Boolean);
    const gridComponents = this.dataKeys.map((key, index) => {
      const gridProps = Object.assign({
        key: `${name}-grid-${key}`
      }, this.getComponentProps(gridComponent, "grid", index));
      const GridComponent = /*#__PURE__*/_react.default.cloneElement(gridComponent, gridProps);
      return shouldRender(GridComponent.props) ? GridComponent : undefined;
    }).filter(Boolean);
    const tickLabelComponents = this.dataKeys.map((key, index) => {
      const tickLabelProps = Object.assign({
        key: `${name}-tick-${key}`
      }, this.getComponentProps(tickLabelComponent, "tickLabels", index));
      return /*#__PURE__*/_react.default.cloneElement(tickLabelComponent, tickLabelProps);
    });
    const axis = this.renderAxisLine(props);
    const axisLabel = this.renderLabel(props);
    const children = [axis, axisLabel, ...tickComponents, ...gridComponents, ...tickLabelComponents];
    return this.renderGroup(props, children);
  }

  // Overridden in victory-native
  renderGroup(props, children) {
    const {
      groupComponent
    } = props;
    return /*#__PURE__*/_react.default.cloneElement(groupComponent, {}, children);
  }
  shouldAnimate() {
    return !!this.props.animate;
  }
  render() {
    const {
      animationWhitelist
    } = VictoryPolarAxis;
    const props = _victoryCore.Axis.modifyProps(this.props, fallbackProps);
    if (this.shouldAnimate()) {
      return this.animateComponent(props, animationWhitelist);
    }
    const children = this.renderAxis(props);
    return props.standalone ? this.renderContainer(props.containerComponent, children) : children;
  }
}
const options = {
  components: [{
    name: "axis",
    index: 0
  }, {
    name: "axisLabel",
    index: 0
  }, {
    name: "grid"
  }, {
    name: "parent",
    index: "parent"
  }, {
    name: "ticks"
  }, {
    name: "tickLabels"
  }]
};
const VictoryPolarAxis = exports.VictoryPolarAxis = (0, _victoryCore.addEvents)(VictoryPolarAxisBase, options);