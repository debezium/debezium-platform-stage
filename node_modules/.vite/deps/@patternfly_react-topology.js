import {
  c_about_modal_box_BackgroundImage_default,
  c_alert_title_max_lines_default,
  c_background_image_BackgroundImage_default,
  c_brand_Height_default,
  c_brand_Width_default,
  c_date_picker_input_c_form_control_Width_default,
  c_date_picker_input_c_form_control_width_chars_default,
  c_description_list_GridTemplateColumns_min_default,
  c_description_list_m_horizontal_term_width_default,
  c_drawer_panel_md_FlexBasis_default,
  c_drawer_panel_md_FlexBasis_max_default,
  c_drawer_panel_md_FlexBasis_min_default,
  c_dual_list_selector_menu_MinHeight_default,
  c_expandable_section_m_truncate_content_LineClamp_default,
  c_form_m_limit_width_MaxWidth_default,
  c_jump_links_toggle_Display_default,
  c_label_text_MaxWidth_default,
  c_menu_content_Height_default,
  c_menu_content_MaxHeight_default,
  c_menu_m_flyout_menu_left_offset_default,
  c_menu_m_flyout_menu_m_left_right_offset_default,
  c_menu_m_flyout_menu_top_offset_default,
  c_modal_box_m_align_top_spacer_default,
  c_notification_drawer_group_toggle_title_max_lines_default,
  c_notification_drawer_list_item_header_title_max_lines_default,
  c_number_input_c_form_control_width_chars_default,
  c_pagination_nav_page_select_c_form_control_width_chars_default,
  c_panel_main_MaxHeight_default,
  c_popover_MaxWidth_default,
  c_popover_MinWidth_default,
  c_skeleton_Height_default,
  c_skeleton_Width_default,
  c_slider_step_InsetInlineStart_default,
  c_slider_value_c_form_control_width_chars_default,
  c_slider_value_default,
  c_spinner_diameter_default,
  c_tooltip_MaxWidth_default,
  c_wizard_Height_default,
  createFocusTrap,
  fromEvent,
  global_breakpoint_2xl_default,
  global_breakpoint_height_2xl_default,
  global_breakpoint_height_lg_default,
  global_breakpoint_height_md_default,
  global_breakpoint_height_sm_default,
  global_breakpoint_height_xl_default,
  global_breakpoint_lg_default,
  global_breakpoint_md_default,
  global_breakpoint_sm_default,
  global_breakpoint_xl_default,
  l_flex_item_Order,
  l_gallery_GridTemplateColumns_max_default,
  l_gallery_GridTemplateColumns_min_default,
  l_grid_item_Order,
  require_prop_types,
  useDropzone
} from "./chunk-PNBPGLFK.js";
import {
  __awaiter,
  __rest
} from "./chunk-EJSEPX5B.js";
import {
  require_react_dom
} from "./chunk-LZCBAB22.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __reExport,
  __toCommonJS,
  __toESM,
  require_react
} from "./chunk-YALARCHK.js";

// vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-view.css
var topology_view_exports = {};
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-view.css";
var init_topology_view = __esm({
  "vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-view.css"() {
  }
});

// node_modules/@patternfly/react-topology/dist/esm/css/topology-view.js
var require_topology_view = __commonJS({
  "node_modules/@patternfly/react-topology/dist/esm/css/topology-view.js"(exports) {
    "use strict";
    exports.__esModule = true;
    init_topology_view();
    exports.default = {
      "topologyContainer": "pf-topology-container",
      "topologyContent": "pf-topology-content"
    };
  }
});

// vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-side-bar.css
var topology_side_bar_exports = {};
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-side-bar.css";
var init_topology_side_bar = __esm({
  "vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-side-bar.css"() {
  }
});

// node_modules/@patternfly/react-topology/dist/esm/css/topology-side-bar.js
var require_topology_side_bar = __commonJS({
  "node_modules/@patternfly/react-topology/dist/esm/css/topology-side-bar.js"(exports) {
    "use strict";
    exports.__esModule = true;
    init_topology_side_bar();
    exports.default = {
      "in": "in",
      "shown": "shown",
      "topologyContainerWithSidebar": "pf-topology-container__with-sidebar",
      "topologyContainerWithSidebarOpen": "pf-topology-container__with-sidebar--open",
      "topologyContent": "pf-topology-content",
      "topologyResizableSideBar": "pf-topology-resizable-side-bar",
      "topologySideBar": "pf-topology-side-bar",
      "topologySideBarDismiss": "pf-topology-side-bar__dismiss",
      "topologySideBarHeader": "pf-topology-side-bar__header",
      "v6CButton": "pf-v6-c-button"
    };
  }
});

// vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-controlbar.css
var topology_controlbar_exports = {};
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-controlbar.css";
var init_topology_controlbar = __esm({
  "vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-controlbar.css"() {
  }
});

// node_modules/@patternfly/react-topology/dist/esm/css/topology-controlbar.js
var require_topology_controlbar = __commonJS({
  "node_modules/@patternfly/react-topology/dist/esm/css/topology-controlbar.js"(exports) {
    "use strict";
    exports.__esModule = true;
    init_topology_controlbar();
    exports.default = {
      "modifiers": {
        "tertiary": "pf-m-tertiary",
        "disabled": "pf-m-disabled"
      },
      "topologyControlBar": "pf-topology-control-bar",
      "topologyControlBarButton": "pf-topology-control-bar__button",
      "v6CButton": "pf-v6-c-button"
    };
  }
});

// vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-components.css
var topology_components_exports = {};
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-components.css";
var init_topology_components = __esm({
  "vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-components.css"() {
  }
});

// node_modules/@patternfly/react-topology/dist/esm/css/topology-components.js
var require_topology_components = __commonJS({
  "node_modules/@patternfly/react-topology/dist/esm/css/topology-components.js"(exports) {
    "use strict";
    exports.__esModule = true;
    init_topology_components();
    exports.default = {
      "modifiers": {
        "hover": "pf-m-hover",
        "disabled": "pf-m-disabled",
        "info": "pf-m-info",
        "success": "pf-m-success",
        "warning": "pf-m-warning",
        "danger": "pf-m-danger",
        "selected": "pf-m-selected",
        "dragging": "pf-m-dragging",
        "secondary": "pf-m-secondary",
        "altGroup": "pf-m-alt-group",
        "dropTarget": "pf-m-drop-target",
        "dotted": "pf-m-dotted",
        "dashed": "pf-m-dashed",
        "dashedMd": "pf-m-dashed-md",
        "dashedLg": "pf-m-dashed-lg",
        "dashedXl": "pf-m-dashed-xl",
        "draggable": "pf-m-draggable",
        "altConnectorArrow": "pf-m-alt-connector-arrow",
        "source": "pf-m-source"
      },
      "topologyConnectorArrow": "pf-topology-connector-arrow",
      "topologyConnectorCircle": "pf-topology__connector-circle",
      "topologyConnectorCross": "pf-topology__connector-cross",
      "topologyConnectorSquare": "pf-topology__connector-square",
      "topologyConnectorX": "pf-topology__connector-x",
      "topologyContextMenuCDropdownMenu": "pf-topology-context-menu__c-dropdown__menu",
      "topologyContextSubMenu": "pf-topology-context-sub-menu",
      "topologyContextSubMenuArrow": "pf-topology-context-sub-menu__arrow",
      "topologyDefaultCreateConnector": "pf-topology-default-create-connector",
      "topologyDefaultCreateConnectorArrow": "pf-topology-default-create-connector__arrow",
      "topologyDefaultCreateConnectorCreate": "pf-topology-default-create-connector__create",
      "topologyDefaultCreateConnectorCreateBg": "pf-topology-default-create-connector__create__bg",
      "topologyDefaultCreateConnectorCreateCursor": "pf-topology-default-create-connector__create__cursor",
      "topologyDefaultCreateConnectorLine": "pf-topology-default-create-connector__line",
      "topologyEdge": "pf-topology__edge",
      "topologyEdgeBackground": "pf-topology__edge__background",
      "topologyEdgeLink": "pf-topology__edge__link",
      "topologyEdgeTag": "pf-topology__edge__tag",
      "topologyEdgeTagBackground": "pf-topology__edge__tag__background",
      "topologyGroup": "pf-topology__group",
      "topologyGroupBackground": "pf-topology__group__background",
      "topologyGroupCollapsedBadge": "pf-topology__group__collapsed-badge",
      "topologyGroupLabel": "pf-topology__group__label",
      "topologyNode": "pf-topology__node",
      "topologyNodeActionIcon": "pf-topology__node__action-icon",
      "topologyNodeActionIconBackground": "pf-topology__node__action-icon__background",
      "topologyNodeActionIconIcon": "pf-topology__node__action-icon__icon",
      "topologyNodeBackground": "pf-topology__node__background",
      "topologyNodeDecorator": "pf-topology__node__decorator",
      "topologyNodeDecoratorBg": "pf-topology__node__decorator__bg",
      "topologyNodeDecoratorIcon": "pf-topology__node__decorator__icon",
      "topologyNodeDecoratorStatus": "pf-topology__node__decorator__status",
      "topologyNodeLabel": "pf-topology__node__label",
      "topologyNodeLabelBackground": "pf-topology__node__label__background",
      "topologyNodeLabelBadge": "pf-topology__node__label__badge",
      "topologyNodeLabelIcon": "pf-topology__node__label__icon",
      "topologyNodeLabelIconBackground": "pf-topology__node__label__icon__background",
      "topologyNodeSeparator": "pf-topology__node__separator",
      "topologyVisualizationSurface": "pf-topology-visualization-surface",
      "topologyVisualizationSurfaceSvg": "pf-topology-visualization-surface__svg"
    };
  }
});

// node_modules/mobx-react-lite/batchingForReactDom.js
var require_batchingForReactDom = __commonJS({
  "node_modules/mobx-react-lite/batchingForReactDom.js"() {
    if (true) {
      console.warn("[mobx-react-lite] importing batchingForReactDom is no longer needed");
    }
  }
});

// node_modules/@patternfly/react-tokens/dist/js/color_black.js
var require_color_black = __commonJS({
  "node_modules/@patternfly/react-tokens/dist/js/color_black.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.color_black = {
      "name": "--pf-t--color--black",
      "value": "#000",
      "var": "var(--pf-t--color--black)"
    };
    exports["default"] = exports.color_black;
  }
});

// node_modules/@patternfly/react-tokens/dist/js/color_blue_10.js
var require_color_blue_10 = __commonJS({
  "node_modules/@patternfly/react-tokens/dist/js/color_blue_10.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.color_blue_10 = {
      "name": "--pf-t--color--blue--10",
      "value": "#e0f0ff",
      "var": "var(--pf-t--color--blue--10)"
    };
    exports["default"] = exports.color_blue_10;
  }
});

// node_modules/@patternfly/react-tokens/dist/js/color_blue_30.js
var require_color_blue_30 = __commonJS({
  "node_modules/@patternfly/react-tokens/dist/js/color_blue_30.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.color_blue_30 = {
      "name": "--pf-t--color--blue--30",
      "value": "#92c5f9",
      "var": "var(--pf-t--color--blue--30)"
    };
    exports["default"] = exports.color_blue_30;
  }
});

// node_modules/point-in-svg-path/index.js
var require_point_in_svg_path = __commonJS({
  "node_modules/point-in-svg-path/index.js"(exports, module) {
    var clone = (obj) => {
      if (typeof obj === "function" || Object(obj) !== obj) {
        return obj;
      }
      const res = new obj.constructor();
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          res[key] = clone(obj[key]);
        }
      }
      return res;
    };
    function repush(array5, item) {
      for (var i = 0, c6 = array5.length; i < c6; i++) {
        if (array5[i] === item) {
          return array5.push(array5.splice(i, 1)[0]);
        }
      }
    }
    function cacher(f, scope, postprocessor) {
      function newf() {
        var arg = Array.prototype.slice.call(arguments, 0), args = arg.join("â€"), cache = newf.cache = newf.cache || {}, count3 = newf.count = newf.count || [];
        if (cache.hasOwnProperty(args)) {
          repush(count3, args);
          return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        count3.length >= 1e3 && delete cache[count3.shift()];
        count3.push(args);
        cache[args] = f.apply(scope, arg);
        return postprocessor ? postprocessor(cache[args]) : cache[args];
      }
      return newf;
    }
    function paths(ps) {
      var p = paths.ps = paths.ps || {};
      if (p[ps]) {
        p[ps].sleep = 100;
      } else {
        p[ps] = {
          sleep: 100
        };
      }
      setTimeout(function() {
        for (var key in p) if (p.hasOwnProperty(key) && key != ps) {
          p[key].sleep--;
          !p[key].sleep && delete p[key];
        }
      });
      return p[ps];
    }
    function box2(x4, y4, width, height) {
      if (x4 == null) {
        x4 = y4 = width = height = 0;
      }
      if (y4 == null) {
        y4 = x4.y;
        width = x4.width;
        height = x4.height;
        x4 = x4.x;
      }
      return {
        x: x4,
        y: y4,
        width,
        w: width,
        height,
        h: height,
        x2: x4 + width,
        y2: y4 + height,
        cx: x4 + width / 2,
        cy: y4 + height / 2,
        r1: Math.min(width, height) / 2,
        r2: Math.max(width, height) / 2,
        r0: Math.sqrt(width * width + height * height) / 2,
        path: rectPath(x4, y4, width, height),
        vb: [x4, y4, width, height].join(" ")
      };
    }
    function pathClone(pathArray) {
      var res = clone(pathArray);
      return res;
    }
    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
      var t13 = 1 - t, t132 = Math.pow(t13, 3), t122 = Math.pow(t13, 2), t22 = t * t, t32 = t22 * t, x4 = t132 * p1x + t122 * 3 * t * c1x + t13 * 3 * t * t * c2x + t32 * p2x, y4 = t132 * p1y + t122 * 3 * t * c1y + t13 * 3 * t * t * c2y + t32 * p2y, mx = p1x + 2 * t * (c1x - p1x) + t22 * (c2x - 2 * c1x + p1x), my = p1y + 2 * t * (c1y - p1y) + t22 * (c2y - 2 * c1y + p1y), nx = c1x + 2 * t * (c2x - c1x) + t22 * (p2x - 2 * c2x + c1x), ny = c1y + 2 * t * (c2y - c1y) + t22 * (p2y - 2 * c2y + c1y), ax = t13 * p1x + t * c1x, ay = t13 * p1y + t * c1y, cx = t13 * c2x + t * p2x, cy = t13 * c2y + t * p2y, alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
      return {
        x: x4,
        y: y4,
        m: { x: mx, y: my },
        n: { x: nx, y: ny },
        start: { x: ax, y: ay },
        end: { x: cx, y: cy },
        alpha
      };
    }
    function is2(o, type2) {
      type2 = String.prototype.toLowerCase.call(type2);
      if (type2 == "finite") {
        return isFinite(o);
      }
      if (type2 == "array" && (o instanceof Array || Array.isArray && Array.isArray(o))) {
        return true;
      }
      return type2 == "null" && o === null || type2 == typeof o && o !== null || type2 == "object" && o === Object(o) || Object.prototype.toString.call(o).slice(8, -1).toLowerCase() == type2;
    }
    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
      if (!is2(p1x, "array")) {
        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
      }
      var bbox = curveDim.apply(null, p1x);
      return box2(
        bbox.min.x,
        bbox.min.y,
        bbox.max.x - bbox.min.x,
        bbox.max.y - bbox.min.y
      );
    }
    function isPointInsideBBox(bbox, x4, y4) {
      return x4 >= bbox.x && x4 <= bbox.x + bbox.width && y4 >= bbox.y && y4 <= bbox.y + bbox.height;
    }
    function isBBoxIntersect(bbox1, bbox2) {
      bbox1 = box2(bbox1);
      bbox2 = box2(bbox2);
      return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    }
    function base3(t, p1, p2, p3, p4) {
      var t13 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4, t22 = t * t13 + 6 * p1 - 12 * p2 + 6 * p3;
      return t * t22 - 3 * p1 + 3 * p2;
    }
    function bezlen(x12, y12, x22, y22, x32, y32, x4, y4, z) {
      if (z == null) {
        z = 1;
      }
      z = z > 1 ? 1 : z < 0 ? 0 : z;
      var z2 = z / 2, n = 12, Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], sum4 = 0;
      for (var i = 0; i < n; i++) {
        var ct = z2 * Tvalues[i] + z2, xbase = base3(ct, x12, x22, x32, x4), ybase = base3(ct, y12, y22, y32, y4), comb = xbase * xbase + ybase * ybase;
        sum4 += Cvalues[i] * Math.sqrt(comb);
      }
      return z2 * sum4;
    }
    function intersect2(x12, y12, x22, y22, x32, y32, x4, y4) {
      if (Math.max(x12, x22) < Math.min(x32, x4) || Math.min(x12, x22) > Math.max(x32, x4) || Math.max(y12, y22) < Math.min(y32, y4) || Math.min(y12, y22) > Math.max(y32, y4)) {
        return;
      }
      var nx = (x12 * y22 - y12 * x22) * (x32 - x4) - (x12 - x22) * (x32 * y4 - y32 * x4), ny = (x12 * y22 - y12 * x22) * (y32 - y4) - (y12 - y22) * (x32 * y4 - y32 * x4), denominator = (x12 - x22) * (y32 - y4) - (y12 - y22) * (x32 - x4);
      if (!denominator) {
        return;
      }
      var px = nx / denominator, py = ny / denominator, px2 = +px.toFixed(2), py2 = +py.toFixed(2);
      if (px2 < +Math.min(x12, x22).toFixed(2) || px2 > +Math.max(x12, x22).toFixed(2) || px2 < +Math.min(x32, x4).toFixed(2) || px2 > +Math.max(x32, x4).toFixed(2) || py2 < +Math.min(y12, y22).toFixed(2) || py2 > +Math.max(y12, y22).toFixed(2) || py2 < +Math.min(y32, y4).toFixed(2) || py2 > +Math.max(y32, y4).toFixed(2)) {
        return;
      }
      return { x: px, y: py };
    }
    function interHelper(bez1, bez2, justCount) {
      var bbox1 = bezierBBox(bez1), bbox2 = bezierBBox(bez2);
      if (!isBBoxIntersect(bbox1, bbox2)) {
        return justCount ? 0 : [];
      }
      var l1 = bezlen.apply(0, bez1), l2 = bezlen.apply(0, bez2), n1 = ~~(l1 / 8), n2 = ~~(l2 / 8), dots1 = [], dots2 = [], xy = {}, res = justCount ? 0 : [];
      for (var i = 0; i < n1 + 1; i++) {
        var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
        dots1.push({ x: p.x, y: p.y, t: i / n1 });
      }
      for (i = 0; i < n2 + 1; i++) {
        p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
        dots2.push({ x: p.x, y: p.y, t: i / n2 });
      }
      for (i = 0; i < n1; i++) {
        for (var j = 0; j < n2; j++) {
          var di = dots1[i], di1 = dots1[i + 1], dj = dots2[j], dj1 = dots2[j + 1], ci = Math.abs(di1.x - di.x) < 1e-3 ? "y" : "x", cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x", is3 = intersect2(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
          if (is3) {
            if (xy[is3.x.toFixed(4)] == is3.y.toFixed(4)) {
              continue;
            }
            xy[is3.x.toFixed(4)] = is3.y.toFixed(4);
            var t13 = di.t + Math.abs((is3[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t), t22 = dj.t + Math.abs((is3[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
            if (t13 >= 0 && t13 <= 1 && t22 >= 0 && t22 <= 1) {
              if (justCount) {
                res++;
              } else {
                res.push({
                  x: is3.x,
                  y: is3.y,
                  t1: t13,
                  t2: t22
                });
              }
            }
          }
        }
      }
      return res;
    }
    function interPathHelper(path1, path22, justCount) {
      path1 = path2curve(path1);
      path22 = path2curve(path22);
      var x12, y12, x22, y22, x1m, y1m, x2m, y2m, bez1, bez2, res = justCount ? 0 : [];
      for (var i = 0, ii = path1.length; i < ii; i++) {
        var pi6 = path1[i];
        if (pi6[0] == "M") {
          x12 = x1m = pi6[1];
          y12 = y1m = pi6[2];
        } else {
          if (pi6[0] == "C") {
            bez1 = [x12, y12].concat(pi6.slice(1));
            x12 = bez1[6];
            y12 = bez1[7];
          } else {
            bez1 = [x12, y12, x12, y12, x1m, y1m, x1m, y1m];
            x12 = x1m;
            y12 = y1m;
          }
          for (var j = 0, jj = path22.length; j < jj; j++) {
            var pj = path22[j];
            if (pj[0] == "M") {
              x22 = x2m = pj[1];
              y22 = y2m = pj[2];
            } else {
              if (pj[0] == "C") {
                bez2 = [x22, y22].concat(pj.slice(1));
                x22 = bez2[6];
                y22 = bez2[7];
              } else {
                bez2 = [x22, y22, x22, y22, x2m, y2m, x2m, y2m];
                x22 = x2m;
                y22 = y2m;
              }
              var intr = interHelper(bez1, bez2, justCount);
              if (justCount) {
                res += intr;
              } else {
                for (var k2 = 0, kk = intr.length; k2 < kk; k2++) {
                  intr[k2].segment1 = i;
                  intr[k2].segment2 = j;
                  intr[k2].bez1 = bez1;
                  intr[k2].bez2 = bez2;
                }
                res = res.concat(intr);
              }
            }
          }
        }
      }
      return res;
    }
    function pathBBox(path3) {
      var pth = paths(path3);
      if (pth.bbox) {
        return clone(pth.bbox);
      }
      if (!path3) {
        return box2();
      }
      var pathLocal = path2curve(path3);
      var x4 = 0;
      var y4 = 0;
      var X3 = [];
      var Y3 = [];
      var p = [];
      for (var i = 0, c6 = pathLocal.length; i < c6; i++) {
        p = pathLocal[i];
        if (p[0] == "M") {
          x4 = p[1];
          y4 = p[2];
          X3.push(x4);
          Y3.push(y4);
          continue;
        }
        var dim = curveDim(x4, y4, p[1], p[2], p[3], p[4], p[5], p[6]);
        X3 = X3.concat(dim.min.x, dim.max.x);
        Y3 = Y3.concat(dim.min.y, dim.max.y);
        x4 = p[5];
        y4 = p[6];
      }
      var xmin = Math.min.apply(0, X3);
      var ymin = Math.min.apply(0, Y3);
      var xmax = Math.max.apply(0, X3);
      var ymax = Math.max.apply(0, Y3);
      var bb2 = box2(xmin, ymin, xmax - xmin, ymax - ymin);
      pth.bbox = clone(bb2);
      return bb2;
    }
    function rectPath(x4, y4, w, h, r) {
      if (r) {
        return [
          ["M", +x4 + +r, y4],
          ["l", w - r * 2, 0],
          ["a", r, r, 0, 0, 1, r, r],
          ["l", 0, h - r * 2],
          ["a", r, r, 0, 0, 1, -r, r],
          ["l", r * 2 - w, 0],
          ["a", r, r, 0, 0, 1, -r, -r],
          ["l", 0, r * 2 - h],
          ["a", r, r, 0, 0, 1, r, -r],
          ["z"]
        ];
      }
      var res = [["M", x4, y4], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
      return res;
    }
    function ellipsePath(x4, y4, rx, ry, a4) {
      if (a4 == null && ry == null) {
        ry = rx;
      }
      x4 = +x4;
      y4 = +y4;
      rx = +rx;
      ry = +ry;
      if (a4 != null) {
        var rad = Math.PI / 180, x12 = x4 + rx * Math.cos(-ry * rad), x22 = x4 + rx * Math.cos(-a4 * rad), y12 = y4 + rx * Math.sin(-ry * rad), y22 = y4 + rx * Math.sin(-a4 * rad), res = [["M", x12, y12], ["A", rx, rx, 0, +(a4 - ry > 180), 0, x22, y22]];
      } else {
        res = [
          ["M", x4, y4],
          ["m", 0, -ry],
          ["a", rx, ry, 0, 1, 1, 0, 2 * ry],
          ["a", rx, ry, 0, 1, 1, 0, -2 * ry],
          ["z"]
        ];
      }
      return res;
    }
    var pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig;
    var pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\s]*,?[\s]*/ig;
    function parsePathString(pathString) {
      if (!pathString) {
        return null;
      }
      var pth = paths(pathString);
      if (pth.arr) {
        return clone(pth.arr);
      }
      var paramCounts = {
        a: 7,
        c: 6,
        o: 2,
        h: 1,
        l: 2,
        m: 2,
        r: 4,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        u: 3,
        z: 0
      }, data = [];
      if (is2(pathString, "array") && is2(pathString[0], "array")) {
        data = Snap.path.clone(pathString);
      }
      if (!data.length) {
        String(pathString).replace(pathCommand, function(a4, b, c6) {
          var params = [], name = b.toLowerCase();
          c6.replace(pathValues, function(a5, b10) {
            b10 && params.push(+b10);
          });
          if (name == "m" && params.length > 2) {
            data.push([b].concat(params.splice(0, 2)));
            name = "l";
            b = b == "m" ? "l" : "L";
          }
          if (name == "o" && params.length == 1) {
            data.push([b, params[0]]);
          }
          if (name == "r") {
            data.push([b].concat(params));
          } else while (params.length >= paramCounts[name]) {
            data.push([b].concat(params.splice(0, paramCounts[name])));
            if (!paramCounts[name]) {
              break;
            }
          }
        });
      }
      pth.arr = clone(data);
      return data;
    }
    function pathToAbsolute(pathArray) {
      var pth = paths(pathArray);
      if (pth.abs) {
        return pathClone(pth.abs);
      }
      if (!is2(pathArray, "array") || !is2(pathArray && pathArray[0], "array")) {
        pathArray = parsePathString(pathArray);
      }
      if (!pathArray || !pathArray.length) {
        return [["M", 0, 0]];
      }
      var res = [], x4 = 0, y4 = 0, mx = 0, my = 0, start3 = 0, pa0;
      if (pathArray[0][0] == "M") {
        x4 = +pathArray[0][1];
        y4 = +pathArray[0][2];
        mx = x4;
        my = y4;
        start3++;
        res[0] = ["M", x4, y4];
      }
      var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
      for (var r, pa, i = start3, ii = pathArray.length; i < ii; i++) {
        res.push(r = []);
        pa = pathArray[i];
        pa0 = pa[0];
        if (pa0 != pa0.toUpperCase()) {
          r[0] = pa0.toUpperCase();
          switch (r[0]) {
            case "A":
              r[1] = pa[1];
              r[2] = pa[2];
              r[3] = pa[3];
              r[4] = pa[4];
              r[5] = pa[5];
              r[6] = +pa[6] + x4;
              r[7] = +pa[7] + y4;
              break;
            case "V":
              r[1] = +pa[1] + y4;
              break;
            case "H":
              r[1] = +pa[1] + x4;
              break;
            case "R":
              var dots = [x4, y4].concat(pa.slice(1));
              for (var j = 2, jj = dots.length; j < jj; j++) {
                dots[j] = +dots[j] + x4;
                dots[++j] = +dots[j] + y4;
              }
              res.pop();
              res = res.concat(catmullRom2bezier(dots, crz));
              break;
            case "O":
              res.pop();
              dots = ellipsePath(x4, y4, pa[1], pa[2]);
              dots.push(dots[0]);
              res = res.concat(dots);
              break;
            case "U":
              res.pop();
              res = res.concat(ellipsePath(x4, y4, pa[1], pa[2], pa[3]));
              r = ["U"].concat(res[res.length - 1].slice(-2));
              break;
            case "M":
              mx = +pa[1] + x4;
              my = +pa[2] + y4;
            default:
              for (j = 1, jj = pa.length; j < jj; j++) {
                r[j] = +pa[j] + (j % 2 ? x4 : y4);
              }
          }
        } else if (pa0 == "R") {
          dots = [x4, y4].concat(pa.slice(1));
          res.pop();
          res = res.concat(catmullRom2bezier(dots, crz));
          r = ["R"].concat(pa.slice(-2));
        } else if (pa0 == "O") {
          res.pop();
          dots = ellipsePath(x4, y4, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
        } else if (pa0 == "U") {
          res.pop();
          res = res.concat(ellipsePath(x4, y4, pa[1], pa[2], pa[3]));
          r = ["U"].concat(res[res.length - 1].slice(-2));
        } else {
          for (var k2 = 0, kk = pa.length; k2 < kk; k2++) {
            r[k2] = pa[k2];
          }
        }
        pa0 = pa0.toUpperCase();
        if (pa0 != "O") {
          switch (r[0]) {
            case "Z":
              x4 = +mx;
              y4 = +my;
              break;
            case "H":
              x4 = r[1];
              break;
            case "V":
              y4 = r[1];
              break;
            case "M":
              mx = r[r.length - 2];
              my = r[r.length - 1];
            default:
              x4 = r[r.length - 2];
              y4 = r[r.length - 1];
          }
        }
      }
      pth.abs = pathClone(res);
      return res;
    }
    function l2c(x12, y12, x22, y22) {
      return [x12, y12, x22, y22, x22, y22];
    }
    function q2c(x12, y12, ax, ay, x22, y22) {
      var _132 = 1 / 3, _23 = 2 / 3;
      return [
        _132 * x12 + _23 * ax,
        _132 * y12 + _23 * ay,
        _132 * x22 + _23 * ax,
        _132 * y22 + _23 * ay,
        x22,
        y22
      ];
    }
    function curveDim(x06, y06, x12, y12, x22, y22, x32, y32) {
      var tvalues = [], bounds = [[], []], a4, b, c6, t, t13, t22, b2ac, sqrtb2ac;
      for (var i = 0; i < 2; ++i) {
        if (i == 0) {
          b = 6 * x06 - 12 * x12 + 6 * x22;
          a4 = -3 * x06 + 9 * x12 - 9 * x22 + 3 * x32;
          c6 = 3 * x12 - 3 * x06;
        } else {
          b = 6 * y06 - 12 * y12 + 6 * y22;
          a4 = -3 * y06 + 9 * y12 - 9 * y22 + 3 * y32;
          c6 = 3 * y12 - 3 * y06;
        }
        if (Math.abs(a4) < 1e-12) {
          if (Math.abs(b) < 1e-12) {
            continue;
          }
          t = -c6 / b;
          if (0 < t && t < 1) {
            tvalues.push(t);
          }
          continue;
        }
        b2ac = b * b - 4 * c6 * a4;
        sqrtb2ac = Math.sqrt(b2ac);
        if (b2ac < 0) {
          continue;
        }
        t13 = (-b + sqrtb2ac) / (2 * a4);
        if (0 < t13 && t13 < 1) {
          tvalues.push(t13);
        }
        t22 = (-b - sqrtb2ac) / (2 * a4);
        if (0 < t22 && t22 < 1) {
          tvalues.push(t22);
        }
      }
      var x4, y4, j = tvalues.length, jlen = j, mt;
      while (j--) {
        t = tvalues[j];
        mt = 1 - t;
        bounds[0][j] = mt * mt * mt * x06 + 3 * mt * mt * t * x12 + 3 * mt * t * t * x22 + t * t * t * x32;
        bounds[1][j] = mt * mt * mt * y06 + 3 * mt * mt * t * y12 + 3 * mt * t * t * y22 + t * t * t * y32;
      }
      bounds[0][jlen] = x06;
      bounds[1][jlen] = y06;
      bounds[0][jlen + 1] = x32;
      bounds[1][jlen + 1] = y32;
      bounds[0].length = bounds[1].length = jlen + 2;
      return {
        min: { x: Math.min.apply(0, bounds[0]), y: Math.min.apply(0, bounds[1]) },
        max: { x: Math.max.apply(0, bounds[0]), y: Math.max.apply(0, bounds[1]) }
      };
    }
    function a2c(x12, y12, rx, ry, angle2, large_arc_flag, sweep_flag, x22, y22, recursive) {
      var _120 = Math.PI * 120 / 180, rad = Math.PI / 180 * (+angle2 || 0), res = [], xy, rotate = cacher(function(x5, y5, rad2) {
        var X3 = x5 * Math.cos(rad2) - y5 * Math.sin(rad2), Y3 = x5 * Math.sin(rad2) + y5 * Math.cos(rad2);
        return { x: X3, y: Y3 };
      });
      if (!rx || !ry) {
        return [x12, y12, x22, y22, x22, y22];
      }
      if (!recursive) {
        xy = rotate(x12, y12, -rad);
        x12 = xy.x;
        y12 = xy.y;
        xy = rotate(x22, y22, -rad);
        x22 = xy.x;
        y22 = xy.y;
        var cos4 = Math.cos(Math.PI / 180 * angle2), sin4 = Math.sin(Math.PI / 180 * angle2), x4 = (x12 - x22) / 2, y4 = (y12 - y22) / 2;
        var h = x4 * x4 / (rx * rx) + y4 * y4 / (ry * ry);
        if (h > 1) {
          h = Math.sqrt(h);
          rx = h * rx;
          ry = h * ry;
        }
        var rx2 = rx * rx, ry2 = ry * ry, k2 = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y4 * y4 - ry2 * x4 * x4) / (rx2 * y4 * y4 + ry2 * x4 * x4))), cx = k2 * rx * y4 / ry + (x12 + x22) / 2, cy = k2 * -ry * x4 / rx + (y12 + y22) / 2, f1 = Math.asin(((y12 - cy) / ry).toFixed(9)), f2 = Math.asin(((y22 - cy) / ry).toFixed(9));
        f1 = x12 < cx ? Math.PI - f1 : f1;
        f2 = x22 < cx ? Math.PI - f2 : f2;
        f1 < 0 && (f1 = Math.PI * 2 + f1);
        f2 < 0 && (f2 = Math.PI * 2 + f2);
        if (sweep_flag && f1 > f2) {
          f1 = f1 - Math.PI * 2;
        }
        if (!sweep_flag && f2 > f1) {
          f2 = f2 - Math.PI * 2;
        }
      } else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
      }
      var df = f2 - f1;
      if (Math.abs(df) > _120) {
        var f2old = f2, x2old = x22, y2old = y22;
        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
        x22 = cx + rx * Math.cos(f2);
        y22 = cy + ry * Math.sin(f2);
        res = a2c(x22, y22, rx, ry, angle2, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
      }
      df = f2 - f1;
      var c1 = Math.cos(f1), s1 = Math.sin(f1), c22 = Math.cos(f2), s2 = Math.sin(f2), t = Math.tan(df / 4), hx = 4 / 3 * rx * t, hy = 4 / 3 * ry * t, m1 = [x12, y12], m22 = [x12 + hx * s1, y12 - hy * c1], m3 = [x22 + hx * s2, y22 - hy * c22], m4 = [x22, y22];
      m22[0] = 2 * m1[0] - m22[0];
      m22[1] = 2 * m1[1] - m22[1];
      if (recursive) {
        return [m22, m3, m4].concat(res);
      } else {
        res = [m22, m3, m4].concat(res).join().split(",");
        var newres = [];
        for (var i = 0, ii = res.length; i < ii; i++) {
          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
        }
        return newres;
      }
    }
    function path2curve(path3, path22) {
      var pth = !path22 && paths(path3);
      if (!path22 && pth.curve) {
        return pathClone(pth.curve);
      }
      var p = pathToAbsolute(path3);
      var p2 = path22 && pathToAbsolute(path22);
      var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
      var attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
      var processPath = function(path4, d, pcom2) {
        var nx, ny;
        if (!path4) {
          return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
        }
        !(path4[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);
        switch (path4[0]) {
          case "M":
            d.X = path4[1];
            d.Y = path4[2];
            break;
          case "A":
            path4 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path4.slice(1))));
            break;
          case "S":
            if (pcom2 == "C" || pcom2 == "S") {
              nx = d.x * 2 - d.bx;
              ny = d.y * 2 - d.by;
            } else {
              nx = d.x;
              ny = d.y;
            }
            path4 = ["C", nx, ny].concat(path4.slice(1));
            break;
          case "T":
            if (pcom2 == "Q" || pcom2 == "T") {
              d.qx = d.x * 2 - d.qx;
              d.qy = d.y * 2 - d.qy;
            } else {
              d.qx = d.x;
              d.qy = d.y;
            }
            path4 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path4[1], path4[2]));
            break;
          case "Q":
            d.qx = path4[1];
            d.qy = path4[2];
            path4 = ["C"].concat(q2c(d.x, d.y, path4[1], path4[2], path4[3], path4[4]));
            break;
          case "L":
            path4 = ["C"].concat(l2c(d.x, d.y, path4[1], path4[2]));
            break;
          case "H":
            path4 = ["C"].concat(l2c(d.x, d.y, path4[1], d.y));
            break;
          case "V":
            path4 = ["C"].concat(l2c(d.x, d.y, d.x, path4[1]));
            break;
          case "Z":
            path4 = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
            break;
        }
        return path4;
      };
      var fixArc = function(pp, i2) {
        if (pp[i2].length > 7) {
          pp[i2].shift();
          var pi6 = pp[i2];
          while (pi6.length) {
            pcoms1[i2] = "A";
            p2 && (pcoms2[i2] = "A");
            pp.splice(i2++, 0, ["C"].concat(pi6.splice(0, 6)));
          }
          pp.splice(i2, 1);
          ii = Math.max(p.length, p2 && p2.length || 0);
        }
      };
      var fixM = function(path1, path23, a1, a22, i2) {
        if (path1 && path23 && path1[i2][0] == "M" && path23[i2][0] != "M") {
          path23.splice(i2, 0, ["M", a22.x, a22.y]);
          a1.bx = 0;
          a1.by = 0;
          a1.x = path1[i2][1];
          a1.y = path1[i2][2];
          ii = Math.max(p.length, p2 && p2.length || 0);
        }
      };
      var pcoms1 = [];
      var pcoms2 = [];
      var pfirst = "";
      var pcom = "";
      for (var i = 0, ii = Math.max(p.length, p2 && p2.length || 0); i < ii; i++) {
        p[i] && (pfirst = p[i][0]);
        if (pfirst != "C") {
          pcoms1[i] = pfirst;
          i && (pcom = pcoms1[i - 1]);
        }
        p[i] = processPath(p[i], attrs, pcom);
        if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C";
        fixArc(p, i);
        if (p2) {
          p2[i] && (pfirst = p2[i][0]);
          if (pfirst != "C") {
            pcoms2[i] = pfirst;
            i && (pcom = pcoms2[i - 1]);
          }
          p2[i] = processPath(p2[i], attrs2, pcom);
          if (pcoms2[i] != "A" && pfirst == "C") {
            pcoms2[i] = "C";
          }
          fixArc(p2, i);
        }
        fixM(p, p2, attrs, attrs2, i);
        fixM(p2, p, attrs2, attrs, i);
        var seg = p[i];
        var seg2 = p2 && p2[i];
        var seglen = seg.length;
        var seg2len = p2 && seg2.length;
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
        attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
        attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
        attrs2.x = p2 && seg2[seg2len - 2];
        attrs2.y = p2 && seg2[seg2len - 1];
      }
      if (!p2) {
        pth.curve = pathClone(p);
      }
      return p2 ? [p, p2] : p;
    }
    function catmullRom2bezier(crp, z) {
      var d = [];
      for (var i = 0, c6 = crp.length; c6 - 2 * !z > i; i += 2) {
        var p = [
          { x: +crp[i - 2], y: +crp[i - 1] },
          { x: +crp[i], y: +crp[i + 1] },
          { x: +crp[i + 2], y: +crp[i + 3] },
          { x: +crp[i + 4], y: +crp[i + 5] }
        ];
        if (z) {
          if (!i) {
            p[0] = { x: +crp[c6 - 2], y: +crp[c6 - 1] };
          } else if (c6 - 4 == i) {
            p[3] = { x: +crp[0], y: +crp[1] };
          } else if (c6 - 2 == i) {
            p[2] = { x: +crp[0], y: +crp[1] };
            p[3] = { x: +crp[2], y: +crp[3] };
          }
        } else {
          if (c6 - 4 == i) {
            p[3] = p[2];
          } else if (!i) {
            p[0] = { x: +crp[i], y: +crp[i + 1] };
          }
        }
        d.push([
          "C",
          (-p[0].x + 6 * p[1].x + p[2].x) / 6,
          (-p[0].y + 6 * p[1].y + p[2].y) / 6,
          (p[1].x + 6 * p[2].x - p[3].x) / 6,
          (p[1].y + 6 * p[2].y - p[3].y) / 6,
          p[2].x,
          p[2].y
        ]);
      }
      return d;
    }
    var pointInSvgPath2 = (path3, x4, y4) => {
      const bbox = pathBBox(path3);
      if (!isPointInsideBBox(bbox, x4, y4)) {
        return false;
      }
      if (interPathHelper(path3, [["M", x4, y4], ["H", bbox.x2 + 10]], 1) % 2 !== 1) {
        return false;
      }
      return true;
    };
    var getPointsAndIntersectingPaths = (paths2, points) => {
      const pathBBoxes = paths2.map(({ id: id2, data }) => ({ id: id2, data, bbox: pathBBox(data) }));
      return points.map(({ id: pointId, x: x4, y: y4 }) => {
        const intersectingPathIds = pathBBoxes.filter(({ data, bbox }) => {
          if (!isPointInsideBBox(bbox, x4, y4)) {
            return false;
          }
          if (interPathHelper(data, [["M", x4, y4], ["H", bbox.x2 + 10]], 1) % 2 !== 1) {
            return false;
          }
          return true;
        }).map(({ id: id2 }) => id2);
        return { pointId, x: x4, y: y4, intersectingPathIds };
      });
    };
    module.exports = {
      pointInSvgPath: pointInSvgPath2,
      getPointsAndIntersectingPaths
    };
  }
});

// node_modules/webcola/dist/src/powergraph.js
var require_powergraph = __commonJS({
  "node_modules/webcola/dist/src/powergraph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PowerEdge = /* @__PURE__ */ function() {
      function PowerEdge2(source, target, type2) {
        this.source = source;
        this.target = target;
        this.type = type2;
      }
      return PowerEdge2;
    }();
    exports.PowerEdge = PowerEdge;
    var Configuration = function() {
      function Configuration2(n, edges, linkAccessor, rootGroup) {
        var _this = this;
        this.linkAccessor = linkAccessor;
        this.modules = new Array(n);
        this.roots = [];
        if (rootGroup) {
          this.initModulesFromGroup(rootGroup);
        } else {
          this.roots.push(new ModuleSet());
          for (var i = 0; i < n; ++i)
            this.roots[0].add(this.modules[i] = new Module(i));
        }
        this.R = edges.length;
        edges.forEach(function(e) {
          var s2 = _this.modules[linkAccessor.getSourceIndex(e)], t = _this.modules[linkAccessor.getTargetIndex(e)], type2 = linkAccessor.getType(e);
          s2.outgoing.add(type2, t);
          t.incoming.add(type2, s2);
        });
      }
      Configuration2.prototype.initModulesFromGroup = function(group2) {
        var moduleSet = new ModuleSet();
        this.roots.push(moduleSet);
        for (var i = 0; i < group2.leaves.length; ++i) {
          var node = group2.leaves[i];
          var module2 = new Module(node.id);
          this.modules[node.id] = module2;
          moduleSet.add(module2);
        }
        if (group2.groups) {
          for (var j = 0; j < group2.groups.length; ++j) {
            var child = group2.groups[j];
            var definition = {};
            for (var prop in child)
              if (prop !== "leaves" && prop !== "groups" && child.hasOwnProperty(prop))
                definition[prop] = child[prop];
            moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));
          }
        }
        return moduleSet;
      };
      Configuration2.prototype.merge = function(a4, b, k2) {
        if (k2 === void 0) {
          k2 = 0;
        }
        var inInt = a4.incoming.intersection(b.incoming), outInt = a4.outgoing.intersection(b.outgoing);
        var children2 = new ModuleSet();
        children2.add(a4);
        children2.add(b);
        var m3 = new Module(this.modules.length, outInt, inInt, children2);
        this.modules.push(m3);
        var update2 = function(s2, i, o) {
          s2.forAll(function(ms, linktype) {
            ms.forAll(function(n) {
              var nls = n[i];
              nls.add(linktype, m3);
              nls.remove(linktype, a4);
              nls.remove(linktype, b);
              a4[o].remove(linktype, n);
              b[o].remove(linktype, n);
            });
          });
        };
        update2(outInt, "incoming", "outgoing");
        update2(inInt, "outgoing", "incoming");
        this.R -= inInt.count() + outInt.count();
        this.roots[k2].remove(a4);
        this.roots[k2].remove(b);
        this.roots[k2].add(m3);
        return m3;
      };
      Configuration2.prototype.rootMerges = function(k2) {
        if (k2 === void 0) {
          k2 = 0;
        }
        var rs = this.roots[k2].modules();
        var n = rs.length;
        var merges = new Array(n * (n - 1));
        var ctr = 0;
        for (var i = 0, i_ = n - 1; i < i_; ++i) {
          for (var j = i + 1; j < n; ++j) {
            var a4 = rs[i], b = rs[j];
            merges[ctr] = { id: ctr, nEdges: this.nEdges(a4, b), a: a4, b };
            ctr++;
          }
        }
        return merges;
      };
      Configuration2.prototype.greedyMerge = function() {
        for (var i = 0; i < this.roots.length; ++i) {
          if (this.roots[i].modules().length < 2)
            continue;
          var ms = this.rootMerges(i).sort(function(a4, b) {
            return a4.nEdges == b.nEdges ? a4.id - b.id : a4.nEdges - b.nEdges;
          });
          var m3 = ms[0];
          if (m3.nEdges >= this.R)
            continue;
          this.merge(m3.a, m3.b, i);
          return true;
        }
      };
      Configuration2.prototype.nEdges = function(a4, b) {
        var inInt = a4.incoming.intersection(b.incoming), outInt = a4.outgoing.intersection(b.outgoing);
        return this.R - inInt.count() - outInt.count();
      };
      Configuration2.prototype.getGroupHierarchy = function(retargetedEdges) {
        var _this = this;
        var groups2 = [];
        var root3 = {};
        toGroups(this.roots[0], root3, groups2);
        var es = this.allEdges();
        es.forEach(function(e) {
          var a4 = _this.modules[e.source];
          var b = _this.modules[e.target];
          retargetedEdges.push(new PowerEdge(typeof a4.gid === "undefined" ? e.source : groups2[a4.gid], typeof b.gid === "undefined" ? e.target : groups2[b.gid], e.type));
        });
        return groups2;
      };
      Configuration2.prototype.allEdges = function() {
        var es = [];
        Configuration2.getEdges(this.roots[0], es);
        return es;
      };
      Configuration2.getEdges = function(modules, es) {
        modules.forAll(function(m3) {
          m3.getEdges(es);
          Configuration2.getEdges(m3.children, es);
        });
      };
      return Configuration2;
    }();
    exports.Configuration = Configuration;
    function toGroups(modules, group2, groups2) {
      modules.forAll(function(m3) {
        if (m3.isLeaf()) {
          if (!group2.leaves)
            group2.leaves = [];
          group2.leaves.push(m3.id);
        } else {
          var g = group2;
          m3.gid = groups2.length;
          if (!m3.isIsland() || m3.isPredefined()) {
            g = { id: m3.gid };
            if (m3.isPredefined())
              for (var prop in m3.definition)
                g[prop] = m3.definition[prop];
            if (!group2.groups)
              group2.groups = [];
            group2.groups.push(m3.gid);
            groups2.push(g);
          }
          toGroups(m3.children, g, groups2);
        }
      });
    }
    var Module = function() {
      function Module2(id2, outgoing, incoming, children2, definition) {
        if (outgoing === void 0) {
          outgoing = new LinkSets();
        }
        if (incoming === void 0) {
          incoming = new LinkSets();
        }
        if (children2 === void 0) {
          children2 = new ModuleSet();
        }
        this.id = id2;
        this.outgoing = outgoing;
        this.incoming = incoming;
        this.children = children2;
        this.definition = definition;
      }
      Module2.prototype.getEdges = function(es) {
        var _this = this;
        this.outgoing.forAll(function(ms, edgetype) {
          ms.forAll(function(target) {
            es.push(new PowerEdge(_this.id, target.id, edgetype));
          });
        });
      };
      Module2.prototype.isLeaf = function() {
        return this.children.count() === 0;
      };
      Module2.prototype.isIsland = function() {
        return this.outgoing.count() === 0 && this.incoming.count() === 0;
      };
      Module2.prototype.isPredefined = function() {
        return typeof this.definition !== "undefined";
      };
      return Module2;
    }();
    exports.Module = Module;
    function intersection2(m3, n) {
      var i = {};
      for (var v2 in m3)
        if (v2 in n)
          i[v2] = m3[v2];
      return i;
    }
    var ModuleSet = function() {
      function ModuleSet2() {
        this.table = {};
      }
      ModuleSet2.prototype.count = function() {
        return Object.keys(this.table).length;
      };
      ModuleSet2.prototype.intersection = function(other) {
        var result = new ModuleSet2();
        result.table = intersection2(this.table, other.table);
        return result;
      };
      ModuleSet2.prototype.intersectionCount = function(other) {
        return this.intersection(other).count();
      };
      ModuleSet2.prototype.contains = function(id2) {
        return id2 in this.table;
      };
      ModuleSet2.prototype.add = function(m3) {
        this.table[m3.id] = m3;
      };
      ModuleSet2.prototype.remove = function(m3) {
        delete this.table[m3.id];
      };
      ModuleSet2.prototype.forAll = function(f) {
        for (var mid in this.table) {
          f(this.table[mid]);
        }
      };
      ModuleSet2.prototype.modules = function() {
        var vs = [];
        this.forAll(function(m3) {
          if (!m3.isPredefined())
            vs.push(m3);
        });
        return vs;
      };
      return ModuleSet2;
    }();
    exports.ModuleSet = ModuleSet;
    var LinkSets = function() {
      function LinkSets2() {
        this.sets = {};
        this.n = 0;
      }
      LinkSets2.prototype.count = function() {
        return this.n;
      };
      LinkSets2.prototype.contains = function(id2) {
        var result = false;
        this.forAllModules(function(m3) {
          if (!result && m3.id == id2) {
            result = true;
          }
        });
        return result;
      };
      LinkSets2.prototype.add = function(linktype, m3) {
        var s2 = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();
        s2.add(m3);
        ++this.n;
      };
      LinkSets2.prototype.remove = function(linktype, m3) {
        var ms = this.sets[linktype];
        ms.remove(m3);
        if (ms.count() === 0) {
          delete this.sets[linktype];
        }
        --this.n;
      };
      LinkSets2.prototype.forAll = function(f) {
        for (var linktype in this.sets) {
          f(this.sets[linktype], Number(linktype));
        }
      };
      LinkSets2.prototype.forAllModules = function(f) {
        this.forAll(function(ms, lt) {
          return ms.forAll(f);
        });
      };
      LinkSets2.prototype.intersection = function(other) {
        var result = new LinkSets2();
        this.forAll(function(ms, lt) {
          if (lt in other.sets) {
            var i = ms.intersection(other.sets[lt]), n = i.count();
            if (n > 0) {
              result.sets[lt] = i;
              result.n += n;
            }
          }
        });
        return result;
      };
      return LinkSets2;
    }();
    exports.LinkSets = LinkSets;
    function getGroups(nodes, links, la, rootGroup) {
      var n = nodes.length, c6 = new Configuration(n, links, la, rootGroup);
      while (c6.greedyMerge())
        ;
      var powerEdges = [];
      var g = c6.getGroupHierarchy(powerEdges);
      powerEdges.forEach(function(e) {
        var f = function(end2) {
          var g2 = e[end2];
          if (typeof g2 == "number")
            e[end2] = nodes[g2];
        };
        f("source");
        f("target");
      });
      return { groups: g, powerEdges };
    }
    exports.getGroups = getGroups;
  }
});

// node_modules/webcola/dist/src/linklengths.js
var require_linklengths = __commonJS({
  "node_modules/webcola/dist/src/linklengths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function unionCount(a4, b) {
      var u4 = {};
      for (var i in a4)
        u4[i] = {};
      for (var i in b)
        u4[i] = {};
      return Object.keys(u4).length;
    }
    function intersectionCount(a4, b) {
      var n = 0;
      for (var i in a4)
        if (typeof b[i] !== "undefined")
          ++n;
      return n;
    }
    function getNeighbours(links, la) {
      var neighbours = {};
      var addNeighbours = function(u4, v2) {
        if (typeof neighbours[u4] === "undefined")
          neighbours[u4] = {};
        neighbours[u4][v2] = {};
      };
      links.forEach(function(e) {
        var u4 = la.getSourceIndex(e), v2 = la.getTargetIndex(e);
        addNeighbours(u4, v2);
        addNeighbours(v2, u4);
      });
      return neighbours;
    }
    function computeLinkLengths(links, w, f, la) {
      var neighbours = getNeighbours(links, la);
      links.forEach(function(l) {
        var a4 = neighbours[la.getSourceIndex(l)];
        var b = neighbours[la.getTargetIndex(l)];
        la.setLength(l, 1 + w * f(a4, b));
      });
    }
    function symmetricDiffLinkLengths(links, la, w) {
      if (w === void 0) {
        w = 1;
      }
      computeLinkLengths(links, w, function(a4, b) {
        return Math.sqrt(unionCount(a4, b) - intersectionCount(a4, b));
      }, la);
    }
    exports.symmetricDiffLinkLengths = symmetricDiffLinkLengths;
    function jaccardLinkLengths(links, la, w) {
      if (w === void 0) {
        w = 1;
      }
      computeLinkLengths(links, w, function(a4, b) {
        return Math.min(Object.keys(a4).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a4, b) / unionCount(a4, b);
      }, la);
    }
    exports.jaccardLinkLengths = jaccardLinkLengths;
    function generateDirectedEdgeConstraints(n, links, axis2, la) {
      var components = stronglyConnectedComponents(n, links, la);
      var nodes = {};
      components.forEach(function(c6, i) {
        return c6.forEach(function(v2) {
          return nodes[v2] = i;
        });
      });
      var constraints = [];
      links.forEach(function(l) {
        var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u4 = nodes[ui], v2 = nodes[vi];
        if (u4 !== v2) {
          constraints.push({
            axis: axis2,
            left: ui,
            right: vi,
            gap: la.getMinSeparation(l)
          });
        }
      });
      return constraints;
    }
    exports.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;
    function stronglyConnectedComponents(numVertices, edges, la) {
      var nodes = [];
      var index4 = 0;
      var stack = [];
      var components = [];
      function strongConnect(v3) {
        v3.index = v3.lowlink = index4++;
        stack.push(v3);
        v3.onStack = true;
        for (var _i2 = 0, _a3 = v3.out; _i2 < _a3.length; _i2++) {
          var w2 = _a3[_i2];
          if (typeof w2.index === "undefined") {
            strongConnect(w2);
            v3.lowlink = Math.min(v3.lowlink, w2.lowlink);
          } else if (w2.onStack) {
            v3.lowlink = Math.min(v3.lowlink, w2.index);
          }
        }
        if (v3.lowlink === v3.index) {
          var component = [];
          while (stack.length) {
            w2 = stack.pop();
            w2.onStack = false;
            component.push(w2);
            if (w2 === v3)
              break;
          }
          components.push(component.map(function(v4) {
            return v4.id;
          }));
        }
      }
      for (var i = 0; i < numVertices; i++) {
        nodes.push({ id: i, out: [] });
      }
      for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {
        var e = edges_1[_i];
        var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];
        v_1.out.push(w);
      }
      for (var _a2 = 0, nodes_1 = nodes; _a2 < nodes_1.length; _a2++) {
        var v2 = nodes_1[_a2];
        if (typeof v2.index === "undefined")
          strongConnect(v2);
      }
      return components;
    }
    exports.stronglyConnectedComponents = stronglyConnectedComponents;
  }
});

// node_modules/webcola/dist/src/descent.js
var require_descent = __commonJS({
  "node_modules/webcola/dist/src/descent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Locks = function() {
      function Locks2() {
        this.locks = {};
      }
      Locks2.prototype.add = function(id2, x4) {
        this.locks[id2] = x4;
      };
      Locks2.prototype.clear = function() {
        this.locks = {};
      };
      Locks2.prototype.isEmpty = function() {
        for (var l in this.locks)
          return false;
        return true;
      };
      Locks2.prototype.apply = function(f) {
        for (var l in this.locks) {
          f(Number(l), this.locks[l]);
        }
      };
      return Locks2;
    }();
    exports.Locks = Locks;
    var Descent = function() {
      function Descent2(x4, D3, G) {
        if (G === void 0) {
          G = null;
        }
        this.D = D3;
        this.G = G;
        this.threshold = 1e-4;
        this.numGridSnapNodes = 0;
        this.snapGridSize = 100;
        this.snapStrength = 1e3;
        this.scaleSnapByMaxH = false;
        this.random = new PseudoRandom();
        this.project = null;
        this.x = x4;
        this.k = x4.length;
        var n = this.n = x4[0].length;
        this.H = new Array(this.k);
        this.g = new Array(this.k);
        this.Hd = new Array(this.k);
        this.a = new Array(this.k);
        this.b = new Array(this.k);
        this.c = new Array(this.k);
        this.d = new Array(this.k);
        this.e = new Array(this.k);
        this.ia = new Array(this.k);
        this.ib = new Array(this.k);
        this.xtmp = new Array(this.k);
        this.locks = new Locks();
        this.minD = Number.MAX_VALUE;
        var i = n, j;
        while (i--) {
          j = n;
          while (--j > i) {
            var d = D3[i][j];
            if (d > 0 && d < this.minD) {
              this.minD = d;
            }
          }
        }
        if (this.minD === Number.MAX_VALUE)
          this.minD = 1;
        i = this.k;
        while (i--) {
          this.g[i] = new Array(n);
          this.H[i] = new Array(n);
          j = n;
          while (j--) {
            this.H[i][j] = new Array(n);
          }
          this.Hd[i] = new Array(n);
          this.a[i] = new Array(n);
          this.b[i] = new Array(n);
          this.c[i] = new Array(n);
          this.d[i] = new Array(n);
          this.e[i] = new Array(n);
          this.ia[i] = new Array(n);
          this.ib[i] = new Array(n);
          this.xtmp[i] = new Array(n);
        }
      }
      Descent2.createSquareMatrix = function(n, f) {
        var M2 = new Array(n);
        for (var i = 0; i < n; ++i) {
          M2[i] = new Array(n);
          for (var j = 0; j < n; ++j) {
            M2[i][j] = f(i, j);
          }
        }
        return M2;
      };
      Descent2.prototype.offsetDir = function() {
        var _this = this;
        var u4 = new Array(this.k);
        var l = 0;
        for (var i = 0; i < this.k; ++i) {
          var x4 = u4[i] = this.random.getNextBetween(0.01, 1) - 0.5;
          l += x4 * x4;
        }
        l = Math.sqrt(l);
        return u4.map(function(x5) {
          return x5 *= _this.minD / l;
        });
      };
      Descent2.prototype.computeDerivatives = function(x4) {
        var _this = this;
        var n = this.n;
        if (n < 1)
          return;
        var i;
        var d = new Array(this.k);
        var d2 = new Array(this.k);
        var Huu = new Array(this.k);
        var maxH = 0;
        for (var u4 = 0; u4 < n; ++u4) {
          for (i = 0; i < this.k; ++i)
            Huu[i] = this.g[i][u4] = 0;
          for (var v2 = 0; v2 < n; ++v2) {
            if (u4 === v2)
              continue;
            var maxDisplaces = n;
            while (maxDisplaces--) {
              var sd2 = 0;
              for (i = 0; i < this.k; ++i) {
                var dx = d[i] = x4[i][u4] - x4[i][v2];
                sd2 += d2[i] = dx * dx;
              }
              if (sd2 > 1e-9)
                break;
              var rd = this.offsetDir();
              for (i = 0; i < this.k; ++i)
                x4[i][v2] += rd[i];
            }
            var l = Math.sqrt(sd2);
            var D3 = this.D[u4][v2];
            var weight = this.G != null ? this.G[u4][v2] : 1;
            if (weight > 1 && l > D3 || !isFinite(D3)) {
              for (i = 0; i < this.k; ++i)
                this.H[i][u4][v2] = 0;
              continue;
            }
            if (weight > 1) {
              weight = 1;
            }
            var D22 = D3 * D3;
            var gs = 2 * weight * (l - D3) / (D22 * l);
            var l3 = l * l * l;
            var hs = 2 * -weight / (D22 * l3);
            if (!isFinite(gs))
              console.log(gs);
            for (i = 0; i < this.k; ++i) {
              this.g[i][u4] += d[i] * gs;
              Huu[i] -= this.H[i][u4][v2] = hs * (l3 + D3 * (d2[i] - sd2) + l * sd2);
            }
          }
          for (i = 0; i < this.k; ++i)
            maxH = Math.max(maxH, this.H[i][u4][u4] = Huu[i]);
        }
        var r = this.snapGridSize / 2;
        var g = this.snapGridSize;
        var w = this.snapStrength;
        var k2 = w / (r * r);
        var numNodes = this.numGridSnapNodes;
        for (var u4 = 0; u4 < numNodes; ++u4) {
          for (i = 0; i < this.k; ++i) {
            var xiu = this.x[i][u4];
            var m3 = xiu / g;
            var f = m3 % 1;
            var q = m3 - f;
            var a4 = Math.abs(f);
            var dx = a4 <= 0.5 ? xiu - q * g : xiu > 0 ? xiu - (q + 1) * g : xiu - (q - 1) * g;
            if (-r < dx && dx <= r) {
              if (this.scaleSnapByMaxH) {
                this.g[i][u4] += maxH * k2 * dx;
                this.H[i][u4][u4] += maxH * k2;
              } else {
                this.g[i][u4] += k2 * dx;
                this.H[i][u4][u4] += k2;
              }
            }
          }
        }
        if (!this.locks.isEmpty()) {
          this.locks.apply(function(u5, p) {
            for (i = 0; i < _this.k; ++i) {
              _this.H[i][u5][u5] += maxH;
              _this.g[i][u5] -= maxH * (p[i] - x4[i][u5]);
            }
          });
        }
      };
      Descent2.dotProd = function(a4, b) {
        var x4 = 0, i = a4.length;
        while (i--)
          x4 += a4[i] * b[i];
        return x4;
      };
      Descent2.rightMultiply = function(m3, v2, r) {
        var i = m3.length;
        while (i--)
          r[i] = Descent2.dotProd(m3[i], v2);
      };
      Descent2.prototype.computeStepSize = function(d) {
        var numerator = 0, denominator = 0;
        for (var i = 0; i < this.k; ++i) {
          numerator += Descent2.dotProd(this.g[i], d[i]);
          Descent2.rightMultiply(this.H[i], d[i], this.Hd[i]);
          denominator += Descent2.dotProd(d[i], this.Hd[i]);
        }
        if (denominator === 0 || !isFinite(denominator))
          return 0;
        return 1 * numerator / denominator;
      };
      Descent2.prototype.reduceStress = function() {
        this.computeDerivatives(this.x);
        var alpha = this.computeStepSize(this.g);
        for (var i = 0; i < this.k; ++i) {
          this.takeDescentStep(this.x[i], this.g[i], alpha);
        }
        return this.computeStress();
      };
      Descent2.copy = function(a4, b) {
        var m3 = a4.length, n = b[0].length;
        for (var i = 0; i < m3; ++i) {
          for (var j = 0; j < n; ++j) {
            b[i][j] = a4[i][j];
          }
        }
      };
      Descent2.prototype.stepAndProject = function(x06, r, d, stepSize) {
        Descent2.copy(x06, r);
        this.takeDescentStep(r[0], d[0], stepSize);
        if (this.project)
          this.project[0](x06[0], x06[1], r[0]);
        this.takeDescentStep(r[1], d[1], stepSize);
        if (this.project)
          this.project[1](r[0], x06[1], r[1]);
        for (var i = 2; i < this.k; i++)
          this.takeDescentStep(r[i], d[i], stepSize);
      };
      Descent2.mApply = function(m3, n, f) {
        var i = m3;
        while (i-- > 0) {
          var j = n;
          while (j-- > 0)
            f(i, j);
        }
      };
      Descent2.prototype.matrixApply = function(f) {
        Descent2.mApply(this.k, this.n, f);
      };
      Descent2.prototype.computeNextPosition = function(x06, r) {
        var _this = this;
        this.computeDerivatives(x06);
        var alpha = this.computeStepSize(this.g);
        this.stepAndProject(x06, r, this.g, alpha);
        if (this.project) {
          this.matrixApply(function(i, j) {
            return _this.e[i][j] = x06[i][j] - r[i][j];
          });
          var beta = this.computeStepSize(this.e);
          beta = Math.max(0.2, Math.min(beta, 1));
          this.stepAndProject(x06, r, this.e, beta);
        }
      };
      Descent2.prototype.run = function(iterations2) {
        var stress = Number.MAX_VALUE, converged = false;
        while (!converged && iterations2-- > 0) {
          var s2 = this.rungeKutta();
          converged = Math.abs(stress / s2 - 1) < this.threshold;
          stress = s2;
        }
        return stress;
      };
      Descent2.prototype.rungeKutta = function() {
        var _this = this;
        this.computeNextPosition(this.x, this.a);
        Descent2.mid(this.x, this.a, this.ia);
        this.computeNextPosition(this.ia, this.b);
        Descent2.mid(this.x, this.b, this.ib);
        this.computeNextPosition(this.ib, this.c);
        this.computeNextPosition(this.c, this.d);
        var disp = 0;
        this.matrixApply(function(i, j) {
          var x4 = (_this.a[i][j] + 2 * _this.b[i][j] + 2 * _this.c[i][j] + _this.d[i][j]) / 6, d = _this.x[i][j] - x4;
          disp += d * d;
          _this.x[i][j] = x4;
        });
        return disp;
      };
      Descent2.mid = function(a4, b, m3) {
        Descent2.mApply(a4.length, a4[0].length, function(i, j) {
          return m3[i][j] = a4[i][j] + (b[i][j] - a4[i][j]) / 2;
        });
      };
      Descent2.prototype.takeDescentStep = function(x4, d, stepSize) {
        for (var i = 0; i < this.n; ++i) {
          x4[i] = x4[i] - stepSize * d[i];
        }
      };
      Descent2.prototype.computeStress = function() {
        var stress = 0;
        for (var u4 = 0, nMinus1 = this.n - 1; u4 < nMinus1; ++u4) {
          for (var v2 = u4 + 1, n = this.n; v2 < n; ++v2) {
            var l = 0;
            for (var i = 0; i < this.k; ++i) {
              var dx = this.x[i][u4] - this.x[i][v2];
              l += dx * dx;
            }
            l = Math.sqrt(l);
            var d = this.D[u4][v2];
            if (!isFinite(d))
              continue;
            var rl = d - l;
            var d2 = d * d;
            stress += rl * rl / d2;
          }
        }
        return stress;
      };
      Descent2.zeroDistance = 1e-10;
      return Descent2;
    }();
    exports.Descent = Descent;
    var PseudoRandom = function() {
      function PseudoRandom2(seed) {
        if (seed === void 0) {
          seed = 1;
        }
        this.seed = seed;
        this.a = 214013;
        this.c = 2531011;
        this.m = 2147483648;
        this.range = 32767;
      }
      PseudoRandom2.prototype.getNext = function() {
        this.seed = (this.seed * this.a + this.c) % this.m;
        return (this.seed >> 16) / this.range;
      };
      PseudoRandom2.prototype.getNextBetween = function(min4, max5) {
        return min4 + this.getNext() * (max5 - min4);
      };
      return PseudoRandom2;
    }();
    exports.PseudoRandom = PseudoRandom;
  }
});

// node_modules/webcola/dist/src/vpsc.js
var require_vpsc = __commonJS({
  "node_modules/webcola/dist/src/vpsc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PositionStats = function() {
      function PositionStats2(scale2) {
        this.scale = scale2;
        this.AB = 0;
        this.AD = 0;
        this.A2 = 0;
      }
      PositionStats2.prototype.addVariable = function(v2) {
        var ai = this.scale / v2.scale;
        var bi = v2.offset / v2.scale;
        var wi = v2.weight;
        this.AB += wi * ai * bi;
        this.AD += wi * ai * v2.desiredPosition;
        this.A2 += wi * ai * ai;
      };
      PositionStats2.prototype.getPosn = function() {
        return (this.AD - this.AB) / this.A2;
      };
      return PositionStats2;
    }();
    exports.PositionStats = PositionStats;
    var Constraint = function() {
      function Constraint2(left3, right3, gap, equality) {
        if (equality === void 0) {
          equality = false;
        }
        this.left = left3;
        this.right = right3;
        this.gap = gap;
        this.equality = equality;
        this.active = false;
        this.unsatisfiable = false;
        this.left = left3;
        this.right = right3;
        this.gap = gap;
        this.equality = equality;
      }
      Constraint2.prototype.slack = function() {
        return this.unsatisfiable ? Number.MAX_VALUE : this.right.scale * this.right.position() - this.gap - this.left.scale * this.left.position();
      };
      return Constraint2;
    }();
    exports.Constraint = Constraint;
    var Variable = function() {
      function Variable2(desiredPosition, weight, scale2) {
        if (weight === void 0) {
          weight = 1;
        }
        if (scale2 === void 0) {
          scale2 = 1;
        }
        this.desiredPosition = desiredPosition;
        this.weight = weight;
        this.scale = scale2;
        this.offset = 0;
      }
      Variable2.prototype.dfdv = function() {
        return 2 * this.weight * (this.position() - this.desiredPosition);
      };
      Variable2.prototype.position = function() {
        return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;
      };
      Variable2.prototype.visitNeighbours = function(prev, f) {
        var ff = function(c6, next) {
          return c6.active && prev !== next && f(c6, next);
        };
        this.cOut.forEach(function(c6) {
          return ff(c6, c6.right);
        });
        this.cIn.forEach(function(c6) {
          return ff(c6, c6.left);
        });
      };
      return Variable2;
    }();
    exports.Variable = Variable;
    var Block = function() {
      function Block2(v2) {
        this.vars = [];
        v2.offset = 0;
        this.ps = new PositionStats(v2.scale);
        this.addVariable(v2);
      }
      Block2.prototype.addVariable = function(v2) {
        v2.block = this;
        this.vars.push(v2);
        this.ps.addVariable(v2);
        this.posn = this.ps.getPosn();
      };
      Block2.prototype.updateWeightedPosition = function() {
        this.ps.AB = this.ps.AD = this.ps.A2 = 0;
        for (var i = 0, n = this.vars.length; i < n; ++i)
          this.ps.addVariable(this.vars[i]);
        this.posn = this.ps.getPosn();
      };
      Block2.prototype.compute_lm = function(v2, u4, postAction) {
        var _this = this;
        var dfdv = v2.dfdv();
        v2.visitNeighbours(u4, function(c6, next) {
          var _dfdv = _this.compute_lm(next, v2, postAction);
          if (next === c6.right) {
            dfdv += _dfdv * c6.left.scale;
            c6.lm = _dfdv;
          } else {
            dfdv += _dfdv * c6.right.scale;
            c6.lm = -_dfdv;
          }
          postAction(c6);
        });
        return dfdv / v2.scale;
      };
      Block2.prototype.populateSplitBlock = function(v2, prev) {
        var _this = this;
        v2.visitNeighbours(prev, function(c6, next) {
          next.offset = v2.offset + (next === c6.right ? c6.gap : -c6.gap);
          _this.addVariable(next);
          _this.populateSplitBlock(next, v2);
        });
      };
      Block2.prototype.traverse = function(visit, acc, v2, prev) {
        var _this = this;
        if (v2 === void 0) {
          v2 = this.vars[0];
        }
        if (prev === void 0) {
          prev = null;
        }
        v2.visitNeighbours(prev, function(c6, next) {
          acc.push(visit(c6));
          _this.traverse(visit, acc, next, v2);
        });
      };
      Block2.prototype.findMinLM = function() {
        var m3 = null;
        this.compute_lm(this.vars[0], null, function(c6) {
          if (!c6.equality && (m3 === null || c6.lm < m3.lm))
            m3 = c6;
        });
        return m3;
      };
      Block2.prototype.findMinLMBetween = function(lv, rv) {
        this.compute_lm(lv, null, function() {
        });
        var m3 = null;
        this.findPath(lv, null, rv, function(c6, next) {
          if (!c6.equality && c6.right === next && (m3 === null || c6.lm < m3.lm))
            m3 = c6;
        });
        return m3;
      };
      Block2.prototype.findPath = function(v2, prev, to, visit) {
        var _this = this;
        var endFound = false;
        v2.visitNeighbours(prev, function(c6, next) {
          if (!endFound && (next === to || _this.findPath(next, v2, to, visit))) {
            endFound = true;
            visit(c6, next);
          }
        });
        return endFound;
      };
      Block2.prototype.isActiveDirectedPathBetween = function(u4, v2) {
        if (u4 === v2)
          return true;
        var i = u4.cOut.length;
        while (i--) {
          var c6 = u4.cOut[i];
          if (c6.active && this.isActiveDirectedPathBetween(c6.right, v2))
            return true;
        }
        return false;
      };
      Block2.split = function(c6) {
        c6.active = false;
        return [Block2.createSplitBlock(c6.left), Block2.createSplitBlock(c6.right)];
      };
      Block2.createSplitBlock = function(startVar) {
        var b = new Block2(startVar);
        b.populateSplitBlock(startVar, null);
        return b;
      };
      Block2.prototype.splitBetween = function(vl, vr) {
        var c6 = this.findMinLMBetween(vl, vr);
        if (c6 !== null) {
          var bs = Block2.split(c6);
          return { constraint: c6, lb: bs[0], rb: bs[1] };
        }
        return null;
      };
      Block2.prototype.mergeAcross = function(b, c6, dist2) {
        c6.active = true;
        for (var i = 0, n = b.vars.length; i < n; ++i) {
          var v2 = b.vars[i];
          v2.offset += dist2;
          this.addVariable(v2);
        }
        this.posn = this.ps.getPosn();
      };
      Block2.prototype.cost = function() {
        var sum4 = 0, i = this.vars.length;
        while (i--) {
          var v2 = this.vars[i], d = v2.position() - v2.desiredPosition;
          sum4 += d * d * v2.weight;
        }
        return sum4;
      };
      return Block2;
    }();
    exports.Block = Block;
    var Blocks = function() {
      function Blocks2(vs) {
        this.vs = vs;
        var n = vs.length;
        this.list = new Array(n);
        while (n--) {
          var b = new Block(vs[n]);
          this.list[n] = b;
          b.blockInd = n;
        }
      }
      Blocks2.prototype.cost = function() {
        var sum4 = 0, i = this.list.length;
        while (i--)
          sum4 += this.list[i].cost();
        return sum4;
      };
      Blocks2.prototype.insert = function(b) {
        b.blockInd = this.list.length;
        this.list.push(b);
      };
      Blocks2.prototype.remove = function(b) {
        var last = this.list.length - 1;
        var swapBlock = this.list[last];
        this.list.length = last;
        if (b !== swapBlock) {
          this.list[b.blockInd] = swapBlock;
          swapBlock.blockInd = b.blockInd;
        }
      };
      Blocks2.prototype.merge = function(c6) {
        var l = c6.left.block, r = c6.right.block;
        var dist2 = c6.right.offset - c6.left.offset - c6.gap;
        if (l.vars.length < r.vars.length) {
          r.mergeAcross(l, c6, dist2);
          this.remove(l);
        } else {
          l.mergeAcross(r, c6, -dist2);
          this.remove(r);
        }
      };
      Blocks2.prototype.forEach = function(f) {
        this.list.forEach(f);
      };
      Blocks2.prototype.updateBlockPositions = function() {
        this.list.forEach(function(b) {
          return b.updateWeightedPosition();
        });
      };
      Blocks2.prototype.split = function(inactive) {
        var _this = this;
        this.updateBlockPositions();
        this.list.forEach(function(b) {
          var v2 = b.findMinLM();
          if (v2 !== null && v2.lm < Solver.LAGRANGIAN_TOLERANCE) {
            b = v2.left.block;
            Block.split(v2).forEach(function(nb) {
              return _this.insert(nb);
            });
            _this.remove(b);
            inactive.push(v2);
          }
        });
      };
      return Blocks2;
    }();
    exports.Blocks = Blocks;
    var Solver = function() {
      function Solver2(vs, cs) {
        this.vs = vs;
        this.cs = cs;
        this.vs = vs;
        vs.forEach(function(v2) {
          v2.cIn = [], v2.cOut = [];
        });
        this.cs = cs;
        cs.forEach(function(c6) {
          c6.left.cOut.push(c6);
          c6.right.cIn.push(c6);
        });
        this.inactive = cs.map(function(c6) {
          c6.active = false;
          return c6;
        });
        this.bs = null;
      }
      Solver2.prototype.cost = function() {
        return this.bs.cost();
      };
      Solver2.prototype.setStartingPositions = function(ps) {
        this.inactive = this.cs.map(function(c6) {
          c6.active = false;
          return c6;
        });
        this.bs = new Blocks(this.vs);
        this.bs.forEach(function(b, i) {
          return b.posn = ps[i];
        });
      };
      Solver2.prototype.setDesiredPositions = function(ps) {
        this.vs.forEach(function(v2, i) {
          return v2.desiredPosition = ps[i];
        });
      };
      Solver2.prototype.mostViolated = function() {
        var minSlack = Number.MAX_VALUE, v2 = null, l = this.inactive, n = l.length, deletePoint = n;
        for (var i = 0; i < n; ++i) {
          var c6 = l[i];
          if (c6.unsatisfiable)
            continue;
          var slack = c6.slack();
          if (c6.equality || slack < minSlack) {
            minSlack = slack;
            v2 = c6;
            deletePoint = i;
            if (c6.equality)
              break;
          }
        }
        if (deletePoint !== n && (minSlack < Solver2.ZERO_UPPERBOUND && !v2.active || v2.equality)) {
          l[deletePoint] = l[n - 1];
          l.length = n - 1;
        }
        return v2;
      };
      Solver2.prototype.satisfy = function() {
        if (this.bs == null) {
          this.bs = new Blocks(this.vs);
        }
        this.bs.split(this.inactive);
        var v2 = null;
        while ((v2 = this.mostViolated()) && (v2.equality || v2.slack() < Solver2.ZERO_UPPERBOUND && !v2.active)) {
          var lb = v2.left.block, rb = v2.right.block;
          if (lb !== rb) {
            this.bs.merge(v2);
          } else {
            if (lb.isActiveDirectedPathBetween(v2.right, v2.left)) {
              v2.unsatisfiable = true;
              continue;
            }
            var split = lb.splitBetween(v2.left, v2.right);
            if (split !== null) {
              this.bs.insert(split.lb);
              this.bs.insert(split.rb);
              this.bs.remove(lb);
              this.inactive.push(split.constraint);
            } else {
              v2.unsatisfiable = true;
              continue;
            }
            if (v2.slack() >= 0) {
              this.inactive.push(v2);
            } else {
              this.bs.merge(v2);
            }
          }
        }
      };
      Solver2.prototype.solve = function() {
        this.satisfy();
        var lastcost = Number.MAX_VALUE, cost = this.bs.cost();
        while (Math.abs(lastcost - cost) > 1e-4) {
          this.satisfy();
          lastcost = cost;
          cost = this.bs.cost();
        }
        return cost;
      };
      Solver2.LAGRANGIAN_TOLERANCE = -1e-4;
      Solver2.ZERO_UPPERBOUND = -1e-10;
      return Solver2;
    }();
    exports.Solver = Solver;
    function removeOverlapInOneDimension(spans, lowerBound, upperBound) {
      var vs = spans.map(function(s2) {
        return new Variable(s2.desiredCenter);
      });
      var cs = [];
      var n = spans.length;
      for (var i = 0; i < n - 1; i++) {
        var left3 = spans[i], right3 = spans[i + 1];
        cs.push(new Constraint(vs[i], vs[i + 1], (left3.size + right3.size) / 2));
      }
      var leftMost = vs[0], rightMost = vs[n - 1], leftMostSize = spans[0].size / 2, rightMostSize = spans[n - 1].size / 2;
      var vLower = null, vUpper = null;
      if (lowerBound) {
        vLower = new Variable(lowerBound, leftMost.weight * 1e3);
        vs.push(vLower);
        cs.push(new Constraint(vLower, leftMost, leftMostSize));
      }
      if (upperBound) {
        vUpper = new Variable(upperBound, rightMost.weight * 1e3);
        vs.push(vUpper);
        cs.push(new Constraint(rightMost, vUpper, rightMostSize));
      }
      var solver = new Solver(vs, cs);
      solver.solve();
      return {
        newCenters: vs.slice(0, spans.length).map(function(v2) {
          return v2.position();
        }),
        lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,
        upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize
      };
    }
    exports.removeOverlapInOneDimension = removeOverlapInOneDimension;
  }
});

// node_modules/webcola/dist/src/rbtree.js
var require_rbtree = __commonJS({
  "node_modules/webcola/dist/src/rbtree.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
          d2.__proto__ = b10;
        } || function(d2, b10) {
          for (var p in b10) if (b10.hasOwnProperty(p)) d2[p] = b10[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var TreeBase = function() {
      function TreeBase2() {
        this.findIter = function(data) {
          var res = this._root;
          var iter = this.iterator();
          while (res !== null) {
            var c6 = this._comparator(data, res.data);
            if (c6 === 0) {
              iter._cursor = res;
              return iter;
            } else {
              iter._ancestors.push(res);
              res = res.get_child(c6 > 0);
            }
          }
          return null;
        };
      }
      TreeBase2.prototype.clear = function() {
        this._root = null;
        this.size = 0;
      };
      ;
      TreeBase2.prototype.find = function(data) {
        var res = this._root;
        while (res !== null) {
          var c6 = this._comparator(data, res.data);
          if (c6 === 0) {
            return res.data;
          } else {
            res = res.get_child(c6 > 0);
          }
        }
        return null;
      };
      ;
      TreeBase2.prototype.lowerBound = function(data) {
        return this._bound(data, this._comparator);
      };
      ;
      TreeBase2.prototype.upperBound = function(data) {
        var cmp = this._comparator;
        function reverse_cmp(a4, b) {
          return cmp(b, a4);
        }
        return this._bound(data, reverse_cmp);
      };
      ;
      TreeBase2.prototype.min = function() {
        var res = this._root;
        if (res === null) {
          return null;
        }
        while (res.left !== null) {
          res = res.left;
        }
        return res.data;
      };
      ;
      TreeBase2.prototype.max = function() {
        var res = this._root;
        if (res === null) {
          return null;
        }
        while (res.right !== null) {
          res = res.right;
        }
        return res.data;
      };
      ;
      TreeBase2.prototype.iterator = function() {
        return new Iterator(this);
      };
      ;
      TreeBase2.prototype.each = function(cb) {
        var it = this.iterator(), data;
        while ((data = it.next()) !== null) {
          cb(data);
        }
      };
      ;
      TreeBase2.prototype.reach = function(cb) {
        var it = this.iterator(), data;
        while ((data = it.prev()) !== null) {
          cb(data);
        }
      };
      ;
      TreeBase2.prototype._bound = function(data, cmp) {
        var cur = this._root;
        var iter = this.iterator();
        while (cur !== null) {
          var c6 = this._comparator(data, cur.data);
          if (c6 === 0) {
            iter._cursor = cur;
            return iter;
          }
          iter._ancestors.push(cur);
          cur = cur.get_child(c6 > 0);
        }
        for (var i = iter._ancestors.length - 1; i >= 0; --i) {
          cur = iter._ancestors[i];
          if (cmp(data, cur.data) > 0) {
            iter._cursor = cur;
            iter._ancestors.length = i;
            return iter;
          }
        }
        iter._ancestors.length = 0;
        return iter;
      };
      ;
      return TreeBase2;
    }();
    exports.TreeBase = TreeBase;
    var Iterator = function() {
      function Iterator2(tree) {
        this._tree = tree;
        this._ancestors = [];
        this._cursor = null;
      }
      Iterator2.prototype.data = function() {
        return this._cursor !== null ? this._cursor.data : null;
      };
      ;
      Iterator2.prototype.next = function() {
        if (this._cursor === null) {
          var root3 = this._tree._root;
          if (root3 !== null) {
            this._minNode(root3);
          }
        } else {
          if (this._cursor.right === null) {
            var save;
            do {
              save = this._cursor;
              if (this._ancestors.length) {
                this._cursor = this._ancestors.pop();
              } else {
                this._cursor = null;
                break;
              }
            } while (this._cursor.right === save);
          } else {
            this._ancestors.push(this._cursor);
            this._minNode(this._cursor.right);
          }
        }
        return this._cursor !== null ? this._cursor.data : null;
      };
      ;
      Iterator2.prototype.prev = function() {
        if (this._cursor === null) {
          var root3 = this._tree._root;
          if (root3 !== null) {
            this._maxNode(root3);
          }
        } else {
          if (this._cursor.left === null) {
            var save;
            do {
              save = this._cursor;
              if (this._ancestors.length) {
                this._cursor = this._ancestors.pop();
              } else {
                this._cursor = null;
                break;
              }
            } while (this._cursor.left === save);
          } else {
            this._ancestors.push(this._cursor);
            this._maxNode(this._cursor.left);
          }
        }
        return this._cursor !== null ? this._cursor.data : null;
      };
      ;
      Iterator2.prototype._minNode = function(start3) {
        while (start3.left !== null) {
          this._ancestors.push(start3);
          start3 = start3.left;
        }
        this._cursor = start3;
      };
      ;
      Iterator2.prototype._maxNode = function(start3) {
        while (start3.right !== null) {
          this._ancestors.push(start3);
          start3 = start3.right;
        }
        this._cursor = start3;
      };
      ;
      return Iterator2;
    }();
    exports.Iterator = Iterator;
    var Node4 = function() {
      function Node5(data) {
        this.data = data;
        this.left = null;
        this.right = null;
        this.red = true;
      }
      Node5.prototype.get_child = function(dir) {
        return dir ? this.right : this.left;
      };
      ;
      Node5.prototype.set_child = function(dir, val) {
        if (dir) {
          this.right = val;
        } else {
          this.left = val;
        }
      };
      ;
      return Node5;
    }();
    var RBTree = function(_super) {
      __extends(RBTree2, _super);
      function RBTree2(comparator) {
        var _this = _super.call(this) || this;
        _this._root = null;
        _this._comparator = comparator;
        _this.size = 0;
        return _this;
      }
      RBTree2.prototype.insert = function(data) {
        var ret = false;
        if (this._root === null) {
          this._root = new Node4(data);
          ret = true;
          this.size++;
        } else {
          var head = new Node4(void 0);
          var dir = false;
          var last = false;
          var gp = null;
          var ggp = head;
          var p = null;
          var node = this._root;
          ggp.right = this._root;
          while (true) {
            if (node === null) {
              node = new Node4(data);
              p.set_child(dir, node);
              ret = true;
              this.size++;
            } else if (RBTree2.is_red(node.left) && RBTree2.is_red(node.right)) {
              node.red = true;
              node.left.red = false;
              node.right.red = false;
            }
            if (RBTree2.is_red(node) && RBTree2.is_red(p)) {
              var dir2 = ggp.right === gp;
              if (node === p.get_child(last)) {
                ggp.set_child(dir2, RBTree2.single_rotate(gp, !last));
              } else {
                ggp.set_child(dir2, RBTree2.double_rotate(gp, !last));
              }
            }
            var cmp = this._comparator(node.data, data);
            if (cmp === 0) {
              break;
            }
            last = dir;
            dir = cmp < 0;
            if (gp !== null) {
              ggp = gp;
            }
            gp = p;
            p = node;
            node = node.get_child(dir);
          }
          this._root = head.right;
        }
        this._root.red = false;
        return ret;
      };
      ;
      RBTree2.prototype.remove = function(data) {
        if (this._root === null) {
          return false;
        }
        var head = new Node4(void 0);
        var node = head;
        node.right = this._root;
        var p = null;
        var gp = null;
        var found = null;
        var dir = true;
        while (node.get_child(dir) !== null) {
          var last = dir;
          gp = p;
          p = node;
          node = node.get_child(dir);
          var cmp = this._comparator(data, node.data);
          dir = cmp > 0;
          if (cmp === 0) {
            found = node;
          }
          if (!RBTree2.is_red(node) && !RBTree2.is_red(node.get_child(dir))) {
            if (RBTree2.is_red(node.get_child(!dir))) {
              var sr = RBTree2.single_rotate(node, dir);
              p.set_child(last, sr);
              p = sr;
            } else if (!RBTree2.is_red(node.get_child(!dir))) {
              var sibling = p.get_child(!last);
              if (sibling !== null) {
                if (!RBTree2.is_red(sibling.get_child(!last)) && !RBTree2.is_red(sibling.get_child(last))) {
                  p.red = false;
                  sibling.red = true;
                  node.red = true;
                } else {
                  var dir2 = gp.right === p;
                  if (RBTree2.is_red(sibling.get_child(last))) {
                    gp.set_child(dir2, RBTree2.double_rotate(p, last));
                  } else if (RBTree2.is_red(sibling.get_child(!last))) {
                    gp.set_child(dir2, RBTree2.single_rotate(p, last));
                  }
                  var gpc = gp.get_child(dir2);
                  gpc.red = true;
                  node.red = true;
                  gpc.left.red = false;
                  gpc.right.red = false;
                }
              }
            }
          }
        }
        if (found !== null) {
          found.data = node.data;
          p.set_child(p.right === node, node.get_child(node.left === null));
          this.size--;
        }
        this._root = head.right;
        if (this._root !== null) {
          this._root.red = false;
        }
        return found !== null;
      };
      ;
      RBTree2.is_red = function(node) {
        return node !== null && node.red;
      };
      RBTree2.single_rotate = function(root3, dir) {
        var save = root3.get_child(!dir);
        root3.set_child(!dir, save.get_child(dir));
        save.set_child(dir, root3);
        root3.red = true;
        save.red = false;
        return save;
      };
      RBTree2.double_rotate = function(root3, dir) {
        root3.set_child(!dir, RBTree2.single_rotate(root3.get_child(!dir), !dir));
        return RBTree2.single_rotate(root3, dir);
      };
      return RBTree2;
    }(TreeBase);
    exports.RBTree = RBTree;
  }
});

// node_modules/webcola/dist/src/rectangle.js
var require_rectangle = __commonJS({
  "node_modules/webcola/dist/src/rectangle.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
          d2.__proto__ = b10;
        } || function(d2, b10) {
          for (var p in b10) if (b10.hasOwnProperty(p)) d2[p] = b10[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var vpsc_1 = require_vpsc();
    var rbtree_1 = require_rbtree();
    function computeGroupBounds(g) {
      g.bounds = typeof g.leaves !== "undefined" ? g.leaves.reduce(function(r, c6) {
        return c6.bounds.union(r);
      }, Rectangle2.empty()) : Rectangle2.empty();
      if (typeof g.groups !== "undefined")
        g.bounds = g.groups.reduce(function(r, c6) {
          return computeGroupBounds(c6).union(r);
        }, g.bounds);
      g.bounds = g.bounds.inflate(g.padding);
      return g.bounds;
    }
    exports.computeGroupBounds = computeGroupBounds;
    var Rectangle2 = function() {
      function Rectangle3(x4, X3, y4, Y3) {
        this.x = x4;
        this.X = X3;
        this.y = y4;
        this.Y = Y3;
      }
      Rectangle3.empty = function() {
        return new Rectangle3(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
      };
      Rectangle3.prototype.cx = function() {
        return (this.x + this.X) / 2;
      };
      Rectangle3.prototype.cy = function() {
        return (this.y + this.Y) / 2;
      };
      Rectangle3.prototype.overlapX = function(r) {
        var ux = this.cx(), vx = r.cx();
        if (ux <= vx && r.x < this.X)
          return this.X - r.x;
        if (vx <= ux && this.x < r.X)
          return r.X - this.x;
        return 0;
      };
      Rectangle3.prototype.overlapY = function(r) {
        var uy = this.cy(), vy = r.cy();
        if (uy <= vy && r.y < this.Y)
          return this.Y - r.y;
        if (vy <= uy && this.y < r.Y)
          return r.Y - this.y;
        return 0;
      };
      Rectangle3.prototype.setXCentre = function(cx) {
        var dx = cx - this.cx();
        this.x += dx;
        this.X += dx;
      };
      Rectangle3.prototype.setYCentre = function(cy) {
        var dy = cy - this.cy();
        this.y += dy;
        this.Y += dy;
      };
      Rectangle3.prototype.width = function() {
        return this.X - this.x;
      };
      Rectangle3.prototype.height = function() {
        return this.Y - this.y;
      };
      Rectangle3.prototype.union = function(r) {
        return new Rectangle3(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));
      };
      Rectangle3.prototype.lineIntersections = function(x12, y12, x22, y22) {
        var sides = [
          [this.x, this.y, this.X, this.y],
          [this.X, this.y, this.X, this.Y],
          [this.X, this.Y, this.x, this.Y],
          [this.x, this.Y, this.x, this.y]
        ];
        var intersections = [];
        for (var i = 0; i < 4; ++i) {
          var r = Rectangle3.lineIntersection(x12, y12, x22, y22, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);
          if (r !== null)
            intersections.push({ x: r.x, y: r.y });
        }
        return intersections;
      };
      Rectangle3.prototype.rayIntersection = function(x22, y22) {
        var ints = this.lineIntersections(this.cx(), this.cy(), x22, y22);
        return ints.length > 0 ? ints[0] : null;
      };
      Rectangle3.prototype.vertices = function() {
        return [
          { x: this.x, y: this.y },
          { x: this.X, y: this.y },
          { x: this.X, y: this.Y },
          { x: this.x, y: this.Y }
        ];
      };
      Rectangle3.lineIntersection = function(x12, y12, x22, y22, x32, y32, x4, y4) {
        var dx12 = x22 - x12, dx34 = x4 - x32, dy12 = y22 - y12, dy34 = y4 - y32, denominator = dy34 * dx12 - dx34 * dy12;
        if (denominator == 0)
          return null;
        var dx31 = x12 - x32, dy31 = y12 - y32, numa = dx34 * dy31 - dy34 * dx31, a4 = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;
        if (a4 >= 0 && a4 <= 1 && b >= 0 && b <= 1) {
          return {
            x: x12 + a4 * dx12,
            y: y12 + a4 * dy12
          };
        }
        return null;
      };
      Rectangle3.prototype.inflate = function(pad3) {
        return new Rectangle3(this.x - pad3, this.X + pad3, this.y - pad3, this.Y + pad3);
      };
      return Rectangle3;
    }();
    exports.Rectangle = Rectangle2;
    function makeEdgeBetween(source, target, ah) {
      var si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() }, ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;
      return {
        sourceIntersection: si,
        targetIntersection: ti,
        arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }
      };
    }
    exports.makeEdgeBetween = makeEdgeBetween;
    function makeEdgeTo(s2, target, ah) {
      var ti = target.rayIntersection(s2.x, s2.y);
      if (!ti)
        ti = { x: target.cx(), y: target.cy() };
      var dx = ti.x - s2.x, dy = ti.y - s2.y, l = Math.sqrt(dx * dx + dy * dy);
      return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };
    }
    exports.makeEdgeTo = makeEdgeTo;
    var Node4 = /* @__PURE__ */ function() {
      function Node5(v2, r, pos) {
        this.v = v2;
        this.r = r;
        this.pos = pos;
        this.prev = makeRBTree();
        this.next = makeRBTree();
      }
      return Node5;
    }();
    var Event = /* @__PURE__ */ function() {
      function Event2(isOpen, v2, pos) {
        this.isOpen = isOpen;
        this.v = v2;
        this.pos = pos;
      }
      return Event2;
    }();
    function compareEvents(a4, b) {
      if (a4.pos > b.pos) {
        return 1;
      }
      if (a4.pos < b.pos) {
        return -1;
      }
      if (a4.isOpen) {
        return -1;
      }
      if (b.isOpen) {
        return 1;
      }
      return 0;
    }
    function makeRBTree() {
      return new rbtree_1.RBTree(function(a4, b) {
        return a4.pos - b.pos;
      });
    }
    var xRect = {
      getCentre: function(r) {
        return r.cx();
      },
      getOpen: function(r) {
        return r.y;
      },
      getClose: function(r) {
        return r.Y;
      },
      getSize: function(r) {
        return r.width();
      },
      makeRect: function(open, close, center2, size) {
        return new Rectangle2(center2 - size / 2, center2 + size / 2, open, close);
      },
      findNeighbours: findXNeighbours
    };
    var yRect = {
      getCentre: function(r) {
        return r.cy();
      },
      getOpen: function(r) {
        return r.x;
      },
      getClose: function(r) {
        return r.X;
      },
      getSize: function(r) {
        return r.height();
      },
      makeRect: function(open, close, center2, size) {
        return new Rectangle2(open, close, center2 - size / 2, center2 + size / 2);
      },
      findNeighbours: findYNeighbours
    };
    function generateGroupConstraints(root3, f, minSep, isContained) {
      if (isContained === void 0) {
        isContained = false;
      }
      var padding = root3.padding, gn = typeof root3.groups !== "undefined" ? root3.groups.length : 0, ln = typeof root3.leaves !== "undefined" ? root3.leaves.length : 0, childConstraints = !gn ? [] : root3.groups.reduce(function(ccs, g) {
        return ccs.concat(generateGroupConstraints(g, f, minSep, true));
      }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add2 = function(r, v2) {
        rs[i] = r;
        vs[i++] = v2;
      };
      if (isContained) {
        var b = root3.bounds, c6 = f.getCentre(b), s2 = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min4 = c6 - s2 + padding / 2, max5 = c6 + s2 - padding / 2;
        root3.minVar.desiredPosition = min4;
        add2(f.makeRect(open, close, min4, padding), root3.minVar);
        root3.maxVar.desiredPosition = max5;
        add2(f.makeRect(open, close, max5, padding), root3.maxVar);
      }
      if (ln)
        root3.leaves.forEach(function(l) {
          return add2(l.bounds, l.variable);
        });
      if (gn)
        root3.groups.forEach(function(g) {
          var b10 = g.bounds;
          add2(f.makeRect(f.getOpen(b10), f.getClose(b10), f.getCentre(b10), f.getSize(b10)), g.minVar);
        });
      var cs = generateConstraints(rs, vs, f, minSep);
      if (gn) {
        vs.forEach(function(v2) {
          v2.cOut = [], v2.cIn = [];
        });
        cs.forEach(function(c7) {
          c7.left.cOut.push(c7), c7.right.cIn.push(c7);
        });
        root3.groups.forEach(function(g) {
          var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;
          g.minVar.cIn.forEach(function(c7) {
            return c7.gap += gapAdjustment;
          });
          g.minVar.cOut.forEach(function(c7) {
            c7.left = g.maxVar;
            c7.gap += gapAdjustment;
          });
        });
      }
      return childConstraints.concat(cs);
    }
    function generateConstraints(rs, vars, rect, minSep) {
      var i, n = rs.length;
      var N = 2 * n;
      console.assert(vars.length >= n);
      var events = new Array(N);
      for (i = 0; i < n; ++i) {
        var r = rs[i];
        var v2 = new Node4(vars[i], r, rect.getCentre(r));
        events[i] = new Event(true, v2, rect.getOpen(r));
        events[i + n] = new Event(false, v2, rect.getClose(r));
      }
      events.sort(compareEvents);
      var cs = new Array();
      var scanline = makeRBTree();
      for (i = 0; i < N; ++i) {
        var e = events[i];
        var v2 = e.v;
        if (e.isOpen) {
          scanline.insert(v2);
          rect.findNeighbours(v2, scanline);
        } else {
          scanline.remove(v2);
          var makeConstraint = function(l, r2) {
            var sep = (rect.getSize(l.r) + rect.getSize(r2.r)) / 2 + minSep;
            cs.push(new vpsc_1.Constraint(l.v, r2.v, sep));
          };
          var visitNeighbours = function(forward, reverse3, mkcon) {
            var u4, it = v2[forward].iterator();
            while ((u4 = it[forward]()) !== null) {
              mkcon(u4, v2);
              u4[reverse3].remove(v2);
            }
          };
          visitNeighbours("prev", "next", function(u4, v3) {
            return makeConstraint(u4, v3);
          });
          visitNeighbours("next", "prev", function(u4, v3) {
            return makeConstraint(v3, u4);
          });
        }
      }
      console.assert(scanline.size === 0);
      return cs;
    }
    function findXNeighbours(v2, scanline) {
      var f = function(forward, reverse3) {
        var it = scanline.findIter(v2);
        var u4;
        while ((u4 = it[forward]()) !== null) {
          var uovervX = u4.r.overlapX(v2.r);
          if (uovervX <= 0 || uovervX <= u4.r.overlapY(v2.r)) {
            v2[forward].insert(u4);
            u4[reverse3].insert(v2);
          }
          if (uovervX <= 0) {
            break;
          }
        }
      };
      f("next", "prev");
      f("prev", "next");
    }
    function findYNeighbours(v2, scanline) {
      var f = function(forward, reverse3) {
        var u4 = scanline.findIter(v2)[forward]();
        if (u4 !== null && u4.r.overlapX(v2.r) > 0) {
          v2[forward].insert(u4);
          u4[reverse3].insert(v2);
        }
      };
      f("next", "prev");
      f("prev", "next");
    }
    function generateXConstraints(rs, vars) {
      return generateConstraints(rs, vars, xRect, 1e-6);
    }
    exports.generateXConstraints = generateXConstraints;
    function generateYConstraints(rs, vars) {
      return generateConstraints(rs, vars, yRect, 1e-6);
    }
    exports.generateYConstraints = generateYConstraints;
    function generateXGroupConstraints(root3) {
      return generateGroupConstraints(root3, xRect, 1e-6);
    }
    exports.generateXGroupConstraints = generateXGroupConstraints;
    function generateYGroupConstraints(root3) {
      return generateGroupConstraints(root3, yRect, 1e-6);
    }
    exports.generateYGroupConstraints = generateYGroupConstraints;
    function removeOverlaps(rs) {
      var vs = rs.map(function(r) {
        return new vpsc_1.Variable(r.cx());
      });
      var cs = generateXConstraints(rs, vs);
      var solver = new vpsc_1.Solver(vs, cs);
      solver.solve();
      vs.forEach(function(v2, i) {
        return rs[i].setXCentre(v2.position());
      });
      vs = rs.map(function(r) {
        return new vpsc_1.Variable(r.cy());
      });
      cs = generateYConstraints(rs, vs);
      solver = new vpsc_1.Solver(vs, cs);
      solver.solve();
      vs.forEach(function(v2, i) {
        return rs[i].setYCentre(v2.position());
      });
    }
    exports.removeOverlaps = removeOverlaps;
    var IndexedVariable = function(_super) {
      __extends(IndexedVariable2, _super);
      function IndexedVariable2(index4, w) {
        var _this = _super.call(this, 0, w) || this;
        _this.index = index4;
        return _this;
      }
      return IndexedVariable2;
    }(vpsc_1.Variable);
    exports.IndexedVariable = IndexedVariable;
    var Projection = function() {
      function Projection2(nodes, groups2, rootGroup, constraints, avoidOverlaps) {
        var _this = this;
        if (rootGroup === void 0) {
          rootGroup = null;
        }
        if (constraints === void 0) {
          constraints = null;
        }
        if (avoidOverlaps === void 0) {
          avoidOverlaps = false;
        }
        this.nodes = nodes;
        this.groups = groups2;
        this.rootGroup = rootGroup;
        this.avoidOverlaps = avoidOverlaps;
        this.variables = nodes.map(function(v2, i2) {
          return v2.variable = new IndexedVariable(i2, 1);
        });
        if (constraints)
          this.createConstraints(constraints);
        if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== "undefined") {
          nodes.forEach(function(v2) {
            if (!v2.width || !v2.height) {
              v2.bounds = new Rectangle2(v2.x, v2.x, v2.y, v2.y);
              return;
            }
            var w2 = v2.width / 2, h2 = v2.height / 2;
            v2.bounds = new Rectangle2(v2.x - w2, v2.x + w2, v2.y - h2, v2.y + h2);
          });
          computeGroupBounds(rootGroup);
          var i = nodes.length;
          groups2.forEach(function(g) {
            _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
            _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
          });
        }
      }
      Projection2.prototype.createSeparation = function(c6) {
        return new vpsc_1.Constraint(this.nodes[c6.left].variable, this.nodes[c6.right].variable, c6.gap, typeof c6.equality !== "undefined" ? c6.equality : false);
      };
      Projection2.prototype.makeFeasible = function(c6) {
        var _this = this;
        if (!this.avoidOverlaps)
          return;
        var axis2 = "x", dim = "width";
        if (c6.axis === "x")
          axis2 = "y", dim = "height";
        var vs = c6.offsets.map(function(o) {
          return _this.nodes[o.node];
        }).sort(function(a4, b) {
          return a4[axis2] - b[axis2];
        });
        var p = null;
        vs.forEach(function(v2) {
          if (p) {
            var nextPos = p[axis2] + p[dim];
            if (nextPos > v2[axis2]) {
              v2[axis2] = nextPos;
            }
          }
          p = v2;
        });
      };
      Projection2.prototype.createAlignment = function(c6) {
        var _this = this;
        var u4 = this.nodes[c6.offsets[0].node].variable;
        this.makeFeasible(c6);
        var cs = c6.axis === "x" ? this.xConstraints : this.yConstraints;
        c6.offsets.slice(1).forEach(function(o) {
          var v2 = _this.nodes[o.node].variable;
          cs.push(new vpsc_1.Constraint(u4, v2, o.offset, true));
        });
      };
      Projection2.prototype.createConstraints = function(constraints) {
        var _this = this;
        var isSep = function(c6) {
          return typeof c6.type === "undefined" || c6.type === "separation";
        };
        this.xConstraints = constraints.filter(function(c6) {
          return c6.axis === "x" && isSep(c6);
        }).map(function(c6) {
          return _this.createSeparation(c6);
        });
        this.yConstraints = constraints.filter(function(c6) {
          return c6.axis === "y" && isSep(c6);
        }).map(function(c6) {
          return _this.createSeparation(c6);
        });
        constraints.filter(function(c6) {
          return c6.type === "alignment";
        }).forEach(function(c6) {
          return _this.createAlignment(c6);
        });
      };
      Projection2.prototype.setupVariablesAndBounds = function(x06, y06, desired, getDesired) {
        this.nodes.forEach(function(v2, i) {
          if (v2.fixed) {
            v2.variable.weight = v2.fixedWeight ? v2.fixedWeight : 1e3;
            desired[i] = getDesired(v2);
          } else {
            v2.variable.weight = 1;
          }
          var w = (v2.width || 0) / 2, h = (v2.height || 0) / 2;
          var ix = x06[i], iy = y06[i];
          v2.bounds = new Rectangle2(ix - w, ix + w, iy - h, iy + h);
        });
      };
      Projection2.prototype.xProject = function(x06, y06, x4) {
        if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))
          return;
        this.project(x06, y06, x06, x4, function(v2) {
          return v2.px;
        }, this.xConstraints, generateXGroupConstraints, function(v2) {
          return v2.bounds.setXCentre(x4[v2.variable.index] = v2.variable.position());
        }, function(g) {
          var xmin = x4[g.minVar.index] = g.minVar.position();
          var xmax = x4[g.maxVar.index] = g.maxVar.position();
          var p2 = g.padding / 2;
          g.bounds.x = xmin - p2;
          g.bounds.X = xmax + p2;
        });
      };
      Projection2.prototype.yProject = function(x06, y06, y4) {
        if (!this.rootGroup && !this.yConstraints)
          return;
        this.project(x06, y06, y06, y4, function(v2) {
          return v2.py;
        }, this.yConstraints, generateYGroupConstraints, function(v2) {
          return v2.bounds.setYCentre(y4[v2.variable.index] = v2.variable.position());
        }, function(g) {
          var ymin = y4[g.minVar.index] = g.minVar.position();
          var ymax = y4[g.maxVar.index] = g.maxVar.position();
          var p2 = g.padding / 2;
          g.bounds.y = ymin - p2;
          ;
          g.bounds.Y = ymax + p2;
        });
      };
      Projection2.prototype.projectFunctions = function() {
        var _this = this;
        return [
          function(x06, y06, x4) {
            return _this.xProject(x06, y06, x4);
          },
          function(x06, y06, y4) {
            return _this.yProject(x06, y06, y4);
          }
        ];
      };
      Projection2.prototype.project = function(x06, y06, start3, desired, getDesired, cs, generateConstraints2, updateNodeBounds, updateGroupBounds) {
        this.setupVariablesAndBounds(x06, y06, desired, getDesired);
        if (this.rootGroup && this.avoidOverlaps) {
          computeGroupBounds(this.rootGroup);
          cs = cs.concat(generateConstraints2(this.rootGroup));
        }
        this.solve(this.variables, cs, start3, desired);
        this.nodes.forEach(updateNodeBounds);
        if (this.rootGroup && this.avoidOverlaps) {
          this.groups.forEach(updateGroupBounds);
          computeGroupBounds(this.rootGroup);
        }
      };
      Projection2.prototype.solve = function(vs, cs, starting, desired) {
        var solver = new vpsc_1.Solver(vs, cs);
        solver.setStartingPositions(starting);
        solver.setDesiredPositions(desired);
        solver.solve();
      };
      return Projection2;
    }();
    exports.Projection = Projection;
  }
});

// node_modules/webcola/dist/src/pqueue.js
var require_pqueue = __commonJS({
  "node_modules/webcola/dist/src/pqueue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PairingHeap = function() {
      function PairingHeap2(elem) {
        this.elem = elem;
        this.subheaps = [];
      }
      PairingHeap2.prototype.toString = function(selector) {
        var str = "", needComma = false;
        for (var i = 0; i < this.subheaps.length; ++i) {
          var subheap = this.subheaps[i];
          if (!subheap.elem) {
            needComma = false;
            continue;
          }
          if (needComma) {
            str = str + ",";
          }
          str = str + subheap.toString(selector);
          needComma = true;
        }
        if (str !== "") {
          str = "(" + str + ")";
        }
        return (this.elem ? selector(this.elem) : "") + str;
      };
      PairingHeap2.prototype.forEach = function(f) {
        if (!this.empty()) {
          f(this.elem, this);
          this.subheaps.forEach(function(s2) {
            return s2.forEach(f);
          });
        }
      };
      PairingHeap2.prototype.count = function() {
        return this.empty() ? 0 : 1 + this.subheaps.reduce(function(n, h) {
          return n + h.count();
        }, 0);
      };
      PairingHeap2.prototype.min = function() {
        return this.elem;
      };
      PairingHeap2.prototype.empty = function() {
        return this.elem == null;
      };
      PairingHeap2.prototype.contains = function(h) {
        if (this === h)
          return true;
        for (var i = 0; i < this.subheaps.length; i++) {
          if (this.subheaps[i].contains(h))
            return true;
        }
        return false;
      };
      PairingHeap2.prototype.isHeap = function(lessThan) {
        var _this = this;
        return this.subheaps.every(function(h) {
          return lessThan(_this.elem, h.elem) && h.isHeap(lessThan);
        });
      };
      PairingHeap2.prototype.insert = function(obj, lessThan) {
        return this.merge(new PairingHeap2(obj), lessThan);
      };
      PairingHeap2.prototype.merge = function(heap2, lessThan) {
        if (this.empty())
          return heap2;
        else if (heap2.empty())
          return this;
        else if (lessThan(this.elem, heap2.elem)) {
          this.subheaps.push(heap2);
          return this;
        } else {
          heap2.subheaps.push(this);
          return heap2;
        }
      };
      PairingHeap2.prototype.removeMin = function(lessThan) {
        if (this.empty())
          return null;
        else
          return this.mergePairs(lessThan);
      };
      PairingHeap2.prototype.mergePairs = function(lessThan) {
        if (this.subheaps.length == 0)
          return new PairingHeap2(null);
        else if (this.subheaps.length == 1) {
          return this.subheaps[0];
        } else {
          var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);
          var remaining = this.mergePairs(lessThan);
          return firstPair.merge(remaining, lessThan);
        }
      };
      PairingHeap2.prototype.decreaseKey = function(subheap, newValue, setHeapNode, lessThan) {
        var newHeap = subheap.removeMin(lessThan);
        subheap.elem = newHeap.elem;
        subheap.subheaps = newHeap.subheaps;
        if (setHeapNode !== null && newHeap.elem !== null) {
          setHeapNode(subheap.elem, subheap);
        }
        var pairingNode = new PairingHeap2(newValue);
        if (setHeapNode !== null) {
          setHeapNode(newValue, pairingNode);
        }
        return this.merge(pairingNode, lessThan);
      };
      return PairingHeap2;
    }();
    exports.PairingHeap = PairingHeap;
    var PriorityQueue = function() {
      function PriorityQueue2(lessThan) {
        this.lessThan = lessThan;
      }
      PriorityQueue2.prototype.top = function() {
        if (this.empty()) {
          return null;
        }
        return this.root.elem;
      };
      PriorityQueue2.prototype.push = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var pairingNode;
        for (var i = 0, arg; arg = args[i]; ++i) {
          pairingNode = new PairingHeap(arg);
          this.root = this.empty() ? pairingNode : this.root.merge(pairingNode, this.lessThan);
        }
        return pairingNode;
      };
      PriorityQueue2.prototype.empty = function() {
        return !this.root || !this.root.elem;
      };
      PriorityQueue2.prototype.isHeap = function() {
        return this.root.isHeap(this.lessThan);
      };
      PriorityQueue2.prototype.forEach = function(f) {
        this.root.forEach(f);
      };
      PriorityQueue2.prototype.pop = function() {
        if (this.empty()) {
          return null;
        }
        var obj = this.root.min();
        this.root = this.root.removeMin(this.lessThan);
        return obj;
      };
      PriorityQueue2.prototype.reduceKey = function(heapNode, newKey, setHeapNode) {
        if (setHeapNode === void 0) {
          setHeapNode = null;
        }
        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);
      };
      PriorityQueue2.prototype.toString = function(selector) {
        return this.root.toString(selector);
      };
      PriorityQueue2.prototype.count = function() {
        return this.root.count();
      };
      return PriorityQueue2;
    }();
    exports.PriorityQueue = PriorityQueue;
  }
});

// node_modules/webcola/dist/src/shortestpaths.js
var require_shortestpaths = __commonJS({
  "node_modules/webcola/dist/src/shortestpaths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pqueue_1 = require_pqueue();
    var Neighbour = /* @__PURE__ */ function() {
      function Neighbour2(id2, distance) {
        this.id = id2;
        this.distance = distance;
      }
      return Neighbour2;
    }();
    var Node4 = /* @__PURE__ */ function() {
      function Node5(id2) {
        this.id = id2;
        this.neighbours = [];
      }
      return Node5;
    }();
    var QueueEntry = /* @__PURE__ */ function() {
      function QueueEntry2(node, prev, d) {
        this.node = node;
        this.prev = prev;
        this.d = d;
      }
      return QueueEntry2;
    }();
    var Calculator = function() {
      function Calculator2(n, es, getSourceIndex, getTargetIndex, getLength) {
        this.n = n;
        this.es = es;
        this.neighbours = new Array(this.n);
        var i = this.n;
        while (i--)
          this.neighbours[i] = new Node4(i);
        i = this.es.length;
        while (i--) {
          var e = this.es[i];
          var u4 = getSourceIndex(e), v2 = getTargetIndex(e);
          var d = getLength(e);
          this.neighbours[u4].neighbours.push(new Neighbour(v2, d));
          this.neighbours[v2].neighbours.push(new Neighbour(u4, d));
        }
      }
      Calculator2.prototype.DistanceMatrix = function() {
        var D3 = new Array(this.n);
        for (var i = 0; i < this.n; ++i) {
          D3[i] = this.dijkstraNeighbours(i);
        }
        return D3;
      };
      Calculator2.prototype.DistancesFromNode = function(start3) {
        return this.dijkstraNeighbours(start3);
      };
      Calculator2.prototype.PathFromNodeToNode = function(start3, end2) {
        return this.dijkstraNeighbours(start3, end2);
      };
      Calculator2.prototype.PathFromNodeToNodeWithPrevCost = function(start3, end2, prevCost) {
        var q = new pqueue_1.PriorityQueue(function(a4, b) {
          return a4.d <= b.d;
        }), u4 = this.neighbours[start3], qu = new QueueEntry(u4, null, 0), visitedFrom = {};
        q.push(qu);
        while (!q.empty()) {
          qu = q.pop();
          u4 = qu.node;
          if (u4.id === end2) {
            break;
          }
          var i = u4.neighbours.length;
          while (i--) {
            var neighbour = u4.neighbours[i], v2 = this.neighbours[neighbour.id];
            if (qu.prev && v2.id === qu.prev.node.id)
              continue;
            var viduid = v2.id + "," + u4.id;
            if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)
              continue;
            var cc2 = qu.prev ? prevCost(qu.prev.node.id, u4.id, v2.id) : 0, t = qu.d + neighbour.distance + cc2;
            visitedFrom[viduid] = t;
            q.push(new QueueEntry(v2, qu, t));
          }
        }
        var path3 = [];
        while (qu.prev) {
          qu = qu.prev;
          path3.push(qu.node.id);
        }
        return path3;
      };
      Calculator2.prototype.dijkstraNeighbours = function(start3, dest) {
        if (dest === void 0) {
          dest = -1;
        }
        var q = new pqueue_1.PriorityQueue(function(a4, b) {
          return a4.d <= b.d;
        }), i = this.neighbours.length, d = new Array(i);
        while (i--) {
          var node = this.neighbours[i];
          node.d = i === start3 ? 0 : Number.POSITIVE_INFINITY;
          node.q = q.push(node);
        }
        while (!q.empty()) {
          var u4 = q.pop();
          d[u4.id] = u4.d;
          if (u4.id === dest) {
            var path3 = [];
            var v2 = u4;
            while (typeof v2.prev !== "undefined") {
              path3.push(v2.prev.id);
              v2 = v2.prev;
            }
            return path3;
          }
          i = u4.neighbours.length;
          while (i--) {
            var neighbour = u4.neighbours[i];
            var v2 = this.neighbours[neighbour.id];
            var t = u4.d + neighbour.distance;
            if (u4.d !== Number.MAX_VALUE && v2.d > t) {
              v2.d = t;
              v2.prev = u4;
              q.reduceKey(v2.q, v2, function(e, q2) {
                return e.q = q2;
              });
            }
          }
        }
        return d;
      };
      return Calculator2;
    }();
    exports.Calculator = Calculator;
  }
});

// node_modules/webcola/dist/src/geom.js
var require_geom = __commonJS({
  "node_modules/webcola/dist/src/geom.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
          d2.__proto__ = b10;
        } || function(d2, b10) {
          for (var p in b10) if (b10.hasOwnProperty(p)) d2[p] = b10[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var rectangle_1 = require_rectangle();
    var Point2 = /* @__PURE__ */ function() {
      function Point3() {
      }
      return Point3;
    }();
    exports.Point = Point2;
    var LineSegment = /* @__PURE__ */ function() {
      function LineSegment2(x12, y12, x22, y22) {
        this.x1 = x12;
        this.y1 = y12;
        this.x2 = x22;
        this.y2 = y22;
      }
      return LineSegment2;
    }();
    exports.LineSegment = LineSegment;
    var PolyPoint = function(_super) {
      __extends(PolyPoint2, _super);
      function PolyPoint2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return PolyPoint2;
    }(Point2);
    exports.PolyPoint = PolyPoint;
    function isLeft(P0, P1, P2) {
      return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);
    }
    exports.isLeft = isLeft;
    function above2(p, vi, vj) {
      return isLeft(p, vi, vj) > 0;
    }
    function below(p, vi, vj) {
      return isLeft(p, vi, vj) < 0;
    }
    function ConvexHull(S) {
      var P = S.slice(0).sort(function(a4, b) {
        return a4.x !== b.x ? b.x - a4.x : b.y - a4.y;
      });
      var n = S.length, i;
      var minmin = 0;
      var xmin = P[0].x;
      for (i = 1; i < n; ++i) {
        if (P[i].x !== xmin)
          break;
      }
      var minmax = i - 1;
      var H = [];
      H.push(P[minmin]);
      if (minmax === n - 1) {
        if (P[minmax].y !== P[minmin].y)
          H.push(P[minmax]);
      } else {
        var maxmin, maxmax = n - 1;
        var xmax = P[n - 1].x;
        for (i = n - 2; i >= 0; i--)
          if (P[i].x !== xmax)
            break;
        maxmin = i + 1;
        i = minmax;
        while (++i <= maxmin) {
          if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)
            continue;
          while (H.length > 1) {
            if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
              break;
            else
              H.length -= 1;
          }
          if (i != minmin)
            H.push(P[i]);
        }
        if (maxmax != maxmin)
          H.push(P[maxmax]);
        var bot = H.length;
        i = maxmin;
        while (--i >= minmax) {
          if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)
            continue;
          while (H.length > bot) {
            if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
              break;
            else
              H.length -= 1;
          }
          if (i != minmin)
            H.push(P[i]);
        }
      }
      return H;
    }
    exports.ConvexHull = ConvexHull;
    function clockwiseRadialSweep(p, P, f) {
      P.slice(0).sort(function(a4, b) {
        return Math.atan2(a4.y - p.y, a4.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x);
      }).forEach(f);
    }
    exports.clockwiseRadialSweep = clockwiseRadialSweep;
    function tangent_PointPolyC(P, V) {
      var Vclosed = V.slice(0);
      Vclosed.push(V[0]);
      return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };
    }
    function Rtangent_PointPolyC(P, V) {
      var n = V.length - 1;
      var a4, b, c6;
      var upA, dnC;
      if (below(P, V[1], V[0]) && !above2(P, V[n - 1], V[0]))
        return 0;
      for (a4 = 0, b = n; ; ) {
        if (b - a4 === 1)
          if (above2(P, V[a4], V[b]))
            return a4;
          else
            return b;
        c6 = Math.floor((a4 + b) / 2);
        dnC = below(P, V[c6 + 1], V[c6]);
        if (dnC && !above2(P, V[c6 - 1], V[c6]))
          return c6;
        upA = above2(P, V[a4 + 1], V[a4]);
        if (upA) {
          if (dnC)
            b = c6;
          else {
            if (above2(P, V[a4], V[c6]))
              b = c6;
            else
              a4 = c6;
          }
        } else {
          if (!dnC)
            a4 = c6;
          else {
            if (below(P, V[a4], V[c6]))
              b = c6;
            else
              a4 = c6;
          }
        }
      }
    }
    function Ltangent_PointPolyC(P, V) {
      var n = V.length - 1;
      var a4, b, c6;
      var dnA, dnC;
      if (above2(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))
        return 0;
      for (a4 = 0, b = n; ; ) {
        if (b - a4 === 1)
          if (below(P, V[a4], V[b]))
            return a4;
          else
            return b;
        c6 = Math.floor((a4 + b) / 2);
        dnC = below(P, V[c6 + 1], V[c6]);
        if (above2(P, V[c6 - 1], V[c6]) && !dnC)
          return c6;
        dnA = below(P, V[a4 + 1], V[a4]);
        if (dnA) {
          if (!dnC)
            b = c6;
          else {
            if (below(P, V[a4], V[c6]))
              b = c6;
            else
              a4 = c6;
          }
        } else {
          if (dnC)
            a4 = c6;
          else {
            if (above2(P, V[a4], V[c6]))
              b = c6;
            else
              a4 = c6;
          }
        }
      }
    }
    function tangent_PolyPolyC(V, W, t13, t22, cmp1, cmp2) {
      var ix1, ix2;
      ix1 = t13(W[0], V);
      ix2 = t22(V[ix1], W);
      var done = false;
      while (!done) {
        done = true;
        while (true) {
          if (ix1 === V.length - 1)
            ix1 = 0;
          if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))
            break;
          ++ix1;
        }
        while (true) {
          if (ix2 === 0)
            ix2 = W.length - 1;
          if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))
            break;
          --ix2;
          done = false;
        }
      }
      return { t1: ix1, t2: ix2 };
    }
    exports.tangent_PolyPolyC = tangent_PolyPolyC;
    function LRtangent_PolyPolyC(V, W) {
      var rl = RLtangent_PolyPolyC(W, V);
      return { t1: rl.t2, t2: rl.t1 };
    }
    exports.LRtangent_PolyPolyC = LRtangent_PolyPolyC;
    function RLtangent_PolyPolyC(V, W) {
      return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above2, below);
    }
    exports.RLtangent_PolyPolyC = RLtangent_PolyPolyC;
    function LLtangent_PolyPolyC(V, W) {
      return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);
    }
    exports.LLtangent_PolyPolyC = LLtangent_PolyPolyC;
    function RRtangent_PolyPolyC(V, W) {
      return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above2, above2);
    }
    exports.RRtangent_PolyPolyC = RRtangent_PolyPolyC;
    var BiTangent = /* @__PURE__ */ function() {
      function BiTangent2(t13, t22) {
        this.t1 = t13;
        this.t2 = t22;
      }
      return BiTangent2;
    }();
    exports.BiTangent = BiTangent;
    var BiTangents = /* @__PURE__ */ function() {
      function BiTangents2() {
      }
      return BiTangents2;
    }();
    exports.BiTangents = BiTangents;
    var TVGPoint = function(_super) {
      __extends(TVGPoint2, _super);
      function TVGPoint2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return TVGPoint2;
    }(Point2);
    exports.TVGPoint = TVGPoint;
    var VisibilityVertex = /* @__PURE__ */ function() {
      function VisibilityVertex2(id2, polyid, polyvertid, p) {
        this.id = id2;
        this.polyid = polyid;
        this.polyvertid = polyvertid;
        this.p = p;
        p.vv = this;
      }
      return VisibilityVertex2;
    }();
    exports.VisibilityVertex = VisibilityVertex;
    var VisibilityEdge = function() {
      function VisibilityEdge2(source, target) {
        this.source = source;
        this.target = target;
      }
      VisibilityEdge2.prototype.length = function() {
        var dx = this.source.p.x - this.target.p.x;
        var dy = this.source.p.y - this.target.p.y;
        return Math.sqrt(dx * dx + dy * dy);
      };
      return VisibilityEdge2;
    }();
    exports.VisibilityEdge = VisibilityEdge;
    var TangentVisibilityGraph = function() {
      function TangentVisibilityGraph2(P, g0) {
        this.P = P;
        this.V = [];
        this.E = [];
        if (!g0) {
          var n = P.length;
          for (var i = 0; i < n; i++) {
            var p = P[i];
            for (var j = 0; j < p.length; ++j) {
              var pj = p[j], vv = new VisibilityVertex(this.V.length, i, j, pj);
              this.V.push(vv);
              if (j > 0)
                this.E.push(new VisibilityEdge(p[j - 1].vv, vv));
            }
            if (p.length > 1)
              this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));
          }
          for (var i = 0; i < n - 1; i++) {
            var Pi = P[i];
            for (var j = i + 1; j < n; j++) {
              var Pj = P[j], t = tangents(Pi, Pj);
              for (var q in t) {
                var c6 = t[q], source = Pi[c6.t1], target = Pj[c6.t2];
                this.addEdgeIfVisible(source, target, i, j);
              }
            }
          }
        } else {
          this.V = g0.V.slice(0);
          this.E = g0.E.slice(0);
        }
      }
      TangentVisibilityGraph2.prototype.addEdgeIfVisible = function(u4, v2, i1, i2) {
        if (!this.intersectsPolys(new LineSegment(u4.x, u4.y, v2.x, v2.y), i1, i2)) {
          this.E.push(new VisibilityEdge(u4.vv, v2.vv));
        }
      };
      TangentVisibilityGraph2.prototype.addPoint = function(p, i1) {
        var n = this.P.length;
        this.V.push(new VisibilityVertex(this.V.length, n, 0, p));
        for (var i = 0; i < n; ++i) {
          if (i === i1)
            continue;
          var poly = this.P[i], t = tangent_PointPolyC(p, poly);
          this.addEdgeIfVisible(p, poly[t.ltan], i1, i);
          this.addEdgeIfVisible(p, poly[t.rtan], i1, i);
        }
        return p.vv;
      };
      TangentVisibilityGraph2.prototype.intersectsPolys = function(l, i1, i2) {
        for (var i = 0, n = this.P.length; i < n; ++i) {
          if (i != i1 && i != i2 && intersects2(l, this.P[i]).length > 0) {
            return true;
          }
        }
        return false;
      };
      return TangentVisibilityGraph2;
    }();
    exports.TangentVisibilityGraph = TangentVisibilityGraph;
    function intersects2(l, P) {
      var ints = [];
      for (var i = 1, n = P.length; i < n; ++i) {
        var int = rectangle_1.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);
        if (int)
          ints.push(int);
      }
      return ints;
    }
    function tangents(V, W) {
      var m3 = V.length - 1, n = W.length - 1;
      var bt = new BiTangents();
      for (var i = 0; i < m3; ++i) {
        for (var j = 0; j < n; ++j) {
          var v1 = V[i == 0 ? m3 - 1 : i - 1];
          var v2 = V[i];
          var v3 = V[i + 1];
          var w1 = W[j == 0 ? n - 1 : j - 1];
          var w2 = W[j];
          var w3 = W[j + 1];
          var v1v2w2 = isLeft(v1, v2, w2);
          var v2w1w2 = isLeft(v2, w1, w2);
          var v2w2w3 = isLeft(v2, w2, w3);
          var w1w2v2 = isLeft(w1, w2, v2);
          var w2v1v2 = isLeft(w2, v1, v2);
          var w2v2v3 = isLeft(w2, v2, v3);
          if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0 && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {
            bt.ll = new BiTangent(i, j);
          } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0 && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {
            bt.rr = new BiTangent(i, j);
          } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0 && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {
            bt.rl = new BiTangent(i, j);
          } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0 && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {
            bt.lr = new BiTangent(i, j);
          }
        }
      }
      return bt;
    }
    exports.tangents = tangents;
    function isPointInsidePoly(p, poly) {
      for (var i = 1, n = poly.length; i < n; ++i)
        if (below(poly[i - 1], poly[i], p))
          return false;
      return true;
    }
    function isAnyPInQ(p, q) {
      return !p.every(function(v2) {
        return !isPointInsidePoly(v2, q);
      });
    }
    function polysOverlap(p, q) {
      if (isAnyPInQ(p, q))
        return true;
      if (isAnyPInQ(q, p))
        return true;
      for (var i = 1, n = p.length; i < n; ++i) {
        var v2 = p[i], u4 = p[i - 1];
        if (intersects2(new LineSegment(u4.x, u4.y, v2.x, v2.y), q).length > 0)
          return true;
      }
      return false;
    }
    exports.polysOverlap = polysOverlap;
  }
});

// node_modules/webcola/dist/src/handledisconnected.js
var require_handledisconnected = __commonJS({
  "node_modules/webcola/dist/src/handledisconnected.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var packingOptions = {
      PADDING: 10,
      GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,
      FLOAT_EPSILON: 1e-4,
      MAX_INERATIONS: 100
    };
    function applyPacking(graphs, w, h, node_size, desired_ratio, centerGraph) {
      if (desired_ratio === void 0) {
        desired_ratio = 1;
      }
      if (centerGraph === void 0) {
        centerGraph = true;
      }
      var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== "undefined" ? desired_ratio : 1, node_size = typeof node_size !== "undefined" ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];
      if (graphs.length == 0)
        return;
      calculate_bb(graphs);
      apply(graphs, desired_ratio);
      if (centerGraph) {
        put_nodes_to_right_positions(graphs);
      }
      function calculate_bb(graphs2) {
        graphs2.forEach(function(g) {
          calculate_single_bb(g);
        });
        function calculate_single_bb(graph) {
          var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;
          graph.array.forEach(function(v2) {
            var w2 = typeof v2.width !== "undefined" ? v2.width : node_size;
            var h2 = typeof v2.height !== "undefined" ? v2.height : node_size;
            w2 /= 2;
            h2 /= 2;
            max_x = Math.max(v2.x + w2, max_x);
            min_x = Math.min(v2.x - w2, min_x);
            max_y = Math.max(v2.y + h2, max_y);
            min_y = Math.min(v2.y - h2, min_y);
          });
          graph.width = max_x - min_x;
          graph.height = max_y - min_y;
        }
      }
      function put_nodes_to_right_positions(graphs2) {
        graphs2.forEach(function(g) {
          var center2 = { x: 0, y: 0 };
          g.array.forEach(function(node) {
            center2.x += node.x;
            center2.y += node.y;
          });
          center2.x /= g.array.length;
          center2.y /= g.array.length;
          var corner = { x: center2.x - g.width / 2, y: center2.y - g.height / 2 };
          var offset3 = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2 };
          g.array.forEach(function(node) {
            node.x += offset3.x;
            node.y += offset3.y;
          });
        });
      }
      function apply(data, desired_ratio2) {
        var curr_best_f = Number.POSITIVE_INFINITY;
        var curr_best = 0;
        data.sort(function(a4, b) {
          return b.height - a4.height;
        });
        min_width = data.reduce(function(a4, b) {
          return a4.width < b.width ? a4.width : b.width;
        });
        var left3 = x12 = min_width;
        var right3 = x22 = get_entire_width(data);
        var iterationCounter = 0;
        var f_x1 = Number.MAX_VALUE;
        var f_x2 = Number.MAX_VALUE;
        var flag = -1;
        var dx = Number.MAX_VALUE;
        var df = Number.MAX_VALUE;
        while (dx > min_width || df > packingOptions.FLOAT_EPSILON) {
          if (flag != 1) {
            var x12 = right3 - (right3 - left3) / packingOptions.GOLDEN_SECTION;
            var f_x1 = step(data, x12);
          }
          if (flag != 0) {
            var x22 = left3 + (right3 - left3) / packingOptions.GOLDEN_SECTION;
            var f_x2 = step(data, x22);
          }
          dx = Math.abs(x12 - x22);
          df = Math.abs(f_x1 - f_x2);
          if (f_x1 < curr_best_f) {
            curr_best_f = f_x1;
            curr_best = x12;
          }
          if (f_x2 < curr_best_f) {
            curr_best_f = f_x2;
            curr_best = x22;
          }
          if (f_x1 > f_x2) {
            left3 = x12;
            x12 = x22;
            f_x1 = f_x2;
            flag = 1;
          } else {
            right3 = x22;
            x22 = x12;
            f_x2 = f_x1;
            flag = 0;
          }
          if (iterationCounter++ > 100) {
            break;
          }
        }
        step(data, curr_best);
      }
      function step(data, max_width) {
        line = [];
        real_width = 0;
        real_height = 0;
        global_bottom = init_y;
        for (var i = 0; i < data.length; i++) {
          var o = data[i];
          put_rect(o, max_width);
        }
        return Math.abs(get_real_ratio() - desired_ratio);
      }
      function put_rect(rect, max_width) {
        var parent = void 0;
        for (var i = 0; i < line.length; i++) {
          if (line[i].space_left >= rect.height && line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width <= packingOptions.FLOAT_EPSILON) {
            parent = line[i];
            break;
          }
        }
        line.push(rect);
        if (parent !== void 0) {
          rect.x = parent.x + parent.width + packingOptions.PADDING;
          rect.y = parent.bottom;
          rect.space_left = rect.height;
          rect.bottom = rect.y;
          parent.space_left -= rect.height + packingOptions.PADDING;
          parent.bottom += rect.height + packingOptions.PADDING;
        } else {
          rect.y = global_bottom;
          global_bottom += rect.height + packingOptions.PADDING;
          rect.x = init_x;
          rect.bottom = rect.y;
          rect.space_left = rect.height;
        }
        if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)
          real_height = rect.y + rect.height - init_y;
        if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)
          real_width = rect.x + rect.width - init_x;
      }
      ;
      function get_entire_width(data) {
        var width = 0;
        data.forEach(function(d) {
          return width += d.width + packingOptions.PADDING;
        });
        return width;
      }
      function get_real_ratio() {
        return real_width / real_height;
      }
    }
    exports.applyPacking = applyPacking;
    function separateGraphs(nodes, links) {
      var marks = {};
      var ways = {};
      var graphs = [];
      var clusters = 0;
      for (var i = 0; i < links.length; i++) {
        var link3 = links[i];
        var n1 = link3.source;
        var n2 = link3.target;
        if (ways[n1.index])
          ways[n1.index].push(n2);
        else
          ways[n1.index] = [n2];
        if (ways[n2.index])
          ways[n2.index].push(n1);
        else
          ways[n2.index] = [n1];
      }
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (marks[node.index])
          continue;
        explore_node(node, true);
      }
      function explore_node(n, is_new) {
        if (marks[n.index] !== void 0)
          return;
        if (is_new) {
          clusters++;
          graphs.push({ array: [] });
        }
        marks[n.index] = clusters;
        graphs[clusters - 1].array.push(n);
        var adjacent = ways[n.index];
        if (!adjacent)
          return;
        for (var j = 0; j < adjacent.length; j++) {
          explore_node(adjacent[j], false);
        }
      }
      return graphs;
    }
    exports.separateGraphs = separateGraphs;
  }
});

// node_modules/webcola/dist/src/layout.js
var require_layout = __commonJS({
  "node_modules/webcola/dist/src/layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var powergraph = require_powergraph();
    var linklengths_1 = require_linklengths();
    var descent_1 = require_descent();
    var rectangle_1 = require_rectangle();
    var shortestpaths_1 = require_shortestpaths();
    var geom_1 = require_geom();
    var handledisconnected_1 = require_handledisconnected();
    var EventType;
    (function(EventType2) {
      EventType2[EventType2["start"] = 0] = "start";
      EventType2[EventType2["tick"] = 1] = "tick";
      EventType2[EventType2["end"] = 2] = "end";
    })(EventType = exports.EventType || (exports.EventType = {}));
    function isGroup(g) {
      return typeof g.leaves !== "undefined" || typeof g.groups !== "undefined";
    }
    var Layout = function() {
      function Layout2() {
        var _this = this;
        this._canvasSize = [1, 1];
        this._linkDistance = 20;
        this._defaultNodeSize = 10;
        this._linkLengthCalculator = null;
        this._linkType = null;
        this._avoidOverlaps = false;
        this._handleDisconnected = true;
        this._running = false;
        this._nodes = [];
        this._groups = [];
        this._rootGroup = null;
        this._links = [];
        this._constraints = [];
        this._distanceMatrix = null;
        this._descent = null;
        this._directedLinkConstraints = null;
        this._threshold = 0.01;
        this._visibilityGraph = null;
        this._groupCompactness = 1e-6;
        this.event = null;
        this.linkAccessor = {
          getSourceIndex: Layout2.getSourceIndex,
          getTargetIndex: Layout2.getTargetIndex,
          setLength: Layout2.setLinkLength,
          getType: function(l) {
            return typeof _this._linkType === "function" ? _this._linkType(l) : 0;
          }
        };
      }
      Layout2.prototype.on = function(e, listener) {
        if (!this.event)
          this.event = {};
        if (typeof e === "string") {
          this.event[EventType[e]] = listener;
        } else {
          this.event[e] = listener;
        }
        return this;
      };
      Layout2.prototype.trigger = function(e) {
        if (this.event && typeof this.event[e.type] !== "undefined") {
          this.event[e.type](e);
        }
      };
      Layout2.prototype.kick = function() {
        while (!this.tick())
          ;
      };
      Layout2.prototype.tick = function() {
        if (this._alpha < this._threshold) {
          this._running = false;
          this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });
          return true;
        }
        var n = this._nodes.length, m3 = this._links.length;
        var o, i;
        this._descent.locks.clear();
        for (i = 0; i < n; ++i) {
          o = this._nodes[i];
          if (o.fixed) {
            if (typeof o.px === "undefined" || typeof o.py === "undefined") {
              o.px = o.x;
              o.py = o.y;
            }
            var p = [o.px, o.py];
            this._descent.locks.add(i, p);
          }
        }
        var s1 = this._descent.rungeKutta();
        if (s1 === 0) {
          this._alpha = 0;
        } else if (typeof this._lastStress !== "undefined") {
          this._alpha = s1;
        }
        this._lastStress = s1;
        this.updateNodePositions();
        this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });
        return false;
      };
      Layout2.prototype.updateNodePositions = function() {
        var x4 = this._descent.x[0], y4 = this._descent.x[1];
        var o, i = this._nodes.length;
        while (i--) {
          o = this._nodes[i];
          o.x = x4[i];
          o.y = y4[i];
        }
      };
      Layout2.prototype.nodes = function(v2) {
        if (!v2) {
          if (this._nodes.length === 0 && this._links.length > 0) {
            var n = 0;
            this._links.forEach(function(l) {
              n = Math.max(n, l.source, l.target);
            });
            this._nodes = new Array(++n);
            for (var i = 0; i < n; ++i) {
              this._nodes[i] = {};
            }
          }
          return this._nodes;
        }
        this._nodes = v2;
        return this;
      };
      Layout2.prototype.groups = function(x4) {
        var _this = this;
        if (!x4)
          return this._groups;
        this._groups = x4;
        this._rootGroup = {};
        this._groups.forEach(function(g) {
          if (typeof g.padding === "undefined")
            g.padding = 1;
          if (typeof g.leaves !== "undefined") {
            g.leaves.forEach(function(v2, i) {
              if (typeof v2 === "number")
                (g.leaves[i] = _this._nodes[v2]).parent = g;
            });
          }
          if (typeof g.groups !== "undefined") {
            g.groups.forEach(function(gi, i) {
              if (typeof gi === "number")
                (g.groups[i] = _this._groups[gi]).parent = g;
            });
          }
        });
        this._rootGroup.leaves = this._nodes.filter(function(v2) {
          return typeof v2.parent === "undefined";
        });
        this._rootGroup.groups = this._groups.filter(function(g) {
          return typeof g.parent === "undefined";
        });
        return this;
      };
      Layout2.prototype.powerGraphGroups = function(f) {
        var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);
        this.groups(g.groups);
        f(g);
        return this;
      };
      Layout2.prototype.avoidOverlaps = function(v2) {
        if (!arguments.length)
          return this._avoidOverlaps;
        this._avoidOverlaps = v2;
        return this;
      };
      Layout2.prototype.handleDisconnected = function(v2) {
        if (!arguments.length)
          return this._handleDisconnected;
        this._handleDisconnected = v2;
        return this;
      };
      Layout2.prototype.flowLayout = function(axis2, minSeparation) {
        if (!arguments.length)
          axis2 = "y";
        this._directedLinkConstraints = {
          axis: axis2,
          getMinSeparation: typeof minSeparation === "number" ? function() {
            return minSeparation;
          } : minSeparation
        };
        return this;
      };
      Layout2.prototype.links = function(x4) {
        if (!arguments.length)
          return this._links;
        this._links = x4;
        return this;
      };
      Layout2.prototype.constraints = function(c6) {
        if (!arguments.length)
          return this._constraints;
        this._constraints = c6;
        return this;
      };
      Layout2.prototype.distanceMatrix = function(d) {
        if (!arguments.length)
          return this._distanceMatrix;
        this._distanceMatrix = d;
        return this;
      };
      Layout2.prototype.size = function(x4) {
        if (!x4)
          return this._canvasSize;
        this._canvasSize = x4;
        return this;
      };
      Layout2.prototype.defaultNodeSize = function(x4) {
        if (!x4)
          return this._defaultNodeSize;
        this._defaultNodeSize = x4;
        return this;
      };
      Layout2.prototype.groupCompactness = function(x4) {
        if (!x4)
          return this._groupCompactness;
        this._groupCompactness = x4;
        return this;
      };
      Layout2.prototype.linkDistance = function(x4) {
        if (!x4) {
          return this._linkDistance;
        }
        this._linkDistance = typeof x4 === "function" ? x4 : +x4;
        this._linkLengthCalculator = null;
        return this;
      };
      Layout2.prototype.linkType = function(f) {
        this._linkType = f;
        return this;
      };
      Layout2.prototype.convergenceThreshold = function(x4) {
        if (!x4)
          return this._threshold;
        this._threshold = typeof x4 === "function" ? x4 : +x4;
        return this;
      };
      Layout2.prototype.alpha = function(x4) {
        if (!arguments.length)
          return this._alpha;
        else {
          x4 = +x4;
          if (this._alpha) {
            if (x4 > 0)
              this._alpha = x4;
            else
              this._alpha = 0;
          } else if (x4 > 0) {
            if (!this._running) {
              this._running = true;
              this.trigger({ type: EventType.start, alpha: this._alpha = x4 });
              this.kick();
            }
          }
          return this;
        }
      };
      Layout2.prototype.getLinkLength = function(link3) {
        return typeof this._linkDistance === "function" ? +this._linkDistance(link3) : this._linkDistance;
      };
      Layout2.setLinkLength = function(link3, length3) {
        link3.length = length3;
      };
      Layout2.prototype.getLinkType = function(link3) {
        return typeof this._linkType === "function" ? this._linkType(link3) : 0;
      };
      Layout2.prototype.symmetricDiffLinkLengths = function(idealLength, w) {
        var _this = this;
        if (w === void 0) {
          w = 1;
        }
        this.linkDistance(function(l) {
          return idealLength * l.length;
        });
        this._linkLengthCalculator = function() {
          return linklengths_1.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w);
        };
        return this;
      };
      Layout2.prototype.jaccardLinkLengths = function(idealLength, w) {
        var _this = this;
        if (w === void 0) {
          w = 1;
        }
        this.linkDistance(function(l) {
          return idealLength * l.length;
        });
        this._linkLengthCalculator = function() {
          return linklengths_1.jaccardLinkLengths(_this._links, _this.linkAccessor, w);
        };
        return this;
      };
      Layout2.prototype.start = function(initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning, centerGraph) {
        var _this = this;
        if (initialUnconstrainedIterations === void 0) {
          initialUnconstrainedIterations = 0;
        }
        if (initialUserConstraintIterations === void 0) {
          initialUserConstraintIterations = 0;
        }
        if (initialAllConstraintsIterations === void 0) {
          initialAllConstraintsIterations = 0;
        }
        if (gridSnapIterations === void 0) {
          gridSnapIterations = 0;
        }
        if (keepRunning === void 0) {
          keepRunning = true;
        }
        if (centerGraph === void 0) {
          centerGraph = true;
        }
        var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m3 = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];
        var x4 = new Array(N), y4 = new Array(N);
        var G = null;
        var ao = this._avoidOverlaps;
        this._nodes.forEach(function(v2, i2) {
          v2.index = i2;
          if (typeof v2.x === "undefined") {
            v2.x = w / 2, v2.y = h / 2;
          }
          x4[i2] = v2.x, y4[i2] = v2.y;
        });
        if (this._linkLengthCalculator)
          this._linkLengthCalculator();
        var distances;
        if (this._distanceMatrix) {
          distances = this._distanceMatrix;
        } else {
          distances = new shortestpaths_1.Calculator(N, this._links, Layout2.getSourceIndex, Layout2.getTargetIndex, function(l) {
            return _this.getLinkLength(l);
          }).DistanceMatrix();
          G = descent_1.Descent.createSquareMatrix(N, function() {
            return 2;
          });
          this._links.forEach(function(l) {
            if (typeof l.source == "number")
              l.source = _this._nodes[l.source];
            if (typeof l.target == "number")
              l.target = _this._nodes[l.target];
          });
          this._links.forEach(function(e) {
            var u4 = Layout2.getSourceIndex(e), v2 = Layout2.getTargetIndex(e);
            G[u4][v2] = G[v2][u4] = e.weight || 1;
          });
        }
        var D3 = descent_1.Descent.createSquareMatrix(N, function(i2, j2) {
          return distances[i2][j2];
        });
        if (this._rootGroup && typeof this._rootGroup.groups !== "undefined") {
          var i = n;
          var addAttraction = function(i2, j2, strength, idealDistance) {
            G[i2][j2] = G[j2][i2] = strength;
            D3[i2][j2] = D3[j2][i2] = idealDistance;
          };
          this._groups.forEach(function(g) {
            addAttraction(i, i + 1, _this._groupCompactness, 0.1);
            x4[i] = 0, y4[i++] = 0;
            x4[i] = 0, y4[i++] = 0;
          });
        } else
          this._rootGroup = { leaves: this._nodes, groups: [] };
        var curConstraints = this._constraints || [];
        if (this._directedLinkConstraints) {
          this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;
          curConstraints = curConstraints.concat(linklengths_1.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, this.linkAccessor));
        }
        this.avoidOverlaps(false);
        this._descent = new descent_1.Descent([x4, y4], D3);
        this._descent.locks.clear();
        for (var i = 0; i < n; ++i) {
          var o = this._nodes[i];
          if (o.fixed) {
            o.px = o.x;
            o.py = o.y;
            var p = [o.x, o.y];
            this._descent.locks.add(i, p);
          }
        }
        this._descent.threshold = this._threshold;
        this.initialLayout(initialUnconstrainedIterations, x4, y4);
        if (curConstraints.length > 0)
          this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();
        this._descent.run(initialUserConstraintIterations);
        this.separateOverlappingComponents(w, h, centerGraph);
        this.avoidOverlaps(ao);
        if (ao) {
          this._nodes.forEach(function(v2, i2) {
            v2.x = x4[i2], v2.y = y4[i2];
          });
          this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();
          this._nodes.forEach(function(v2, i2) {
            x4[i2] = v2.x, y4[i2] = v2.y;
          });
        }
        this._descent.G = G;
        this._descent.run(initialAllConstraintsIterations);
        if (gridSnapIterations) {
          this._descent.snapStrength = 1e3;
          this._descent.snapGridSize = this._nodes[0].width;
          this._descent.numGridSnapNodes = n;
          this._descent.scaleSnapByMaxH = n != N;
          var G0 = descent_1.Descent.createSquareMatrix(N, function(i2, j2) {
            if (i2 >= n || j2 >= n)
              return G[i2][j2];
            return 0;
          });
          this._descent.G = G0;
          this._descent.run(gridSnapIterations);
        }
        this.updateNodePositions();
        this.separateOverlappingComponents(w, h, centerGraph);
        return keepRunning ? this.resume() : this;
      };
      Layout2.prototype.initialLayout = function(iterations2, x4, y4) {
        if (this._groups.length > 0 && iterations2 > 0) {
          var n = this._nodes.length;
          var edges = this._links.map(function(e) {
            return { source: e.source.index, target: e.target.index };
          });
          var vs = this._nodes.map(function(v2) {
            return { index: v2.index };
          });
          this._groups.forEach(function(g, i) {
            vs.push({ index: g.index = n + i });
          });
          this._groups.forEach(function(g, i) {
            if (typeof g.leaves !== "undefined")
              g.leaves.forEach(function(v2) {
                return edges.push({ source: g.index, target: v2.index });
              });
            if (typeof g.groups !== "undefined")
              g.groups.forEach(function(gg) {
                return edges.push({ source: g.index, target: gg.index });
              });
          });
          new Layout2().size(this.size()).nodes(vs).links(edges).avoidOverlaps(false).linkDistance(this.linkDistance()).symmetricDiffLinkLengths(5).convergenceThreshold(1e-4).start(iterations2, 0, 0, 0, false);
          this._nodes.forEach(function(v2) {
            x4[v2.index] = vs[v2.index].x;
            y4[v2.index] = vs[v2.index].y;
          });
        } else {
          this._descent.run(iterations2);
        }
      };
      Layout2.prototype.separateOverlappingComponents = function(width, height, centerGraph) {
        var _this = this;
        if (centerGraph === void 0) {
          centerGraph = true;
        }
        if (!this._distanceMatrix && this._handleDisconnected) {
          var x_1 = this._descent.x[0], y_1 = this._descent.x[1];
          this._nodes.forEach(function(v2, i) {
            v2.x = x_1[i], v2.y = y_1[i];
          });
          var graphs = handledisconnected_1.separateGraphs(this._nodes, this._links);
          handledisconnected_1.applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);
          this._nodes.forEach(function(v2, i) {
            _this._descent.x[0][i] = v2.x, _this._descent.x[1][i] = v2.y;
            if (v2.bounds) {
              v2.bounds.setXCentre(v2.x);
              v2.bounds.setYCentre(v2.y);
            }
          });
        }
      };
      Layout2.prototype.resume = function() {
        return this.alpha(0.1);
      };
      Layout2.prototype.stop = function() {
        return this.alpha(0);
      };
      Layout2.prototype.prepareEdgeRouting = function(nodeMargin) {
        if (nodeMargin === void 0) {
          nodeMargin = 0;
        }
        this._visibilityGraph = new geom_1.TangentVisibilityGraph(this._nodes.map(function(v2) {
          return v2.bounds.inflate(-nodeMargin).vertices();
        }));
      };
      Layout2.prototype.routeEdge = function(edge, ah, draw) {
        if (ah === void 0) {
          ah = 5;
        }
        var lineData = [];
        var vg2 = new geom_1.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), port1 = { x: edge.source.x, y: edge.source.y }, port2 = { x: edge.target.x, y: edge.target.y }, start3 = vg2.addPoint(port1, edge.source.index), end2 = vg2.addPoint(port2, edge.target.index);
        vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);
        if (typeof draw !== "undefined") {
          draw(vg2);
        }
        var sourceInd = function(e) {
          return e.source.id;
        }, targetInd = function(e) {
          return e.target.id;
        }, length3 = function(e) {
          return e.length();
        }, spCalc = new shortestpaths_1.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length3), shortestPath = spCalc.PathFromNodeToNode(start3.id, end2.id);
        if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {
          var route = rectangle_1.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);
          lineData = [route.sourceIntersection, route.arrowStart];
        } else {
          var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];
          for (var i = n; i >= 0; --i)
            lineData.push(vg2.V[shortestPath[i]].p);
          lineData.push(rectangle_1.makeEdgeTo(q, edge.target.innerBounds, ah));
        }
        return lineData;
      };
      Layout2.getSourceIndex = function(e) {
        return typeof e.source === "number" ? e.source : e.source.index;
      };
      Layout2.getTargetIndex = function(e) {
        return typeof e.target === "number" ? e.target : e.target.index;
      };
      Layout2.linkId = function(e) {
        return Layout2.getSourceIndex(e) + "-" + Layout2.getTargetIndex(e);
      };
      Layout2.dragStart = function(d) {
        if (isGroup(d)) {
          Layout2.storeOffset(d, Layout2.dragOrigin(d));
        } else {
          Layout2.stopNode(d);
          d.fixed |= 2;
        }
      };
      Layout2.stopNode = function(v2) {
        v2.px = v2.x;
        v2.py = v2.y;
      };
      Layout2.storeOffset = function(d, origin) {
        if (typeof d.leaves !== "undefined") {
          d.leaves.forEach(function(v2) {
            v2.fixed |= 2;
            Layout2.stopNode(v2);
            v2._dragGroupOffsetX = v2.x - origin.x;
            v2._dragGroupOffsetY = v2.y - origin.y;
          });
        }
        if (typeof d.groups !== "undefined") {
          d.groups.forEach(function(g) {
            return Layout2.storeOffset(g, origin);
          });
        }
      };
      Layout2.dragOrigin = function(d) {
        if (isGroup(d)) {
          return {
            x: d.bounds.cx(),
            y: d.bounds.cy()
          };
        } else {
          return d;
        }
      };
      Layout2.drag = function(d, position) {
        if (isGroup(d)) {
          if (typeof d.leaves !== "undefined") {
            d.leaves.forEach(function(v2) {
              d.bounds.setXCentre(position.x);
              d.bounds.setYCentre(position.y);
              v2.px = v2._dragGroupOffsetX + position.x;
              v2.py = v2._dragGroupOffsetY + position.y;
            });
          }
          if (typeof d.groups !== "undefined") {
            d.groups.forEach(function(g) {
              return Layout2.drag(g, position);
            });
          }
        } else {
          d.px = position.x;
          d.py = position.y;
        }
      };
      Layout2.dragEnd = function(d) {
        if (isGroup(d)) {
          if (typeof d.leaves !== "undefined") {
            d.leaves.forEach(function(v2) {
              Layout2.dragEnd(v2);
              delete v2._dragGroupOffsetX;
              delete v2._dragGroupOffsetY;
            });
          }
          if (typeof d.groups !== "undefined") {
            d.groups.forEach(Layout2.dragEnd);
          }
        } else {
          d.fixed &= ~6;
        }
      };
      Layout2.mouseOver = function(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
      };
      Layout2.mouseOut = function(d) {
        d.fixed &= ~4;
      };
      return Layout2;
    }();
    exports.Layout = Layout;
  }
});

// node_modules/webcola/dist/src/adaptor.js
var require_adaptor = __commonJS({
  "node_modules/webcola/dist/src/adaptor.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
          d2.__proto__ = b10;
        } || function(d2, b10) {
          for (var p in b10) if (b10.hasOwnProperty(p)) d2[p] = b10[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var layout_1 = require_layout();
    var LayoutAdaptor = function(_super) {
      __extends(LayoutAdaptor2, _super);
      function LayoutAdaptor2(options) {
        var _this = _super.call(this) || this;
        var self2 = _this;
        var o = options;
        if (o.trigger) {
          _this.trigger = o.trigger;
        }
        if (o.kick) {
          _this.kick = o.kick;
        }
        if (o.drag) {
          _this.drag = o.drag;
        }
        if (o.on) {
          _this.on = o.on;
        }
        _this.dragstart = _this.dragStart = layout_1.Layout.dragStart;
        _this.dragend = _this.dragEnd = layout_1.Layout.dragEnd;
        return _this;
      }
      LayoutAdaptor2.prototype.trigger = function(e) {
      };
      ;
      LayoutAdaptor2.prototype.kick = function() {
      };
      ;
      LayoutAdaptor2.prototype.drag = function() {
      };
      ;
      LayoutAdaptor2.prototype.on = function(eventType, listener) {
        return this;
      };
      ;
      return LayoutAdaptor2;
    }(layout_1.Layout);
    exports.LayoutAdaptor = LayoutAdaptor;
    function adaptor(options) {
      return new LayoutAdaptor(options);
    }
    exports.adaptor = adaptor;
  }
});

// node_modules/webcola/dist/src/d3v3adaptor.js
var require_d3v3adaptor = __commonJS({
  "node_modules/webcola/dist/src/d3v3adaptor.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
          d2.__proto__ = b10;
        } || function(d2, b10) {
          for (var p in b10) if (b10.hasOwnProperty(p)) d2[p] = b10[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var layout_1 = require_layout();
    var D3StyleLayoutAdaptor = function(_super) {
      __extends(D3StyleLayoutAdaptor2, _super);
      function D3StyleLayoutAdaptor2() {
        var _this = _super.call(this) || this;
        _this.event = d3.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function() {
          if (!drag2) {
            var drag2 = d3.behavior.drag().origin(layout_1.Layout.dragOrigin).on("dragstart.d3adaptor", layout_1.Layout.dragStart).on("drag.d3adaptor", function(d) {
              layout_1.Layout.drag(d, d3.event);
              d3layout.resume();
            }).on("dragend.d3adaptor", layout_1.Layout.dragEnd);
          }
          if (!arguments.length)
            return drag2;
          this.call(drag2);
        };
        return _this;
      }
      D3StyleLayoutAdaptor2.prototype.trigger = function(e) {
        var d3event = { type: layout_1.EventType[e.type], alpha: e.alpha, stress: e.stress };
        this.event[d3event.type](d3event);
      };
      D3StyleLayoutAdaptor2.prototype.kick = function() {
        var _this = this;
        d3.timer(function() {
          return _super.prototype.tick.call(_this);
        });
      };
      D3StyleLayoutAdaptor2.prototype.on = function(eventType, listener) {
        if (typeof eventType === "string") {
          this.event.on(eventType, listener);
        } else {
          this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
      };
      return D3StyleLayoutAdaptor2;
    }(layout_1.Layout);
    exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;
    function d3adaptor3() {
      return new D3StyleLayoutAdaptor();
    }
    exports.d3adaptor = d3adaptor3;
  }
});

// node_modules/webcola/dist/src/d3v4adaptor.js
var require_d3v4adaptor = __commonJS({
  "node_modules/webcola/dist/src/d3v4adaptor.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
          d2.__proto__ = b10;
        } || function(d2, b10) {
          for (var p in b10) if (b10.hasOwnProperty(p)) d2[p] = b10[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var layout_1 = require_layout();
    var D3StyleLayoutAdaptor = function(_super) {
      __extends(D3StyleLayoutAdaptor2, _super);
      function D3StyleLayoutAdaptor2(d3Context) {
        var _this = _super.call(this) || this;
        _this.d3Context = d3Context;
        _this.event = d3Context.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function() {
          if (!drag2) {
            var drag2 = d3Context.drag().subject(layout_1.Layout.dragOrigin).on("start.d3adaptor", layout_1.Layout.dragStart).on("drag.d3adaptor", function(d) {
              layout_1.Layout.drag(d, d3Context.event);
              d3layout.resume();
            }).on("end.d3adaptor", layout_1.Layout.dragEnd);
          }
          if (!arguments.length)
            return drag2;
          arguments[0].call(drag2);
        };
        return _this;
      }
      D3StyleLayoutAdaptor2.prototype.trigger = function(e) {
        var d3event = { type: layout_1.EventType[e.type], alpha: e.alpha, stress: e.stress };
        this.event.call(d3event.type, d3event);
      };
      D3StyleLayoutAdaptor2.prototype.kick = function() {
        var _this = this;
        var t = this.d3Context.timer(function() {
          return _super.prototype.tick.call(_this) && t.stop();
        });
      };
      D3StyleLayoutAdaptor2.prototype.on = function(eventType, listener) {
        if (typeof eventType === "string") {
          this.event.on(eventType, listener);
        } else {
          this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
      };
      return D3StyleLayoutAdaptor2;
    }(layout_1.Layout);
    exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;
  }
});

// node_modules/webcola/dist/src/d3adaptor.js
var require_d3adaptor = __commonJS({
  "node_modules/webcola/dist/src/d3adaptor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3v3 = require_d3v3adaptor();
    var d3v4 = require_d3v4adaptor();
    function d3adaptor3(d3Context) {
      if (!d3Context || isD3V3(d3Context)) {
        return new d3v3.D3StyleLayoutAdaptor();
      }
      return new d3v4.D3StyleLayoutAdaptor(d3Context);
    }
    exports.d3adaptor = d3adaptor3;
    function isD3V3(d3Context) {
      var v3exp = /^3\./;
      return d3Context.version && d3Context.version.match(v3exp) !== null;
    }
  }
});

// node_modules/webcola/dist/src/gridrouter.js
var require_gridrouter = __commonJS({
  "node_modules/webcola/dist/src/gridrouter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rectangle_1 = require_rectangle();
    var vpsc_1 = require_vpsc();
    var shortestpaths_1 = require_shortestpaths();
    var NodeWrapper = /* @__PURE__ */ function() {
      function NodeWrapper2(id2, rect, children2) {
        this.id = id2;
        this.rect = rect;
        this.children = children2;
        this.leaf = typeof children2 === "undefined" || children2.length === 0;
      }
      return NodeWrapper2;
    }();
    exports.NodeWrapper = NodeWrapper;
    var Vert = /* @__PURE__ */ function() {
      function Vert2(id2, x4, y4, node, line) {
        if (node === void 0) {
          node = null;
        }
        if (line === void 0) {
          line = null;
        }
        this.id = id2;
        this.x = x4;
        this.y = y4;
        this.node = node;
        this.line = line;
      }
      return Vert2;
    }();
    exports.Vert = Vert;
    var LongestCommonSubsequence = function() {
      function LongestCommonSubsequence2(s2, t) {
        this.s = s2;
        this.t = t;
        var mf = LongestCommonSubsequence2.findMatch(s2, t);
        var tr = t.slice(0).reverse();
        var mr = LongestCommonSubsequence2.findMatch(s2, tr);
        if (mf.length >= mr.length) {
          this.length = mf.length;
          this.si = mf.si;
          this.ti = mf.ti;
          this.reversed = false;
        } else {
          this.length = mr.length;
          this.si = mr.si;
          this.ti = t.length - mr.ti - mr.length;
          this.reversed = true;
        }
      }
      LongestCommonSubsequence2.findMatch = function(s2, t) {
        var m3 = s2.length;
        var n = t.length;
        var match = { length: 0, si: -1, ti: -1 };
        var l = new Array(m3);
        for (var i = 0; i < m3; i++) {
          l[i] = new Array(n);
          for (var j = 0; j < n; j++)
            if (s2[i] === t[j]) {
              var v2 = l[i][j] = i === 0 || j === 0 ? 1 : l[i - 1][j - 1] + 1;
              if (v2 > match.length) {
                match.length = v2;
                match.si = i - v2 + 1;
                match.ti = j - v2 + 1;
              }
              ;
            } else
              l[i][j] = 0;
        }
        return match;
      };
      LongestCommonSubsequence2.prototype.getSequence = function() {
        return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];
      };
      return LongestCommonSubsequence2;
    }();
    exports.LongestCommonSubsequence = LongestCommonSubsequence;
    var GridRouter = function() {
      function GridRouter2(originalnodes, accessor, groupPadding) {
        var _this = this;
        if (groupPadding === void 0) {
          groupPadding = 12;
        }
        this.originalnodes = originalnodes;
        this.groupPadding = groupPadding;
        this.leaves = null;
        this.nodes = originalnodes.map(function(v2, i) {
          return new NodeWrapper(i, accessor.getBounds(v2), accessor.getChildren(v2));
        });
        this.leaves = this.nodes.filter(function(v2) {
          return v2.leaf;
        });
        this.groups = this.nodes.filter(function(g) {
          return !g.leaf;
        });
        this.cols = this.getGridLines("x");
        this.rows = this.getGridLines("y");
        this.groups.forEach(function(v2) {
          return v2.children.forEach(function(c6) {
            return _this.nodes[c6].parent = v2;
          });
        });
        this.root = { children: [] };
        this.nodes.forEach(function(v2) {
          if (typeof v2.parent === "undefined") {
            v2.parent = _this.root;
            _this.root.children.push(v2.id);
          }
          v2.ports = [];
        });
        this.backToFront = this.nodes.slice(0);
        this.backToFront.sort(function(x4, y4) {
          return _this.getDepth(x4) - _this.getDepth(y4);
        });
        var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function(g) {
          return !g.leaf;
        });
        frontToBackGroups.forEach(function(v2) {
          var r = rectangle_1.Rectangle.empty();
          v2.children.forEach(function(c6) {
            return r = r.union(_this.nodes[c6].rect);
          });
          v2.rect = r.inflate(_this.groupPadding);
        });
        var colMids = this.midPoints(this.cols.map(function(r) {
          return r.pos;
        }));
        var rowMids = this.midPoints(this.rows.map(function(r) {
          return r.pos;
        }));
        var rowx = colMids[0], rowX = colMids[colMids.length - 1];
        var coly = rowMids[0], colY = rowMids[rowMids.length - 1];
        var hlines = this.rows.map(function(r) {
          return { x1: rowx, x2: rowX, y1: r.pos, y2: r.pos };
        }).concat(rowMids.map(function(m3) {
          return { x1: rowx, x2: rowX, y1: m3, y2: m3 };
        }));
        var vlines = this.cols.map(function(c6) {
          return { x1: c6.pos, x2: c6.pos, y1: coly, y2: colY };
        }).concat(colMids.map(function(m3) {
          return { x1: m3, x2: m3, y1: coly, y2: colY };
        }));
        var lines = hlines.concat(vlines);
        lines.forEach(function(l) {
          return l.verts = [];
        });
        this.verts = [];
        this.edges = [];
        hlines.forEach(function(h) {
          return vlines.forEach(function(v2) {
            var p = new Vert(_this.verts.length, v2.x1, h.y1);
            h.verts.push(p);
            v2.verts.push(p);
            _this.verts.push(p);
            var i = _this.backToFront.length;
            while (i-- > 0) {
              var node = _this.backToFront[i], r = node.rect;
              var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());
              if (dx < r.width() / 2 && dy < r.height() / 2) {
                p.node = node;
                break;
              }
            }
          });
        });
        lines.forEach(function(l, li) {
          _this.nodes.forEach(function(v3, i2) {
            v3.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function(intersect2, j) {
              var p = new Vert(_this.verts.length, intersect2.x, intersect2.y, v3, l);
              _this.verts.push(p);
              l.verts.push(p);
              v3.ports.push(p);
            });
          });
          var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;
          var delta = function(a4, b) {
            return isHoriz ? b.x - a4.x : b.y - a4.y;
          };
          l.verts.sort(delta);
          for (var i = 1; i < l.verts.length; i++) {
            var u4 = l.verts[i - 1], v2 = l.verts[i];
            if (u4.node && u4.node === v2.node && u4.node.leaf)
              continue;
            _this.edges.push({ source: u4.id, target: v2.id, length: Math.abs(delta(u4, v2)) });
          }
        });
      }
      GridRouter2.prototype.avg = function(a4) {
        return a4.reduce(function(x4, y4) {
          return x4 + y4;
        }) / a4.length;
      };
      GridRouter2.prototype.getGridLines = function(axis2) {
        var columns = [];
        var ls = this.leaves.slice(0, this.leaves.length);
        while (ls.length > 0) {
          var overlapping = ls.filter(function(v2) {
            return v2.rect["overlap" + axis2.toUpperCase()](ls[0].rect);
          });
          var col = {
            nodes: overlapping,
            pos: this.avg(overlapping.map(function(v2) {
              return v2.rect["c" + axis2]();
            }))
          };
          columns.push(col);
          col.nodes.forEach(function(v2) {
            return ls.splice(ls.indexOf(v2), 1);
          });
        }
        columns.sort(function(a4, b) {
          return a4.pos - b.pos;
        });
        return columns;
      };
      GridRouter2.prototype.getDepth = function(v2) {
        var depth = 0;
        while (v2.parent !== this.root) {
          depth++;
          v2 = v2.parent;
        }
        return depth;
      };
      GridRouter2.prototype.midPoints = function(a4) {
        var gap = a4[1] - a4[0];
        var mids = [a4[0] - gap / 2];
        for (var i = 1; i < a4.length; i++) {
          mids.push((a4[i] + a4[i - 1]) / 2);
        }
        mids.push(a4[a4.length - 1] + gap / 2);
        return mids;
      };
      GridRouter2.prototype.findLineage = function(v2) {
        var lineage = [v2];
        do {
          v2 = v2.parent;
          lineage.push(v2);
        } while (v2 !== this.root);
        return lineage.reverse();
      };
      GridRouter2.prototype.findAncestorPathBetween = function(a4, b) {
        var aa2 = this.findLineage(a4), ba = this.findLineage(b), i = 0;
        while (aa2[i] === ba[i])
          i++;
        return { commonAncestor: aa2[i - 1], lineages: aa2.slice(i).concat(ba.slice(i)) };
      };
      GridRouter2.prototype.siblingObstacles = function(a4, b) {
        var _this = this;
        var path3 = this.findAncestorPathBetween(a4, b);
        var lineageLookup = {};
        path3.lineages.forEach(function(v2) {
          return lineageLookup[v2.id] = {};
        });
        var obstacles = path3.commonAncestor.children.filter(function(v2) {
          return !(v2 in lineageLookup);
        });
        path3.lineages.filter(function(v2) {
          return v2.parent !== path3.commonAncestor;
        }).forEach(function(v2) {
          return obstacles = obstacles.concat(v2.parent.children.filter(function(c6) {
            return c6 !== v2.id;
          }));
        });
        return obstacles.map(function(v2) {
          return _this.nodes[v2];
        });
      };
      GridRouter2.getSegmentSets = function(routes, x4, y4) {
        var vsegments = [];
        for (var ei = 0; ei < routes.length; ei++) {
          var route = routes[ei];
          for (var si = 0; si < route.length; si++) {
            var s2 = route[si];
            s2.edgeid = ei;
            s2.i = si;
            var sdx = s2[1][x4] - s2[0][x4];
            if (Math.abs(sdx) < 0.1) {
              vsegments.push(s2);
            }
          }
        }
        vsegments.sort(function(a4, b) {
          return a4[0][x4] - b[0][x4];
        });
        var vsegmentsets = [];
        var segmentset = null;
        for (var i = 0; i < vsegments.length; i++) {
          var s2 = vsegments[i];
          if (!segmentset || Math.abs(s2[0][x4] - segmentset.pos) > 0.1) {
            segmentset = { pos: s2[0][x4], segments: [] };
            vsegmentsets.push(segmentset);
          }
          segmentset.segments.push(s2);
        }
        return vsegmentsets;
      };
      GridRouter2.nudgeSegs = function(x4, y4, routes, segments, leftOf, gap) {
        var n = segments.length;
        if (n <= 1)
          return;
        var vs = segments.map(function(s3) {
          return new vpsc_1.Variable(s3[0][x4]);
        });
        var cs = [];
        for (var i = 0; i < n; i++) {
          for (var j = 0; j < n; j++) {
            if (i === j)
              continue;
            var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e22 = s2.edgeid, lind = -1, rind = -1;
            if (x4 == "x") {
              if (leftOf(e1, e22)) {
                if (s1[0][y4] < s1[1][y4]) {
                  lind = j, rind = i;
                } else {
                  lind = i, rind = j;
                }
              }
            } else {
              if (leftOf(e1, e22)) {
                if (s1[0][y4] < s1[1][y4]) {
                  lind = i, rind = j;
                } else {
                  lind = j, rind = i;
                }
              }
            }
            if (lind >= 0) {
              cs.push(new vpsc_1.Constraint(vs[lind], vs[rind], gap));
            }
          }
        }
        var solver = new vpsc_1.Solver(vs, cs);
        solver.solve();
        vs.forEach(function(v2, i2) {
          var s3 = segments[i2];
          var pos = v2.position();
          s3[0][x4] = s3[1][x4] = pos;
          var route = routes[s3.edgeid];
          if (s3.i > 0)
            route[s3.i - 1][1][x4] = pos;
          if (s3.i < route.length - 1)
            route[s3.i + 1][0][x4] = pos;
        });
      };
      GridRouter2.nudgeSegments = function(routes, x4, y4, leftOf, gap) {
        var vsegmentsets = GridRouter2.getSegmentSets(routes, x4, y4);
        for (var i = 0; i < vsegmentsets.length; i++) {
          var ss = vsegmentsets[i];
          var events = [];
          for (var j = 0; j < ss.segments.length; j++) {
            var s2 = ss.segments[j];
            events.push({ type: 0, s: s2, pos: Math.min(s2[0][y4], s2[1][y4]) });
            events.push({ type: 1, s: s2, pos: Math.max(s2[0][y4], s2[1][y4]) });
          }
          events.sort(function(a4, b) {
            return a4.pos - b.pos + a4.type - b.type;
          });
          var open = [];
          var openCount = 0;
          events.forEach(function(e) {
            if (e.type === 0) {
              open.push(e.s);
              openCount++;
            } else {
              openCount--;
            }
            if (openCount == 0) {
              GridRouter2.nudgeSegs(x4, y4, routes, open, leftOf, gap);
              open = [];
            }
          });
        }
      };
      GridRouter2.prototype.routeEdges = function(edges, nudgeGap, source, target) {
        var _this = this;
        var routePaths = edges.map(function(e) {
          return _this.route(source(e), target(e));
        });
        var order2 = GridRouter2.orderEdges(routePaths);
        var routes = routePaths.map(function(e) {
          return GridRouter2.makeSegments(e);
        });
        GridRouter2.nudgeSegments(routes, "x", "y", order2, nudgeGap);
        GridRouter2.nudgeSegments(routes, "y", "x", order2, nudgeGap);
        GridRouter2.unreverseEdges(routes, routePaths);
        return routes;
      };
      GridRouter2.unreverseEdges = function(routes, routePaths) {
        routes.forEach(function(segments, i) {
          var path3 = routePaths[i];
          if (path3.reversed) {
            segments.reverse();
            segments.forEach(function(segment) {
              segment.reverse();
            });
          }
        });
      };
      GridRouter2.angleBetween2Lines = function(line1, line2) {
        var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);
        var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);
        var diff = angle1 - angle2;
        if (diff > Math.PI || diff < -Math.PI) {
          diff = angle2 - angle1;
        }
        return diff;
      };
      GridRouter2.isLeft = function(a4, b, c6) {
        return (b.x - a4.x) * (c6.y - a4.y) - (b.y - a4.y) * (c6.x - a4.x) <= 0;
      };
      GridRouter2.getOrder = function(pairs2) {
        var outgoing = {};
        for (var i = 0; i < pairs2.length; i++) {
          var p = pairs2[i];
          if (typeof outgoing[p.l] === "undefined")
            outgoing[p.l] = {};
          outgoing[p.l][p.r] = true;
        }
        return function(l, r) {
          return typeof outgoing[l] !== "undefined" && outgoing[l][r];
        };
      };
      GridRouter2.orderEdges = function(edges) {
        var edgeOrder = [];
        for (var i = 0; i < edges.length - 1; i++) {
          for (var j = i + 1; j < edges.length; j++) {
            var e = edges[i], f = edges[j], lcs = new LongestCommonSubsequence(e, f);
            var u4, vi, vj;
            if (lcs.length === 0)
              continue;
            if (lcs.reversed) {
              f.reverse();
              f.reversed = true;
              lcs = new LongestCommonSubsequence(e, f);
            }
            if ((lcs.si <= 0 || lcs.ti <= 0) && (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {
              edgeOrder.push({ l: i, r: j });
              continue;
            }
            if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {
              u4 = e[lcs.si + 1];
              vj = e[lcs.si - 1];
              vi = f[lcs.ti - 1];
            } else {
              u4 = e[lcs.si + lcs.length - 2];
              vi = e[lcs.si + lcs.length];
              vj = f[lcs.ti + lcs.length];
            }
            if (GridRouter2.isLeft(u4, vi, vj)) {
              edgeOrder.push({ l: j, r: i });
            } else {
              edgeOrder.push({ l: i, r: j });
            }
          }
        }
        return GridRouter2.getOrder(edgeOrder);
      };
      GridRouter2.makeSegments = function(path3) {
        function copyPoint(p) {
          return { x: p.x, y: p.y };
        }
        var isStraight = function(a5, b10, c7) {
          return Math.abs((b10.x - a5.x) * (c7.y - a5.y) - (b10.y - a5.y) * (c7.x - a5.x)) < 1e-3;
        };
        var segments = [];
        var a4 = copyPoint(path3[0]);
        for (var i = 1; i < path3.length; i++) {
          var b = copyPoint(path3[i]), c6 = i < path3.length - 1 ? path3[i + 1] : null;
          if (!c6 || !isStraight(a4, b, c6)) {
            segments.push([a4, b]);
            a4 = b;
          }
        }
        return segments;
      };
      GridRouter2.prototype.route = function(s2, t) {
        var _this = this;
        var source = this.nodes[s2], target = this.nodes[t];
        this.obstacles = this.siblingObstacles(source, target);
        var obstacleLookup = {};
        this.obstacles.forEach(function(o) {
          return obstacleLookup[o.id] = o;
        });
        this.passableEdges = this.edges.filter(function(e) {
          var u5 = _this.verts[e.source], v3 = _this.verts[e.target];
          return !(u5.node && u5.node.id in obstacleLookup || v3.node && v3.node.id in obstacleLookup);
        });
        for (var i = 1; i < source.ports.length; i++) {
          var u4 = source.ports[0].id;
          var v2 = source.ports[i].id;
          this.passableEdges.push({
            source: u4,
            target: v2,
            length: 0
          });
        }
        for (var i = 1; i < target.ports.length; i++) {
          var u4 = target.ports[0].id;
          var v2 = target.ports[i].id;
          this.passableEdges.push({
            source: u4,
            target: v2,
            length: 0
          });
        }
        var getSource = function(e) {
          return e.source;
        }, getTarget = function(e) {
          return e.target;
        }, getLength = function(e) {
          return e.length;
        };
        var shortestPathCalculator = new shortestpaths_1.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);
        var bendPenalty = function(u5, v3, w) {
          var a4 = _this.verts[u5], b = _this.verts[v3], c6 = _this.verts[w];
          var dx = Math.abs(c6.x - a4.x), dy = Math.abs(c6.y - a4.y);
          if (a4.node === source && a4.node === b.node || b.node === target && b.node === c6.node)
            return 0;
          return dx > 1 && dy > 1 ? 1e3 : 0;
        };
        var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);
        var pathPoints = shortestPath.reverse().map(function(vi) {
          return _this.verts[vi];
        });
        pathPoints.push(this.nodes[target.id].ports[0]);
        return pathPoints.filter(function(v3, i2) {
          return !(i2 < pathPoints.length - 1 && pathPoints[i2 + 1].node === source && v3.node === source || i2 > 0 && v3.node === target && pathPoints[i2 - 1].node === target);
        });
      };
      GridRouter2.getRoutePath = function(route, cornerradius, arrowwidth, arrowheight) {
        var result = {
          routepath: "M " + route[0][0].x + " " + route[0][0].y + " ",
          arrowpath: ""
        };
        if (route.length > 1) {
          for (var i = 0; i < route.length; i++) {
            var li = route[i];
            var x4 = li[1].x, y4 = li[1].y;
            var dx = x4 - li[0].x;
            var dy = y4 - li[0].y;
            if (i < route.length - 1) {
              if (Math.abs(dx) > 0) {
                x4 -= dx / Math.abs(dx) * cornerradius;
              } else {
                y4 -= dy / Math.abs(dy) * cornerradius;
              }
              result.routepath += "L " + x4 + " " + y4 + " ";
              var l = route[i + 1];
              var x06 = l[0].x, y06 = l[0].y;
              var x12 = l[1].x;
              var y12 = l[1].y;
              dx = x12 - x06;
              dy = y12 - y06;
              var angle2 = GridRouter2.angleBetween2Lines(li, l) < 0 ? 1 : 0;
              var x22, y22;
              if (Math.abs(dx) > 0) {
                x22 = x06 + dx / Math.abs(dx) * cornerradius;
                y22 = y06;
              } else {
                x22 = x06;
                y22 = y06 + dy / Math.abs(dy) * cornerradius;
              }
              var cx = Math.abs(x22 - x4);
              var cy = Math.abs(y22 - y4);
              result.routepath += "A " + cx + " " + cy + " 0 0 " + angle2 + " " + x22 + " " + y22 + " ";
            } else {
              var arrowtip = [x4, y4];
              var arrowcorner1, arrowcorner2;
              if (Math.abs(dx) > 0) {
                x4 -= dx / Math.abs(dx) * arrowheight;
                arrowcorner1 = [x4, y4 + arrowwidth];
                arrowcorner2 = [x4, y4 - arrowwidth];
              } else {
                y4 -= dy / Math.abs(dy) * arrowheight;
                arrowcorner1 = [x4 + arrowwidth, y4];
                arrowcorner2 = [x4 - arrowwidth, y4];
              }
              result.routepath += "L " + x4 + " " + y4 + " ";
              if (arrowheight > 0) {
                result.arrowpath = "M " + arrowtip[0] + " " + arrowtip[1] + " L " + arrowcorner1[0] + " " + arrowcorner1[1] + " L " + arrowcorner2[0] + " " + arrowcorner2[1];
              }
            }
          }
        } else {
          var li = route[0];
          var x4 = li[1].x, y4 = li[1].y;
          var dx = x4 - li[0].x;
          var dy = y4 - li[0].y;
          var arrowtip = [x4, y4];
          var arrowcorner1, arrowcorner2;
          if (Math.abs(dx) > 0) {
            x4 -= dx / Math.abs(dx) * arrowheight;
            arrowcorner1 = [x4, y4 + arrowwidth];
            arrowcorner2 = [x4, y4 - arrowwidth];
          } else {
            y4 -= dy / Math.abs(dy) * arrowheight;
            arrowcorner1 = [x4 + arrowwidth, y4];
            arrowcorner2 = [x4 - arrowwidth, y4];
          }
          result.routepath += "L " + x4 + " " + y4 + " ";
          if (arrowheight > 0) {
            result.arrowpath = "M " + arrowtip[0] + " " + arrowtip[1] + " L " + arrowcorner1[0] + " " + arrowcorner1[1] + " L " + arrowcorner2[0] + " " + arrowcorner2[1];
          }
        }
        return result;
      };
      return GridRouter2;
    }();
    exports.GridRouter = GridRouter;
  }
});

// node_modules/webcola/dist/src/layout3d.js
var require_layout3d = __commonJS({
  "node_modules/webcola/dist/src/layout3d.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shortestpaths_1 = require_shortestpaths();
    var descent_1 = require_descent();
    var rectangle_1 = require_rectangle();
    var linklengths_1 = require_linklengths();
    var Link3D = function() {
      function Link3D2(source, target) {
        this.source = source;
        this.target = target;
      }
      Link3D2.prototype.actualLength = function(x4) {
        var _this = this;
        return Math.sqrt(x4.reduce(function(c6, v2) {
          var dx = v2[_this.target] - v2[_this.source];
          return c6 + dx * dx;
        }, 0));
      };
      return Link3D2;
    }();
    exports.Link3D = Link3D;
    var Node3D = /* @__PURE__ */ function() {
      function Node3D2(x4, y4, z) {
        if (x4 === void 0) {
          x4 = 0;
        }
        if (y4 === void 0) {
          y4 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        this.x = x4;
        this.y = y4;
        this.z = z;
      }
      return Node3D2;
    }();
    exports.Node3D = Node3D;
    var Layout3D = function() {
      function Layout3D2(nodes, links, idealLinkLength) {
        var _this = this;
        if (idealLinkLength === void 0) {
          idealLinkLength = 1;
        }
        this.nodes = nodes;
        this.links = links;
        this.idealLinkLength = idealLinkLength;
        this.constraints = null;
        this.useJaccardLinkLengths = true;
        this.result = new Array(Layout3D2.k);
        for (var i = 0; i < Layout3D2.k; ++i) {
          this.result[i] = new Array(nodes.length);
        }
        nodes.forEach(function(v2, i2) {
          for (var _i = 0, _a2 = Layout3D2.dims; _i < _a2.length; _i++) {
            var dim = _a2[_i];
            if (typeof v2[dim] == "undefined")
              v2[dim] = Math.random();
          }
          _this.result[0][i2] = v2.x;
          _this.result[1][i2] = v2.y;
          _this.result[2][i2] = v2.z;
        });
      }
      ;
      Layout3D2.prototype.linkLength = function(l) {
        return l.actualLength(this.result);
      };
      Layout3D2.prototype.start = function(iterations2) {
        var _this = this;
        if (iterations2 === void 0) {
          iterations2 = 100;
        }
        var n = this.nodes.length;
        var linkAccessor = new LinkAccessor();
        if (this.useJaccardLinkLengths)
          linklengths_1.jaccardLinkLengths(this.links, linkAccessor, 1.5);
        this.links.forEach(function(e) {
          return e.length *= _this.idealLinkLength;
        });
        var distanceMatrix = new shortestpaths_1.Calculator(n, this.links, function(e) {
          return e.source;
        }, function(e) {
          return e.target;
        }, function(e) {
          return e.length;
        }).DistanceMatrix();
        var D3 = descent_1.Descent.createSquareMatrix(n, function(i2, j) {
          return distanceMatrix[i2][j];
        });
        var G = descent_1.Descent.createSquareMatrix(n, function() {
          return 2;
        });
        this.links.forEach(function(_a2) {
          var source = _a2.source, target = _a2.target;
          return G[source][target] = G[target][source] = 1;
        });
        this.descent = new descent_1.Descent(this.result, D3);
        this.descent.threshold = 1e-3;
        this.descent.G = G;
        if (this.constraints)
          this.descent.project = new rectangle_1.Projection(this.nodes, null, null, this.constraints).projectFunctions();
        for (var i = 0; i < this.nodes.length; i++) {
          var v2 = this.nodes[i];
          if (v2.fixed) {
            this.descent.locks.add(i, [v2.x, v2.y, v2.z]);
          }
        }
        this.descent.run(iterations2);
        return this;
      };
      Layout3D2.prototype.tick = function() {
        this.descent.locks.clear();
        for (var i = 0; i < this.nodes.length; i++) {
          var v2 = this.nodes[i];
          if (v2.fixed) {
            this.descent.locks.add(i, [v2.x, v2.y, v2.z]);
          }
        }
        return this.descent.rungeKutta();
      };
      Layout3D2.dims = ["x", "y", "z"];
      Layout3D2.k = Layout3D2.dims.length;
      return Layout3D2;
    }();
    exports.Layout3D = Layout3D;
    var LinkAccessor = function() {
      function LinkAccessor2() {
      }
      LinkAccessor2.prototype.getSourceIndex = function(e) {
        return e.source;
      };
      LinkAccessor2.prototype.getTargetIndex = function(e) {
        return e.target;
      };
      LinkAccessor2.prototype.getLength = function(e) {
        return e.length;
      };
      LinkAccessor2.prototype.setLength = function(e, l) {
        e.length = l;
      };
      return LinkAccessor2;
    }();
  }
});

// node_modules/webcola/dist/src/batch.js
var require_batch = __commonJS({
  "node_modules/webcola/dist/src/batch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var layout_1 = require_layout();
    var gridrouter_1 = require_gridrouter();
    function gridify(pgLayout, nudgeGap, margin, groupMargin) {
      pgLayout.cola.start(0, 0, 0, 10, false);
      var gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);
      return gridrouter.routeEdges(pgLayout.powerGraph.powerEdges, nudgeGap, function(e) {
        return e.source.routerNode.id;
      }, function(e) {
        return e.target.routerNode.id;
      });
    }
    exports.gridify = gridify;
    function route(nodes, groups2, margin, groupMargin) {
      nodes.forEach(function(d) {
        d.routerNode = {
          name: d.name,
          bounds: d.bounds.inflate(-margin)
        };
      });
      groups2.forEach(function(d) {
        d.routerNode = {
          bounds: d.bounds.inflate(-groupMargin),
          children: (typeof d.groups !== "undefined" ? d.groups.map(function(c6) {
            return nodes.length + c6.id;
          }) : []).concat(typeof d.leaves !== "undefined" ? d.leaves.map(function(c6) {
            return c6.index;
          }) : [])
        };
      });
      var gridRouterNodes = nodes.concat(groups2).map(function(d, i) {
        d.routerNode.id = i;
        return d.routerNode;
      });
      return new gridrouter_1.GridRouter(gridRouterNodes, {
        getChildren: function(v2) {
          return v2.children;
        },
        getBounds: function(v2) {
          return v2.bounds;
        }
      }, margin - groupMargin);
    }
    function powerGraphGridLayout(graph, size, grouppadding) {
      var powerGraph;
      graph.nodes.forEach(function(v2, i) {
        return v2.index = i;
      });
      new layout_1.Layout().avoidOverlaps(false).nodes(graph.nodes).links(graph.links).powerGraphGroups(function(d) {
        powerGraph = d;
        powerGraph.groups.forEach(function(v2) {
          return v2.padding = grouppadding;
        });
      });
      var n = graph.nodes.length;
      var edges = [];
      var vs = graph.nodes.slice(0);
      vs.forEach(function(v2, i) {
        return v2.index = i;
      });
      powerGraph.groups.forEach(function(g) {
        var sourceInd = g.index = g.id + n;
        vs.push(g);
        if (typeof g.leaves !== "undefined")
          g.leaves.forEach(function(v2) {
            return edges.push({ source: sourceInd, target: v2.index });
          });
        if (typeof g.groups !== "undefined")
          g.groups.forEach(function(gg) {
            return edges.push({ source: sourceInd, target: gg.id + n });
          });
      });
      powerGraph.powerEdges.forEach(function(e) {
        edges.push({ source: e.source.index, target: e.target.index });
      });
      new layout_1.Layout().size(size).nodes(vs).links(edges).avoidOverlaps(false).linkDistance(30).symmetricDiffLinkLengths(5).convergenceThreshold(1e-4).start(100, 0, 0, 0, false);
      return {
        cola: new layout_1.Layout().convergenceThreshold(1e-3).size(size).avoidOverlaps(true).nodes(graph.nodes).links(graph.links).groupCompactness(1e-4).linkDistance(30).symmetricDiffLinkLengths(5).powerGraphGroups(function(d) {
          powerGraph = d;
          powerGraph.groups.forEach(function(v2) {
            v2.padding = grouppadding;
          });
        }).start(50, 0, 100, 0, false),
        powerGraph
      };
    }
    exports.powerGraphGridLayout = powerGraphGridLayout;
  }
});

// node_modules/webcola/dist/index.js
var require_dist = __commonJS({
  "node_modules/webcola/dist/index.js"(exports) {
    "use strict";
    function __export2(m3) {
      for (var p in m3) if (!exports.hasOwnProperty(p)) exports[p] = m3[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_adaptor());
    __export2(require_d3adaptor());
    __export2(require_descent());
    __export2(require_geom());
    __export2(require_gridrouter());
    __export2(require_handledisconnected());
    __export2(require_layout());
    __export2(require_layout3d());
    __export2(require_linklengths());
    __export2(require_powergraph());
    __export2(require_pqueue());
    __export2(require_rbtree());
    __export2(require_rectangle());
    __export2(require_shortestpaths());
    __export2(require_vpsc());
    __export2(require_batch());
  }
});

// node_modules/@dagrejs/graphlib/lib/graph.js
var require_graph = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/graph.js"(exports, module) {
    "use strict";
    var DEFAULT_EDGE_NAME = "\0";
    var GRAPH_NODE = "\0";
    var EDGE_KEY_DELIM = "";
    var Graph = class {
      constructor(opts) {
        __publicField(this, "_isDirected", true);
        __publicField(this, "_isMultigraph", false);
        __publicField(this, "_isCompound", false);
        // Label for the graph itself
        __publicField(this, "_label");
        // Defaults to be set when creating a new node
        __publicField(this, "_defaultNodeLabelFn", () => void 0);
        // Defaults to be set when creating a new edge
        __publicField(this, "_defaultEdgeLabelFn", () => void 0);
        // v -> label
        __publicField(this, "_nodes", {});
        // v -> edgeObj
        __publicField(this, "_in", {});
        // u -> v -> Number
        __publicField(this, "_preds", {});
        // v -> edgeObj
        __publicField(this, "_out", {});
        // v -> w -> Number
        __publicField(this, "_sucs", {});
        // e -> edgeObj
        __publicField(this, "_edgeObjs", {});
        // e -> label
        __publicField(this, "_edgeLabels", {});
        /* Number of nodes in the graph. Should only be changed by the implementation. */
        __publicField(this, "_nodeCount", 0);
        /* Number of edges in the graph. Should only be changed by the implementation. */
        __publicField(this, "_edgeCount", 0);
        __publicField(this, "_parent");
        __publicField(this, "_children");
        if (opts) {
          this._isDirected = opts.hasOwnProperty("directed") ? opts.directed : true;
          this._isMultigraph = opts.hasOwnProperty("multigraph") ? opts.multigraph : false;
          this._isCompound = opts.hasOwnProperty("compound") ? opts.compound : false;
        }
        if (this._isCompound) {
          this._parent = {};
          this._children = {};
          this._children[GRAPH_NODE] = {};
        }
      }
      /* === Graph functions ========= */
      /**
       * Whether graph was created with 'directed' flag set to true or not.
       */
      isDirected() {
        return this._isDirected;
      }
      /**
       * Whether graph was created with 'multigraph' flag set to true or not.
       */
      isMultigraph() {
        return this._isMultigraph;
      }
      /**
       * Whether graph was created with 'compound' flag set to true or not.
       */
      isCompound() {
        return this._isCompound;
      }
      /**
       * Sets the label of the graph.
       */
      setGraph(label) {
        this._label = label;
        return this;
      }
      /**
       * Gets the graph label.
       */
      graph() {
        return this._label;
      }
      /* === Node functions ========== */
      /**
       * Sets the default node label. If newDefault is a function, it will be
       * invoked ach time when setting a label for a node. Otherwise, this label
       * will be assigned as default label in case if no label was specified while
       * setting a node.
       * Complexity: O(1).
       */
      setDefaultNodeLabel(newDefault) {
        this._defaultNodeLabelFn = newDefault;
        if (typeof newDefault !== "function") {
          this._defaultNodeLabelFn = () => newDefault;
        }
        return this;
      }
      /**
       * Gets the number of nodes in the graph.
       * Complexity: O(1).
       */
      nodeCount() {
        return this._nodeCount;
      }
      /**
       * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
       * not included in list.
       * Complexity: O(1).
       */
      nodes() {
        return Object.keys(this._nodes);
      }
      /**
       * Gets list of nodes without in-edges.
       * Complexity: O(|V|).
       */
      sources() {
        var self2 = this;
        return this.nodes().filter((v2) => Object.keys(self2._in[v2]).length === 0);
      }
      /**
       * Gets list of nodes without out-edges.
       * Complexity: O(|V|).
       */
      sinks() {
        var self2 = this;
        return this.nodes().filter((v2) => Object.keys(self2._out[v2]).length === 0);
      }
      /**
       * Invokes setNode method for each node in names list.
       * Complexity: O(|names|).
       */
      setNodes(vs, value) {
        var args = arguments;
        var self2 = this;
        vs.forEach(function(v2) {
          if (args.length > 1) {
            self2.setNode(v2, value);
          } else {
            self2.setNode(v2);
          }
        });
        return this;
      }
      /**
       * Creates or updates the value for the node v in the graph. If label is supplied
       * it is set as the value for the node. If label is not supplied and the node was
       * created by this call then the default node label will be assigned.
       * Complexity: O(1).
       */
      setNode(v2, value) {
        if (this._nodes.hasOwnProperty(v2)) {
          if (arguments.length > 1) {
            this._nodes[v2] = value;
          }
          return this;
        }
        this._nodes[v2] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v2);
        if (this._isCompound) {
          this._parent[v2] = GRAPH_NODE;
          this._children[v2] = {};
          this._children[GRAPH_NODE][v2] = true;
        }
        this._in[v2] = {};
        this._preds[v2] = {};
        this._out[v2] = {};
        this._sucs[v2] = {};
        ++this._nodeCount;
        return this;
      }
      /**
       * Gets the label of node with specified name.
       * Complexity: O(|V|).
       */
      node(v2) {
        return this._nodes[v2];
      }
      /**
       * Detects whether graph has a node with specified name or not.
       */
      hasNode(v2) {
        return this._nodes.hasOwnProperty(v2);
      }
      /**
       * Remove the node with the name from the graph or do nothing if the node is not in
       * the graph. If the node was removed this function also removes any incident
       * edges.
       * Complexity: O(1).
       */
      removeNode(v2) {
        var self2 = this;
        if (this._nodes.hasOwnProperty(v2)) {
          var removeEdge = (e) => self2.removeEdge(self2._edgeObjs[e]);
          delete this._nodes[v2];
          if (this._isCompound) {
            this._removeFromParentsChildList(v2);
            delete this._parent[v2];
            this.children(v2).forEach(function(child) {
              self2.setParent(child);
            });
            delete this._children[v2];
          }
          Object.keys(this._in[v2]).forEach(removeEdge);
          delete this._in[v2];
          delete this._preds[v2];
          Object.keys(this._out[v2]).forEach(removeEdge);
          delete this._out[v2];
          delete this._sucs[v2];
          --this._nodeCount;
        }
        return this;
      }
      /**
       * Sets node p as a parent for node v if it is defined, or removes the
       * parent for v if p is undefined. Method throws an exception in case of
       * invoking it in context of noncompound graph.
       * Average-case complexity: O(1).
       */
      setParent(v2, parent) {
        if (!this._isCompound) {
          throw new Error("Cannot set parent in a non-compound graph");
        }
        if (parent === void 0) {
          parent = GRAPH_NODE;
        } else {
          parent += "";
          for (var ancestor = parent; ancestor !== void 0; ancestor = this.parent(ancestor)) {
            if (ancestor === v2) {
              throw new Error("Setting " + parent + " as parent of " + v2 + " would create a cycle");
            }
          }
          this.setNode(parent);
        }
        this.setNode(v2);
        this._removeFromParentsChildList(v2);
        this._parent[v2] = parent;
        this._children[parent][v2] = true;
        return this;
      }
      _removeFromParentsChildList(v2) {
        delete this._children[this._parent[v2]][v2];
      }
      /**
       * Gets parent node for node v.
       * Complexity: O(1).
       */
      parent(v2) {
        if (this._isCompound) {
          var parent = this._parent[v2];
          if (parent !== GRAPH_NODE) {
            return parent;
          }
        }
      }
      /**
       * Gets list of direct children of node v.
       * Complexity: O(1).
       */
      children(v2 = GRAPH_NODE) {
        if (this._isCompound) {
          var children2 = this._children[v2];
          if (children2) {
            return Object.keys(children2);
          }
        } else if (v2 === GRAPH_NODE) {
          return this.nodes();
        } else if (this.hasNode(v2)) {
          return [];
        }
      }
      /**
       * Return all nodes that are predecessors of the specified node or undefined if node v is not in
       * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
       * Complexity: O(|V|).
       */
      predecessors(v2) {
        var predsV = this._preds[v2];
        if (predsV) {
          return Object.keys(predsV);
        }
      }
      /**
       * Return all nodes that are successors of the specified node or undefined if node v is not in
       * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
       * Complexity: O(|V|).
       */
      successors(v2) {
        var sucsV = this._sucs[v2];
        if (sucsV) {
          return Object.keys(sucsV);
        }
      }
      /**
       * Return all nodes that are predecessors or successors of the specified node or undefined if
       * node v is not in the graph.
       * Complexity: O(|V|).
       */
      neighbors(v2) {
        var preds = this.predecessors(v2);
        if (preds) {
          const union2 = new Set(preds);
          for (var succ of this.successors(v2)) {
            union2.add(succ);
          }
          return Array.from(union2.values());
        }
      }
      isLeaf(v2) {
        var neighbors;
        if (this.isDirected()) {
          neighbors = this.successors(v2);
        } else {
          neighbors = this.neighbors(v2);
        }
        return neighbors.length === 0;
      }
      /**
       * Creates new graph with nodes filtered via filter. Edges incident to rejected node
       * are also removed. In case of compound graph, if parent is rejected by filter,
       * than all its children are rejected too.
       * Average-case complexity: O(|E|+|V|).
       */
      filterNodes(filter3) {
        var copy3 = new this.constructor({
          directed: this._isDirected,
          multigraph: this._isMultigraph,
          compound: this._isCompound
        });
        copy3.setGraph(this.graph());
        var self2 = this;
        Object.entries(this._nodes).forEach(function([v2, value]) {
          if (filter3(v2)) {
            copy3.setNode(v2, value);
          }
        });
        Object.values(this._edgeObjs).forEach(function(e) {
          if (copy3.hasNode(e.v) && copy3.hasNode(e.w)) {
            copy3.setEdge(e, self2.edge(e));
          }
        });
        var parents = {};
        function findParent(v2) {
          var parent = self2.parent(v2);
          if (parent === void 0 || copy3.hasNode(parent)) {
            parents[v2] = parent;
            return parent;
          } else if (parent in parents) {
            return parents[parent];
          } else {
            return findParent(parent);
          }
        }
        if (this._isCompound) {
          copy3.nodes().forEach((v2) => copy3.setParent(v2, findParent(v2)));
        }
        return copy3;
      }
      /* === Edge functions ========== */
      /**
       * Sets the default edge label or factory function. This label will be
       * assigned as default label in case if no label was specified while setting
       * an edge or this function will be invoked each time when setting an edge
       * with no label specified and returned value * will be used as a label for edge.
       * Complexity: O(1).
       */
      setDefaultEdgeLabel(newDefault) {
        this._defaultEdgeLabelFn = newDefault;
        if (typeof newDefault !== "function") {
          this._defaultEdgeLabelFn = () => newDefault;
        }
        return this;
      }
      /**
       * Gets the number of edges in the graph.
       * Complexity: O(1).
       */
      edgeCount() {
        return this._edgeCount;
      }
      /**
       * Gets edges of the graph. In case of compound graph subgraphs are not considered.
       * Complexity: O(|E|).
       */
      edges() {
        return Object.values(this._edgeObjs);
      }
      /**
       * Establish an edges path over the nodes in nodes list. If some edge is already
       * exists, it will update its label, otherwise it will create an edge between pair
       * of nodes with label provided or default label if no label provided.
       * Complexity: O(|nodes|).
       */
      setPath(vs, value) {
        var self2 = this;
        var args = arguments;
        vs.reduce(function(v2, w) {
          if (args.length > 1) {
            self2.setEdge(v2, w, value);
          } else {
            self2.setEdge(v2, w);
          }
          return w;
        });
        return this;
      }
      /**
       * Creates or updates the label for the edge (v, w) with the optionally supplied
       * name. If label is supplied it is set as the value for the edge. If label is not
       * supplied and the edge was created by this call then the default edge label will
       * be assigned. The name parameter is only useful with multigraphs.
       */
      setEdge() {
        var v2, w, name, value;
        var valueSpecified = false;
        var arg0 = arguments[0];
        if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
          v2 = arg0.v;
          w = arg0.w;
          name = arg0.name;
          if (arguments.length === 2) {
            value = arguments[1];
            valueSpecified = true;
          }
        } else {
          v2 = arg0;
          w = arguments[1];
          name = arguments[3];
          if (arguments.length > 2) {
            value = arguments[2];
            valueSpecified = true;
          }
        }
        v2 = "" + v2;
        w = "" + w;
        if (name !== void 0) {
          name = "" + name;
        }
        var e = edgeArgsToId(this._isDirected, v2, w, name);
        if (this._edgeLabels.hasOwnProperty(e)) {
          if (valueSpecified) {
            this._edgeLabels[e] = value;
          }
          return this;
        }
        if (name !== void 0 && !this._isMultigraph) {
          throw new Error("Cannot set a named edge when isMultigraph = false");
        }
        this.setNode(v2);
        this.setNode(w);
        this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v2, w, name);
        var edgeObj = edgeArgsToObj(this._isDirected, v2, w, name);
        v2 = edgeObj.v;
        w = edgeObj.w;
        Object.freeze(edgeObj);
        this._edgeObjs[e] = edgeObj;
        incrementOrInitEntry(this._preds[w], v2);
        incrementOrInitEntry(this._sucs[v2], w);
        this._in[w][e] = edgeObj;
        this._out[v2][e] = edgeObj;
        this._edgeCount++;
        return this;
      }
      /**
       * Gets the label for the specified edge.
       * Complexity: O(1).
       */
      edge(v2, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w, name);
        return this._edgeLabels[e];
      }
      /**
       * Gets the label for the specified edge and converts it to an object.
       * Complexity: O(1)
       */
      edgeAsObj() {
        const edge = this.edge(...arguments);
        if (typeof edge !== "object") {
          return { label: edge };
        }
        return edge;
      }
      /**
       * Detects whether the graph contains specified edge or not. No subgraphs are considered.
       * Complexity: O(1).
       */
      hasEdge(v2, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w, name);
        return this._edgeLabels.hasOwnProperty(e);
      }
      /**
       * Removes the specified edge from the graph. No subgraphs are considered.
       * Complexity: O(1).
       */
      removeEdge(v2, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w, name);
        var edge = this._edgeObjs[e];
        if (edge) {
          v2 = edge.v;
          w = edge.w;
          delete this._edgeLabels[e];
          delete this._edgeObjs[e];
          decrementOrRemoveEntry(this._preds[w], v2);
          decrementOrRemoveEntry(this._sucs[v2], w);
          delete this._in[w][e];
          delete this._out[v2][e];
          this._edgeCount--;
        }
        return this;
      }
      /**
       * Return all edges that point to the node v. Optionally filters those edges down to just those
       * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
       * Complexity: O(|E|).
       */
      inEdges(v2, u4) {
        var inV = this._in[v2];
        if (inV) {
          var edges = Object.values(inV);
          if (!u4) {
            return edges;
          }
          return edges.filter((edge) => edge.v === u4);
        }
      }
      /**
       * Return all edges that are pointed at by node v. Optionally filters those edges down to just
       * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
       * Complexity: O(|E|).
       */
      outEdges(v2, w) {
        var outV = this._out[v2];
        if (outV) {
          var edges = Object.values(outV);
          if (!w) {
            return edges;
          }
          return edges.filter((edge) => edge.w === w);
        }
      }
      /**
       * Returns all edges to or from node v regardless of direction. Optionally filters those edges
       * down to just those between nodes v and w regardless of direction.
       * Complexity: O(|E|).
       */
      nodeEdges(v2, w) {
        var inEdges = this.inEdges(v2, w);
        if (inEdges) {
          return inEdges.concat(this.outEdges(v2, w));
        }
      }
    };
    function incrementOrInitEntry(map5, k2) {
      if (map5[k2]) {
        map5[k2]++;
      } else {
        map5[k2] = 1;
      }
    }
    function decrementOrRemoveEntry(map5, k2) {
      if (!--map5[k2]) {
        delete map5[k2];
      }
    }
    function edgeArgsToId(isDirected, v_, w_, name) {
      var v2 = "" + v_;
      var w = "" + w_;
      if (!isDirected && v2 > w) {
        var tmp = v2;
        v2 = w;
        w = tmp;
      }
      return v2 + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name === void 0 ? DEFAULT_EDGE_NAME : name);
    }
    function edgeArgsToObj(isDirected, v_, w_, name) {
      var v2 = "" + v_;
      var w = "" + w_;
      if (!isDirected && v2 > w) {
        var tmp = v2;
        v2 = w;
        w = tmp;
      }
      var edgeObj = { v: v2, w };
      if (name) {
        edgeObj.name = name;
      }
      return edgeObj;
    }
    function edgeObjToId(isDirected, edgeObj) {
      return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
    }
    module.exports = Graph;
  }
});

// node_modules/@dagrejs/graphlib/lib/version.js
var require_version = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/version.js"(exports, module) {
    module.exports = "2.2.2";
  }
});

// node_modules/@dagrejs/graphlib/lib/index.js
var require_lib = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/index.js"(exports, module) {
    module.exports = {
      Graph: require_graph(),
      version: require_version()
    };
  }
});

// node_modules/@dagrejs/graphlib/lib/json.js
var require_json = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/json.js"(exports, module) {
    var Graph = require_graph();
    module.exports = {
      write: write2,
      read: read2
    };
    function write2(g) {
      var json = {
        options: {
          directed: g.isDirected(),
          multigraph: g.isMultigraph(),
          compound: g.isCompound()
        },
        nodes: writeNodes(g),
        edges: writeEdges(g)
      };
      if (g.graph() !== void 0) {
        json.value = structuredClone(g.graph());
      }
      return json;
    }
    function writeNodes(g) {
      return g.nodes().map(function(v2) {
        var nodeValue = g.node(v2);
        var parent = g.parent(v2);
        var node = { v: v2 };
        if (nodeValue !== void 0) {
          node.value = nodeValue;
        }
        if (parent !== void 0) {
          node.parent = parent;
        }
        return node;
      });
    }
    function writeEdges(g) {
      return g.edges().map(function(e) {
        var edgeValue = g.edge(e);
        var edge = { v: e.v, w: e.w };
        if (e.name !== void 0) {
          edge.name = e.name;
        }
        if (edgeValue !== void 0) {
          edge.value = edgeValue;
        }
        return edge;
      });
    }
    function read2(json) {
      var g = new Graph(json.options).setGraph(json.value);
      json.nodes.forEach(function(entry) {
        g.setNode(entry.v, entry.value);
        if (entry.parent) {
          g.setParent(entry.v, entry.parent);
        }
      });
      json.edges.forEach(function(entry) {
        g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
      });
      return g;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/components.js
var require_components = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/components.js"(exports, module) {
    module.exports = components;
    function components(g) {
      var visited = {};
      var cmpts = [];
      var cmpt;
      function dfs(v2) {
        if (visited.hasOwnProperty(v2)) return;
        visited[v2] = true;
        cmpt.push(v2);
        g.successors(v2).forEach(dfs);
        g.predecessors(v2).forEach(dfs);
      }
      g.nodes().forEach(function(v2) {
        cmpt = [];
        dfs(v2);
        if (cmpt.length) {
          cmpts.push(cmpt);
        }
      });
      return cmpts;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/data/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/data/priority-queue.js"(exports, module) {
    var PriorityQueue = class {
      constructor() {
        __publicField(this, "_arr", []);
        __publicField(this, "_keyIndices", {});
      }
      /**
       * Returns the number of elements in the queue. Takes `O(1)` time.
       */
      size() {
        return this._arr.length;
      }
      /**
       * Returns the keys that are in the queue. Takes `O(n)` time.
       */
      keys() {
        return this._arr.map(function(x4) {
          return x4.key;
        });
      }
      /**
       * Returns `true` if **key** is in the queue and `false` if not.
       */
      has(key) {
        return this._keyIndices.hasOwnProperty(key);
      }
      /**
       * Returns the priority for **key**. If **key** is not present in the queue
       * then this function returns `undefined`. Takes `O(1)` time.
       *
       * @param {Object} key
       */
      priority(key) {
        var index4 = this._keyIndices[key];
        if (index4 !== void 0) {
          return this._arr[index4].priority;
        }
      }
      /**
       * Returns the key for the minimum element in this queue. If the queue is
       * empty this function throws an Error. Takes `O(1)` time.
       */
      min() {
        if (this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return this._arr[0].key;
      }
      /**
       * Inserts a new key into the priority queue. If the key already exists in
       * the queue this function returns `false`; otherwise it will return `true`.
       * Takes `O(n)` time.
       *
       * @param {Object} key the key to add
       * @param {Number} priority the initial priority for the key
       */
      add(key, priority) {
        var keyIndices = this._keyIndices;
        key = String(key);
        if (!keyIndices.hasOwnProperty(key)) {
          var arr = this._arr;
          var index4 = arr.length;
          keyIndices[key] = index4;
          arr.push({ key, priority });
          this._decrease(index4);
          return true;
        }
        return false;
      }
      /**
       * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
       */
      removeMin() {
        this._swap(0, this._arr.length - 1);
        var min4 = this._arr.pop();
        delete this._keyIndices[min4.key];
        this._heapify(0);
        return min4.key;
      }
      /**
       * Decreases the priority for **key** to **priority**. If the new priority is
       * greater than the previous priority, this function will throw an Error.
       *
       * @param {Object} key the key for which to raise priority
       * @param {Number} priority the new priority for the key
       */
      decrease(key, priority) {
        var index4 = this._keyIndices[key];
        if (priority > this._arr[index4].priority) {
          throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index4].priority + " New: " + priority);
        }
        this._arr[index4].priority = priority;
        this._decrease(index4);
      }
      _heapify(i) {
        var arr = this._arr;
        var l = 2 * i;
        var r = l + 1;
        var largest = i;
        if (l < arr.length) {
          largest = arr[l].priority < arr[largest].priority ? l : largest;
          if (r < arr.length) {
            largest = arr[r].priority < arr[largest].priority ? r : largest;
          }
          if (largest !== i) {
            this._swap(i, largest);
            this._heapify(largest);
          }
        }
      }
      _decrease(index4) {
        var arr = this._arr;
        var priority = arr[index4].priority;
        var parent;
        while (index4 !== 0) {
          parent = index4 >> 1;
          if (arr[parent].priority < priority) {
            break;
          }
          this._swap(index4, parent);
          index4 = parent;
        }
      }
      _swap(i, j) {
        var arr = this._arr;
        var keyIndices = this._keyIndices;
        var origArrI = arr[i];
        var origArrJ = arr[j];
        arr[i] = origArrJ;
        arr[j] = origArrI;
        keyIndices[origArrJ.key] = i;
        keyIndices[origArrI.key] = j;
      }
    };
    module.exports = PriorityQueue;
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js"(exports, module) {
    var PriorityQueue = require_priority_queue();
    module.exports = dijkstra;
    var DEFAULT_WEIGHT_FUNC = () => 1;
    function dijkstra(g, source, weightFn, edgeFn) {
      return runDijkstra(
        g,
        String(source),
        weightFn || DEFAULT_WEIGHT_FUNC,
        edgeFn || function(v2) {
          return g.outEdges(v2);
        }
      );
    }
    function runDijkstra(g, source, weightFn, edgeFn) {
      var results = {};
      var pq = new PriorityQueue();
      var v2, vEntry;
      var updateNeighbors = function(edge) {
        var w = edge.v !== v2 ? edge.v : edge.w;
        var wEntry = results[w];
        var weight = weightFn(edge);
        var distance = vEntry.distance + weight;
        if (weight < 0) {
          throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance < wEntry.distance) {
          wEntry.distance = distance;
          wEntry.predecessor = v2;
          pq.decrease(w, distance);
        }
      };
      g.nodes().forEach(function(v3) {
        var distance = v3 === source ? 0 : Number.POSITIVE_INFINITY;
        results[v3] = { distance };
        pq.add(v3, distance);
      });
      while (pq.size() > 0) {
        v2 = pq.removeMin();
        vEntry = results[v2];
        if (vEntry.distance === Number.POSITIVE_INFINITY) {
          break;
        }
        edgeFn(v2).forEach(updateNeighbors);
      }
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js
var require_dijkstra_all = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js"(exports, module) {
    var dijkstra = require_dijkstra();
    module.exports = dijkstraAll;
    function dijkstraAll(g, weightFunc, edgeFunc) {
      return g.nodes().reduce(function(acc, v2) {
        acc[v2] = dijkstra(g, v2, weightFunc, edgeFunc);
        return acc;
      }, {});
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/tarjan.js
var require_tarjan = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/tarjan.js"(exports, module) {
    module.exports = tarjan;
    function tarjan(g) {
      var index4 = 0;
      var stack = [];
      var visited = {};
      var results = [];
      function dfs(v2) {
        var entry = visited[v2] = {
          onStack: true,
          lowlink: index4,
          index: index4++
        };
        stack.push(v2);
        g.successors(v2).forEach(function(w2) {
          if (!visited.hasOwnProperty(w2)) {
            dfs(w2);
            entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink);
          } else if (visited[w2].onStack) {
            entry.lowlink = Math.min(entry.lowlink, visited[w2].index);
          }
        });
        if (entry.lowlink === entry.index) {
          var cmpt = [];
          var w;
          do {
            w = stack.pop();
            visited[w].onStack = false;
            cmpt.push(w);
          } while (v2 !== w);
          results.push(cmpt);
        }
      }
      g.nodes().forEach(function(v2) {
        if (!visited.hasOwnProperty(v2)) {
          dfs(v2);
        }
      });
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js
var require_find_cycles = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js"(exports, module) {
    var tarjan = require_tarjan();
    module.exports = findCycles;
    function findCycles(g) {
      return tarjan(g).filter(function(cmpt) {
        return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
      });
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js
var require_floyd_warshall = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js"(exports, module) {
    module.exports = floydWarshall;
    var DEFAULT_WEIGHT_FUNC = () => 1;
    function floydWarshall(g, weightFn, edgeFn) {
      return runFloydWarshall(
        g,
        weightFn || DEFAULT_WEIGHT_FUNC,
        edgeFn || function(v2) {
          return g.outEdges(v2);
        }
      );
    }
    function runFloydWarshall(g, weightFn, edgeFn) {
      var results = {};
      var nodes = g.nodes();
      nodes.forEach(function(v2) {
        results[v2] = {};
        results[v2][v2] = { distance: 0 };
        nodes.forEach(function(w) {
          if (v2 !== w) {
            results[v2][w] = { distance: Number.POSITIVE_INFINITY };
          }
        });
        edgeFn(v2).forEach(function(edge) {
          var w = edge.v === v2 ? edge.w : edge.v;
          var d = weightFn(edge);
          results[v2][w] = { distance: d, predecessor: v2 };
        });
      });
      nodes.forEach(function(k2) {
        var rowK = results[k2];
        nodes.forEach(function(i) {
          var rowI = results[i];
          nodes.forEach(function(j) {
            var ik = rowI[k2];
            var kj = rowK[j];
            var ij = rowI[j];
            var altDistance = ik.distance + kj.distance;
            if (altDistance < ij.distance) {
              ij.distance = altDistance;
              ij.predecessor = kj.predecessor;
            }
          });
        });
      });
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/topsort.js
var require_topsort = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/topsort.js"(exports, module) {
    function topsort(g) {
      var visited = {};
      var stack = {};
      var results = [];
      function visit(node) {
        if (stack.hasOwnProperty(node)) {
          throw new CycleException();
        }
        if (!visited.hasOwnProperty(node)) {
          stack[node] = true;
          visited[node] = true;
          g.predecessors(node).forEach(visit);
          delete stack[node];
          results.push(node);
        }
      }
      g.sinks().forEach(visit);
      if (Object.keys(visited).length !== g.nodeCount()) {
        throw new CycleException();
      }
      return results;
    }
    var CycleException = class extends Error {
      constructor() {
        super(...arguments);
      }
    };
    module.exports = topsort;
    topsort.CycleException = CycleException;
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js
var require_is_acyclic = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js"(exports, module) {
    var topsort = require_topsort();
    module.exports = isAcyclic;
    function isAcyclic(g) {
      try {
        topsort(g);
      } catch (e) {
        if (e instanceof topsort.CycleException) {
          return false;
        }
        throw e;
      }
      return true;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dfs.js
var require_dfs = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dfs.js"(exports, module) {
    module.exports = dfs;
    function dfs(g, vs, order2) {
      if (!Array.isArray(vs)) {
        vs = [vs];
      }
      var navigation = g.isDirected() ? (v2) => g.successors(v2) : (v2) => g.neighbors(v2);
      var orderFunc = order2 === "post" ? postOrderDfs : preOrderDfs;
      var acc = [];
      var visited = {};
      vs.forEach((v2) => {
        if (!g.hasNode(v2)) {
          throw new Error("Graph does not have node: " + v2);
        }
        orderFunc(v2, navigation, visited, acc);
      });
      return acc;
    }
    function postOrderDfs(v2, navigation, visited, acc) {
      var stack = [[v2, false]];
      while (stack.length > 0) {
        var curr = stack.pop();
        if (curr[1]) {
          acc.push(curr[0]);
        } else {
          if (!visited.hasOwnProperty(curr[0])) {
            visited[curr[0]] = true;
            stack.push([curr[0], true]);
            forEachRight(navigation(curr[0]), (w) => stack.push([w, false]));
          }
        }
      }
    }
    function preOrderDfs(v2, navigation, visited, acc) {
      var stack = [v2];
      while (stack.length > 0) {
        var curr = stack.pop();
        if (!visited.hasOwnProperty(curr)) {
          visited[curr] = true;
          acc.push(curr);
          forEachRight(navigation(curr), (w) => stack.push(w));
        }
      }
    }
    function forEachRight(array5, iteratee) {
      var length3 = array5.length;
      while (length3--) {
        iteratee(array5[length3], length3, array5);
      }
      return array5;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/postorder.js
var require_postorder = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/postorder.js"(exports, module) {
    var dfs = require_dfs();
    module.exports = postorder;
    function postorder(g, vs) {
      return dfs(g, vs, "post");
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/preorder.js
var require_preorder = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/preorder.js"(exports, module) {
    var dfs = require_dfs();
    module.exports = preorder;
    function preorder(g, vs) {
      return dfs(g, vs, "pre");
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/prim.js
var require_prim = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/prim.js"(exports, module) {
    var Graph = require_graph();
    var PriorityQueue = require_priority_queue();
    module.exports = prim;
    function prim(g, weightFunc) {
      var result = new Graph();
      var parents = {};
      var pq = new PriorityQueue();
      var v2;
      function updateNeighbors(edge) {
        var w = edge.v === v2 ? edge.w : edge.v;
        var pri = pq.priority(w);
        if (pri !== void 0) {
          var edgeWeight = weightFunc(edge);
          if (edgeWeight < pri) {
            parents[w] = v2;
            pq.decrease(w, edgeWeight);
          }
        }
      }
      if (g.nodeCount() === 0) {
        return result;
      }
      g.nodes().forEach(function(v3) {
        pq.add(v3, Number.POSITIVE_INFINITY);
        result.setNode(v3);
      });
      pq.decrease(g.nodes()[0], 0);
      var init2 = false;
      while (pq.size() > 0) {
        v2 = pq.removeMin();
        if (parents.hasOwnProperty(v2)) {
          result.setEdge(v2, parents[v2]);
        } else if (init2) {
          throw new Error("Input graph is not connected: " + g);
        } else {
          init2 = true;
        }
        g.nodeEdges(v2).forEach(updateNeighbors);
      }
      return result;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/index.js
var require_alg = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/index.js"(exports, module) {
    module.exports = {
      components: require_components(),
      dijkstra: require_dijkstra(),
      dijkstraAll: require_dijkstra_all(),
      findCycles: require_find_cycles(),
      floydWarshall: require_floyd_warshall(),
      isAcyclic: require_is_acyclic(),
      postorder: require_postorder(),
      preorder: require_preorder(),
      prim: require_prim(),
      tarjan: require_tarjan(),
      topsort: require_topsort()
    };
  }
});

// node_modules/@dagrejs/graphlib/index.js
var require_graphlib = __commonJS({
  "node_modules/@dagrejs/graphlib/index.js"(exports, module) {
    var lib = require_lib();
    module.exports = {
      Graph: lib.Graph,
      json: require_json(),
      alg: require_alg(),
      version: lib.version
    };
  }
});

// node_modules/@dagrejs/dagre/lib/data/list.js
var require_list = __commonJS({
  "node_modules/@dagrejs/dagre/lib/data/list.js"(exports, module) {
    var List2 = class {
      constructor() {
        let sentinel = {};
        sentinel._next = sentinel._prev = sentinel;
        this._sentinel = sentinel;
      }
      dequeue() {
        let sentinel = this._sentinel;
        let entry = sentinel._prev;
        if (entry !== sentinel) {
          unlink(entry);
          return entry;
        }
      }
      enqueue(entry) {
        let sentinel = this._sentinel;
        if (entry._prev && entry._next) {
          unlink(entry);
        }
        entry._next = sentinel._next;
        sentinel._next._prev = entry;
        sentinel._next = entry;
        entry._prev = sentinel;
      }
      toString() {
        let strs = [];
        let sentinel = this._sentinel;
        let curr = sentinel._prev;
        while (curr !== sentinel) {
          strs.push(JSON.stringify(curr, filterOutLinks));
          curr = curr._prev;
        }
        return "[" + strs.join(", ") + "]";
      }
    };
    function unlink(entry) {
      entry._prev._next = entry._next;
      entry._next._prev = entry._prev;
      delete entry._next;
      delete entry._prev;
    }
    function filterOutLinks(k2, v2) {
      if (k2 !== "_next" && k2 !== "_prev") {
        return v2;
      }
    }
    module.exports = List2;
  }
});

// node_modules/@dagrejs/dagre/lib/greedy-fas.js
var require_greedy_fas = __commonJS({
  "node_modules/@dagrejs/dagre/lib/greedy-fas.js"(exports, module) {
    var Graph = require_graphlib().Graph;
    var List2 = require_list();
    module.exports = greedyFAS;
    var DEFAULT_WEIGHT_FN = () => 1;
    function greedyFAS(g, weightFn) {
      if (g.nodeCount() <= 1) {
        return [];
      }
      let state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
      let results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
      return results.flatMap((e) => g.outEdges(e.v, e.w));
    }
    function doGreedyFAS(g, buckets, zeroIdx) {
      let results = [];
      let sources = buckets[buckets.length - 1];
      let sinks = buckets[0];
      let entry;
      while (g.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        if (g.nodeCount()) {
          for (let i = buckets.length - 2; i > 0; --i) {
            entry = buckets[i].dequeue();
            if (entry) {
              results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    }
    function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
      let results = collectPredecessors ? [] : void 0;
      g.inEdges(entry.v).forEach((edge) => {
        let weight = g.edge(edge);
        let uEntry = g.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w });
        }
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
      });
      g.outEdges(entry.v).forEach((edge) => {
        let weight = g.edge(edge);
        let w = edge.w;
        let wEntry = g.node(w);
        wEntry["in"] -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
      });
      g.removeNode(entry.v);
      return results;
    }
    function buildState(g, weightFn) {
      let fasGraph = new Graph();
      let maxIn = 0;
      let maxOut = 0;
      g.nodes().forEach((v2) => {
        fasGraph.setNode(v2, { v: v2, "in": 0, out: 0 });
      });
      g.edges().forEach((e) => {
        let prevWeight = fasGraph.edge(e.v, e.w) || 0;
        let weight = weightFn(e);
        let edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e.v, e.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
      });
      let buckets = range4(maxOut + maxIn + 3).map(() => new List2());
      let zeroIdx = maxIn + 1;
      fasGraph.nodes().forEach((v2) => {
        assignBucket(buckets, zeroIdx, fasGraph.node(v2));
      });
      return { graph: fasGraph, buckets, zeroIdx };
    }
    function assignBucket(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    }
    function range4(limit) {
      const range5 = [];
      for (let i = 0; i < limit; i++) {
        range5.push(i);
      }
      return range5;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/util.js
var require_util = __commonJS({
  "node_modules/@dagrejs/dagre/lib/util.js"(exports, module) {
    "use strict";
    var Graph = require_graphlib().Graph;
    module.exports = {
      addBorderNode,
      addDummyNode,
      asNonCompoundGraph,
      buildLayerMatrix,
      intersectRect,
      mapValues,
      maxRank,
      normalizeRanks,
      notime,
      partition,
      pick,
      predecessorWeights,
      range: range4,
      removeEmptyRanks,
      simplify,
      successorWeights,
      time: time2,
      uniqueId,
      zipObject
    };
    function addDummyNode(g, type2, attrs, name) {
      let v2;
      do {
        v2 = uniqueId(name);
      } while (g.hasNode(v2));
      attrs.dummy = type2;
      g.setNode(v2, attrs);
      return v2;
    }
    function simplify(g) {
      let simplified = new Graph().setGraph(g.graph());
      g.nodes().forEach((v2) => simplified.setNode(v2, g.node(v2)));
      g.edges().forEach((e) => {
        let simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
        let label = g.edge(e);
        simplified.setEdge(e.v, e.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    }
    function asNonCompoundGraph(g) {
      let simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
      g.nodes().forEach((v2) => {
        if (!g.children(v2).length) {
          simplified.setNode(v2, g.node(v2));
        }
      });
      g.edges().forEach((e) => {
        simplified.setEdge(e, g.edge(e));
      });
      return simplified;
    }
    function successorWeights(g) {
      let weightMap = g.nodes().map((v2) => {
        let sucs = {};
        g.outEdges(v2).forEach((e) => {
          sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
        });
        return sucs;
      });
      return zipObject(g.nodes(), weightMap);
    }
    function predecessorWeights(g) {
      let weightMap = g.nodes().map((v2) => {
        let preds = {};
        g.inEdges(v2).forEach((e) => {
          preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
        });
        return preds;
      });
      return zipObject(g.nodes(), weightMap);
    }
    function intersectRect(rect, point7) {
      let x4 = rect.x;
      let y4 = rect.y;
      let dx = point7.x - x4;
      let dy = point7.y - y4;
      let w = rect.width / 2;
      let h = rect.height / 2;
      if (!dx && !dy) {
        throw new Error("Not possible to find intersection inside of the rectangle");
      }
      let sx, sy;
      if (Math.abs(dy) * w > Math.abs(dx) * h) {
        if (dy < 0) {
          h = -h;
        }
        sx = h * dx / dy;
        sy = h;
      } else {
        if (dx < 0) {
          w = -w;
        }
        sx = w;
        sy = w * dy / dx;
      }
      return { x: x4 + sx, y: y4 + sy };
    }
    function buildLayerMatrix(g) {
      let layering = range4(maxRank(g) + 1).map(() => []);
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        let rank2 = node.rank;
        if (rank2 !== void 0) {
          layering[rank2][node.order] = v2;
        }
      });
      return layering;
    }
    function normalizeRanks(g) {
      let min4 = Math.min(...g.nodes().map((v2) => {
        let rank2 = g.node(v2).rank;
        if (rank2 === void 0) {
          return Number.MAX_VALUE;
        }
        return rank2;
      }));
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        if (node.hasOwnProperty("rank")) {
          node.rank -= min4;
        }
      });
    }
    function removeEmptyRanks(g) {
      let offset3 = Math.min(...g.nodes().map((v2) => g.node(v2).rank));
      let layers = [];
      g.nodes().forEach((v2) => {
        let rank2 = g.node(v2).rank - offset3;
        if (!layers[rank2]) {
          layers[rank2] = [];
        }
        layers[rank2].push(v2);
      });
      let delta = 0;
      let nodeRankFactor = g.graph().nodeRankFactor;
      Array.from(layers).forEach((vs, i) => {
        if (vs === void 0 && i % nodeRankFactor !== 0) {
          --delta;
        } else if (vs !== void 0 && delta) {
          vs.forEach((v2) => g.node(v2).rank += delta);
        }
      });
    }
    function addBorderNode(g, prefix, rank2, order2) {
      let node = {
        width: 0,
        height: 0
      };
      if (arguments.length >= 4) {
        node.rank = rank2;
        node.order = order2;
      }
      return addDummyNode(g, "border", node, prefix);
    }
    function maxRank(g) {
      return Math.max(...g.nodes().map((v2) => {
        let rank2 = g.node(v2).rank;
        if (rank2 === void 0) {
          return Number.MIN_VALUE;
        }
        return rank2;
      }));
    }
    function partition(collection, fn) {
      let result = { lhs: [], rhs: [] };
      collection.forEach((value) => {
        if (fn(value)) {
          result.lhs.push(value);
        } else {
          result.rhs.push(value);
        }
      });
      return result;
    }
    function time2(name, fn) {
      let start3 = Date.now();
      try {
        return fn();
      } finally {
        console.log(name + " time: " + (Date.now() - start3) + "ms");
      }
    }
    function notime(name, fn) {
      return fn();
    }
    var idCounter = 0;
    function uniqueId(prefix) {
      var id2 = ++idCounter;
      return toString(prefix) + id2;
    }
    function range4(start3, limit, step = 1) {
      if (limit == null) {
        limit = start3;
        start3 = 0;
      }
      let endCon = (i) => i < limit;
      if (step < 0) {
        endCon = (i) => limit < i;
      }
      const range5 = [];
      for (let i = start3; endCon(i); i += step) {
        range5.push(i);
      }
      return range5;
    }
    function pick(source, keys) {
      const dest = {};
      for (const key of keys) {
        if (source[key] !== void 0) {
          dest[key] = source[key];
        }
      }
      return dest;
    }
    function mapValues(obj, funcOrProp) {
      let func = funcOrProp;
      if (typeof funcOrProp === "string") {
        func = (val) => val[funcOrProp];
      }
      return Object.entries(obj).reduce((acc, [k2, v2]) => {
        acc[k2] = func(v2, k2);
        return acc;
      }, {});
    }
    function zipObject(props, values) {
      return props.reduce((acc, key, i) => {
        acc[key] = values[i];
        return acc;
      }, {});
    }
  }
});

// node_modules/@dagrejs/dagre/lib/acyclic.js
var require_acyclic = __commonJS({
  "node_modules/@dagrejs/dagre/lib/acyclic.js"(exports, module) {
    "use strict";
    var greedyFAS = require_greedy_fas();
    var uniqueId = require_util().uniqueId;
    module.exports = {
      run: run3,
      undo
    };
    function run3(g) {
      let fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
      fas.forEach((e) => {
        let label = g.edge(e);
        g.removeEdge(e);
        label.forwardName = e.name;
        label.reversed = true;
        g.setEdge(e.w, e.v, label, uniqueId("rev"));
      });
      function weightFn(g2) {
        return (e) => {
          return g2.edge(e).weight;
        };
      }
    }
    function dfsFAS(g) {
      let fas = [];
      let stack = {};
      let visited = {};
      function dfs(v2) {
        if (visited.hasOwnProperty(v2)) {
          return;
        }
        visited[v2] = true;
        stack[v2] = true;
        g.outEdges(v2).forEach((e) => {
          if (stack.hasOwnProperty(e.w)) {
            fas.push(e);
          } else {
            dfs(e.w);
          }
        });
        delete stack[v2];
      }
      g.nodes().forEach(dfs);
      return fas;
    }
    function undo(g) {
      g.edges().forEach((e) => {
        let label = g.edge(e);
        if (label.reversed) {
          g.removeEdge(e);
          let forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g.setEdge(e.w, e.v, label, forwardName);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/@dagrejs/dagre/lib/normalize.js"(exports, module) {
    "use strict";
    var util = require_util();
    module.exports = {
      run: run3,
      undo
    };
    function run3(g) {
      g.graph().dummyChains = [];
      g.edges().forEach((edge) => normalizeEdge(g, edge));
    }
    function normalizeEdge(g, e) {
      let v2 = e.v;
      let vRank = g.node(v2).rank;
      let w = e.w;
      let wRank = g.node(w).rank;
      let name = e.name;
      let edgeLabel = g.edge(e);
      let labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1) return;
      g.removeEdge(e);
      let dummy, attrs, i;
      for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          width: 0,
          height: 0,
          edgeLabel,
          edgeObj: e,
          rank: vRank
        };
        dummy = util.addDummyNode(g, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g.setEdge(v2, dummy, { weight: edgeLabel.weight }, name);
        if (i === 0) {
          g.graph().dummyChains.push(dummy);
        }
        v2 = dummy;
      }
      g.setEdge(v2, w, { weight: edgeLabel.weight }, name);
    }
    function undo(g) {
      g.graph().dummyChains.forEach((v2) => {
        let node = g.node(v2);
        let origLabel = node.edgeLabel;
        let w;
        g.setEdge(node.edgeObj, origLabel);
        while (node.dummy) {
          w = g.successors(v2)[0];
          g.removeNode(v2);
          origLabel.points.push({ x: node.x, y: node.y });
          if (node.dummy === "edge-label") {
            origLabel.x = node.x;
            origLabel.y = node.y;
            origLabel.width = node.width;
            origLabel.height = node.height;
          }
          v2 = w;
          node = g.node(v2);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/util.js
var require_util2 = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/util.js"(exports, module) {
    "use strict";
    module.exports = {
      longestPath,
      slack
    };
    function longestPath(g) {
      var visited = {};
      function dfs(v2) {
        var label = g.node(v2);
        if (visited.hasOwnProperty(v2)) {
          return label.rank;
        }
        visited[v2] = true;
        var rank2 = Math.min(...g.outEdges(v2).map((e) => {
          if (e == null) {
            return Number.POSITIVE_INFINITY;
          }
          return dfs(e.w) - g.edge(e).minlen;
        }));
        if (rank2 === Number.POSITIVE_INFINITY) {
          rank2 = 0;
        }
        return label.rank = rank2;
      }
      g.sources().forEach(dfs);
    }
    function slack(g, e) {
      return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js
var require_feasible_tree = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js"(exports, module) {
    "use strict";
    var Graph = require_graphlib().Graph;
    var slack = require_util2().slack;
    module.exports = feasibleTree;
    function feasibleTree(g) {
      var t = new Graph({ directed: false });
      var start3 = g.nodes()[0];
      var size = g.nodeCount();
      t.setNode(start3, {});
      var edge, delta;
      while (tightTree(t, g) < size) {
        edge = findMinSlackEdge(t, g);
        delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
        shiftRanks(t, g, delta);
      }
      return t;
    }
    function tightTree(t, g) {
      function dfs(v2) {
        g.nodeEdges(v2).forEach((e) => {
          var edgeV = e.v, w = v2 === edgeV ? e.w : edgeV;
          if (!t.hasNode(w) && !slack(g, e)) {
            t.setNode(w, {});
            t.setEdge(v2, w, {});
            dfs(w);
          }
        });
      }
      t.nodes().forEach(dfs);
      return t.nodeCount();
    }
    function findMinSlackEdge(t, g) {
      const edges = g.edges();
      return edges.reduce((acc, edge) => {
        let edgeSlack = Number.POSITIVE_INFINITY;
        if (t.hasNode(edge.v) !== t.hasNode(edge.w)) {
          edgeSlack = slack(g, edge);
        }
        if (edgeSlack < acc[0]) {
          return [edgeSlack, edge];
        }
        return acc;
      }, [Number.POSITIVE_INFINITY, null])[1];
    }
    function shiftRanks(t, g, delta) {
      t.nodes().forEach((v2) => g.node(v2).rank += delta);
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/network-simplex.js
var require_network_simplex = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/network-simplex.js"(exports, module) {
    "use strict";
    var feasibleTree = require_feasible_tree();
    var slack = require_util2().slack;
    var initRank = require_util2().longestPath;
    var preorder = require_graphlib().alg.preorder;
    var postorder = require_graphlib().alg.postorder;
    var simplify = require_util().simplify;
    module.exports = networkSimplex;
    networkSimplex.initLowLimValues = initLowLimValues;
    networkSimplex.initCutValues = initCutValues;
    networkSimplex.calcCutValue = calcCutValue;
    networkSimplex.leaveEdge = leaveEdge;
    networkSimplex.enterEdge = enterEdge;
    networkSimplex.exchangeEdges = exchangeEdges;
    function networkSimplex(g) {
      g = simplify(g);
      initRank(g);
      var t = feasibleTree(g);
      initLowLimValues(t);
      initCutValues(t, g);
      var e, f;
      while (e = leaveEdge(t)) {
        f = enterEdge(t, g, e);
        exchangeEdges(t, g, e, f);
      }
    }
    function initCutValues(t, g) {
      var vs = postorder(t, t.nodes());
      vs = vs.slice(0, vs.length - 1);
      vs.forEach((v2) => assignCutValue(t, g, v2));
    }
    function assignCutValue(t, g, child) {
      var childLab = t.node(child);
      var parent = childLab.parent;
      t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
    }
    function calcCutValue(t, g, child) {
      var childLab = t.node(child);
      var parent = childLab.parent;
      var childIsTail = true;
      var graphEdge = g.edge(child, parent);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g.edge(parent, child);
      }
      cutValue = graphEdge.weight;
      g.nodeEdges(child).forEach((e) => {
        var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
        if (other !== parent) {
          var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge(t, child, other)) {
            var otherCutValue = t.edge(child, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    }
    function initLowLimValues(tree, root3) {
      if (arguments.length < 2) {
        root3 = tree.nodes()[0];
      }
      dfsAssignLowLim(tree, {}, 1, root3);
    }
    function dfsAssignLowLim(tree, visited, nextLim, v2, parent) {
      var low = nextLim;
      var label = tree.node(v2);
      visited[v2] = true;
      tree.neighbors(v2).forEach((w) => {
        if (!visited.hasOwnProperty(w)) {
          nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v2);
        }
      });
      label.low = low;
      label.lim = nextLim++;
      if (parent) {
        label.parent = parent;
      } else {
        delete label.parent;
      }
      return nextLim;
    }
    function leaveEdge(tree) {
      return tree.edges().find((e) => tree.edge(e).cutvalue < 0);
    }
    function enterEdge(t, g, edge) {
      var v2 = edge.v;
      var w = edge.w;
      if (!g.hasEdge(v2, w)) {
        v2 = edge.w;
        w = edge.v;
      }
      var vLabel = t.node(v2);
      var wLabel = t.node(w);
      var tailLabel = vLabel;
      var flip3 = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip3 = true;
      }
      var candidates = g.edges().filter((edge2) => {
        return flip3 === isDescendant(t, t.node(edge2.v), tailLabel) && flip3 !== isDescendant(t, t.node(edge2.w), tailLabel);
      });
      return candidates.reduce((acc, edge2) => {
        if (slack(g, edge2) < slack(g, acc)) {
          return edge2;
        }
        return acc;
      });
    }
    function exchangeEdges(t, g, e, f) {
      var v2 = e.v;
      var w = e.w;
      t.removeEdge(v2, w);
      t.setEdge(f.v, f.w, {});
      initLowLimValues(t);
      initCutValues(t, g);
      updateRanks(t, g);
    }
    function updateRanks(t, g) {
      var root3 = t.nodes().find((v2) => !g.node(v2).parent);
      var vs = preorder(t, root3);
      vs = vs.slice(1);
      vs.forEach((v2) => {
        var parent = t.node(v2).parent, edge = g.edge(v2, parent), flipped = false;
        if (!edge) {
          edge = g.edge(parent, v2);
          flipped = true;
        }
        g.node(v2).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    }
    function isTreeEdge(tree, u4, v2) {
      return tree.hasEdge(u4, v2);
    }
    function isDescendant(tree, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/index.js
var require_rank = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/index.js"(exports, module) {
    "use strict";
    var rankUtil = require_util2();
    var longestPath = rankUtil.longestPath;
    var feasibleTree = require_feasible_tree();
    var networkSimplex = require_network_simplex();
    module.exports = rank2;
    function rank2(g) {
      switch (g.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker(g);
          break;
        case "tight-tree":
          tightTreeRanker(g);
          break;
        case "longest-path":
          longestPathRanker(g);
          break;
        default:
          networkSimplexRanker(g);
      }
    }
    var longestPathRanker = longestPath;
    function tightTreeRanker(g) {
      longestPath(g);
      feasibleTree(g);
    }
    function networkSimplexRanker(g) {
      networkSimplex(g);
    }
  }
});

// node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js
var require_parent_dummy_chains = __commonJS({
  "node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js"(exports, module) {
    module.exports = parentDummyChains;
    function parentDummyChains(g) {
      let postorderNums = postorder(g);
      g.graph().dummyChains.forEach((v2) => {
        let node = g.node(v2);
        let edgeObj = node.edgeObj;
        let pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
        let path3 = pathData.path;
        let lca = pathData.lca;
        let pathIdx = 0;
        let pathV = path3[pathIdx];
        let ascending3 = true;
        while (v2 !== edgeObj.w) {
          node = g.node(v2);
          if (ascending3) {
            while ((pathV = path3[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {
              pathIdx++;
            }
            if (pathV === lca) {
              ascending3 = false;
            }
          }
          if (!ascending3) {
            while (pathIdx < path3.length - 1 && g.node(pathV = path3[pathIdx + 1]).minRank <= node.rank) {
              pathIdx++;
            }
            pathV = path3[pathIdx];
          }
          g.setParent(v2, pathV);
          v2 = g.successors(v2)[0];
        }
      });
    }
    function findPath(g, postorderNums, v2, w) {
      let vPath = [];
      let wPath = [];
      let low = Math.min(postorderNums[v2].low, postorderNums[w].low);
      let lim = Math.max(postorderNums[v2].lim, postorderNums[w].lim);
      let parent;
      let lca;
      parent = v2;
      do {
        parent = g.parent(parent);
        vPath.push(parent);
      } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
      lca = parent;
      parent = w;
      while ((parent = g.parent(parent)) !== lca) {
        wPath.push(parent);
      }
      return { path: vPath.concat(wPath.reverse()), lca };
    }
    function postorder(g) {
      let result = {};
      let lim = 0;
      function dfs(v2) {
        let low = lim;
        g.children(v2).forEach(dfs);
        result[v2] = { low, lim: lim++ };
      }
      g.children().forEach(dfs);
      return result;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/nesting-graph.js
var require_nesting_graph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/nesting-graph.js"(exports, module) {
    var util = require_util();
    module.exports = {
      run: run3,
      cleanup
    };
    function run3(g) {
      let root3 = util.addDummyNode(g, "root", {}, "_root");
      let depths = treeDepths(g);
      let height = Math.max(...Object.values(depths)) - 1;
      let nodeSep = 2 * height + 1;
      g.graph().nestingRoot = root3;
      g.edges().forEach((e) => g.edge(e).minlen *= nodeSep);
      let weight = sumWeights(g) + 1;
      g.children().forEach((child) => dfs(g, root3, nodeSep, weight, height, depths, child));
      g.graph().nodeRankFactor = nodeSep;
    }
    function dfs(g, root3, nodeSep, weight, height, depths, v2) {
      let children2 = g.children(v2);
      if (!children2.length) {
        if (v2 !== root3) {
          g.setEdge(root3, v2, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      let top3 = util.addBorderNode(g, "_bt");
      let bottom3 = util.addBorderNode(g, "_bb");
      let label = g.node(v2);
      g.setParent(top3, v2);
      label.borderTop = top3;
      g.setParent(bottom3, v2);
      label.borderBottom = bottom3;
      children2.forEach((child) => {
        dfs(g, root3, nodeSep, weight, height, depths, child);
        let childNode = g.node(child);
        let childTop = childNode.borderTop ? childNode.borderTop : child;
        let childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        let thisWeight = childNode.borderTop ? weight : 2 * weight;
        let minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
        g.setEdge(top3, childTop, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
        g.setEdge(childBottom, bottom3, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
      });
      if (!g.parent(v2)) {
        g.setEdge(root3, top3, { weight: 0, minlen: height + depths[v2] });
      }
    }
    function treeDepths(g) {
      var depths = {};
      function dfs2(v2, depth) {
        var children2 = g.children(v2);
        if (children2 && children2.length) {
          children2.forEach((child) => dfs2(child, depth + 1));
        }
        depths[v2] = depth;
      }
      g.children().forEach((v2) => dfs2(v2, 1));
      return depths;
    }
    function sumWeights(g) {
      return g.edges().reduce((acc, e) => acc + g.edge(e).weight, 0);
    }
    function cleanup(g) {
      var graphLabel = g.graph();
      g.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        if (edge.nestingEdge) {
          g.removeEdge(e);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/add-border-segments.js
var require_add_border_segments = __commonJS({
  "node_modules/@dagrejs/dagre/lib/add-border-segments.js"(exports, module) {
    var util = require_util();
    module.exports = addBorderSegments;
    function addBorderSegments(g) {
      function dfs(v2) {
        let children2 = g.children(v2);
        let node = g.node(v2);
        if (children2.length) {
          children2.forEach(dfs);
        }
        if (node.hasOwnProperty("minRank")) {
          node.borderLeft = [];
          node.borderRight = [];
          for (let rank2 = node.minRank, maxRank = node.maxRank + 1; rank2 < maxRank; ++rank2) {
            addBorderNode(g, "borderLeft", "_bl", v2, node, rank2);
            addBorderNode(g, "borderRight", "_br", v2, node, rank2);
          }
        }
      }
      g.children().forEach(dfs);
    }
    function addBorderNode(g, prop, prefix, sg, sgNode, rank2) {
      let label = { width: 0, height: 0, rank: rank2, borderType: prop };
      let prev = sgNode[prop][rank2 - 1];
      let curr = util.addDummyNode(g, "border", label, prefix);
      sgNode[prop][rank2] = curr;
      g.setParent(curr, sg);
      if (prev) {
        g.setEdge(prev, curr, { weight: 1 });
      }
    }
  }
});

// node_modules/@dagrejs/dagre/lib/coordinate-system.js
var require_coordinate_system = __commonJS({
  "node_modules/@dagrejs/dagre/lib/coordinate-system.js"(exports, module) {
    "use strict";
    module.exports = {
      adjust,
      undo
    };
    function adjust(g) {
      let rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g);
      }
    }
    function undo(g) {
      let rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g);
        swapWidthHeight(g);
      }
    }
    function swapWidthHeight(g) {
      g.nodes().forEach((v2) => swapWidthHeightOne(g.node(v2)));
      g.edges().forEach((e) => swapWidthHeightOne(g.edge(e)));
    }
    function swapWidthHeightOne(attrs) {
      let w = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w;
    }
    function reverseY(g) {
      g.nodes().forEach((v2) => reverseYOne(g.node(v2)));
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.points.forEach(reverseYOne);
        if (edge.hasOwnProperty("y")) {
          reverseYOne(edge);
        }
      });
    }
    function reverseYOne(attrs) {
      attrs.y = -attrs.y;
    }
    function swapXY(g) {
      g.nodes().forEach((v2) => swapXYOne(g.node(v2)));
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.points.forEach(swapXYOne);
        if (edge.hasOwnProperty("x")) {
          swapXYOne(edge);
        }
      });
    }
    function swapXYOne(attrs) {
      let x4 = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x4;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/init-order.js
var require_init_order = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/init-order.js"(exports, module) {
    "use strict";
    var util = require_util();
    module.exports = initOrder;
    function initOrder(g) {
      let visited = {};
      let simpleNodes = g.nodes().filter((v2) => !g.children(v2).length);
      let maxRank = Math.max(...simpleNodes.map((v2) => g.node(v2).rank));
      let layers = util.range(maxRank + 1).map(() => []);
      function dfs(v2) {
        if (visited[v2]) return;
        visited[v2] = true;
        let node = g.node(v2);
        layers[node.rank].push(v2);
        g.successors(v2).forEach(dfs);
      }
      let orderedVs = simpleNodes.sort((a4, b) => g.node(a4).rank - g.node(b).rank);
      orderedVs.forEach(dfs);
      return layers;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/cross-count.js
var require_cross_count = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/cross-count.js"(exports, module) {
    "use strict";
    var zipObject = require_util().zipObject;
    module.exports = crossCount;
    function crossCount(g, layering) {
      let cc2 = 0;
      for (let i = 1; i < layering.length; ++i) {
        cc2 += twoLayerCrossCount(g, layering[i - 1], layering[i]);
      }
      return cc2;
    }
    function twoLayerCrossCount(g, northLayer, southLayer) {
      let southPos = zipObject(southLayer, southLayer.map((v2, i) => i));
      let southEntries = northLayer.flatMap((v2) => {
        return g.outEdges(v2).map((e) => {
          return { pos: southPos[e.w], weight: g.edge(e).weight };
        }).sort((a4, b) => a4.pos - b.pos);
      });
      let firstIndex = 1;
      while (firstIndex < southLayer.length) firstIndex <<= 1;
      let treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      let tree = new Array(treeSize).fill(0);
      let cc2 = 0;
      southEntries.forEach((entry) => {
        let index4 = entry.pos + firstIndex;
        tree[index4] += entry.weight;
        let weightSum = 0;
        while (index4 > 0) {
          if (index4 % 2) {
            weightSum += tree[index4 + 1];
          }
          index4 = index4 - 1 >> 1;
          tree[index4] += entry.weight;
        }
        cc2 += entry.weight * weightSum;
      });
      return cc2;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/barycenter.js
var require_barycenter = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/barycenter.js"(exports, module) {
    module.exports = barycenter;
    function barycenter(g, movable = []) {
      return movable.map((v2) => {
        let inV = g.inEdges(v2);
        if (!inV.length) {
          return { v: v2 };
        } else {
          let result = inV.reduce((acc, e) => {
            let edge = g.edge(e), nodeU = g.node(e.v);
            return {
              sum: acc.sum + edge.weight * nodeU.order,
              weight: acc.weight + edge.weight
            };
          }, { sum: 0, weight: 0 });
          return {
            v: v2,
            barycenter: result.sum / result.weight,
            weight: result.weight
          };
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js
var require_resolve_conflicts = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js"(exports, module) {
    "use strict";
    var util = require_util();
    module.exports = resolveConflicts;
    function resolveConflicts(entries, cg) {
      let mappedEntries = {};
      entries.forEach((entry, i) => {
        let tmp = mappedEntries[entry.v] = {
          indegree: 0,
          "in": [],
          out: [],
          vs: [entry.v],
          i
        };
        if (entry.barycenter !== void 0) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      cg.edges().forEach((e) => {
        let entryV = mappedEntries[e.v];
        let entryW = mappedEntries[e.w];
        if (entryV !== void 0 && entryW !== void 0) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e.w]);
        }
      });
      let sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
      return doResolveConflicts(sourceSet);
    }
    function doResolveConflicts(sourceSet) {
      let entries = [];
      function handleIn(vEntry) {
        return (uEntry) => {
          if (uEntry.merged) {
            return;
          }
          if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries(vEntry, uEntry);
          }
        };
      }
      function handleOut(vEntry) {
        return (wEntry) => {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      }
      while (sourceSet.length) {
        let entry = sourceSet.pop();
        entries.push(entry);
        entry["in"].reverse().forEach(handleIn(entry));
        entry.out.forEach(handleOut(entry));
      }
      return entries.filter((entry) => !entry.merged).map((entry) => {
        return util.pick(entry, ["vs", "i", "barycenter", "weight"]);
      });
    }
    function mergeEntries(target, source) {
      let sum4 = 0;
      let weight = 0;
      if (target.weight) {
        sum4 += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum4 += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = source.vs.concat(target.vs);
      target.barycenter = sum4 / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/sort.js
var require_sort = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/sort.js"(exports, module) {
    var util = require_util();
    module.exports = sort3;
    function sort3(entries, biasRight) {
      let parts = util.partition(entries, (entry) => {
        return entry.hasOwnProperty("barycenter");
      });
      let sortable = parts.lhs, unsortable = parts.rhs.sort((a4, b) => b.i - a4.i), vs = [], sum4 = 0, weight = 0, vsIndex = 0;
      sortable.sort(compareWithBias(!!biasRight));
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      sortable.forEach((entry) => {
        vsIndex += entry.vs.length;
        vs.push(entry.vs);
        sum4 += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      });
      let result = { vs: vs.flat(true) };
      if (weight) {
        result.barycenter = sum4 / weight;
        result.weight = weight;
      }
      return result;
    }
    function consumeUnsortable(vs, unsortable, index4) {
      let last;
      while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= index4) {
        unsortable.pop();
        vs.push(last.vs);
        index4++;
      }
      return index4;
    }
    function compareWithBias(bias) {
      return (entryV, entryW) => {
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        } else if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js
var require_sort_subgraph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js"(exports, module) {
    var barycenter = require_barycenter();
    var resolveConflicts = require_resolve_conflicts();
    var sort3 = require_sort();
    module.exports = sortSubgraph;
    function sortSubgraph(g, v2, cg, biasRight) {
      let movable = g.children(v2);
      let node = g.node(v2);
      let bl = node ? node.borderLeft : void 0;
      let br = node ? node.borderRight : void 0;
      let subgraphs = {};
      if (bl) {
        movable = movable.filter((w) => w !== bl && w !== br);
      }
      let barycenters = barycenter(g, movable);
      barycenters.forEach((entry) => {
        if (g.children(entry.v).length) {
          let subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
          subgraphs[entry.v] = subgraphResult;
          if (subgraphResult.hasOwnProperty("barycenter")) {
            mergeBarycenters(entry, subgraphResult);
          }
        }
      });
      let entries = resolveConflicts(barycenters, cg);
      expandSubgraphs(entries, subgraphs);
      let result = sort3(entries, biasRight);
      if (bl) {
        result.vs = [bl, result.vs, br].flat(true);
        if (g.predecessors(bl).length) {
          let blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
          if (!result.hasOwnProperty("barycenter")) {
            result.barycenter = 0;
            result.weight = 0;
          }
          result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
          result.weight += 2;
        }
      }
      return result;
    }
    function expandSubgraphs(entries, subgraphs) {
      entries.forEach((entry) => {
        entry.vs = entry.vs.flatMap((v2) => {
          if (subgraphs[v2]) {
            return subgraphs[v2].vs;
          }
          return v2;
        });
      });
    }
    function mergeBarycenters(target, other) {
      if (target.barycenter !== void 0) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js
var require_build_layer_graph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js"(exports, module) {
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module.exports = buildLayerGraph;
    function buildLayerGraph(g, rank2, relationship) {
      let root3 = createRootNode(g), result = new Graph({ compound: true }).setGraph({ root: root3 }).setDefaultNodeLabel((v2) => g.node(v2));
      g.nodes().forEach((v2) => {
        let node = g.node(v2), parent = g.parent(v2);
        if (node.rank === rank2 || node.minRank <= rank2 && rank2 <= node.maxRank) {
          result.setNode(v2);
          result.setParent(v2, parent || root3);
          g[relationship](v2).forEach((e) => {
            let u4 = e.v === v2 ? e.w : e.v, edge = result.edge(u4, v2), weight = edge !== void 0 ? edge.weight : 0;
            result.setEdge(u4, v2, { weight: g.edge(e).weight + weight });
          });
          if (node.hasOwnProperty("minRank")) {
            result.setNode(v2, {
              borderLeft: node.borderLeft[rank2],
              borderRight: node.borderRight[rank2]
            });
          }
        }
      });
      return result;
    }
    function createRootNode(g) {
      var v2;
      while (g.hasNode(v2 = util.uniqueId("_root"))) ;
      return v2;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js
var require_add_subgraph_constraints = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js"(exports, module) {
    module.exports = addSubgraphConstraints;
    function addSubgraphConstraints(g, cg, vs) {
      let prev = {}, rootPrev;
      vs.forEach((v2) => {
        let child = g.parent(v2), parent, prevChild;
        while (child) {
          parent = g.parent(child);
          if (parent) {
            prevChild = prev[parent];
            prev[parent] = child;
          } else {
            prevChild = rootPrev;
            rootPrev = child;
          }
          if (prevChild && prevChild !== child) {
            cg.setEdge(prevChild, child);
            return;
          }
          child = parent;
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/index.js
var require_order = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/index.js"(exports, module) {
    "use strict";
    var initOrder = require_init_order();
    var crossCount = require_cross_count();
    var sortSubgraph = require_sort_subgraph();
    var buildLayerGraph = require_build_layer_graph();
    var addSubgraphConstraints = require_add_subgraph_constraints();
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module.exports = order2;
    function order2(g, opts) {
      if (opts && typeof opts.customOrder === "function") {
        opts.customOrder(g, order2);
        return;
      }
      let maxRank = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, util.range(maxRank - 1, -1, -1), "outEdges");
      let layering = initOrder(g);
      assignOrder(g, layering);
      if (opts && opts.disableOptimalOrderHeuristic) {
        return;
      }
      let bestCC = Number.POSITIVE_INFINITY, best;
      for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
        layering = util.buildLayerMatrix(g);
        let cc2 = crossCount(g, layering);
        if (cc2 < bestCC) {
          lastBest = 0;
          best = Object.assign({}, layering);
          bestCC = cc2;
        }
      }
      assignOrder(g, best);
    }
    function buildLayerGraphs(g, ranks, relationship) {
      return ranks.map(function(rank2) {
        return buildLayerGraph(g, rank2, relationship);
      });
    }
    function sweepLayerGraphs(layerGraphs, biasRight) {
      let cg = new Graph();
      layerGraphs.forEach(function(lg) {
        let root3 = lg.graph().root;
        let sorted = sortSubgraph(lg, root3, cg, biasRight);
        sorted.vs.forEach((v2, i) => lg.node(v2).order = i);
        addSubgraphConstraints(lg, cg, sorted.vs);
      });
    }
    function assignOrder(g, layering) {
      Object.values(layering).forEach((layer) => layer.forEach((v2, i) => g.node(v2).order = i));
    }
  }
});

// node_modules/@dagrejs/dagre/lib/position/bk.js
var require_bk = __commonJS({
  "node_modules/@dagrejs/dagre/lib/position/bk.js"(exports, module) {
    "use strict";
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module.exports = {
      positionX,
      findType1Conflicts,
      findType2Conflicts,
      addConflict,
      hasConflict,
      verticalAlignment,
      horizontalCompaction,
      alignCoordinates,
      findSmallestWidthAlignment,
      balance
    };
    function findType1Conflicts(g, layering) {
      let conflicts = {};
      function visitLayer(prevLayer, layer) {
        let k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
        layer.forEach((v2, i) => {
          let w = findOtherInnerSegmentNode(g, v2), k1 = w ? g.node(w).order : prevLayerLength;
          if (w || v2 === lastNode) {
            layer.slice(scanPos, i + 1).forEach((scanNode) => {
              g.predecessors(scanNode).forEach((u4) => {
                let uLabel = g.node(u4), uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
                  addConflict(conflicts, u4, scanNode);
                }
              });
            });
            scanPos = i + 1;
            k0 = k1;
          }
        });
        return layer;
      }
      layering.length && layering.reduce(visitLayer);
      return conflicts;
    }
    function findType2Conflicts(g, layering) {
      let conflicts = {};
      function scan2(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        let v2;
        util.range(southPos, southEnd).forEach((i) => {
          v2 = south[i];
          if (g.node(v2).dummy) {
            g.predecessors(v2).forEach((u4) => {
              let uNode = g.node(u4);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                addConflict(conflicts, u4, v2);
              }
            });
          }
        });
      }
      function visitLayer(north, south) {
        let prevNorthPos = -1, nextNorthPos, southPos = 0;
        south.forEach((v2, southLookahead) => {
          if (g.node(v2).dummy === "border") {
            let predecessors = g.predecessors(v2);
            if (predecessors.length) {
              nextNorthPos = g.node(predecessors[0]).order;
              scan2(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scan2(south, southPos, south.length, nextNorthPos, north.length);
        });
        return south;
      }
      layering.length && layering.reduce(visitLayer);
      return conflicts;
    }
    function findOtherInnerSegmentNode(g, v2) {
      if (g.node(v2).dummy) {
        return g.predecessors(v2).find((u4) => g.node(u4).dummy);
      }
    }
    function addConflict(conflicts, v2, w) {
      if (v2 > w) {
        let tmp = v2;
        v2 = w;
        w = tmp;
      }
      let conflictsV = conflicts[v2];
      if (!conflictsV) {
        conflicts[v2] = conflictsV = {};
      }
      conflictsV[w] = true;
    }
    function hasConflict(conflicts, v2, w) {
      if (v2 > w) {
        let tmp = v2;
        v2 = w;
        w = tmp;
      }
      return !!conflicts[v2] && conflicts[v2].hasOwnProperty(w);
    }
    function verticalAlignment(g, layering, conflicts, neighborFn) {
      let root3 = {}, align = {}, pos = {};
      layering.forEach((layer) => {
        layer.forEach((v2, order2) => {
          root3[v2] = v2;
          align[v2] = v2;
          pos[v2] = order2;
        });
      });
      layering.forEach((layer) => {
        let prevIdx = -1;
        layer.forEach((v2) => {
          let ws = neighborFn(v2);
          if (ws.length) {
            ws = ws.sort((a4, b) => pos[a4] - pos[b]);
            let mp = (ws.length - 1) / 2;
            for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
              let w = ws[i];
              if (align[v2] === v2 && prevIdx < pos[w] && !hasConflict(conflicts, v2, w)) {
                align[w] = v2;
                align[v2] = root3[v2] = root3[w];
                prevIdx = pos[w];
              }
            }
          }
        });
      });
      return { root: root3, align };
    }
    function horizontalCompaction(g, layering, root3, align, reverseSep) {
      let xs = {}, blockG = buildBlockGraph(g, layering, root3, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
      function iterate(setXsFunc, nextNodesFunc) {
        let stack = blockG.nodes();
        let elem = stack.pop();
        let visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
          elem = stack.pop();
        }
      }
      function pass1(elem) {
        xs[elem] = blockG.inEdges(elem).reduce((acc, e) => {
          return Math.max(acc, xs[e.v] + blockG.edge(e));
        }, 0);
      }
      function pass2(elem) {
        let min4 = blockG.outEdges(elem).reduce((acc, e) => {
          return Math.min(acc, xs[e.w] - blockG.edge(e));
        }, Number.POSITIVE_INFINITY);
        let node = g.node(elem);
        if (min4 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min4);
        }
      }
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      Object.keys(align).forEach((v2) => xs[v2] = xs[root3[v2]]);
      return xs;
    }
    function buildBlockGraph(g, layering, root3, reverseSep) {
      let blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      layering.forEach((layer) => {
        let u4;
        layer.forEach((v2) => {
          let vRoot = root3[v2];
          blockGraph.setNode(vRoot);
          if (u4) {
            var uRoot = root3[u4], prevMax = blockGraph.edge(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v2, u4), prevMax || 0));
          }
          u4 = v2;
        });
      });
      return blockGraph;
    }
    function findSmallestWidthAlignment(g, xss) {
      return Object.values(xss).reduce((currentMinAndXs, xs) => {
        let max5 = Number.NEGATIVE_INFINITY;
        let min4 = Number.POSITIVE_INFINITY;
        Object.entries(xs).forEach(([v2, x4]) => {
          let halfWidth = width(g, v2) / 2;
          max5 = Math.max(x4 + halfWidth, max5);
          min4 = Math.min(x4 - halfWidth, min4);
        });
        const newMin = max5 - min4;
        if (newMin < currentMinAndXs[0]) {
          currentMinAndXs = [newMin, xs];
        }
        return currentMinAndXs;
      }, [Number.POSITIVE_INFINITY, null])[1];
    }
    function alignCoordinates(xss, alignTo) {
      let alignToVals = Object.values(alignTo), alignToMin = Math.min(...alignToVals), alignToMax = Math.max(...alignToVals);
      ["u", "d"].forEach((vert) => {
        ["l", "r"].forEach((horiz) => {
          let alignment = vert + horiz, xs = xss[alignment];
          if (xs === alignTo) return;
          let xsVals = Object.values(xs);
          let delta = alignToMin - Math.min(...xsVals);
          if (horiz !== "l") {
            delta = alignToMax - Math.max(...xsVals);
          }
          if (delta) {
            xss[alignment] = util.mapValues(xs, (x4) => x4 + delta);
          }
        });
      });
    }
    function balance(xss, align) {
      return util.mapValues(xss.ul, (num, v2) => {
        if (align) {
          return xss[align.toLowerCase()][v2];
        } else {
          let xs = Object.values(xss).map((xs2) => xs2[v2]).sort((a4, b) => a4 - b);
          return (xs[1] + xs[2]) / 2;
        }
      });
    }
    function positionX(g) {
      let layering = util.buildLayerMatrix(g);
      let conflicts = Object.assign(
        findType1Conflicts(g, layering),
        findType2Conflicts(g, layering)
      );
      let xss = {};
      let adjustedLayering;
      ["u", "d"].forEach((vert) => {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach((horiz) => {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map((inner2) => {
              return Object.values(inner2).reverse();
            });
          }
          let neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
          let align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
          let xs = horizontalCompaction(
            g,
            adjustedLayering,
            align.root,
            align.align,
            horiz === "r"
          );
          if (horiz === "r") {
            xs = util.mapValues(xs, (x4) => -x4);
          }
          xss[vert + horiz] = xs;
        });
      });
      let smallestWidth = findSmallestWidthAlignment(g, xss);
      alignCoordinates(xss, smallestWidth);
      return balance(xss, g.graph().align);
    }
    function sep(nodeSep, edgeSep, reverseSep) {
      return (g, v2, w) => {
        let vLabel = g.node(v2);
        let wLabel = g.node(w);
        let sum4 = 0;
        let delta;
        sum4 += vLabel.width / 2;
        if (vLabel.hasOwnProperty("labelpos")) {
          switch (vLabel.labelpos.toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum4 += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum4 += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum4 += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum4 += wLabel.width / 2;
        if (wLabel.hasOwnProperty("labelpos")) {
          switch (wLabel.labelpos.toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum4 += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum4;
      };
    }
    function width(g, v2) {
      return g.node(v2).width;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/position/index.js
var require_position = __commonJS({
  "node_modules/@dagrejs/dagre/lib/position/index.js"(exports, module) {
    "use strict";
    var util = require_util();
    var positionX = require_bk().positionX;
    module.exports = position;
    function position(g) {
      g = util.asNonCompoundGraph(g);
      positionY(g);
      Object.entries(positionX(g)).forEach(([v2, x4]) => g.node(v2).x = x4);
    }
    function positionY(g) {
      let layering = util.buildLayerMatrix(g);
      let rankSep = g.graph().ranksep;
      let prevY = 0;
      layering.forEach((layer) => {
        const maxHeight = layer.reduce((acc, v2) => {
          const height = g.node(v2).height;
          if (acc > height) {
            return acc;
          } else {
            return height;
          }
        }, 0);
        layer.forEach((v2) => g.node(v2).y = prevY + maxHeight / 2);
        prevY += maxHeight + rankSep;
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/layout.js
var require_layout2 = __commonJS({
  "node_modules/@dagrejs/dagre/lib/layout.js"(exports, module) {
    "use strict";
    var acyclic = require_acyclic();
    var normalize3 = require_normalize();
    var rank2 = require_rank();
    var normalizeRanks = require_util().normalizeRanks;
    var parentDummyChains = require_parent_dummy_chains();
    var removeEmptyRanks = require_util().removeEmptyRanks;
    var nestingGraph = require_nesting_graph();
    var addBorderSegments = require_add_border_segments();
    var coordinateSystem = require_coordinate_system();
    var order2 = require_order();
    var position = require_position();
    var util = require_util();
    var Graph = require_graphlib().Graph;
    module.exports = layout3;
    function layout3(g, opts) {
      let time2 = opts && opts.debugTiming ? util.time : util.notime;
      time2("layout", () => {
        let layoutGraph = time2("  buildLayoutGraph", () => buildLayoutGraph(g));
        time2("  runLayout", () => runLayout(layoutGraph, time2));
        time2("  updateInputGraph", () => updateInputGraph(g, layoutGraph));
      });
    }
    function runLayout(g, time2) {
      time2("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g));
      time2("    removeSelfEdges", () => removeSelfEdges(g));
      time2("    acyclic", () => acyclic.run(g));
      time2("    nestingGraph.run", () => nestingGraph.run(g));
      time2("    rank", () => rank2(util.asNonCompoundGraph(g)));
      time2("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g));
      time2("    removeEmptyRanks", () => removeEmptyRanks(g));
      time2("    nestingGraph.cleanup", () => nestingGraph.cleanup(g));
      time2("    normalizeRanks", () => normalizeRanks(g));
      time2("    assignRankMinMax", () => assignRankMinMax(g));
      time2("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g));
      time2("    normalize.run", () => normalize3.run(g));
      time2("    parentDummyChains", () => parentDummyChains(g));
      time2("    addBorderSegments", () => addBorderSegments(g));
      time2("    order", () => order2(g));
      time2("    insertSelfEdges", () => insertSelfEdges(g));
      time2("    adjustCoordinateSystem", () => coordinateSystem.adjust(g));
      time2("    position", () => position(g));
      time2("    positionSelfEdges", () => positionSelfEdges(g));
      time2("    removeBorderNodes", () => removeBorderNodes(g));
      time2("    normalize.undo", () => normalize3.undo(g));
      time2("    fixupEdgeLabelCoords", () => fixupEdgeLabelCoords(g));
      time2("    undoCoordinateSystem", () => coordinateSystem.undo(g));
      time2("    translateGraph", () => translateGraph(g));
      time2("    assignNodeIntersects", () => assignNodeIntersects(g));
      time2("    reversePoints", () => reversePointsForReversedEdges(g));
      time2("    acyclic.undo", () => acyclic.undo(g));
    }
    function updateInputGraph(inputGraph, layoutGraph) {
      inputGraph.nodes().forEach((v2) => {
        let inputLabel = inputGraph.node(v2);
        let layoutLabel = layoutGraph.node(v2);
        if (inputLabel) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          inputLabel.rank = layoutLabel.rank;
          if (layoutGraph.children(v2).length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      inputGraph.edges().forEach((e) => {
        let inputLabel = inputGraph.edge(e);
        let layoutLabel = layoutGraph.edge(e);
        inputLabel.points = layoutLabel.points;
        if (layoutLabel.hasOwnProperty("x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    }
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs = ["width", "height"];
    var nodeDefaults = { width: 0, height: 0 };
    var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs = ["labelpos"];
    function buildLayoutGraph(inputGraph) {
      let g = new Graph({ multigraph: true, compound: true });
      let graph = canonicalize(inputGraph.graph());
      g.setGraph(Object.assign(
        {},
        graphDefaults,
        selectNumberAttrs(graph, graphNumAttrs),
        util.pick(graph, graphAttrs)
      ));
      inputGraph.nodes().forEach((v2) => {
        let node = canonicalize(inputGraph.node(v2));
        const newNode = selectNumberAttrs(node, nodeNumAttrs);
        Object.keys(nodeDefaults).forEach((k2) => {
          if (newNode[k2] === void 0) {
            newNode[k2] = nodeDefaults[k2];
          }
        });
        g.setNode(v2, newNode);
        g.setParent(v2, inputGraph.parent(v2));
      });
      inputGraph.edges().forEach((e) => {
        let edge = canonicalize(inputGraph.edge(e));
        g.setEdge(e, Object.assign(
          {},
          edgeDefaults,
          selectNumberAttrs(edge, edgeNumAttrs),
          util.pick(edge, edgeAttrs)
        ));
      });
      return g;
    }
    function makeSpaceForEdgeLabels(g) {
      let graph = g.graph();
      graph.ranksep /= 2;
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.minlen *= 2;
        if (edge.labelpos.toLowerCase() !== "c") {
          if (graph.rankdir === "TB" || graph.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    }
    function injectEdgeLabelProxies(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (edge.width && edge.height) {
          let v2 = g.node(e.v);
          let w = g.node(e.w);
          let label = { rank: (w.rank - v2.rank) / 2 + v2.rank, e };
          util.addDummyNode(g, "edge-proxy", label, "_ep");
        }
      });
    }
    function assignRankMinMax(g) {
      let maxRank = 0;
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        if (node.borderTop) {
          node.minRank = g.node(node.borderTop).rank;
          node.maxRank = g.node(node.borderBottom).rank;
          maxRank = Math.max(maxRank, node.maxRank);
        }
      });
      g.graph().maxRank = maxRank;
    }
    function removeEdgeLabelProxies(g) {
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        if (node.dummy === "edge-proxy") {
          g.edge(node.e).labelRank = node.rank;
          g.removeNode(v2);
        }
      });
    }
    function translateGraph(g) {
      let minX = Number.POSITIVE_INFINITY;
      let maxX = 0;
      let minY = Number.POSITIVE_INFINITY;
      let maxY2 = 0;
      let graphLabel = g.graph();
      let marginX = graphLabel.marginx || 0;
      let marginY = graphLabel.marginy || 0;
      function getExtremes(attrs) {
        let x4 = attrs.x;
        let y4 = attrs.y;
        let w = attrs.width;
        let h = attrs.height;
        minX = Math.min(minX, x4 - w / 2);
        maxX = Math.max(maxX, x4 + w / 2);
        minY = Math.min(minY, y4 - h / 2);
        maxY2 = Math.max(maxY2, y4 + h / 2);
      }
      g.nodes().forEach((v2) => getExtremes(g.node(v2)));
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (edge.hasOwnProperty("x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        node.x -= minX;
        node.y -= minY;
      });
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.points.forEach((p) => {
          p.x -= minX;
          p.y -= minY;
        });
        if (edge.hasOwnProperty("x")) {
          edge.x -= minX;
        }
        if (edge.hasOwnProperty("y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY2 - minY + marginY;
    }
    function assignNodeIntersects(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        let nodeV = g.node(e.v);
        let nodeW = g.node(e.w);
        let p1, p2;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p2 = nodeV;
        } else {
          p1 = edge.points[0];
          p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift(util.intersectRect(nodeV, p1));
        edge.points.push(util.intersectRect(nodeW, p2));
      });
    }
    function fixupEdgeLabelCoords(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (edge.hasOwnProperty("x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    }
    function reversePointsForReversedEdges(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (edge.reversed) {
          edge.points.reverse();
        }
      });
    }
    function removeBorderNodes(g) {
      g.nodes().forEach((v2) => {
        if (g.children(v2).length) {
          let node = g.node(v2);
          let t = g.node(node.borderTop);
          let b = g.node(node.borderBottom);
          let l = g.node(node.borderLeft[node.borderLeft.length - 1]);
          let r = g.node(node.borderRight[node.borderRight.length - 1]);
          node.width = Math.abs(r.x - l.x);
          node.height = Math.abs(b.y - t.y);
          node.x = l.x + node.width / 2;
          node.y = t.y + node.height / 2;
        }
      });
      g.nodes().forEach((v2) => {
        if (g.node(v2).dummy === "border") {
          g.removeNode(v2);
        }
      });
    }
    function removeSelfEdges(g) {
      g.edges().forEach((e) => {
        if (e.v === e.w) {
          var node = g.node(e.v);
          if (!node.selfEdges) {
            node.selfEdges = [];
          }
          node.selfEdges.push({ e, label: g.edge(e) });
          g.removeEdge(e);
        }
      });
    }
    function insertSelfEdges(g) {
      var layers = util.buildLayerMatrix(g);
      layers.forEach((layer) => {
        var orderShift = 0;
        layer.forEach((v2, i) => {
          var node = g.node(v2);
          node.order = i + orderShift;
          (node.selfEdges || []).forEach((selfEdge) => {
            util.addDummyNode(g, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node.rank,
              order: i + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node.selfEdges;
        });
      });
    }
    function positionSelfEdges(g) {
      g.nodes().forEach((v2) => {
        var node = g.node(v2);
        if (node.dummy === "selfedge") {
          var selfNode = g.node(node.e.v);
          var x4 = selfNode.x + selfNode.width / 2;
          var y4 = selfNode.y;
          var dx = node.x - x4;
          var dy = selfNode.height / 2;
          g.setEdge(node.e, node.label);
          g.removeNode(v2);
          node.label.points = [
            { x: x4 + 2 * dx / 3, y: y4 - dy },
            { x: x4 + 5 * dx / 6, y: y4 - dy },
            { x: x4 + dx, y: y4 },
            { x: x4 + 5 * dx / 6, y: y4 + dy },
            { x: x4 + 2 * dx / 3, y: y4 + dy }
          ];
          node.label.x = node.x;
          node.label.y = node.y;
        }
      });
    }
    function selectNumberAttrs(obj, attrs) {
      return util.mapValues(util.pick(obj, attrs), Number);
    }
    function canonicalize(attrs) {
      var newAttrs = {};
      if (attrs) {
        Object.entries(attrs).forEach(([k2, v2]) => {
          if (typeof k2 === "string") {
            k2 = k2.toLowerCase();
          }
          newAttrs[k2] = v2;
        });
      }
      return newAttrs;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/debug.js
var require_debug = __commonJS({
  "node_modules/@dagrejs/dagre/lib/debug.js"(exports, module) {
    var util = require_util();
    var Graph = require_graphlib().Graph;
    module.exports = {
      debugOrdering
    };
    function debugOrdering(g) {
      let layerMatrix = util.buildLayerMatrix(g);
      let h = new Graph({ compound: true, multigraph: true }).setGraph({});
      g.nodes().forEach((v2) => {
        h.setNode(v2, { label: v2 });
        h.setParent(v2, "layer" + g.node(v2).rank);
      });
      g.edges().forEach((e) => h.setEdge(e.v, e.w, {}, e.name));
      layerMatrix.forEach((layer, i) => {
        let layerV = "layer" + i;
        h.setNode(layerV, { rank: "same" });
        layer.reduce((u4, v2) => {
          h.setEdge(u4, v2, { style: "invis" });
          return v2;
        });
      });
      return h;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/version.js
var require_version2 = __commonJS({
  "node_modules/@dagrejs/dagre/lib/version.js"(exports, module) {
    module.exports = "1.1.2";
  }
});

// node_modules/@dagrejs/dagre/index.js
var require_dagre = __commonJS({
  "node_modules/@dagrejs/dagre/index.js"(exports, module) {
    module.exports = {
      graphlib: require_graphlib(),
      layout: require_layout2(),
      debug: require_debug(),
      util: {
        time: require_util().time,
        notime: require_util().notime
      },
      version: require_version2()
    };
  }
});

// vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-pipelines.css
var topology_pipelines_exports = {};
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-pipelines.css";
var init_topology_pipelines = __esm({
  "vite:dep-pre-bundle:external-conversion:/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/dist/esm/css/topology-pipelines.css"() {
  }
});

// node_modules/@patternfly/react-topology/dist/esm/css/topology-pipelines.js
var require_topology_pipelines = __commonJS({
  "node_modules/@patternfly/react-topology/dist/esm/css/topology-pipelines.js"(exports) {
    "use strict";
    exports.__esModule = true;
    init_topology_pipelines();
    exports.default = {
      "modifiers": {
        "danger": "pf-m-danger",
        "success": "pf-m-success",
        "warning": "pf-m-warning",
        "skipped": "pf-m-skipped",
        "inProgress": "pf-m-in-progress",
        "running": "pf-m-running",
        "idle": "pf-m-idle",
        "pending": "pf-m-pending",
        "selected": "pf-m-selected",
        "hover": "pf-m-hover",
        "spin": "pf-m-spin",
        "selectable": "pf-m-selectable",
        "unmet": "pf-m-unmet"
      },
      "topologyNodeActionIconIcon": "pf-topology__node__action-icon__icon",
      "topologyPipelinesPill": "pf-topology-pipelines__pill",
      "topologyPipelinesPillBackground": "pf-topology-pipelines__pill-background",
      "topologyPipelinesPillBadge": "pf-topology-pipelines__pill-badge",
      "topologyPipelinesPillStatus": "pf-topology-pipelines__pill-status",
      "topologyPipelinesPillText": "pf-topology-pipelines__pill-text",
      "topologyPipelinesStatusIcon": "pf-topology-pipelines__status-icon",
      "topologyPipelinesStatusIconBackground": "pf-topology-pipelines__status-icon-background",
      "topologyPipelinesWhenExpressionBackground": "pf-topology-pipelines__when-expression-background",
      "topologyPipelinesWhenExpressionEdge": "pf-topology-pipelines__when-expression-edge"
    };
  }
});

// node_modules/@patternfly/react-topology/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  ADD_CHILD_EVENT: () => ADD_CHILD_EVENT,
  ATTR_DATA_ID: () => ATTR_DATA_ID,
  ATTR_DATA_KIND: () => ATTR_DATA_KIND,
  ATTR_DATA_TYPE: () => ATTR_DATA_TYPE,
  AbstractAnchor: () => AbstractAnchor,
  AnchorEnd: () => AnchorEnd,
  BOTTOM_LAYER: () => BOTTOM_LAYER,
  BadgeLocation: () => BadgeLocation,
  BaseEdge: () => BaseEdge,
  BaseElement: () => BaseElement,
  BaseGraph: () => BaseGraph,
  BaseLayout: () => BaseLayout,
  BaseNode: () => BaseNode,
  BasePipelineNode: () => BasePipelineNode_default,
  BreadthFirstLayout: () => BreadthFirstLayout,
  COLLAPSE_ALL: () => COLLAPSE_ALL,
  CREATE_CONNECTOR_DROP_TYPE: () => CREATE_CONNECTOR_DROP_TYPE,
  CREATE_CONNECTOR_OPERATION: () => CREATE_CONNECTOR_OPERATION,
  CenterAnchor: () => CenterAnchor,
  ColaGroup: () => ColaGroup,
  ColaGroupsLayout: () => ColaGroupsLayout,
  ColaGroupsNode: () => ColaGroupsNode,
  ColaLayout: () => ColaLayout,
  ColaLink: () => ColaLink,
  ColaNode: () => ColaNode,
  ConcentricLayout: () => ConcentricLayout,
  ConnectorArrow: () => ConnectorArrow_default,
  ConnectorArrowAlt: () => ConnectorArrowAlt_default,
  ConnectorCircle: () => ConnectorCircle_default,
  ConnectorCross: () => ConnectorCross_default,
  ConnectorSquare: () => ConnectorSquare_default,
  ContextMenu: () => ContextMenu_default,
  ContextMenuItem: () => DropdownItem,
  ContextMenuSeparator: () => Divider,
  ContextSubMenuItem: () => ContextSubMenuItem_default,
  ControllerContext: () => ControllerContext_default,
  DEFAULT_DECORATOR_PADDING: () => DEFAULT_DECORATOR_PADDING,
  DEFAULT_DECORATOR_RADIUS: () => DEFAULT_DECORATOR_RADIUS,
  DEFAULT_EDGE_TYPE: () => DEFAULT_EDGE_TYPE,
  DEFAULT_FINALLY_EDGE_TYPE: () => DEFAULT_FINALLY_EDGE_TYPE,
  DEFAULT_FINALLY_NODE_TYPE: () => DEFAULT_FINALLY_NODE_TYPE,
  DEFAULT_LAYER: () => DEFAULT_LAYER,
  DEFAULT_LAYERS: () => DEFAULT_LAYERS,
  DEFAULT_SPACER_NODE_TYPE: () => DEFAULT_SPACER_NODE_TYPE,
  DEFAULT_TASK_NODE_TYPE: () => DEFAULT_TASK_NODE_TYPE,
  DEFAULT_WHEN_OFFSET: () => DEFAULT_WHEN_OFFSET,
  DEFAULT_WHEN_SIZE: () => DEFAULT_WHEN_SIZE,
  DRAG_MOVE_OPERATION: () => DRAG_MOVE_OPERATION,
  DRAG_NODE_END_EVENT: () => DRAG_NODE_END_EVENT,
  DRAG_NODE_EVENT: () => DRAG_NODE_EVENT,
  DRAG_NODE_START_EVENT: () => DRAG_NODE_START_EVENT,
  DagreGroupsLayout: () => DagreGroupsLayout,
  DagreLayout: () => DagreLayout,
  Decorator: () => Decorator_default,
  DefaultConnectorTerminal: () => DefaultConnectorTerminal_default,
  DefaultConntectorTag: () => DefaultConnectorTag_default,
  DefaultCreateConnector: () => DefaultCreateConnector_default,
  DefaultEdge: () => DefaultEdge_default,
  DefaultGroup: () => DefaultGroup_default,
  DefaultNode: () => DefaultNode_default,
  DefaultRemoveConnector: () => DefaultRemoveConnector_default,
  DefaultTaskGroup: () => DefaultTaskGroup_default,
  DefaultTaskGroupCollapsed: () => DefaultTaskGroupCollapsed_default,
  DefaultTaskGroupExpanded: () => DefaultTaskGroupExpanded_default,
  Dimensions: () => Dimensions,
  DndManagerImpl: () => DndManagerImpl,
  DrawDesign: () => DrawDesign,
  EDGE_DRAG_TYPE: () => EDGE_DRAG_TYPE,
  ELEMENT_VISIBILITY_CHANGE_EVENT: () => ELEMENT_VISIBILITY_CHANGE_EVENT,
  EXPAND_ALL: () => EXPAND_ALL,
  EdgeAnimationSpeed: () => EdgeAnimationSpeed,
  EdgeConnectorArrow: () => DefaultConnectorTerminal_default,
  EdgeStyle: () => EdgeStyle,
  EdgeTerminalType: () => EdgeTerminalType,
  ElementContext: () => ElementContext_default,
  ElementWrapper: () => ElementWrapper_default,
  Ellipse: () => Ellipse_default,
  EllipseAnchor: () => EllipseAnchor,
  FIT_TO_SCREEN: () => FIT_TO_SCREEN,
  FinallyNode: () => FinallyNode_default,
  ForceLayout: () => ForceLayout,
  GRAPH_LAYOUT_END_EVENT: () => GRAPH_LAYOUT_END_EVENT,
  GRAPH_POSITION_CHANGE_EVENT: () => GRAPH_POSITION_CHANGE_EVENT,
  GROUPS_LAYER: () => GROUPS_LAYER,
  GraphComponent: () => GraphComponent_default,
  GridLayout: () => GridLayout,
  HEXAGON_CORNER_RADIUS: () => HEXAGON_CORNER_RADIUS,
  Hexagon: () => Hexagon_default,
  LAYOUT_DEFAULTS: () => LAYOUT_DEFAULTS,
  LEFT_TO_RIGHT: () => LEFT_TO_RIGHT,
  LEGEND: () => LEGEND,
  LOWER_LEFT_RADIANS: () => LOWER_LEFT_RADIANS,
  LOWER_RIGHT_RADIANS: () => LOWER_RIGHT_RADIANS,
  LabelActionIcon: () => LabelActionIcon_default,
  LabelBadge: () => LabelBadge_default,
  LabelContextMenu: () => LabelContextMenu_default,
  LabelIcon: () => LabelIcon_default,
  LabelPosition: () => LabelPosition,
  Layer: () => Layer_default,
  LayersProvider: () => LayersProvider,
  LayoutGroup: () => LayoutGroup,
  LayoutLink: () => LayoutLink,
  LayoutNode: () => LayoutNode,
  MOVE_CONNECTOR_DROP_TYPE: () => MOVE_CONNECTOR_DROP_TYPE,
  ModelKind: () => ModelKind,
  Modifiers: () => Modifiers,
  NODE_COLLAPSE_CHANGE_EVENT: () => NODE_COLLAPSE_CHANGE_EVENT,
  NODE_DRAG_TYPE: () => NODE_DRAG_TYPE,
  NODE_POSITIONED_EVENT: () => NODE_POSITIONED_EVENT,
  NODE_SEPARATION_HORIZONTAL: () => NODE_SEPARATION_HORIZONTAL,
  NODE_SEPARATION_VERTICAL: () => NODE_SEPARATION_VERTICAL,
  NodeLabel: () => NodeLabel_default,
  NodeShadows: () => NodeShadows_default,
  NodeShape: () => NodeShape,
  NodeStatus: () => NodeStatus,
  OCTAGON_CORNER_RADIUS: () => OCTAGON_CORNER_RADIUS,
  Octagon: () => Octagon_default,
  PipelineDagreGroupsLayout: () => PipelineDagreGroupsLayout,
  PipelineDagreLayout: () => PipelineDagreLayout,
  Point: () => Point,
  PolygonAnchor: () => PolygonAnchor,
  REGROUP_OPERATION: () => REGROUP_OPERATION,
  REMOVE_CHILD_EVENT: () => REMOVE_CHILD_EVENT,
  RESET_VIEW: () => RESET_VIEW,
  RHOMBUS_CORNER_RADIUS: () => RHOMBUS_CORNER_RADIUS,
  Rect: () => Rect,
  RectAnchor: () => RectAnchor,
  Rectangle: () => Rectangle_default,
  RegisterComponentFactory: () => RegisterComponentFactory_default,
  RegisterElementFactory: () => RegisterElementFactory_default,
  RegisterLayoutFactory: () => RegisterLayoutFactory_default,
  Rhombus: () => Rhombus_default,
  RunStatus: () => RunStatus,
  SELECTION_EVENT: () => SELECTION_EVENT,
  SELECTION_STATE: () => SELECTION_STATE,
  SVGAnchor: () => SVGAnchor,
  SVGArrowMarker: () => SVGArrowMarker_default,
  SVGDefs: () => SVGDefs,
  SVGDefsProvider: () => SVGDefsProvider_default,
  ScaleDetailsLevel: () => ScaleDetailsLevel,
  SidedShape: () => SidedShape_default,
  SpacerNode: () => SpacerNode_default,
  Stadium: () => Stadium_default,
  StatusIcon: () => StatusIcon_default,
  StatusModifier: () => StatusModifier,
  TOP_LAYER: () => TOP_LAYER,
  TOP_TO_BOTTOM: () => TOP_TO_BOTTOM,
  TRAPEZOID_CORNER_RADIUS: () => TRAPEZOID_CORNER_RADIUS,
  TaskEdge: () => TaskEdge_default,
  TaskGroupPillLabel: () => TaskGroupPillLabel_default,
  TaskGroupSourceAnchor: () => TaskGroupSourceAnchor,
  TaskGroupTargetAnchor: () => TaskGroupTargetAnchor,
  TaskNode: () => TaskNode_default,
  TaskNodeSourceAnchor: () => TaskNodeSourceAnchor,
  TaskNodeTargetAnchor: () => TaskNodeTargetAnchor,
  TaskPill: () => TaskPill_default,
  TopologyControlBar: () => TopologyControlBar,
  TopologyQuadrant: () => TopologyQuadrant,
  TopologySideBar: () => TopologySideBar,
  TopologyView: () => TopologyView,
  Trapezoid: () => Trapezoid_default,
  UPPER_LEFT_RADIANS: () => UPPER_LEFT_RADIANS,
  UPPER_RIGHT_RADIANS: () => UPPER_RIGHT_RADIANS,
  Visualization: () => Visualization,
  VisualizationProvider: () => VisualizationProvider_default,
  VisualizationSurface: () => VisualizationSurface_default,
  WhenDecorator: () => WhenDecorator_default,
  WhenEdge: () => WhenEdge_default,
  WhenNode: () => WhenDecorator_default,
  WhenStatus: () => WhenStatus,
  ZOOM_IN: () => ZOOM_IN,
  ZOOM_OUT: () => ZOOM_OUT,
  action: () => action,
  addSpacerNodes: () => addSpacerNodes,
  boundingBoxForLine: () => boundingBoxForLine,
  canDropEdgeOnNode: () => canDropEdgeOnNode,
  createAggregateEdges: () => createAggregateEdges,
  createSvgIdUrl: () => createSvgIdUrl,
  createTopologyControlButtons: () => createTopologyControlButtons,
  defaultControlButtonsOptions: () => defaultControlButtonsOptions,
  defaultElementFactory: () => defaultElementFactory_default,
  distanceToPoint: () => distanceToPoint,
  edgeDragSourceSpec: () => edgeDragSourceSpec,
  getClosestVisibleParent: () => getClosestVisibleParent,
  getDefaultShapeDecoratorCenter: () => getDefaultShapeDecoratorCenter,
  getEdgeAnimationDuration: () => getEdgeAnimationDuration,
  getEdgeStyleClassModifier: () => getEdgeStyleClassModifier,
  getEdgesFromNodes: () => getEdgesFromNodes,
  getElementPadding: () => getElementPadding,
  getEllipseAnchorPoint: () => getEllipseAnchorPoint,
  getGroupChildrenDimensions: () => getGroupChildrenDimensions,
  getGroupPadding: () => getGroupPadding,
  getHullPath: () => getHullPath,
  getLinesIntersection: () => getLinesIntersection,
  getNodeScaleTranslation: () => getNodeScaleTranslation,
  getPathAnchorPoint: () => getPathAnchorPoint,
  getPathForSides: () => getPathForSides,
  getPointsForSides: () => getPointsForSides,
  getPolygonAnchorPoint: () => getPolygonAnchorPoint,
  getRectAnchorPoint: () => getRectAnchorPoint,
  getRunStatusModifier: () => getRunStatusModifier,
  getShapeComponent: () => getShapeComponent,
  getSpacerNodes: () => getSpacerNodes,
  getTopCollapsedParent: () => getTopCollapsedParent,
  getWhenStatusModifier: () => getWhenStatusModifier,
  graphDropTargetSpec: () => graphDropTargetSpec,
  groupDropTargetSpec: () => groupDropTargetSpec,
  groupNodeElements: () => groupNodeElements,
  highlightNode: () => highlightNode,
  hullPath: () => hullPath,
  integralShapePath: () => integralShapePath,
  isEdge: () => isEdge,
  isGraph: () => isGraph,
  isNode: () => isNode,
  leafNodeElements: () => leafNodeElements,
  matchesType: () => matchesType,
  maxPadding: () => maxPadding,
  noDropTargetSpec: () => noDropTargetSpec,
  noRegroupDragSourceSpec: () => noRegroupDragSourceSpec,
  nodeDragSourceSpec: () => nodeDragSourceSpec,
  nodeDropTargetSpec: () => nodeDropTargetSpec,
  nodesEdgeIsDragging: () => nodesEdgeIsDragging,
  nonShadowModifiers: () => nonShadowModifiers,
  observer: () => observer2,
  path: () => path2,
  pipelineElementFactory: () => pipelineElementFactory_default,
  pointTuplesToPath: () => pointTuplesToPath,
  straightPath: () => straightPath,
  unitNormal: () => unitNormal,
  useAnchor: () => useAnchor,
  useBendpoint: () => useBendpoint,
  useCallbackRef: () => useCallbackRef,
  useCombineRefs: () => useCombineRefs_default,
  useComponentFactory: () => useComponentFactory_default,
  useDetailsLevel: () => useDetailsLevel_default,
  useDndDrag: () => useDndDrag,
  useDndDrop: () => useDndDrop,
  useDndManager: () => useDndManager,
  useDragNode: () => useDragNode,
  useElementFactory: () => useElementFactory_default,
  useEventListener: () => useEventListener_default,
  useHover: () => useHover_default,
  useLayoutFactory: () => useLayoutFactory_default,
  useModel: () => useModel_default,
  usePanZoom: () => usePanZoom,
  usePolygonAnchor: () => usePolygonAnchor,
  useScaleNode: () => useScaleNode_default,
  useSelection: () => useSelection,
  useSize: () => useSize,
  useSvgAnchor: () => useSvgAnchor,
  useVisualizationController: () => useVisualizationController_default,
  useVisualizationState: () => useVisualizationState_default,
  vecScale: () => vecScale,
  vecSum: () => vecSum,
  withAnchor: () => withAnchor,
  withBendpoint: () => withBendpoint,
  withContextMenu: () => withContextMenu,
  withCreateConnector: () => withCreateConnector,
  withDndDrag: () => withDndDrag,
  withDndDrop: () => withDndDrop,
  withDragNode: () => withDragNode,
  withPanZoom: () => withPanZoom,
  withPolygonAnchor: () => withPolygonAnchor,
  withRemoveConnector: () => withRemoveConnector,
  withSelection: () => withSelection,
  withSourceDrag: () => withSourceDrag,
  withSvgAnchor: () => withSvgAnchor,
  withTargetDrag: () => withTargetDrag
});

// node_modules/@patternfly/react-topology/dist/esm/components/TopologyView/TopologyView.js
var React360 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModal.js
var React31 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/dist/esm/index.js
function css(...args) {
  const classes = [];
  const hasOwn = {}.hasOwnProperty;
  args.filter(Boolean).forEach((arg) => {
    const argType = typeof arg;
    if (argType === "string" || argType === "number") {
      classes.push(arg);
    } else if (Array.isArray(arg) && arg.length) {
      const inner2 = css(...arg);
      if (inner2) {
        classes.push(inner2);
      }
    } else if (argType === "object") {
      for (const key in arg) {
        if (hasOwn.call(arg, key) && arg[key]) {
          classes.push(key);
        }
      }
    }
  });
  return classes.join(" ");
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModalBoxContent.js
var React = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/AboutModalBox/about-modal-box.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/AboutModalBox/about-modal-box.css";
var about_modal_box_default = {
  "aboutModalBox": "pf-v6-c-about-modal-box",
  "aboutModalBoxBrand": "pf-v6-c-about-modal-box__brand",
  "aboutModalBoxBrandImage": "pf-v6-c-about-modal-box__brand-image",
  "aboutModalBoxClose": "pf-v6-c-about-modal-box__close",
  "aboutModalBoxContent": "pf-v6-c-about-modal-box__content",
  "aboutModalBoxHeader": "pf-v6-c-about-modal-box__header",
  "aboutModalBoxStrapline": "pf-v6-c-about-modal-box__strapline",
  "button": "pf-v6-c-button",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "plain": "pf-m-plain"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Content/content.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Content/content.css";
var content_default = {
  "content": "pf-v6-c-content",
  "contentA": "pf-v6-c-content--a",
  "contentBlockquote": "pf-v6-c-content--blockquote",
  "contentDd": "pf-v6-c-content--dd",
  "contentDl": "pf-v6-c-content--dl",
  "contentDt": "pf-v6-c-content--dt",
  "contentH1": "pf-v6-c-content--h1",
  "contentH2": "pf-v6-c-content--h2",
  "contentH3": "pf-v6-c-content--h3",
  "contentH4": "pf-v6-c-content--h4",
  "contentH5": "pf-v6-c-content--h5",
  "contentH6": "pf-v6-c-content--h6",
  "contentHr": "pf-v6-c-content--hr",
  "contentLi": "pf-v6-c-content--li",
  "contentOl": "pf-v6-c-content--ol",
  "contentP": "pf-v6-c-content--p",
  "contentPre": "pf-v6-c-content--pre",
  "contentSmall": "pf-v6-c-content--small",
  "contentTable": "pf-v6-c-content--table",
  "contentUl": "pf-v6-c-content--ul",
  "modifiers": {
    "visited": "pf-m-visited",
    "plain": "pf-m-plain"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModalBoxContent.js
var AboutModalBoxContent = (_a2) => {
  var { children: children2, trademark, hasNoContentContainer = false } = _a2, props = __rest(_a2, ["children", "trademark", "hasNoContentContainer"]);
  return React.createElement(
    "div",
    Object.assign({ className: css(about_modal_box_default.aboutModalBoxContent) }, props),
    React.createElement("div", { className: css(`${about_modal_box_default.aboutModalBox}__body`) }, hasNoContentContainer ? children2 : React.createElement("div", { className: css(content_default.content) }, children2)),
    React.createElement("p", { className: css(about_modal_box_default.aboutModalBoxStrapline) }, trademark)
  );
};
AboutModalBoxContent.displayName = "AboutModalBoxContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModalBoxHeader.js
var React11 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Title/Title.js
var React10 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Title/title.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Title/title.css";
var title_default = {
  "modifiers": {
    "4xl": "pf-m-4xl",
    "3xl": "pf-m-3xl",
    "2xl": "pf-m-2xl",
    "xl": "pf-m-xl",
    "lg": "pf-m-lg",
    "md": "pf-m-md",
    "h1": "pf-m-h1",
    "h2": "pf-m-h2",
    "h3": "pf-m-h3",
    "h4": "pf-m-h4",
    "h5": "pf-m-h5",
    "h6": "pf-m-h6"
  },
  "title": "pf-v6-c-title"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/createIcon.js
var React2 = __toESM(require_react());
var currentId = 0;
function createIcon({ name, xOffset = 0, yOffset = 0, width, height, svgPath }) {
  var _a2;
  return _a2 = class SVGIcon extends React2.Component {
    constructor() {
      super(...arguments);
      this.id = `icon-title-${currentId++}`;
    }
    render() {
      const _b = this.props, { title, className } = _b, props = __rest(_b, ["title", "className"]);
      const classes = className ? `pf-v6-svg ${className}` : "pf-v6-svg";
      const hasTitle = Boolean(title);
      const viewBox = [xOffset, yOffset, width, height].join(" ");
      return React2.createElement(
        "svg",
        Object.assign({ className: classes, viewBox, fill: "currentColor", "aria-labelledby": hasTitle ? this.id : null, "aria-hidden": hasTitle ? null : true, role: "img", width: "1em", height: "1em" }, props),
        hasTitle && React2.createElement("title", { id: this.id }, title),
        React2.createElement("path", { d: svgPath })
      );
    }
  }, _a2.displayName = name, _a2;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/check-circle-icon.js
var CheckCircleIconConfig = {
  name: "CheckCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z",
  yOffset: 0,
  xOffset: 0
};
var CheckCircleIcon = createIcon(CheckCircleIconConfig);
var check_circle_icon_default = CheckCircleIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/exclamation-circle-icon.js
var ExclamationCircleIconConfig = {
  name: "ExclamationCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z",
  yOffset: 0,
  xOffset: 0
};
var ExclamationCircleIcon = createIcon(ExclamationCircleIconConfig);
var exclamation_circle_icon_default = ExclamationCircleIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/exclamation-triangle-icon.js
var ExclamationTriangleIconConfig = {
  name: "ExclamationTriangleIcon",
  height: 512,
  width: 576,
  svgPath: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z",
  yOffset: 0,
  xOffset: 0
};
var ExclamationTriangleIcon = createIcon(ExclamationTriangleIconConfig);
var exclamation_triangle_icon_default = ExclamationTriangleIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/info-circle-icon.js
var InfoCircleIconConfig = {
  name: "InfoCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z",
  yOffset: 0,
  xOffset: 0
};
var InfoCircleIcon = createIcon(InfoCircleIconConfig);
var info_circle_icon_default = InfoCircleIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/bell-icon.js
var BellIconConfig = {
  name: "BellIcon",
  height: 1024,
  width: 896,
  svgPath: "M448,0 C465.333333,0 480.333333,6.33333333 493,19 C505.666667,31.6666667 512,46.6666667 512,64 L512,106 L514.23,106.45 C587.89,121.39 648.48,157.24 696,214 C744,271.333333 768,338.666667 768,416 C768,500 780,568.666667 804,622 C818.666667,652.666667 841.333333,684 872,716 C873.773676,718.829136 875.780658,721.505113 878,724 C890,737.333333 896,752.333333 896,769 C896,785.666667 890,800.333333 878,813 C866,825.666667 850.666667,832 832,832 L63.3,832 C44.9533333,831.84 29.8533333,825.506667 18,813 C6,800.333333 0,785.666667 0,769 C0,752.333333 6,737.333333 18,724 L24,716 L25.06,714.9 C55.1933333,683.28 77.5066667,652.313333 92,622 C116,568.666667 128,500 128,416 C128,338.666667 152,271.333333 200,214 C248,156.666667 309.333333,120.666667 384,106 L384,63.31 C384.166667,46.27 390.5,31.5 403,19 C415.666667,6.33333333 430.666667,0 448,0 Z M576,896 L576,897.08 C575.74,932.6 563.073333,962.573333 538,987 C512.666667,1011.66667 482.666667,1024 448,1024 C413.333333,1024 383.333333,1011.66667 358,987 C332.666667,962.333333 320,932 320,896 L576,896 Z",
  yOffset: 0,
  xOffset: 0
};
var BellIcon = createIcon(BellIconConfig);
var bell_icon_default = BellIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/constants.js
var ValidatedOptions;
(function(ValidatedOptions2) {
  ValidatedOptions2["success"] = "success";
  ValidatedOptions2["error"] = "error";
  ValidatedOptions2["warning"] = "warning";
  ValidatedOptions2["default"] = "default";
})(ValidatedOptions || (ValidatedOptions = {}));
var KeyTypes = {
  Tab: "Tab",
  Space: " ",
  Escape: "Escape",
  Enter: "Enter",
  ArrowUp: "ArrowUp",
  ArrowDown: "ArrowDown",
  ArrowLeft: "ArrowLeft",
  ArrowRight: "ArrowRight"
};
var globalWidthBreakpoints = {
  sm: parseInt(global_breakpoint_sm_default.value),
  md: parseInt(global_breakpoint_md_default.value),
  lg: parseInt(global_breakpoint_lg_default.value),
  xl: parseInt(global_breakpoint_xl_default.value),
  "2xl": parseInt(global_breakpoint_2xl_default.value)
};
var globalHeightBreakpoints = {
  sm: parseInt(global_breakpoint_height_sm_default.value),
  md: parseInt(global_breakpoint_height_md_default.value),
  lg: parseInt(global_breakpoint_height_lg_default.value),
  xl: parseInt(global_breakpoint_height_xl_default.value),
  "2xl": parseInt(global_breakpoint_height_2xl_default.value)
};
var statusIcons = {
  success: check_circle_icon_default,
  danger: exclamation_circle_icon_default,
  warning: exclamation_triangle_icon_default,
  info: info_circle_icon_default,
  custom: bell_icon_default
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/FocusTrap/FocusTrap.js
var import_react2 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/useUnmountEffect.js
var import_react = __toESM(require_react());
function useUnmountEffect(effect4) {
  const effectRef = (0, import_react.useRef)(effect4);
  effectRef.current = effect4;
  (0, import_react.useEffect)(() => () => {
    effectRef.current();
  }, []);
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/FocusTrap/FocusTrap.js
var FocusTrap = (0, import_react2.forwardRef)(function FocusTrap2(_a2, forwardedRef) {
  var { active = true, paused = false, focusTrapOptions = {}, preventScrollOnDeactivate = false } = _a2, props = __rest(_a2, ["active", "paused", "focusTrapOptions", "preventScrollOnDeactivate"]);
  const ref = (0, import_react2.useRef)(null);
  (0, import_react2.useImperativeHandle)(forwardedRef, () => ref.current);
  const focusTrapRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    const focusTrap = createFocusTrap(ref.current, Object.assign(Object.assign({}, focusTrapOptions), { returnFocusOnDeactivate: false }));
    focusTrapRef.current = focusTrap;
    return () => {
      focusTrap.deactivate();
    };
  }, []);
  (0, import_react2.useEffect)(() => {
    const focusTrap = focusTrapRef.current;
    active ? focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.activate() : focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.deactivate();
  }, [active]);
  (0, import_react2.useEffect)(() => {
    const focusTrap = focusTrapRef.current;
    paused ? focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.pause() : focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.unpause();
  }, [paused]);
  const previousElementRef = (0, import_react2.useRef)(typeof document !== "undefined" ? document.activeElement : null);
  useUnmountEffect(() => {
    if (focusTrapOptions.returnFocusOnDeactivate !== false && previousElementRef.current instanceof HTMLElement) {
      previousElementRef.current.focus({
        preventScroll: preventScrollOnDeactivate
      });
    }
  });
  return import_react2.default.createElement("div", Object.assign({ ref }, props));
});
FocusTrap.displayName = "FocusTrap";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/GenerateId/GenerateId.js
var React4 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/util.js
var ReactDOM = __toESM(require_react_dom());
function capitalize(input) {
  return input[0].toUpperCase() + input.substring(1);
}
function getUniqueId(prefix = "pf") {
  const uid2 = (/* @__PURE__ */ new Date()).getTime() + Math.random().toString(36).slice(2);
  return `${prefix}-${uid2}`;
}
function debounce(func, wait) {
  let timeout2;
  return (...args) => {
    clearTimeout(timeout2);
    timeout2 = setTimeout(() => func.apply(this, args), wait);
  };
}
function isElementInView(container, element, partial, strict = false) {
  if (!container || !element) {
    return false;
  }
  const containerBounds = container.getBoundingClientRect();
  const elementBounds = element.getBoundingClientRect();
  const containerBoundsLeft = Math.ceil(containerBounds.left);
  const containerBoundsRight = Math.floor(containerBounds.right);
  const elementBoundsLeft = Math.ceil(elementBounds.left);
  const elementBoundsRight = Math.floor(elementBounds.right);
  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;
  const isPartiallyInView = (partial || !strict && containerBounds.width < elementBounds.width) && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight);
  return isTotallyInView || isPartiallyInView;
}
function fillTemplate(templateString, templateVars) {
  return templateString.replace(/\${(.*?)}/g, (_14, match) => templateVars[match] || "");
}
function pluralize(i, singular, plural) {
  if (!plural) {
    plural = `${singular}s`;
  }
  return `${i || 0} ${i === 1 ? singular : plural}`;
}
var setBreakpointCssVars = (mods, cssVar) => Object.entries(mods || {}).reduce((acc, [breakpoint, value]) => breakpoint === "default" ? Object.assign(Object.assign({}, acc), { [cssVar]: value }) : Object.assign(Object.assign({}, acc), { [`${cssVar}-on-${breakpoint}`]: value }), {});
var formatBreakpointMods = (mods, styles36, stylePrefix = "", breakpoint, vertical) => {
  if (!mods) {
    return "";
  }
  if (breakpoint && !vertical) {
    if (breakpoint in mods) {
      return styles36.modifiers[toCamel(`${stylePrefix}${mods[breakpoint]}`)];
    }
    const breakpointsOrder = ["2xl", "xl", "lg", "md", "sm", "default"];
    const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);
    for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {
      if (breakpointsOrder[i] in mods) {
        return styles36.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i]]}`)];
      }
    }
    return "";
  }
  return Object.entries(mods || {}).map(([breakpoint2, mod]) => `${stylePrefix}${mod}${breakpoint2 !== "default" ? `-on-${breakpoint2}` : ""}${vertical && breakpoint2 !== "default" ? "-height" : ""}`).map(toCamel).map((mod) => mod.replace(/-?(\dxl)/gi, (_res, group2) => `_${group2}`)).map((modifierKey) => styles36.modifiers[modifierKey]).filter(Boolean).join(" ");
};
var getVerticalBreakpoint = (height) => {
  if (height === null) {
    return null;
  }
  if (height >= globalHeightBreakpoints["2xl"]) {
    return "2xl";
  }
  if (height >= globalHeightBreakpoints.xl) {
    return "xl";
  }
  if (height >= globalHeightBreakpoints.lg) {
    return "lg";
  }
  if (height >= globalHeightBreakpoints.md) {
    return "md";
  }
  if (height >= globalHeightBreakpoints.sm) {
    return "sm";
  }
  return "default";
};
var getBreakpoint = (width) => {
  if (width === null) {
    return null;
  }
  if (width >= globalWidthBreakpoints["2xl"]) {
    return "2xl";
  }
  if (width >= globalWidthBreakpoints.xl) {
    return "xl";
  }
  if (width >= globalWidthBreakpoints.lg) {
    return "lg";
  }
  if (width >= globalWidthBreakpoints.md) {
    return "md";
  }
  if (width >= globalWidthBreakpoints.sm) {
    return "sm";
  }
  return "default";
};
var camelize = (s2) => s2.toUpperCase().replace("-", "").replace("_", "");
var toCamel = (s2) => s2.replace(/([-_][a-z])/gi, camelize);
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var getTextWidth = (text, node) => {
  const computedStyle = getComputedStyle(node);
  const getFontFromComputedStyle = () => {
    let computedFont = "";
    const fontStretchLookupTable = {
      "50%": "ultra-condensed",
      "62.5%": "extra-condensed",
      "75%": "condensed",
      "87.5%": "semi-condensed",
      "100%": "normal",
      "112.5%": "semi-expanded",
      "125%": "expanded",
      "150%": "extra-expanded",
      "200%": "ultra-expanded"
    };
    let fontStretch;
    if (computedStyle.fontStretch in fontStretchLookupTable) {
      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];
    } else {
      fontStretch = "normal";
    }
    computedFont = computedStyle.fontStyle + " " + computedStyle.fontVariant + " " + computedStyle.fontWeight + " " + fontStretch + " " + computedStyle.fontSize + "/" + computedStyle.lineHeight + " " + computedStyle.fontFamily;
    return computedFont;
  };
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.font = computedStyle.font || getFontFromComputedStyle();
  return context.measureText(text).width;
};
var innerDimensions = (node) => {
  const computedStyle = getComputedStyle(node);
  let width = node.clientWidth;
  let height = node.clientHeight;
  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
  return { height, width };
};
var trimLeft = (node, value) => {
  const availableWidth = innerDimensions(node).width;
  let newValue = value;
  if (getTextWidth(value, node) > availableWidth) {
    while (getTextWidth(`...${newValue}`, node) > availableWidth) {
      newValue = newValue.substring(1);
    }
    if (node.value) {
      node.value = `...${newValue}`;
    } else {
      node.innerText = `...${newValue}`;
    }
  } else {
    if (node.value) {
      node.value = value;
    } else {
      node.innerText = value;
    }
  }
};
var clearTimeouts = (timeoutRefs) => {
  timeoutRefs.forEach((ref) => {
    if (ref.current) {
      clearTimeout(ref.current);
    }
  });
};
var getLanguageDirection = (targetElement, defaultDirection = "ltr") => {
  if (!targetElement) {
    return defaultDirection;
  }
  const computedDirection = getComputedStyle(targetElement).getPropertyValue("direction");
  if (["ltr", "rtl"].includes(computedDirection)) {
    return computedDirection;
  }
  return defaultDirection;
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/GenerateId/GenerateId.js
var currentId2 = 0;
function getRandomId() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  } else {
    return getUniqueId();
  }
}
var GenerateId = class extends React4.Component {
  constructor() {
    super(...arguments);
    this.uniqueElement = this.props.isRandom ? getRandomId() : currentId2++;
    this.id = `${this.props.prefix}${this.uniqueElement}`;
  }
  render() {
    return this.props.children(this.id);
  }
};
GenerateId.displayName = "GenerateId";
GenerateId.defaultProps = {
  prefix: "pf-random-id-",
  isRandom: false
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/htmlConstants.js
var ASTERISK = "*";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/OUIA/ouia.js
var import_react3 = __toESM(require_react());
var uid = 0;
var ouiaPrefix = "OUIA-Generated-";
var ouiaIdByRoute = {};
function getOUIAProps(componentType, id2, ouiaSafe = true) {
  return {
    "data-ouia-component-type": `PF6/${componentType}`,
    "data-ouia-safe": ouiaSafe,
    "data-ouia-component-id": id2
  };
}
var useOUIAProps = (componentType, id2, ouiaSafe = true, variant) => ({
  "data-ouia-component-type": `PF6/${componentType}`,
  "data-ouia-safe": ouiaSafe,
  "data-ouia-component-id": useOUIAId(componentType, id2, variant)
});
var useOUIAId = (componentType, id2, variant) => {
  const defaultOUIAId = (0, import_react3.useMemo)(() => getDefaultOUIAId(componentType, variant), [componentType, variant]);
  return id2 !== null && id2 !== void 0 ? id2 : defaultOUIAId;
};
function getDefaultOUIAId(componentType, variant) {
  try {
    let key;
    if (typeof window !== "undefined") {
      key = `${window.location.href}-${componentType}-${variant || ""}`;
    } else {
      key = `${componentType}-${variant || ""}`;
    }
    if (!ouiaIdByRoute[key]) {
      ouiaIdByRoute[key] = 0;
    }
    return `${ouiaPrefix}${componentType}-${variant ? `${variant}-` : ""}${++ouiaIdByRoute[key]}`;
  } catch (exception) {
    return `${ouiaPrefix}${componentType}-${variant ? `${variant}-` : ""}${++uid}`;
  }
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/Popper.js
var React7 = __toESM(require_react());
var ReactDOM2 = __toESM(require_react_dom());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/react-popper/usePopper.js
var React6 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getWindow.js
function getWindow(node) {
  if (node.toString() !== "[object Window]") {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  return node;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  const win = getWindow(node);
  const scrollLeft = win.pageXOffset;
  const scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/instanceOf.js
function isElement(node) {
  const OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  const OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return (isElement(element) ? element.ownerDocument : element.document).documentElement;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/isScrollParent.js
function isScrollParent(element) {
  const { overflow, overflowX, overflowY } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getCompositeRect.js
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed2 = false) {
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(elementOrVirtualElement);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  let scroll = { scrollLeft: 0, scrollTop: 0 };
  let offsets = { x: 0, y: 0 };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed2) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    // $FlowFixMe: need a better way to handle this...
    element.host || // ShadowRoot detected
    // $FlowFixMe: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/listScrollParents.js
function listScrollParents(element, list = []) {
  const scrollParent = getScrollParent(element);
  const isBody = getNodeName(scrollParent) === "body";
  const win = getWindow(scrollParent);
  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element).position === "fixed") {
    return null;
  }
  const offsetParent = element.offsetParent;
  if (offsetParent) {
    const html2 = getDocumentElement(offsetParent);
    if (getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && getComputedStyle2(html2).position !== "static") {
      return html2;
    }
  }
  return offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    const css3 = getComputedStyle2(currentNode);
    if (css3.transform !== "none" || css3.perspective !== "none" || css3.willChange && css3.willChange !== "auto") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static") {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce((acc, placement) => acc.concat([`${placement}-${start}`, `${placement}-${end}`]), []);
var placements = [...basePlacements, auto].reduce((acc, placement) => acc.concat([placement, `${placement}-${start}`, `${placement}-${end}`]), []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
  beforeRead,
  read,
  afterRead,
  beforeMain,
  main,
  afterMain,
  beforeWrite,
  write,
  afterWrite
];

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/orderModifiers.js
function order(modifiers2) {
  const map5 = /* @__PURE__ */ new Map();
  const visited = /* @__PURE__ */ new Set();
  const result = [];
  modifiers2.forEach((modifier) => {
    map5.set(modifier.name, modifier);
  });
  function sort3(modifier) {
    visited.add(modifier.name);
    const requires = [...modifier.requires || [], ...modifier.requiresIfExists || []];
    requires.forEach((dep) => {
      if (!visited.has(dep)) {
        const depModifier = map5.get(dep);
        if (depModifier) {
          sort3(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach((modifier) => {
    if (!visited.has(modifier.name)) {
      sort3(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  const orderedModifiers = order(modifiers2);
  return modifierPhases.reduce((acc, phase) => acc.concat(orderedModifiers.filter((modifier) => modifier.phase === phase)), []);
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/debounce.js
function debounce2(fn) {
  let pending;
  return () => {
    if (!pending) {
      pending = new Promise((resolve) => {
        Promise.resolve().then(() => {
          pending = void 0;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/mergeByName.js
function mergeByName(modifiers2) {
  const merged = modifiers2.reduce((merged2, current) => {
    const existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), { options: Object.assign(Object.assign({}, existing.options), current.options), data: Object.assign(Object.assign({}, existing.data), current.data) }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map((key) => merged[key]);
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getViewportRect.js
function getViewportRect(element) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x4 = 0;
  let y4 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x4 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x4 + getWindowScrollBarX(element),
    y: y4
  };
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  const html2 = getDocumentElement(element);
  const winScroll = getWindowScroll(element);
  const body = element.ownerDocument.body;
  const width = Math.max(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = Math.max(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x4 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  const y4 = -winScroll.scrollTop;
  if (getComputedStyle2(body || html2).direction === "rtl") {
    x4 += Math.max(html2.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return { width, height, x: x4, y: y4 };
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/contains.js
function contains(parent, child) {
  const isShadow = Boolean(child.getRootNode && child.getRootNode().host);
  if (parent.contains(child)) {
    return true;
  } else if (isShadow) {
    let next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign(Object.assign({}, rect), { left: rect.x, top: rect.y, right: rect.x + rect.width, bottom: rect.y + rect.height });
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element) {
  const rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  const clippingParents2 = listScrollParents(getParentNode(element));
  const canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter((clippingParent) => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body");
}
function getClippingRect(element, boundary, rootBoundary) {
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  const clippingParents2 = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents2[0];
  const clippingRect = clippingParents2.reduce((accRect, clippingParent) => {
    const rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = Math.max(rect.top, accRect.top);
    accRect.right = Math.min(rect.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/computeOffsets.js
function computeOffsets({ reference: reference2, element, placement }) {
  const basePlacement = placement ? getBasePlacement(placement) : null;
  const variation = placement ? getVariation(placement) : null;
  const commonX = reference2.x + reference2.width / 2 - element.width / 2;
  const commonY = reference2.y + reference2.height / 2 - element.height / 2;
  let offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  const mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    const len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign(Object.assign({}, getFreshSideObject()), paddingObject);
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce((hashMap, key) => {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/detectOverflow.js
function detectOverflow(state, options = {}) {
  const { placement = state.placement, boundary = clippingParents, rootBoundary = viewport, elementContext = popper, altBoundary = false, padding = 0 } = options;
  const paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  const altContext = elementContext === popper ? reference : popper;
  const referenceElement = state.elements.reference;
  const popperRect = state.rects.popper;
  const element = state.elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  const referenceClientRect = getBoundingClientRect(referenceElement);
  const popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets2));
  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  const overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  const offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    const offset3 = offsetData[placement];
    Object.keys(overflowOffsets).forEach((key) => {
      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      const axis2 = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset3[axis2] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/index.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements(...args) {
  return !args.some((element) => !(element && typeof element.getBoundingClientRect === "function"));
}
function popperGenerator(generatorOptions = {}) {
  const { defaultModifiers: defaultModifiers2 = [], defaultOptions = DEFAULT_OPTIONS } = generatorOptions;
  return function createPopper3(reference2, popper2, options = defaultOptions) {
    let state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    let effectCleanupFns = [];
    let isDestroyed = false;
    const instance = {
      state,
      setOptions(options2) {
        cleanupModifierEffects();
        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        const orderedModifiers = orderModifiers(mergeByName([...defaultModifiers2, ...state.options.modifiers]));
        state.orderedModifiers = orderedModifiers.filter((m3) => m3.enabled);
        if (false) {
          const modifiers2 = uniqueBy([...orderedModifiers, ...state.options.modifiers], ({ name }) => name);
          validateModifiers(modifiers2);
          if (getBasePlacement(state.options.placement) === auto) {
            const flipModifier = state.orderedModifiers.find(({ name }) => name === "flip");
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          const { marginTop, marginRight, marginBottom, marginLeft } = getComputedStyle2(popper2);
          if ([marginTop, marginRight, marginBottom, marginLeft].some((margin) => parseFloat(margin))) {
            console.warn([
              'Popper: CSS "margin" styles cannot be used to apply padding',
              "between the popper and its reference element or boundary.",
              "To replicate margin, use the `offset` modifier, as well as",
              "the `padding` option in the `preventOverflow` and `flip`",
              "modifiers."
            ].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update â€“ it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate() {
        if (isDestroyed) {
          return;
        }
        const { reference: reference3, popper: popper3 } = state.elements;
        if (!areValidElements(reference3, popper3)) {
          if (false) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach((modifier) => state.modifiersData[modifier.name] = Object.assign({}, modifier.data));
        let __debug_loops__ = 0;
        for (let index4 = 0; index4 < state.orderedModifiers.length; index4++) {
          if (false) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index4 = -1;
            continue;
          }
          const { fn, options: options2 = {}, name } = state.orderedModifiers[index4];
          if (typeof fn === "function") {
            state = fn({ state, options: options2, name, instance }) || state;
          }
        }
      },
      // Async and optimistically optimized update â€“ it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce2(() => new Promise((resolve) => {
        instance.forceUpdate();
        resolve(state);
      })),
      destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (false) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then((state2) => {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(({ name, options: options2 = {}, effect: effect4 }) => {
        if (typeof effect4 === "function") {
          const cleanupFn = effect4({ state, name, instance, options: options2 });
          const noopFn = () => {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach((fn) => fn());
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/eventListeners.js
var passive = { passive: true };
function effect({ state, instance, options }) {
  const { scroll = true, resize = true } = options;
  const window2 = getWindow(state.elements.popper);
  const scrollParents = [...state.scrollParents.reference, ...state.scrollParents.popper];
  if (scroll) {
    scrollParents.forEach((scrollParent) => {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return () => {
    if (scroll) {
      scrollParents.forEach((scrollParent) => {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: () => {
  },
  effect,
  data: {}
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/popperOffsets.js
function popperOffsets({ state, name }) {
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsets({ x: x4, y: y4 }) {
  const win = window;
  const dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x4 * dpr) / dpr || 0,
    y: Math.round(y4 * dpr) / dpr || 0
  };
}
function mapToStyles({ popper: popper2, popperRect, placement, offsets, position, gpuAcceleration, adaptive }) {
  let { x: x4, y: y4 } = roundOffsets(offsets);
  const hasX = offsets.hasOwnProperty("x");
  const hasY = offsets.hasOwnProperty("y");
  let sideX = left;
  let sideY = top;
  const win = window;
  if (adaptive) {
    let offsetParent = getOffsetParent(popper2);
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
    }
    if (placement === top) {
      sideY = bottom;
      y4 -= offsetParent.clientHeight - popperRect.height;
      y4 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left) {
      sideX = right;
      x4 -= offsetParent.clientWidth - popperRect.width;
      x4 *= gpuAcceleration ? 1 : -1;
    }
  }
  const commonStyles = Object.assign({ position }, adaptive && unsetSides);
  if (gpuAcceleration) {
    return Object.assign(Object.assign({}, commonStyles), {
      [sideY]: hasY ? "0" : "",
      [sideX]: hasX ? "0" : "",
      // Layer acceleration can disable subpixel rendering which causes slightly
      // blurry text on low PPI displays, so we want to use 2D transforms
      // instead
      transform: (win.devicePixelRatio || 1) < 2 ? `translate(${x4}px, ${y4}px)` : `translate3d(${x4}px, ${y4}px, 0)`
    });
  }
  return Object.assign(Object.assign({}, commonStyles), { [sideY]: hasY ? `${y4}px` : "", [sideX]: hasX ? `${x4}px` : "", transform: "" });
}
function computeStyles({ state, options }) {
  const { gpuAcceleration = true, adaptive = true } = options;
  if (false) {
    const transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some((property) => transitionProperty.indexOf(property) >= 0)) {
      console.warn([
        "Popper: Detected CSS transitions on at least one of the following",
        'CSS properties: "transform", "top", "right", "bottom", "left".',
        "\n\n",
        'Disable the "computeStyles" modifier\'s `adaptive` option to allow',
        "for smooth transitions, or remove these properties from the CSS",
        "transition declaration on the popper element if only transitioning",
        "opacity or background-color for example.",
        "\n\n",
        "We recommend using the popper element as a wrapper around an inner",
        "element that can have any CSS property transitioned for animations."
      ].join(" "));
    }
  }
  const commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), { offsets: state.modifiersData.popperOffsets, position: state.options.strategy, adaptive })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), { offsets: state.modifiersData.arrow, position: "absolute", adaptive: false })));
  }
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), { "data-popper-placement": state.placement });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/applyStyles.js
function applyStyles({ state }) {
  Object.keys(state.elements).forEach((name) => {
    const style = state.styles[name] || {};
    const attributes = state.attributes[name] || {};
    const element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach((name2) => {
      const value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect2({ state }) {
  const initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return () => {
    Object.keys(state.elements).forEach((name) => {
      const element = state.elements[name];
      const attributes = state.attributes[name] || {};
      const styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      const style = styleProperties.reduce((style2, property) => {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach((attribute) => {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect2,
  requires: ["computeStyles"]
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset3) {
  const basePlacement = getBasePlacement(placement);
  const invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  let [skidding, distance] = typeof offset3 === "function" ? offset3(Object.assign(Object.assign({}, rects), { placement })) : offset3;
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? { x: distance, y: skidding } : { x: skidding, y: distance };
}
function offset({ state, options, name }) {
  const { offset: offset3 = [0, 0] } = options;
  const data = placements.reduce((acc, placement) => {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
    return acc;
  }, {});
  const { x: x4, y: y4 } = data[state.placement];
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x4;
    state.modifiersData.popperOffsets.y += y4;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getOppositePlacement.js
var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash[matched]);
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getOppositeVariationPlacement.js
var hash2 = { start: "end", end: "start" };
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash2[matched]);
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options = {}) {
  const { placement, boundary, rootBoundary, padding, flipVariations, allowedAutoPlacements = placements } = options;
  const variation = getVariation(placement);
  const placements3 = variation ? flipVariations ? variationPlacements : variationPlacements.filter((placement2) => getVariation(placement2) === variation) : basePlacements;
  let allowedPlacements = placements3.filter((placement2) => allowedAutoPlacements.indexOf(placement2) >= 0);
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements3;
    if (false) {
      console.error([
        "Popper: The `allowedAutoPlacements` option did not allow any",
        "placements. Ensure the `placement` option matches the variation",
        "of the allowed placements.",
        'For example, "auto" cannot be used to allow "bottom-start".',
        'Use "auto-start" instead.'
      ].join(" "));
    }
  }
  const overflows = allowedPlacements.reduce((acc, placement2) => {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort((a4, b) => overflows[a4] - overflows[b]);
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  const oppositePlacement = getOppositePlacement(placement);
  return [
    getOppositeVariationPlacement(placement),
    oppositePlacement,
    getOppositeVariationPlacement(oppositePlacement)
  ];
}
function flip({ state, options, name }) {
  if (state.modifiersData[name]._skip) {
    return;
  }
  const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = true, fallbackPlacements: specifiedFallbackPlacements, padding, boundary, rootBoundary, altBoundary, flipVariations = true, allowedAutoPlacements } = options;
  const preferredPlacement = state.options.placement;
  const basePlacement = getBasePlacement(preferredPlacement);
  const isBasePlacement = basePlacement === preferredPlacement;
  const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  const placements3 = [preferredPlacement, ...fallbackPlacements].reduce((acc, placement) => acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
    placement,
    boundary,
    rootBoundary,
    padding,
    flipVariations,
    allowedAutoPlacements
  }) : placement), []);
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const checksMap = /* @__PURE__ */ new Map();
  let makeFallbackChecks = true;
  let firstFittingPlacement = placements3[0];
  for (let i = 0; i < placements3.length; i++) {
    const placement = placements3[i];
    const basePlacement2 = getBasePlacement(placement);
    const isStartVariation = getVariation(placement) === start;
    const isVertical = [top, bottom].indexOf(basePlacement2) >= 0;
    const len = isVertical ? "width" : "height";
    const overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    let mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    const altVariationSide = getOppositePlacement(mainVariationSide);
    const checks = [];
    if (checkMainAxis) {
      checks.push(overflow[basePlacement2] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every((check) => check)) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    const numberOfChecks = flipVariations ? 3 : 1;
    for (let i = numberOfChecks; i > 0; i--) {
      const fittingPlacement = placements3.find((placement) => {
        const checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, i).every((check) => check);
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        break;
      }
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: { _skip: false }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getAltAxis.js
function getAltAxis(axis2) {
  return axis2 === "x" ? "y" : "x";
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/within.js
function within(min4, value, max5) {
  return Math.max(min4, Math.min(value, max5));
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/preventOverflow.js
function preventOverflow({ state, options, name }) {
  const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = false, boundary, rootBoundary, altBoundary, padding, tether = true, tetherOffset = 0 } = options;
  const overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  const basePlacement = getBasePlacement(state.placement);
  const variation = getVariation(state.placement);
  const isBasePlacement = !variation;
  const mainAxis = getMainAxisFromPlacement(basePlacement);
  const altAxis = getAltAxis(mainAxis);
  const popperOffsets2 = state.modifiersData.popperOffsets;
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign(Object.assign({}, state.rects), { placement: state.placement })) : tetherOffset;
  const data = { x: 0, y: 0 };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    const mainSide = mainAxis === "y" ? top : left;
    const altSide = mainAxis === "y" ? bottom : right;
    const len = mainAxis === "y" ? "height" : "width";
    const offset3 = popperOffsets2[mainAxis];
    const min4 = popperOffsets2[mainAxis] + overflow[mainSide];
    const max5 = popperOffsets2[mainAxis] - overflow[altSide];
    const additive = tether ? -popperRect[len] / 2 : 0;
    const minLen = variation === start ? referenceRect[len] : popperRect[len];
    const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    const arrowElement = state.elements.arrow;
    const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 };
    const arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    const arrowPaddingMin = arrowPaddingObject[mainSide];
    const arrowPaddingMax = arrowPaddingObject[altSide];
    const arrowLen = within(0, referenceRect[len], arrowRect[len]);
    const minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    const maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    const clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    const tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    const tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
    const preventedOffset = within(tether ? Math.min(min4, tetherMin) : min4, offset3, tether ? Math.max(max5, tetherMax) : max5);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset3;
  }
  if (checkAltAxis) {
    const mainSide = mainAxis === "x" ? top : left;
    const altSide = mainAxis === "x" ? bottom : right;
    const offset3 = popperOffsets2[altAxis];
    const min4 = offset3 + overflow[mainSide];
    const max5 = offset3 - overflow[altSide];
    const preventedOffset = within(min4, offset3, max5);
    popperOffsets2[altAxis] = preventedOffset;
    data[altAxis] = preventedOffset - offset3;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/arrow.js
function arrow({ state, name }) {
  const arrowElement = state.elements.arrow;
  const popperOffsets2 = state.modifiersData.popperOffsets;
  const basePlacement = getBasePlacement(state.placement);
  const axis2 = getMainAxisFromPlacement(basePlacement);
  const isVertical = [left, right].indexOf(basePlacement) >= 0;
  const len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  const paddingObject = state.modifiersData[`${name}#persistent`].padding;
  const arrowRect = getLayoutRect(arrowElement);
  const minProp = axis2 === "y" ? top : left;
  const maxProp = axis2 === "y" ? bottom : right;
  const endDiff = state.rects.reference[len] + state.rects.reference[axis2] - popperOffsets2[axis2] - state.rects.popper[len];
  const startDiff = popperOffsets2[axis2] - state.rects.reference[axis2];
  const arrowOffsetParent = getOffsetParent(arrowElement);
  const clientSize = arrowOffsetParent ? axis2 === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  const centerToReference = endDiff / 2 - startDiff / 2;
  const min4 = paddingObject[minProp];
  const max5 = clientSize - arrowRect[len] - paddingObject[maxProp];
  const center2 = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  const offset3 = within(min4, center2, max5);
  const axisProp = axis2;
  state.modifiersData[name] = {
    [axisProp]: offset3,
    centerOffset: offset3 - center2
  };
}
function effect3({ state, options, name }) {
  let { element: arrowElement = "[data-popper-arrow]", padding = 0 } = options;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (false) {
    if (!isHTMLElement(arrowElement)) {
      console.error([
        'Popper: "arrow" element must be an HTMLElement (not an SVGElement).',
        "To use an SVG arrow, wrap it in an HTMLElement that will be used as",
        "the arrow."
      ].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (false) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
  state.modifiersData[`${name}#persistent`] = {
    padding: mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements))
  };
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect3,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets = { x: 0, y: 0 }) {
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some((side) => overflow[side] >= 0);
}
function hide({ state, name }) {
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const preventedOffsets = state.modifiersData.preventOverflow;
  const referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  const popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  const referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  const popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  const isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  const hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), { "data-popper-reference-hidden": isReferenceHidden, "data-popper-escaped": hasPopperEscaped });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/popper.js
var defaultModifiers = [
  eventListeners_default,
  popperOffsets_default,
  computeStyles_default,
  applyStyles_default,
  offset_default,
  flip_default,
  preventOverflow_default,
  arrow_default,
  hide_default
];
var createPopper2 = popperGenerator({ defaultModifiers });

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/useIsomorphicLayout.js
var React5 = __toESM(require_react());
var useIsomorphicLayoutEffect = canUseDOM ? React5.useLayoutEffect : React5.useEffect;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/react-popper/usePopper.js
var isEqual = (a4, b) => JSON.stringify(a4) === JSON.stringify(b);
var fromEntries = (entries) => entries.reduce((acc, [key, value]) => {
  acc[key] = value;
  return acc;
}, {});
var EMPTY_MODIFIERS = [];
var usePopper = (referenceElement, popperElement, options = {}) => {
  const prevOptions = React6.useRef(null);
  const optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };
  const [state, setState] = React6.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      }
    },
    attributes: {}
  });
  const updateStateModifier = React6.useMemo(() => ({
    name: "updateState",
    enabled: true,
    phase: "write",
    // eslint-disable-next-line no-shadow
    fn: ({ state: state2 }) => {
      const elements = Object.keys(state2.elements);
      setState({
        styles: fromEntries(elements.map((element) => [element, state2.styles[element] || {}])),
        attributes: fromEntries(elements.map((element) => [element, state2.attributes[element]]))
      });
    },
    requires: ["computeStyles"]
  }), []);
  const popperOptions = React6.useMemo(() => {
    const newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [...optionsWithDefaults.modifiers, updateStateModifier, { name: "applyStyles", enabled: false }]
    };
    if (isEqual(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [
    optionsWithDefaults.onFirstUpdate,
    optionsWithDefaults.placement,
    optionsWithDefaults.strategy,
    optionsWithDefaults.modifiers,
    updateStateModifier
  ]);
  const popperInstanceRef = React6.useRef();
  useIsomorphicLayoutEffect(() => {
    if (popperInstanceRef && popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(() => {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    const createPopper3 = options.createPopper || createPopper2;
    const popperInstance = createPopper3(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return () => {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/Popper.js
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Popper/Popper.css";
var hash3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom",
  "top-start": "bottom-end",
  "top-end": "bottom-start",
  "bottom-start": "top-end",
  "bottom-end": "top-start",
  "left-start": "right-end",
  "left-end": "right-start",
  "right-start": "left-end",
  "right-end": "left-start"
};
var getOppositePlacement2 = (placement) => placement.replace(/left|right|bottom|top|top-start|top-end|bottom-start|bottom-end|right-start|right-end|left-start|left-end/g, (matched) => hash3[matched]);
var getOpacityTransition = (animationDuration) => `opacity ${animationDuration}ms cubic-bezier(.54, 1.5, .38, 1.11)`;
var Popper = ({ trigger, popper: popper2, direction = "down", position = "start", placement, width, minWidth = "trigger", maxWidth, appendTo = "inline", zIndex = 9999, isVisible = true, positionModifiers, distance = 0, onMouseEnter, onMouseLeave, onFocus, onBlur, onDocumentClick, onTriggerClick, onTriggerEnter, onPopperClick, onPopperMouseEnter, onPopperMouseLeave, onDocumentKeyDown, enableFlip = true, flipBehavior = "flip", triggerRef, popperRef, animationDuration = 0, entryDelay = 0, exitDelay = 0, onHidden = () => {
}, onHide = () => {
}, onMount = () => {
}, onShow = () => {
}, onShown = () => {
}, preventOverflow: preventOverflow3 = false }) => {
  var _a2;
  const [triggerElement, setTriggerElement] = React7.useState(null);
  const [refElement, setRefElement] = React7.useState(null);
  const [popperElement, setPopperElement] = React7.useState(null);
  const [popperContent, setPopperContent] = React7.useState(null);
  const [ready, setReady] = React7.useState(false);
  const [opacity, setOpacity] = React7.useState(0);
  const [internalIsVisible, setInternalIsVisible] = React7.useState(isVisible);
  const transitionTimerRef = React7.useRef(null);
  const showTimerRef = React7.useRef(null);
  const hideTimerRef = React7.useRef(null);
  const prevExitDelayRef = React7.useRef();
  const refOrTrigger = refElement || triggerElement;
  const showPopper = isVisible || internalIsVisible;
  const triggerParent = (_a2 = (triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) || triggerElement) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
  const languageDirection = getLanguageDirection(triggerParent);
  const internalPosition = React7.useMemo(() => {
    const fixedPositions = { left: "left", right: "right", center: "center" };
    const positionMap = {
      ltr: Object.assign({ start: "left", end: "right" }, fixedPositions),
      rtl: Object.assign({ start: "right", end: "left" }, fixedPositions)
    };
    return positionMap[languageDirection][position];
  }, [position, languageDirection]);
  const onDocumentClickCallback = React7.useCallback((event) => onDocumentClick(event, refOrTrigger, popperElement), [showPopper, triggerElement, refElement, popperElement, onDocumentClick]);
  React7.useEffect(() => {
    setReady(true);
    onMount();
  }, []);
  React7.useEffect(() => () => {
    clearTimeouts([transitionTimerRef, hideTimerRef, showTimerRef]);
  }, []);
  React7.useEffect(() => {
    if (triggerRef) {
      if (triggerRef.current) {
        setRefElement(triggerRef.current);
      } else if (typeof triggerRef === "function") {
        setRefElement(triggerRef());
      }
    }
  }, [triggerRef, trigger]);
  React7.useEffect(() => {
    if (popperRef) {
      if (popperRef.current) {
        setPopperElement(popperRef.current);
      } else if (typeof popperRef === "function") {
        setPopperElement(popperRef());
      }
    }
  }, [showPopper, popperRef]);
  React7.useEffect(() => {
    const observer3 = new MutationObserver(() => {
      update2 && update2();
    });
    popperElement && observer3.observe(popperElement, { attributes: true, childList: true, subtree: true });
    return () => {
      observer3.disconnect();
    };
  }, [popperElement]);
  const addEventListener = (listener, element, event, capture = false) => {
    if (listener && element) {
      element.addEventListener(event, listener, { capture });
    }
  };
  const removeEventListener = (listener, element, event, capture = false) => {
    if (listener && element) {
      element.removeEventListener(event, listener, { capture });
    }
  };
  React7.useEffect(() => {
    addEventListener(onMouseEnter, refOrTrigger, "mouseenter");
    addEventListener(onMouseLeave, refOrTrigger, "mouseleave");
    addEventListener(onFocus, refOrTrigger, "focus");
    addEventListener(onBlur, refOrTrigger, "blur");
    addEventListener(onTriggerClick, refOrTrigger, "click");
    addEventListener(onTriggerEnter, refOrTrigger, "keydown");
    addEventListener(onPopperClick, popperElement, "click");
    addEventListener(onPopperMouseEnter, popperElement, "mouseenter");
    addEventListener(onPopperMouseLeave, popperElement, "mouseleave");
    onDocumentClick && addEventListener(onDocumentClickCallback, document, "click", true);
    addEventListener(onDocumentKeyDown, document, "keydown", true);
    return () => {
      removeEventListener(onMouseEnter, refOrTrigger, "mouseenter");
      removeEventListener(onMouseLeave, refOrTrigger, "mouseleave");
      removeEventListener(onFocus, refOrTrigger, "focus");
      removeEventListener(onBlur, refOrTrigger, "blur");
      removeEventListener(onTriggerClick, refOrTrigger, "click");
      removeEventListener(onTriggerEnter, refOrTrigger, "keydown");
      removeEventListener(onPopperClick, popperElement, "click");
      removeEventListener(onPopperMouseEnter, popperElement, "mouseenter");
      removeEventListener(onPopperMouseLeave, popperElement, "mouseleave");
      onDocumentClick && removeEventListener(onDocumentClickCallback, document, "click", true);
      removeEventListener(onDocumentKeyDown, document, "keydown", true);
    };
  }, [
    triggerElement,
    popperElement,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    onTriggerClick,
    onTriggerEnter,
    onPopperClick,
    onPopperMouseEnter,
    onPopperMouseLeave,
    onDocumentClick,
    onDocumentKeyDown,
    refElement
  ]);
  const getPlacement = () => {
    if (placement) {
      return placement;
    }
    let convertedPlacement = direction === "up" ? "top" : "bottom";
    if (internalPosition !== "center") {
      convertedPlacement = `${convertedPlacement}-${internalPosition === "right" ? "end" : "start"}`;
    }
    return convertedPlacement;
  };
  const getPlacementMemo = React7.useMemo(getPlacement, [direction, internalPosition, placement]);
  const getOppositePlacementMemo = React7.useMemo(() => getOppositePlacement2(getPlacement()), [direction, internalPosition, placement]);
  const widthMods = React7.useMemo(() => ({
    name: "widthMods",
    enabled: width !== void 0 || minWidth !== void 0 || maxWidth !== void 0,
    phase: "beforeWrite",
    requires: ["computeStyles"],
    fn: ({ state }) => {
      const triggerWidth = state.rects.reference.width;
      if (width) {
        state.styles.popper.width = width === "trigger" ? `${triggerWidth}px` : width;
      }
      if (minWidth) {
        state.styles.popper.minWidth = minWidth === "trigger" ? `${triggerWidth}px` : minWidth;
      }
      if (maxWidth) {
        state.styles.popper.maxWidth = maxWidth === "trigger" ? `${triggerWidth}px` : maxWidth;
      }
    },
    effect: ({ state }) => {
      const triggerWidth = state.elements.reference.offsetWidth;
      if (width) {
        state.elements.popper.style.width = width === "trigger" ? `${triggerWidth}px` : width;
      }
      if (minWidth) {
        state.elements.popper.style.minWidth = minWidth === "trigger" ? `${triggerWidth}px` : minWidth;
      }
      if (maxWidth) {
        state.elements.popper.style.maxWidth = maxWidth === "trigger" ? `${triggerWidth}px` : maxWidth;
      }
      return () => {
      };
    }
  }), [width, minWidth, maxWidth]);
  const { styles: popperStyles, attributes, update: update2, forceUpdate } = usePopper(refOrTrigger, popperElement, {
    placement: getPlacementMemo,
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, distance]
        }
      },
      {
        name: "preventOverflow",
        enabled: preventOverflow3
      },
      {
        // adds attribute [data-popper-reference-hidden] to the popper element which can be used to hide it using CSS
        name: "hide",
        enabled: true
      },
      {
        name: "flip",
        enabled: getPlacementMemo.startsWith("auto") || enableFlip,
        options: {
          fallbackPlacements: flipBehavior === "flip" ? [getOppositePlacementMemo] : flipBehavior
        }
      },
      widthMods
    ]
  });
  React7.useEffect(() => {
    var _a3, _b, _c, _d, _e, _f, _g;
    const currentPopperContent = ((_d = (_c = (_b = (_a3 = popper2 === null || popper2 === void 0 ? void 0 : popper2.props) === null || _a3 === void 0 ? void 0 : _a3.children) === null || _b === void 0 ? void 0 : _b[1]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.children) || ((_g = (_f = (_e = popper2 === null || popper2 === void 0 ? void 0 : popper2.props) === null || _e === void 0 ? void 0 : _e.children) === null || _f === void 0 ? void 0 : _f.props) === null || _g === void 0 ? void 0 : _g.children);
    setPopperContent(currentPopperContent);
    if (currentPopperContent && popperContent && currentPopperContent !== popperContent) {
      forceUpdate && forceUpdate();
    }
  }, [popper2]);
  React7.useEffect(() => {
    if (prevExitDelayRef.current < exitDelay) {
      clearTimeouts([transitionTimerRef, hideTimerRef]);
      hideTimerRef.current = setTimeout(() => {
        transitionTimerRef.current = setTimeout(() => {
          setInternalIsVisible(false);
        }, animationDuration);
      }, exitDelay);
    }
    prevExitDelayRef.current = exitDelay;
  }, [exitDelay]);
  const show = () => {
    onShow();
    clearTimeouts([transitionTimerRef, hideTimerRef]);
    showTimerRef.current = setTimeout(() => {
      setInternalIsVisible(true);
      setOpacity(1);
      onShown();
    }, entryDelay);
  };
  const hide3 = () => {
    onHide();
    clearTimeouts([showTimerRef]);
    hideTimerRef.current = setTimeout(() => {
      setOpacity(0);
      transitionTimerRef.current = setTimeout(() => {
        setInternalIsVisible(false);
        onHidden();
      }, animationDuration);
    }, exitDelay);
  };
  React7.useEffect(() => {
    if (isVisible) {
      show();
    } else {
      hide3();
    }
  }, [isVisible]);
  const modifierFromPopperPosition = () => {
    if (attributes && attributes.popper && attributes.popper["data-popper-placement"]) {
      const popperPlacement = attributes.popper["data-popper-placement"];
      return positionModifiers[popperPlacement];
    }
    return positionModifiers.top;
  };
  const options = Object.assign({ className: css(popper2.props && popper2.props.className, positionModifiers && modifierFromPopperPosition()), style: Object.assign(Object.assign(Object.assign({}, popper2.props && popper2.props.style || {}), popperStyles.popper), {
    zIndex,
    opacity,
    transition: getOpacityTransition(animationDuration)
  }) }, attributes.popper);
  const getMenuWithPopper = () => {
    const localPopper = React7.cloneElement(popper2, options);
    return popperRef ? localPopper : React7.createElement("div", { style: { display: "contents" }, ref: (node) => setPopperElement(node === null || node === void 0 ? void 0 : node.firstElementChild) }, localPopper);
  };
  const getPopper = () => {
    if (appendTo === "inline") {
      return getMenuWithPopper();
    } else {
      const target = typeof appendTo === "function" ? appendTo() : appendTo;
      return ReactDOM2.createPortal(getMenuWithPopper(), target);
    }
  };
  return React7.createElement(
    React7.Fragment,
    null,
    !triggerRef && trigger && React7.isValidElement(trigger) && React7.createElement("div", { style: { display: "contents" }, ref: (node) => setTriggerElement(node === null || node === void 0 ? void 0 : node.firstElementChild) }, trigger),
    triggerRef && trigger && React7.isValidElement(trigger) && trigger,
    ready && showPopper && getPopper()
  );
};
Popper.displayName = "Popper";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/KeyboardHandler.js
var React8 = __toESM(require_react());
var handleArrows = (event, navigableElements, isActiveElement = (element) => document.activeElement.contains(element), getFocusableElement = (element) => element, validSiblingTags = ["A", "BUTTON", "INPUT"], noVerticalArrowHandling = false, noHorizontalArrowHandling = false, updateTabIndex = true, onlyTraverseSiblings = true) => {
  const activeElement = document.activeElement;
  const key = event.key;
  let moveTarget = null;
  if (!noVerticalArrowHandling) {
    if (["ArrowUp", "ArrowDown"].includes(key)) {
      event.preventDefault();
      event.stopImmediatePropagation();
      let currentIndex = -1;
      navigableElements.forEach((element, index4) => {
        if (isActiveElement(element)) {
          let increment = 0;
          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {
            key === "ArrowUp" ? increment-- : increment++;
            currentIndex = index4 + increment;
            if (currentIndex >= navigableElements.length) {
              currentIndex = 0;
            }
            if (currentIndex < 0) {
              currentIndex = navigableElements.length - 1;
            }
            moveTarget = getFocusableElement(navigableElements[currentIndex]);
          }
        }
      });
    }
  }
  if (!noHorizontalArrowHandling) {
    if (["ArrowLeft", "ArrowRight"].includes(key)) {
      event.preventDefault();
      event.stopImmediatePropagation();
      let currentIndex = -1;
      navigableElements.forEach((element, index4) => {
        if (isActiveElement(element)) {
          const activeRow = navigableElements[index4].querySelectorAll(validSiblingTags.join(","));
          if (!activeRow.length || onlyTraverseSiblings) {
            let nextSibling = activeElement;
            while (nextSibling) {
              const isDirectChildOfNavigableElement = nextSibling.parentElement === element;
              const nextSiblingMainElement = isDirectChildOfNavigableElement ? nextSibling : nextSibling.parentElement;
              nextSibling = key === "ArrowLeft" ? nextSiblingMainElement.previousElementSibling : nextSiblingMainElement.nextElementSibling;
              if (nextSibling) {
                if (validSiblingTags.includes(nextSibling.tagName)) {
                  moveTarget = nextSibling;
                  break;
                }
                if (validSiblingTags.includes(nextSibling.children[0].tagName)) {
                  moveTarget = nextSibling.children[0];
                  break;
                }
              }
            }
          } else {
            activeRow.forEach((focusableElement, index5) => {
              if (event.target === focusableElement) {
                const increment = key === "ArrowLeft" ? -1 : 1;
                currentIndex = index5 + increment;
                if (currentIndex >= activeRow.length) {
                  currentIndex = 0;
                }
                if (currentIndex < 0) {
                  currentIndex = activeRow.length - 1;
                }
                moveTarget = activeRow[currentIndex];
              }
            });
          }
        }
      });
    }
  }
  if (moveTarget) {
    if (updateTabIndex) {
      activeElement.tabIndex = -1;
      moveTarget.tabIndex = 0;
    }
    moveTarget.focus();
  }
};
var KeyboardHandler = class extends React8.Component {
  constructor() {
    super(...arguments);
    this.keyHandler = (event) => {
      const { isEventFromContainer } = this.props;
      if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {
        return;
      }
      const { isActiveElement, getFocusableElement, noVerticalArrowHandling, noHorizontalArrowHandling, noEnterHandling, noSpaceHandling, updateTabIndex, validSiblingTags, additionalKeyHandler, createNavigableElements, onlyTraverseSiblings } = this.props;
      additionalKeyHandler && additionalKeyHandler(event);
      const navigableElements = createNavigableElements();
      if (!navigableElements) {
        console.warn("No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.");
        return;
      }
      const key = event.key;
      if (!noEnterHandling) {
        if (key === "Enter") {
          event.preventDefault();
          event.stopImmediatePropagation();
          document.activeElement.click();
        }
      }
      if (!noSpaceHandling) {
        if (key === " ") {
          event.preventDefault();
          event.stopImmediatePropagation();
          document.activeElement.click();
        }
      }
      handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);
    };
    this._isEventFromContainer = (event) => {
      const { containerRef } = this.props;
      return containerRef.current && containerRef.current.contains(event.target);
    };
  }
  componentDidMount() {
    if (canUseDOM) {
      window.addEventListener("keydown", this.keyHandler);
    }
  }
  componentWillUnmount() {
    if (canUseDOM) {
      window.removeEventListener("keydown", this.keyHandler);
    }
  }
  render() {
    return null;
  }
};
KeyboardHandler.displayName = "KeyboardHandler";
KeyboardHandler.defaultProps = {
  containerRef: null,
  createNavigableElements: () => null,
  isActiveElement: (navigableElement) => document.activeElement === navigableElement,
  getFocusableElement: (navigableElement) => navigableElement,
  validSiblingTags: ["BUTTON", "A"],
  onlyTraverseSiblings: true,
  updateTabIndex: true,
  noHorizontalArrowHandling: false,
  noVerticalArrowHandling: false,
  noEnterHandling: false,
  noSpaceHandling: false
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/resizeObserver.js
var getResizeObserver = (containerRefElement, handleResize, useRequestAnimationFrame) => {
  let unobserve;
  if (canUseDOM) {
    const { ResizeObserver: ResizeObserver2 } = window;
    if (containerRefElement && ResizeObserver2) {
      const resizeObserver = new ResizeObserver2((entries) => {
        if (useRequestAnimationFrame) {
          window.requestAnimationFrame(() => {
            if (Array.isArray(entries) && entries.length > 0) {
              handleResize();
            }
          });
        } else {
          if (Array.isArray(entries) && entries.length > 0) {
            handleResize();
          }
        }
      });
      resizeObserver.observe(containerRefElement);
      unobserve = () => resizeObserver.unobserve(containerRefElement);
    } else {
      window.addEventListener("resize", handleResize);
      unobserve = () => window.removeEventListener("resize", handleResize);
    }
  }
  return () => {
    if (unobserve) {
      unobserve();
    }
  };
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/useInterval.js
var React9 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/datetimeUtils.js
var isValidDate = (date2) => Boolean(date2 && !isNaN(date2));

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Title/Title.js
var TitleSizes;
(function(TitleSizes2) {
  TitleSizes2["md"] = "md";
  TitleSizes2["lg"] = "lg";
  TitleSizes2["xl"] = "xl";
  TitleSizes2["2xl"] = "2xl";
  TitleSizes2["3xl"] = "3xl";
  TitleSizes2["4xl"] = "4xl";
})(TitleSizes || (TitleSizes = {}));
var Title = (_a2) => {
  var { className = "", children: children2 = "", headingLevel: HeadingLevel, size, ouiaId, ouiaSafe = true } = _a2, props = __rest(_a2, ["className", "children", "headingLevel", "size", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps(Title.displayName, ouiaId, ouiaSafe);
  return React10.createElement(HeadingLevel, Object.assign({}, ouiaProps, props, { className: css(title_default.title, size ? title_default.modifiers[size] : title_default.modifiers[HeadingLevel], className) }), children2);
};
Title.displayName = "Title";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModalBoxHeader.js
var AboutModalBoxHeader = (_a2) => {
  var { productName, id: id2 } = _a2, props = __rest(_a2, ["productName", "id"]);
  return React11.createElement(
    "div",
    Object.assign({ className: css(about_modal_box_default.aboutModalBoxHeader) }, props),
    React11.createElement(Title, { headingLevel: "h1", size: "4xl", id: id2 }, productName)
  );
};
AboutModalBoxHeader.displayName = "AboutModalBoxHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModalBoxBrand.js
var React12 = __toESM(require_react());
var AboutModalBoxBrand = (_a2) => {
  var { src, alt } = _a2, props = __rest(_a2, ["src", "alt"]);
  return React12.createElement(
    "div",
    Object.assign({ className: css(about_modal_box_default.aboutModalBoxBrand) }, props),
    React12.createElement("img", { className: css(about_modal_box_default.aboutModalBoxBrandImage), src, alt })
  );
};
AboutModalBoxBrand.displayName = "AboutModalBoxBrand";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModalBoxCloseButton.js
var React16 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Button/Button.js
var React15 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Button/button.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Button/button.css";
var button_default = {
  "badge": "pf-v6-c-badge",
  "button": "pf-v6-c-button",
  "buttonCount": "pf-v6-c-button__count",
  "buttonIcon": "pf-v6-c-button__icon",
  "buttonProgress": "pf-v6-c-button__progress",
  "modifiers": {
    "primary": "pf-m-primary",
    "unread": "pf-m-unread",
    "secondary": "pf-m-secondary",
    "danger": "pf-m-danger",
    "tertiary": "pf-m-tertiary",
    "link": "pf-m-link",
    "inline": "pf-m-inline",
    "displayLg": "pf-m-display-lg",
    "warning": "pf-m-warning",
    "control": "pf-m-control",
    "stateful": "pf-m-stateful",
    "read": "pf-m-read",
    "attention": "pf-m-attention",
    "plain": "pf-m-plain",
    "noPadding": "pf-m-no-padding",
    "block": "pf-m-block",
    "small": "pf-m-small",
    "clicked": "pf-m-clicked",
    "disabled": "pf-m-disabled",
    "ariaDisabled": "pf-m-aria-disabled",
    "progress": "pf-m-progress",
    "inProgress": "pf-m-in-progress",
    "start": "pf-m-start",
    "end": "pf-m-end"
  },
  "spinner": "pf-v6-c-spinner"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Spinner/Spinner.js
var React13 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Spinner/spinner.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Spinner/spinner.css";
var spinner_default = {
  "modifiers": {
    "inline": "pf-m-inline",
    "sm": "pf-m-sm",
    "md": "pf-m-md",
    "lg": "pf-m-lg",
    "xl": "pf-m-xl"
  },
  "spinner": "pf-v6-c-spinner",
  "spinnerPath": "pf-v6-c-spinner__path"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Spinner/Spinner.js
var spinnerSize;
(function(spinnerSize2) {
  spinnerSize2["sm"] = "sm";
  spinnerSize2["md"] = "md";
  spinnerSize2["lg"] = "lg";
  spinnerSize2["xl"] = "xl";
})(spinnerSize || (spinnerSize = {}));
var Spinner = (_a2) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className = "",
    size = "xl",
    "aria-valuetext": ariaValueText = "Loading...",
    diameter,
    isInline = false,
    "aria-label": ariaLabel,
    "aria-labelledBy": ariaLabelledBy
  } = _a2, props = __rest(_a2, ["className", "size", "aria-valuetext", "diameter", "isInline", "aria-label", "aria-labelledBy"]);
  return React13.createElement(
    "svg",
    Object.assign({ className: css(spinner_default.spinner, isInline ? spinner_default.modifiers.inline : spinner_default.modifiers[size], className), role: "progressbar", "aria-valuetext": ariaValueText, viewBox: "0 0 100 100" }, diameter && { style: { [c_spinner_diameter_default.name]: diameter } }, ariaLabel && { "aria-label": ariaLabel }, ariaLabelledBy && { "aria-labelledBy": ariaLabelledBy }, !ariaLabel && !ariaLabelledBy && { "aria-label": "Contents" }, props),
    React13.createElement("circle", { className: spinner_default.spinnerPath, cx: "50", cy: "50", r: "45", fill: "none" })
  );
};
Spinner.displayName = "Spinner";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Badge/Badge.js
var React14 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Badge/badge.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Badge/badge.css";
var badge_default = {
  "badge": "pf-v6-c-badge",
  "badgeToggleIcon": "pf-v6-c-badge__toggle-icon",
  "modifiers": {
    "read": "pf-m-read",
    "unread": "pf-m-unread",
    "disabled": "pf-m-disabled"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Badge/Badge.js
var Badge = (_a2) => {
  var { isRead = false, isDisabled = false, className = "", children: children2 = "", screenReaderText } = _a2, props = __rest(_a2, ["isRead", "isDisabled", "className", "children", "screenReaderText"]);
  return React14.createElement(
    "span",
    Object.assign({}, props, { className: css(badge_default.badge, isRead ? badge_default.modifiers.read : badge_default.modifiers.unread, isDisabled && badge_default.modifiers.disabled, className) }),
    children2,
    screenReaderText && React14.createElement("span", { className: "pf-v6-screen-reader" }, screenReaderText)
  );
};
Badge.displayName = "Badge";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Button/Button.js
var ButtonVariant;
(function(ButtonVariant2) {
  ButtonVariant2["primary"] = "primary";
  ButtonVariant2["secondary"] = "secondary";
  ButtonVariant2["tertiary"] = "tertiary";
  ButtonVariant2["danger"] = "danger";
  ButtonVariant2["warning"] = "warning";
  ButtonVariant2["link"] = "link";
  ButtonVariant2["plain"] = "plain";
  ButtonVariant2["control"] = "control";
  ButtonVariant2["stateful"] = "stateful";
})(ButtonVariant || (ButtonVariant = {}));
var ButtonType;
(function(ButtonType2) {
  ButtonType2["button"] = "button";
  ButtonType2["submit"] = "submit";
  ButtonType2["reset"] = "reset";
})(ButtonType || (ButtonType = {}));
var ButtonSize;
(function(ButtonSize2) {
  ButtonSize2["default"] = "default";
  ButtonSize2["sm"] = "sm";
  ButtonSize2["lg"] = "lg";
})(ButtonSize || (ButtonSize = {}));
var ButtonState;
(function(ButtonState2) {
  ButtonState2["read"] = "read";
  ButtonState2["unread"] = "unread";
  ButtonState2["attention"] = "attention";
})(ButtonState || (ButtonState = {}));
var ButtonBase = (_a2) => {
  var { children: children2 = null, className = "", component = "button", isClicked = false, isBlock = false, isDisabled = false, isAriaDisabled = false, isLoading = null, isDanger = false, spinnerAriaValueText, spinnerAriaLabelledBy, spinnerAriaLabel, size = ButtonSize.default, inoperableEvents = ["onClick", "onKeyPress"], isInline = false, type: type2 = ButtonType.button, variant = ButtonVariant.primary, state = ButtonState.unread, hasNoPadding = false, iconPosition = "start", "aria-label": ariaLabel = null, icon = null, role, ouiaId, ouiaSafe = true, tabIndex = null, innerRef, countOptions } = _a2, props = __rest(_a2, ["children", "className", "component", "isClicked", "isBlock", "isDisabled", "isAriaDisabled", "isLoading", "isDanger", "spinnerAriaValueText", "spinnerAriaLabelledBy", "spinnerAriaLabel", "size", "inoperableEvents", "isInline", "type", "variant", "state", "hasNoPadding", "iconPosition", "aria-label", "icon", "role", "ouiaId", "ouiaSafe", "tabIndex", "innerRef", "countOptions"]);
  const ouiaProps = useOUIAProps(Button.displayName, ouiaId, ouiaSafe, variant);
  const Component50 = component;
  const isButtonElement = Component50 === "button";
  const isInlineSpan = isInline && Component50 === "span";
  const preventedEvents = inoperableEvents.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), { [eventToPrevent]: (event) => {
    event.preventDefault();
  } }), {});
  const getDefaultTabIdx = () => {
    if (isDisabled) {
      return isButtonElement ? null : -1;
    } else if (isAriaDisabled) {
      return null;
    } else if (isInlineSpan) {
      return 0;
    }
  };
  return React15.createElement(
    Component50,
    Object.assign({}, props, isAriaDisabled ? preventedEvents : null, { "aria-disabled": isAriaDisabled || !isButtonElement && isDisabled, "aria-label": ariaLabel, className: css(button_default.button, button_default.modifiers[variant], isBlock && button_default.modifiers.block, isDisabled && !isButtonElement && button_default.modifiers.disabled, isAriaDisabled && button_default.modifiers.ariaDisabled, isClicked && button_default.modifiers.clicked, isInline && variant === ButtonVariant.link && button_default.modifiers.inline, isDanger && (variant === ButtonVariant.secondary || variant === ButtonVariant.link) && button_default.modifiers.danger, isLoading !== null && variant !== ButtonVariant.plain && button_default.modifiers.progress, isLoading && button_default.modifiers.inProgress, hasNoPadding && variant === ButtonVariant.plain && button_default.modifiers.noPadding, variant === ButtonVariant.stateful && button_default.modifiers[state], size === ButtonSize.sm && button_default.modifiers.small, size === ButtonSize.lg && button_default.modifiers.displayLg, className), disabled: isButtonElement ? isDisabled : null, tabIndex: tabIndex !== null ? tabIndex : getDefaultTabIdx(), type: isButtonElement || isInlineSpan ? type2 : null, role: isInlineSpan ? "button" : role, ref: innerRef }, ouiaProps),
    isLoading && React15.createElement(
      "span",
      { className: css(button_default.buttonProgress) },
      React15.createElement(Spinner, { size: spinnerSize.md, isInline, "aria-valuetext": spinnerAriaValueText, "aria-label": spinnerAriaLabel, "aria-labelledby": spinnerAriaLabelledBy })
    ),
    variant === ButtonVariant.plain && children2 === null && icon ? icon : null,
    variant !== ButtonVariant.plain && icon && (iconPosition === "start" || iconPosition === "left") && React15.createElement("span", { className: css(button_default.buttonIcon, button_default.modifiers.start) }, icon),
    children2,
    variant !== ButtonVariant.plain && icon && (iconPosition === "end" || iconPosition === "right") && React15.createElement("span", { className: css(button_default.buttonIcon, button_default.modifiers.end) }, icon),
    countOptions && React15.createElement(
      "span",
      { className: css(button_default.buttonCount, countOptions.className) },
      React15.createElement(Badge, { isRead: countOptions.isRead, isDisabled }, countOptions.count)
    )
  );
};
var Button = React15.forwardRef((props, ref) => React15.createElement(ButtonBase, Object.assign({ innerRef: ref }, props)));
Button.displayName = "Button";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/times-icon.js
var TimesIconConfig = {
  name: "TimesIcon",
  height: 512,
  width: 352,
  svgPath: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z",
  yOffset: 0,
  xOffset: 0
};
var TimesIcon = createIcon(TimesIconConfig);
var times_icon_default = TimesIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModalBoxCloseButton.js
var AboutModalBoxCloseButton = (_a2) => {
  var { onClose = (_e) => void 0, "aria-label": ariaLabel = "Close Dialog" } = _a2, props = __rest(_a2, ["onClose", "aria-label"]);
  return React16.createElement(
    "div",
    Object.assign({ className: css(about_modal_box_default.aboutModalBoxClose) }, props),
    React16.createElement(
      Button,
      { variant: "plain", onClick: onClose, "aria-label": ariaLabel },
      React16.createElement(times_icon_default, null)
    )
  );
};
AboutModalBoxCloseButton.displayName = "AboutModalBoxCloseButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModalBox.js
var React17 = __toESM(require_react());
var AboutModalBox = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React17.createElement("div", Object.assign({ className: css(about_modal_box_default.aboutModalBox, className) }, props), children2);
};
AboutModalBox.displayName = "AboutModalBox";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/Modal.js
var React30 = __toESM(require_react());
var ReactDOM3 = __toESM(require_react_dom());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Backdrop/backdrop.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Backdrop/backdrop.css";
var backdrop_default = {
  "backdrop": "pf-v6-c-backdrop",
  "backdropOpen": "pf-v6-c-backdrop__open"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalContent.js
var React29 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ModalBox/modal-box.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ModalBox/modal-box.css";
var modal_box_default = {
  "button": "pf-v6-c-button",
  "modalBox": "pf-v6-c-modal-box",
  "modalBoxBody": "pf-v6-c-modal-box__body",
  "modalBoxClose": "pf-v6-c-modal-box__close",
  "modalBoxDescription": "pf-v6-c-modal-box__description",
  "modalBoxFooter": "pf-v6-c-modal-box__footer",
  "modalBoxHeader": "pf-v6-c-modal-box__header",
  "modalBoxHeaderMain": "pf-v6-c-modal-box__header-main",
  "modalBoxTitle": "pf-v6-c-modal-box__title",
  "modalBoxTitleIcon": "pf-v6-c-modal-box__title-icon",
  "modalBoxTitleText": "pf-v6-c-modal-box__title-text",
  "modifiers": {
    "sm": "pf-m-sm",
    "md": "pf-m-md",
    "lg": "pf-m-lg",
    "alignTop": "pf-m-align-top",
    "danger": "pf-m-danger",
    "warning": "pf-m-warning",
    "success": "pf-m-success",
    "custom": "pf-m-custom",
    "info": "pf-m-info",
    "help": "pf-m-help",
    "icon": "pf-m-icon"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Bullseye/bullseye.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Bullseye/bullseye.css";
var bullseye_default = {
  "bullseye": "pf-v6-l-bullseye"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Backdrop/Backdrop.js
var React18 = __toESM(require_react());
var Backdrop = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React18.createElement("div", Object.assign({}, props, { className: css(backdrop_default.backdrop, className) }), children2);
};
Backdrop.displayName = "Backdrop";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalBoxBody.js
var React19 = __toESM(require_react());
var ModalBoxBody = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React19.createElement("div", Object.assign({}, props, { className: css(modal_box_default.modalBoxBody, className) }), children2);
};
ModalBoxBody.displayName = "ModalBoxBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalBoxCloseButton.js
var React20 = __toESM(require_react());
var ModalBoxCloseButton = (_a2) => {
  var { className, onClose = () => void 0, "aria-label": ariaLabel = "Close", ouiaId } = _a2, props = __rest(_a2, ["className", "onClose", "aria-label", "ouiaId"]);
  return React20.createElement(
    "div",
    { className: css(modal_box_default.modalBoxClose, className) },
    React20.createElement(
      Button,
      Object.assign({ variant: "plain", onClick: (event) => onClose(event), "aria-label": ariaLabel }, ouiaId && { ouiaId: `${ouiaId}-${ModalBoxCloseButton.displayName}` }, props),
      React20.createElement(times_icon_default, null)
    )
  );
};
ModalBoxCloseButton.displayName = "ModalBoxCloseButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalBox.js
var React21 = __toESM(require_react());
var ModalBox = (_a2) => {
  var { children: children2, className = "", variant = "default", position, positionOffset, "aria-labelledby": ariaLabelledby, "aria-label": ariaLabel = "", "aria-describedby": ariaDescribedby, style } = _a2, props = __rest(_a2, ["children", "className", "variant", "position", "positionOffset", "aria-labelledby", "aria-label", "aria-describedby", "style"]);
  if (positionOffset) {
    style = style || {};
    style[c_modal_box_m_align_top_spacer_default.name] = positionOffset;
  }
  return React21.createElement("div", Object.assign({}, props, { role: "dialog", "aria-label": ariaLabel || null, "aria-labelledby": ariaLabelledby || null, "aria-describedby": ariaDescribedby, "aria-modal": "true", className: css(modal_box_default.modalBox, className, position === "top" && modal_box_default.modifiers.alignTop, variant === "large" && modal_box_default.modifiers.lg, variant === "small" && modal_box_default.modifiers.sm, variant === "medium" && modal_box_default.modifiers.md), style }), children2);
};
ModalBox.displayName = "ModalBox";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalBoxFooter.js
var React22 = __toESM(require_react());
var ModalBoxFooter = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React22.createElement("footer", Object.assign({}, props, { className: css(modal_box_default.modalBoxFooter, className) }), children2);
};
ModalBoxFooter.displayName = "ModalBoxFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalBoxDescription.js
var React23 = __toESM(require_react());
var ModalBoxDescription = (_a2) => {
  var { children: children2 = null, className = "", id: id2 = "" } = _a2, props = __rest(_a2, ["children", "className", "id"]);
  return React23.createElement("div", Object.assign({}, props, { id: id2, className: css(modal_box_default.modalBoxDescription, className) }), children2);
};
ModalBoxDescription.displayName = "ModalBoxDescription";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalBoxHeader.js
var React24 = __toESM(require_react());
var ModalBoxHeader = (_a2) => {
  var { children: children2 = null, className = "", help = null } = _a2, props = __rest(_a2, ["children", "className", "help"]);
  return React24.createElement(
    "header",
    Object.assign({ className: css(modal_box_default.modalBoxHeader, help && modal_box_default.modifiers.help, className) }, props),
    help && React24.createElement(
      React24.Fragment,
      null,
      React24.createElement("div", { className: css(modal_box_default.modalBoxHeaderMain) }, children2),
      React24.createElement("div", { className: `${modal_box_default.modalBoxHeader}-help` }, help)
    ),
    !help && children2
  );
};
ModalBoxHeader.displayName = "ModalBoxHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalBoxTitle.js
var React28 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tooltip/Tooltip.js
var React27 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Tooltip/tooltip.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Tooltip/tooltip.css";
var tooltip_default = {
  "modifiers": {
    "top": "pf-m-top",
    "topLeft": "pf-m-top-left",
    "topRight": "pf-m-top-right",
    "bottom": "pf-m-bottom",
    "bottomLeft": "pf-m-bottom-left",
    "bottomRight": "pf-m-bottom-right",
    "left": "pf-m-left",
    "leftTop": "pf-m-left-top",
    "leftBottom": "pf-m-left-bottom",
    "right": "pf-m-right",
    "rightTop": "pf-m-right-top",
    "rightBottom": "pf-m-right-bottom",
    "textAlignLeft": "pf-m-text-align-left"
  },
  "tooltip": "pf-v6-c-tooltip",
  "tooltipArrow": "pf-v6-c-tooltip__arrow",
  "tooltipContent": "pf-v6-c-tooltip__content"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tooltip/TooltipContent.js
var React25 = __toESM(require_react());
var TooltipContent = (_a2) => {
  var { className, children: children2, isLeftAligned } = _a2, props = __rest(_a2, ["className", "children", "isLeftAligned"]);
  return React25.createElement("div", Object.assign({ className: css(tooltip_default.tooltipContent, isLeftAligned && tooltip_default.modifiers.textAlignLeft, className) }, props), children2);
};
TooltipContent.displayName = "TooltipContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tooltip/TooltipArrow.js
var React26 = __toESM(require_react());
var TooltipArrow = (_a2) => {
  var { className } = _a2, props = __rest(_a2, ["className"]);
  return React26.createElement("div", Object.assign({ className: css(tooltip_default.tooltipArrow, className) }, props));
};
TooltipArrow.displayName = "TooltipArrow";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tooltip/Tooltip.js
var TooltipPosition;
(function(TooltipPosition2) {
  TooltipPosition2["auto"] = "auto";
  TooltipPosition2["top"] = "top";
  TooltipPosition2["bottom"] = "bottom";
  TooltipPosition2["left"] = "left";
  TooltipPosition2["right"] = "right";
  TooltipPosition2["topStart"] = "top-start";
  TooltipPosition2["topEnd"] = "top-end";
  TooltipPosition2["bottomStart"] = "bottom-start";
  TooltipPosition2["bottomEnd"] = "bottom-end";
  TooltipPosition2["leftStart"] = "left-start";
  TooltipPosition2["leftEnd"] = "left-end";
  TooltipPosition2["rightStart"] = "right-start";
  TooltipPosition2["rightEnd"] = "right-end";
})(TooltipPosition || (TooltipPosition = {}));
var pfTooltipIdCounter = 1;
var Tooltip = (_a2) => {
  var {
    content: bodyContent,
    position = "top",
    trigger = "mouseenter focus",
    isVisible = false,
    isContentLeftAligned = false,
    enableFlip = true,
    className = "",
    entryDelay = 300,
    exitDelay = 300,
    appendTo = () => document.body,
    zIndex = 9999,
    minWidth,
    maxWidth = c_tooltip_MaxWidth_default.value,
    distance = 15,
    aria = "describedby",
    // For every initial starting position, there are 3 escape positions
    flipBehavior = ["top", "right", "bottom", "left", "top", "right", "bottom"],
    id: id2 = `pf-tooltip-${pfTooltipIdCounter++}`,
    children: children2,
    animationDuration = 300,
    triggerRef,
    "aria-live": ariaLive = triggerRef ? "polite" : "off",
    onTooltipHidden = () => {
    }
  } = _a2, rest = __rest(_a2, ["content", "position", "trigger", "isVisible", "isContentLeftAligned", "enableFlip", "className", "entryDelay", "exitDelay", "appendTo", "zIndex", "minWidth", "maxWidth", "distance", "aria", "flipBehavior", "id", "children", "animationDuration", "triggerRef", "aria-live", "onTooltipHidden"]);
  const hideOnClick = true;
  const triggerOnMouseenter = trigger.includes("mouseenter");
  const triggerOnFocus = trigger.includes("focus");
  const triggerOnClick = trigger.includes("click");
  const triggerManually = trigger === "manual";
  const [visible, setVisible] = React27.useState(false);
  const popperRef = React27.createRef();
  const onDocumentKeyDown = (event) => {
    if (!triggerManually) {
      if (event.key === KeyTypes.Escape && visible) {
        hide3();
      }
    }
  };
  const onTriggerEnter = (event) => {
    if (event.key === KeyTypes.Enter) {
      if (!visible) {
        show();
      } else {
        hide3();
      }
    }
  };
  React27.useEffect(() => {
    if (isVisible) {
      show();
    } else {
      hide3();
    }
  }, [isVisible]);
  const show = () => {
    setVisible(true);
  };
  const hide3 = () => {
    setVisible(false);
  };
  const positionModifiers = {
    top: tooltip_default.modifiers.top,
    bottom: tooltip_default.modifiers.bottom,
    left: tooltip_default.modifiers.left,
    right: tooltip_default.modifiers.right,
    "top-start": tooltip_default.modifiers.topLeft,
    "top-end": tooltip_default.modifiers.topRight,
    "bottom-start": tooltip_default.modifiers.bottomLeft,
    "bottom-end": tooltip_default.modifiers.bottomRight,
    "left-start": tooltip_default.modifiers.leftTop,
    "left-end": tooltip_default.modifiers.leftBottom,
    "right-start": tooltip_default.modifiers.rightTop,
    "right-end": tooltip_default.modifiers.rightBottom
  };
  const hasCustomMaxWidth = maxWidth !== c_tooltip_MaxWidth_default.value;
  const content = React27.createElement(
    "div",
    Object.assign({ "aria-live": ariaLive, className: css(tooltip_default.tooltip, className), role: "tooltip", id: id2, style: {
      maxWidth: hasCustomMaxWidth ? maxWidth : null
    }, ref: popperRef }, rest),
    React27.createElement(TooltipArrow, null),
    React27.createElement(TooltipContent, { isLeftAligned: isContentLeftAligned }, bodyContent)
  );
  const onDocumentClick = (event, triggerElement) => {
    if (hideOnClick === true) {
      if (visible) {
        hide3();
      } else if (event.target === triggerElement) {
        show();
      }
    } else if (hideOnClick === "toggle" && event.target === triggerElement) {
      if (visible) {
        hide3();
      } else {
        show();
      }
    } else if (hideOnClick === false && !visible && event.target === triggerElement) {
      show();
    }
  };
  const addAriaToTrigger = () => {
    if (aria === "describedby" && children2 && children2.props && !children2.props["aria-describedby"]) {
      return React27.cloneElement(children2, { "aria-describedby": id2 });
    } else if (aria === "labelledby" && children2.props && !children2.props["aria-labelledby"]) {
      return React27.cloneElement(children2, { "aria-labelledby": id2 });
    }
    return children2;
  };
  return React27.createElement(Popper, { trigger: aria !== "none" && visible ? addAriaToTrigger() : children2, triggerRef, popper: content, popperRef, minWidth: minWidth !== void 0 ? minWidth : "revert", appendTo, isVisible: visible, positionModifiers, distance, placement: position, onMouseEnter: triggerOnMouseenter && show, onMouseLeave: triggerOnMouseenter && hide3, onPopperMouseEnter: triggerOnMouseenter && show, onPopperMouseLeave: triggerOnMouseenter && hide3, onFocus: triggerOnFocus && show, onBlur: triggerOnFocus && hide3, onDocumentClick: triggerOnClick && onDocumentClick, onDocumentKeyDown: triggerManually ? null : onDocumentKeyDown, onTriggerEnter: triggerManually ? null : onTriggerEnter, enableFlip, zIndex, flipBehavior, animationDuration, entryDelay, exitDelay, onHidden: onTooltipHidden });
};
Tooltip.displayName = "Tooltip";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalBoxTitle.js
var isVariantIcon = (icon) => ["success", "danger", "warning", "info", "custom"].includes(icon);
var ModalBoxTitle = (_a2) => {
  var { className = "", id: id2, title, titleIconVariant, titleLabel = "" } = _a2, props = __rest(_a2, ["className", "id", "title", "titleIconVariant", "titleLabel"]);
  const [hasTooltip, setHasTooltip] = React28.useState(false);
  const h1 = React28.useRef(null);
  const label = titleLabel || (isVariantIcon(titleIconVariant) ? `${capitalize(titleIconVariant)} alert:` : titleLabel);
  const variantIcons4 = {
    success: React28.createElement(check_circle_icon_default, null),
    danger: React28.createElement(exclamation_circle_icon_default, null),
    warning: React28.createElement(exclamation_triangle_icon_default, null),
    info: React28.createElement(info_circle_icon_default, null),
    custom: React28.createElement(bell_icon_default, null)
  };
  const CustomIcon = !isVariantIcon(titleIconVariant) && titleIconVariant;
  useIsomorphicLayoutEffect(() => {
    setHasTooltip(h1.current && h1.current.offsetWidth < h1.current.scrollWidth);
  }, []);
  const content = React28.createElement(
    "h1",
    Object.assign({ id: id2, ref: h1, className: css(modal_box_default.modalBoxTitle, titleIconVariant && modal_box_default.modifiers.icon, className) }, props),
    titleIconVariant && React28.createElement("span", { className: css(modal_box_default.modalBoxTitleIcon) }, isVariantIcon(titleIconVariant) ? variantIcons4[titleIconVariant] : React28.createElement(CustomIcon, null)),
    label && React28.createElement("span", { className: "pf-v6-screen-reader" }, label),
    React28.createElement("span", { className: css(modal_box_default.modalBoxTitleText) }, title)
  );
  return hasTooltip ? React28.createElement(Tooltip, { content: title }, content) : content;
};
ModalBoxTitle.displayName = "ModalBoxTitle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/ModalContent.js
var ModalContent = (_a2) => {
  var { children: children2, className = "", isOpen = false, header = null, help = null, description = null, title = "", titleIconVariant = null, titleLabel = "", "aria-label": ariaLabel = "", "aria-describedby": ariaDescribedby, "aria-labelledby": ariaLabelledby, bodyAriaLabel, bodyAriaRole, showClose = true, footer = null, actions = [], onClose = () => void 0, variant = "default", position, positionOffset, width, maxWidth, boxId, labelId, descriptorId, disableFocusTrap = false, hasNoBodyWrapper = false, ouiaId, ouiaSafe = true, elementToFocus } = _a2, props = __rest(_a2, ["children", "className", "isOpen", "header", "help", "description", "title", "titleIconVariant", "titleLabel", "aria-label", "aria-describedby", "aria-labelledby", "bodyAriaLabel", "bodyAriaRole", "showClose", "footer", "actions", "onClose", "variant", "position", "positionOffset", "width", "maxWidth", "boxId", "labelId", "descriptorId", "disableFocusTrap", "hasNoBodyWrapper", "ouiaId", "ouiaSafe", "elementToFocus"]);
  if (!isOpen) {
    return null;
  }
  const modalBoxHeader = header ? React29.createElement(ModalBoxHeader, { help }, header) : title && React29.createElement(
    ModalBoxHeader,
    { help },
    React29.createElement(ModalBoxTitle, { title, titleIconVariant, titleLabel, id: labelId }),
    description && React29.createElement(ModalBoxDescription, { id: descriptorId }, description)
  );
  const modalBoxFooter = footer ? React29.createElement(ModalBoxFooter, null, footer) : actions.length > 0 && React29.createElement(ModalBoxFooter, null, actions);
  const defaultModalBodyAriaRole = bodyAriaLabel ? "region" : void 0;
  const hasNoDescription = !description && !ariaDescribedby;
  const id2 = hasNoDescription ? descriptorId : void 0;
  const modalBody = hasNoBodyWrapper ? children2 : React29.createElement(ModalBoxBody, Object.assign({ "aria-label": bodyAriaLabel, role: bodyAriaRole || defaultModalBodyAriaRole }, props, { id: id2 }), children2);
  const ariaLabelledbyFormatted = () => {
    if (ariaLabelledby === null) {
      return null;
    }
    const idRefList = [];
    if ((ariaLabel && boxId) !== "") {
      idRefList.push(ariaLabel && boxId);
    }
    if (ariaLabelledby) {
      idRefList.push(ariaLabelledby);
    }
    if (title) {
      idRefList.push(labelId);
    }
    return idRefList.join(" ");
  };
  const modalBox = React29.createElement(
    ModalBox,
    Object.assign({ id: boxId, className: css(className, isVariantIcon(titleIconVariant) && modal_box_default.modifiers[titleIconVariant]), variant, position, positionOffset, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledbyFormatted(), "aria-describedby": ariaDescribedby || (hasNoBodyWrapper ? null : descriptorId) }, getOUIAProps(ModalContent.displayName, ouiaId, ouiaSafe), { style: Object.assign(Object.assign({}, width && { "--pf-v6-c-modal-box--Width": typeof width !== "number" ? width : `${width}px` }), maxWidth && {
      "--pf-v6-c-modal-box--MaxWidth": typeof maxWidth !== "number" ? maxWidth : `${maxWidth}px`
    }) }),
    showClose && React29.createElement(ModalBoxCloseButton, { onClose: (event) => onClose(event), ouiaId }),
    modalBoxHeader,
    modalBody,
    modalBoxFooter
  );
  return React29.createElement(
    Backdrop,
    null,
    React29.createElement(FocusTrap, { active: !disableFocusTrap, focusTrapOptions: {
      clickOutsideDeactivates: true,
      tabbableOptions: { displayCheck: "none" },
      // FocusTrap's initialFocus can accept false as a value to prevent initial focus.
      // We want to prevent this in case false is ever passed in.
      initialFocus: elementToFocus || void 0
    }, className: css(bullseye_default.bullseye) }, modalBox)
  );
};
ModalContent.displayName = "ModalContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/deprecated/components/Modal/Modal.js
var ModalVariant;
(function(ModalVariant3) {
  ModalVariant3["small"] = "small";
  ModalVariant3["medium"] = "medium";
  ModalVariant3["large"] = "large";
  ModalVariant3["default"] = "default";
})(ModalVariant || (ModalVariant = {}));
var Modal = class _Modal extends React30.Component {
  constructor(props) {
    super(props);
    this.boxId = "";
    this.labelId = "";
    this.descriptorId = "";
    this.handleEscKeyClick = (event) => {
      var _a2, _b;
      const { onEscapePress } = this.props;
      if (event.key === KeyTypes.Escape && this.props.isOpen) {
        onEscapePress ? onEscapePress(event) : (_b = (_a2 = this.props).onClose) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      }
    };
    this.getElement = (appendTo) => {
      if (typeof appendTo === "function") {
        return appendTo();
      }
      return appendTo || document.body;
    };
    this.toggleSiblingsFromScreenReaders = (hide3) => {
      const { appendTo } = this.props;
      const target = this.getElement(appendTo);
      const bodyChildren = target.children;
      for (const child of Array.from(bodyChildren)) {
        if (child !== this.state.container) {
          hide3 ? child.setAttribute("aria-hidden", "" + hide3) : child.removeAttribute("aria-hidden");
        }
      }
    };
    this.isEmpty = (value) => value === null || value === void 0 || value === "";
    const boxIdNum = _Modal.currentId++;
    const labelIdNum = boxIdNum + 1;
    const descriptorIdNum = boxIdNum + 2;
    this.boxId = props.id || `pf-modal-part-${boxIdNum}`;
    this.labelId = `pf-modal-part-${labelIdNum}`;
    this.descriptorId = `pf-modal-part-${descriptorIdNum}`;
    this.state = {
      container: void 0,
      ouiaStateId: getDefaultOUIAId(_Modal.displayName, props.variant)
    };
  }
  componentDidMount() {
    const { appendTo, title, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, hasNoBodyWrapper, header } = this.props;
    const target = this.getElement(appendTo);
    const container = document.createElement("div");
    this.setState({ container });
    target.appendChild(container);
    target.addEventListener("keydown", this.handleEscKeyClick, false);
    if (this.props.isOpen) {
      target.classList.add(css(backdrop_default.backdropOpen));
    } else {
      target.classList.remove(css(backdrop_default.backdropOpen));
    }
    if (this.isEmpty(title) && this.isEmpty(ariaLabel) && this.isEmpty(ariaLabelledby)) {
      console.error("Modal: Specify at least one of: title, aria-label, aria-labelledby.");
    }
    if (this.isEmpty(ariaLabel) && this.isEmpty(ariaLabelledby) && (hasNoBodyWrapper || header)) {
      console.error("Modal: When using hasNoBodyWrapper or setting a custom header, ensure you assign an accessible name to the the modal container with aria-label or aria-labelledby.");
    }
  }
  componentDidUpdate() {
    const { appendTo } = this.props;
    const target = this.getElement(appendTo);
    if (this.props.isOpen) {
      target.classList.add(css(backdrop_default.backdropOpen));
      this.toggleSiblingsFromScreenReaders(true);
    } else {
      target.classList.remove(css(backdrop_default.backdropOpen));
      this.toggleSiblingsFromScreenReaders(false);
    }
  }
  componentWillUnmount() {
    const { appendTo } = this.props;
    const target = this.getElement(appendTo);
    if (this.state.container) {
      target.removeChild(this.state.container);
    }
    target.removeEventListener("keydown", this.handleEscKeyClick, false);
    target.classList.remove(css(backdrop_default.backdropOpen));
    this.toggleSiblingsFromScreenReaders(false);
  }
  render() {
    const _a2 = this.props, {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      appendTo,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onEscapePress,
      "aria-labelledby": ariaLabelledby,
      "aria-label": ariaLabel,
      "aria-describedby": ariaDescribedby,
      bodyAriaLabel,
      bodyAriaRole,
      title,
      titleIconVariant,
      titleLabel,
      ouiaId,
      ouiaSafe,
      position,
      elementToFocus
    } = _a2, props = __rest(_a2, ["appendTo", "onEscapePress", "aria-labelledby", "aria-label", "aria-describedby", "bodyAriaLabel", "bodyAriaRole", "title", "titleIconVariant", "titleLabel", "ouiaId", "ouiaSafe", "position", "elementToFocus"]);
    const { container } = this.state;
    if (!canUseDOM || !container) {
      return null;
    }
    return ReactDOM3.createPortal(React30.createElement(ModalContent, Object.assign({}, props, { boxId: this.boxId, labelId: this.labelId, descriptorId: this.descriptorId, title, titleIconVariant, titleLabel, "aria-label": ariaLabel, "aria-describedby": ariaDescribedby, "aria-labelledby": ariaLabelledby, bodyAriaLabel, bodyAriaRole, ouiaId: ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe, position, elementToFocus })), container);
  }
};
Modal.displayName = "Modal";
Modal.currentId = 0;
Modal.defaultProps = {
  className: "",
  isOpen: false,
  title: "",
  titleIconVariant: null,
  titleLabel: "",
  "aria-label": "",
  showClose: true,
  "aria-describedby": "",
  "aria-labelledby": "",
  id: void 0,
  actions: [],
  onClose: () => void 0,
  variant: "default",
  hasNoBodyWrapper: false,
  appendTo: () => document.body,
  ouiaSafe: true,
  position: "default"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/AboutModal/AboutModal.js
var AboutModal = (_a2) => {
  var { children: children2, className, isOpen = false, onClose = (_e) => void 0, productName, trademark, backgroundImageSrc, brandImageSrc, brandImageAlt, hasNoContentContainer = false, appendTo, closeButtonAriaLabel, "aria-label": ariaLabel, disableFocusTrap } = _a2, props = __rest(_a2, ["children", "className", "isOpen", "onClose", "productName", "trademark", "backgroundImageSrc", "brandImageSrc", "brandImageAlt", "hasNoContentContainer", "appendTo", "closeButtonAriaLabel", "aria-label", "disableFocusTrap"]);
  if (brandImageSrc && !brandImageAlt) {
    console.error("AboutModal:", "brandImageAlt is required when a brandImageSrc is specified, and should not be an empty string.");
  }
  if (!productName && !ariaLabel) {
    console.error("AboutModal:", "Either productName or ariaLabel is required for component to be accessible");
  }
  if (!isOpen) {
    return null;
  }
  return React31.createElement(GenerateId, { prefix: "pf-about-modal-title-" }, (ariaLabelledBy) => React31.createElement(
    Modal,
    Object.assign({ isOpen, variant: ModalVariant.large }, productName && { "aria-labelledby": ariaLabelledBy }, { "aria-label": ariaLabel, onEscapePress: onClose, showClose: false, appendTo, disableFocusTrap, hasNoBodyWrapper: true }),
    React31.createElement(
      AboutModalBox,
      { style: backgroundImageSrc ? { [c_about_modal_box_BackgroundImage_default.name]: `url(${backgroundImageSrc})` } : {}, className: css(className) },
      React31.createElement(AboutModalBoxBrand, { src: brandImageSrc, alt: brandImageAlt }),
      React31.createElement(AboutModalBoxCloseButton, { "aria-label": closeButtonAriaLabel, onClose }),
      productName && React31.createElement(AboutModalBoxHeader, { id: ariaLabelledBy, productName }),
      React31.createElement(AboutModalBoxContent, Object.assign({ trademark, hasNoContentContainer }, props), children2)
    )
  ));
};
AboutModal.displayName = "AboutModal";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Accordion/Accordion.js
var React33 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Accordion/accordion.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Accordion/accordion.css";
var accordion_default = {
  "accordion": "pf-v6-c-accordion",
  "accordionExpandableContent": "pf-v6-c-accordion__expandable-content",
  "accordionExpandableContentBody": "pf-v6-c-accordion__expandable-content-body",
  "accordionItem": "pf-v6-c-accordion__item",
  "accordionToggle": "pf-v6-c-accordion__toggle",
  "accordionToggleIcon": "pf-v6-c-accordion__toggle-icon",
  "accordionToggleText": "pf-v6-c-accordion__toggle-text",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "toggleStart": "pf-m-toggle-start",
    "displayLg": "pf-m-display-lg",
    "bordered": "pf-m-bordered",
    "expanded": "pf-m-expanded",
    "fixed": "pf-m-fixed"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Accordion/AccordionContext.js
var React32 = __toESM(require_react());
var AccordionContext = React32.createContext({});
var AccordionItemContext = React32.createContext({});

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Accordion/Accordion.js
var Accordion = (_a2) => {
  var { children: children2 = null, className = "", "aria-label": ariaLabel, headingLevel = "h3", asDefinitionList = true, isBordered = false, displaySize = "default", togglePosition = "end" } = _a2, props = __rest(_a2, ["children", "className", "aria-label", "headingLevel", "asDefinitionList", "isBordered", "displaySize", "togglePosition"]);
  const AccordionList = asDefinitionList ? "dl" : "div";
  return React33.createElement(
    AccordionList,
    Object.assign({ className: css(accordion_default.accordion, isBordered && accordion_default.modifiers.bordered, togglePosition === "start" && accordion_default.modifiers.toggleStart, displaySize === "lg" && accordion_default.modifiers.displayLg, className), "aria-label": ariaLabel }, !asDefinitionList && ariaLabel && { role: "region" }, props),
    React33.createElement(AccordionContext.Provider, { value: {
      ContentContainer: asDefinitionList ? "dd" : "div",
      ToggleContainer: asDefinitionList ? "dt" : headingLevel,
      togglePosition
    } }, children2)
  );
};
Accordion.displayName = "Accordion";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Accordion/AccordionContent.js
var React35 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Accordion/AccordionExpandableContentBody.js
var React34 = __toESM(require_react());
var AccordionExpandableContentBody = ({ children: children2 = null }) => React34.createElement("div", { className: css(accordion_default.accordionExpandableContentBody) }, children2);
AccordionExpandableContentBody.displayName = "AccordionExpandableContentBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Accordion/AccordionContent.js
var AccordionContent = (_a2) => {
  var { className = "", children: children2 = null, id: id2 = "", isFixed: isFixed2 = false, isCustomContent = false, "aria-label": ariaLabel = "", "aria-labelledby": ariaLabelledby, component } = _a2, props = __rest(_a2, ["className", "children", "id", "isFixed", "isCustomContent", "aria-label", "aria-labelledby", "component"]);
  const [hasScrollbar, setHasScrollbar] = React35.useState(false);
  const containerRef = React35.useRef(null);
  const { isExpanded } = React35.useContext(AccordionItemContext);
  React35.useEffect(() => {
    if ((containerRef === null || containerRef === void 0 ? void 0 : containerRef.current) && isFixed2 && isExpanded) {
      const { offsetHeight, scrollHeight } = containerRef.current;
      setHasScrollbar(offsetHeight < scrollHeight);
    } else if (!isFixed2) {
      setHasScrollbar(false);
    }
  }, [containerRef, isFixed2, isExpanded]);
  return React35.createElement(AccordionContext.Consumer, null, ({ ContentContainer }) => {
    const Container = component || ContentContainer;
    return React35.createElement(Container, Object.assign({ ref: containerRef, id: id2, className: css(accordion_default.accordionExpandableContent, isFixed2 && accordion_default.modifiers.fixed, className), hidden: !isExpanded }, ariaLabel && { "aria-label": ariaLabel }, ariaLabelledby && { "aria-labelledby": ariaLabelledby }, hasScrollbar && { tabIndex: 0 }, hasScrollbar && Container === "div" && { role: "region" }, props), isCustomContent ? children2 : React35.createElement(AccordionExpandableContentBody, null, children2));
  });
};
AccordionContent.displayName = "AccordionContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Accordion/AccordionItem.js
var React36 = __toESM(require_react());
var AccordionItem = ({ children: children2 = null, className, isExpanded: isExpandedProp = false }) => React36.createElement(
  AccordionItemContext.Provider,
  { value: {
    isExpanded: isExpandedProp
  } },
  React36.createElement("div", { className: css(accordion_default.accordionItem, isExpandedProp && accordion_default.modifiers.expanded, className) }, children2)
);
AccordionItem.displayName = "AccordionItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Accordion/AccordionToggle.js
var React37 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/angle-right-icon.js
var AngleRightIconConfig = {
  name: "AngleRightIcon",
  height: 512,
  width: 256,
  svgPath: "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z",
  yOffset: 0,
  xOffset: 0
};
var AngleRightIcon = createIcon(AngleRightIconConfig);
var angle_right_icon_default = AngleRightIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Accordion/AccordionToggle.js
var AccordionToggle = (_a2) => {
  var { className = "", id: id2, children: children2 = null, component } = _a2, props = __rest(_a2, ["className", "id", "children", "component"]);
  const renderToggleIcon = () => React37.createElement(
    "span",
    { className: css(accordion_default.accordionToggleIcon) },
    React37.createElement(angle_right_icon_default, null)
  );
  const { isExpanded } = React37.useContext(AccordionItemContext);
  return React37.createElement(AccordionContext.Consumer, null, ({ ToggleContainer, togglePosition }) => {
    const Container = component || ToggleContainer;
    const isToggleStartPositioned = togglePosition === "start";
    return React37.createElement(
      Container,
      null,
      React37.createElement(
        "button",
        Object.assign({ id: id2, className: css(accordion_default.accordionToggle, isExpanded && accordion_default.modifiers.expanded, className), "aria-expanded": isExpanded, type: "button" }, props),
        isToggleStartPositioned && renderToggleIcon(),
        React37.createElement("span", { className: css(accordion_default.accordionToggleText) }, children2),
        !isToggleStartPositioned && renderToggleIcon()
      )
    );
  });
};
AccordionToggle.displayName = "AccordionToggle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ActionList/ActionList.js
var React38 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ActionList/action-list.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ActionList/action-list.css";
var action_list_default = {
  "actionList": "pf-v6-c-action-list",
  "actionListGroup": "pf-v6-c-action-list__group",
  "modifiers": {
    "icons": "pf-m-icons"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ActionList/ActionList.js
var ActionList = (_a2) => {
  var { children: children2, isIconList, className } = _a2, props = __rest(_a2, ["children", "isIconList", "className"]);
  return React38.createElement("div", Object.assign({ className: css(action_list_default.actionList, isIconList && action_list_default.modifiers.icons, className) }, props), children2);
};
ActionList.displayName = "ActionList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ActionList/ActionListGroup.js
var React39 = __toESM(require_react());
var ActionListGroup = (_a2) => {
  var { children: children2, className, isIconGroup } = _a2, props = __rest(_a2, ["children", "className", "isIconGroup"]);
  return React39.createElement("div", Object.assign({ className: css(action_list_default.actionListGroup, isIconGroup && action_list_default.modifiers.icons, className) }, props), children2);
};
ActionListGroup.displayName = "ActionListGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ActionList/ActionListItem.js
var React40 = __toESM(require_react());
var ActionListItem = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React40.createElement("div", Object.assign({ className: css(`${action_list_default.actionList}__item`, className) }, props), children2);
};
ActionListItem.displayName = "ActionListItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/Alert.js
var React44 = __toESM(require_react());
var import_react4 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Alert/alert.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Alert/alert.css";
var alert_default = {
  "alert": "pf-v6-c-alert",
  "alertAction": "pf-v6-c-alert__action",
  "alertActionGroup": "pf-v6-c-alert__action-group",
  "alertDescription": "pf-v6-c-alert__description",
  "alertIcon": "pf-v6-c-alert__icon",
  "alertTitle": "pf-v6-c-alert__title",
  "alertToggle": "pf-v6-c-alert__toggle",
  "alertToggleIcon": "pf-v6-c-alert__toggle-icon",
  "button": "pf-v6-c-button",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "custom": "pf-m-custom",
    "success": "pf-m-success",
    "danger": "pf-m-danger",
    "warning": "pf-m-warning",
    "info": "pf-m-info",
    "inline": "pf-m-inline",
    "plain": "pf-m-plain",
    "expandable": "pf-m-expandable",
    "expanded": "pf-m-expanded",
    "truncate": "pf-m-truncate"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/AlertIcon.js
var React41 = __toESM(require_react());
var variantIcons = {
  success: check_circle_icon_default,
  danger: exclamation_circle_icon_default,
  warning: exclamation_triangle_icon_default,
  info: info_circle_icon_default,
  custom: bell_icon_default
};
var AlertIcon = (_a2) => {
  var { variant, customIcon, className = "" } = _a2, props = __rest(_a2, ["variant", "customIcon", "className"]);
  const Icon2 = variantIcons[variant];
  return Icon2 ? React41.createElement("div", Object.assign({}, props, { className: css(alert_default.alertIcon, className) }), customIcon || React41.createElement(Icon2, null)) : null;
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/AlertContext.js
var React42 = __toESM(require_react());
var AlertContext = React42.createContext(null);

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/AlertToggleExpandButton.js
var React43 = __toESM(require_react());
var AlertToggleExpandButton = (_a2) => {
  var { "aria-label": ariaLabel = "", variantLabel, onToggleExpand, isExpanded = false } = _a2, props = __rest(_a2, ["aria-label", "variantLabel", "onToggleExpand", "isExpanded"]);
  const { title, variantLabel: alertVariantLabel } = React43.useContext(AlertContext);
  return React43.createElement(
    Button,
    Object.assign({ variant: ButtonVariant.plain, onClick: onToggleExpand, "aria-expanded": isExpanded, "aria-label": ariaLabel === "" ? `Toggle ${variantLabel || alertVariantLabel} alert: ${title}` : ariaLabel }, props),
    React43.createElement(
      "span",
      { className: css(alert_default.alertToggleIcon) },
      React43.createElement(angle_right_icon_default, { "aria-hidden": "true" })
    )
  );
};
AlertToggleExpandButton.displayName = "AlertToggleExpandButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/Alert.js
var AlertVariant;
(function(AlertVariant2) {
  AlertVariant2["success"] = "success";
  AlertVariant2["danger"] = "danger";
  AlertVariant2["warning"] = "warning";
  AlertVariant2["info"] = "info";
  AlertVariant2["custom"] = "custom";
})(AlertVariant || (AlertVariant = {}));
var Alert = (_a2) => {
  var { variant = AlertVariant.custom, isInline = false, isPlain = false, isLiveRegion = false, variantLabel = `${capitalize(variant)} alert:`, actionClose, actionLinks, title, component = "h4", children: children2 = "", className = "", ouiaId, ouiaSafe = true, timeout: timeout2 = false, timeoutAnimation = 3e3, onTimeout = () => {
  }, truncateTitle = 0, tooltipPosition, customIcon, isExpandable = false, toggleAriaLabel = `${capitalize(variant)} alert details`, onMouseEnter = () => {
  }, onMouseLeave = () => {
  }, id: id2 } = _a2, props = __rest(_a2, ["variant", "isInline", "isPlain", "isLiveRegion", "variantLabel", "actionClose", "actionLinks", "title", "component", "children", "className", "ouiaId", "ouiaSafe", "timeout", "timeoutAnimation", "onTimeout", "truncateTitle", "tooltipPosition", "customIcon", "isExpandable", "toggleAriaLabel", "onMouseEnter", "onMouseLeave", "id"]);
  const ouiaProps = useOUIAProps(Alert.displayName, ouiaId, ouiaSafe, variant);
  const getHeadingContent = React44.createElement(
    React44.Fragment,
    null,
    React44.createElement("span", { className: "pf-v6-screen-reader" }, variantLabel),
    title
  );
  const titleRef = React44.useRef(null);
  const TitleComponent = component;
  const divRef = React44.useRef();
  const [isTooltipVisible, setIsTooltipVisible] = (0, import_react4.useState)(false);
  React44.useEffect(() => {
    if (!titleRef.current || !truncateTitle) {
      return;
    }
    titleRef.current.style.setProperty(c_alert_title_max_lines_default.name, truncateTitle.toString());
    const showTooltip = titleRef.current && titleRef.current.offsetHeight < titleRef.current.scrollHeight;
    if (isTooltipVisible !== showTooltip) {
      setIsTooltipVisible(showTooltip);
    }
  }, [titleRef, truncateTitle, isTooltipVisible]);
  const [timedOut, setTimedOut] = (0, import_react4.useState)(false);
  const [timedOutAnimation, setTimedOutAnimation] = (0, import_react4.useState)(true);
  const [isMouseOver, setIsMouseOver] = (0, import_react4.useState)();
  const [containsFocus, setContainsFocus] = (0, import_react4.useState)();
  const dismissed = timedOut && timedOutAnimation && !isMouseOver && !containsFocus;
  React44.useEffect(() => {
    const calculatedTimeout = timeout2 === true ? 8e3 : Number(timeout2);
    if (calculatedTimeout > 0) {
      const timer2 = setTimeout(() => setTimedOut(true), calculatedTimeout);
      return () => clearTimeout(timer2);
    }
  }, [timeout2]);
  React44.useEffect(() => {
    const onDocumentFocus = () => {
      if (divRef.current) {
        if (divRef.current.contains(document.activeElement)) {
          setContainsFocus(true);
          setTimedOutAnimation(false);
        } else if (containsFocus) {
          setContainsFocus(false);
        }
      }
    };
    document.addEventListener("focus", onDocumentFocus, true);
    return () => document.removeEventListener("focus", onDocumentFocus, true);
  }, [containsFocus]);
  React44.useEffect(() => {
    if (containsFocus === false || isMouseOver === false) {
      const timer2 = setTimeout(() => setTimedOutAnimation(true), timeoutAnimation);
      return () => clearTimeout(timer2);
    }
  }, [containsFocus, isMouseOver, timeoutAnimation]);
  React44.useEffect(() => {
    dismissed && onTimeout();
  }, [dismissed, onTimeout]);
  const [isExpanded, setIsExpanded] = (0, import_react4.useState)(false);
  const onToggleExpand = () => {
    setIsExpanded(!isExpanded);
  };
  const myOnMouseEnter = (ev) => {
    setIsMouseOver(true);
    setTimedOutAnimation(false);
    onMouseEnter(ev);
  };
  const myOnMouseLeave = (ev) => {
    setIsMouseOver(false);
    onMouseLeave(ev);
  };
  if (dismissed) {
    return null;
  }
  const Title2 = React44.createElement(TitleComponent, Object.assign({}, isTooltipVisible && { tabIndex: 0 }, { ref: titleRef, className: css(alert_default.alertTitle, truncateTitle && alert_default.modifiers.truncate) }), getHeadingContent);
  return React44.createElement(
    "div",
    Object.assign({ ref: divRef, className: css(alert_default.alert, isInline && alert_default.modifiers.inline, isPlain && alert_default.modifiers.plain, isExpandable && alert_default.modifiers.expandable, isExpanded && alert_default.modifiers.expanded, alert_default.modifiers[variant], className) }, ouiaProps, isLiveRegion && {
      "aria-live": "polite",
      "aria-atomic": "false"
    }, { onMouseEnter: myOnMouseEnter, onMouseLeave: myOnMouseLeave, id: id2 }, props),
    isExpandable && React44.createElement(
      AlertContext.Provider,
      { value: { title, variantLabel } },
      React44.createElement(
        "div",
        { className: css(alert_default.alertToggle) },
        React44.createElement(AlertToggleExpandButton, { isExpanded, onToggleExpand, "aria-label": toggleAriaLabel })
      )
    ),
    React44.createElement(AlertIcon, { variant, customIcon }),
    isTooltipVisible ? React44.createElement(Tooltip, { content: getHeadingContent, position: tooltipPosition }, Title2) : Title2,
    actionClose && React44.createElement(
      AlertContext.Provider,
      { value: { title, variantLabel } },
      React44.createElement("div", { className: css(alert_default.alertAction) }, actionClose)
    ),
    children2 && (!isExpandable || isExpandable && isExpanded) && React44.createElement("div", { className: css(alert_default.alertDescription) }, children2),
    actionLinks && React44.createElement("div", { className: css(alert_default.alertActionGroup) }, actionLinks)
  );
};
Alert.displayName = "Alert";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/AlertActionCloseButton.js
var React45 = __toESM(require_react());
var AlertActionCloseButton = (_a2) => {
  var { className, onClose = () => void 0, "aria-label": ariaLabel = "", variantLabel } = _a2, props = __rest(_a2, ["className", "onClose", "aria-label", "variantLabel"]);
  return React45.createElement(AlertContext.Consumer, null, ({ title, variantLabel: alertVariantLabel }) => React45.createElement(
    Button,
    Object.assign({ variant: ButtonVariant.plain, onClick: onClose, "aria-label": ariaLabel === "" ? `Close ${variantLabel || alertVariantLabel} alert: ${title}` : ariaLabel, className }, props),
    React45.createElement(times_icon_default, null)
  ));
};
AlertActionCloseButton.displayName = "AlertActionCloseButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/AlertActionLink.js
var React46 = __toESM(require_react());
var AlertActionLink = (_a2) => {
  var { className = "", children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React46.createElement(Button, Object.assign({ variant: ButtonVariant.link, isInline: true, className }, props), children2);
};
AlertActionLink.displayName = "AlertActionLink";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/AlertGroup.js
var React48 = __toESM(require_react());
var ReactDOM4 = __toESM(require_react_dom());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/AlertGroupInline.js
var React47 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Alert/alert-group.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Alert/alert-group.css";
var alert_group_default = {
  "alert": "pf-v6-c-alert",
  "alertGroup": "pf-v6-c-alert-group",
  "alertGroupItem": "pf-v6-c-alert-group__item",
  "alertGroupOverflowButton": "pf-v6-c-alert-group__overflow-button",
  "modifiers": {
    "toast": "pf-m-toast",
    "offstageTop": "pf-m-offstage-top",
    "offstageRight": "pf-m-offstage-right"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/AlertGroupInline.js
var AlertGroupInline = (_a2) => {
  var { className, children: children2, isToast, isLiveRegion, onOverflowClick, overflowMessage } = _a2, rest = __rest(_a2, ["className", "children", "isToast", "isLiveRegion", "onOverflowClick", "overflowMessage"]);
  return React47.createElement(
    "ul",
    Object.assign({ role: "list", "aria-live": isLiveRegion ? "polite" : null, "aria-atomic": isLiveRegion ? false : null, className: css(alert_group_default.alertGroup, className, isToast ? alert_group_default.modifiers.toast : "") }, rest),
    React47.Children.toArray(children2).map((alert, index4) => {
      var _a3;
      return React47.createElement("li", { key: ((_a3 = alert.props) === null || _a3 === void 0 ? void 0 : _a3.id) || index4 }, alert);
    }),
    overflowMessage && React47.createElement(
      "li",
      null,
      React47.createElement("button", { onClick: onOverflowClick, className: css(alert_group_default.alertGroupOverflowButton) }, overflowMessage)
    )
  );
};
AlertGroupInline.displayName = "AlertGroupInline";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Alert/AlertGroup.js
var AlertGroup = class extends React48.Component {
  constructor() {
    super(...arguments);
    this.state = {
      container: void 0
    };
  }
  componentDidMount() {
    const container = document.createElement("div");
    const target = this.getTargetElement();
    this.setState({ container });
    target.appendChild(container);
  }
  componentWillUnmount() {
    const target = this.getTargetElement();
    if (this.state.container) {
      target.removeChild(this.state.container);
    }
  }
  getTargetElement() {
    const appendTo = this.props.appendTo;
    if (typeof appendTo === "function") {
      return appendTo();
    }
    return appendTo || document.body;
  }
  render() {
    const _a2 = this.props, {
      className,
      children: children2,
      isToast,
      isLiveRegion,
      onOverflowClick,
      overflowMessage,
      "aria-label": ariaLabel,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      appendTo
    } = _a2, props = __rest(_a2, ["className", "children", "isToast", "isLiveRegion", "onOverflowClick", "overflowMessage", "aria-label", "appendTo"]);
    const alertGroup = React48.createElement(AlertGroupInline, Object.assign({ onOverflowClick, className, isToast, isLiveRegion, overflowMessage, "aria-label": ariaLabel }, props), children2);
    if (!this.props.isToast) {
      return alertGroup;
    }
    const container = this.state.container;
    if (!canUseDOM || !container) {
      return null;
    }
    return ReactDOM4.createPortal(alertGroup, container);
  }
};
AlertGroup.displayName = "AlertGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Avatar/Avatar.js
var React49 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Avatar/avatar.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Avatar/avatar.css";
var avatar_default = {
  "avatar": "pf-v6-c-avatar",
  "modifiers": {
    "bordered": "pf-m-bordered",
    "sm": "pf-m-sm",
    "md": "pf-m-md",
    "lg": "pf-m-lg",
    "xl": "pf-m-xl"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Avatar/Avatar.js
var Avatar = (_a2) => {
  var { className, src = "", alt, isBordered, size } = _a2, props = __rest(_a2, ["className", "src", "alt", "isBordered", "size"]);
  return React49.createElement("img", Object.assign({ src, alt, className: css(avatar_default.avatar, avatar_default.modifiers[size], isBordered && avatar_default.modifiers.bordered, className) }, props));
};
Avatar.displayName = "Avatar";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/BackToTop/BackToTop.js
var React50 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/BackToTop/back-to-top.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/BackToTop/back-to-top.css";
var back_to_top_default = {
  "backToTop": "pf-v6-c-back-to-top",
  "button": "pf-v6-c-button",
  "modifiers": {
    "hidden": "pf-m-hidden"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/angle-up-icon.js
var AngleUpIconConfig = {
  name: "AngleUpIcon",
  height: 512,
  width: 320,
  svgPath: "M177 159.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 329.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z",
  yOffset: 0,
  xOffset: 0
};
var AngleUpIcon = createIcon(AngleUpIconConfig);
var angle_up_icon_default = AngleUpIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/BackToTop/BackToTop.js
var BackToTopBase = (_a2) => {
  var { className, title = "Back to top", innerRef, scrollableSelector, isAlwaysVisible = false } = _a2, props = __rest(_a2, ["className", "title", "innerRef", "scrollableSelector", "isAlwaysVisible"]);
  const [visible, setVisible] = React50.useState(isAlwaysVisible);
  React50.useEffect(() => {
    setVisible(isAlwaysVisible);
  }, [isAlwaysVisible]);
  const [scrollElement, setScrollElement] = React50.useState(null);
  const toggleVisible = () => {
    if (scrollElement) {
      const scrolled = scrollElement.scrollY ? scrollElement.scrollY : scrollElement.scrollTop;
      if (!isAlwaysVisible) {
        if (scrolled > 400) {
          setVisible(true);
        } else {
          setVisible(false);
        }
      }
    }
  };
  React50.useEffect(() => {
    const hasScrollSpy = Boolean(scrollableSelector);
    if (hasScrollSpy) {
      const scrollEl = document.querySelector(scrollableSelector);
      if (!canUseDOM || !(scrollEl instanceof HTMLElement)) {
        return;
      }
      setScrollElement(scrollEl);
      scrollEl.addEventListener("scroll", toggleVisible);
      return () => {
        scrollEl.removeEventListener("scroll", toggleVisible);
      };
    } else {
      if (!canUseDOM) {
        return;
      }
      const scrollEl = window;
      setScrollElement(scrollEl);
      scrollEl.addEventListener("scroll", toggleVisible);
      return () => {
        scrollEl.removeEventListener("scroll", toggleVisible);
      };
    }
  }, [scrollableSelector, toggleVisible]);
  const handleClick = () => {
    scrollElement.scrollTo({ top: 0, behavior: "smooth" });
  };
  return React50.createElement(
    "div",
    Object.assign({ className: css(back_to_top_default.backToTop, !visible && back_to_top_default.modifiers.hidden, className), ref: innerRef, onClick: handleClick }, props),
    React50.createElement(Button, { variant: "primary", icon: React50.createElement(angle_up_icon_default, { "aria-hidden": "true" }), iconPosition: "end" }, title)
  );
};
var BackToTop = React50.forwardRef((props, ref) => React50.createElement(BackToTopBase, Object.assign({ innerRef: ref }, props)));
BackToTop.displayName = "BackToTop";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/BackgroundImage/BackgroundImage.js
var import_react5 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/BackgroundImage/background-image.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/BackgroundImage/background-image.css";
var background_image_default = {
  "backgroundImage": "pf-v6-c-background-image",
  "dirRtl": "pf-v6-m-dir-rtl"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/BackgroundImage/BackgroundImage.js
var BackgroundImage = (_a2) => {
  var { className, src } = _a2, props = __rest(_a2, ["className", "src"]);
  return import_react5.default.createElement("div", Object.assign({ className: css(background_image_default.backgroundImage, className), style: {
    [c_background_image_BackgroundImage_default.name]: `url(${src})`
  } }, props));
};
BackgroundImage.displayName = "BackgroundImage";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Banner/Banner.js
var React52 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Banner/banner.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Banner/banner.css";
var banner_default = {
  "banner": "pf-v6-c-banner",
  "button": "pf-v6-c-button",
  "modifiers": {
    "danger": "pf-m-danger",
    "success": "pf-m-success",
    "warning": "pf-m-warning",
    "info": "pf-m-info",
    "custom": "pf-m-custom",
    "red": "pf-m-red",
    "orangered": "pf-m-orangered",
    "orange": "pf-m-orange",
    "yellow": "pf-m-yellow",
    "green": "pf-m-green",
    "teal": "pf-m-teal",
    "blue": "pf-m-blue",
    "purple": "pf-m-purple",
    "sticky": "pf-m-sticky",
    "disabled": "pf-m-disabled",
    "inline": "pf-m-inline"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Banner/Banner.js
var Banner = (_a2) => {
  var { children: children2, className, screenReaderText, isSticky = false, color: color2, status } = _a2, props = __rest(_a2, ["children", "className", "screenReaderText", "isSticky", "color", "status"]);
  const getStatusOrColorModifier = () => {
    if (status) {
      return banner_default.modifiers[status];
    }
    if (color2) {
      return banner_default.modifiers[color2];
    }
  };
  return React52.createElement(
    "div",
    Object.assign({ className: css(banner_default.banner, getStatusOrColorModifier(), isSticky && banner_default.modifiers.sticky, className) }, props),
    screenReaderText && React52.createElement("span", { className: "pf-v6-screen-reader" }, screenReaderText),
    children2
  );
};
Banner.displayName = "Banner";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Brand/Brand.js
var React53 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Brand/brand.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Brand/brand.css";
var brand_default = {
  "brand": "pf-v6-c-brand",
  "modifiers": {
    "picture": "pf-m-picture"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Brand/Brand.js
var Brand = (_a2) => {
  var { className = "", src = "", alt, children: children2, widths, heights, style } = _a2, props = __rest(_a2, ["className", "src", "alt", "children", "widths", "heights", "style"]);
  let responsiveStyles;
  if (widths !== void 0) {
    responsiveStyles = Object.assign({}, setBreakpointCssVars(widths, c_brand_Width_default.name));
  }
  if (heights !== void 0) {
    responsiveStyles = Object.assign(Object.assign({}, responsiveStyles), setBreakpointCssVars(heights, c_brand_Height_default.name));
  }
  return (
    /** the brand component currently contains no styling the 'pf-v6-c-brand' string will be used for the className */
    children2 !== void 0 ? React53.createElement(
      "picture",
      Object.assign({ className: css(brand_default.brand, brand_default.modifiers.picture, className), style: Object.assign(Object.assign({}, style), responsiveStyles) }, props),
      children2,
      React53.createElement("img", { src, alt })
    ) : React53.createElement("img", Object.assign({}, props, { className: css(brand_default.brand, className), style: Object.assign(Object.assign({}, style), responsiveStyles), src, alt }))
  );
};
Brand.displayName = "Brand";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Breadcrumb/Breadcrumb.js
var React54 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Breadcrumb/breadcrumb.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Breadcrumb/breadcrumb.css";
var breadcrumb_default = {
  "breadcrumb": "pf-v6-c-breadcrumb",
  "breadcrumbDropdown": "pf-v6-c-breadcrumb__dropdown",
  "breadcrumbHeading": "pf-v6-c-breadcrumb__heading",
  "breadcrumbItem": "pf-v6-c-breadcrumb__item",
  "breadcrumbItemDivider": "pf-v6-c-breadcrumb__item-divider",
  "breadcrumbLink": "pf-v6-c-breadcrumb__link",
  "breadcrumbList": "pf-v6-c-breadcrumb__list",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "current": "pf-m-current"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Breadcrumb/Breadcrumb.js
var Breadcrumb = (_a2) => {
  var { children: children2 = null, className = "", "aria-label": ariaLabel = "Breadcrumb", ouiaId, ouiaSafe = true } = _a2, props = __rest(_a2, ["children", "className", "aria-label", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps(Breadcrumb.displayName, ouiaId, ouiaSafe);
  return React54.createElement(
    "nav",
    Object.assign({}, props, { "aria-label": ariaLabel, className: css(breadcrumb_default.breadcrumb, className) }, ouiaProps),
    React54.createElement("ol", { className: breadcrumb_default.breadcrumbList, role: "list" }, React54.Children.map(children2, (child, index4) => {
      const showDivider = index4 > 0;
      if (React54.isValidElement(child)) {
        return React54.cloneElement(child, { showDivider });
      }
      return child;
    }))
  );
};
Breadcrumb.displayName = "Breadcrumb";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Breadcrumb/BreadcrumbItem.js
var React55 = __toESM(require_react());
var BreadcrumbItem = (_a2) => {
  var { children: children2 = null, className: classNameProp = "", to = void 0, isActive = false, isDropdown = false, showDivider, target = void 0, component = "a", render = void 0 } = _a2, props = __rest(_a2, ["children", "className", "to", "isActive", "isDropdown", "showDivider", "target", "component", "render"]);
  const Component50 = component;
  const ariaCurrent = isActive ? "page" : void 0;
  const className = css(breadcrumb_default.breadcrumbLink, isActive && breadcrumb_default.modifiers.current);
  return React55.createElement(
    "li",
    Object.assign({}, props, { className: css(breadcrumb_default.breadcrumbItem, classNameProp) }),
    showDivider && React55.createElement(
      "span",
      { className: breadcrumb_default.breadcrumbItemDivider },
      React55.createElement(angle_right_icon_default, null)
    ),
    component === "button" && React55.createElement("button", { className, "aria-current": ariaCurrent, type: "button" }, children2),
    isDropdown && React55.createElement("span", { className: css(breadcrumb_default.breadcrumbDropdown) }, children2),
    render && render({ className, ariaCurrent }),
    to && !render && React55.createElement(Component50, { href: to, target, className, "aria-current": ariaCurrent }, children2),
    !to && component !== "button" && !isDropdown && children2
  );
};
BreadcrumbItem.displayName = "BreadcrumbItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Breadcrumb/BreadcrumbHeading.js
var React56 = __toESM(require_react());
var BreadcrumbHeading = (_a2) => {
  var { children: children2 = null, className = "", to = void 0, target = void 0, component = "a", showDivider } = _a2, props = __rest(_a2, ["children", "className", "to", "target", "component", "showDivider"]);
  const Component50 = component;
  return React56.createElement(
    "li",
    Object.assign({}, props, { className: css(breadcrumb_default.breadcrumbItem, className) }),
    showDivider && React56.createElement(
      "span",
      { className: breadcrumb_default.breadcrumbItemDivider },
      React56.createElement(angle_right_icon_default, null)
    ),
    React56.createElement(
      "h1",
      { className: breadcrumb_default.breadcrumbHeading },
      !to && component === "button" && React56.createElement("button", { className: css(breadcrumb_default.breadcrumbLink, breadcrumb_default.modifiers.current), "aria-current": true, type: "button" }, children2),
      to && React56.createElement(Component50, { href: to, target, className: css(breadcrumb_default.breadcrumbLink, breadcrumb_default.modifiers.current), "aria-current": "page" }, children2),
      !to && component !== "button" && React56.createElement(React56.Fragment, null, children2)
    )
  );
};
BreadcrumbHeading.displayName = "BreadcrumbHeading";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/CalendarMonth/CalendarMonth.js
var import_react13 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TextInput/TextInput.js
var React58 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/FormControl/form-control.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/FormControl/form-control.css";
var form_control_default = {
  "formControl": "pf-v6-c-form-control",
  "formControlIcon": "pf-v6-c-form-control__icon",
  "formControlToggleIcon": "pf-v6-c-form-control__toggle-icon",
  "formControlUtilities": "pf-v6-c-form-control__utilities",
  "modifiers": {
    "readonly": "pf-m-readonly",
    "success": "pf-m-success",
    "warning": "pf-m-warning",
    "error": "pf-m-error",
    "plain": "pf-m-plain",
    "expanded": "pf-m-expanded",
    "disabled": "pf-m-disabled",
    "icon": "pf-m-icon",
    "placeholder": "pf-m-placeholder",
    "resizeVertical": "pf-m-resize-vertical",
    "resizeHorizontal": "pf-m-resize-horizontal",
    "resizeBoth": "pf-m-resize-both",
    "status": "pf-m-status"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/FormControl/FormControlIcon.js
var React57 = __toESM(require_react());
var statusIcons2 = {
  success: check_circle_icon_default,
  error: exclamation_circle_icon_default,
  warning: exclamation_triangle_icon_default
};
var FormControlIcon = (_a2) => {
  var { status, customIcon, className } = _a2, props = __rest(_a2, ["status", "customIcon", "className"]);
  const StatusIcon2 = status && statusIcons2[status];
  return React57.createElement("span", Object.assign({ className: css(form_control_default.formControlIcon, status && form_control_default.modifiers.status, className) }, props), customIcon || React57.createElement(StatusIcon2, null));
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TextInput/TextInput.js
var TextInputTypes;
(function(TextInputTypes2) {
  TextInputTypes2["text"] = "text";
  TextInputTypes2["date"] = "date";
  TextInputTypes2["datetimeLocal"] = "datetime-local";
  TextInputTypes2["email"] = "email";
  TextInputTypes2["month"] = "month";
  TextInputTypes2["number"] = "number";
  TextInputTypes2["password"] = "password";
  TextInputTypes2["search"] = "search";
  TextInputTypes2["tel"] = "tel";
  TextInputTypes2["time"] = "time";
  TextInputTypes2["url"] = "url";
})(TextInputTypes || (TextInputTypes = {}));
var TextInputReadOnlyVariant;
(function(TextInputReadOnlyVariant2) {
  TextInputReadOnlyVariant2["default"] = "default";
  TextInputReadOnlyVariant2["plain"] = "plain";
})(TextInputReadOnlyVariant || (TextInputReadOnlyVariant = {}));
var TextInputBase = class _TextInputBase extends React58.Component {
  constructor(props) {
    super(props);
    this.inputRef = React58.createRef();
    this.observer = () => {
    };
    this.handleChange = (event) => {
      if (this.props.onChange) {
        this.props.onChange(event, event.currentTarget.value);
      }
    };
    this.handleResize = () => {
      const inputRef = this.props.innerRef || this.inputRef;
      if (inputRef && inputRef.current) {
        trimLeft(inputRef.current, String(this.props.value));
      }
    };
    this.restoreText = () => {
      const inputRef = this.props.innerRef || this.inputRef;
      inputRef.current.value = String(this.props.value);
      inputRef.current.scrollLeft = inputRef.current.scrollWidth;
    };
    this.onFocus = (event) => {
      const { isLeftTruncated, isStartTruncated, onFocus } = this.props;
      if (isLeftTruncated || isStartTruncated) {
        this.restoreText();
      }
      onFocus && onFocus(event);
    };
    this.onBlur = (event) => {
      const { isLeftTruncated, isStartTruncated, onBlur } = this.props;
      if (isLeftTruncated || isStartTruncated) {
        this.handleResize();
      }
      onBlur && onBlur(event);
    };
    this.sanitizeInputValue = (value) => typeof value === "string" ? value.replace(/\n/g, " ") : value;
    if (!props.id && !props["aria-label"] && !props["aria-labelledby"]) {
      console.error("Text input:", "Text input requires either an id or aria-label to be specified");
    }
    this.state = {
      ouiaStateId: getDefaultOUIAId(_TextInputBase.displayName)
    };
  }
  componentDidMount() {
    if (this.props.isLeftTruncated || this.props.isStartTruncated) {
      const inputRef = this.props.innerRef || this.inputRef;
      this.observer = getResizeObserver(inputRef.current, this.handleResize, true);
      this.handleResize();
    }
  }
  componentWillUnmount() {
    if (this.props.isLeftTruncated || this.props.isStartTruncated) {
      this.observer();
    }
  }
  render() {
    const _a2 = this.props, {
      innerRef,
      className,
      type: type2,
      value,
      placeholder,
      validated,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onChange,
      onFocus,
      onBlur,
      isLeftTruncated,
      isStartTruncated,
      isExpanded,
      expandedProps,
      readOnly,
      readOnlyVariant,
      isRequired,
      isDisabled,
      customIcon,
      ouiaId,
      ouiaSafe
    } = _a2, props = __rest(_a2, ["innerRef", "className", "type", "value", "placeholder", "validated", "onChange", "onFocus", "onBlur", "isLeftTruncated", "isStartTruncated", "isExpanded", "expandedProps", "readOnly", "readOnlyVariant", "isRequired", "isDisabled", "customIcon", "ouiaId", "ouiaSafe"]);
    const hasStatusIcon = ["success", "error", "warning"].includes(validated);
    const ariaExpandedProps = expandedProps ? { "aria-expanded": expandedProps === null || expandedProps === void 0 ? void 0 : expandedProps.isExpanded, "aria-controls": expandedProps === null || expandedProps === void 0 ? void 0 : expandedProps.ariaControls, role: "combobox" } : {};
    return React58.createElement(
      "span",
      { className: css(form_control_default.formControl, readOnlyVariant && form_control_default.modifiers.readonly, readOnlyVariant === "plain" && form_control_default.modifiers.plain, isDisabled && form_control_default.modifiers.disabled, (isExpanded || (expandedProps === null || expandedProps === void 0 ? void 0 : expandedProps.isExpanded)) && form_control_default.modifiers.expanded, customIcon && form_control_default.modifiers.icon, hasStatusIcon && form_control_default.modifiers[validated], className) },
      React58.createElement("input", Object.assign({}, props, { onFocus: this.onFocus, onBlur: this.onBlur, onChange: this.handleChange, type: type2, value: this.sanitizeInputValue(value), "aria-invalid": props["aria-invalid"] ? props["aria-invalid"] : validated === ValidatedOptions.error }, ariaExpandedProps, { required: isRequired, disabled: isDisabled, readOnly: !!readOnlyVariant || readOnly, ref: innerRef || this.inputRef, placeholder }, getOUIAProps(TextInput.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe))),
      (customIcon || hasStatusIcon) && React58.createElement(
        "span",
        { className: css(form_control_default.formControlUtilities) },
        customIcon && React58.createElement(FormControlIcon, { customIcon }),
        hasStatusIcon && React58.createElement(FormControlIcon, { status: validated })
      )
    );
  }
};
TextInputBase.displayName = "TextInputBase";
TextInputBase.defaultProps = {
  "aria-label": null,
  isRequired: false,
  validated: "default",
  isDisabled: false,
  isExpanded: false,
  type: TextInputTypes.text,
  isLeftTruncated: false,
  isStartTruncated: false,
  onChange: () => void 0,
  ouiaSafe: true
};
var TextInput = React58.forwardRef((props, ref) => React58.createElement(TextInputBase, Object.assign({}, props, { innerRef: ref })));
TextInput.displayName = "TextInput";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Select/Select.js
var import_react9 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/Menu.js
var React60 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Menu/menu.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Menu/menu.css";
var menu_default = {
  "button": "pf-v6-c-button",
  "check": "pf-v6-c-check",
  "dirRtl": "pf-v6-m-dir-rtl",
  "divider": "pf-v6-c-divider",
  "menu": "pf-v6-c-menu",
  "menuBreadcrumb": "pf-v6-c-menu__breadcrumb",
  "menuContent": "pf-v6-c-menu__content",
  "menuFooter": "pf-v6-c-menu__footer",
  "menuGroup": "pf-v6-c-menu__group",
  "menuGroupTitle": "pf-v6-c-menu__group-title",
  "menuHeader": "pf-v6-c-menu__header",
  "menuItem": "pf-v6-c-menu__item",
  "menuItemAction": "pf-v6-c-menu__item-action",
  "menuItemActionIcon": "pf-v6-c-menu__item-action-icon",
  "menuItemCheck": "pf-v6-c-menu__item-check",
  "menuItemDescription": "pf-v6-c-menu__item-description",
  "menuItemExternalIcon": "pf-v6-c-menu__item-external-icon",
  "menuItemIcon": "pf-v6-c-menu__item-icon",
  "menuItemMain": "pf-v6-c-menu__item-main",
  "menuItemSelectIcon": "pf-v6-c-menu__item-select-icon",
  "menuItemText": "pf-v6-c-menu__item-text",
  "menuItemToggleIcon": "pf-v6-c-menu__item-toggle-icon",
  "menuList": "pf-v6-c-menu__list",
  "menuListItem": "pf-v6-c-menu__list-item",
  "menuSearch": "pf-v6-c-menu__search",
  "menuToggle": "pf-v6-c-menu-toggle",
  "modifiers": {
    "hidden": "pf-m-hidden",
    "hiddenOnSm": "pf-m-hidden-on-sm",
    "visibleOnSm": "pf-m-visible-on-sm",
    "hiddenOnMd": "pf-m-hidden-on-md",
    "visibleOnMd": "pf-m-visible-on-md",
    "hiddenOnLg": "pf-m-hidden-on-lg",
    "visibleOnLg": "pf-m-visible-on-lg",
    "hiddenOnXl": "pf-m-hidden-on-xl",
    "visibleOnXl": "pf-m-visible-on-xl",
    "hiddenOn_2xl": "pf-m-hidden-on-2xl",
    "visibleOn_2xl": "pf-m-visible-on-2xl",
    "disabled": "pf-m-disabled",
    "ariaDisabled": "pf-m-aria-disabled",
    "flyout": "pf-m-flyout",
    "top": "pf-m-top",
    "left": "pf-m-left",
    "drilldown": "pf-m-drilldown",
    "drilledIn": "pf-m-drilled-in",
    "currentPath": "pf-m-current-path",
    "static": "pf-m-static",
    "plain": "pf-m-plain",
    "scrollable": "pf-m-scrollable",
    "load": "pf-m-load",
    "loading": "pf-m-loading",
    "danger": "pf-m-danger",
    "focus": "pf-m-focus",
    "selected": "pf-m-selected",
    "favorited": "pf-m-favorited"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuContext.js
var React59 = __toESM(require_react());
var MenuContext = React59.createContext({
  menuId: null,
  parentMenu: null,
  onActionClick: () => null,
  onSelect: () => null,
  activeItemId: null,
  selected: null,
  drilledInMenus: [],
  drilldownItemPath: [],
  onDrillIn: null,
  onDrillOut: null,
  onGetMenuHeight: () => null,
  flyoutRef: null,
  setFlyoutRef: () => null,
  disableHover: false,
  role: "menu"
});
var MenuItemContext = React59.createContext({
  itemId: null,
  isDisabled: false
});

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/Menu.js
var MenuBase = class extends React60.Component {
  constructor(props) {
    super(props);
    this.menuRef = React60.createRef();
    this.activeMenu = null;
    this.state = {
      ouiaStateId: getDefaultOUIAId(Menu.displayName),
      transitionMoveTarget: null,
      flyoutRef: null,
      disableHover: false,
      currentDrilldownMenuId: this.props.id
    };
    this.handleDrilldownTransition = (event) => {
      const current = this.menuRef.current;
      if (!current || current !== event.target.closest(`.${menu_default.menu}`) && !Array.from(current.getElementsByClassName(menu_default.menu)).includes(event.target.closest(`.${menu_default.menu}`))) {
        return;
      }
      if (this.state.transitionMoveTarget) {
        this.state.transitionMoveTarget.focus();
        this.setState({ transitionMoveTarget: null });
      } else {
        const nextMenu = current.querySelector("#" + this.props.activeMenu) || current || null;
        const nextMenuLists = nextMenu.getElementsByTagName("UL");
        if (nextMenuLists.length === 0) {
          return;
        }
        const nextMenuChildren = Array.from(nextMenuLists[0].children);
        if (!this.state.currentDrilldownMenuId || nextMenu.id !== this.state.currentDrilldownMenuId) {
          this.setState({ currentDrilldownMenuId: nextMenu.id });
        } else {
          return;
        }
        const nextTarget = nextMenuChildren.filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider)))[0].firstChild;
        nextTarget.focus();
        nextTarget.tabIndex = 0;
      }
    };
    this.handleExtraKeys = (event) => {
      const isDrilldown = this.props.containsDrilldown;
      const activeElement = document.activeElement;
      if (event.target.closest(`.${menu_default.menu}`) !== this.activeMenu && !event.target.classList.contains(breadcrumb_default.breadcrumbLink)) {
        this.activeMenu = event.target.closest(`.${menu_default.menu}`);
        this.setState({ disableHover: true });
      }
      if (event.target.tagName === "INPUT") {
        return;
      }
      const parentMenu = this.activeMenu;
      const key = event.key;
      const isFromBreadcrumb = activeElement.classList.contains(breadcrumb_default.breadcrumbLink);
      if (key === " " || key === "Enter") {
        event.preventDefault();
        if (isDrilldown && !isFromBreadcrumb) {
          const isDrillingOut = activeElement.closest("li").classList.contains("pf-m-current-path");
          if (isDrillingOut && parentMenu.parentElement.tagName === "LI") {
            activeElement.tabIndex = -1;
            parentMenu.parentElement.firstChild.tabIndex = 0;
            this.setState({ transitionMoveTarget: parentMenu.parentElement.firstChild });
          } else {
            if (activeElement.nextElementSibling && activeElement.nextElementSibling.classList.contains(menu_default.menu)) {
              const childItems = Array.from(activeElement.nextElementSibling.getElementsByTagName("UL")[0].children).filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider)));
              activeElement.tabIndex = -1;
              childItems[0].firstChild.tabIndex = 0;
              this.setState({ transitionMoveTarget: childItems[0].firstChild });
            }
          }
        }
        document.activeElement.click();
      }
    };
    this.createNavigableElements = () => {
      const isDrilldown = this.props.containsDrilldown;
      if (isDrilldown) {
        return this.activeMenu ? Array.from(this.activeMenu.getElementsByTagName("UL")[0].children).filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider))) : [];
      } else {
        return this.menuRef.current ? Array.from(this.menuRef.current.getElementsByTagName("LI")).filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider))) : [];
      }
    };
    if (props.innerRef) {
      this.menuRef = props.innerRef;
    }
  }
  allowTabFirstItem() {
    const current = this.menuRef.current;
    if (current) {
      const first = current.querySelector("ul button:not(:disabled), ul a:not(:disabled)");
      if (first) {
        first.tabIndex = 0;
      }
    }
  }
  componentDidMount() {
    if (this.context) {
      this.setState({ disableHover: this.context.disableHover });
    }
    if (canUseDOM) {
      window.addEventListener("transitionend", this.props.isRootMenu ? this.handleDrilldownTransition : null);
    }
    this.allowTabFirstItem();
  }
  componentWillUnmount() {
    if (canUseDOM) {
      window.removeEventListener("transitionend", this.handleDrilldownTransition);
    }
  }
  componentDidUpdate(prevProps) {
    if (prevProps.children !== this.props.children) {
      this.allowTabFirstItem();
    }
  }
  render() {
    const _a2 = this.props, {
      id: id2,
      children: children2,
      className,
      onSelect,
      selected = null,
      onActionClick,
      ouiaId,
      ouiaSafe,
      containsFlyout,
      containsDrilldown,
      isMenuDrilledIn,
      isPlain,
      isScrollable,
      drilldownItemPath,
      drilledInMenus,
      onDrillIn,
      onDrillOut,
      onGetMenuHeight,
      parentMenu = null,
      activeItemId = null,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      innerRef,
      isRootMenu,
      activeMenu,
      role,
      isNavFlyout
    } = _a2, props = __rest(_a2, ["id", "children", "className", "onSelect", "selected", "onActionClick", "ouiaId", "ouiaSafe", "containsFlyout", "containsDrilldown", "isMenuDrilledIn", "isPlain", "isScrollable", "drilldownItemPath", "drilledInMenus", "onDrillIn", "onDrillOut", "onGetMenuHeight", "parentMenu", "activeItemId", "innerRef", "isRootMenu", "activeMenu", "role", "isNavFlyout"]);
    const _isMenuDrilledIn = isMenuDrilledIn || drilledInMenus && drilledInMenus.includes(id2) || false;
    return React60.createElement(
      MenuContext.Provider,
      { value: {
        menuId: id2,
        parentMenu: parentMenu || id2,
        onSelect,
        onActionClick,
        activeItemId,
        selected,
        drilledInMenus,
        drilldownItemPath,
        onDrillIn,
        onDrillOut,
        onGetMenuHeight,
        flyoutRef: this.state.flyoutRef,
        setFlyoutRef: (flyoutRef) => this.setState({ flyoutRef }),
        disableHover: this.state.disableHover,
        role
      } },
      isRootMenu && React60.createElement(KeyboardHandler, { containerRef: this.menuRef || null, additionalKeyHandler: this.handleExtraKeys, createNavigableElements: this.createNavigableElements, isActiveElement: (element) => document.activeElement.closest("li") === element || // if element is a basic MenuItem
      document.activeElement.parentElement === element || document.activeElement.closest(`.${menu_default.menuSearch}`) === element || // if element is a MenuSearch
      document.activeElement.closest("ol") && document.activeElement.closest("ol").firstChild === element, getFocusableElement: (navigableElement) => {
        var _a3, _b;
        return (navigableElement === null || navigableElement === void 0 ? void 0 : navigableElement.tagName) === "DIV" && navigableElement.querySelector("input") || // for MenuSearchInput
        ((_a3 = navigableElement.firstChild) === null || _a3 === void 0 ? void 0 : _a3.tagName) === "LABEL" && navigableElement.querySelector("input") || // for MenuItem checkboxes
        ((_b = navigableElement.firstChild) === null || _b === void 0 ? void 0 : _b.tagName) === "DIV" && navigableElement.querySelector("a, button, input") || // For aria-disabled element that is rendered inside a div with "display: contents" styling
        navigableElement.firstChild;
      }, noHorizontalArrowHandling: document.activeElement && (document.activeElement.classList.contains(breadcrumb_default.breadcrumbLink) || document.activeElement.tagName === "INPUT"), noEnterHandling: true, noSpaceHandling: true }),
      React60.createElement("div", Object.assign({ id: id2, className: css(menu_default.menu, isPlain && menu_default.modifiers.plain, isScrollable && menu_default.modifiers.scrollable, containsFlyout && menu_default.modifiers.flyout, isNavFlyout && "pf-m-nav", containsDrilldown && menu_default.modifiers.drilldown, _isMenuDrilledIn && menu_default.modifiers.drilledIn, className), ref: this.menuRef }, getOUIAProps(Menu.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), props), children2)
    );
  }
};
MenuBase.displayName = "Menu";
MenuBase.contextType = MenuContext;
MenuBase.defaultProps = {
  ouiaSafe: true,
  isRootMenu: true,
  isPlain: false,
  isScrollable: false,
  role: "menu"
};
var Menu = React60.forwardRef((props, ref) => React60.createElement(MenuBase, Object.assign({}, props, { innerRef: ref })));
Menu.displayName = "Menu";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuContent.js
var React61 = __toESM(require_react());
var MenuContent = React61.forwardRef((props, ref) => {
  const { getHeight, children: children2, menuHeight, maxMenuHeight } = props, rest = __rest(props, ["getHeight", "children", "menuHeight", "maxMenuHeight"]);
  const menuContentRef = React61.createRef();
  const refCallback = (el, menuId, onGetMenuHeight) => {
    if (el) {
      let clientHeight = el.clientHeight;
      let rootMenuList = null;
      let parentEl = el.closest(`.${menu_default.menuList}`);
      while (parentEl !== null && parentEl.nodeType === 1) {
        if (parentEl.classList.contains(menu_default.menuList)) {
          rootMenuList = parentEl;
        }
        parentEl = parentEl.parentElement;
      }
      if (rootMenuList) {
        const rootMenuListStyles = getComputedStyle(rootMenuList);
        const rootMenuListPaddingOffset = parseFloat(rootMenuListStyles.getPropertyValue("padding-top").replace(/px/g, "")) + parseFloat(rootMenuListStyles.getPropertyValue("padding-bottom").replace(/px/g, "")) + parseFloat(getComputedStyle(rootMenuList.parentElement).getPropertyValue("border-bottom-width").replace(/px/g, ""));
        clientHeight = clientHeight + rootMenuListPaddingOffset;
      }
      onGetMenuHeight && onGetMenuHeight(menuId, clientHeight);
      getHeight && getHeight(clientHeight.toString());
    }
    return ref || menuContentRef;
  };
  return React61.createElement(MenuContext.Consumer, null, ({ menuId, onGetMenuHeight }) => React61.createElement("div", Object.assign({}, rest, { className: css(menu_default.menuContent, props.className), ref: (el) => refCallback(el, menuId, onGetMenuHeight), style: Object.assign(Object.assign({}, menuHeight && { [c_menu_content_Height_default.name]: menuHeight }), maxMenuHeight && { [c_menu_content_MaxHeight_default.name]: maxMenuHeight }) }), children2));
});
MenuContent.displayName = "MenuContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuFooter.js
var React62 = __toESM(require_react());
var MenuFooter = (_a2) => {
  var { children: children2, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React62.createElement("div", Object.assign({}, props, { className: css(menu_default.menuFooter, className) }), children2);
};
MenuFooter.displayName = "MenuFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuSearch.js
var React63 = __toESM(require_react());
var MenuSearch = React63.forwardRef((props, ref) => React63.createElement("div", Object.assign({}, props, { className: css(menu_default.menuSearch, props.className), ref })));
MenuSearch.displayName = "MenuSearch";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuSearchInput.js
var React64 = __toESM(require_react());
var MenuSearchInput = React64.forwardRef((props, ref) => (
  // Update to use the styles object when core adds the class
  React64.createElement("div", Object.assign({}, props, { className: css(`${menu_default.menuSearch}-input`, props.className), ref }))
));
MenuSearchInput.displayName = "MenuSearchInput";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuGroup.js
var React65 = __toESM(require_react());
var MenuGroupBase = (_a2) => {
  var { children: children2, className = "", label = "", titleId, innerRef, labelHeadingLevel: HeadingLevel = "h1" } = _a2, props = __rest(_a2, ["children", "className", "label", "titleId", "innerRef", "labelHeadingLevel"]);
  const Wrapper = typeof label === "function" ? label : HeadingLevel;
  return React65.createElement(
    "section",
    Object.assign({}, props, { className: css(menu_default.menuGroup, className), ref: innerRef }),
    React65.createElement(
      React65.Fragment,
      null,
      ["function", "string"].includes(typeof label) ? React65.createElement(Wrapper, { className: css(menu_default.menuGroupTitle), id: titleId }, label) : label,
      children2
    )
  );
};
var MenuGroup = React65.forwardRef((props, ref) => React65.createElement(MenuGroupBase, Object.assign({}, props, { innerRef: ref })));
MenuGroup.displayName = "MenuGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuItem.js
var React68 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/external-link-alt-icon.js
var ExternalLinkAltIconConfig = {
  name: "ExternalLinkAltIcon",
  height: 512,
  width: 512,
  svgPath: "M432,320H400a16,16,0,0,0-16,16V448H64V128H208a16,16,0,0,0,16-16V80a16,16,0,0,0-16-16H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V336A16,16,0,0,0,432,320ZM488,0h-128c-21.37,0-32.05,25.91-17,41l35.73,35.73L135,320.37a24,24,0,0,0,0,34L157.67,377a24,24,0,0,0,34,0L435.28,133.32,471,169c15,15,41,4.5,41-17V24A24,24,0,0,0,488,0Z",
  yOffset: 0,
  xOffset: 0
};
var ExternalLinkAltIcon = createIcon(ExternalLinkAltIconConfig);
var external_link_alt_icon_default = ExternalLinkAltIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/angle-left-icon.js
var AngleLeftIconConfig = {
  name: "AngleLeftIcon",
  height: 512,
  width: 256,
  svgPath: "M31.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L127.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L201.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34z",
  yOffset: 0,
  xOffset: 0
};
var AngleLeftIcon = createIcon(AngleLeftIconConfig);
var angle_left_icon_default = AngleLeftIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/check-icon.js
var CheckIconConfig = {
  name: "CheckIcon",
  height: 512,
  width: 512,
  svgPath: "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z",
  yOffset: 0,
  xOffset: 0
};
var CheckIcon = createIcon(CheckIconConfig);
var check_icon_default = CheckIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Checkbox/Checkbox.js
var React66 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Check/check.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Check/check.css";
var check_default = {
  "check": "pf-v6-c-check",
  "checkBody": "pf-v6-c-check__body",
  "checkDescription": "pf-v6-c-check__description",
  "checkInput": "pf-v6-c-check__input",
  "checkLabel": "pf-v6-c-check__label",
  "checkLabelRequired": "pf-v6-c-check__label-required",
  "modifiers": {
    "standalone": "pf-m-standalone",
    "disabled": "pf-m-disabled"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Checkbox/Checkbox.js
var defaultOnChange = () => {
};
var Checkbox = class _Checkbox extends React66.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event, event.currentTarget.checked);
    };
    this.state = {
      ouiaStateId: getDefaultOUIAId(_Checkbox.displayName)
    };
  }
  render() {
    const _a2 = this.props, { "aria-label": ariaLabel, className, inputClassName, onChange, isLabelWrapped, labelPosition = "end", isValid, isDisabled, isRequired, isChecked, label, checked, defaultChecked, description, body, ouiaId, ouiaSafe, component } = _a2, props = __rest(_a2, ["aria-label", "className", "inputClassName", "onChange", "isLabelWrapped", "labelPosition", "isValid", "isDisabled", "isRequired", "isChecked", "label", "checked", "defaultChecked", "description", "body", "ouiaId", "ouiaSafe", "component"]);
    if (!props.id) {
      console.error("Checkbox:", "id is required to make input accessible");
    }
    const checkedProps = {};
    if ([true, false].includes(checked) || isChecked === true) {
      checkedProps.checked = checked || isChecked;
    }
    if (onChange !== defaultOnChange) {
      checkedProps.checked = isChecked;
    }
    if ([false, true].includes(defaultChecked)) {
      checkedProps.defaultChecked = defaultChecked;
    }
    const inputRendered = React66.createElement("input", Object.assign({}, props, { className: css(check_default.checkInput, inputClassName), type: "checkbox", onChange: this.handleChange, "aria-invalid": !isValid, "aria-label": ariaLabel, disabled: isDisabled, required: isRequired, ref: (elem) => elem && (elem.indeterminate = isChecked === null) }, checkedProps, getOUIAProps(_Checkbox.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe)));
    const wrapWithLabel = isLabelWrapped && !component || component === "label";
    const Label2 = wrapWithLabel ? "span" : "label";
    const labelRendered = label ? React66.createElement(
      Label2,
      { className: css(check_default.checkLabel, isDisabled && check_default.modifiers.disabled), htmlFor: !wrapWithLabel ? props.id : void 0 },
      label,
      isRequired && React66.createElement("span", { className: css(check_default.checkLabelRequired), "aria-hidden": "true" }, ASTERISK)
    ) : null;
    const Component50 = component !== null && component !== void 0 ? component : wrapWithLabel ? "label" : "div";
    checkedProps.checked = checkedProps.checked === null ? false : checkedProps.checked;
    return React66.createElement(
      Component50,
      { className: css(check_default.check, !label && check_default.modifiers.standalone, className), htmlFor: wrapWithLabel ? props.id : void 0 },
      labelPosition === "start" ? React66.createElement(
        React66.Fragment,
        null,
        labelRendered,
        inputRendered
      ) : React66.createElement(
        React66.Fragment,
        null,
        inputRendered,
        labelRendered
      ),
      description && React66.createElement("span", { className: css(check_default.checkDescription) }, description),
      body && React66.createElement("span", { className: css(check_default.checkBody) }, body)
    );
  }
};
Checkbox.displayName = "Checkbox";
Checkbox.defaultProps = {
  className: "",
  isLabelWrapped: false,
  isValid: true,
  isDisabled: false,
  isRequired: false,
  isChecked: false,
  onChange: defaultOnChange,
  ouiaSafe: true
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuItemAction.js
var React67 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/star-icon.js
var StarIconConfig = {
  name: "StarIcon",
  height: 512,
  width: 576,
  svgPath: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z",
  yOffset: 0,
  xOffset: 0
};
var StarIcon = createIcon(StarIconConfig);
var star_icon_default = StarIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuItemAction.js
var MenuItemActionBase = (_a2) => {
  var { className, icon, onClick, "aria-label": ariaLabel, isFavorited = null, isDisabled, actionId, innerRef } = _a2, props = __rest(_a2, ["className", "icon", "onClick", "aria-label", "isFavorited", "isDisabled", "actionId", "innerRef"]);
  return React67.createElement(MenuContext.Consumer, null, ({ onActionClick }) => React67.createElement(MenuItemContext.Consumer, null, ({ itemId, isDisabled: isDisabledContext }) => {
    const onClickButton = (event) => {
      onClick && onClick(event);
      onActionClick && onActionClick(event, itemId, actionId);
    };
    return React67.createElement(
      "div",
      Object.assign({ className: css(menu_default.menuItemAction, isFavorited !== null && "pf-m-favorite", isFavorited && menu_default.modifiers.favorited, className) }, props),
      React67.createElement(Button, { "aria-label": ariaLabel, onClick: onClickButton, ref: innerRef, role: "menuitem", variant: "plain", tabIndex: -1, isDisabled: isDisabled || isDisabledContext }, icon === "favorites" || isFavorited !== null ? React67.createElement(star_icon_default, { "aria-hidden": true }) : icon)
    );
  }));
};
var MenuItemAction = React67.forwardRef((props, ref) => React67.createElement(MenuItemActionBase, Object.assign({}, props, { innerRef: ref })));
MenuItemAction.displayName = "MenuItemAction";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuItem.js
var FlyoutContext = React68.createContext({
  direction: "right"
});
var MenuItemBase = (_a2) => {
  var { children: children2, className, itemId = null, to, hasCheckbox = false, isActive = null, isFavorited = null, isLoadButton = false, isLoading = false, flyoutMenu, direction, description = null, onClick = () => {
  }, component = "button", isDisabled = false, isAriaDisabled = false, isExternalLink = false, isSelected = null, isFocused, isDanger = false, icon, actions, onShowFlyout, drilldownMenu, isOnPath, innerRef, id: id2, "aria-label": ariaLabel, tooltipProps, rel, target, download } = _a2, props = __rest(_a2, ["children", "className", "itemId", "to", "hasCheckbox", "isActive", "isFavorited", "isLoadButton", "isLoading", "flyoutMenu", "direction", "description", "onClick", "component", "isDisabled", "isAriaDisabled", "isExternalLink", "isSelected", "isFocused", "isDanger", "icon", "actions", "onShowFlyout", "drilldownMenu", "isOnPath", "innerRef", "id", "aria-label", "tooltipProps", "rel", "target", "download"]);
  const { menuId, parentMenu, onSelect, onActionClick, activeItemId, selected, drilldownItemPath, onDrillIn, onDrillOut, flyoutRef, setFlyoutRef, disableHover, role: menuRole } = React68.useContext(MenuContext);
  let Component50 = to ? "a" : component;
  if (hasCheckbox && !to) {
    Component50 = "label";
  }
  const [flyoutTarget, setFlyoutTarget] = React68.useState(null);
  const flyoutContext = React68.useContext(FlyoutContext);
  const [flyoutXDirection, setFlyoutXDirection] = React68.useState(flyoutContext.direction);
  const ref = React68.useRef();
  const flyoutVisible = ref === flyoutRef;
  const hasFlyout = flyoutMenu !== void 0;
  const showFlyout = (show) => {
    if (!flyoutVisible && show) {
      setFlyoutRef(ref);
    } else if (flyoutVisible && !show) {
      setFlyoutRef(null);
    }
    onShowFlyout && show && onShowFlyout();
  };
  useIsomorphicLayoutEffect(() => {
    if (hasFlyout && ref.current && canUseDOM) {
      const flyoutMenu2 = ref.current.lastElementChild;
      if (flyoutMenu2 && flyoutMenu2.classList.contains(menu_default.menu)) {
        const origin = ref.current.getClientRects()[0];
        const rect = flyoutMenu2.getClientRects()[0];
        if (origin && rect) {
          const spaceLeftLeft = origin.x - rect.width;
          const spaceLeftRight = window.innerWidth - origin.x - origin.width - rect.width;
          let xDir = flyoutXDirection;
          if (spaceLeftRight < 0 && xDir !== "left") {
            setFlyoutXDirection("left");
            xDir = "left";
          } else if (spaceLeftLeft < 0 && xDir !== "right") {
            setFlyoutXDirection("right");
            xDir = "right";
          }
          let xOffset = 0;
          if (spaceLeftLeft < 0 && spaceLeftRight < 0) {
            xOffset = xDir === "right" ? -spaceLeftRight : -spaceLeftLeft;
          }
          if (xDir === "left") {
            flyoutMenu2.classList.add(menu_default.modifiers.left);
            flyoutMenu2.style.setProperty(c_menu_m_flyout_menu_m_left_right_offset_default.name, `-${xOffset}px`);
          } else {
            flyoutMenu2.style.setProperty(c_menu_m_flyout_menu_left_offset_default.name, `-${xOffset}px`);
          }
          const spaceLeftBot = window.innerHeight - origin.y - rect.height;
          const spaceLeftTop = window.innerHeight - rect.height;
          if (spaceLeftTop < 0 && spaceLeftBot < 0) {
          } else if (spaceLeftBot < 0) {
            flyoutMenu2.style.setProperty(c_menu_m_flyout_menu_top_offset_default.name, `${spaceLeftBot}px`);
          }
        }
      }
    }
  }, [flyoutVisible, flyoutMenu]);
  React68.useEffect(() => {
    setFlyoutXDirection(flyoutContext.direction);
  }, [flyoutContext]);
  React68.useEffect(() => {
    if (flyoutTarget) {
      if (flyoutVisible) {
        const flyoutMenu2 = flyoutTarget.nextElementSibling;
        const flyoutItems = Array.from(flyoutMenu2.getElementsByTagName("UL")[0].children).filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider)));
        flyoutItems[0].firstChild.focus();
      } else {
        flyoutTarget.focus();
      }
    }
  }, [flyoutVisible, flyoutTarget]);
  const handleFlyout = (event) => {
    const key = event.key;
    const target2 = event.target;
    const type2 = event.type;
    if (key === " " || key === "Enter" || key === "ArrowRight" || type2 === "click") {
      event.stopPropagation();
      event.preventDefault();
      if (!flyoutVisible) {
        showFlyout(true);
        setFlyoutTarget(target2);
      }
    }
    if (key === "Escape" || key === "ArrowLeft") {
      if (flyoutVisible) {
        event.stopPropagation();
        showFlyout(false);
      }
    }
  };
  const onItemSelect = (event, onSelect2) => {
    if (!isAriaDisabled) {
      onSelect2 && onSelect2(event, itemId);
      onClick && onClick(event);
    }
  };
  const _isOnPath = isOnPath && isOnPath || drilldownItemPath && drilldownItemPath.includes(itemId) || false;
  let drill;
  if (direction) {
    if (direction === "down") {
      drill = (event) => onDrillIn && onDrillIn(event, menuId, typeof drilldownMenu === "function" ? drilldownMenu().props.id : drilldownMenu.props.id, itemId);
    } else {
      drill = (event) => onDrillOut && onDrillOut(event, parentMenu, itemId);
    }
  }
  let additionalProps = {};
  if (Component50 === "a") {
    additionalProps = {
      href: to,
      "aria-disabled": isDisabled || isAriaDisabled ? true : null,
      // prevent invalid 'disabled' attribute on <a> tags
      disabled: null,
      target: isExternalLink ? "_blank" : target,
      rel,
      download
    };
  } else if (Component50 === "button") {
    additionalProps = {
      type: "button",
      "aria-disabled": isAriaDisabled ? true : null
    };
  }
  if (isOnPath) {
    additionalProps["aria-expanded"] = true;
  } else if (hasFlyout) {
    additionalProps["aria-haspopup"] = "menu";
    additionalProps["aria-expanded"] = flyoutVisible;
  }
  const getAriaCurrent = () => {
    if (isActive !== null) {
      if (isActive) {
        return "page";
      } else {
        return null;
      }
    } else if (itemId !== null && activeItemId !== null) {
      return itemId === activeItemId;
    }
    return null;
  };
  const getIsSelected = () => {
    if (isSelected !== null) {
      return isSelected;
    } else if (selected !== null && itemId !== null) {
      return Array.isArray(selected) && selected.includes(itemId) || itemId === selected;
    }
    return false;
  };
  const onMouseOver = () => {
    if (disableHover) {
      return;
    }
    if (hasFlyout) {
      showFlyout(true);
    } else {
      setFlyoutRef(null);
    }
  };
  React68.useEffect(() => {
    if (isFocused && ref.current) {
      const itemEl = ref.current;
      const parentListEl = itemEl.parentElement;
      if (parentListEl) {
        const isAboveTop = itemEl.offsetTop - parentListEl.offsetTop < parentListEl.scrollTop;
        const isBelowBottom = itemEl.offsetTop - parentListEl.offsetTop + itemEl.clientHeight;
        if (isAboveTop || isBelowBottom) {
          itemEl.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      }
    }
  }, [isFocused]);
  const isSelectMenu = menuRole === "listbox";
  const renderItem = React68.createElement(
    React68.Fragment,
    null,
    React68.createElement(GenerateId, null, (randomId) => React68.createElement(
      Component50,
      Object.assign({ id: id2, tabIndex: -1, className: css(menu_default.menuItem, getIsSelected() && !hasCheckbox && menu_default.modifiers.selected, className), "aria-current": getAriaCurrent() }, !hasCheckbox && { disabled: isDisabled, "aria-label": ariaLabel }, !hasCheckbox && !flyoutMenu && { role: isSelectMenu ? "option" : "menuitem" }, !hasCheckbox && !flyoutMenu && isSelectMenu && { "aria-selected": getIsSelected() }, { ref: innerRef }, !hasCheckbox && {
        onClick: (event) => {
          if (!isAriaDisabled) {
            onItemSelect(event, onSelect);
            drill && drill(event);
            flyoutMenu && handleFlyout(event);
          } else {
            event.preventDefault();
          }
        }
      }, hasCheckbox && { htmlFor: randomId }, additionalProps),
      React68.createElement(
        "span",
        { className: css(menu_default.menuItemMain) },
        direction === "up" && React68.createElement(
          "span",
          { className: css(menu_default.menuItemToggleIcon) },
          React68.createElement(angle_left_icon_default, { "aria-hidden": true })
        ),
        icon && React68.createElement("span", { className: css(menu_default.menuItemIcon) }, icon),
        hasCheckbox && React68.createElement(
          "span",
          { className: css(menu_default.menuItemCheck) },
          React68.createElement(Checkbox, { id: randomId, component: "span", isChecked: isSelected || false, onChange: (event) => onItemSelect(event, onSelect), isDisabled, "aria-disabled": isAriaDisabled })
        ),
        React68.createElement("span", { className: css(menu_default.menuItemText) }, children2),
        isExternalLink && React68.createElement(
          "span",
          { className: css(menu_default.menuItemExternalIcon) },
          React68.createElement(external_link_alt_icon_default, { "aria-hidden": true })
        ),
        (flyoutMenu || direction === "down") && React68.createElement(
          "span",
          { className: css(menu_default.menuItemToggleIcon) },
          React68.createElement(angle_right_icon_default, { "aria-hidden": true })
        ),
        getIsSelected() && React68.createElement(
          "span",
          { className: css(menu_default.menuItemSelectIcon) },
          React68.createElement(check_icon_default, { "aria-hidden": true })
        )
      ),
      description && direction !== "up" && React68.createElement(
        "span",
        { className: css(menu_default.menuItemDescription) },
        React68.createElement("span", null, description)
      )
    )),
    flyoutVisible && React68.createElement(
      MenuContext.Provider,
      { value: { disableHover } },
      React68.createElement(FlyoutContext.Provider, { value: { direction: flyoutXDirection } }, flyoutMenu)
    ),
    typeof drilldownMenu === "function" ? drilldownMenu() : drilldownMenu,
    React68.createElement(
      MenuItemContext.Provider,
      { value: { itemId, isDisabled } },
      actions,
      isFavorited !== null && React68.createElement(MenuItemAction, { icon: "favorites", isFavorited, "aria-label": isFavorited ? "starred" : "not starred", onClick: (event) => onActionClick(event, itemId), tabIndex: -1, actionId: "fav" })
    )
  );
  return React68.createElement("li", Object.assign({ className: css(menu_default.menuListItem, isDisabled && menu_default.modifiers.disabled, isAriaDisabled && menu_default.modifiers.ariaDisabled, _isOnPath && menu_default.modifiers.currentPath, isLoadButton && menu_default.modifiers.load, isLoading && menu_default.modifiers.loading, isFocused && "pf-m-focus", isDanger && menu_default.modifiers.danger, className), onMouseOver: () => {
    if (!isAriaDisabled) {
      onMouseOver();
    }
  } }, flyoutMenu && !isAriaDisabled && { onKeyDown: handleFlyout }, { ref, role: !hasCheckbox ? "none" : "menuitem" }, hasCheckbox && { "aria-label": ariaLabel }, props), tooltipProps ? React68.createElement(Tooltip, Object.assign({}, tooltipProps), renderItem) : renderItem);
};
var MenuItem = React68.forwardRef((props, ref) => React68.createElement(MenuItemBase, Object.assign({}, props, { innerRef: ref })));
MenuItem.displayName = "MenuItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuList.js
var React69 = __toESM(require_react());
var MenuList = (_a2) => {
  var { children: children2 = null, className, isAriaMultiselectable = false, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["children", "className", "isAriaMultiselectable", "aria-label"]);
  const { role } = React69.useContext(MenuContext);
  return React69.createElement("ul", Object.assign({ role }, role === "listbox" && { "aria-multiselectable": isAriaMultiselectable }, { className: css(menu_default.menuList, className), "aria-label": ariaLabel }, props), children2);
};
MenuList.displayName = "MenuList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/DrilldownMenu.js
var import_react6 = __toESM(require_react());
var DrilldownMenu = (_a2) => {
  var { children: children2, id: id2, isMenuDrilledIn = false, getHeight } = _a2, props = __rest(_a2, ["children", "id", "isMenuDrilledIn", "getHeight"]);
  return (
    /* eslint-disable @typescript-eslint/no-unused-vars */
    import_react6.default.createElement(MenuContext.Consumer, null, (_a3) => {
      var { menuId, parentMenu, flyoutRef, setFlyoutRef, disableHover } = _a3, context = __rest(_a3, ["menuId", "parentMenu", "flyoutRef", "setFlyoutRef", "disableHover"]);
      return import_react6.default.createElement(
        Menu,
        Object.assign({ id: id2, parentMenu: menuId, isMenuDrilledIn, isRootMenu: false, ref: import_react6.default.createRef() }, context, props),
        import_react6.default.createElement(
          MenuContent,
          { getHeight },
          import_react6.default.createElement(MenuList, null, children2)
        )
      );
    })
  );
};
DrilldownMenu.displayName = "DrilldownMenu";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuBreadcrumb.js
var import_react7 = __toESM(require_react());
var MenuBreadcrumb = (_a2) => {
  var { children: children2 } = _a2, props = __rest(_a2, ["children"]);
  return import_react7.default.createElement("div", Object.assign({ className: css(menu_default.menuBreadcrumb) }, props), children2);
};
MenuBreadcrumb.displayName = "MenuBreadcrumb";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuContainer.js
var import_react8 = __toESM(require_react());
var MenuContainer = ({ menu, menuRef, isOpen, toggle, toggleRef, onOpenChange, zIndex = 9999, popperProps, onOpenChangeKeys = ["Escape", "Tab"] }) => {
  import_react8.default.useEffect(() => {
    const handleMenuKeys = (event) => {
      var _a2, _b, _c;
      if (isOpen && onOpenChange && ((_a2 = menuRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) || ((_b = toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
        if (onOpenChangeKeys.includes(event.key)) {
          onOpenChange(false);
          (_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.focus();
        }
      }
    };
    const handleClick = (event) => {
      var _a2, _b, _c;
      if (isOpen && ((_a2 = toggleRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target))) {
        setTimeout(() => {
          var _a3;
          const firstElement = (_a3 = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a3 === void 0 ? void 0 : _a3.querySelector('li button:not(:disabled),li input:not(:disabled),li a:not([aria-disabled="true"])');
          firstElement && firstElement.focus();
        }, 0);
      }
      if (isOpen && onOpenChange && !((_b = toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
        if (isOpen && !((_c = menuRef.current) === null || _c === void 0 ? void 0 : _c.contains(event.target))) {
          onOpenChange(false);
        }
      }
    };
    window.addEventListener("keydown", handleMenuKeys);
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("keydown", handleMenuKeys);
      window.removeEventListener("click", handleClick);
    };
  }, [isOpen, menuRef, onOpenChange, onOpenChangeKeys, toggleRef]);
  return import_react8.default.createElement(Popper, Object.assign({ trigger: toggle, triggerRef: toggleRef, popper: menu, popperRef: menuRef, isVisible: isOpen, zIndex }, popperProps));
};
MenuContainer.displayName = "MenuContainer";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Select/Select.js
var SelectBase = (_a2) => {
  var { children: children2, className, onSelect, isOpen, selected, toggle, shouldFocusToggleOnSelect = false, shouldFocusFirstItemOnOpen = true, onOpenChange, onOpenChangeKeys = ["Escape", "Tab"], isPlain, innerRef, zIndex = 9999, role = "listbox", popperProps, menuHeight, maxMenuHeight, isScrollable } = _a2, props = __rest(_a2, ["children", "className", "onSelect", "isOpen", "selected", "toggle", "shouldFocusToggleOnSelect", "shouldFocusFirstItemOnOpen", "onOpenChange", "onOpenChangeKeys", "isPlain", "innerRef", "zIndex", "role", "popperProps", "menuHeight", "maxMenuHeight", "isScrollable"]);
  const localMenuRef = import_react9.default.useRef();
  const localToggleRef = import_react9.default.useRef();
  const menuRef = innerRef || localMenuRef;
  const toggleRef = typeof toggle === "function" || typeof toggle !== "function" && !toggle.toggleRef ? localToggleRef : toggle === null || toggle === void 0 ? void 0 : toggle.toggleRef;
  import_react9.default.useEffect(() => {
    const handleMenuKeys = (event) => {
      var _a3, _b, _c;
      if (isOpen && onOpenChange && (((_a3 = menuRef.current) === null || _a3 === void 0 ? void 0 : _a3.contains(event.target)) || ((_b = toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)))) {
        if (onOpenChangeKeys.includes(event.key)) {
          event.preventDefault();
          onOpenChange(false);
          (_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.focus();
        }
      }
    };
    const handleClick = (event) => {
      var _a3, _b, _c;
      if (isOpen && shouldFocusFirstItemOnOpen && ((_a3 = toggleRef.current) === null || _a3 === void 0 ? void 0 : _a3.contains(event.target))) {
        setTimeout(() => {
          var _a4;
          const firstElement = (_a4 = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a4 === void 0 ? void 0 : _a4.querySelector("li button:not(:disabled),li input:not(:disabled)");
          firstElement && firstElement.focus();
        }, 0);
      }
      if (isOpen && onOpenChange && !((_b = toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
        if (isOpen && !((_c = menuRef.current) === null || _c === void 0 ? void 0 : _c.contains(event.target))) {
          onOpenChange(false);
        }
      }
    };
    window.addEventListener("keydown", handleMenuKeys);
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("keydown", handleMenuKeys);
      window.removeEventListener("click", handleClick);
    };
  }, [isOpen, menuRef, toggleRef, onOpenChange, onOpenChangeKeys]);
  const menu = import_react9.default.createElement(
    Menu,
    Object.assign({ role, className: css(className), ref: menuRef, onSelect: (event, value) => {
      onSelect && onSelect(event, value);
      shouldFocusToggleOnSelect && toggleRef.current.focus();
    }, isPlain, selected, isScrollable: isScrollable !== null && isScrollable !== void 0 ? isScrollable : menuHeight !== void 0 || maxMenuHeight !== void 0 }, getOUIAProps(Select.displayName, props.ouiaId !== void 0 ? props.ouiaId : getDefaultOUIAId(Select.displayName), props.ouiaSafe !== void 0 ? props.ouiaSafe : true), props),
    import_react9.default.createElement(MenuContent, { menuHeight, maxMenuHeight }, children2)
  );
  return import_react9.default.createElement(Popper, Object.assign({ trigger: typeof toggle === "function" ? toggle(toggleRef) : toggle.toggleNode, triggerRef: toggleRef, popper: menu, popperRef: menuRef, isVisible: isOpen, zIndex }, popperProps));
};
var Select = import_react9.default.forwardRef((props, ref) => import_react9.default.createElement(SelectBase, Object.assign({ innerRef: ref }, props)));
Select.displayName = "Select";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Select/SelectGroup.js
var import_react10 = __toESM(require_react());
var SelectGroup = (_a2) => {
  var { children: children2, className, label } = _a2, props = __rest(_a2, ["children", "className", "label"]);
  return import_react10.default.createElement(MenuGroup, Object.assign({ className: css(className), label }, props), children2);
};
SelectGroup.displayName = "SelectGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Select/SelectList.js
var import_react11 = __toESM(require_react());
var SelectList = (_a2) => {
  var { children: children2, className, isAriaMultiselectable = false } = _a2, props = __rest(_a2, ["children", "className", "isAriaMultiselectable"]);
  return import_react11.default.createElement(MenuList, Object.assign({ isAriaMultiselectable, className: css(className) }, props), children2);
};
SelectList.displayName = "SelectList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Select/SelectOption.js
var import_react12 = __toESM(require_react());
var SelectOptionBase = (_a2) => {
  var { children: children2, className, innerRef, value } = _a2, props = __rest(_a2, ["children", "className", "innerRef", "value"]);
  return import_react12.default.createElement(MenuItem, Object.assign({ itemId: value, ref: innerRef, className: css(className) }, props), children2);
};
var SelectOption = import_react12.default.forwardRef((props, ref) => import_react12.default.createElement(SelectOptionBase, Object.assign({}, props, { innerRef: ref })));
SelectOption.displayName = "SelectOption";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MenuToggle/MenuToggle.js
var React77 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/MenuToggle/menu-toggle.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/MenuToggle/menu-toggle.css";
var menu_toggle_default = {
  "button": "pf-v6-c-button",
  "check": "pf-v6-c-check",
  "checkInput": "pf-v6-c-check__input",
  "menuToggle": "pf-v6-c-menu-toggle",
  "menuToggleButton": "pf-v6-c-menu-toggle__button",
  "menuToggleControls": "pf-v6-c-menu-toggle__controls",
  "menuToggleCount": "pf-v6-c-menu-toggle__count",
  "menuToggleIcon": "pf-v6-c-menu-toggle__icon",
  "menuToggleStatusIcon": "pf-v6-c-menu-toggle__status-icon",
  "menuToggleText": "pf-v6-c-menu-toggle__text",
  "menuToggleToggleIcon": "pf-v6-c-menu-toggle__toggle-icon",
  "modifiers": {
    "primary": "pf-m-primary",
    "secondary": "pf-m-secondary",
    "fullHeight": "pf-m-full-height",
    "fullWidth": "pf-m-full-width",
    "plain": "pf-m-plain",
    "expanded": "pf-m-expanded",
    "disabled": "pf-m-disabled",
    "small": "pf-m-small",
    "success": "pf-m-success",
    "warning": "pf-m-warning",
    "danger": "pf-m-danger",
    "splitButton": "pf-m-split-button",
    "action": "pf-m-action",
    "typeahead": "pf-m-typeahead"
  },
  "textInputGroup": "pf-v6-c-text-input-group"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/caret-down-icon.js
var CaretDownIconConfig = {
  name: "CaretDownIcon",
  height: 512,
  width: 320,
  svgPath: "M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z",
  yOffset: 0,
  xOffset: 0
};
var CaretDownIcon = createIcon(CaretDownIconConfig);
var caret_down_icon_default = CaretDownIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MenuToggle/MenuToggle.js
var MenuToggleStatus;
(function(MenuToggleStatus2) {
  MenuToggleStatus2["success"] = "success";
  MenuToggleStatus2["danger"] = "danger";
  MenuToggleStatus2["warning"] = "warning";
})(MenuToggleStatus || (MenuToggleStatus = {}));
var MenuToggleBase = class extends React77.Component {
  constructor() {
    super(...arguments);
    this.displayName = "MenuToggleBase";
  }
  render() {
    const _a2 = this.props, { children: children2, className, icon, badge, isExpanded, isDisabled, isFullHeight, isFullWidth, splitButtonOptions, variant, status, statusIcon, innerRef, onClick, "aria-label": ariaLabel } = _a2, otherProps = __rest(_a2, ["children", "className", "icon", "badge", "isExpanded", "isDisabled", "isFullHeight", "isFullWidth", "splitButtonOptions", "variant", "status", "statusIcon", "innerRef", "onClick", "aria-label"]);
    const isPlain = variant === "plain";
    const isPlainText = variant === "plainText";
    const isTypeahead = variant === "typeahead";
    let _statusIcon = statusIcon;
    if (!statusIcon) {
      switch (status) {
        case MenuToggleStatus.success:
          _statusIcon = React77.createElement(check_circle_icon_default, { "aria-hidden": "true" });
          break;
        case MenuToggleStatus.warning:
          _statusIcon = React77.createElement(exclamation_triangle_icon_default, { "aria-hidden": "true" });
          break;
        case MenuToggleStatus.danger:
          _statusIcon = React77.createElement(exclamation_circle_icon_default, { "aria-hidden": "true" });
          break;
      }
    }
    const toggleControls = React77.createElement(
      "span",
      { className: css(menu_toggle_default.menuToggleControls) },
      status !== void 0 && React77.createElement("span", { className: css(menu_toggle_default.menuToggleStatusIcon) }, _statusIcon),
      React77.createElement(
        "span",
        { className: css(menu_toggle_default.menuToggleToggleIcon) },
        React77.createElement(caret_down_icon_default, { "aria-hidden": true })
      )
    );
    const content = React77.createElement(
      React77.Fragment,
      null,
      icon && React77.createElement("span", { className: css(menu_toggle_default.menuToggleIcon) }, icon),
      isTypeahead ? children2 : children2 && React77.createElement("span", { className: css(menu_toggle_default.menuToggleText) }, children2),
      React77.isValidElement(badge) && React77.createElement("span", { className: css(menu_toggle_default.menuToggleCount) }, badge),
      isTypeahead ? React77.createElement("button", { type: "button", className: css(menu_toggle_default.menuToggleButton), "aria-expanded": isExpanded, onClick, "aria-label": ariaLabel || "Menu toggle", tabIndex: -1 }, toggleControls) : !isPlain && toggleControls
    );
    const commonStyles = css(menu_toggle_default.menuToggle, isExpanded && menu_toggle_default.modifiers.expanded, variant === "primary" && menu_toggle_default.modifiers.primary, variant === "secondary" && menu_toggle_default.modifiers.secondary, status && menu_toggle_default.modifiers[status], (isPlain || isPlainText) && menu_toggle_default.modifiers.plain, isPlainText && "pf-m-text", isFullHeight && menu_toggle_default.modifiers.fullHeight, isFullWidth && menu_toggle_default.modifiers.fullWidth, isDisabled && menu_toggle_default.modifiers.disabled, className);
    const componentProps = Object.assign(Object.assign({ children: content }, isDisabled && { disabled: true }), otherProps);
    if (isTypeahead) {
      return React77.createElement("div", Object.assign({ ref: innerRef, className: css(commonStyles, menu_toggle_default.modifiers.typeahead) }, componentProps));
    }
    if (splitButtonOptions) {
      return React77.createElement(
        "div",
        { ref: innerRef, className: css(commonStyles, menu_toggle_default.modifiers.splitButton, (splitButtonOptions === null || splitButtonOptions === void 0 ? void 0 : splitButtonOptions.variant) === "action" && menu_toggle_default.modifiers.action) },
        splitButtonOptions === null || splitButtonOptions === void 0 ? void 0 : splitButtonOptions.items,
        React77.createElement(
          "button",
          Object.assign({ className: css(menu_toggle_default.menuToggleButton), type: "button", "aria-expanded": isExpanded, "aria-label": ariaLabel, disabled: isDisabled, onClick }, children2 && { style: { display: "flex", paddingLeft: "var(--pf-v5-global--spacer--sm)" } }, otherProps),
          children2 && React77.createElement("span", { className: css(menu_toggle_default.menuToggleText) }, children2),
          toggleControls
        )
      );
    }
    return React77.createElement("button", Object.assign({ className: css(commonStyles), type: "button", "aria-label": ariaLabel, "aria-expanded": isExpanded, ref: innerRef, disabled: isDisabled, onClick }, componentProps));
  }
};
MenuToggleBase.defaultProps = {
  className: "",
  isExpanded: false,
  isDisabled: false,
  isFullWidth: false,
  isFullHeight: false
};
var MenuToggle = React77.forwardRef((props, ref) => React77.createElement(MenuToggleBase, Object.assign({ innerRef: ref }, props)));
MenuToggle.displayName = "MenuToggle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MenuToggle/MenuToggleAction.js
var React78 = __toESM(require_react());
var MenuToggleAction = class extends React78.Component {
  render() {
    const _a2 = this.props, { id: id2, className, onClick, isDisabled, children: children2 } = _a2, props = __rest(_a2, ["id", "className", "onClick", "isDisabled", "children"]);
    return React78.createElement("button", Object.assign({ id: id2, className: css(menu_toggle_default.menuToggleButton, className), onClick, type: "button", disabled: isDisabled }, props), children2);
  }
};
MenuToggleAction.displayName = "MenuToggleAction";
MenuToggleAction.defaultProps = {
  className: "",
  isDisabled: false,
  onClick: () => {
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MenuToggle/MenuToggleCheckbox.js
var React79 = __toESM(require_react());
var MenuToggleCheckbox = class _MenuToggleCheckbox extends React79.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event.target.checked, event);
    };
    this.calculateChecked = () => {
      const { isChecked, defaultChecked } = this.props;
      if (isChecked === null) {
        return false;
      } else if (isChecked !== void 0) {
        return isChecked;
      }
      return defaultChecked;
    };
    this.state = {
      ouiaStateId: getDefaultOUIAId(_MenuToggleCheckbox.displayName)
    };
  }
  render() {
    const _a2 = this.props, {
      className,
      isValid,
      isDisabled,
      isChecked,
      children: children2,
      ouiaId,
      ouiaSafe,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onChange,
      defaultChecked,
      id: id2
    } = _a2, props = __rest(_a2, ["className", "isValid", "isDisabled", "isChecked", "children", "ouiaId", "ouiaSafe", "onChange", "defaultChecked", "id"]);
    const text = children2 && React79.createElement("span", { className: css(check_default.checkLabel, className), "aria-hidden": "true", id: id2 }, children2);
    return React79.createElement(
      "label",
      { className: css(check_default.check, !children2 && check_default.modifiers.standalone, className) },
      React79.createElement("input", Object.assign({ className: css(check_default.checkInput) }, this.calculateChecked() !== void 0 && { onChange: this.handleChange }, { name: id2, type: "checkbox", ref: (elem) => elem && (elem.indeterminate = isChecked === null), "aria-invalid": !isValid, disabled: isDisabled }, defaultChecked !== void 0 ? { defaultChecked } : { checked: this.calculateChecked() }, getOUIAProps(_MenuToggleCheckbox.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), props)),
      text
    );
  }
};
MenuToggleCheckbox.displayName = "MenuToggleCheckbox";
MenuToggleCheckbox.defaultProps = {
  isValid: true,
  isDisabled: false,
  onChange: () => void 0
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/InputGroup/InputGroup.js
var React80 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/InputGroup/input-group.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/InputGroup/input-group.css";
var input_group_default = {
  "inputGroup": "pf-v6-c-input-group",
  "inputGroupItem": "pf-v6-c-input-group__item",
  "inputGroupText": "pf-v6-c-input-group__text",
  "modifiers": {
    "box": "pf-m-box",
    "plain": "pf-m-plain",
    "disabled": "pf-m-disabled",
    "fill": "pf-m-fill"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/InputGroup/InputGroup.js
var InputGroupBase = (_a2) => {
  var { className, children: children2, innerRef } = _a2, props = __rest(_a2, ["className", "children", "innerRef"]);
  const ref = React80.useRef(null);
  const inputGroupRef = innerRef || ref;
  return React80.createElement("div", Object.assign({ ref: inputGroupRef, className: css(input_group_default.inputGroup, className) }, props), children2);
};
InputGroupBase.displayName = "InputGroupBase";
var InputGroup = React80.forwardRef((props, ref) => React80.createElement(InputGroupBase, Object.assign({ innerRef: ref }, props)));
InputGroup.displayName = "InputGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/InputGroup/InputGroupItem.js
var React81 = __toESM(require_react());
var InputGroupItem = (_a2) => {
  var { className, children: children2, isFill = false, isBox = false, isPlain, isDisabled } = _a2, props = __rest(_a2, ["className", "children", "isFill", "isBox", "isPlain", "isDisabled"]);
  return React81.createElement("div", Object.assign({ className: css(input_group_default.inputGroupItem, isFill && input_group_default.modifiers.fill, isBox && input_group_default.modifiers.box, isPlain && input_group_default.modifiers.plain, isDisabled && input_group_default.modifiers.disabled, className) }, props), children2);
};
InputGroupItem.displayName = "InputGroupItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/InputGroup/InputGroupText.js
var React82 = __toESM(require_react());
var InputGroupText = (_a2) => {
  var { className, component = "span", children: children2, isPlain, isDisabled } = _a2, props = __rest(_a2, ["className", "component", "children", "isPlain", "isDisabled"]);
  const Component50 = component;
  return React82.createElement(
    InputGroupItem,
    { isPlain, isBox: true, isDisabled },
    React82.createElement(Component50, Object.assign({ className: css(input_group_default.inputGroupText, className) }, props), children2)
  );
};
InputGroupText.displayName = "InputGroupText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/CalendarMonth/calendar-month.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/CalendarMonth/calendar-month.css";
var calendar_month_default = {
  "calendarMonth": "pf-v6-c-calendar-month",
  "calendarMonthCalendar": "pf-v6-c-calendar-month__calendar",
  "calendarMonthDate": "pf-v6-c-calendar-month__date",
  "calendarMonthDatesCell": "pf-v6-c-calendar-month__dates-cell",
  "calendarMonthDatesRow": "pf-v6-c-calendar-month__dates-row",
  "calendarMonthDay": "pf-v6-c-calendar-month__day",
  "calendarMonthDays": "pf-v6-c-calendar-month__days",
  "calendarMonthHeader": "pf-v6-c-calendar-month__header",
  "calendarMonthHeaderMonth": "pf-v6-c-calendar-month__header-month",
  "calendarMonthHeaderNavControl": "pf-v6-c-calendar-month__header-nav-control",
  "calendarMonthHeaderYear": "pf-v6-c-calendar-month__header-year",
  "dirRtl": "pf-v6-m-dir-rtl",
  "menuToggle": "pf-v6-c-menu-toggle",
  "modifiers": {
    "current": "pf-m-current",
    "inRange": "pf-m-in-range",
    "startRange": "pf-m-start-range",
    "endRange": "pf-m-end-range",
    "adjacentMonth": "pf-m-adjacent-month",
    "selected": "pf-m-selected",
    "disabled": "pf-m-disabled",
    "hover": "pf-m-hover",
    "focus": "pf-m-focus"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/CalendarMonth/CalendarMonth.js
var Weekday;
(function(Weekday2) {
  Weekday2[Weekday2["Sunday"] = 0] = "Sunday";
  Weekday2[Weekday2["Monday"] = 1] = "Monday";
  Weekday2[Weekday2["Tuesday"] = 2] = "Tuesday";
  Weekday2[Weekday2["Wednesday"] = 3] = "Wednesday";
  Weekday2[Weekday2["Thursday"] = 4] = "Thursday";
  Weekday2[Weekday2["Friday"] = 5] = "Friday";
  Weekday2[Weekday2["Saturday"] = 6] = "Saturday";
})(Weekday || (Weekday = {}));
var buildCalendar = (year, month, weekStart, validators) => {
  const defaultDate = new Date(year, month);
  const firstDayOfWeek = new Date(defaultDate);
  firstDayOfWeek.setDate(firstDayOfWeek.getDate() - firstDayOfWeek.getDay() + weekStart);
  const calendarWeeks = [];
  if (firstDayOfWeek.getMonth() === defaultDate.getMonth() && firstDayOfWeek.getDate() !== 1) {
    firstDayOfWeek.setDate(firstDayOfWeek.getDate() - 7);
  }
  for (let i = 0; i < 6; i++) {
    const week = [];
    for (let j = 0; j < 7; j++) {
      const date2 = new Date(firstDayOfWeek);
      week.push({
        date: date2,
        isValid: validators.every((validator) => validator(date2))
      });
      firstDayOfWeek.setDate(firstDayOfWeek.getDate() + 1);
    }
    calendarWeeks.push(week);
    if (firstDayOfWeek.getMonth() !== defaultDate.getMonth()) {
      break;
    }
  }
  return calendarWeeks;
};
var isSameDate = (d1, d2) => d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth() && d1.getDate() === d2.getDate();
var today = /* @__PURE__ */ new Date();
var CalendarMonth = (_a2) => {
  var {
    date: dateProp,
    locale: locale3 = void 0,
    monthFormat = (date2) => date2.toLocaleDateString(locale3, { month: "long" }),
    weekdayFormat = (date2) => date2.toLocaleDateString(locale3, { weekday: "narrow" }),
    longWeekdayFormat = (date2) => date2.toLocaleDateString(locale3, { weekday: "long" }),
    dayFormat = (date2) => date2.getDate(),
    weekStart = 0,
    // Use the American Sunday as a default
    onChange = () => {
    },
    validators = [() => true],
    className,
    onSelectToggle = () => {
    },
    onMonthChange = () => {
    },
    rangeStart,
    prevMonthAriaLabel = "Previous month",
    nextMonthAriaLabel = "Next month",
    yearInputAriaLabel = "Select year",
    cellAriaLabel,
    isDateFocused = false,
    inlineProps
  } = _a2, props = __rest(_a2, ["date", "locale", "monthFormat", "weekdayFormat", "longWeekdayFormat", "dayFormat", "weekStart", "onChange", "validators", "className", "onSelectToggle", "onMonthChange", "rangeStart", "prevMonthAriaLabel", "nextMonthAriaLabel", "yearInputAriaLabel", "cellAriaLabel", "isDateFocused", "inlineProps"]);
  const longMonths = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map((monthNum) => new Date(1990, monthNum)).map(monthFormat);
  const [isSelectOpen, setIsSelectOpen] = import_react13.default.useState(false);
  const getInitialDate = () => {
    if (isValidDate(dateProp)) {
      return dateProp;
    }
    if (isValidDate(rangeStart)) {
      return rangeStart;
    }
    return today;
  };
  const initialDate = getInitialDate();
  const [focusedDate, setFocusedDate] = import_react13.default.useState(initialDate);
  const yearFormat = (date2) => date2.getFullYear();
  const yearFormatted = yearFormat(focusedDate);
  const [yearInput, setYearInput] = import_react13.default.useState(yearFormatted.toString());
  const [hoveredDate, setHoveredDate] = import_react13.default.useState(new Date(focusedDate));
  const focusRef = import_react13.default.useRef();
  const [hiddenMonthId] = import_react13.default.useState(getUniqueId("hidden-month-span"));
  const [shouldFocus, setShouldFocus] = import_react13.default.useState(false);
  const isValidated = (date2) => validators.every((validator) => validator(date2));
  const focusedDateValidated = isValidated(focusedDate);
  (0, import_react13.useEffect)(() => {
    if (isValidDate(dateProp) && !isSameDate(focusedDate, dateProp)) {
      setFocusedDate(dateProp);
    } else if (!dateProp) {
      setFocusedDate(today);
    }
  }, [dateProp]);
  (0, import_react13.useEffect)(() => {
    if ((shouldFocus || isDateFocused) && focusedDateValidated && focusRef.current) {
      focusRef.current.focus();
    }
  }, [focusedDate, isDateFocused, focusedDateValidated, focusRef]);
  const onMonthClick = (ev, newDate2) => {
    setFocusedDate(newDate2);
    setHoveredDate(newDate2);
    setShouldFocus(false);
    onMonthChange(ev, newDate2);
    setYearInput(yearFormat(newDate2).toString());
  };
  const onKeyDown = (ev) => {
    const newDate2 = new Date(focusedDate);
    if (ev.key === "ArrowUp") {
      newDate2.setDate(newDate2.getDate() - 7);
    } else if (ev.key === "ArrowRight") {
      newDate2.setDate(newDate2.getDate() + 1);
    } else if (ev.key === "ArrowDown") {
      newDate2.setDate(newDate2.getDate() + 7);
    } else if (ev.key === "ArrowLeft") {
      newDate2.setDate(newDate2.getDate() - 1);
    }
    if (newDate2.getTime() !== focusedDate.getTime() && isValidated(newDate2)) {
      ev.preventDefault();
      setFocusedDate(newDate2);
      setHoveredDate(newDate2);
      setShouldFocus(true);
    }
  };
  const changeYear = (newYear) => changeMonth(focusedDate.getMonth(), newYear);
  const changeMonth = (newMonth, newYear) => new Date(newYear !== null && newYear !== void 0 ? newYear : focusedDate.getFullYear(), newMonth, 1);
  const MIN_YEAR = 1900;
  const MAX_YEAR = 2100;
  const handleYearInputChange = (event, yearStr) => {
    if (!/^\d{0,4}$/.test(yearStr)) {
      return;
    }
    setYearInput(yearStr);
    if (yearStr.length === 4) {
      const yearNum = Number(yearStr);
      if (yearNum >= MIN_YEAR && yearNum <= MAX_YEAR) {
        const newDate2 = changeYear(yearNum);
        setFocusedDate(newDate2);
        setHoveredDate(newDate2);
        setShouldFocus(false);
        event.target.focus();
        onMonthChange(event, newDate2);
      } else {
        setYearInput(yearFormatted.toString());
      }
    }
  };
  const addMonth = (toAdd) => {
    let newMonth = focusedDate.getMonth() + toAdd;
    let newYear = focusedDate.getFullYear();
    if (newMonth === -1) {
      newMonth = 11;
      newYear--;
    } else if (newMonth === 12) {
      newMonth = 0;
      newYear++;
    }
    return changeMonth(newMonth, newYear);
  };
  const prevMonth = addMonth(-1);
  const nextMonth = addMonth(1);
  const focusedYear = focusedDate.getFullYear();
  const focusedMonth = focusedDate.getMonth();
  const calendar2 = import_react13.default.useMemo(() => buildCalendar(focusedYear, focusedMonth, weekStart, validators), [focusedYear, focusedMonth, weekStart, validators]);
  if (!focusedDateValidated) {
    const toFocus = calendar2.reduce((acc, cur) => [...acc, ...cur], []).filter(({ date: date2, isValid }) => isValid && date2.getMonth() === focusedMonth).map(({ date: date2 }) => ({ date: date2, days: Math.abs(focusedDate.getTime() - date2.getTime()) })).sort((o1, o2) => o1.days - o2.days).map(({ date: date2 }) => date2)[0];
    if (toFocus) {
      setFocusedDate(toFocus);
      setHoveredDate(toFocus);
    }
  }
  const isHoveredDateValid = isValidated(hoveredDate);
  const monthFormatted = monthFormat(focusedDate);
  const calendarToRender = import_react13.default.createElement(
    "div",
    Object.assign({ className: css(calendar_month_default.calendarMonth, className) }, props),
    import_react13.default.createElement(
      "div",
      { className: calendar_month_default.calendarMonthHeader },
      import_react13.default.createElement(
        "div",
        { className: css(calendar_month_default.calendarMonthHeaderNavControl, "pf-m-prev-month") },
        import_react13.default.createElement(
          Button,
          { variant: "plain", "aria-label": prevMonthAriaLabel, onClick: (ev) => onMonthClick(ev, prevMonth) },
          import_react13.default.createElement(angle_left_icon_default, { "aria-hidden": true })
        )
      ),
      import_react13.default.createElement(
        InputGroup,
        null,
        import_react13.default.createElement(
          InputGroupItem,
          { isFill: true },
          import_react13.default.createElement(
            "div",
            { className: calendar_month_default.calendarMonthHeaderMonth },
            import_react13.default.createElement("span", { id: hiddenMonthId, hidden: true }, "Month"),
            import_react13.default.createElement(
              Select,
              { toggle: (toggleRef) => import_react13.default.createElement(MenuToggle, { ref: toggleRef, onClick: () => setIsSelectOpen(!isSelectOpen), isExpanded: isSelectOpen, style: { width: "140px" } }, monthFormatted), "aria-labelledby": hiddenMonthId, isOpen: isSelectOpen, onOpenChange: (isOpen) => {
                setIsSelectOpen(isOpen);
                onSelectToggle(isOpen);
              }, onSelect: (ev, monthNum) => {
                setTimeout(() => {
                  setIsSelectOpen(false);
                  onSelectToggle(false);
                  const newDate2 = changeMonth(Number(monthNum));
                  setFocusedDate(newDate2);
                  setHoveredDate(newDate2);
                  setShouldFocus(false);
                  onMonthChange(ev, newDate2);
                }, 0);
              }, selected: monthFormatted },
              import_react13.default.createElement(SelectList, null, longMonths.map((longMonth, index4) => import_react13.default.createElement(SelectOption, { key: index4, value: index4, isSelected: longMonth === monthFormatted }, longMonth)))
            )
          )
        ),
        import_react13.default.createElement(
          InputGroupItem,
          null,
          import_react13.default.createElement(
            "div",
            { className: calendar_month_default.calendarMonthHeaderYear },
            import_react13.default.createElement(TextInput, { "aria-label": yearInputAriaLabel, type: "number", value: yearInput, onChange: handleYearInputChange })
          )
        )
      ),
      import_react13.default.createElement(
        "div",
        { className: css(calendar_month_default.calendarMonthHeaderNavControl, "pf-m-next-month") },
        import_react13.default.createElement(
          Button,
          { variant: "plain", "aria-label": nextMonthAriaLabel, onClick: (ev) => onMonthClick(ev, nextMonth) },
          import_react13.default.createElement(angle_right_icon_default, { "aria-hidden": true })
        )
      )
    ),
    import_react13.default.createElement(
      "table",
      { className: calendar_month_default.calendarMonthCalendar },
      import_react13.default.createElement(
        "thead",
        { className: calendar_month_default.calendarMonthDays },
        import_react13.default.createElement("tr", null, calendar2[0].map(({ date: date2 }, index4) => import_react13.default.createElement(
          "th",
          { key: index4, className: calendar_month_default.calendarMonthDay, scope: "col" },
          import_react13.default.createElement("span", { className: "pf-v6-screen-reader" }, longWeekdayFormat(date2)),
          import_react13.default.createElement("span", { "aria-hidden": true }, weekdayFormat(date2))
        )))
      ),
      import_react13.default.createElement("tbody", { onKeyDown }, calendar2.map((week, index4) => import_react13.default.createElement("tr", { key: index4, className: calendar_month_default.calendarMonthDatesRow }, week.map(({ date: date2, isValid }, index5) => {
        const dayFormatted = dayFormat(date2);
        const isToday = isSameDate(date2, today);
        const isSelected = isValidDate(dateProp) && isSameDate(date2, dateProp);
        const isFocused = isSameDate(date2, focusedDate);
        const isAdjacentMonth = date2.getMonth() !== focusedDate.getMonth();
        const isRangeStart = isValidDate(rangeStart) && isSameDate(date2, rangeStart);
        let isInRange = false;
        let isRangeEnd = false;
        if (isValidDate(rangeStart) && isValidDate(dateProp)) {
          isInRange = date2 > rangeStart && date2 < dateProp;
          isRangeEnd = isSameDate(date2, dateProp);
        } else if (isValidDate(rangeStart) && isHoveredDateValid) {
          if (hoveredDate > rangeStart || isSameDate(hoveredDate, rangeStart)) {
            isInRange = date2 > rangeStart && date2 < hoveredDate;
            isRangeEnd = isSameDate(date2, hoveredDate);
          }
        }
        return import_react13.default.createElement(
          "td",
          { key: index5, className: css(calendar_month_default.calendarMonthDatesCell, isAdjacentMonth && calendar_month_default.modifiers.adjacentMonth, isToday && calendar_month_default.modifiers.current, (isSelected || isRangeStart) && calendar_month_default.modifiers.selected, !isValid && calendar_month_default.modifiers.disabled, (isInRange || isRangeStart || isRangeEnd) && calendar_month_default.modifiers.inRange, isRangeStart && calendar_month_default.modifiers.startRange, isRangeEnd && calendar_month_default.modifiers.endRange) },
          import_react13.default.createElement("button", Object.assign({ className: css(calendar_month_default.calendarMonthDate, isRangeEnd && calendar_month_default.modifiers.hover, !isValid && calendar_month_default.modifiers.disabled), type: "button", onClick: (event) => onChange(event, date2), onMouseOver: () => setHoveredDate(date2), tabIndex: isFocused ? 0 : -1, disabled: !isValid, "aria-label": cellAriaLabel ? cellAriaLabel(date2) : `${dayFormat(date2)} ${monthFormat(date2)} ${yearFormat(date2)}` }, isFocused && { ref: focusRef }), dayFormatted)
        );
      }))))
    )
  );
  if (inlineProps !== void 0) {
    const Component50 = inlineProps.component ? inlineProps.component : "article";
    return import_react13.default.createElement(
      Component50,
      Object.assign({}, inlineProps.ariaLabelledby && { "aria-labelledby": inlineProps.ariaLabelledby }),
      inlineProps.title,
      calendarToRender
    );
  }
  return calendarToRender;
};
CalendarMonth.displayName = "CalendarMonth";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/Card.js
var React84 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Card/card.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Card/card.css";
var card_default = {
  "button": "pf-v6-c-button",
  "card": "pf-v6-c-card",
  "cardActions": "pf-v6-c-card__actions",
  "cardBody": "pf-v6-c-card__body",
  "cardExpandableContent": "pf-v6-c-card__expandable-content",
  "cardFooter": "pf-v6-c-card__footer",
  "cardHeader": "pf-v6-c-card__header",
  "cardHeaderMain": "pf-v6-c-card__header-main",
  "cardHeaderToggle": "pf-v6-c-card__header-toggle",
  "cardHeaderToggleIcon": "pf-v6-c-card__header-toggle-icon",
  "cardSelectableActions": "pf-v6-c-card__selectable-actions",
  "cardTitle": "pf-v6-c-card__title",
  "cardTitleText": "pf-v6-c-card__title-text",
  "check": "pf-v6-c-check",
  "checkInput": "pf-v6-c-check__input",
  "checkLabel": "pf-v6-c-check__label",
  "dirRtl": "pf-v6-m-dir-rtl",
  "divider": "pf-v6-c-divider",
  "modifiers": {
    "selectable": "pf-m-selectable",
    "clickable": "pf-m-clickable",
    "selected": "pf-m-selected",
    "current": "pf-m-current",
    "disabled": "pf-m-disabled",
    "compact": "pf-m-compact",
    "displayLg": "pf-m-display-lg",
    "secondary": "pf-m-secondary",
    "plain": "pf-m-plain",
    "expanded": "pf-m-expanded",
    "fullHeight": "pf-m-full-height",
    "toggleRight": "pf-m-toggle-right",
    "noOffset": "pf-m-no-offset",
    "inline": "pf-m-inline",
    "noFill": "pf-m-no-fill"
  },
  "radio": "pf-v6-c-radio",
  "radioInput": "pf-v6-c-radio__input",
  "radioLabel": "pf-v6-c-radio__label"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/Card.js
var CardContext = React84.createContext({
  cardId: "",
  isExpanded: false,
  isClickable: false,
  isSelectable: false,
  isSelected: false,
  isClicked: false,
  isDisabled: false
});
var Card = (_a2) => {
  var { children: children2, id: id2 = "", className, component = "div", isCompact = false, isSelectable = false, isClickable = false, isDisabled = false, isSelected = false, isClicked = false, isExpanded = false, isLarge = false, isFullHeight = false, isPlain = false, variant = "default", ouiaId, ouiaSafe = true } = _a2, props = __rest(_a2, ["children", "id", "className", "component", "isCompact", "isSelectable", "isClickable", "isDisabled", "isSelected", "isClicked", "isExpanded", "isLarge", "isFullHeight", "isPlain", "variant", "ouiaId", "ouiaSafe"]);
  const Component50 = component;
  const ouiaProps = useOUIAProps(Card.displayName, ouiaId, ouiaSafe);
  if (isCompact && isLarge) {
    console.warn("Card: Cannot use isCompact with isLarge. Defaulting to isCompact");
    isLarge = false;
  }
  const getSelectableModifiers = () => {
    if (isSelectable && isClickable) {
      return css(card_default.modifiers.selectable, card_default.modifiers.clickable, (isSelected || isClicked) && card_default.modifiers.current);
    }
    if (isSelectable) {
      return css(card_default.modifiers.selectable, isSelected && card_default.modifiers.selected);
    }
    if (isClickable) {
      return css(card_default.modifiers.clickable, isClicked && card_default.modifiers.current);
    }
    return "";
  };
  return React84.createElement(
    CardContext.Provider,
    { value: {
      cardId: id2,
      isExpanded,
      isClickable,
      isSelectable,
      isSelected,
      isClicked,
      isDisabled
    } },
    React84.createElement(Component50, Object.assign({ id: id2, className: css(card_default.card, isCompact && card_default.modifiers.compact, isExpanded && card_default.modifiers.expanded, isLarge && card_default.modifiers.displayLg, isFullHeight && card_default.modifiers.fullHeight, isPlain && card_default.modifiers.plain, variant === "secondary" && card_default.modifiers.secondary, getSelectableModifiers(), isDisabled && card_default.modifiers.disabled, className) }, props, ouiaProps), children2)
  );
};
Card.displayName = "Card";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/CardBody.js
var React85 = __toESM(require_react());
var CardBody = (_a2) => {
  var { children: children2, className, component = "div", isFilled = true } = _a2, props = __rest(_a2, ["children", "className", "component", "isFilled"]);
  const Component50 = component;
  return React85.createElement(Component50, Object.assign({ className: css(card_default.cardBody, !isFilled && card_default.modifiers.noFill, className) }, props), children2);
};
CardBody.displayName = "CardBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/CardExpandableContent.js
var React86 = __toESM(require_react());
var CardExpandableContent = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React86.createElement(CardContext.Consumer, null, ({ isExpanded }) => isExpanded ? React86.createElement("div", Object.assign({ className: css(card_default.cardExpandableContent, className) }, props), children2) : null);
};
CardExpandableContent.displayName = "CardExpandableContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/CardFooter.js
var React87 = __toESM(require_react());
var CardFooter = (_a2) => {
  var { children: children2, className, component = "div" } = _a2, props = __rest(_a2, ["children", "className", "component"]);
  const Component50 = component;
  return React87.createElement(Component50, Object.assign({ className: css(card_default.cardFooter, className) }, props), children2);
};
CardFooter.displayName = "CardFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/CardTitle.js
var React88 = __toESM(require_react());
var CardTitle = (_a2) => {
  var { children: children2, className, component = "div" } = _a2, props = __rest(_a2, ["children", "className", "component"]);
  const { cardId } = React88.useContext(CardContext);
  const Component50 = component;
  const titleId = cardId ? `${cardId}-title` : "";
  return React88.createElement(
    "div",
    { className: css(card_default.cardTitle) },
    React88.createElement(Component50, Object.assign({ className: css(card_default.cardTitleText, className), id: titleId || void 0 }, props), children2)
  );
};
CardTitle.displayName = "CardTitle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/CardHeader.js
var React93 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/CardHeaderMain.js
var React89 = __toESM(require_react());
var CardHeaderMain = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React89.createElement("div", Object.assign({ className: css(card_default.cardHeaderMain, className) }, props), children2);
};
CardHeaderMain.displayName = "CardHeaderMain";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/CardActions.js
var React90 = __toESM(require_react());
var CardActions = (_a2) => {
  var { children: children2, className, hasNoOffset = false } = _a2, props = __rest(_a2, ["children", "className", "hasNoOffset"]);
  return React90.createElement("div", Object.assign({ className: css(card_default.cardActions, hasNoOffset && card_default.modifiers.noOffset, className) }, props), children2);
};
CardActions.displayName = "CardActions";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/CardSelectableActions.js
var React91 = __toESM(require_react());
var CardSelectableActions = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React91.createElement("div", Object.assign({ className: css(card_default.cardSelectableActions, className) }, props), children2);
};
CardSelectableActions.displayName = "CardSelectableActions";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Radio/Radio.js
var React92 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Radio/radio.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Radio/radio.css";
var radio_default = {
  "modifiers": {
    "standalone": "pf-m-standalone",
    "disabled": "pf-m-disabled"
  },
  "radio": "pf-v6-c-radio",
  "radioBody": "pf-v6-c-radio__body",
  "radioDescription": "pf-v6-c-radio__description",
  "radioInput": "pf-v6-c-radio__input",
  "radioLabel": "pf-v6-c-radio__label"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Radio/Radio.js
var Radio = class _Radio extends React92.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event, event.currentTarget.checked);
    };
    if (!props.label && !props["aria-label"]) {
      console.error("Radio:", "Radio requires an aria-label to be specified");
    }
    this.state = {
      ouiaStateId: getDefaultOUIAId(_Radio.displayName)
    };
  }
  render() {
    const _a2 = this.props, {
      "aria-label": ariaLabel,
      checked,
      className,
      inputClassName,
      defaultChecked,
      isLabelWrapped,
      labelPosition = "end",
      isChecked,
      isDisabled,
      isValid,
      label,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onChange,
      description,
      body,
      ouiaId,
      ouiaSafe = true,
      component
    } = _a2, props = __rest(_a2, ["aria-label", "checked", "className", "inputClassName", "defaultChecked", "isLabelWrapped", "labelPosition", "isChecked", "isDisabled", "isValid", "label", "onChange", "description", "body", "ouiaId", "ouiaSafe", "component"]);
    if (!props.id) {
      console.error("Radio:", "id is required to make input accessible");
    }
    const inputRendered = React92.createElement("input", Object.assign({}, props, { className: css(radio_default.radioInput, inputClassName), type: "radio", onChange: this.handleChange, "aria-invalid": !isValid, disabled: isDisabled, checked: checked || isChecked }, checked === void 0 && { defaultChecked }, !label && { "aria-label": ariaLabel }, getOUIAProps(_Radio.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe)));
    const wrapWithLabel = isLabelWrapped && !component || component === "label";
    const Label2 = wrapWithLabel ? "span" : "label";
    const labelRendered = label ? React92.createElement(Label2, { className: css(radio_default.radioLabel, isDisabled && radio_default.modifiers.disabled), htmlFor: !wrapWithLabel ? props.id : void 0 }, label) : null;
    const Component50 = component !== null && component !== void 0 ? component : wrapWithLabel ? "label" : "div";
    return React92.createElement(
      Component50,
      { className: css(radio_default.radio, !label && radio_default.modifiers.standalone, className), htmlFor: wrapWithLabel ? props.id : void 0 },
      labelPosition === "start" ? React92.createElement(
        React92.Fragment,
        null,
        labelRendered,
        inputRendered
      ) : React92.createElement(
        React92.Fragment,
        null,
        inputRendered,
        labelRendered
      ),
      description && React92.createElement("span", { className: css(radio_default.radioDescription) }, description),
      body && React92.createElement("span", { className: css(radio_default.radioBody) }, body)
    );
  }
};
Radio.displayName = "Radio";
Radio.defaultProps = {
  className: "",
  isDisabled: false,
  isValid: true,
  onChange: () => {
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Card/CardHeader.js
var CardHeader = (_a2) => {
  var { children: children2, className, actions, selectableActions, id: id2, onExpand, toggleButtonProps, isToggleRightAligned } = _a2, props = __rest(_a2, ["children", "className", "actions", "selectableActions", "id", "onExpand", "toggleButtonProps", "isToggleRightAligned"]);
  return React93.createElement(CardContext.Consumer, null, ({ cardId, isClickable, isSelectable, isSelected, isClicked, isDisabled: isCardDisabled }) => {
    const cardHeaderToggle = React93.createElement(
      "div",
      { className: css(card_default.cardHeaderToggle) },
      React93.createElement(
        Button,
        Object.assign({ variant: "plain", type: "button", onClick: (evt) => {
          onExpand(evt, cardId);
        } }, toggleButtonProps),
        React93.createElement(
          "span",
          { className: css(card_default.cardHeaderToggleIcon) },
          React93.createElement(angle_right_icon_default, { "aria-hidden": "true" })
        )
      )
    );
    const isClickableOrSelectableOnly = isClickable && !isSelectable || isSelectable && !isClickable;
    if ((actions === null || actions === void 0 ? void 0 : actions.actions) && isClickableOrSelectableOnly) {
      console.warn(`${isClickable ? "Clickable" : "Selectable"} only cards should not contain any other actions. If you wish to include additional actions, use a clickable and selectable card.`);
    }
    const handleActionClick = (event) => {
      if (selectableActions === null || selectableActions === void 0 ? void 0 : selectableActions.onClickAction) {
        selectableActions.onClickAction(event);
      } else if (selectableActions === null || selectableActions === void 0 ? void 0 : selectableActions.to) {
        window.open(selectableActions.to, selectableActions.isExternalLink ? "_blank" : "_self");
      }
    };
    const getClickableSelectableProps = () => {
      var _a3;
      const baseProps = {
        className: "pf-m-standalone",
        inputClassName: isClickable && !isSelectable && "pf-v6-screen-reader",
        label: React93.createElement(React93.Fragment, null),
        "aria-label": selectableActions.selectableActionAriaLabel,
        "aria-labelledby": selectableActions.selectableActionAriaLabelledby,
        id: selectableActions.selectableActionId,
        name: selectableActions.name,
        isDisabled: isCardDisabled
      };
      const isSelectableInputChecked = (_a3 = selectableActions.isChecked) !== null && _a3 !== void 0 ? _a3 : isSelected;
      if (isClickable && !isSelectable) {
        return Object.assign(Object.assign({}, baseProps), { onClick: handleActionClick, isChecked: isClicked });
      }
      if (isSelectable) {
        return Object.assign(Object.assign({}, baseProps), { onChange: selectableActions.onChange, isChecked: isSelectableInputChecked });
      }
      return baseProps;
    };
    return React93.createElement(
      "div",
      Object.assign({ className: css(card_default.cardHeader, isToggleRightAligned && card_default.modifiers.toggleRight, className), id: id2 }, props),
      onExpand && !isToggleRightAligned && cardHeaderToggle,
      (actions || selectableActions && (isClickable || isSelectable)) && React93.createElement(
        CardActions,
        { className: actions === null || actions === void 0 ? void 0 : actions.className, hasNoOffset: (actions === null || actions === void 0 ? void 0 : actions.hasNoOffset) || (selectableActions === null || selectableActions === void 0 ? void 0 : selectableActions.hasNoOffset) },
        actions === null || actions === void 0 ? void 0 : actions.actions,
        selectableActions && (isClickable || isSelectable) && React93.createElement(CardSelectableActions, { className: selectableActions === null || selectableActions === void 0 ? void 0 : selectableActions.className }, (selectableActions === null || selectableActions === void 0 ? void 0 : selectableActions.variant) === "single" || isClickable && !isSelectable ? React93.createElement(Radio, Object.assign({}, getClickableSelectableProps())) : React93.createElement(Checkbox, Object.assign({}, getClickableSelectableProps())))
      ),
      children2 && React93.createElement(CardHeaderMain, null, children2),
      onExpand && isToggleRightAligned && cardHeaderToggle
    );
  });
};
CardHeader.displayName = "CardHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ClipboardCopy/ClipboardCopy.js
var React97 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ClipboardCopy/clipboard-copy.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ClipboardCopy/clipboard-copy.css";
var clipboard_copy_default = {
  "button": "pf-v6-c-button",
  "clipboardCopy": "pf-v6-c-clipboard-copy",
  "clipboardCopyActions": "pf-v6-c-clipboard-copy__actions",
  "clipboardCopyActionsItem": "pf-v6-c-clipboard-copy__actions-item",
  "clipboardCopyExpandableContent": "pf-v6-c-clipboard-copy__expandable-content",
  "clipboardCopyGroup": "pf-v6-c-clipboard-copy__group",
  "clipboardCopyText": "pf-v6-c-clipboard-copy__text",
  "clipboardCopyToggleIcon": "pf-v6-c-clipboard-copy__toggle-icon",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "expanded": "pf-m-expanded",
    "inline": "pf-m-inline",
    "block": "pf-m-block",
    "code": "pf-m-code",
    "plain": "pf-m-plain"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ClipboardCopy/ClipboardCopyButton.js
var React94 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/copy-icon.js
var CopyIconConfig = {
  name: "CopyIcon",
  height: 512,
  width: 448,
  svgPath: "M320 448v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24V120c0-13.255 10.745-24 24-24h72v296c0 30.879 25.121 56 56 56h168zm0-344V0H152c-13.255 0-24 10.745-24 24v368c0 13.255 10.745 24 24 24h272c13.255 0 24-10.745 24-24V128H344c-13.2 0-24-10.8-24-24zm120.971-31.029L375.029 7.029A24 24 0 0 0 358.059 0H352v96h96v-6.059a24 24 0 0 0-7.029-16.97z",
  yOffset: 0,
  xOffset: 0
};
var CopyIcon = createIcon(CopyIconConfig);
var copy_icon_default = CopyIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ClipboardCopy/ClipboardCopyButton.js
var ClipboardCopyButton = (_a2) => {
  var { onClick, exitDelay = 0, entryDelay = 300, maxWidth = "100px", position = "top", "aria-label": ariaLabel = "Copyable input", id: id2, textId, children: children2, variant = "control", onTooltipHidden = () => {
  }, className } = _a2, props = __rest(_a2, ["onClick", "exitDelay", "entryDelay", "maxWidth", "position", "aria-label", "id", "textId", "children", "variant", "onTooltipHidden", "className"]);
  const triggerRef = React94.createRef();
  return React94.createElement(
    Tooltip,
    { trigger: "mouseenter focus click", triggerRef, exitDelay, entryDelay, maxWidth, position, "aria-live": "polite", aria: "none", content: React94.createElement("div", null, children2), onTooltipHidden },
    React94.createElement(
      Button,
      Object.assign({ type: "button", variant, onClick, "aria-label": ariaLabel, className, id: id2, "aria-labelledby": `${id2} ${textId}` }, props, { ref: triggerRef }),
      React94.createElement(copy_icon_default, null)
    )
  );
};
ClipboardCopyButton.displayName = "ClipboardCopyButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ClipboardCopy/ClipboardCopyToggle.js
var React95 = __toESM(require_react());
var ClipboardCopyToggle = (_a2) => {
  var { onClick, id: id2, textId, contentId, isExpanded = false } = _a2, props = __rest(_a2, ["onClick", "id", "textId", "contentId", "isExpanded"]);
  return React95.createElement(
    Button,
    Object.assign({ type: "button", variant: "control", onClick, id: id2, "aria-labelledby": `${id2} ${textId}`, "aria-controls": contentId, "aria-expanded": isExpanded }, props),
    React95.createElement(
      "div",
      { className: css(clipboard_copy_default.clipboardCopyToggleIcon) },
      React95.createElement(angle_right_icon_default, { "aria-hidden": "true" })
    )
  );
};
ClipboardCopyToggle.displayName = "ClipboardCopyToggle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ClipboardCopy/ClipboardCopyExpanded.js
var React96 = __toESM(require_react());
var ClipboardCopyExpanded = class extends React96.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const _a2 = this.props, { className, children: children2, onChange, isReadOnly, isCode } = _a2, props = __rest(_a2, ["className", "children", "onChange", "isReadOnly", "isCode"]);
    return React96.createElement("div", Object.assign({ suppressContentEditableWarning: true, className: css(clipboard_copy_default.clipboardCopyExpandableContent, className), onInput: (e) => onChange(e, e.target.innerText), contentEditable: !isReadOnly }, props), isCode ? React96.createElement("pre", { dir: "ltr" }, children2) : children2);
  }
};
ClipboardCopyExpanded.displayName = "ClipboardCopyExpanded";
ClipboardCopyExpanded.defaultProps = {
  onChange: () => void 0,
  className: "",
  isReadOnly: false,
  isCode: false
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ClipboardCopy/ClipboardCopy.js
var clipboardCopyFunc = (_event, text) => {
  try {
    navigator.clipboard.writeText(text.toString());
  } catch (error) {
    console.warn("Clipboard API not found, this copy function will not work. This is likely because you're using an", "unsupported browser or you're not using HTTPS. \n\nIf you're a developer building an application which needs", "to support copying to the clipboard without the clipboard API, you'll have to create your own copy", "function and pass it to the ClipboardCopy component as the onCopy prop. For more information see", "https://developer.mozilla.org/en-US/docs/Web/API/Navigator/clipboard");
    console.error(error);
  }
};
var ClipboardCopyVariant;
(function(ClipboardCopyVariant2) {
  ClipboardCopyVariant2["inline"] = "inline";
  ClipboardCopyVariant2["expansion"] = "expansion";
  ClipboardCopyVariant2["inlineCompact"] = "inline-compact";
})(ClipboardCopyVariant || (ClipboardCopyVariant = {}));
var ClipboardCopy = class _ClipboardCopy extends React97.Component {
  constructor(props) {
    super(props);
    this.timer = null;
    this.componentDidUpdate = (prevProps, prevState) => {
      if (prevProps.children !== this.props.children) {
        const newText = this.props.children;
        this.setState({ text: newText, textWhenExpanded: newText });
      }
    };
    this.componentWillUnmount = () => {
      if (this.timer) {
        window.clearTimeout(this.timer);
      }
    };
    this.expandContent = (_event) => {
      this.setState((prevState) => ({
        expanded: !prevState.expanded
      }));
    };
    this.updateText = (event, text2) => {
      this.setState({ text: text2 });
      this.props.onChange(event, text2);
    };
    this.updateTextWhenExpanded = (event, text2) => {
      this.setState({ textWhenExpanded: text2 });
      this.props.onChange(event, text2);
    };
    this.render = () => {
      const _a2 = this.props, {
        /* eslint-disable @typescript-eslint/no-unused-vars */
        isExpanded,
        onChange,
        // Don't pass to <div>
        /* eslint-enable @typescript-eslint/no-unused-vars */
        isReadOnly,
        isCode,
        isBlock,
        exitDelay,
        maxWidth,
        entryDelay,
        onCopy,
        hoverTip,
        clickTip,
        textAriaLabel,
        toggleAriaLabel,
        variant,
        position,
        className,
        additionalActions,
        ouiaId,
        ouiaSafe
      } = _a2, divProps = __rest(_a2, ["isExpanded", "onChange", "isReadOnly", "isCode", "isBlock", "exitDelay", "maxWidth", "entryDelay", "onCopy", "hoverTip", "clickTip", "textAriaLabel", "toggleAriaLabel", "variant", "position", "className", "additionalActions", "ouiaId", "ouiaSafe"]);
      const textIdPrefix = "text-input-";
      const toggleIdPrefix = "toggle-";
      const contentIdPrefix = "content-";
      return React97.createElement(
        "div",
        Object.assign({ className: css(clipboard_copy_default.clipboardCopy, variant === "inline-compact" && clipboard_copy_default.modifiers.inline, isBlock && clipboard_copy_default.modifiers.block, this.state.expanded && clipboard_copy_default.modifiers.expanded, className) }, divProps, getOUIAProps(_ClipboardCopy.displayName, ouiaId, ouiaSafe)),
        variant === "inline-compact" && React97.createElement(GenerateId, { prefix: "" }, (id2) => React97.createElement(
          React97.Fragment,
          null,
          !isCode && React97.createElement("span", { className: css(clipboard_copy_default.clipboardCopyText), id: `${textIdPrefix}${id2}` }, this.state.text),
          isCode && React97.createElement("code", { className: css(clipboard_copy_default.clipboardCopyText, clipboard_copy_default.modifiers.code), id: `${textIdPrefix}${id2}` }, this.state.text),
          React97.createElement(
            "span",
            { className: css(clipboard_copy_default.clipboardCopyActions) },
            React97.createElement(
              "span",
              { className: css(clipboard_copy_default.clipboardCopyActionsItem) },
              React97.createElement(ClipboardCopyButton, { variant: "plain", exitDelay, entryDelay, maxWidth, position, id: `copy-button-${id2}`, textId: `text-input-${id2}`, "aria-label": hoverTip, onClick: (event) => {
                onCopy(event, this.state.text);
                this.setState({ copied: true });
              }, onTooltipHidden: () => this.setState({ copied: false }) }, this.state.copied ? clickTip : hoverTip)
            ),
            additionalActions && additionalActions
          )
        )),
        variant !== "inline-compact" && React97.createElement(GenerateId, { prefix: "" }, (id2) => React97.createElement(
          React97.Fragment,
          null,
          React97.createElement(
            "div",
            { className: css(clipboard_copy_default.clipboardCopyGroup) },
            variant === "expansion" && React97.createElement(ClipboardCopyToggle, { isExpanded: this.state.expanded, onClick: (_event) => {
              this.expandContent(_event);
              if (this.state.expanded) {
                this.setState({ text: this.state.textWhenExpanded });
              } else {
                this.setState({ textWhenExpanded: this.state.text });
              }
            }, id: `${toggleIdPrefix}${id2}`, textId: `${textIdPrefix}${id2}`, contentId: `${contentIdPrefix}${id2}`, "aria-label": toggleAriaLabel }),
            React97.createElement(TextInput, Object.assign({ readOnlyVariant: isReadOnly || this.state.expanded ? "default" : void 0, onChange: this.updateText, value: this.state.expanded ? this.state.textWhenExpanded : this.state.text, id: `text-input-${id2}`, "aria-label": textAriaLabel }, isCode && { dir: "ltr" })),
            React97.createElement(ClipboardCopyButton, { exitDelay, entryDelay, maxWidth, position, id: `copy-button-${id2}`, textId: `text-input-${id2}`, "aria-label": hoverTip, onClick: (event) => {
              onCopy(event, this.state.expanded ? this.state.textWhenExpanded : this.state.text);
              this.setState({ copied: true });
            }, onTooltipHidden: () => this.setState({ copied: false }) }, this.state.copied ? clickTip : hoverTip)
          ),
          this.state.expanded && React97.createElement(ClipboardCopyExpanded, { isReadOnly, isCode, id: `content-${id2}`, onChange: this.updateTextWhenExpanded }, this.state.text)
        ))
      );
    };
    const text = Array.isArray(this.props.children) ? this.props.children.join("") : this.props.children;
    this.state = {
      text,
      expanded: this.props.isExpanded,
      copied: false,
      textWhenExpanded: text
    };
  }
};
ClipboardCopy.displayName = "ClipboardCopy";
ClipboardCopy.defaultProps = {
  hoverTip: "Copy to clipboard",
  clickTip: "Successfully copied to clipboard!",
  isReadOnly: false,
  isExpanded: false,
  isCode: false,
  variant: "inline",
  position: TooltipPosition.top,
  maxWidth: "150px",
  exitDelay: 1500,
  entryDelay: 300,
  onCopy: clipboardCopyFunc,
  onChange: () => void 0,
  textAriaLabel: "Copyable input",
  toggleAriaLabel: "Show content",
  additionalActions: null,
  ouiaSafe: true
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ClipboardCopy/ClipboardCopyAction.js
var React98 = __toESM(require_react());
var ClipboardCopyAction = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React98.createElement("span", Object.assign({ className: css(clipboard_copy_default.clipboardCopyActionsItem, className) }, props), children2);
};
ClipboardCopyAction.displayName = "ClipboardCopyAction";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/CodeBlock/CodeBlock.js
var React99 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/CodeBlock/code-block.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/CodeBlock/code-block.css";
var code_block_default = {
  "codeBlock": "pf-v6-c-code-block",
  "codeBlockActions": "pf-v6-c-code-block__actions",
  "codeBlockCode": "pf-v6-c-code-block__code",
  "codeBlockContent": "pf-v6-c-code-block__content",
  "codeBlockHeader": "pf-v6-c-code-block__header",
  "codeBlockPre": "pf-v6-c-code-block__pre"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/CodeBlock/CodeBlock.js
var CodeBlock = (_a2) => {
  var { children: children2 = null, className, actions = null } = _a2, props = __rest(_a2, ["children", "className", "actions"]);
  return React99.createElement(
    "div",
    Object.assign({ className: css(code_block_default.codeBlock, className) }, props),
    actions && React99.createElement(
      "div",
      { className: css(code_block_default.codeBlockHeader) },
      React99.createElement("div", { className: css(code_block_default.codeBlockActions) }, actions)
    ),
    React99.createElement("div", { className: css(code_block_default.codeBlockContent) }, children2)
  );
};
CodeBlock.displayName = "CodeBlock";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/CodeBlock/CodeBlockCode.js
var React100 = __toESM(require_react());
var CodeBlockCode = (_a2) => {
  var { children: children2 = null, className, codeClassName } = _a2, props = __rest(_a2, ["children", "className", "codeClassName"]);
  return React100.createElement(
    "pre",
    Object.assign({ className: css(code_block_default.codeBlockPre, className) }, props),
    React100.createElement("code", { className: css(code_block_default.codeBlockCode, codeClassName) }, children2)
  );
};
CodeBlockCode.displayName = "CodeBlockCode";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/CodeBlock/CodeBlockAction.js
var React101 = __toESM(require_react());
var CodeBlockAction = (_a2) => {
  var { children: children2 = null, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React101.createElement("div", Object.assign({ className: css(`${code_block_default.codeBlockActions}-item`, className) }, props), children2);
};
CodeBlockAction.displayName = "CodeBlockAction";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataList.js
var React102 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/DataList/data-list.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/DataList/data-list.css";
var data_list_default = {
  "dataList": "pf-v6-c-data-list",
  "dataListAction": "pf-v6-c-data-list__action",
  "dataListCell": "pf-v6-c-data-list__cell",
  "dataListCheck": "pf-v6-c-data-list__check",
  "dataListExpandableContent": "pf-v6-c-data-list__expandable-content",
  "dataListExpandableContentBody": "pf-v6-c-data-list__expandable-content-body",
  "dataListItem": "pf-v6-c-data-list__item",
  "dataListItemAction": "pf-v6-c-data-list__item-action",
  "dataListItemContent": "pf-v6-c-data-list__item-content",
  "dataListItemControl": "pf-v6-c-data-list__item-control",
  "dataListItemDraggableButton": "pf-v6-c-data-list__item-draggable-button",
  "dataListItemDraggableIcon": "pf-v6-c-data-list__item-draggable-icon",
  "dataListItemRow": "pf-v6-c-data-list__item-row",
  "dataListText": "pf-v6-c-data-list__text",
  "dataListToggle": "pf-v6-c-data-list__toggle",
  "dataListToggleIcon": "pf-v6-c-data-list__toggle-icon",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "icon": "pf-m-icon",
    "alignRight": "pf-m-align-right",
    "noFill": "pf-m-no-fill",
    "flex_2": "pf-m-flex-2",
    "flex_3": "pf-m-flex-3",
    "flex_4": "pf-m-flex-4",
    "flex_5": "pf-m-flex-5",
    "gridNone": "pf-m-grid-none",
    "gridSm": "pf-m-grid-sm",
    "gridMd": "pf-m-grid-md",
    "gridLg": "pf-m-grid-lg",
    "gridXl": "pf-m-grid-xl",
    "grid_2xl": "pf-m-grid-2xl",
    "compact": "pf-m-compact",
    "dragOver": "pf-m-drag-over",
    "truncate": "pf-m-truncate",
    "breakWord": "pf-m-break-word",
    "nowrap": "pf-m-nowrap",
    "clickable": "pf-m-clickable",
    "selected": "pf-m-selected",
    "ghostRow": "pf-m-ghost-row",
    "expanded": "pf-m-expanded",
    "disabled": "pf-m-disabled",
    "hidden": "pf-m-hidden",
    "hiddenOnSm": "pf-m-hidden-on-sm",
    "visibleOnSm": "pf-m-visible-on-sm",
    "hiddenOnMd": "pf-m-hidden-on-md",
    "visibleOnMd": "pf-m-visible-on-md",
    "hiddenOnLg": "pf-m-hidden-on-lg",
    "visibleOnLg": "pf-m-visible-on-lg",
    "hiddenOnXl": "pf-m-hidden-on-xl",
    "visibleOnXl": "pf-m-visible-on-xl",
    "hiddenOn_2xl": "pf-m-hidden-on-2xl",
    "visibleOn_2xl": "pf-m-visible-on-2xl",
    "noPadding": "pf-m-no-padding"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataList.js
var gridBreakpointClasses = {
  none: data_list_default.modifiers.gridNone,
  always: "pf-m-grid",
  // Placeholder per https://github.com/patternfly/patternfly-react/issues/4965#issuecomment-704984236
  sm: data_list_default.modifiers.gridSm,
  md: data_list_default.modifiers.gridMd,
  lg: data_list_default.modifiers.gridLg,
  xl: data_list_default.modifiers.gridXl,
  "2xl": data_list_default.modifiers.grid_2xl
};
var DataListWrapModifier;
(function(DataListWrapModifier2) {
  DataListWrapModifier2["nowrap"] = "nowrap";
  DataListWrapModifier2["truncate"] = "truncate";
  DataListWrapModifier2["breakWord"] = "breakWord";
})(DataListWrapModifier || (DataListWrapModifier = {}));
var DataListContext = React102.createContext({
  isSelectable: false
});
var DataList = class extends React102.Component {
  constructor(props) {
    super(props);
    this.ref = React102.createRef();
    this.getIndex = (id2) => Array.from(this.ref.current.children).findIndex((item) => item.id === id2);
  }
  render() {
    const _a2 = this.props, { className, children: children2, "aria-label": ariaLabel, onSelectDataListItem, selectedDataListItemId, isCompact, wrapModifier, gridBreakpoint, onSelectableRowChange } = _a2, props = __rest(_a2, ["className", "children", "aria-label", "onSelectDataListItem", "selectedDataListItemId", "isCompact", "wrapModifier", "gridBreakpoint", "onSelectableRowChange"]);
    const isSelectable = onSelectDataListItem !== void 0;
    const updateSelectedDataListItem = (event, id2) => {
      onSelectDataListItem(event, id2);
    };
    return React102.createElement(
      DataListContext.Provider,
      { value: {
        isSelectable,
        selectedDataListItemId,
        updateSelectedDataListItem,
        onSelectableRowChange
      } },
      React102.createElement("ul", Object.assign({ className: css(data_list_default.dataList, isCompact && data_list_default.modifiers.compact, gridBreakpointClasses[gridBreakpoint], wrapModifier && data_list_default.modifiers[wrapModifier], className), style: props.style, role: "list", "aria-label": ariaLabel }, props, { ref: this.ref }), children2)
    );
  }
};
DataList.displayName = "DataList";
DataList.defaultProps = {
  children: null,
  className: "",
  selectedDataListItemId: "",
  isCompact: false,
  gridBreakpoint: "md",
  wrapModifier: null
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListAction.js
var React103 = __toESM(require_react());
var DataListAction = (_a2) => {
  var {
    children: children2,
    className,
    visibility,
    /* eslint-disable @typescript-eslint/no-unused-vars */
    id: id2,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    /* eslint-disable @typescript-eslint/no-unused-vars */
    isPlainButtonAction
  } = _a2, props = __rest(_a2, ["children", "className", "visibility", "id", "aria-label", "aria-labelledby", "isPlainButtonAction"]);
  return React103.createElement("div", Object.assign({ className: css(data_list_default.dataListItemAction, formatBreakpointMods(visibility, data_list_default), className) }, props), isPlainButtonAction ? React103.createElement("div", { className: css(data_list_default.dataListAction) }, children2) : children2);
};
DataListAction.displayName = "DataListAction";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListCell.js
var React104 = __toESM(require_react());
var DataListCell = (_a2) => {
  var { children: children2 = null, className = "", width = 1, isFilled = true, alignRight = false, isIcon = false, wrapModifier = null } = _a2, props = __rest(_a2, ["children", "className", "width", "isFilled", "alignRight", "isIcon", "wrapModifier"]);
  return React104.createElement("div", Object.assign({ className: css(data_list_default.dataListCell, width > 1 && data_list_default.modifiers[`flex_${width}`], !isFilled && data_list_default.modifiers.noFill, alignRight && data_list_default.modifiers.alignRight, isIcon && data_list_default.modifiers.icon, className, wrapModifier && data_list_default.modifiers[wrapModifier]) }, props), children2);
};
DataListCell.displayName = "DataListCell";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListCheck.js
var React105 = __toESM(require_react());
var DataListCheck = (_a2) => {
  var {
    className = "",
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onChange = (event, checked2) => {
    },
    isValid = true,
    isDisabled = false,
    isChecked = false,
    checked = false,
    defaultChecked,
    otherControls = false
  } = _a2, props = __rest(_a2, ["className", "onChange", "isValid", "isDisabled", "isChecked", "checked", "defaultChecked", "otherControls"]);
  const check = React105.createElement(
    "div",
    { className: css(data_list_default.dataListCheck) },
    React105.createElement("input", Object.assign({}, props, { type: "checkbox", onChange: (event) => onChange(event, event.currentTarget.checked), "aria-invalid": !isValid, disabled: isDisabled }, [true, false].includes(defaultChecked) && { defaultChecked }, ![true, false].includes(defaultChecked) && { checked: isChecked || checked }))
  );
  return React105.createElement(
    React105.Fragment,
    null,
    !otherControls && React105.createElement("div", { className: css(data_list_default.dataListItemControl, className) }, check),
    otherControls && check
  );
};
DataListCheck.displayName = "DataListCheck";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListControl.js
var React106 = __toESM(require_react());
var DataListControl = (_a2) => {
  var { children: children2, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React106.createElement("div", Object.assign({ className: css(data_list_default.dataListItemControl, className) }, props), children2);
};
DataListControl.displayName = "DataListControl";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListDragButton.js
var React107 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/grip-vertical-icon.js
var GripVerticalIconConfig = {
  name: "GripVerticalIcon",
  height: 512,
  width: 320,
  svgPath: "M96 32H32C14.33 32 0 46.33 0 64v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32V64c0-17.67-14.33-32-32-32zm0 160H32c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32zm0 160H32c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32zM288 32h-64c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32V64c0-17.67-14.33-32-32-32zm0 160h-64c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32zm0 160h-64c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32z",
  yOffset: 0,
  xOffset: 0
};
var GripVerticalIcon = createIcon(GripVerticalIconConfig);
var grip_vertical_icon_default = GripVerticalIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListDragButton.js
var DataListDragButton = (_a2) => {
  var { className = "", isDisabled = false } = _a2, props = __rest(_a2, ["className", "isDisabled"]);
  return React107.createElement(
    "button",
    Object.assign({ className: css(data_list_default.dataListItemDraggableButton, isDisabled && data_list_default.modifiers.disabled, className), type: "button", disabled: isDisabled }, props),
    React107.createElement(
      "span",
      { className: css(data_list_default.dataListItemDraggableIcon) },
      React107.createElement(grip_vertical_icon_default, null)
    )
  );
};
DataListDragButton.displayName = "DataListDragButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListItem.js
var React108 = __toESM(require_react());
var DataListItem = class extends React108.Component {
  render() {
    const _a2 = this.props, { children: children2, isExpanded, className, id: id2, "aria-labelledby": ariaLabelledBy, selectableInputAriaLabel } = _a2, props = __rest(_a2, ["children", "isExpanded", "className", "id", "aria-labelledby", "selectableInputAriaLabel"]);
    return React108.createElement(DataListContext.Consumer, null, ({ isSelectable, selectedDataListItemId, updateSelectedDataListItem, onSelectableRowChange }) => {
      const selectDataListItem = (event) => {
        let target = event.target;
        while (event.currentTarget !== target) {
          if ("onclick" in target && target.onclick || target.parentNode.classList.contains(data_list_default.dataListItemAction) || target.parentNode.classList.contains(data_list_default.dataListItemControl)) {
            return;
          } else {
            target = target.parentNode;
          }
        }
        updateSelectedDataListItem(event, id2);
      };
      const onKeyDown = (event) => {
        if ([KeyTypes.Enter, KeyTypes.Space].includes(event.key)) {
          event.preventDefault();
          updateSelectedDataListItem(event, id2);
        }
      };
      const isSelected = selectedDataListItemId === id2;
      const selectableInputAriaProps = selectableInputAriaLabel ? { "aria-label": selectableInputAriaLabel } : { "aria-labelledby": ariaLabelledBy };
      return React108.createElement(
        "li",
        Object.assign({ id: id2, className: css(data_list_default.dataListItem, isExpanded && data_list_default.modifiers.expanded, isSelectable && data_list_default.modifiers.clickable, selectedDataListItemId && isSelected && data_list_default.modifiers.selected, className), "aria-labelledby": ariaLabelledBy }, isSelectable && { tabIndex: 0, onClick: selectDataListItem, onKeyDown }, isSelectable && isSelected && { "aria-selected": true }, props),
        onSelectableRowChange && React108.createElement("input", Object.assign({ className: "pf-v6-screen-reader", type: "radio", checked: isSelected, onChange: (event) => onSelectableRowChange(event, id2), tabIndex: -1 }, selectableInputAriaProps)),
        React108.Children.map(children2, (child) => React108.isValidElement(child) && React108.cloneElement(child, {
          rowid: ariaLabelledBy
        }))
      );
    });
  }
};
DataListItem.displayName = "DataListItem";
DataListItem.defaultProps = {
  isExpanded: false,
  className: "",
  id: "",
  children: null,
  "aria-labelledby": ""
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListItemCells.js
var React109 = __toESM(require_react());
var DataListItemCells = (_a2) => {
  var {
    className = "",
    dataListCells,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rowid = ""
  } = _a2, props = __rest(_a2, ["className", "dataListCells", "rowid"]);
  return React109.createElement("div", Object.assign({ className: css(data_list_default.dataListItemContent, className) }, props), dataListCells);
};
DataListItemCells.displayName = "DataListItemCells";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListItemRow.js
var React110 = __toESM(require_react());
var DataListItemRow = (_a2) => {
  var { children: children2, className = "", rowid = "", wrapModifier = null } = _a2, props = __rest(_a2, ["children", "className", "rowid", "wrapModifier"]);
  return React110.createElement("div", Object.assign({ className: css(data_list_default.dataListItemRow, className, wrapModifier && data_list_default.modifiers[wrapModifier]) }, props), React110.Children.map(children2, (child) => React110.isValidElement(child) && React110.cloneElement(child, {
    rowid
  })));
};
DataListItemRow.displayName = "DataListItemRow";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListToggle.js
var React111 = __toESM(require_react());
var DataListToggle = (_a2) => {
  var { className = "", isExpanded = false, "aria-controls": ariaControls = "", "aria-label": ariaLabel = "Details", rowid = "", id: id2, buttonProps } = _a2, props = __rest(_a2, ["className", "isExpanded", "aria-controls", "aria-label", "rowid", "id", "buttonProps"]);
  return React111.createElement(
    "div",
    Object.assign({ className: css(data_list_default.dataListItemControl, className) }, props),
    React111.createElement(
      "div",
      { className: css(data_list_default.dataListToggle) },
      React111.createElement(
        Button,
        Object.assign({ id: id2, variant: ButtonVariant.plain, "aria-controls": ariaControls !== "" && ariaControls, "aria-label": ariaLabel, "aria-labelledby": ariaLabel !== "Details" ? null : `${rowid} ${id2}`, "aria-expanded": isExpanded }, buttonProps),
        React111.createElement(
          "div",
          { className: css(data_list_default.dataListToggleIcon) },
          React111.createElement(angle_right_icon_default, null)
        )
      )
    )
  );
};
DataListToggle.displayName = "DataListToggle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListContent.js
var React112 = __toESM(require_react());
var DataListContent = (_a2) => {
  var {
    className = "",
    children: children2 = null,
    id: id2 = "",
    isHidden = false,
    "aria-label": ariaLabel,
    hasNoPadding = false,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rowid = ""
  } = _a2, props = __rest(_a2, ["className", "children", "id", "isHidden", "aria-label", "hasNoPadding", "rowid"]);
  return React112.createElement(
    "section",
    Object.assign({ id: id2, className: css(data_list_default.dataListExpandableContent, className), hidden: isHidden, "aria-label": ariaLabel }, props),
    React112.createElement("div", { className: css(data_list_default.dataListExpandableContentBody, hasNoPadding && data_list_default.modifiers.noPadding) }, children2)
  );
};
DataListContent.displayName = "DataListContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DataList/DataListText.js
var React113 = __toESM(require_react());
var DataListText = (_a2) => {
  var { children: children2 = null, className = "", component = "span", wrapModifier = null, tooltip: tooltipProp = "", onMouseEnter: onMouseEnterProp = () => {
  } } = _a2, props = __rest(_a2, ["children", "className", "component", "wrapModifier", "tooltip", "onMouseEnter"]);
  const Component50 = component;
  const [tooltip, setTooltip] = React113.useState("");
  const onMouseEnter = (event) => {
    if (event.target.offsetWidth < event.target.scrollWidth) {
      setTooltip(tooltipProp || event.target.innerHTML);
    } else {
      setTooltip("");
    }
    onMouseEnterProp(event);
  };
  const text = React113.createElement(Component50, Object.assign({ onMouseEnter, className: css(className, wrapModifier && data_list_default.modifiers[wrapModifier], data_list_default.dataListText) }, props), children2);
  return tooltip !== "" ? React113.createElement(Tooltip, { content: tooltip, isVisible: true }, text) : text;
};
DataListText.displayName = "DataListText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DatePicker/DatePicker.js
var React126 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/DatePicker/date-picker.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/DatePicker/date-picker.css";
var date_picker_default = {
  "datePicker": "pf-v6-c-date-picker",
  "datePickerCalendar": "pf-v6-c-date-picker__calendar",
  "datePickerHelperText": "pf-v6-c-date-picker__helper-text",
  "datePickerInput": "pf-v6-c-date-picker__input",
  "formControl": "pf-v6-c-form-control",
  "modifiers": {
    "alignRight": "pf-m-align-right",
    "top": "pf-m-top",
    "static": "pf-m-static"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/Popover.js
var React123 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Popover/popover.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Popover/popover.css";
var popover_default = {
  "modifiers": {
    "noPadding": "pf-m-no-padding",
    "widthAuto": "pf-m-width-auto",
    "top": "pf-m-top",
    "topLeft": "pf-m-top-left",
    "topRight": "pf-m-top-right",
    "bottom": "pf-m-bottom",
    "bottomLeft": "pf-m-bottom-left",
    "bottomRight": "pf-m-bottom-right",
    "left": "pf-m-left",
    "leftTop": "pf-m-left-top",
    "leftBottom": "pf-m-left-bottom",
    "right": "pf-m-right",
    "rightTop": "pf-m-right-top",
    "rightBottom": "pf-m-right-bottom",
    "danger": "pf-m-danger",
    "warning": "pf-m-warning",
    "success": "pf-m-success",
    "custom": "pf-m-custom",
    "info": "pf-m-info"
  },
  "popover": "pf-v6-c-popover",
  "popoverArrow": "pf-v6-c-popover__arrow",
  "popoverBody": "pf-v6-c-popover__body",
  "popoverClose": "pf-v6-c-popover__close",
  "popoverContent": "pf-v6-c-popover__content",
  "popoverFooter": "pf-v6-c-popover__footer",
  "popoverHeader": "pf-v6-c-popover__header",
  "popoverTitle": "pf-v6-c-popover__title",
  "popoverTitleIcon": "pf-v6-c-popover__title-icon",
  "popoverTitleText": "pf-v6-c-popover__title-text"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverContext.js
var React114 = __toESM(require_react());
var PopoverContext = React114.createContext({});

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverContent.js
var React115 = __toESM(require_react());
var PopoverContent = (_a2) => {
  var { className = null, children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React115.createElement("div", Object.assign({ className: css(popover_default.popoverContent, className) }, props), children2);
};
PopoverContent.displayName = "PopoverContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverBody.js
var React116 = __toESM(require_react());
var PopoverBody = (_a2) => {
  var { children: children2, id: id2, className } = _a2, props = __rest(_a2, ["children", "id", "className"]);
  return React116.createElement("div", Object.assign({ className: css(popover_default.popoverBody, className), id: id2 }, props), children2);
};
PopoverBody.displayName = "PopoverBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeader.js
var React119 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeaderIcon.js
var React117 = __toESM(require_react());
var PopoverHeaderIcon = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React117.createElement("span", Object.assign({ className: css(popover_default.popoverTitleIcon, className) }, props), children2);
};
PopoverHeaderIcon.displayName = "PopoverHeaderIcon";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeaderText.js
var React118 = __toESM(require_react());
var PopoverHeaderText = (_a2) => {
  var { children: children2, className, headingLevel } = _a2, props = __rest(_a2, ["children", "className", "headingLevel"]);
  const HeadingLevel = headingLevel;
  return React118.createElement(HeadingLevel, Object.assign({ className: css(popover_default.popoverTitleText, className) }, props), children2);
};
PopoverHeaderText.displayName = "PopoverHeaderText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeader.js
var PopoverHeader = (_a2) => {
  var { children: children2, icon, className, titleHeadingLevel = "h6", alertSeverityVariant, id: id2, alertSeverityScreenReaderText } = _a2, props = __rest(_a2, ["children", "icon", "className", "titleHeadingLevel", "alertSeverityVariant", "id", "alertSeverityScreenReaderText"]);
  return React119.createElement(
    "header",
    Object.assign({ className: css(popover_default.popoverHeader, className) }, props),
    React119.createElement(
      "div",
      { className: css(popover_default.popoverTitle), id: id2 },
      icon && React119.createElement(PopoverHeaderIcon, null, icon),
      React119.createElement(
        PopoverHeaderText,
        { headingLevel: titleHeadingLevel },
        alertSeverityVariant && alertSeverityScreenReaderText && React119.createElement("span", { className: "pf-v6-screen-reader" }, alertSeverityScreenReaderText),
        children2
      )
    )
  );
};
PopoverHeader.displayName = "PopoverHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverFooter.js
var React120 = __toESM(require_react());
var PopoverFooter = (_a2) => {
  var { children: children2, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React120.createElement("footer", Object.assign({ className: css(popover_default.popoverFooter, className) }, props), children2);
};
PopoverFooter.displayName = "PopoverFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverCloseButton.js
var React121 = __toESM(require_react());
var PopoverCloseButton = (_a2) => {
  var { onClose = () => void 0 } = _a2, props = __rest(_a2, ["onClose"]);
  return React121.createElement(
    "div",
    { className: css(popover_default.popoverClose) },
    React121.createElement(
      Button,
      Object.assign({ onClick: onClose, variant: "plain", "aria-label": true }, props, { style: { pointerEvents: "auto" } }),
      React121.createElement(times_icon_default, null)
    )
  );
};
PopoverCloseButton.displayName = "PopoverCloseButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverArrow.js
var React122 = __toESM(require_react());
var PopoverArrow = (_a2) => {
  var { className = "" } = _a2, props = __rest(_a2, ["className"]);
  return React122.createElement("div", Object.assign({ className: css(popover_default.popoverArrow, className) }, props));
};
PopoverArrow.displayName = "PopoverArrow";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Popover/Popover.js
var PopoverPosition;
(function(PopoverPosition2) {
  PopoverPosition2["auto"] = "auto";
  PopoverPosition2["top"] = "top";
  PopoverPosition2["bottom"] = "bottom";
  PopoverPosition2["left"] = "left";
  PopoverPosition2["right"] = "right";
  PopoverPosition2["topStart"] = "top-start";
  PopoverPosition2["topEnd"] = "top-end";
  PopoverPosition2["bottomStart"] = "bottom-start";
  PopoverPosition2["bottomEnd"] = "bottom-end";
  PopoverPosition2["leftStart"] = "left-start";
  PopoverPosition2["leftEnd"] = "left-end";
  PopoverPosition2["rightStart"] = "right-start";
  PopoverPosition2["rightEnd"] = "right-end";
})(PopoverPosition || (PopoverPosition = {}));
var alertStyle = {
  custom: popover_default.modifiers.custom,
  info: popover_default.modifiers.info,
  success: popover_default.modifiers.success,
  warning: popover_default.modifiers.warning,
  danger: popover_default.modifiers.danger
};
var Popover = (_a2) => {
  var { children: children2, position = "top", enableFlip = true, className = "", isVisible = null, shouldClose = () => null, shouldOpen = () => null, "aria-label": ariaLabel = "", bodyContent, headerContent = null, headerComponent = "h6", headerIcon = null, alertSeverityVariant, alertSeverityScreenReaderText, footerContent = null, appendTo = () => document.body, hideOnOutsideClick = true, onHide = () => null, onHidden = () => null, onShow = () => null, onShown = () => null, onMount = () => null, zIndex = 9999, triggerAction = "click", minWidth = c_popover_MinWidth_default && c_popover_MinWidth_default.value, maxWidth = c_popover_MaxWidth_default && c_popover_MaxWidth_default.value, closeBtnAriaLabel = "Close", showClose = true, distance = 25, flipBehavior = [
    "top",
    "bottom",
    "left",
    "right",
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-start",
    "left-end",
    "right-start",
    "right-end"
  ], animationDuration = 300, id: id2, withFocusTrap: propWithFocusTrap, triggerRef, hasNoPadding = false, hasAutoWidth = false, elementToFocus } = _a2, rest = __rest(_a2, ["children", "position", "enableFlip", "className", "isVisible", "shouldClose", "shouldOpen", "aria-label", "bodyContent", "headerContent", "headerComponent", "headerIcon", "alertSeverityVariant", "alertSeverityScreenReaderText", "footerContent", "appendTo", "hideOnOutsideClick", "onHide", "onHidden", "onShow", "onShown", "onMount", "zIndex", "triggerAction", "minWidth", "maxWidth", "closeBtnAriaLabel", "showClose", "distance", "flipBehavior", "animationDuration", "id", "withFocusTrap", "triggerRef", "hasNoPadding", "hasAutoWidth", "elementToFocus"]);
  const uniqueId = id2 || getUniqueId();
  const triggerManually = isVisible !== null;
  const [visible, setVisible] = React123.useState(false);
  const [focusTrapActive, setFocusTrapActive] = React123.useState(Boolean(propWithFocusTrap));
  const popoverRef = React123.useRef(null);
  React123.useEffect(() => {
    onMount();
  }, []);
  React123.useEffect(() => {
    if (triggerManually) {
      if (isVisible) {
        show(void 0, true);
      } else {
        hide3();
      }
    }
  }, [isVisible, triggerManually]);
  const show = (event, withFocusTrap) => {
    event && onShow(event);
    setVisible(true);
    propWithFocusTrap !== false && withFocusTrap && setFocusTrapActive(true);
  };
  const hide3 = (event) => {
    event && onHide(event);
    setVisible(false);
  };
  const positionModifiers = {
    top: popover_default.modifiers.top,
    bottom: popover_default.modifiers.bottom,
    left: popover_default.modifiers.left,
    right: popover_default.modifiers.right,
    "top-start": popover_default.modifiers.topLeft,
    "top-end": popover_default.modifiers.topRight,
    "bottom-start": popover_default.modifiers.bottomLeft,
    "bottom-end": popover_default.modifiers.bottomRight,
    "left-start": popover_default.modifiers.leftTop,
    "left-end": popover_default.modifiers.leftBottom,
    "right-start": popover_default.modifiers.rightTop,
    "right-end": popover_default.modifiers.rightBottom
  };
  const hasCustomMinWidth = minWidth !== c_popover_MinWidth_default.value;
  const hasCustomMaxWidth = maxWidth !== c_popover_MaxWidth_default.value;
  const onDocumentKeyDown = (event) => {
    if (event.key === KeyTypes.Escape && visible) {
      if (triggerManually) {
        shouldClose(event, hide3);
      } else {
        hide3(event);
      }
    }
  };
  const onDocumentClick = (event, triggerElement, popperElement) => {
    if (hideOnOutsideClick && visible) {
      const isFromChild = popperElement && popperElement.contains(event.target);
      const isFromTrigger = triggerElement && triggerElement.contains(event.target);
      if (isFromChild || isFromTrigger) {
        return;
      }
      if (triggerManually) {
        shouldClose(event, hide3);
      } else {
        hide3(event);
      }
    }
  };
  const onTriggerClick = (event) => {
    if (triggerManually) {
      if (visible) {
        shouldClose(event, hide3);
      } else {
        shouldOpen(event, show);
      }
    } else {
      if (visible) {
        hide3(event);
      } else {
        show(event, true);
      }
    }
  };
  const onContentMouseDown = () => {
    if (focusTrapActive) {
      setFocusTrapActive(false);
    }
  };
  const onMouseEnter = (event) => {
    if (triggerManually) {
      shouldOpen(event, show);
    } else {
      show(event, false);
    }
  };
  const onMouseLeave = (event) => {
    if (triggerManually) {
      shouldClose(event, hide3);
    } else {
      hide3(event);
    }
  };
  const onFocus = (event) => {
    if (triggerManually) {
      shouldOpen(event, show);
    } else {
      show(event, false);
    }
  };
  const onBlur = (event) => {
    if (triggerManually) {
      shouldClose(event, hide3);
    } else {
      hide3(event);
    }
  };
  const closePopover = (event) => {
    event.stopPropagation();
    if (triggerManually) {
      shouldClose(event, hide3);
    } else {
      hide3(event);
    }
  };
  const content = React123.createElement(
    FocusTrap,
    Object.assign({ ref: popoverRef, active: focusTrapActive, focusTrapOptions: {
      returnFocusOnDeactivate: propWithFocusTrap !== false,
      clickOutsideDeactivates: true,
      // FocusTrap's initialFocus can accept false as a value to prevent initial focus.
      // We want to prevent this in case false is ever passed in.
      initialFocus: elementToFocus || void 0,
      checkCanFocusTrap: (containers) => new Promise((resolve) => {
        const interval2 = setInterval(() => {
          if (containers.every((container) => getComputedStyle(container).visibility !== "hidden")) {
            resolve();
            clearInterval(interval2);
          }
        }, 10);
      }),
      tabbableOptions: { displayCheck: "none" },
      fallbackFocus: () => {
        let node = null;
        if (document && document.activeElement) {
          node = document.activeElement;
        }
        return node;
      }
    }, preventScrollOnDeactivate: true, className: css(popover_default.popover, alertSeverityVariant && alertStyle[alertSeverityVariant], hasNoPadding && popover_default.modifiers.noPadding, hasAutoWidth && popover_default.modifiers.widthAuto, className), role: "dialog", "aria-modal": "true", "aria-label": headerContent ? void 0 : ariaLabel, "aria-labelledby": headerContent ? `popover-${uniqueId}-header` : void 0, "aria-describedby": `popover-${uniqueId}-body`, onMouseDown: onContentMouseDown, style: {
      minWidth: hasCustomMinWidth ? minWidth : null,
      maxWidth: hasCustomMaxWidth ? maxWidth : null
    } }, rest),
    React123.createElement(PopoverArrow, null),
    React123.createElement(
      PopoverContent,
      null,
      showClose && triggerAction === "click" && React123.createElement(PopoverCloseButton, { onClose: closePopover, "aria-label": closeBtnAriaLabel }),
      headerContent && React123.createElement(PopoverHeader, { id: `popover-${uniqueId}-header`, icon: headerIcon, alertSeverityVariant, alertSeverityScreenReaderText: alertSeverityScreenReaderText || `${alertSeverityVariant} alert:`, titleHeadingLevel: headerComponent }, typeof headerContent === "function" ? headerContent(hide3) : headerContent),
      React123.createElement(PopoverBody, { id: `popover-${uniqueId}-body` }, typeof bodyContent === "function" ? bodyContent(hide3) : bodyContent),
      footerContent && React123.createElement(PopoverFooter, { id: `popover-${uniqueId}-footer` }, typeof footerContent === "function" ? footerContent(hide3) : footerContent)
    )
  );
  return React123.createElement(
    PopoverContext.Provider,
    { value: { headerComponent } },
    React123.createElement(Popper, { trigger: children2, triggerRef, popper: content, popperRef: popoverRef, minWidth, appendTo, isVisible: visible, onMouseEnter: triggerAction === "hover" && onMouseEnter, onMouseLeave: triggerAction === "hover" && onMouseLeave, onPopperMouseEnter: triggerAction === "hover" && onMouseEnter, onPopperMouseLeave: triggerAction === "hover" && onMouseLeave, onFocus: triggerAction === "hover" && onFocus, onBlur: triggerAction === "hover" && onBlur, positionModifiers, distance, placement: position, onTriggerClick: triggerAction === "click" && onTriggerClick, onDocumentClick, onDocumentKeyDown, enableFlip, zIndex, flipBehavior, animationDuration, onHidden, onShown, onHide: () => setFocusTrapActive(false) })
  );
};
Popover.displayName = "Popover";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/outlined-calendar-alt-icon.js
var OutlinedCalendarAltIconConfig = {
  name: "OutlinedCalendarAltIcon",
  height: 512,
  width: 448,
  svgPath: "M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z",
  yOffset: 0,
  xOffset: 0
};
var OutlinedCalendarAltIcon = createIcon(OutlinedCalendarAltIconConfig);
var outlined_calendar_alt_icon_default = OutlinedCalendarAltIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DatePicker/DatePicker.js
var import_react14 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/HelperText/HelperText.js
var React124 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/HelperText/helper-text.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/HelperText/helper-text.css";
var helper_text_default = {
  "helperText": "pf-v6-c-helper-text",
  "helperTextItem": "pf-v6-c-helper-text__item",
  "helperTextItemIcon": "pf-v6-c-helper-text__item-icon",
  "helperTextItemText": "pf-v6-c-helper-text__item-text",
  "modifiers": {
    "hidden": "pf-m-hidden",
    "indeterminate": "pf-m-indeterminate",
    "warning": "pf-m-warning",
    "success": "pf-m-success",
    "error": "pf-m-error",
    "dynamic": "pf-m-dynamic"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/HelperText/HelperText.js
var HelperText = (_a2) => {
  var { children: children2, className, component = "div", id: id2, isLiveRegion = false, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["children", "className", "component", "id", "isLiveRegion", "aria-label"]);
  const Component50 = component;
  return React124.createElement(Component50, Object.assign({ id: id2, className: css(helper_text_default.helperText, className) }, isLiveRegion && { "aria-live": "polite" }, component === "ul" && { role: "list", "aria-label": ariaLabel }, props), children2);
};
HelperText.displayName = "HelperText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/HelperText/HelperTextItem.js
var React125 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/minus-icon.js
var MinusIconConfig = {
  name: "MinusIcon",
  height: 512,
  width: 448,
  svgPath: "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
  yOffset: 0,
  xOffset: 0
};
var MinusIcon = createIcon(MinusIconConfig);
var minus_icon_default = MinusIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/HelperText/HelperTextItem.js
var HelperTextItemVariant;
(function(HelperTextItemVariant2) {
  HelperTextItemVariant2["default"] = "default";
  HelperTextItemVariant2["warning"] = "warning";
  HelperTextItemVariant2["error"] = "error";
  HelperTextItemVariant2["success"] = "success";
})(HelperTextItemVariant || (HelperTextItemVariant = {}));
var defaultVariantIcons = {
  indeterminate: React125.createElement(minus_icon_default, null),
  warning: React125.createElement(exclamation_triangle_icon_default, null),
  success: React125.createElement(check_circle_icon_default, null),
  error: React125.createElement(exclamation_circle_icon_default, null)
};
var HelperTextItem = (_a2) => {
  var { children: children2, className, component = "div", variant = "default", icon, id: id2, screenReaderText = `${variant} status` } = _a2, props = __rest(_a2, ["children", "className", "component", "variant", "icon", "id", "screenReaderText"]);
  const Component50 = component;
  const isNotDefaultVariant = variant !== "default";
  const defaultIcon = isNotDefaultVariant && defaultVariantIcons[variant];
  return React125.createElement(
    Component50,
    Object.assign({ className: css(helper_text_default.helperTextItem, isNotDefaultVariant && helper_text_default.modifiers[variant], className), id: id2 }, props),
    (defaultIcon || icon) && React125.createElement("span", { className: css(helper_text_default.helperTextItemIcon), "aria-hidden": true }, icon || defaultIcon),
    React125.createElement(
      "span",
      { className: css(helper_text_default.helperTextItemText) },
      children2,
      isNotDefaultVariant && React125.createElement(
        "span",
        { className: "pf-v6-screen-reader" },
        ": ",
        screenReaderText,
        ";"
      )
    )
  );
};
HelperTextItem.displayName = "HelperTextItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DatePicker/DatePicker.js
var yyyyMMddFormat = (date2) => `${date2.getFullYear()}-${(date2.getMonth() + 1).toString().padStart(2, "0")}-${date2.getDate().toString().padStart(2, "0")}`;
var DatePickerBase = (_a2, ref) => {
  var { className, locale: locale3 = void 0, dateFormat = yyyyMMddFormat, dateParse = (val) => val.split("-").length === 3 ? /* @__PURE__ */ new Date(`${val}T00:00:00`) : /* @__PURE__ */ new Date(void 0), isDisabled = false, placeholder = "YYYY-MM-DD", value: valueProp = "", "aria-label": ariaLabel = "Date picker", buttonAriaLabel = "Toggle date picker", onChange = () => void 0, onBlur = () => void 0, invalidFormatText = "Invalid date", requiredDateOptions, helperText, appendTo = "inline", popoverProps, monthFormat, weekdayFormat, longWeekdayFormat, dayFormat, weekStart, validators = [], rangeStart, style: styleProps = {}, inputProps = {} } = _a2, props = __rest(_a2, ["className", "locale", "dateFormat", "dateParse", "isDisabled", "placeholder", "value", "aria-label", "buttonAriaLabel", "onChange", "onBlur", "invalidFormatText", "requiredDateOptions", "helperText", "appendTo", "popoverProps", "monthFormat", "weekdayFormat", "longWeekdayFormat", "dayFormat", "weekStart", "validators", "rangeStart", "style", "inputProps"]);
  const [value, setValue] = React126.useState(valueProp);
  const [valueDate, setValueDate] = React126.useState(dateParse(value));
  const [errorText, setErrorText] = React126.useState("");
  const [popoverOpen, setPopoverOpen] = React126.useState(false);
  const [selectOpen, setSelectOpen] = React126.useState(false);
  const [pristine, setPristine] = React126.useState(true);
  const [textInputFocused, setTextInputFocused] = React126.useState(false);
  const widthChars = React126.useMemo(() => Math.max(dateFormat(/* @__PURE__ */ new Date()).length, placeholder.length), [dateFormat]);
  const style = Object.assign({ [c_date_picker_input_c_form_control_width_chars_default.name]: widthChars }, styleProps);
  const buttonRef = React126.useRef();
  const datePickerWrapperRef = React126.useRef();
  const triggerRef = React126.useRef();
  const dateIsRequired = (requiredDateOptions === null || requiredDateOptions === void 0 ? void 0 : requiredDateOptions.isRequired) || false;
  const emptyDateText = (requiredDateOptions === null || requiredDateOptions === void 0 ? void 0 : requiredDateOptions.emptyDateText) || "Date cannot be blank";
  React126.useEffect(() => {
    setValue(valueProp);
    setValueDate(dateParse(valueProp));
  }, [valueProp]);
  React126.useEffect(() => {
    if (isValidDate(valueDate)) {
      applyValidators(valueDate);
    }
  }, [validators]);
  React126.useEffect(() => {
    setPristine(!value);
    const newValueDate = dateParse(value);
    if (errorText && isValidDate(newValueDate)) {
      applyValidators(newValueDate);
    }
    if (value === "" && !pristine && !textInputFocused) {
      dateIsRequired ? setErrorText(emptyDateText) : setErrorText("");
    }
  }, [value]);
  const applyValidators = (date2) => {
    setErrorText(validators.map((validator) => validator(date2)).join("\n") || "");
  };
  const onTextInput = (event, value2) => {
    setValue(value2);
    setErrorText("");
    const newValueDate = dateParse(value2);
    setValueDate(newValueDate);
    if (isValidDate(newValueDate)) {
      onChange(event, value2, new Date(newValueDate));
    } else {
      onChange(event, value2);
    }
  };
  const onInputBlur = (event) => {
    setTextInputFocused(false);
    const newValueDate = dateParse(value);
    const dateIsValid = isValidDate(newValueDate);
    const onBlurDateArg = dateIsValid ? new Date(newValueDate) : void 0;
    onBlur(event, value, onBlurDateArg);
    if (dateIsValid) {
      applyValidators(newValueDate);
    }
    if (!dateIsValid && !pristine) {
      setErrorText(invalidFormatText);
    }
    if (!dateIsValid && pristine && (requiredDateOptions === null || requiredDateOptions === void 0 ? void 0 : requiredDateOptions.isRequired)) {
      setErrorText(emptyDateText);
    }
  };
  const onDateClick = (_event, newValueDate) => {
    const newValue = dateFormat(newValueDate);
    setValue(newValue);
    setValueDate(newValueDate);
    applyValidators(newValueDate);
    setPopoverOpen(false);
    onChange(null, newValue, new Date(newValueDate));
  };
  const onKeyPress = (ev) => {
    if (ev.key === "Enter" && value) {
      if (isValidDate(valueDate)) {
        applyValidators(valueDate);
      } else {
        setErrorText(invalidFormatText);
      }
    }
  };
  (0, import_react14.useImperativeHandle)(ref, () => ({
    setCalendarOpen: (isOpen) => setPopoverOpen(isOpen),
    toggleCalendar: (setOpen) => {
      setPopoverOpen((prev) => setOpen !== void 0 ? setOpen : !prev);
    },
    isCalendarOpen: popoverOpen
  }), [setPopoverOpen, popoverOpen, selectOpen]);
  const createFocusSelectorString = (modifierClass) => `.${calendar_month_default.calendarMonthDatesCell}.${modifierClass} .${calendar_month_default.calendarMonthDate}`;
  const focusSelectorForSelectedDate = createFocusSelectorString(calendar_month_default.modifiers.selected);
  const focusSelectorForUnselectedDate = createFocusSelectorString(calendar_month_default.modifiers.current);
  return React126.createElement(
    "div",
    Object.assign({ className: css(date_picker_default.datePicker, className), ref: datePickerWrapperRef, style }, props),
    React126.createElement(
      Popover,
      Object.assign({ elementToFocus: isValidDate(valueDate) ? focusSelectorForSelectedDate : focusSelectorForUnselectedDate, position: "bottom", bodyContent: React126.createElement(CalendarMonth, {
        date: valueDate,
        onChange: onDateClick,
        locale: locale3,
        // Use truthy values of strings
        validators: validators.map((validator) => (date2) => !validator(date2)),
        onSelectToggle: (open) => setSelectOpen(open),
        monthFormat,
        weekdayFormat,
        longWeekdayFormat,
        dayFormat,
        weekStart,
        rangeStart
      }), showClose: false, isVisible: popoverOpen, shouldClose: (event, hideFunction) => {
        event = event;
        if (event.key === KeyTypes.Escape && selectOpen) {
          event.stopPropagation();
          setSelectOpen(false);
          return false;
        }
        if (buttonRef.current && buttonRef.current.contains(event.target)) {
          return false;
        }
        if (popoverOpen) {
          event.stopPropagation();
          setPopoverOpen(false);
          hideFunction();
          (requiredDateOptions === null || requiredDateOptions === void 0 ? void 0 : requiredDateOptions.isRequired) && !value && setErrorText(emptyDateText);
        }
        if (event.key === KeyTypes.Escape && popoverOpen) {
          event.stopPropagation();
        }
        return true;
      }, withFocusTrap: true, hasNoPadding: true, hasAutoWidth: true, appendTo, triggerRef }, popoverProps),
      React126.createElement(
        "div",
        { className: date_picker_default.datePickerInput, ref: triggerRef },
        React126.createElement(
          InputGroup,
          null,
          React126.createElement(
            InputGroupItem,
            null,
            React126.createElement(TextInput, Object.assign({ isDisabled, isRequired: requiredDateOptions === null || requiredDateOptions === void 0 ? void 0 : requiredDateOptions.isRequired, "aria-label": ariaLabel, placeholder, validated: errorText.trim() ? "error" : "default", value, onChange: onTextInput, onBlur: onInputBlur, onFocus: () => setTextInputFocused(true), onKeyPress }, inputProps))
          ),
          React126.createElement(
            InputGroupItem,
            null,
            React126.createElement(
              "button",
              {
                ref: buttonRef,
                // TODO: Removed style follow up work with issue #8457
                className: css(button_default.button, button_default.modifiers.control),
                "aria-label": buttonAriaLabel,
                type: "button",
                onClick: () => setPopoverOpen(!popoverOpen),
                disabled: isDisabled
              },
              React126.createElement(outlined_calendar_alt_icon_default, null)
            )
          )
        )
      )
    ),
    (errorText || helperText) && React126.createElement("div", { className: date_picker_default.datePickerHelperText }, errorText ? React126.createElement(
      HelperText,
      null,
      React126.createElement(HelperTextItem, { variant: "error" }, errorText)
    ) : helperText)
  );
};
var DatePicker = React126.forwardRef(DatePickerBase);
DatePicker.displayName = "DatePicker";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DescriptionList/DescriptionList.js
var React127 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/DescriptionList/description-list.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/DescriptionList/description-list.css";
var description_list_default = {
  "card": "pf-v6-c-card",
  "descriptionList": "pf-v6-c-description-list",
  "descriptionListDescription": "pf-v6-c-description-list__description",
  "descriptionListGroup": "pf-v6-c-description-list__group",
  "descriptionListTerm": "pf-v6-c-description-list__term",
  "descriptionListTermIcon": "pf-v6-c-description-list__term-icon",
  "descriptionListText": "pf-v6-c-description-list__text",
  "modifiers": {
    "inlineGrid": "pf-m-inline-grid",
    "autoColumnWidths": "pf-m-auto-column-widths",
    "autoFit": "pf-m-auto-fit",
    "compact": "pf-m-compact",
    "fluid": "pf-m-fluid",
    "fillColumns": "pf-m-fill-columns",
    "displayLg": "pf-m-display-lg",
    "display_2xl": "pf-m-display-2xl",
    "helpText": "pf-m-help-text",
    "1Col": "pf-m-1-col",
    "2Col": "pf-m-2-col",
    "3Col": "pf-m-3-col",
    "horizontal": "pf-m-horizontal",
    "vertical": "pf-m-vertical",
    "1ColOnSm": "pf-m-1-col-on-sm",
    "2ColOnSm": "pf-m-2-col-on-sm",
    "3ColOnSm": "pf-m-3-col-on-sm",
    "horizontalOnSm": "pf-m-horizontal-on-sm",
    "verticalOnSm": "pf-m-vertical-on-sm",
    "1ColOnMd": "pf-m-1-col-on-md",
    "2ColOnMd": "pf-m-2-col-on-md",
    "3ColOnMd": "pf-m-3-col-on-md",
    "horizontalOnMd": "pf-m-horizontal-on-md",
    "verticalOnMd": "pf-m-vertical-on-md",
    "1ColOnLg": "pf-m-1-col-on-lg",
    "2ColOnLg": "pf-m-2-col-on-lg",
    "3ColOnLg": "pf-m-3-col-on-lg",
    "horizontalOnLg": "pf-m-horizontal-on-lg",
    "verticalOnLg": "pf-m-vertical-on-lg",
    "1ColOnXl": "pf-m-1-col-on-xl",
    "2ColOnXl": "pf-m-2-col-on-xl",
    "3ColOnXl": "pf-m-3-col-on-xl",
    "horizontalOnXl": "pf-m-horizontal-on-xl",
    "verticalOnXl": "pf-m-vertical-on-xl",
    "1ColOn_2xl": "pf-m-1-col-on-2xl",
    "2ColOn_2xl": "pf-m-2-col-on-2xl",
    "3ColOn_2xl": "pf-m-3-col-on-2xl",
    "horizontalOn_2xl": "pf-m-horizontal-on-2xl",
    "verticalOn_2xl": "pf-m-vertical-on-2xl"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DescriptionList/DescriptionList.js
var cssTermWidth = {
  name: "--pf-v5-c-description-list__term-width"
};
var setBreakpointModifiers = (prefix, modifiers2) => {
  const mods = modifiers2;
  return Object.keys(mods || {}).reduce((acc, curr) => curr === "default" ? Object.assign(Object.assign({}, acc), { [prefix]: mods[curr] }) : Object.assign(Object.assign({}, acc), { [`${prefix}-on-${curr}`]: mods[curr] }), {});
};
var DescriptionList = (_a2) => {
  var { className = "", children: children2 = null, isHorizontal = false, isAutoColumnWidths, isAutoFit, isInlineGrid, isCompact, isFluid, isFillColumns, displaySize = "default", columnModifier, autoFitMinModifier, termWidth, horizontalTermWidthModifier, orientation, style } = _a2, props = __rest(_a2, ["className", "children", "isHorizontal", "isAutoColumnWidths", "isAutoFit", "isInlineGrid", "isCompact", "isFluid", "isFillColumns", "displaySize", "columnModifier", "autoFitMinModifier", "termWidth", "horizontalTermWidthModifier", "orientation", "style"]);
  if (isAutoFit && autoFitMinModifier) {
    style = Object.assign(Object.assign({}, style), setBreakpointModifiers(c_description_list_GridTemplateColumns_min_default.name, autoFitMinModifier));
  }
  if (termWidth) {
    style = Object.assign(Object.assign({}, style), { [cssTermWidth.name]: termWidth });
  }
  if (isHorizontal && horizontalTermWidthModifier) {
    style = Object.assign(Object.assign({}, style), setBreakpointModifiers(c_description_list_m_horizontal_term_width_default.name, horizontalTermWidthModifier));
  }
  return React127.createElement("dl", Object.assign({ className: css(description_list_default.descriptionList, (isHorizontal || isFluid) && description_list_default.modifiers.horizontal, isAutoColumnWidths && description_list_default.modifiers.autoColumnWidths, isAutoFit && description_list_default.modifiers.autoFit, formatBreakpointMods(columnModifier, description_list_default), formatBreakpointMods(orientation, description_list_default), isInlineGrid && description_list_default.modifiers.inlineGrid, isCompact && description_list_default.modifiers.compact, isFluid && description_list_default.modifiers.fluid, isFillColumns && description_list_default.modifiers.fillColumns, displaySize === "lg" && description_list_default.modifiers.displayLg, displaySize === "2xl" && description_list_default.modifiers.display_2xl, className), style }, props), children2);
};
DescriptionList.displayName = "DescriptionList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DescriptionList/DescriptionListDescription.js
var React128 = __toESM(require_react());
var DescriptionListDescription = (_a2) => {
  var { children: children2 = null, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React128.createElement(
    "dd",
    Object.assign({ className: css(description_list_default.descriptionListDescription, className) }, props),
    React128.createElement("div", { className: css(description_list_default.descriptionListText) }, children2)
  );
};
DescriptionListDescription.displayName = "DescriptionListDescription";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DescriptionList/DescriptionListGroup.js
var React129 = __toESM(require_react());
var DescriptionListGroup = (_a2) => {
  var { className, children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React129.createElement("div", Object.assign({ className: css(description_list_default.descriptionListGroup, className) }, props), children2);
};
DescriptionListGroup.displayName = "DescriptionListGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DescriptionList/DescriptionListTerm.js
var React130 = __toESM(require_react());
var DescriptionListTerm = (_a2) => {
  var { children: children2, className, icon } = _a2, props = __rest(_a2, ["children", "className", "icon"]);
  return React130.createElement(
    "dt",
    Object.assign({ className: css(description_list_default.descriptionListTerm, className) }, props),
    icon ? React130.createElement("span", { className: css(description_list_default.descriptionListTermIcon) }, icon) : null,
    React130.createElement("span", { className: css(description_list_default.descriptionListText) }, children2)
  );
};
DescriptionListTerm.displayName = "DescriptionListTerm";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DescriptionList/DescriptionListTermHelpText.js
var React131 = __toESM(require_react());
var DescriptionListTermHelpText = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React131.createElement("dt", Object.assign({ className: css(description_list_default.descriptionListTerm, className) }, props), children2);
};
DescriptionListTermHelpText.displayName = "DescriptionListTermHelpText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DescriptionList/DescriptionListTermHelpTextButton.js
var React132 = __toESM(require_react());
var DescriptionListTermHelpTextButton = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React132.createElement("span", Object.assign({ className: css(className, description_list_default.descriptionListText, description_list_default.modifiers.helpText), role: "button", type: "button", tabIndex: 0 }, props), children2);
};
DescriptionListTermHelpTextButton.displayName = "DescriptionListTermHelpTextButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Divider/Divider.js
var React133 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Divider/divider.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Divider/divider.css";
var divider_default = {
  "divider": "pf-v6-c-divider",
  "modifiers": {
    "hidden": "pf-m-hidden",
    "hiddenOnSm": "pf-m-hidden-on-sm",
    "visibleOnSm": "pf-m-visible-on-sm",
    "hiddenOnMd": "pf-m-hidden-on-md",
    "visibleOnMd": "pf-m-visible-on-md",
    "hiddenOnLg": "pf-m-hidden-on-lg",
    "visibleOnLg": "pf-m-visible-on-lg",
    "hiddenOnXl": "pf-m-hidden-on-xl",
    "visibleOnXl": "pf-m-visible-on-xl",
    "hiddenOn_2xl": "pf-m-hidden-on-2xl",
    "visibleOn_2xl": "pf-m-visible-on-2xl",
    "horizontal": "pf-m-horizontal",
    "vertical": "pf-m-vertical",
    "insetNone": "pf-m-inset-none",
    "insetXs": "pf-m-inset-xs",
    "insetSm": "pf-m-inset-sm",
    "insetMd": "pf-m-inset-md",
    "insetLg": "pf-m-inset-lg",
    "insetXl": "pf-m-inset-xl",
    "inset_2xl": "pf-m-inset-2xl",
    "inset_3xl": "pf-m-inset-3xl",
    "horizontalOnSm": "pf-m-horizontal-on-sm",
    "verticalOnSm": "pf-m-vertical-on-sm",
    "insetNoneOnSm": "pf-m-inset-none-on-sm",
    "insetXsOnSm": "pf-m-inset-xs-on-sm",
    "insetSmOnSm": "pf-m-inset-sm-on-sm",
    "insetMdOnSm": "pf-m-inset-md-on-sm",
    "insetLgOnSm": "pf-m-inset-lg-on-sm",
    "insetXlOnSm": "pf-m-inset-xl-on-sm",
    "inset_2xlOnSm": "pf-m-inset-2xl-on-sm",
    "inset_3xlOnSm": "pf-m-inset-3xl-on-sm",
    "horizontalOnMd": "pf-m-horizontal-on-md",
    "verticalOnMd": "pf-m-vertical-on-md",
    "insetNoneOnMd": "pf-m-inset-none-on-md",
    "insetXsOnMd": "pf-m-inset-xs-on-md",
    "insetSmOnMd": "pf-m-inset-sm-on-md",
    "insetMdOnMd": "pf-m-inset-md-on-md",
    "insetLgOnMd": "pf-m-inset-lg-on-md",
    "insetXlOnMd": "pf-m-inset-xl-on-md",
    "inset_2xlOnMd": "pf-m-inset-2xl-on-md",
    "inset_3xlOnMd": "pf-m-inset-3xl-on-md",
    "horizontalOnLg": "pf-m-horizontal-on-lg",
    "verticalOnLg": "pf-m-vertical-on-lg",
    "insetNoneOnLg": "pf-m-inset-none-on-lg",
    "insetXsOnLg": "pf-m-inset-xs-on-lg",
    "insetSmOnLg": "pf-m-inset-sm-on-lg",
    "insetMdOnLg": "pf-m-inset-md-on-lg",
    "insetLgOnLg": "pf-m-inset-lg-on-lg",
    "insetXlOnLg": "pf-m-inset-xl-on-lg",
    "inset_2xlOnLg": "pf-m-inset-2xl-on-lg",
    "inset_3xlOnLg": "pf-m-inset-3xl-on-lg",
    "horizontalOnXl": "pf-m-horizontal-on-xl",
    "verticalOnXl": "pf-m-vertical-on-xl",
    "insetNoneOnXl": "pf-m-inset-none-on-xl",
    "insetXsOnXl": "pf-m-inset-xs-on-xl",
    "insetSmOnXl": "pf-m-inset-sm-on-xl",
    "insetMdOnXl": "pf-m-inset-md-on-xl",
    "insetLgOnXl": "pf-m-inset-lg-on-xl",
    "insetXlOnXl": "pf-m-inset-xl-on-xl",
    "inset_2xlOnXl": "pf-m-inset-2xl-on-xl",
    "inset_3xlOnXl": "pf-m-inset-3xl-on-xl",
    "horizontalOn_2xl": "pf-m-horizontal-on-2xl",
    "verticalOn_2xl": "pf-m-vertical-on-2xl",
    "insetNoneOn_2xl": "pf-m-inset-none-on-2xl",
    "insetXsOn_2xl": "pf-m-inset-xs-on-2xl",
    "insetSmOn_2xl": "pf-m-inset-sm-on-2xl",
    "insetMdOn_2xl": "pf-m-inset-md-on-2xl",
    "insetLgOn_2xl": "pf-m-inset-lg-on-2xl",
    "insetXlOn_2xl": "pf-m-inset-xl-on-2xl",
    "inset_2xlOn_2xl": "pf-m-inset-2xl-on-2xl",
    "inset_3xlOn_2xl": "pf-m-inset-3xl-on-2xl"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Divider/Divider.js
var DividerVariant;
(function(DividerVariant2) {
  DividerVariant2["hr"] = "hr";
  DividerVariant2["li"] = "li";
  DividerVariant2["div"] = "div";
})(DividerVariant || (DividerVariant = {}));
var Divider = (_a2) => {
  var { className, component = DividerVariant.hr, inset, orientation } = _a2, props = __rest(_a2, ["className", "component", "inset", "orientation"]);
  const Component50 = component;
  return React133.createElement(Component50, Object.assign({ className: css(divider_default.divider, formatBreakpointMods(inset, divider_default), formatBreakpointMods(orientation, divider_default), className) }, component !== "hr" && { role: "separator" }, props));
};
Divider.displayName = "Divider";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/Drawer.js
var React134 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Drawer/drawer.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Drawer/drawer.css";
var drawer_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "drawer": "pf-v6-c-drawer",
  "drawerActions": "pf-v6-c-drawer__actions",
  "drawerBody": "pf-v6-c-drawer__body",
  "drawerClose": "pf-v6-c-drawer__close",
  "drawerContent": "pf-v6-c-drawer__content",
  "drawerDescription": "pf-v6-c-drawer__description",
  "drawerHead": "pf-v6-c-drawer__head",
  "drawerMain": "pf-v6-c-drawer__main",
  "drawerPanel": "pf-v6-c-drawer__panel",
  "drawerPanelMain": "pf-v6-c-drawer__panel-main",
  "drawerSection": "pf-v6-c-drawer__section",
  "drawerSplitter": "pf-v6-c-drawer__splitter",
  "drawerSplitterHandle": "pf-v6-c-drawer__splitter-handle",
  "modifiers": {
    "panelBottom": "pf-m-panel-bottom",
    "inline": "pf-m-inline",
    "noBorder": "pf-m-no-border",
    "resizable": "pf-m-resizable",
    "static": "pf-m-static",
    "panelLeft": "pf-m-panel-left",
    "expanded": "pf-m-expanded",
    "resizing": "pf-m-resizing",
    "secondary": "pf-m-secondary",
    "noBackground": "pf-m-no-background",
    "primary": "pf-m-primary",
    "noPadding": "pf-m-no-padding",
    "padding": "pf-m-padding",
    "vertical": "pf-m-vertical",
    "width_25": "pf-m-width-25",
    "width_33": "pf-m-width-33",
    "width_50": "pf-m-width-50",
    "width_66": "pf-m-width-66",
    "width_75": "pf-m-width-75",
    "width_100": "pf-m-width-100",
    "width_25OnLg": "pf-m-width-25-on-lg",
    "width_33OnLg": "pf-m-width-33-on-lg",
    "width_50OnLg": "pf-m-width-50-on-lg",
    "width_66OnLg": "pf-m-width-66-on-lg",
    "width_75OnLg": "pf-m-width-75-on-lg",
    "width_100OnLg": "pf-m-width-100-on-lg",
    "width_25OnXl": "pf-m-width-25-on-xl",
    "width_33OnXl": "pf-m-width-33-on-xl",
    "width_50OnXl": "pf-m-width-50-on-xl",
    "width_66OnXl": "pf-m-width-66-on-xl",
    "width_75OnXl": "pf-m-width-75-on-xl",
    "width_100OnXl": "pf-m-width-100-on-xl",
    "width_25On_2xl": "pf-m-width-25-on-2xl",
    "width_33On_2xl": "pf-m-width-33-on-2xl",
    "width_50On_2xl": "pf-m-width-50-on-2xl",
    "width_66On_2xl": "pf-m-width-66-on-2xl",
    "width_75On_2xl": "pf-m-width-75-on-2xl",
    "width_100On_2xl": "pf-m-width-100-on-2xl",
    "inlineOnLg": "pf-m-inline-on-lg",
    "staticOnLg": "pf-m-static-on-lg",
    "inlineOnXl": "pf-m-inline-on-xl",
    "staticOnXl": "pf-m-static-on-xl",
    "inlineOn_2xl": "pf-m-inline-on-2xl",
    "staticOn_2xl": "pf-m-static-on-2xl"
  },
  "pageMain": "pf-v6-c-page__main"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/Drawer.js
var DrawerColorVariant;
(function(DrawerColorVariant2) {
  DrawerColorVariant2["default"] = "default";
  DrawerColorVariant2["secondary"] = "secondary";
  DrawerColorVariant2["noBackground"] = "no-background";
})(DrawerColorVariant || (DrawerColorVariant = {}));
var DrawerContext = React134.createContext({
  isExpanded: false,
  isStatic: false,
  onExpand: () => {
  },
  position: "end",
  drawerRef: null,
  drawerContentRef: null,
  isInline: false
});
var Drawer = (_a2) => {
  var { className = "", children: children2, isExpanded = false, isInline = false, isStatic = false, position = "end", onExpand = () => {
  } } = _a2, props = __rest(_a2, ["className", "children", "isExpanded", "isInline", "isStatic", "position", "onExpand"]);
  const drawerRef = React134.useRef();
  const drawerContentRef = React134.useRef();
  return React134.createElement(
    DrawerContext.Provider,
    { value: { isExpanded, isStatic, onExpand, position, drawerRef, drawerContentRef, isInline } },
    React134.createElement("div", Object.assign({ className: css(drawer_default.drawer, isExpanded && drawer_default.modifiers.expanded, isInline && drawer_default.modifiers.inline, isStatic && drawer_default.modifiers.static, (position === "left" || position === "start") && drawer_default.modifiers.panelLeft, position === "bottom" && drawer_default.modifiers.panelBottom, className), ref: drawerRef }, props), children2)
  );
};
Drawer.displayName = "Drawer";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerActions.js
var React135 = __toESM(require_react());
var DrawerActions = (_a2) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className = "",
    children: children2
  } = _a2, props = __rest(_a2, ["className", "children"]);
  return React135.createElement("div", Object.assign({ className: css(drawer_default.drawerActions, className) }, props), children2);
};
DrawerActions.displayName = "DrawerActions";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerCloseButton.js
var React136 = __toESM(require_react());
var DrawerCloseButton = (_a2) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className = "",
    onClose = () => void 0,
    "aria-label": ariaLabel = "Close drawer panel"
  } = _a2, props = __rest(_a2, ["className", "onClose", "aria-label"]);
  return React136.createElement(
    "div",
    Object.assign({ className: css(drawer_default.drawerClose, className) }, props),
    React136.createElement(
      Button,
      { variant: "plain", onClick: onClose, "aria-label": ariaLabel },
      React136.createElement(times_icon_default, null)
    )
  );
};
DrawerCloseButton.displayName = "DrawerCloseButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerContent.js
var React138 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerMain.js
var React137 = __toESM(require_react());
var DrawerMain = (_a2) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className = "",
    children: children2
  } = _a2, props = __rest(_a2, ["className", "children"]);
  return React137.createElement("div", Object.assign({ className: css(drawer_default.drawerMain, className) }, props), children2);
};
DrawerMain.displayName = "DrawerMain";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerContent.js
var DrawerContentColorVariant;
(function(DrawerContentColorVariant2) {
  DrawerContentColorVariant2["default"] = "default";
  DrawerContentColorVariant2["primary"] = "primary";
  DrawerContentColorVariant2["secondary"] = "secondary";
})(DrawerContentColorVariant || (DrawerContentColorVariant = {}));
var DrawerContent = (_a2) => {
  var { className, children: children2, panelContent, colorVariant = DrawerContentColorVariant.default } = _a2, props = __rest(_a2, ["className", "children", "panelContent", "colorVariant"]);
  const { drawerContentRef } = React138.useContext(DrawerContext);
  return React138.createElement(
    DrawerMain,
    null,
    React138.createElement("div", Object.assign({ className: css(drawer_default.drawerContent, colorVariant === DrawerContentColorVariant.primary && drawer_default.modifiers.primary, colorVariant === DrawerContentColorVariant.secondary && drawer_default.modifiers.secondary, className), ref: drawerContentRef }, props), children2),
    panelContent
  );
};
DrawerContent.displayName = "DrawerContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerContentBody.js
var React139 = __toESM(require_react());
var DrawerContentBody = (_a2) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className = "",
    children: children2,
    hasPadding = false
  } = _a2, props = __rest(_a2, ["className", "children", "hasPadding"]);
  return React139.createElement("div", Object.assign({ className: css(drawer_default.drawerBody, hasPadding && drawer_default.modifiers.padding, className) }, props), children2);
};
DrawerContentBody.displayName = "DrawerContentBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerPanelDescription.js
var React140 = __toESM(require_react());
var DrawerPanelDescription = (_a2) => {
  var { className, children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React140.createElement("div", Object.assign({ className: css(drawer_default.drawerDescription, className) }, props), children2);
};
DrawerPanelDescription.displayName = "DrawerPanelDescription";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerHead.js
var React141 = __toESM(require_react());
var DrawerHead = (_a2) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className = "",
    children: children2
  } = _a2, props = __rest(_a2, ["className", "children"]);
  return React141.createElement("div", Object.assign({ className: css(drawer_default.drawerHead, className) }, props), children2);
};
DrawerHead.displayName = "DrawerHead";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerPanelBody.js
var React142 = __toESM(require_react());
var DrawerPanelBody = (_a2) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className = "",
    children: children2,
    hasNoPadding = false
  } = _a2, props = __rest(_a2, ["className", "children", "hasNoPadding"]);
  return React142.createElement("div", Object.assign({ className: css(drawer_default.drawerBody, hasNoPadding && drawer_default.modifiers.noPadding, className) }, props), children2);
};
DrawerPanelBody.displayName = "DrawerPanelBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerPanelContent.js
var React143 = __toESM(require_react());
var isResizing = null;
var newSize = 0;
var DrawerPanelContent = (_a2) => {
  var { className, id: id2, children: children2, hasNoBorder = false, isResizable = false, onResize, minSize, defaultSize, maxSize, increment = 5, resizeAriaLabel = "Resize", widths, colorVariant = DrawerColorVariant.default, focusTrap } = _a2, props = __rest(_a2, ["className", "id", "children", "hasNoBorder", "isResizable", "onResize", "minSize", "defaultSize", "maxSize", "increment", "resizeAriaLabel", "widths", "colorVariant", "focusTrap"]);
  const panel = React143.useRef();
  const splitterRef = React143.useRef();
  const [separatorValue, setSeparatorValue] = React143.useState(0);
  const { position, isExpanded, isStatic, onExpand, drawerRef, drawerContentRef, isInline } = React143.useContext(DrawerContext);
  const hidden = isStatic ? false : !isExpanded;
  const [isExpandedInternal, setIsExpandedInternal] = React143.useState(!hidden);
  const [isFocusTrapActive, setIsFocusTrapActive] = React143.useState(false);
  const previouslyFocusedElement = React143.useRef(null);
  let currWidth = 0;
  let panelRect;
  let end2;
  let start3;
  let bottom3;
  let setInitialVals = true;
  if (isStatic && (focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.enabled)) {
    console.warn(`DrawerPanelContent: The focusTrap.enabled prop cannot be true if the Drawer's isStatic prop is true. This will cause a permanent focus trap.`);
  }
  React143.useEffect(() => {
    if (!isStatic && isExpanded) {
      setIsExpandedInternal(isExpanded);
    }
  }, [isStatic, isExpanded]);
  const calcValueNow = () => {
    let splitterPos;
    let drawerSize;
    const isRTL = getLanguageDirection(panel.current) === "rtl";
    if (isInline && (position === "end" || position === "right")) {
      if (isRTL) {
        splitterPos = panel.current.getBoundingClientRect().left - splitterRef.current.getBoundingClientRect().right;
        drawerSize = drawerRef.current.getBoundingClientRect().left - drawerRef.current.getBoundingClientRect().right;
      } else {
        splitterPos = panel.current.getBoundingClientRect().right - splitterRef.current.getBoundingClientRect().left;
        drawerSize = drawerRef.current.getBoundingClientRect().right - drawerRef.current.getBoundingClientRect().left;
      }
    } else if (isInline && (position === "start" || position === "left")) {
      if (isRTL) {
        splitterPos = splitterRef.current.getBoundingClientRect().left - panel.current.getBoundingClientRect().right;
        drawerSize = drawerRef.current.getBoundingClientRect().left - drawerRef.current.getBoundingClientRect().right;
      } else {
        splitterPos = splitterRef.current.getBoundingClientRect().right - panel.current.getBoundingClientRect().left;
        drawerSize = drawerRef.current.getBoundingClientRect().right - drawerRef.current.getBoundingClientRect().left;
      }
    } else if (position === "end" || position === "right") {
      if (isRTL) {
        splitterPos = drawerContentRef.current.getBoundingClientRect().left - splitterRef.current.getBoundingClientRect().right;
        drawerSize = drawerContentRef.current.getBoundingClientRect().left - drawerContentRef.current.getBoundingClientRect().right;
      } else {
        splitterPos = drawerContentRef.current.getBoundingClientRect().right - splitterRef.current.getBoundingClientRect().left;
        drawerSize = drawerContentRef.current.getBoundingClientRect().right - drawerContentRef.current.getBoundingClientRect().left;
      }
    } else if (position === "start" || position === "left") {
      if (isRTL) {
        splitterPos = splitterRef.current.getBoundingClientRect().left - drawerContentRef.current.getBoundingClientRect().right;
        drawerSize = drawerContentRef.current.getBoundingClientRect().left - drawerContentRef.current.getBoundingClientRect().right;
      } else {
        splitterPos = splitterRef.current.getBoundingClientRect().right - drawerContentRef.current.getBoundingClientRect().left;
        drawerSize = drawerContentRef.current.getBoundingClientRect().right - drawerContentRef.current.getBoundingClientRect().left;
      }
    } else if (position === "bottom") {
      splitterPos = drawerContentRef.current.getBoundingClientRect().bottom - splitterRef.current.getBoundingClientRect().top;
      drawerSize = drawerContentRef.current.getBoundingClientRect().bottom - drawerContentRef.current.getBoundingClientRect().top;
    }
    const newSplitterPos = splitterPos / drawerSize * 100;
    return Math.round((newSplitterPos + Number.EPSILON) * 100) / 100;
  };
  const handleTouchStart = (e) => {
    e.stopPropagation();
    document.addEventListener("touchmove", callbackTouchMove, { passive: false });
    document.addEventListener("touchend", callbackTouchEnd);
    isResizing = true;
  };
  const handleMousedown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    document.addEventListener("mousemove", callbackMouseMove);
    document.addEventListener("mouseup", callbackMouseUp);
    drawerRef.current.classList.add(css(drawer_default.modifiers.resizing));
    isResizing = true;
    setInitialVals = true;
  };
  const handleMouseMove = (e) => {
    const mousePos = position === "bottom" ? e.clientY : e.clientX;
    handleControlMove(e, mousePos);
  };
  const handleTouchMove = (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
    const touchPos = position === "bottom" ? e.touches[0].clientY : e.touches[0].clientX;
    handleControlMove(e, touchPos);
  };
  const handleControlMove = (e, controlPosition) => {
    const isRTL = getLanguageDirection(panel.current) === "rtl";
    e.stopPropagation();
    if (!isResizing) {
      return;
    }
    if (setInitialVals) {
      panelRect = panel.current.getBoundingClientRect();
      if (isRTL) {
        start3 = panelRect.right;
        end2 = panelRect.left;
      } else {
        end2 = panelRect.right;
        start3 = panelRect.left;
      }
      bottom3 = panelRect.bottom;
      setInitialVals = false;
    }
    const mousePos = controlPosition;
    let newSize2 = 0;
    if (position === "end" || position === "right") {
      newSize2 = isRTL ? mousePos - end2 : end2 - mousePos;
    } else if (position === "start" || position === "left") {
      newSize2 = isRTL ? start3 - mousePos : mousePos - start3;
    } else {
      newSize2 = bottom3 - mousePos;
    }
    if (position === "bottom") {
      panel.current.style.overflowAnchor = "none";
    }
    panel.current.style.setProperty(c_drawer_panel_md_FlexBasis_default.name, newSize2 + "px");
    currWidth = newSize2;
    setSeparatorValue(calcValueNow());
  };
  const handleMouseup = (e) => {
    if (!isResizing) {
      return;
    }
    drawerRef.current.classList.remove(css(drawer_default.modifiers.resizing));
    isResizing = false;
    onResize && onResize(e, currWidth, id2);
    setInitialVals = true;
    document.removeEventListener("mousemove", callbackMouseMove);
    document.removeEventListener("mouseup", callbackMouseUp);
  };
  const handleTouchEnd = (e) => {
    e.stopPropagation();
    if (!isResizing) {
      return;
    }
    isResizing = false;
    onResize && onResize(e, currWidth, id2);
    document.removeEventListener("touchmove", callbackTouchMove);
    document.removeEventListener("touchend", callbackTouchEnd);
  };
  const callbackMouseMove = React143.useCallback(handleMouseMove, []);
  const callbackTouchEnd = React143.useCallback(handleTouchEnd, []);
  const callbackTouchMove = React143.useCallback(handleTouchMove, []);
  const callbackMouseUp = React143.useCallback(handleMouseup, []);
  const handleKeys = (e) => {
    const isRTL = getLanguageDirection(panel.current) === "rtl";
    const key = e.key;
    if (key !== "Escape" && key !== "Enter" && key !== "ArrowUp" && key !== "ArrowDown" && key !== "ArrowLeft" && key !== "ArrowRight") {
      if (isResizing) {
        e.preventDefault();
      }
      return;
    }
    e.preventDefault();
    if (key === "Escape" || key === "Enter") {
      onResize && onResize(e, currWidth, id2);
    }
    const panelRect2 = panel.current.getBoundingClientRect();
    newSize = position === "bottom" ? panelRect2.height : panelRect2.width;
    let delta = 0;
    if (key === "ArrowRight") {
      if (isRTL) {
        delta = position === "left" || position === "start" ? -increment : increment;
      } else {
        delta = position === "left" || position === "start" ? increment : -increment;
      }
    } else if (key === "ArrowLeft") {
      if (isRTL) {
        delta = position === "left" || position === "start" ? increment : -increment;
      } else {
        delta = position === "left" || position === "start" ? -increment : increment;
      }
    } else if (key === "ArrowUp") {
      delta = increment;
    } else if (key === "ArrowDown") {
      delta = -increment;
    }
    newSize = newSize + delta;
    if (position === "bottom") {
      panel.current.style.overflowAnchor = "none";
    }
    panel.current.style.setProperty(c_drawer_panel_md_FlexBasis_default.name, newSize + "px");
    currWidth = newSize;
    setSeparatorValue(calcValueNow());
  };
  const boundaryCssVars = {};
  if (defaultSize) {
    boundaryCssVars[c_drawer_panel_md_FlexBasis_default.name] = defaultSize;
  }
  if (minSize) {
    boundaryCssVars[c_drawer_panel_md_FlexBasis_min_default.name] = minSize;
  }
  if (maxSize) {
    boundaryCssVars[c_drawer_panel_md_FlexBasis_max_default.name] = maxSize;
  }
  const isValidFocusTrap = (focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.enabled) && !isStatic;
  const Component50 = isValidFocusTrap ? FocusTrap : "div";
  return React143.createElement(GenerateId, { prefix: "pf-drawer-panel-" }, (panelId) => {
    const focusTrapProps = {
      tabIndex: -1,
      "aria-modal": true,
      role: "dialog",
      active: isFocusTrapActive,
      "aria-labelledby": (focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap["aria-labelledby"]) || id2 || panelId,
      focusTrapOptions: {
        fallbackFocus: () => panel.current,
        onActivate: () => {
          if (previouslyFocusedElement.current !== document.activeElement) {
            previouslyFocusedElement.current = document.activeElement;
          }
        },
        onDeactivate: () => {
          previouslyFocusedElement.current && previouslyFocusedElement.current.focus && previouslyFocusedElement.current.focus();
        },
        clickOutsideDeactivates: true,
        returnFocusOnDeactivate: false,
        // FocusTrap's initialFocus can accept false as a value to prevent initial focus.
        // We want to prevent this in case false is ever passed in.
        initialFocus: (focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.elementToFocusOnExpand) || void 0,
        escapeDeactivates: false
      }
    };
    return React143.createElement(Component50, Object.assign({}, isValidFocusTrap && focusTrapProps, { id: id2 || panelId, className: css(drawer_default.drawerPanel, isResizable && drawer_default.modifiers.resizable, hasNoBorder && drawer_default.modifiers.noBorder, formatBreakpointMods(widths, drawer_default), colorVariant === DrawerColorVariant.noBackground && drawer_default.modifiers.noBackground, colorVariant === DrawerColorVariant.secondary && drawer_default.modifiers.secondary, className), onTransitionEnd: (ev) => {
      if (ev.target === panel.current) {
        if (!hidden && ev.nativeEvent.propertyName === "transform") {
          onExpand(ev);
        }
        setIsExpandedInternal(!hidden);
        if (isValidFocusTrap && ev.nativeEvent.propertyName === "transform") {
          setIsFocusTrapActive((prevIsFocusTrapActive) => !prevIsFocusTrapActive);
        }
      }
    }, hidden }, (defaultSize || minSize || maxSize) && {
      style: boundaryCssVars
    }, props, { ref: panel }), isExpandedInternal && React143.createElement(
      React143.Fragment,
      null,
      isResizable && React143.createElement(
        React143.Fragment,
        null,
        React143.createElement(
          "div",
          { className: css(drawer_default.drawerSplitter, position !== "bottom" && drawer_default.modifiers.vertical), role: "separator", tabIndex: 0, "aria-orientation": position === "bottom" ? "horizontal" : "vertical", "aria-label": resizeAriaLabel, "aria-valuenow": separatorValue, "aria-valuemin": 0, "aria-valuemax": 100, "aria-controls": id2 || panelId, onMouseDown: handleMousedown, onKeyDown: handleKeys, onTouchStart: handleTouchStart, ref: splitterRef },
          React143.createElement("div", { className: css(drawer_default.drawerSplitterHandle), "aria-hidden": true })
        ),
        React143.createElement("div", { className: css(drawer_default.drawerPanelMain) }, children2)
      ),
      !isResizable && children2
    ));
  });
};
DrawerPanelContent.displayName = "DrawerPanelContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Drawer/DrawerSection.js
var React144 = __toESM(require_react());
var DrawerSection = (_a2) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className = "",
    children: children2,
    colorVariant = DrawerColorVariant.default
  } = _a2, props = __rest(_a2, ["className", "children", "colorVariant"]);
  return React144.createElement("div", Object.assign({ className: css(drawer_default.drawerSection, colorVariant === DrawerColorVariant.noBackground && drawer_default.modifiers.noBackground, colorVariant === DrawerColorVariant.secondary && drawer_default.modifiers.secondary, className) }, props), children2);
};
DrawerSection.displayName = "DrawerSection";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/Dropdown.js
var import_react15 = __toESM(require_react());
var DropdownBase = (_a2) => {
  var { children: children2, className, onSelect, isOpen, toggle, shouldFocusToggleOnSelect = false, onOpenChange, isPlain, isScrollable, innerRef, ouiaId, ouiaSafe = true, zIndex = 9999, popperProps, onOpenChangeKeys = ["Escape", "Tab"], menuHeight, maxMenuHeight } = _a2, props = __rest(_a2, ["children", "className", "onSelect", "isOpen", "toggle", "shouldFocusToggleOnSelect", "onOpenChange", "isPlain", "isScrollable", "innerRef", "ouiaId", "ouiaSafe", "zIndex", "popperProps", "onOpenChangeKeys", "menuHeight", "maxMenuHeight"]);
  const localMenuRef = import_react15.default.useRef();
  const localToggleRef = import_react15.default.useRef();
  const ouiaProps = useOUIAProps(Dropdown.displayName, ouiaId, ouiaSafe);
  const menuRef = innerRef || localMenuRef;
  const toggleRef = typeof toggle === "function" || typeof toggle !== "function" && !toggle.toggleRef ? localToggleRef : toggle === null || toggle === void 0 ? void 0 : toggle.toggleRef;
  import_react15.default.useEffect(() => {
    const handleMenuKeys = (event) => {
      var _a3, _b, _c;
      if (isOpen && onOpenChange && (((_a3 = menuRef.current) === null || _a3 === void 0 ? void 0 : _a3.contains(event.target)) || ((_b = toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)))) {
        if (onOpenChangeKeys.includes(event.key)) {
          onOpenChange(false);
          (_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.focus();
        }
      }
    };
    const handleClick = (event) => {
      var _a3, _b, _c;
      if (isOpen && ((_a3 = toggleRef.current) === null || _a3 === void 0 ? void 0 : _a3.contains(event.target))) {
        setTimeout(() => {
          var _a4;
          const firstElement = (_a4 = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a4 === void 0 ? void 0 : _a4.querySelector('li button:not(:disabled),li input:not(:disabled),li a:not([aria-disabled="true"])');
          firstElement && firstElement.focus();
        }, 0);
      }
      if (isOpen && onOpenChange && !((_b = toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
        if (isOpen && !((_c = menuRef.current) === null || _c === void 0 ? void 0 : _c.contains(event.target))) {
          onOpenChange(false);
        }
      }
    };
    window.addEventListener("keydown", handleMenuKeys);
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("keydown", handleMenuKeys);
      window.removeEventListener("click", handleClick);
    };
  }, [isOpen, menuRef, toggleRef, onOpenChange, onOpenChangeKeys]);
  const scrollable = maxMenuHeight !== void 0 || menuHeight !== void 0 || isScrollable;
  const menu = import_react15.default.createElement(
    Menu,
    Object.assign({ className: css(className), ref: menuRef, onSelect: (event, value) => {
      onSelect && onSelect(event, value);
      shouldFocusToggleOnSelect && toggleRef.current.focus();
    }, isPlain, isScrollable: scrollable }, props, ouiaProps),
    import_react15.default.createElement(MenuContent, { menuHeight, maxMenuHeight }, children2)
  );
  return import_react15.default.createElement(Popper, Object.assign({ trigger: typeof toggle === "function" ? toggle(toggleRef) : toggle.toggleNode, triggerRef: toggleRef, popper: menu, popperRef: menuRef, isVisible: isOpen, zIndex }, popperProps));
};
var Dropdown = import_react15.default.forwardRef((props, ref) => import_react15.default.createElement(DropdownBase, Object.assign({ innerRef: ref }, props)));
Dropdown.displayName = "Dropdown";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownGroup.js
var import_react16 = __toESM(require_react());
var DropdownGroup = (_a2) => {
  var { children: children2, className, label, labelHeadingLevel = "h1" } = _a2, props = __rest(_a2, ["children", "className", "label", "labelHeadingLevel"]);
  return import_react16.default.createElement(MenuGroup, Object.assign({ className: css(className), label, labelHeadingLevel }, props), children2);
};
DropdownGroup.displayName = "DropdownGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownItem.js
var import_react17 = __toESM(require_react());
var DropdownItemBase = (_a2) => {
  var { children: children2, className, description, isDisabled, isAriaDisabled, value, onClick, ouiaId, ouiaSafe, innerRef, tooltipProps } = _a2, props = __rest(_a2, ["children", "className", "description", "isDisabled", "isAriaDisabled", "value", "onClick", "ouiaId", "ouiaSafe", "innerRef", "tooltipProps"]);
  const ouiaProps = useOUIAProps(DropdownItem.displayName, ouiaId, ouiaSafe);
  return import_react17.default.createElement(MenuItem, Object.assign({ className: css(className), description, isDisabled, isAriaDisabled, itemId: value, onClick, tooltipProps, ref: innerRef }, ouiaProps, props), children2);
};
var DropdownItem = import_react17.default.forwardRef((props, ref) => import_react17.default.createElement(DropdownItemBase, Object.assign({}, props, { innerRef: ref })));
DropdownItem.displayName = "DropdownItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownList.js
var import_react18 = __toESM(require_react());
var DropdownList = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return import_react18.default.createElement(MenuList, Object.assign({ className: css(className) }, props), children2);
};
DropdownList.displayName = "DropdownList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelector.js
var React150 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/DualListSelector/dual-list-selector.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/DualListSelector/dual-list-selector.css";
var dual_list_selector_default = {
  "badge": "pf-v6-c-badge",
  "button": "pf-v6-c-button",
  "dirRtl": "pf-v6-m-dir-rtl",
  "dualListSelector": "pf-v6-c-dual-list-selector",
  "dualListSelectorControls": "pf-v6-c-dual-list-selector__controls",
  "dualListSelectorControlsItem": "pf-v6-c-dual-list-selector__controls-item",
  "dualListSelectorDraggable": "pf-v6-c-dual-list-selector__draggable",
  "dualListSelectorHeader": "pf-v6-c-dual-list-selector__header",
  "dualListSelectorItem": "pf-v6-c-dual-list-selector__item",
  "dualListSelectorItemCheck": "pf-v6-c-dual-list-selector__item-check",
  "dualListSelectorItemCount": "pf-v6-c-dual-list-selector__item-count",
  "dualListSelectorItemMain": "pf-v6-c-dual-list-selector__item-main",
  "dualListSelectorItemText": "pf-v6-c-dual-list-selector__item-text",
  "dualListSelectorItemToggle": "pf-v6-c-dual-list-selector__item-toggle",
  "dualListSelectorItemToggleIcon": "pf-v6-c-dual-list-selector__item-toggle-icon",
  "dualListSelectorList": "pf-v6-c-dual-list-selector__list",
  "dualListSelectorListItem": "pf-v6-c-dual-list-selector__list-item",
  "dualListSelectorListItemRow": "pf-v6-c-dual-list-selector__list-item-row",
  "dualListSelectorMain": "pf-v6-c-dual-list-selector__main",
  "dualListSelectorMenu": "pf-v6-c-dual-list-selector__menu",
  "dualListSelectorPane": "pf-v6-c-dual-list-selector__pane",
  "dualListSelectorStatus": "pf-v6-c-dual-list-selector__status",
  "dualListSelectorStatusText": "pf-v6-c-dual-list-selector__status-text",
  "dualListSelectorTitleText": "pf-v6-c-dual-list-selector__title-text",
  "dualListSelectorTools": "pf-v6-c-dual-list-selector__tools",
  "dualListSelectorToolsActions": "pf-v6-c-dual-list-selector__tools-actions",
  "dualListSelectorToolsFilter": "pf-v6-c-dual-list-selector__tools-filter",
  "modifiers": {
    "chosen": "pf-m-chosen",
    "dragOver": "pf-m-drag-over",
    "expandable": "pf-m-expandable",
    "expanded": "pf-m-expanded",
    "disabled": "pf-m-disabled",
    "selected": "pf-m-selected",
    "check": "pf-m-check",
    "ghostRow": "pf-m-ghost-row",
    "read": "pf-m-read"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorContext.js
var React149 = __toESM(require_react());
var DualListSelectorContext = React149.createContext({ isTree: false });
var DualListSelectorListContext = React149.createContext({});
var DualListSelectorPaneContext = React149.createContext({ isChosen: false });

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelector.js
var DualListSelector = class extends React150.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const _a2 = this.props, { className, children: children2, id: id2, isTree } = _a2, props = __rest(_a2, ["className", "children", "id", "isTree"]);
    return React150.createElement(
      DualListSelectorContext.Provider,
      { value: { isTree } },
      React150.createElement(GenerateId, null, (randomId) => React150.createElement("div", Object.assign({ className: css(dual_list_selector_default.dualListSelector, className), id: id2 || randomId }, props), children2))
    );
  }
};
DualListSelector.displayName = "DualListSelector";
DualListSelector.defaultProps = {
  children: "",
  isTree: false
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorControl.js
var React151 = __toESM(require_react());
var DualListSelectorControlBase = (_a2) => {
  var { innerRef, children: children2, className, "aria-label": ariaLabel, isDisabled = true, onClick = () => {
  }, tooltipContent, tooltipProps = {} } = _a2, props = __rest(_a2, ["innerRef", "children", "className", "aria-label", "isDisabled", "onClick", "tooltipContent", "tooltipProps"]);
  const privateRef = React151.useRef(null);
  const ref = innerRef || privateRef;
  return React151.createElement(
    "div",
    Object.assign({ className: css(dual_list_selector_default.dualListSelectorControlsItem, className) }, props),
    React151.createElement(Button, { isDisabled, "aria-disabled": isDisabled, variant: ButtonVariant.plain, onClick, "aria-label": ariaLabel, tabIndex: -1, ref }, children2),
    tooltipContent && React151.createElement(Tooltip, Object.assign({ content: tooltipContent, position: "left", triggerRef: ref }, tooltipProps))
  );
};
DualListSelectorControlBase.displayName = "DualListSelectorControlBase";
var DualListSelectorControl = React151.forwardRef((props, ref) => React151.createElement(DualListSelectorControlBase, Object.assign({ innerRef: ref }, props)));
DualListSelectorControl.displayName = "DualListSelectorControl";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorControlsWrapper.js
var React152 = __toESM(require_react());
var DualListSelectorControlsWrapperBase = (_a2) => {
  var { innerRef, children: children2 = null, className, "aria-label": ariaLabel = "Controls for moving options between lists" } = _a2, props = __rest(_a2, ["innerRef", "children", "className", "aria-label"]);
  const ref = React152.useRef(null);
  const wrapperRef = innerRef || ref;
  const handleKeys = (event) => {
    if (!wrapperRef.current || wrapperRef.current !== event.target.closest(`.${dual_list_selector_default.dualListSelectorControls}`) && !Array.from(wrapperRef.current.getElementsByClassName(dual_list_selector_default.dualListSelectorControls)).includes(event.target.closest(`.${dual_list_selector_default.dualListSelectorControls}`))) {
      return;
    }
    event.stopImmediatePropagation();
    const controls = Array.from(wrapperRef.current.getElementsByTagName("BUTTON")).filter((el) => !el.classList.contains("pf-m-disabled"));
    const activeElement = document.activeElement;
    handleArrows(event, controls, (element) => activeElement.contains(element), (element) => element, void 0, void 0, true, false);
  };
  React152.useEffect(() => {
    window.addEventListener("keydown", handleKeys);
    return () => {
      window.removeEventListener("keydown", handleKeys);
    };
  }, [wrapperRef.current]);
  return React152.createElement("div", Object.assign({ className: css(dual_list_selector_default.dualListSelectorControls, className), tabIndex: 0, ref: wrapperRef, "aria-label": ariaLabel }, props), children2);
};
DualListSelectorControlsWrapperBase.displayName = "DualListSelectorControlsWrapperBase";
var DualListSelectorControlsWrapper = React152.forwardRef((props, ref) => React152.createElement(DualListSelectorControlsWrapperBase, Object.assign({ innerRef: ref, role: "group" }, props)));
DualListSelectorControlsWrapper.displayName = "DualListSelectorControlsWrapper";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorPane.js
var React180 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorListWrapper.js
var React155 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorListItem.js
var React153 = __toESM(require_react());
var DualListSelectorListItemBase = (_a2) => {
  var {
    onOptionSelect,
    orderIndex,
    children: children2,
    className,
    id: id2 = getUniqueId("dual-list-selector-list-item"),
    isSelected,
    innerRef,
    isDraggable = false,
    isDisabled,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    draggableButtonAriaLabel = "Reorder option"
  } = _a2, props = __rest(_a2, ["onOptionSelect", "orderIndex", "children", "className", "id", "isSelected", "innerRef", "isDraggable", "isDisabled", "draggableButtonAriaLabel"]);
  const privateRef = React153.useRef(null);
  const ref = innerRef || privateRef;
  const { setFocusedOption } = React153.useContext(DualListSelectorListContext);
  return React153.createElement(
    "li",
    Object.assign({ className: css(dual_list_selector_default.dualListSelectorListItem, className, isDisabled && dual_list_selector_default.modifiers.disabled), key: orderIndex, onClick: isDisabled ? void 0 : (e) => {
      setFocusedOption(id2);
      onOptionSelect(e, id2);
    }, onKeyDown: (e) => {
      if (e.key === " " || e.key === "Enter") {
        document.activeElement.click();
        e.preventDefault();
      }
    }, "aria-selected": isSelected, id: id2, ref, role: "option", tabIndex: -1 }, props),
    React153.createElement(
      "div",
      { className: css(dual_list_selector_default.dualListSelectorListItemRow, isSelected && dual_list_selector_default.modifiers.selected) },
      isDraggable && !isDisabled && React153.createElement(
        "div",
        { className: css(dual_list_selector_default.dualListSelectorDraggable) },
        React153.createElement(
          Button,
          { variant: ButtonVariant.plain, component: "span" },
          React153.createElement(grip_vertical_icon_default, { style: { verticalAlign: "-0.3em" } })
        )
      ),
      React153.createElement(
        "span",
        { className: css(dual_list_selector_default.dualListSelectorItem) },
        React153.createElement(
          "span",
          { className: css(dual_list_selector_default.dualListSelectorItemMain) },
          React153.createElement("span", { className: css(dual_list_selector_default.dualListSelectorItemText) }, children2)
        )
      )
    )
  );
};
DualListSelectorListItemBase.displayName = "DualListSelectorListItemBase";
var DualListSelectorListItem = React153.forwardRef((props, ref) => React153.createElement(DualListSelectorListItemBase, Object.assign({ innerRef: ref }, props)));
DualListSelectorListItem.displayName = "DualListSelectorListItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorList.js
var React154 = __toESM(require_react());
var DualListSelectorList = (_a2) => {
  var { children: children2 } = _a2, props = __rest(_a2, ["children"]);
  const { isTree, ariaLabelledBy, focusedOption, displayOption, selectedOptions, id: id2, options, isDisabled } = React154.useContext(DualListSelectorListContext);
  const hasOptions = () => options.length !== 0 || children2 !== void 0 && children2.length !== 0;
  return React154.createElement("ul", Object.assign({ className: css(dual_list_selector_default.dualListSelectorList) }, hasOptions() && {
    role: isTree ? "tree" : "listbox",
    "aria-multiselectable": true,
    "aria-labelledby": ariaLabelledBy,
    "aria-activedescendant": focusedOption
  }, { "aria-disabled": isDisabled ? "true" : void 0 }, props), options.length === 0 ? children2 : options.map((option, index4) => {
    if (displayOption(option)) {
      return React154.createElement(DualListSelectorListItem, { key: index4, isSelected: selectedOptions.indexOf(index4) !== -1, id: `${id2}-option-${index4}`, orderIndex: index4, isDisabled }, option);
    }
    return;
  }));
};
DualListSelectorList.displayName = "DualListSelectorList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorListWrapper.js
var DualListSelectorListWrapperBase = (_a2) => {
  var { className, children: children2, "aria-labelledby": ariaLabelledBy, innerRef, options = [], selectedOptions = [], displayOption, id: id2 = getUniqueId("dual-list-selector-list"), isDisabled = false } = _a2, props = __rest(_a2, ["className", "children", "aria-labelledby", "innerRef", "options", "selectedOptions", "displayOption", "id", "isDisabled"]);
  const [focusedOption, setFocusedOption] = React155.useState("");
  const ref = React155.useRef(null);
  const menuRef = innerRef || ref;
  const { isTree } = React155.useContext(DualListSelectorContext);
  const handleKeys = (event) => {
    if (!menuRef.current || menuRef.current !== event.target.closest(`.${dual_list_selector_default.dualListSelectorMenu}`) && !Array.from(menuRef.current.getElementsByClassName(dual_list_selector_default.dualListSelectorMenu)).includes(event.target.closest(`.${dual_list_selector_default.dualListSelectorMenu}`))) {
      return;
    }
    event.stopImmediatePropagation();
    const validOptions = isTree ? Array.from(menuRef.current.querySelectorAll(`.${dual_list_selector_default.dualListSelectorItemToggle}, .${dual_list_selector_default.dualListSelectorItemCheck} > input`)) : Array.from(menuRef.current.getElementsByTagName("LI")).filter((el) => !el.classList.contains("pf-m-disabled"));
    const activeElement = document.activeElement;
    handleArrows(event, validOptions, (element) => activeElement.contains(element), (element) => {
      if (element.classList.contains(`.${dual_list_selector_default.dualListSelectorListItem}`)) {
        setFocusedOption(element.id);
      } else {
        setFocusedOption(element.closest(`.${dual_list_selector_default.dualListSelectorListItem}`).id);
      }
      return element;
    }, [`.${dual_list_selector_default.dualListSelectorItemToggle}`, `.${dual_list_selector_default.dualListSelectorItemCheck} > input`], void 0, false, false, false);
  };
  React155.useEffect(() => {
    window.addEventListener("keydown", handleKeys);
    return () => {
      window.removeEventListener("keydown", handleKeys);
    };
  }, [menuRef.current]);
  return React155.createElement(
    "div",
    Object.assign({ className: css(dual_list_selector_default.dualListSelectorMenu, className), ref: menuRef, tabIndex: 0 }, props),
    React155.createElement(DualListSelectorListContext.Provider, { value: {
      setFocusedOption,
      isTree,
      focusedOption,
      ariaLabelledBy,
      displayOption,
      selectedOptions,
      id: id2,
      options,
      isDisabled
    } }, children2 ? children2 : React155.createElement(DualListSelectorList, null))
  );
};
DualListSelectorListWrapperBase.displayName = "DualListSelectorListWrapperBase";
var DualListSelectorListWrapper = React155.forwardRef((props, ref) => React155.createElement(DualListSelectorListWrapperBase, Object.assign({ innerRef: ref }, props)));
DualListSelectorListWrapper.displayName = "DualListSelectorListWrapper";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SearchInput/SearchInput.js
var React179 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Icon/Icon.js
var React156 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Icon/icon.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Icon/icon.css";
var icon_default = {
  "icon": "pf-v6-c-icon",
  "iconContent": "pf-v6-c-icon__content",
  "iconProgress": "pf-v6-c-icon__progress",
  "modifiers": {
    "inline": "pf-m-inline",
    "sm": "pf-m-sm",
    "md": "pf-m-md",
    "lg": "pf-m-lg",
    "xl": "pf-m-xl",
    "2xl": "pf-m-2xl",
    "3xl": "pf-m-3xl",
    "bodySm": "pf-m-body-sm",
    "bodyDefault": "pf-m-body-default",
    "bodyLg": "pf-m-body-lg",
    "headingSm": "pf-m-heading-sm",
    "headingMd": "pf-m-heading-md",
    "headingLg": "pf-m-heading-lg",
    "headingXl": "pf-m-heading-xl",
    "heading_2xl": "pf-m-heading-2xl",
    "heading_3xl": "pf-m-heading-3xl",
    "inProgress": "pf-m-in-progress",
    "danger": "pf-m-danger",
    "warning": "pf-m-warning",
    "success": "pf-m-success",
    "info": "pf-m-info",
    "custom": "pf-m-custom"
  },
  "spinner": "pf-v6-c-spinner"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Icon/Icon.js
var Icon = (_a2) => {
  var { children: children2, className, progressIcon, size, iconSize, progressIconSize, status, isInline = false, isInProgress = false, defaultProgressArialabel = "Loading...", shouldMirrorRTL = false } = _a2, props = __rest(_a2, ["children", "className", "progressIcon", "size", "iconSize", "progressIconSize", "status", "isInline", "isInProgress", "defaultProgressArialabel", "shouldMirrorRTL"]);
  const _progressIcon = progressIcon !== null && progressIcon !== void 0 ? progressIcon : React156.createElement(Spinner, { diameter: "1em", "aria-label": defaultProgressArialabel });
  return React156.createElement(
    "span",
    Object.assign({ className: css(icon_default.icon, isInline && icon_default.modifiers.inline, isInProgress && icon_default.modifiers.inProgress, icon_default.modifiers[size], className) }, props),
    React156.createElement("span", { className: css(icon_default.iconContent, icon_default.modifiers[iconSize], icon_default.modifiers[status], shouldMirrorRTL && "pf-v6-m-mirror-inline-rtl") }, children2),
    isInProgress && React156.createElement("span", { className: css(icon_default.iconProgress, icon_default.modifiers[progressIconSize], className) }, _progressIcon)
  );
};
Icon.displayName = "Icon";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/angle-down-icon.js
var AngleDownIconConfig = {
  name: "AngleDownIcon",
  height: 512,
  width: 320,
  svgPath: "M143 352.3L7 216.3c-9.4-9.4-9.4-24.6 0-33.9l22.6-22.6c9.4-9.4 24.6-9.4 33.9 0l96.4 96.4 96.4-96.4c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9l-136 136c-9.2 9.4-24.4 9.4-33.8 0z",
  yOffset: 0,
  xOffset: 0
};
var AngleDownIcon = createIcon(AngleDownIconConfig);
var angle_down_icon_default = AngleDownIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/search-icon.js
var SearchIconConfig = {
  name: "SearchIcon",
  height: 512,
  width: 512,
  svgPath: "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z",
  yOffset: 0,
  xOffset: 0
};
var SearchIcon = createIcon(SearchIconConfig);
var search_icon_default = SearchIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/arrow-right-icon.js
var ArrowRightIconConfig = {
  name: "ArrowRightIcon",
  height: 512,
  width: 448,
  svgPath: "M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z",
  yOffset: 0,
  xOffset: 0
};
var ArrowRightIcon = createIcon(ArrowRightIconConfig);
var arrow_right_icon_default = ArrowRightIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SearchInput/AdvancedSearchMenu.js
var React175 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/ActionGroup.js
var React157 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Form/form.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Form/form.css";
var form_default = {
  "button": "pf-v6-c-button",
  "dirRtl": "pf-v6-m-dir-rtl",
  "form": "pf-v6-c-form",
  "formActions": "pf-v6-c-form__actions",
  "formFieldGroup": "pf-v6-c-form__field-group",
  "formFieldGroupBody": "pf-v6-c-form__field-group-body",
  "formFieldGroupHeader": "pf-v6-c-form__field-group-header",
  "formFieldGroupHeaderActions": "pf-v6-c-form__field-group-header-actions",
  "formFieldGroupHeaderDescription": "pf-v6-c-form__field-group-header-description",
  "formFieldGroupHeaderMain": "pf-v6-c-form__field-group-header-main",
  "formFieldGroupHeaderTitle": "pf-v6-c-form__field-group-header-title",
  "formFieldGroupHeaderTitleText": "pf-v6-c-form__field-group-header-title-text",
  "formFieldGroupToggle": "pf-v6-c-form__field-group-toggle",
  "formFieldGroupToggleButton": "pf-v6-c-form__field-group-toggle-button",
  "formFieldGroupToggleIcon": "pf-v6-c-form__field-group-toggle-icon",
  "formFieldset": "pf-v6-c-form__fieldset",
  "formGroup": "pf-v6-c-form__group",
  "formGroupControl": "pf-v6-c-form__group-control",
  "formGroupLabel": "pf-v6-c-form__group-label",
  "formGroupLabelHelp": "pf-v6-c-form__group-label-help",
  "formGroupLabelInfo": "pf-v6-c-form__group-label-info",
  "formGroupLabelMain": "pf-v6-c-form__group-label-main",
  "formHelperText": "pf-v6-c-form__helper-text",
  "formLabel": "pf-v6-c-form__label",
  "formLabelRequired": "pf-v6-c-form__label-required",
  "formLabelText": "pf-v6-c-form__label-text",
  "formSection": "pf-v6-c-form__section",
  "formSectionTitle": "pf-v6-c-form__section-title",
  "modifiers": {
    "horizontal": "pf-m-horizontal",
    "alignRight": "pf-m-align-right",
    "noPaddingTop": "pf-m-no-padding-top",
    "horizontalOnXs": "pf-m-horizontal-on-xs",
    "horizontalOnSm": "pf-m-horizontal-on-sm",
    "horizontalOnMd": "pf-m-horizontal-on-md",
    "horizontalOnLg": "pf-m-horizontal-on-lg",
    "horizontalOnXl": "pf-m-horizontal-on-xl",
    "horizontalOn_2xl": "pf-m-horizontal-on-2xl",
    "limitWidth": "pf-m-limit-width",
    "action": "pf-m-action",
    "info": "pf-m-info",
    "disabled": "pf-m-disabled",
    "inline": "pf-m-inline",
    "stack": "pf-m-stack",
    "inactive": "pf-m-inactive",
    "hidden": "pf-m-hidden",
    "expanded": "pf-m-expanded"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/ActionGroup.js
var ActionGroup = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  const customClassName = css(form_default.formGroup, form_default.modifiers.action, className);
  const formActionsComponent = React157.createElement("div", { className: css(form_default.formActions) }, children2);
  return React157.createElement(
    "div",
    Object.assign({}, props, { className: customClassName }),
    React157.createElement("div", { className: css(form_default.formGroupControl) }, formActionsComponent)
  );
};
ActionGroup.displayName = "ActionGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/Form.js
var React158 = __toESM(require_react());
var FormBase = (_a2) => {
  var { children: children2 = null, className = "", isHorizontal = false, isWidthLimited = false, maxWidth = "", innerRef } = _a2, props = __rest(_a2, ["children", "className", "isHorizontal", "isWidthLimited", "maxWidth", "innerRef"]);
  return React158.createElement("form", Object.assign({ noValidate: true }, maxWidth && {
    style: Object.assign({ [c_form_m_limit_width_MaxWidth_default.name]: maxWidth }, props.style)
  }, props, { className: css(form_default.form, isHorizontal && form_default.modifiers.horizontal, (isWidthLimited || maxWidth) && form_default.modifiers.limitWidth, className), ref: innerRef }), children2);
};
var Form = React158.forwardRef((props, ref) => React158.createElement(FormBase, Object.assign({ innerRef: ref }, props)));
Form.displayName = "Form";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormAlert.js
var React159 = __toESM(require_react());
var FormAlert = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return (
    // There are currently no associated styles with the pf-v6-c-form_alert class.
    // Therefore, it does not exist in react-styles
    React159.createElement("div", Object.assign({}, props, { className: css(`${form_default.form}__alert`, className) }), children2)
  );
};
FormAlert.displayName = "FormAlert";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormFieldGroup.js
var React162 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/InternalFormFieldGroup.js
var React161 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormFieldGroupToggle.js
var React160 = __toESM(require_react());
var FormFieldGroupToggle = (_a2) => {
  var { className, onToggle, isExpanded, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, toggleId } = _a2, props = __rest(_a2, ["className", "onToggle", "isExpanded", "aria-label", "aria-labelledby", "toggleId"]);
  return React160.createElement(
    "div",
    Object.assign({ className: css(form_default.formFieldGroupToggle, className) }, props),
    React160.createElement(
      "div",
      { className: css(form_default.formFieldGroupToggleButton) },
      React160.createElement(
        Button,
        { variant: "plain", "aria-label": ariaLabel, onClick: onToggle, "aria-expanded": isExpanded, "aria-labelledby": ariaLabelledby, id: toggleId },
        React160.createElement(
          "span",
          { className: css(form_default.formFieldGroupToggleIcon) },
          React160.createElement(angle_right_icon_default, { "aria-hidden": "true" })
        )
      )
    )
  );
};
FormFieldGroupToggle.displayName = "FormFieldGroupToggle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/InternalFormFieldGroup.js
var InternalFormFieldGroup = (_a2) => {
  var { children: children2, className, header, isExpandable, isExpanded, onToggle, toggleAriaLabel } = _a2, props = __rest(_a2, ["children", "className", "header", "isExpandable", "isExpanded", "onToggle", "toggleAriaLabel"]);
  const headerTitleText = header ? header.props.titleText : null;
  if (isExpandable && !toggleAriaLabel && !headerTitleText) {
    console.error("FormFieldGroupExpandable:", "toggleAriaLabel or the titleText prop of FormFieldGroupHeader is required to make the toggle button accessible");
  }
  return React161.createElement(
    "div",
    Object.assign({ className: css(form_default.formFieldGroup, isExpanded && isExpandable && form_default.modifiers.expanded, className), role: "group" }, headerTitleText && { "aria-labelledby": `${header.props.titleText.id}` }, props),
    isExpandable && React161.createElement(GenerateId, { prefix: "form-field-group-toggle" }, (id2) => React161.createElement(FormFieldGroupToggle, Object.assign({ onToggle, isExpanded, "aria-label": toggleAriaLabel, toggleId: id2 }, headerTitleText && { "aria-labelledby": `${header.props.titleText.id} ${id2}` }))),
    header && header,
    (!isExpandable || isExpandable && isExpanded) && React161.createElement("div", { className: css(form_default.formFieldGroupBody) }, children2)
  );
};
InternalFormFieldGroup.displayName = "InternalFormFieldGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormFieldGroup.js
var FormFieldGroup = (_a2) => {
  var { children: children2, className, header } = _a2, props = __rest(_a2, ["children", "className", "header"]);
  return React162.createElement(InternalFormFieldGroup, Object.assign({ className, header }, props), children2);
};
FormFieldGroup.displayName = "FormFieldGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormFieldGroupExpandable.js
var React163 = __toESM(require_react());
var import_react19 = __toESM(require_react());
var FormFieldGroupExpandable = (_a2) => {
  var { children: children2, className, header, isExpanded = false, toggleAriaLabel } = _a2, props = __rest(_a2, ["children", "className", "header", "isExpanded", "toggleAriaLabel"]);
  const [localIsExpanded, setIsExpanded] = (0, import_react19.useState)(isExpanded);
  return React163.createElement(InternalFormFieldGroup, Object.assign({ className, header, isExpandable: true, isExpanded: localIsExpanded, toggleAriaLabel, onToggle: () => setIsExpanded(!localIsExpanded) }, props), children2);
};
FormFieldGroupExpandable.displayName = "FormFieldGroupExpandable";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormFieldGroupHeader.js
var React164 = __toESM(require_react());
var FormFieldGroupHeader = (_a2) => {
  var { className, titleText, titleDescription, actions } = _a2, props = __rest(_a2, ["className", "titleText", "titleDescription", "actions"]);
  return React164.createElement(
    "div",
    Object.assign({ className: css(form_default.formFieldGroupHeader, className) }, props),
    React164.createElement(
      "div",
      { className: css(form_default.formFieldGroupHeaderMain) },
      titleText && React164.createElement(
        "div",
        { className: css(form_default.formFieldGroupHeaderTitle) },
        React164.createElement("div", { className: css(form_default.formFieldGroupHeaderTitleText), id: titleText.id }, titleText.text)
      ),
      titleDescription && React164.createElement("div", { className: css(form_default.formFieldGroupHeaderDescription) }, titleDescription)
    ),
    React164.createElement("div", { className: css(form_default.formFieldGroupHeaderActions) }, actions && actions)
  );
};
FormFieldGroupHeader.displayName = "FormFieldGroupHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormGroup.js
var React165 = __toESM(require_react());
var FormGroup = (_a2) => {
  var { children: children2 = null, className = "", label, labelInfo, labelHelp, isRequired = false, isInline = false, hasNoPaddingTop = false, isStack = false, fieldId, role } = _a2, props = __rest(_a2, ["children", "className", "label", "labelInfo", "labelHelp", "isRequired", "isInline", "hasNoPaddingTop", "isStack", "fieldId", "role"]);
  const isGroupOrRadioGroup = role === "group" || role === "radiogroup";
  const LabelComponent = isGroupOrRadioGroup ? "span" : "label";
  const labelContent = React165.createElement(
    React165.Fragment,
    null,
    React165.createElement(
      LabelComponent,
      Object.assign({ className: css(form_default.formLabel) }, !isGroupOrRadioGroup && { htmlFor: fieldId }),
      React165.createElement("span", { className: css(form_default.formLabelText) }, label),
      isRequired && React165.createElement(
        "span",
        { className: css(form_default.formLabelRequired), "aria-hidden": "true" },
        " ",
        ASTERISK
      )
    ),
    React165.createElement(React165.Fragment, null, "Â Â "),
    React165.isValidElement(labelHelp) && React165.createElement("span", { className: form_default.formGroupLabelHelp }, labelHelp)
  );
  return React165.createElement(GenerateId, null, (randomId) => React165.createElement(
    "div",
    Object.assign({ className: css(form_default.formGroup, className) }, role && { role }, isGroupOrRadioGroup && { "aria-labelledby": `${fieldId || randomId}-legend` }, props),
    label && React165.createElement(
      "div",
      Object.assign({ className: css(form_default.formGroupLabel, labelInfo && form_default.modifiers.info, hasNoPaddingTop && form_default.modifiers.noPaddingTop) }, isGroupOrRadioGroup && { id: `${fieldId || randomId}-legend` }),
      labelInfo && React165.createElement(
        React165.Fragment,
        null,
        React165.createElement("div", { className: css(form_default.formGroupLabelMain) }, labelContent),
        React165.createElement("div", { className: css(form_default.formGroupLabelInfo) }, labelInfo)
      ),
      !labelInfo && labelContent
    ),
    React165.createElement("div", { className: css(form_default.formGroupControl, isInline && form_default.modifiers.inline, isStack && form_default.modifiers.stack) }, children2)
  ));
};
FormGroup.displayName = "FormGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormGroupLabelHelp.js
var import_react20 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/question-circle-icon.js
var QuestionCircleIconConfig = {
  name: "QuestionCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z",
  yOffset: 0,
  xOffset: 0
};
var QuestionCircleIcon = createIcon(QuestionCircleIconConfig);
var question_circle_icon_default = QuestionCircleIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormGroupLabelHelp.js
var FormGroupLabelHelpBase = (_a2) => {
  var { "aria-label": ariaLabel, className, innerRef } = _a2, props = __rest(_a2, ["aria-label", "className", "innerRef"]);
  const ref = import_react20.default.useRef(null);
  const buttonRef = innerRef || ref;
  const isMutableRef = (ref2) => typeof ref2 === "object" && ref2 !== null && "current" in ref2 && ref2.current !== void 0;
  const handleKeyDown = (event) => {
    if ([KeyTypes.Space, KeyTypes.Enter].includes(event.key) && isMutableRef(buttonRef) && buttonRef.current) {
      event.preventDefault();
      buttonRef.current.click();
    }
  };
  return import_react20.default.createElement(
    Button,
    Object.assign({ component: "span", isInline: true, ref: buttonRef, onKeyDown: handleKeyDown, "aria-label": ariaLabel, className, variant: "plain", hasNoPadding: true }, props),
    import_react20.default.createElement(question_circle_icon_default, null)
  );
};
var FormGroupLabelHelp = import_react20.default.forwardRef((props, ref) => import_react20.default.createElement(FormGroupLabelHelpBase, Object.assign({ innerRef: ref }, props)));
FormGroupLabelHelp.displayName = "FormGroupLabelHelp";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormHelperText.js
var React167 = __toESM(require_react());
var FormHelperText = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React167.createElement("div", Object.assign({ className: css(form_default.formHelperText, className) }, props), children2);
};
FormHelperText.displayName = "FormHelperText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormSection.js
var React168 = __toESM(require_react());
var FormSection = (_a2) => {
  var { className = "", children: children2, title = "", titleElement: TitleElement = "div" } = _a2, props = __rest(_a2, ["className", "children", "title", "titleElement"]);
  return React168.createElement(GenerateId, { prefix: "pf-form-section-title" }, (sectionId) => React168.createElement(
    "section",
    Object.assign({ className: css(form_default.formSection, className), role: "group" }, title && { "aria-labelledby": sectionId }, props),
    title && React168.createElement(TitleElement, { id: sectionId, className: css(form_default.formSectionTitle, className) }, title),
    children2
  ));
};
FormSection.displayName = "FormSection";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Form/FormContext.js
var import_react21 = __toESM(require_react());
var FormContext = import_react21.default.createContext({});
var FormContextConsumer = FormContext.Consumer;
var FormContextProvider = ({ initialValues, children: children2 }) => {
  var _a2;
  const [values, setValues] = import_react21.default.useState(initialValues || {});
  const [errors2, setErrors] = import_react21.default.useState({});
  const [validators, setValidators] = import_react21.default.useState({});
  const [touched, setTouched] = import_react21.default.useState({});
  const isValid = ((_a2 = Object.keys(errors2)) === null || _a2 === void 0 ? void 0 : _a2.length) === 0;
  const getValue = (fieldId) => Object.entries(values).reduce((acc, [id2, value]) => id2 === fieldId ? value : acc, "");
  const setValue = (fieldId, value, triggerValidation = true) => {
    var _a3;
    if (values[fieldId] !== value) {
      setValues((prevValues) => Object.assign(Object.assign({}, prevValues), { [fieldId]: value }));
      triggerValidation && ((_a3 = validators[fieldId]) === null || _a3 === void 0 ? void 0 : _a3.call(validators, value));
    }
  };
  const getError = (fieldId) => Object.entries(errors2).reduce((acc, [id2, error]) => id2 === fieldId ? error : acc, "");
  const setError = (fieldId, error) => errors2[fieldId] !== error && setErrors((_a3) => {
    var _b = fieldId, _14 = _a3[_b], prevErrors = __rest(_a3, [typeof _b === "symbol" ? _b : _b + ""]);
    return Object.assign(Object.assign({}, prevErrors), !!error && { [fieldId]: error });
  });
  const isTouched = (fieldId) => Object.entries(touched).reduce((acc, [id2, isTouched2]) => id2 === fieldId ? isTouched2 : acc, false);
  const setFieldTouched = (fieldId, isTouched2) => touched[fieldId] !== isTouched2 && setTouched((_a3) => {
    var _b = fieldId, _14 = _a3[_b], prevTouched = __rest(_a3, [typeof _b === "symbol" ? _b : _b + ""]);
    return Object.assign(Object.assign({}, prevTouched), isTouched2 && { [fieldId]: isTouched2 });
  });
  const setValidator = (fieldId, validate2) => validators[fieldId] !== validate2 && setValidators((prevValidators) => Object.assign(Object.assign({}, prevValidators), { [fieldId]: validate2 }));
  const validate = () => {
    var _a3;
    return (_a3 = Object.entries(validators)) === null || _a3 === void 0 ? void 0 : _a3.reduce((acc, [id2, validateField]) => {
      const fieldError = validateField(values[id2]);
      if (fieldError) {
        acc[id2] = fieldError;
      }
      return acc;
    }, {});
  };
  return import_react21.default.createElement(FormContext.Provider, { value: {
    values,
    errors: errors2,
    touched,
    isValid,
    setValues,
    setErrors,
    getValue,
    setValue,
    getError,
    setError,
    validate,
    setValidator,
    isTouched,
    setTouched: setFieldTouched
  } }, typeof children2 === "function" ? import_react21.default.createElement(FormContext.Consumer, null, (formContext) => children2(formContext)) : children2);
};
FormContextProvider.displayName = "FormContextProvider";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Panel/Panel.js
var React170 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Panel/panel.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Panel/panel.css";
var panel_default = {
  "modifiers": {
    "bordered": "pf-m-bordered",
    "secondary": "pf-m-secondary",
    "raised": "pf-m-raised",
    "scrollable": "pf-m-scrollable"
  },
  "panel": "pf-v6-c-panel",
  "panelFooter": "pf-v6-c-panel__footer",
  "panelHeader": "pf-v6-c-panel__header",
  "panelMain": "pf-v6-c-panel__main",
  "panelMainBody": "pf-v6-c-panel__main-body"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Panel/Panel.js
var PanelBase = (_a2) => {
  var { className, children: children2, variant, isScrollable, innerRef } = _a2, props = __rest(_a2, ["className", "children", "variant", "isScrollable", "innerRef"]);
  return React170.createElement("div", Object.assign({ className: css(panel_default.panel, variant && panel_default.modifiers[variant], isScrollable && panel_default.modifiers.scrollable, className), ref: innerRef }, props), children2);
};
var Panel = React170.forwardRef((props, ref) => React170.createElement(PanelBase, Object.assign({ innerRef: ref }, props)));
Panel.displayName = "Panel";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Panel/PanelMain.js
var React171 = __toESM(require_react());
var PanelMain = (_a2) => {
  var { className, children: children2, maxHeight } = _a2, props = __rest(_a2, ["className", "children", "maxHeight"]);
  return React171.createElement("div", Object.assign({ className: css(panel_default.panelMain, className), style: { [c_panel_main_MaxHeight_default.name]: maxHeight } }, props), children2);
};
PanelMain.displayName = "PanelMain";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Panel/PanelMainBody.js
var React172 = __toESM(require_react());
var PanelMainBody = (_a2) => {
  var { className, children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React172.createElement("div", Object.assign({ className: css(panel_default.panelMainBody, className) }, props), children2);
};
PanelMainBody.displayName = "PanelMainBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Panel/PanelHeader.js
var React173 = __toESM(require_react());
var PanelHeader = (_a2) => {
  var { className, children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React173.createElement("div", Object.assign({ className: css(panel_default.panelHeader, className) }, props), children2);
};
PanelHeader.displayName = "PanelHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Panel/PanelFooter.js
var React174 = __toESM(require_react());
var PanelFooter = (_a2) => {
  var { className, children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React174.createElement("div", Object.assign({ className: css(panel_default.panelFooter, className) }, props), children2);
};
PanelFooter.displayName = "PanelFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SearchInput/AdvancedSearchMenu.js
var AdvancedSearchMenu = ({ className, parentRef, parentInputRef, value = "", attributes = [], formAdditionalItems, hasWordsAttrLabel = "Has words", advancedSearchDelimiter, getAttrValueMap, onChange, onSearch, onClear, resetButtonLabel = "Reset", submitSearchButtonLabel = "Search", isSearchMenuOpen, onToggleAdvancedMenu }) => {
  const firstAttrRef = React175.useRef(null);
  const [putFocusBackOnInput, setPutFocusBackOnInput] = React175.useState(false);
  React175.useEffect(() => {
    if (attributes.length > 0 && !advancedSearchDelimiter) {
      console.error("AdvancedSearchMenu: An advancedSearchDelimiter prop is required when advanced search attributes are provided using the attributes prop");
    }
  });
  React175.useEffect(() => {
    if (isSearchMenuOpen && firstAttrRef && firstAttrRef.current) {
      firstAttrRef.current.focus();
      setPutFocusBackOnInput(true);
    } else if (!isSearchMenuOpen && putFocusBackOnInput && parentInputRef && parentInputRef.current) {
      parentInputRef.current.focus();
    }
  }, [isSearchMenuOpen]);
  React175.useEffect(() => {
    document.addEventListener("mousedown", onDocClick);
    document.addEventListener("touchstart", onDocClick);
    document.addEventListener("keydown", onEscPress);
    return function cleanup() {
      document.removeEventListener("mousedown", onDocClick);
      document.removeEventListener("touchstart", onDocClick);
      document.removeEventListener("keydown", onEscPress);
    };
  });
  const onDocClick = (event) => {
    const clickedWithinSearchInput = parentRef && parentRef.current.contains(event.target);
    if (isSearchMenuOpen && !clickedWithinSearchInput) {
      onToggleAdvancedMenu(event);
    }
  };
  const onEscPress = (event) => {
    if (isSearchMenuOpen && event.key === KeyTypes.Escape && parentRef && parentRef.current.contains(event.target)) {
      onToggleAdvancedMenu(event);
      if (parentInputRef) {
        parentInputRef.current.focus();
      }
    }
  };
  const onSearchHandler = (event) => {
    event.preventDefault();
    if (onSearch) {
      onSearch(event, value, getAttrValueMap());
    }
    if (isSearchMenuOpen) {
      onToggleAdvancedMenu(event);
    }
  };
  const handleValueChange = (attribute, newValue, event) => {
    const newMap = getAttrValueMap();
    newMap[attribute] = newValue;
    let updatedValue = "";
    Object.entries(newMap).forEach(([k2, v2]) => {
      if (v2.trim() !== "") {
        const quoteWrappedValue = v2.includes(" ") ? `'${v2.replace(/(^'|'$)/g, "")}'` : v2;
        if (k2 !== "haswords") {
          updatedValue = `${updatedValue} ${k2}${advancedSearchDelimiter}${quoteWrappedValue}`;
        } else {
          updatedValue = `${updatedValue} ${quoteWrappedValue}`;
        }
      }
    });
    if (onChange) {
      onChange(event, updatedValue.replace(/^\s+/g, ""));
    }
  };
  const getValue = (attribute) => {
    const map5 = getAttrValueMap();
    return map5.hasOwnProperty(attribute) ? map5[attribute] : "";
  };
  const buildFormGroups = () => {
    const formGroups = [];
    attributes.forEach((attribute, index4) => {
      const display = typeof attribute === "string" ? attribute : attribute.display;
      const queryAttr = typeof attribute === "string" ? attribute : attribute.attr;
      if (index4 === 0) {
        formGroups.push(React175.createElement(
          FormGroup,
          { label: display, fieldId: `${queryAttr}_${index4}`, key: `${attribute}_${index4}` },
          React175.createElement(TextInput, { ref: firstAttrRef, type: "text", id: `${queryAttr}_${index4}`, value: getValue(queryAttr), onChange: (evt, value2) => handleValueChange(queryAttr, value2, evt) })
        ));
      } else {
        formGroups.push(React175.createElement(
          FormGroup,
          { label: display, fieldId: `${queryAttr}_${index4}`, key: `${attribute}_${index4}` },
          React175.createElement(TextInput, { type: "text", id: `${queryAttr}_${index4}`, value: getValue(queryAttr), onChange: (evt, value2) => handleValueChange(queryAttr, value2, evt) })
        ));
      }
    });
    formGroups.push(React175.createElement(GenerateId, { key: "hasWords" }, (randomId) => React175.createElement(
      FormGroup,
      { label: hasWordsAttrLabel, fieldId: randomId },
      React175.createElement(TextInput, { type: "text", id: randomId, value: getValue("haswords"), onChange: (evt, value2) => handleValueChange("haswords", value2, evt) })
    )));
    return formGroups;
  };
  return isSearchMenuOpen ? React175.createElement(
    Panel,
    { variant: "raised", className: css(className) },
    React175.createElement(
      PanelMain,
      null,
      React175.createElement(
        PanelMainBody,
        null,
        React175.createElement(
          Form,
          null,
          buildFormGroups(),
          formAdditionalItems ? formAdditionalItems : null,
          React175.createElement(
            ActionGroup,
            null,
            React175.createElement(Button, { variant: "primary", type: "submit", onClick: onSearchHandler, isDisabled: !value }, submitSearchButtonLabel),
            !!onClear && React175.createElement(Button, { variant: "link", type: "reset", onClick: onClear }, resetButtonLabel)
          )
        )
      )
    )
  ) : null;
};
AdvancedSearchMenu.displayName = "SearchInput";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TextInputGroup/TextInputGroup.js
var React176 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/TextInputGroup/text-input-group.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/TextInputGroup/text-input-group.css";
var text_input_group_default = {
  "labelGroupMain": "pf-v6-c-label-group__main",
  "modifiers": {
    "disabled": "pf-m-disabled",
    "plain": "pf-m-plain",
    "icon": "pf-m-icon",
    "hint": "pf-m-hint"
  },
  "textInputGroup": "pf-v6-c-text-input-group",
  "textInputGroupGroup": "pf-v6-c-text-input-group__group",
  "textInputGroupIcon": "pf-v6-c-text-input-group__icon",
  "textInputGroupMain": "pf-v6-c-text-input-group__main",
  "textInputGroupText": "pf-v6-c-text-input-group__text",
  "textInputGroupTextInput": "pf-v6-c-text-input-group__text-input",
  "textInputGroupUtilities": "pf-v6-c-text-input-group__utilities"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TextInputGroup/TextInputGroup.js
var TextInputGroupContext = React176.createContext({
  isDisabled: false
});
var TextInputGroup = (_a2) => {
  var { children: children2, className, isDisabled, isPlain, innerRef } = _a2, props = __rest(_a2, ["children", "className", "isDisabled", "isPlain", "innerRef"]);
  const ref = React176.useRef(null);
  const textInputGroupRef = innerRef || ref;
  return React176.createElement(
    TextInputGroupContext.Provider,
    { value: { isDisabled } },
    React176.createElement("div", Object.assign({ ref: textInputGroupRef, className: css(text_input_group_default.textInputGroup, isDisabled && text_input_group_default.modifiers.disabled, isPlain && text_input_group_default.modifiers.plain, className) }, props), children2)
  );
};
TextInputGroup.displayName = "TextInputGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TextInputGroup/TextInputGroupMain.js
var React177 = __toESM(require_react());
var TextInputGroupMainBase = (_a2) => {
  var { children: children2, className, icon, type: type2 = "text", hint, onChange = () => void 0, onFocus, onBlur, "aria-label": ariaLabel = "Type to filter", value: inputValue, placeholder: inputPlaceHolder, innerRef, name, "aria-activedescendant": ariaActivedescendant, role, isExpanded, "aria-controls": ariaControls, inputId } = _a2, props = __rest(_a2, ["children", "className", "icon", "type", "hint", "onChange", "onFocus", "onBlur", "aria-label", "value", "placeholder", "innerRef", "name", "aria-activedescendant", "role", "isExpanded", "aria-controls", "inputId"]);
  const { isDisabled } = React177.useContext(TextInputGroupContext);
  const ref = React177.useRef(null);
  const textInputGroupInputInputRef = innerRef || ref;
  const handleChange = (event) => {
    onChange(event, event.currentTarget.value);
  };
  return React177.createElement(
    "div",
    Object.assign({ className: css(text_input_group_default.textInputGroupMain, icon && text_input_group_default.modifiers.icon, className) }, props),
    children2,
    React177.createElement(
      "span",
      { className: css(text_input_group_default.textInputGroupText) },
      hint && React177.createElement("input", { className: css(text_input_group_default.textInputGroupTextInput, text_input_group_default.modifiers.hint), type: "text", disabled: true, "aria-hidden": "true", value: hint, id: inputId }),
      icon && React177.createElement("span", { className: css(text_input_group_default.textInputGroupIcon) }, icon),
      React177.createElement("input", Object.assign({ ref: textInputGroupInputInputRef, type: type2, className: css(text_input_group_default.textInputGroupTextInput), "aria-label": ariaLabel, disabled: isDisabled, onChange: handleChange, onFocus, onBlur, value: inputValue || "", placeholder: inputPlaceHolder, name, "aria-activedescendant": ariaActivedescendant, id: inputId }, role && { role }, isExpanded !== void 0 && { "aria-expanded": isExpanded }, ariaControls && { "aria-controls": ariaControls }))
    )
  );
};
var TextInputGroupMain = React177.forwardRef((props, ref) => React177.createElement(TextInputGroupMainBase, Object.assign({ innerRef: ref }, props)));
TextInputGroupMain.displayName = "TextInputGroupMain";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TextInputGroup/TextInputGroupUtilities.js
var React178 = __toESM(require_react());
var TextInputGroupUtilities = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React178.createElement("div", Object.assign({ className: css(text_input_group_default.textInputGroupUtilities, className) }, props), children2);
};
TextInputGroupUtilities.displayName = "TextInputGroupUtilities";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SearchInput/SearchInput.js
var SearchInputBase = (_a2) => {
  var { className, searchInputId, value = "", attributes = [], formAdditionalItems, hasWordsAttrLabel = "Has words", advancedSearchDelimiter, placeholder, hint, onChange, onSearch, onClear, onToggleAdvancedSearch, isAdvancedSearchOpen, resultsCount, onNextClick, onPreviousClick, innerRef, expandableInput, "aria-label": ariaLabel = "Search input", resetButtonLabel = "Reset", openMenuButtonAriaLabel = "Open advanced search", previousNavigationButtonAriaLabel = "Previous", isPreviousNavigationButtonDisabled = false, isNextNavigationButtonDisabled = false, nextNavigationButtonAriaLabel = "Next", submitSearchButtonLabel = "Search", isDisabled = false, appendTo, zIndex = 9999, name, areUtilitiesDisplayed } = _a2, props = __rest(_a2, ["className", "searchInputId", "value", "attributes", "formAdditionalItems", "hasWordsAttrLabel", "advancedSearchDelimiter", "placeholder", "hint", "onChange", "onSearch", "onClear", "onToggleAdvancedSearch", "isAdvancedSearchOpen", "resultsCount", "onNextClick", "onPreviousClick", "innerRef", "expandableInput", "aria-label", "resetButtonLabel", "openMenuButtonAriaLabel", "previousNavigationButtonAriaLabel", "isPreviousNavigationButtonDisabled", "isNextNavigationButtonDisabled", "nextNavigationButtonAriaLabel", "submitSearchButtonLabel", "isDisabled", "appendTo", "zIndex", "name", "areUtilitiesDisplayed"]);
  const [isSearchMenuOpen, setIsSearchMenuOpen] = React179.useState(false);
  const [searchValue, setSearchValue] = React179.useState(value);
  const searchInputRef = React179.useRef(null);
  const ref = React179.useRef(null);
  const searchInputInputRef = innerRef || ref;
  const searchInputExpandableToggleRef = React179.useRef(null);
  const triggerRef = React179.useRef(null);
  const popperRef = React179.useRef(null);
  const [focusAfterExpandChange, setFocusAfterExpandChange] = React179.useState(false);
  const { isExpanded, onToggleExpand, toggleAriaLabel } = expandableInput || {};
  React179.useEffect(() => {
    var _a3, _b;
    if (!focusAfterExpandChange) {
      return;
    } else if (isExpanded) {
      (_a3 = searchInputInputRef === null || searchInputInputRef === void 0 ? void 0 : searchInputInputRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
    } else {
      (_b = searchInputExpandableToggleRef === null || searchInputExpandableToggleRef === void 0 ? void 0 : searchInputExpandableToggleRef.current) === null || _b === void 0 ? void 0 : _b.focus();
    }
    setFocusAfterExpandChange(false);
  }, [focusAfterExpandChange, isExpanded, searchInputInputRef, searchInputExpandableToggleRef]);
  React179.useEffect(() => {
    setSearchValue(value);
  }, [value]);
  React179.useEffect(() => {
    if (attributes.length > 0 && !advancedSearchDelimiter) {
      console.error("An advancedSearchDelimiter prop is required when advanced search attributes are provided using the attributes prop");
    }
  });
  React179.useEffect(() => {
    setIsSearchMenuOpen(isAdvancedSearchOpen);
  }, [isAdvancedSearchOpen]);
  const onChangeHandler = (event, value2) => {
    if (onChange) {
      onChange(event, value2);
    }
    setSearchValue(value2);
  };
  const onToggle = (e) => {
    const isOpen = !isSearchMenuOpen;
    setIsSearchMenuOpen(isOpen);
    if (onToggleAdvancedSearch) {
      onToggleAdvancedSearch(e, isOpen);
    }
  };
  const onSearchHandler = (event) => {
    event.preventDefault();
    if (onSearch) {
      onSearch(event, value, getAttrValueMap());
    }
    setIsSearchMenuOpen(false);
  };
  const splitStringExceptInQuotes = (str) => {
    let quoteType;
    return str.match(/\\?.|^$/g).reduce((p, c6) => {
      if (c6 === "'" || c6 === '"') {
        if (!quoteType) {
          quoteType = c6;
        }
        if (c6 === quoteType) {
          p.quote = !p.quote;
        }
      } else if (!p.quote && c6 === " ") {
        p.a.push("");
      } else {
        p.a[p.a.length - 1] += c6.replace(/\\(.)/, "$1");
      }
      return p;
    }, { a: [""] }).a;
  };
  const getAttrValueMap = () => {
    const attrValue = {};
    const pairs2 = splitStringExceptInQuotes(searchValue);
    pairs2.map((pair2) => {
      const splitPair = pair2.split(advancedSearchDelimiter);
      if (splitPair.length === 2) {
        attrValue[splitPair[0]] = splitPair[1].replace(/(^'|'$)/g, "");
      } else if (splitPair.length === 1) {
        attrValue.haswords = attrValue.hasOwnProperty("haswords") ? `${attrValue.haswords} ${splitPair[0]}` : splitPair[0];
      }
    });
    return attrValue;
  };
  const onEnter = (event) => {
    if (event.key === "Enter") {
      onSearchHandler(event);
    }
  };
  const onClearInput = (e) => {
    if (onClear) {
      onClear(e);
    }
    if (searchInputInputRef && searchInputInputRef.current) {
      searchInputInputRef.current.focus();
    }
  };
  const onExpandHandler = (event) => {
    setSearchValue("");
    onToggleExpand(event, isExpanded);
    setFocusAfterExpandChange(true);
  };
  const renderUtilities = value && (resultsCount || !!onNextClick && !!onPreviousClick || !!onClear && !expandableInput);
  const buildTextInputGroup = (_a3 = {}) => {
    var searchInputProps2 = __rest(_a3, []);
    return React179.createElement(
      TextInputGroup,
      Object.assign({ isDisabled }, searchInputProps2),
      React179.createElement(TextInputGroupMain, { hint, icon: React179.createElement(search_icon_default, null), innerRef: searchInputInputRef, value: searchValue, placeholder, "aria-label": ariaLabel, onKeyDown: onEnter, onChange: onChangeHandler, name, inputId: searchInputId }),
      (renderUtilities || areUtilitiesDisplayed) && React179.createElement(
        TextInputGroupUtilities,
        null,
        resultsCount && React179.createElement(Badge, { isRead: true }, resultsCount),
        !!onNextClick && !!onPreviousClick && React179.createElement(
          "div",
          { className: text_input_group_default.textInputGroupGroup },
          React179.createElement(
            Button,
            { variant: ButtonVariant.plain, "aria-label": previousNavigationButtonAriaLabel, isDisabled: isDisabled || isPreviousNavigationButtonDisabled, onClick: onPreviousClick },
            React179.createElement(angle_up_icon_default, null)
          ),
          React179.createElement(
            Button,
            { variant: ButtonVariant.plain, "aria-label": nextNavigationButtonAriaLabel, isDisabled: isDisabled || isNextNavigationButtonDisabled, onClick: onNextClick },
            React179.createElement(angle_down_icon_default, null)
          )
        ),
        !!onClear && !expandableInput && React179.createElement(
          Button,
          { variant: ButtonVariant.plain, isDisabled, "aria-label": resetButtonLabel, onClick: onClearInput },
          React179.createElement(times_icon_default, null)
        )
      )
    );
  };
  const expandableToggle = React179.createElement(Button, { variant: ButtonVariant.plain, "aria-label": toggleAriaLabel, "aria-expanded": isExpanded, icon: isExpanded ? React179.createElement(times_icon_default, null) : React179.createElement(search_icon_default, null), onClick: onExpandHandler, ref: searchInputExpandableToggleRef });
  const buildExpandableSearchInput = (_a3 = {}) => {
    var searchInputProps2 = __rest(_a3, []);
    return React179.createElement(
      InputGroup,
      Object.assign({}, searchInputProps2),
      React179.createElement(
        InputGroupItem,
        { isFill: true },
        buildTextInputGroup(),
        " "
      ),
      React179.createElement(InputGroupItem, { isPlain: true }, expandableToggle)
    );
  };
  const buildSearchTextInputGroup = (_a3 = {}) => {
    var searchInputProps2 = __rest(_a3, []);
    if (expandableInput) {
      return buildExpandableSearchInput(Object.assign({}, searchInputProps2));
    }
    return buildTextInputGroup(Object.assign({}, searchInputProps2));
  };
  const buildSearchTextInputGroupWithExtraButtons = (_a3 = {}) => {
    var searchInputProps2 = __rest(_a3, []);
    return React179.createElement(
      InputGroup,
      Object.assign({ ref: triggerRef }, searchInputProps2),
      React179.createElement(InputGroupItem, { isFill: true }, buildTextInputGroup()),
      (attributes.length > 0 || onToggleAdvancedSearch) && React179.createElement(
        InputGroupItem,
        { isPlain: true },
        React179.createElement(
          Button,
          { className: isSearchMenuOpen && "pf-m-expanded", variant: ButtonVariant.control, "aria-label": openMenuButtonAriaLabel, onClick: onToggle, isDisabled, "aria-expanded": isSearchMenuOpen },
          React179.createElement(caret_down_icon_default, null)
        )
      ),
      !!onSearch && React179.createElement(
        InputGroupItem,
        null,
        React179.createElement(
          Button,
          { type: "submit", variant: ButtonVariant.control, "aria-label": submitSearchButtonLabel, onClick: onSearchHandler, isDisabled },
          React179.createElement(
            Icon,
            { shouldMirrorRTL: true },
            React179.createElement(arrow_right_icon_default, null)
          )
        )
      ),
      expandableInput && React179.createElement(InputGroupItem, null, expandableToggle)
    );
  };
  const searchInputProps = Object.assign(Object.assign({}, props), { className: className && css(className), innerRef: searchInputRef });
  if (!!expandableInput && !isExpanded) {
    return React179.createElement(
      InputGroup,
      Object.assign({}, searchInputProps),
      React179.createElement(InputGroupItem, null, expandableToggle)
    );
  }
  if (!!onSearch || attributes.length > 0 || !!onToggleAdvancedSearch) {
    if (attributes.length > 0) {
      const AdvancedSearch = React179.createElement(
        "div",
        { ref: popperRef },
        React179.createElement(AdvancedSearchMenu, { value, parentRef: searchInputRef, parentInputRef: searchInputInputRef, onSearch, onClear, onChange, onToggleAdvancedMenu: onToggle, resetButtonLabel, submitSearchButtonLabel, attributes, formAdditionalItems, hasWordsAttrLabel, advancedSearchDelimiter, getAttrValueMap, isSearchMenuOpen })
      );
      const AdvancedSearchWithPopper = React179.createElement(
        "div",
        Object.assign({ className: css(className), ref: searchInputRef }, props),
        React179.createElement(Popper, { trigger: buildSearchTextInputGroupWithExtraButtons(), triggerRef, popper: AdvancedSearch, popperRef, isVisible: isSearchMenuOpen, enableFlip: true, appendTo: () => appendTo || searchInputRef.current, zIndex })
      );
      const AdvancedSearchInline = React179.createElement(
        "div",
        Object.assign({ className: css(className), ref: searchInputRef }, props),
        buildSearchTextInputGroupWithExtraButtons(),
        AdvancedSearch
      );
      return appendTo !== "inline" ? AdvancedSearchWithPopper : AdvancedSearchInline;
    }
    return buildSearchTextInputGroupWithExtraButtons(Object.assign({}, searchInputProps));
  }
  return buildSearchTextInputGroup(searchInputProps);
};
SearchInputBase.displayName = "SearchInputBase";
var SearchInput = React179.forwardRef((props, ref) => React179.createElement(SearchInputBase, Object.assign({}, props, { innerRef: ref })));
SearchInput.displayName = "SearchInput";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorPane.js
var DualListSelectorPane = (_a2) => {
  var { isChosen = false, className = "", status = "", actions, searchInput, children: children2, title = "", id: id2 = getUniqueId("dual-list-selector-pane"), isDisabled = false, listMinHeight } = _a2, props = __rest(_a2, ["isChosen", "className", "status", "actions", "searchInput", "children", "title", "id", "isDisabled", "listMinHeight"]);
  return React180.createElement(
    "div",
    Object.assign({ className: css(dual_list_selector_default.dualListSelectorPane, isChosen ? dual_list_selector_default.modifiers.chosen : "pf-m-available", className) }, props),
    title && React180.createElement(
      "div",
      { className: css(dual_list_selector_default.dualListSelectorHeader) },
      React180.createElement(
        "div",
        { className: `${dual_list_selector_default.dualListSelector}__title` },
        React180.createElement("div", { className: css(dual_list_selector_default.dualListSelectorTitleText) }, title)
      )
    ),
    (actions || searchInput) && React180.createElement(
      "div",
      { className: css(dual_list_selector_default.dualListSelectorTools) },
      searchInput && React180.createElement("div", { className: css(dual_list_selector_default.dualListSelectorToolsFilter) }, searchInput ? searchInput : React180.createElement(SearchInput, { isDisabled })),
      actions && React180.createElement("div", { className: css(dual_list_selector_default.dualListSelectorToolsActions) }, actions)
    ),
    status && React180.createElement(
      "div",
      { className: css(dual_list_selector_default.dualListSelectorStatus) },
      React180.createElement("div", { className: css(dual_list_selector_default.dualListSelectorStatusText), id: `${id2}-status` }, status)
    ),
    React180.createElement(
      DualListSelectorPaneContext.Provider,
      { value: { isChosen } },
      React180.createElement(DualListSelectorListWrapper, Object.assign({ "aria-labelledby": `${id2}-status`, id: `${id2}-list` }, listMinHeight && {
        style: { [c_dual_list_selector_menu_MinHeight_default.name]: listMinHeight }
      }), children2)
    )
  );
};
DualListSelectorPane.displayName = "DualListSelectorPane";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorTree.js
var React182 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorTreeItem.js
var React181 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/treeUtils.js
function flattenTree(tree) {
  let result = [];
  tree.forEach((item) => {
    if (item.children) {
      result = result.concat(flattenTree(item.children));
    } else {
      result.push(item.id);
    }
  });
  return result;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorTreeItem.js
var DualListSelectorTreeItemBase = (_a2) => {
  var {
    onOptionCheck,
    children: children2,
    className,
    id: id2,
    text,
    defaultExpanded,
    hasBadge,
    isChecked,
    checkProps,
    badgeProps,
    itemData,
    isDisabled = false,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    useMemo: useMemo26
  } = _a2, props = __rest(_a2, ["onOptionCheck", "children", "className", "id", "text", "defaultExpanded", "hasBadge", "isChecked", "checkProps", "badgeProps", "itemData", "isDisabled", "useMemo"]);
  const ref = React181.useRef(null);
  const [isExpanded, setIsExpanded] = React181.useState(defaultExpanded || false);
  const { setFocusedOption } = React181.useContext(DualListSelectorListContext);
  React181.useEffect(() => {
    setIsExpanded(defaultExpanded);
  }, [defaultExpanded]);
  return React181.createElement(
    "li",
    Object.assign({ className: css(dual_list_selector_default.dualListSelectorListItem, className, children2 && dual_list_selector_default.modifiers.expandable, isExpanded && dual_list_selector_default.modifiers.expanded, isDisabled && dual_list_selector_default.modifiers.disabled), id: id2 }, props, { "aria-selected": isChecked, role: "treeitem" }, isExpanded && { "aria-expanded": "true" }),
    React181.createElement(
      "div",
      { className: css(dual_list_selector_default.dualListSelectorListItemRow, isChecked && dual_list_selector_default.modifiers.selected, dual_list_selector_default.modifiers.check) },
      React181.createElement(
        "div",
        { className: css(dual_list_selector_default.dualListSelectorItem), ref, tabIndex: -1, onClick: isDisabled ? void 0 : (evt) => {
          onOptionCheck && onOptionCheck(evt, !isChecked, itemData);
          setFocusedOption(id2);
        } },
        React181.createElement(
          "span",
          { className: css(dual_list_selector_default.dualListSelectorItemMain) },
          children2 && React181.createElement(
            "div",
            { className: css(dual_list_selector_default.dualListSelectorItemToggle), onClick: (e) => {
              if (children2) {
                setIsExpanded(!isExpanded);
              }
              e.stopPropagation();
            }, onKeyDown: (e) => {
              if (e.key === " " || e.key === "Enter") {
                document.activeElement.click();
                e.preventDefault();
              }
            }, tabIndex: -1 },
            React181.createElement(
              "span",
              { className: css(dual_list_selector_default.dualListSelectorItemToggleIcon) },
              React181.createElement(angle_right_icon_default, { "aria-hidden": true })
            )
          ),
          React181.createElement(
            "span",
            { className: css(dual_list_selector_default.dualListSelectorItemCheck) },
            React181.createElement("input", Object.assign({ type: "checkbox", onChange: (evt) => {
              onOptionCheck && onOptionCheck(evt, !isChecked, itemData);
              setFocusedOption(id2);
            }, onClick: (evt) => evt.stopPropagation(), onKeyDown: (e) => {
              if (e.key === " " || e.key === "Enter") {
                onOptionCheck && onOptionCheck(e, !isChecked, itemData);
                setFocusedOption(id2);
                e.preventDefault();
              }
            }, ref: (elem) => elem && (elem.indeterminate = isChecked === null), checked: isChecked || false, tabIndex: -1 }, checkProps))
          ),
          React181.createElement("span", { className: css(dual_list_selector_default.dualListSelectorItemText) }, text),
          hasBadge && children2 && React181.createElement(
            "span",
            { className: css(dual_list_selector_default.dualListSelectorItemCount) },
            React181.createElement(Badge, Object.assign({}, badgeProps), flattenTree(children2.props.data).length)
          )
        )
      )
    ),
    isExpanded && children2
  );
};
var DualListSelectorTreeItem = React181.memo(DualListSelectorTreeItemBase, (prevProps, nextProps) => {
  if (!nextProps.useMemo) {
    return false;
  }
  if (prevProps.className !== nextProps.className || prevProps.text !== nextProps.text || prevProps.id !== nextProps.id || prevProps.defaultExpanded !== nextProps.defaultExpanded || prevProps.checkProps !== nextProps.checkProps || prevProps.hasBadge !== nextProps.hasBadge || prevProps.badgeProps !== nextProps.badgeProps || prevProps.isChecked !== nextProps.isChecked || prevProps.itemData !== nextProps.itemData) {
    return false;
  }
  return true;
});
DualListSelectorTreeItem.displayName = "DualListSelectorTreeItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/DualListSelector/DualListSelectorTree.js
var DualListSelectorTree = (_a2) => {
  var { data, hasBadges = false, isNested = false, defaultAllExpanded = false, onOptionCheck, isDisabled = false } = _a2, props = __rest(_a2, ["data", "hasBadges", "isNested", "defaultAllExpanded", "onOptionCheck", "isDisabled"]);
  const dataToRender = typeof data === "function" ? data() : data;
  const tree = dataToRender.map((item) => React182.createElement(DualListSelectorTreeItem, Object.assign({ key: item.id, text: item.text, id: item.id, defaultExpanded: item.defaultExpanded !== void 0 ? item.defaultExpanded : defaultAllExpanded, onOptionCheck, isChecked: item.isChecked, checkProps: item.checkProps, hasBadge: item.hasBadge !== void 0 ? item.hasBadge : hasBadges, badgeProps: item.badgeProps, itemData: item, isDisabled, useMemo: true }, item.children && {
    children: React182.createElement(DualListSelectorTree, { isNested: true, data: item.children, hasBadges, defaultAllExpanded, onOptionCheck, isDisabled })
  })));
  return isNested ? React182.createElement("ul", Object.assign({ className: css(dual_list_selector_default.dualListSelectorList), role: "group" }, props), tree) : React182.createElement(React182.Fragment, null, tree);
};
DualListSelectorTree.displayName = "DualListSelectorTree";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyState.js
var React185 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/EmptyState/empty-state.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/EmptyState/empty-state.css";
var empty_state_default = {
  "emptyState": "pf-v6-c-empty-state",
  "emptyStateActions": "pf-v6-c-empty-state__actions",
  "emptyStateBody": "pf-v6-c-empty-state__body",
  "emptyStateContent": "pf-v6-c-empty-state__content",
  "emptyStateFooter": "pf-v6-c-empty-state__footer",
  "emptyStateIcon": "pf-v6-c-empty-state__icon",
  "emptyStateTitleText": "pf-v6-c-empty-state__title-text",
  "modifiers": {
    "xs": "pf-m-xs",
    "sm": "pf-m-sm",
    "lg": "pf-m-lg",
    "xl": "pf-m-xl",
    "fullHeight": "pf-m-full-height",
    "danger": "pf-m-danger",
    "warning": "pf-m-warning",
    "success": "pf-m-success",
    "info": "pf-m-info",
    "custom": "pf-m-custom"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStateHeader.js
var React184 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStateIcon.js
var React183 = __toESM(require_react());
var isSpinner = (icon) => icon.type === Spinner;
var EmptyStateIcon = (_a2) => {
  var { className, icon: IconComponent } = _a2, props = __rest(_a2, ["className", "icon"]);
  const iconIsSpinner = isSpinner(React183.createElement(IconComponent, null));
  return React183.createElement(
    "div",
    { className: css(empty_state_default.emptyStateIcon) },
    React183.createElement(IconComponent, Object.assign({ className, "aria-hidden": !iconIsSpinner }, props))
  );
};
EmptyStateIcon.displayName = "EmptyStateIcon";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStateHeader.js
var EmptyStateHeadingLevel;
(function(EmptyStateHeadingLevel2) {
  EmptyStateHeadingLevel2["h1"] = "h1";
  EmptyStateHeadingLevel2["h2"] = "h2";
  EmptyStateHeadingLevel2["h3"] = "h3";
  EmptyStateHeadingLevel2["h4"] = "h4";
  EmptyStateHeadingLevel2["h5"] = "h5";
  EmptyStateHeadingLevel2["h6"] = "h6";
})(EmptyStateHeadingLevel || (EmptyStateHeadingLevel = {}));
var EmptyStateHeader = (_a2) => {
  var { className, titleClassName, titleText, headingLevel: HeadingLevel = EmptyStateHeadingLevel.h1, icon: Icon2 } = _a2, props = __rest(_a2, ["className", "titleClassName", "titleText", "headingLevel", "icon"]);
  return React184.createElement(
    "div",
    Object.assign({ className: css(`${empty_state_default.emptyState}__header`, className) }, props),
    Icon2 && React184.createElement(EmptyStateIcon, { icon: Icon2 }),
    React184.createElement(
      "div",
      { className: css(`${empty_state_default.emptyState}__title`) },
      React184.createElement(HeadingLevel, { className: css(empty_state_default.emptyStateTitleText, titleClassName) }, titleText)
    )
  );
};
EmptyStateHeader.displayName = "EmptyStateHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyState.js
var EmptyStateVariant;
(function(EmptyStateVariant2) {
  EmptyStateVariant2["xs"] = "xs";
  EmptyStateVariant2["sm"] = "sm";
  EmptyStateVariant2["lg"] = "lg";
  EmptyStateVariant2["xl"] = "xl";
  EmptyStateVariant2["full"] = "full";
})(EmptyStateVariant || (EmptyStateVariant = {}));
var EmptyStateStatus;
(function(EmptyStateStatus2) {
  EmptyStateStatus2["danger"] = "danger";
  EmptyStateStatus2["warning"] = "warning";
  EmptyStateStatus2["success"] = "success";
  EmptyStateStatus2["info"] = "info";
  EmptyStateStatus2["custom"] = "custom";
})(EmptyStateStatus || (EmptyStateStatus = {}));
var EmptyState = (_a2) => {
  var { children: children2, className, variant = EmptyStateVariant.full, isFullHeight, status, icon: customIcon, titleText, titleClassName, headerClassName, headingLevel } = _a2, props = __rest(_a2, ["children", "className", "variant", "isFullHeight", "status", "icon", "titleText", "titleClassName", "headerClassName", "headingLevel"]);
  const statusIcon = status && statusIcons[status];
  const icon = customIcon || statusIcon;
  return React185.createElement(
    "div",
    Object.assign({ className: css(empty_state_default.emptyState, variant !== "full" && empty_state_default.modifiers[variant], isFullHeight && empty_state_default.modifiers.fullHeight, status && empty_state_default.modifiers[status], className) }, props),
    React185.createElement(
      "div",
      { className: css(empty_state_default.emptyStateContent) },
      React185.createElement(EmptyStateHeader, { icon, titleText, titleClassName, className: headerClassName, headingLevel }),
      children2
    )
  );
};
EmptyState.displayName = "EmptyState";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStateBody.js
var React186 = __toESM(require_react());
var EmptyStateBody = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React186.createElement("div", Object.assign({ className: css(empty_state_default.emptyStateBody, className) }, props), children2);
};
EmptyStateBody.displayName = "EmptyStateBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStateFooter.js
var React187 = __toESM(require_react());
var EmptyStateFooter = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React187.createElement("div", Object.assign({ className: css(empty_state_default.emptyStateFooter, className) }, props), children2);
};
EmptyStateFooter.displayName = "EmptyStateFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStateActions.js
var React188 = __toESM(require_react());
var EmptyStateActions = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React188.createElement("div", Object.assign({ className: css(empty_state_default.emptyStateActions, className) }, props), children2);
};
EmptyStateActions.displayName = "EmptyStateActions";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ExpandableSection/ExpandableSection.js
var React189 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ExpandableSection/expandable-section.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ExpandableSection/expandable-section.css";
var expandable_section_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "expandableSection": "pf-v6-c-expandable-section",
  "expandableSectionContent": "pf-v6-c-expandable-section__content",
  "expandableSectionToggle": "pf-v6-c-expandable-section__toggle",
  "expandableSectionToggleIcon": "pf-v6-c-expandable-section__toggle-icon",
  "expandableSectionToggleText": "pf-v6-c-expandable-section__toggle-text",
  "modifiers": {
    "expanded": "pf-m-expanded",
    "limitWidth": "pf-m-limit-width",
    "displayLg": "pf-m-display-lg",
    "indented": "pf-m-indented",
    "truncate": "pf-m-truncate",
    "expandTop": "pf-m-expand-top"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ExpandableSection/ExpandableSection.js
var ExpandableSectionVariant;
(function(ExpandableSectionVariant2) {
  ExpandableSectionVariant2["default"] = "default";
  ExpandableSectionVariant2["truncate"] = "truncate";
})(ExpandableSectionVariant || (ExpandableSectionVariant = {}));
var setLineClamp = (lines, element) => {
  if (!element || lines < 1) {
    return;
  }
  element.style.setProperty(c_expandable_section_m_truncate_content_LineClamp_default.name, lines.toString());
};
var ExpandableSection = class extends React189.Component {
  constructor(props) {
    super(props);
    this.expandableContentRef = React189.createRef();
    this.observer = () => {
    };
    this.checkToggleVisibility = () => {
      var _a2;
      if ((_a2 = this.expandableContentRef) === null || _a2 === void 0 ? void 0 : _a2.current) {
        const maxLines = this.props.truncateMaxLines || parseInt(c_expandable_section_m_truncate_content_LineClamp_default.value);
        const totalLines = this.expandableContentRef.current.scrollHeight / parseInt(getComputedStyle(this.expandableContentRef.current).lineHeight);
        this.setState({
          hasToggle: totalLines > maxLines
        });
      }
    };
    this.resize = () => {
      const { offsetWidth } = this.expandableContentRef.current;
      if (this.state.previousWidth !== offsetWidth) {
        this.setState({ previousWidth: offsetWidth });
        this.checkToggleVisibility();
      }
    };
    this.handleResize = debounce(this.resize, 250);
    this.state = {
      isExpanded: props.isExpanded,
      hasToggle: true,
      previousWidth: void 0
    };
  }
  calculateToggleText(toggleText, toggleTextExpanded, toggleTextCollapsed, propOrStateIsExpanded) {
    if (propOrStateIsExpanded && toggleTextExpanded !== "") {
      return toggleTextExpanded;
    }
    if (!propOrStateIsExpanded && toggleTextCollapsed !== "") {
      return toggleTextCollapsed;
    }
    return toggleText;
  }
  componentDidMount() {
    if (this.props.variant === ExpandableSectionVariant.truncate) {
      const expandableContent = this.expandableContentRef.current;
      this.setState({ previousWidth: expandableContent.offsetWidth });
      this.observer = getResizeObserver(expandableContent, this.handleResize, false);
      if (this.props.truncateMaxLines) {
        setLineClamp(this.props.truncateMaxLines, expandableContent);
      }
      this.checkToggleVisibility();
    }
  }
  componentDidUpdate(prevProps) {
    if (this.props.variant === ExpandableSectionVariant.truncate && (prevProps.truncateMaxLines !== this.props.truncateMaxLines || prevProps.children !== this.props.children)) {
      const expandableContent = this.expandableContentRef.current;
      setLineClamp(this.props.truncateMaxLines, expandableContent);
      this.checkToggleVisibility();
    }
  }
  componentWillUnmount() {
    if (this.props.variant === ExpandableSectionVariant.truncate) {
      this.observer();
    }
  }
  render() {
    const _a2 = this.props, {
      onToggle: onToggleProp,
      className,
      toggleText,
      toggleTextExpanded,
      toggleTextCollapsed,
      toggleContent,
      children: children2,
      isExpanded,
      isDetached,
      displaySize,
      isWidthLimited,
      isIndented,
      contentId,
      toggleId,
      variant,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      truncateMaxLines
    } = _a2, props = __rest(_a2, ["onToggle", "className", "toggleText", "toggleTextExpanded", "toggleTextCollapsed", "toggleContent", "children", "isExpanded", "isDetached", "displaySize", "isWidthLimited", "isIndented", "contentId", "toggleId", "variant", "truncateMaxLines"]);
    if (isDetached && !toggleId) {
      console.warn("ExpandableSection: The toggleId value must be passed in and must match the toggleId of the ExpandableSectionToggle.");
    }
    let onToggle = onToggleProp;
    let propOrStateIsExpanded = isExpanded;
    const uniqueContentId = contentId || getUniqueId("expandable-section-content");
    const uniqueToggleId = toggleId || getUniqueId("expandable-section-toggle");
    if (isExpanded === void 0) {
      propOrStateIsExpanded = this.state.isExpanded;
      onToggle = (event, isOpen) => {
        this.setState({ isExpanded: isOpen }, () => onToggleProp(event, this.state.isExpanded));
      };
    }
    const computedToggleText = this.calculateToggleText(toggleText, toggleTextExpanded, toggleTextCollapsed, propOrStateIsExpanded);
    const expandableToggle = !isDetached && React189.createElement(
      "button",
      { className: css(expandable_section_default.expandableSectionToggle), type: "button", "aria-expanded": propOrStateIsExpanded, "aria-controls": uniqueContentId, id: uniqueToggleId, onClick: (event) => onToggle(event, !propOrStateIsExpanded) },
      variant !== ExpandableSectionVariant.truncate && React189.createElement(
        "span",
        { className: css(expandable_section_default.expandableSectionToggleIcon) },
        React189.createElement(angle_right_icon_default, { "aria-hidden": true })
      ),
      React189.createElement("span", { className: css(expandable_section_default.expandableSectionToggleText) }, toggleContent || computedToggleText)
    );
    return React189.createElement(
      "div",
      Object.assign({ className: css(expandable_section_default.expandableSection, propOrStateIsExpanded && expandable_section_default.modifiers.expanded, displaySize === "lg" && expandable_section_default.modifiers.displayLg, isWidthLimited && expandable_section_default.modifiers.limitWidth, isIndented && expandable_section_default.modifiers.indented, variant === ExpandableSectionVariant.truncate && expandable_section_default.modifiers.truncate, className) }, props),
      variant === ExpandableSectionVariant.default && expandableToggle,
      React189.createElement("div", { ref: this.expandableContentRef, className: css(expandable_section_default.expandableSectionContent), hidden: variant !== ExpandableSectionVariant.truncate && !propOrStateIsExpanded, id: uniqueContentId, "aria-labelledby": uniqueToggleId, role: "region" }, children2),
      variant === ExpandableSectionVariant.truncate && this.state.hasToggle && expandableToggle
    );
  }
};
ExpandableSection.displayName = "ExpandableSection";
ExpandableSection.defaultProps = {
  className: "",
  toggleText: "",
  toggleTextExpanded: "",
  toggleTextCollapsed: "",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onToggle: (event, isExpanded) => void 0,
  isDetached: false,
  displaySize: "default",
  isWidthLimited: false,
  isIndented: false,
  variant: "default"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ExpandableSection/ExpandableSectionToggle.js
var React190 = __toESM(require_react());
var ExpandableSectionToggle = (_a2) => {
  var { children: children2, className = "", isExpanded = false, onToggle, contentId, toggleId, direction = "down", hasTruncatedContent = false } = _a2, props = __rest(_a2, ["children", "className", "isExpanded", "onToggle", "contentId", "toggleId", "direction", "hasTruncatedContent"]);
  return React190.createElement(
    "div",
    Object.assign({ className: css(expandable_section_default.expandableSection, isExpanded && expandable_section_default.modifiers.expanded, hasTruncatedContent && expandable_section_default.modifiers.truncate, className) }, props),
    React190.createElement(
      "button",
      { className: css(expandable_section_default.expandableSectionToggle), type: "button", "aria-expanded": isExpanded, "aria-controls": contentId, onClick: () => onToggle(!isExpanded), id: toggleId },
      !hasTruncatedContent && React190.createElement(
        "span",
        { className: css(expandable_section_default.expandableSectionToggleIcon, isExpanded && direction === "up" && expandable_section_default.modifiers.expandTop) },
        React190.createElement(angle_right_icon_default, { "aria-hidden": true })
      ),
      React190.createElement("span", { className: css(expandable_section_default.expandableSectionToggleText) }, children2)
    )
  );
};
ExpandableSectionToggle.displayName = "ExpandableSectionToggle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/FileUpload/FileUploadField.js
var React192 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/FileUpload/file-upload.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/FileUpload/file-upload.css";
var file_upload_default = {
  "button": "pf-v6-c-button",
  "fileUpload": "pf-v6-c-file-upload",
  "fileUploadFileDetails": "pf-v6-c-file-upload__file-details",
  "fileUploadFileDetailsSpinner": "pf-v6-c-file-upload__file-details-spinner",
  "fileUploadFileSelect": "pf-v6-c-file-upload__file-select",
  "formControl": "pf-v6-c-form-control",
  "modifiers": {
    "dragHover": "pf-m-drag-hover",
    "loading": "pf-m-loading",
    "control": "pf-m-control"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TextArea/TextArea.js
var React191 = __toESM(require_react());
var TextAreResizeOrientation;
(function(TextAreResizeOrientation2) {
  TextAreResizeOrientation2["horizontal"] = "horizontal";
  TextAreResizeOrientation2["vertical"] = "vertical";
  TextAreResizeOrientation2["both"] = "both";
})(TextAreResizeOrientation || (TextAreResizeOrientation = {}));
var TextAreaReadOnlyVariant;
(function(TextAreaReadOnlyVariant2) {
  TextAreaReadOnlyVariant2["default"] = "default";
  TextAreaReadOnlyVariant2["plain"] = "plain";
})(TextAreaReadOnlyVariant || (TextAreaReadOnlyVariant = {}));
var TextAreaBase = class extends React191.Component {
  constructor(props) {
    super(props);
    this.inputRef = React191.createRef();
    this.setAutoHeight = (field) => {
      const parent = field.parentElement;
      parent.style.setProperty("height", "inherit");
      const computed3 = window.getComputedStyle(field);
      const height = parseInt(computed3.getPropertyValue("border-top-width")) + parseInt(computed3.getPropertyValue("padding-top")) + field.scrollHeight + parseInt(computed3.getPropertyValue("padding-bottom")) + parseInt(computed3.getPropertyValue("border-bottom-width"));
      parent.style.setProperty("height", `${height}px`);
    };
    this.handleChange = (event) => {
      const field = event.currentTarget;
      if (this.props.autoResize && canUseDOM) {
        this.setAutoHeight(field);
      }
      if (this.props.onChange) {
        this.props.onChange(event, field.value);
      }
    };
    if (!props.id && !props["aria-label"]) {
      console.error("TextArea: TextArea requires either an id or aria-label to be specified");
    }
  }
  componentDidMount() {
    const inputRef = this.props.innerRef || this.inputRef;
    if (this.props.autoResize && canUseDOM) {
      const field = inputRef.current;
      this.setAutoHeight(field);
    }
  }
  render() {
    const _a2 = this.props, {
      className,
      value,
      validated,
      isRequired,
      isDisabled,
      readOnlyVariant,
      resizeOrientation,
      innerRef,
      disabled,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      autoResize,
      onChange,
      /* eslint-enable @typescript-eslint/no-unused-vars */
      onBlur,
      onFocus
    } = _a2, props = __rest(_a2, ["className", "value", "validated", "isRequired", "isDisabled", "readOnlyVariant", "resizeOrientation", "innerRef", "disabled", "autoResize", "onChange", "onBlur", "onFocus"]);
    const orientation = `resize${capitalize(resizeOrientation)}`;
    const hasStatusIcon = ["success", "error", "warning"].includes(validated);
    return React191.createElement(
      "span",
      { className: css(form_control_default.formControl, readOnlyVariant && form_control_default.modifiers.readonly, readOnlyVariant === "plain" && form_control_default.modifiers.plain, resizeOrientation && form_control_default.modifiers[orientation], isDisabled && form_control_default.modifiers.disabled, hasStatusIcon && form_control_default.modifiers[validated], className) },
      React191.createElement("textarea", Object.assign({ onChange: this.handleChange, onFocus, onBlur }, typeof this.props.defaultValue !== "string" && { value }, { "aria-invalid": validated === ValidatedOptions.error, required: isRequired, disabled: isDisabled || disabled, readOnly: !!readOnlyVariant, ref: innerRef || this.inputRef }, props)),
      hasStatusIcon && React191.createElement(
        "span",
        { className: css(form_control_default.formControlUtilities) },
        React191.createElement(FormControlIcon, { status: validated })
      )
    );
  }
};
TextAreaBase.displayName = "TextArea";
TextAreaBase.defaultProps = {
  innerRef: React191.createRef(),
  className: "",
  isRequired: false,
  isDisabled: false,
  validated: "default",
  resizeOrientation: "both",
  "aria-label": null
};
var TextArea = React191.forwardRef((props, ref) => React191.createElement(TextAreaBase, Object.assign({}, props, { innerRef: ref })));
TextArea.displayName = "TextArea";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/helpers/fileUtils.js
var fileReaderType;
(function(fileReaderType2) {
  fileReaderType2["text"] = "text";
  fileReaderType2["dataURL"] = "dataURL";
})(fileReaderType || (fileReaderType = {}));
function readFile(fileHandle, type2) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
    if (type2 === fileReaderType.text) {
      reader.readAsText(fileHandle);
    } else if (type2 === fileReaderType.dataURL) {
      reader.readAsDataURL(fileHandle);
    } else {
      reject("unknown type");
    }
  });
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/FileUpload/FileUploadField.js
var FileUploadField = (_a2) => {
  var { id: id2, name, type: type2, value = "", filename = "", onBrowseButtonClick = () => {
  }, onClearButtonClick = () => {
  }, onTextAreaClick, onTextChange, onTextAreaBlur, textAreaPlaceholder = "", className = "", isDisabled = false, isReadOnly = false, isLoading = false, spinnerAriaValueText, isRequired = false, isDragActive = false, validated = "default", "aria-label": ariaLabel = "File upload", filenamePlaceholder = "Drag a file here or browse to upload", filenameAriaLabel = filename ? "Read only filename" : filenamePlaceholder, browseButtonText = "Browse...", browseButtonAriaDescribedby, clearButtonText = "Clear", isClearButtonDisabled = !filename && !value, containerRef = null, allowEditingUploadedText = false, hideDefaultPreview = false, children: children2 = null } = _a2, props = __rest(_a2, ["id", "name", "type", "value", "filename", "onBrowseButtonClick", "onClearButtonClick", "onTextAreaClick", "onTextChange", "onTextAreaBlur", "textAreaPlaceholder", "className", "isDisabled", "isReadOnly", "isLoading", "spinnerAriaValueText", "isRequired", "isDragActive", "validated", "aria-label", "filenamePlaceholder", "filenameAriaLabel", "browseButtonText", "browseButtonAriaDescribedby", "clearButtonText", "isClearButtonDisabled", "containerRef", "allowEditingUploadedText", "hideDefaultPreview", "children"]);
  const onTextAreaChange = (event, newValue) => {
    onTextChange === null || onTextChange === void 0 ? void 0 : onTextChange(event, newValue);
  };
  return React192.createElement(
    "div",
    Object.assign({ className: css(file_upload_default.fileUpload, isDragActive && file_upload_default.modifiers.dragHover, isLoading && file_upload_default.modifiers.loading, className), ref: containerRef }, props),
    React192.createElement(
      "div",
      { className: file_upload_default.fileUploadFileSelect },
      React192.createElement(
        InputGroup,
        null,
        React192.createElement(
          InputGroupItem,
          { isFill: true },
          React192.createElement(TextInput, {
            readOnlyVariant: "default",
            isDisabled,
            id: `${id2}-filename`,
            name: name || `${id2}-filename`,
            "aria-label": filenameAriaLabel,
            placeholder: filenamePlaceholder,
            value: filename
          })
        ),
        React192.createElement(
          InputGroupItem,
          null,
          React192.createElement(Button, { variant: ButtonVariant.control, onClick: onBrowseButtonClick, isDisabled, "aria-describedby": browseButtonAriaDescribedby }, browseButtonText)
        ),
        React192.createElement(
          InputGroupItem,
          null,
          React192.createElement(Button, { variant: ButtonVariant.control, isDisabled: isDisabled || isClearButtonDisabled, onClick: onClearButtonClick }, clearButtonText)
        )
      )
    ),
    React192.createElement(
      "div",
      { className: file_upload_default.fileUploadFileDetails },
      !hideDefaultPreview && type2 === fileReaderType.text && React192.createElement(TextArea, { readOnly: isReadOnly || !!filename && !allowEditingUploadedText, disabled: isDisabled, isRequired, resizeOrientation: TextAreResizeOrientation.vertical, validated, id: id2, "aria-label": ariaLabel, value, onChange: onTextAreaChange, onClick: onTextAreaClick, onBlur: onTextAreaBlur, placeholder: textAreaPlaceholder }),
      isLoading && React192.createElement(
        "div",
        { className: file_upload_default.fileUploadFileDetailsSpinner },
        React192.createElement(Spinner, { size: spinnerSize.lg, "aria-valuetext": spinnerAriaValueText })
      )
    ),
    children2
  );
};
FileUploadField.displayName = "FileUploadField";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/FileUpload/FileUpload.js
var React193 = __toESM(require_react());
var FileUpload = (_a2) => {
  var { id: id2, type: type2, value = type2 === fileReaderType.text || type2 === fileReaderType.dataURL ? "" : null, filename = "", children: children2 = null, onFileInputChange = null, onReadStarted = () => {
  }, onReadFinished = () => {
  }, onReadFailed = () => {
  }, onClearClick, onClick = (event) => event.preventDefault(), onTextChange, onDataChange, dropzoneProps = {} } = _a2, props = __rest(_a2, ["id", "type", "value", "filename", "children", "onFileInputChange", "onReadStarted", "onReadFinished", "onReadFailed", "onClearClick", "onClick", "onTextChange", "onDataChange", "dropzoneProps"]);
  const onDropAccepted = (acceptedFiles, event) => {
    if (acceptedFiles.length > 0) {
      const fileHandle = acceptedFiles[0];
      onFileInputChange === null || onFileInputChange === void 0 ? void 0 : onFileInputChange(event, fileHandle);
      if (type2 === fileReaderType.text || type2 === fileReaderType.dataURL) {
        onReadStarted(event, fileHandle);
        readFile(fileHandle, type2).then((data) => {
          onReadFinished(event, fileHandle);
          onDataChange === null || onDataChange === void 0 ? void 0 : onDataChange(event, data);
        }).catch((error) => {
          onReadFailed(event, error, fileHandle);
          onReadFinished(event, fileHandle);
          onDataChange === null || onDataChange === void 0 ? void 0 : onDataChange(event, "");
        });
      }
    }
    dropzoneProps.onDropAccepted && dropzoneProps.onDropAccepted(acceptedFiles, event);
  };
  const onDropRejected = (rejectedFiles, event) => {
    dropzoneProps.onDropRejected && dropzoneProps.onDropRejected(rejectedFiles, event);
  };
  const onClearButtonClick = (event) => {
    onClearClick === null || onClearClick === void 0 ? void 0 : onClearClick(event);
    setFileValue(null);
  };
  const { getRootProps, getInputProps, isDragActive, open, inputRef } = useDropzone(Object.assign(Object.assign({ noClick: true, multiple: false }, dropzoneProps), {
    onDropAccepted,
    onDropRejected
  }));
  const setFileValue = (filename2) => {
    inputRef.current.value = filename2;
  };
  const oldInputProps = getInputProps();
  const inputProps = Object.assign(Object.assign({}, oldInputProps), { onChange: (e) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    (_b = oldInputProps.onChange) === null || _b === void 0 ? void 0 : _b.call(oldInputProps, e);
    const files = yield fromEvent(e.nativeEvent);
    if (files.length === 1) {
      onFileInputChange === null || onFileInputChange === void 0 ? void 0 : onFileInputChange(e, files[0]);
    }
  }) });
  const rootProps = getRootProps(Object.assign(Object.assign({}, props), {
    tabIndex: null,
    // Omit the unwanted tabIndex from react-dropzone's getRootProps
    id: id2,
    type: type2,
    filename,
    value,
    isDragActive,
    onBrowseButtonClick: open,
    onClearButtonClick,
    onTextAreaClick: onClick,
    onTextChange,
    onClick,
    refKey: "containerRef"
  }));
  return React193.createElement(
    FileUploadField,
    Object.assign({}, rootProps),
    React193.createElement("input", Object.assign({}, inputProps)),
    children2
  );
};
FileUpload.displayName = "FileUpload";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/FileUpload/FileUploadHelperText.js
var React194 = __toESM(require_react());
var FileUploadHelperText = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React194.createElement("div", Object.assign({ className: css(`${file_upload_default.fileUpload}__helper-text`, className) }, props), children2);
};
FileUploadHelperText.displayName = "FileUploadHelperText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/FormSelect/FormSelect.js
var React195 = __toESM(require_react());
var FormSelect = class _FormSelect extends React195.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event, event.currentTarget.value);
    };
    if (!props.id && !props["aria-label"]) {
      console.error("FormSelect requires either an id or aria-label to be specified");
    }
    this.state = {
      ouiaStateId: getDefaultOUIAId(_FormSelect.displayName, props.validated)
    };
  }
  render() {
    const _a2 = this.props, { children: children2, className, value, validated, isDisabled, isRequired, ouiaId, ouiaSafe } = _a2, props = __rest(_a2, ["children", "className", "value", "validated", "isDisabled", "isRequired", "ouiaId", "ouiaSafe"]);
    const selectedOption = React195.Children.toArray(children2).find((option) => option.props.value === value);
    const isSelectedPlaceholder = selectedOption && selectedOption.props.isPlaceholder;
    const hasStatusIcon = ["success", "error", "warning"].includes(validated);
    return React195.createElement(
      "span",
      { className: css(form_control_default.formControl, isDisabled && form_control_default.modifiers.disabled, isSelectedPlaceholder && form_control_default.modifiers.placeholder, hasStatusIcon && form_control_default.modifiers[validated], className) },
      React195.createElement("select", Object.assign({}, props, { "aria-invalid": validated === ValidatedOptions.error }, getOUIAProps(_FormSelect.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), { onChange: this.handleChange, disabled: isDisabled, required: isRequired, value }), children2),
      React195.createElement(
        "span",
        { className: css(form_control_default.formControlUtilities) },
        hasStatusIcon && React195.createElement(FormControlIcon, { status: validated }),
        React195.createElement(
          "span",
          { className: css(form_control_default.formControlToggleIcon) },
          React195.createElement(caret_down_icon_default, null)
        )
      )
    );
  }
};
FormSelect.displayName = "FormSelect";
FormSelect.defaultProps = {
  className: "",
  value: "",
  validated: "default",
  isDisabled: false,
  isRequired: false,
  onBlur: () => void 0,
  onFocus: () => void 0,
  onChange: () => void 0,
  ouiaSafe: true
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/FormSelect/FormSelectOption.js
var React196 = __toESM(require_react());
var FormSelectOption = (_a2) => {
  var {
    className = "",
    value = "",
    isDisabled = false,
    label,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isPlaceholder = false
  } = _a2, props = __rest(_a2, ["className", "value", "isDisabled", "label", "isPlaceholder"]);
  return React196.createElement("option", Object.assign({}, props, { className, value, disabled: isDisabled }), label);
};
FormSelectOption.displayName = "FormSelectOption";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/FormSelect/FormSelectOptionGroup.js
var React197 = __toESM(require_react());
var FormSelectOptionGroup = (_a2) => {
  var { children: children2 = null, className = "", isDisabled = false, label } = _a2, props = __rest(_a2, ["children", "className", "isDisabled", "label"]);
  return React197.createElement("optgroup", Object.assign({}, props, { disabled: !!isDisabled, className, label }), children2);
};
FormSelectOptionGroup.displayName = "FormSelectOptionGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Hint/Hint.js
var React198 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Hint/hint.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Hint/hint.css";
var hint_default = {
  "button": "pf-v6-c-button",
  "hint": "pf-v6-c-hint",
  "hintActions": "pf-v6-c-hint__actions",
  "hintBody": "pf-v6-c-hint__body",
  "hintFooter": "pf-v6-c-hint__footer",
  "hintTitle": "pf-v6-c-hint__title",
  "modifiers": {
    "link": "pf-m-link",
    "inline": "pf-m-inline",
    "noOffset": "pf-m-no-offset"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Hint/Hint.js
var Hint = (_a2) => {
  var { children: children2, className, actions, hasNoActionsOffset = false } = _a2, props = __rest(_a2, ["children", "className", "actions", "hasNoActionsOffset"]);
  return React198.createElement(
    "div",
    Object.assign({ className: css(hint_default.hint, className) }, props),
    actions && React198.createElement("div", { className: css(hint_default.hintActions, hasNoActionsOffset && hint_default.modifiers.noOffset) }, actions),
    children2
  );
};
Hint.displayName = "Hint";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Hint/HintBody.js
var React199 = __toESM(require_react());
var HintBody = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React199.createElement("div", Object.assign({ className: css(hint_default.hintBody, className) }, props), children2);
};
HintBody.displayName = "HintBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Hint/HintFooter.js
var React200 = __toESM(require_react());
var HintFooter = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React200.createElement("div", Object.assign({ className: css(hint_default.hintFooter, className) }, props), children2);
};
HintFooter.displayName = "HintFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Hint/HintTitle.js
var React201 = __toESM(require_react());
var HintTitle = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React201.createElement("div", Object.assign({ className: css(hint_default.hintTitle, className) }, props), children2);
};
HintTitle.displayName = "HintTitle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/JumpLinks/JumpLinks.js
var React204 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/JumpLinks/jump-links.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/JumpLinks/jump-links.css";
var jump_links_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "jumpLinks": "pf-v6-c-jump-links",
  "jumpLinksItem": "pf-v6-c-jump-links__item",
  "jumpLinksLabel": "pf-v6-c-jump-links__label",
  "jumpLinksLink": "pf-v6-c-jump-links__link",
  "jumpLinksLinkText": "pf-v6-c-jump-links__link-text",
  "jumpLinksList": "pf-v6-c-jump-links__list",
  "jumpLinksMain": "pf-v6-c-jump-links__main",
  "jumpLinksToggle": "pf-v6-c-jump-links__toggle",
  "jumpLinksToggleIcon": "pf-v6-c-jump-links__toggle-icon",
  "modifiers": {
    "center": "pf-m-center",
    "vertical": "pf-m-vertical",
    "expandable": "pf-m-expandable",
    "nonExpandable": "pf-m-non-expandable",
    "expandableOnSm": "pf-m-expandable-on-sm",
    "nonExpandableOnSm": "pf-m-non-expandable-on-sm",
    "expandableOnMd": "pf-m-expandable-on-md",
    "nonExpandableOnMd": "pf-m-non-expandable-on-md",
    "expandableOnLg": "pf-m-expandable-on-lg",
    "nonExpandableOnLg": "pf-m-non-expandable-on-lg",
    "expandableOnXl": "pf-m-expandable-on-xl",
    "nonExpandableOnXl": "pf-m-non-expandable-on-xl",
    "expandableOn_2xl": "pf-m-expandable-on-2xl",
    "nonExpandableOn_2xl": "pf-m-non-expandable-on-2xl",
    "expanded": "pf-m-expanded",
    "current": "pf-m-current"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Sidebar/sidebar.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Sidebar/sidebar.css";
var sidebar_default = {
  "modifiers": {
    "gutter": "pf-m-gutter",
    "panelRight": "pf-m-panel-right",
    "stack": "pf-m-stack",
    "split": "pf-m-split",
    "border": "pf-m-border",
    "padding": "pf-m-padding",
    "sticky": "pf-m-sticky",
    "static": "pf-m-static",
    "secondary": "pf-m-secondary",
    "noBackground": "pf-m-no-background",
    "widthDefault": "pf-m-width-default",
    "width_25": "pf-m-width-25",
    "width_33": "pf-m-width-33",
    "width_50": "pf-m-width-50",
    "width_66": "pf-m-width-66",
    "width_75": "pf-m-width-75",
    "width_100": "pf-m-width-100",
    "widthDefaultOnSm": "pf-m-width-default-on-sm",
    "width_25OnSm": "pf-m-width-25-on-sm",
    "width_33OnSm": "pf-m-width-33-on-sm",
    "width_50OnSm": "pf-m-width-50-on-sm",
    "width_66OnSm": "pf-m-width-66-on-sm",
    "width_75OnSm": "pf-m-width-75-on-sm",
    "width_100OnSm": "pf-m-width-100-on-sm",
    "widthDefaultOnMd": "pf-m-width-default-on-md",
    "width_25OnMd": "pf-m-width-25-on-md",
    "width_33OnMd": "pf-m-width-33-on-md",
    "width_50OnMd": "pf-m-width-50-on-md",
    "width_66OnMd": "pf-m-width-66-on-md",
    "width_75OnMd": "pf-m-width-75-on-md",
    "width_100OnMd": "pf-m-width-100-on-md",
    "widthDefaultOnLg": "pf-m-width-default-on-lg",
    "width_25OnLg": "pf-m-width-25-on-lg",
    "width_33OnLg": "pf-m-width-33-on-lg",
    "width_50OnLg": "pf-m-width-50-on-lg",
    "width_66OnLg": "pf-m-width-66-on-lg",
    "width_75OnLg": "pf-m-width-75-on-lg",
    "width_100OnLg": "pf-m-width-100-on-lg",
    "widthDefaultOnXl": "pf-m-width-default-on-xl",
    "width_25OnXl": "pf-m-width-25-on-xl",
    "width_33OnXl": "pf-m-width-33-on-xl",
    "width_50OnXl": "pf-m-width-50-on-xl",
    "width_66OnXl": "pf-m-width-66-on-xl",
    "width_75OnXl": "pf-m-width-75-on-xl",
    "width_100OnXl": "pf-m-width-100-on-xl",
    "widthDefaultOn_2xl": "pf-m-width-default-on-2xl",
    "width_25On_2xl": "pf-m-width-25-on-2xl",
    "width_33On_2xl": "pf-m-width-33-on-2xl",
    "width_50On_2xl": "pf-m-width-50-on-2xl",
    "width_66On_2xl": "pf-m-width-66-on-2xl",
    "width_75On_2xl": "pf-m-width-75-on-2xl",
    "width_100On_2xl": "pf-m-width-100-on-2xl"
  },
  "sidebar": "pf-v6-c-sidebar",
  "sidebarContent": "pf-v6-c-sidebar__content",
  "sidebarMain": "pf-v6-c-sidebar__main",
  "sidebarPanel": "pf-v6-c-sidebar__panel"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/JumpLinks/JumpLinksItem.js
var React203 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/JumpLinks/JumpLinksList.js
var React202 = __toESM(require_react());
var JumpLinksList = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React202.createElement("ul", Object.assign({ className: css(jump_links_default.jumpLinksList, className), role: "list" }, props), children2);
};
JumpLinksList.displayName = "JumpLinksList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/JumpLinks/JumpLinksItem.js
var JumpLinksItem = (_a2) => {
  var {
    isActive,
    href,
    // eslint-disable-next-line
    node,
    children: children2,
    onClick,
    className
  } = _a2, props = __rest(_a2, ["isActive", "href", "node", "children", "onClick", "className"]);
  const childrenArr = React203.Children.toArray(children2);
  const sublists = childrenArr.filter((child) => child.type === JumpLinksList);
  children2 = childrenArr.filter((child) => child.type !== JumpLinksList);
  return React203.createElement(
    "li",
    Object.assign({ className: css(jump_links_default.jumpLinksItem, isActive && jump_links_default.modifiers.current, className) }, isActive && { "aria-current": "location" }, props),
    React203.createElement(
      "span",
      { className: jump_links_default.jumpLinksLink },
      React203.createElement(
        Button,
        { variant: ButtonVariant.link, component: "a", href, onClick },
        React203.createElement("span", { className: jump_links_default.jumpLinksLinkText }, children2)
      )
    ),
    sublists
  );
};
JumpLinksItem.displayName = "JumpLinksItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/JumpLinks/JumpLinks.js
var getScrollItems = (children2, res) => {
  React204.Children.forEach(children2, (child) => {
    if (canUseDOM && document.getElementById && document.querySelector && child.type === JumpLinksItem) {
      const scrollNode = child.props.node || child.props.href;
      if (typeof scrollNode === "string") {
        if (scrollNode.startsWith("#")) {
          res.push(document.getElementById(scrollNode.substr(1)));
        } else {
          res.push(document.querySelector(scrollNode));
        }
      } else if (scrollNode instanceof HTMLElement) {
        res.push(scrollNode);
      }
    }
    if ([React204.Fragment, JumpLinksList, JumpLinksItem].includes(child.type)) {
      getScrollItems(child.props.children, res);
    }
  });
  return res;
};
function isResponsive(jumpLinks) {
  return jumpLinks && getComputedStyle(jumpLinks).getPropertyValue(c_jump_links_toggle_Display_default.name).includes("block");
}
var JumpLinks = (_a2) => {
  var { isCentered, isVertical, children: children2, label, "aria-label": ariaLabel = typeof label === "string" ? label : null, scrollableRef, scrollableSelector, activeIndex: activeIndexProp = 0, offset: offset3 = 0, expandable, isExpanded: isExpandedProp = false, alwaysShowLabel = true, toggleAriaLabel = "Toggle jump links", className } = _a2, props = __rest(_a2, ["isCentered", "isVertical", "children", "label", "aria-label", "scrollableRef", "scrollableSelector", "activeIndex", "offset", "expandable", "isExpanded", "alwaysShowLabel", "toggleAriaLabel", "className"]);
  const hasScrollSpy = Boolean(scrollableRef || scrollableSelector);
  const [scrollItems, setScrollItems] = React204.useState(hasScrollSpy ? getScrollItems(children2, []) : []);
  const [activeIndex, setActiveIndex] = React204.useState(activeIndexProp);
  const [isExpanded, setIsExpanded] = React204.useState(isExpandedProp);
  const isLinkClicked = React204.useRef(false);
  const navRef = React204.useRef();
  let scrollableElement;
  const getScrollableElement = () => {
    if (scrollableRef) {
      if (scrollableRef instanceof HTMLElement) {
        return scrollableRef;
      } else if (typeof scrollableRef === "function") {
        return scrollableRef();
      }
      return scrollableRef.current;
    } else if (scrollableSelector) {
      return document.querySelector(scrollableSelector);
    }
  };
  const scrollSpy = React204.useCallback(() => {
    if (!canUseDOM || !hasScrollSpy || !(scrollableElement instanceof HTMLElement)) {
      return;
    }
    if (isLinkClicked.current) {
      isLinkClicked.current = false;
      return;
    }
    const scrollPosition = Math.ceil(scrollableElement.scrollTop + offset3);
    window.requestAnimationFrame(() => {
      let newScrollItems = scrollItems;
      const requiresRefresh = newScrollItems.every((e) => !(e === null || e === void 0 ? void 0 : e.offsetTop)) || !newScrollItems[0] || newScrollItems.includes(null);
      if (requiresRefresh) {
        newScrollItems = getScrollItems(children2, []);
        setScrollItems(newScrollItems);
      }
      const scrollElements = newScrollItems.map((e, index4) => ({
        y: e ? e.offsetTop : null,
        index: index4
      })).filter(({ y: y4 }) => y4 !== null).sort((e1, e22) => e22.y - e1.y);
      for (const { y: y4, index: index4 } of scrollElements) {
        if (scrollPosition >= y4) {
          return setActiveIndex(index4);
        }
      }
    });
  }, [scrollItems, hasScrollSpy, scrollableElement, offset3]);
  React204.useEffect(() => {
    scrollableElement = getScrollableElement();
    if (!(scrollableElement instanceof HTMLElement)) {
      return;
    }
    scrollableElement.addEventListener("scroll", scrollSpy);
    return () => scrollableElement.removeEventListener("scroll", scrollSpy);
  }, [scrollableElement, scrollSpy, getScrollableElement]);
  React204.useEffect(() => {
    scrollSpy();
  }, []);
  let jumpLinkIndex = 0;
  const cloneChildren = (children3) => !hasScrollSpy ? children3 : React204.Children.map(children3, (child) => {
    if (child.type === JumpLinksItem) {
      const { onClick: onClickProp, isActive: isActiveProp } = child.props;
      const itemIndex = jumpLinkIndex++;
      const scrollItem = scrollItems[itemIndex];
      return React204.cloneElement(child, {
        onClick(ev) {
          isLinkClicked.current = true;
          let newScrollItems;
          if (!scrollItem) {
            newScrollItems = getScrollItems(children3, []);
            setScrollItems(newScrollItems);
          }
          const newScrollItem = scrollItem || newScrollItems[itemIndex];
          if (newScrollItem) {
            const scrollableElement2 = getScrollableElement();
            if (scrollableElement2 instanceof HTMLElement) {
              if (isResponsive(navRef.current)) {
                if (navRef.current) {
                  navRef.current.classList.remove(jump_links_default.modifiers.expanded);
                }
                let stickyParent = navRef.current && navRef.current.parentElement;
                while (stickyParent && !stickyParent.classList.contains(sidebar_default.modifiers.sticky)) {
                  stickyParent = stickyParent.parentElement;
                }
                setIsExpanded(false);
                if (stickyParent) {
                  offset3 += stickyParent.scrollHeight;
                }
              }
              scrollableElement2.scrollTo(0, newScrollItem.offsetTop - offset3);
            }
            newScrollItem.focus();
            window.history.pushState("", "", ev.currentTarget.href);
            ev.preventDefault();
            setActiveIndex(itemIndex);
          }
          if (onClickProp) {
            onClickProp(ev);
          }
        },
        isActive: isActiveProp || activeIndex === itemIndex,
        children: cloneChildren(child.props.children)
      });
    } else if (child.type === React204.Fragment) {
      return cloneChildren(child.props.children);
    } else if (child.type === JumpLinksList) {
      return React204.cloneElement(child, { children: cloneChildren(child.props.children) });
    }
    return child;
  });
  return React204.createElement(
    "nav",
    Object.assign({ className: css(jump_links_default.jumpLinks, isCentered && jump_links_default.modifiers.center, isVertical && jump_links_default.modifiers.vertical, formatBreakpointMods(expandable, jump_links_default), isExpanded && jump_links_default.modifiers.expanded, className), "aria-label": ariaLabel, ref: navRef }, props),
    React204.createElement(
      "div",
      { className: jump_links_default.jumpLinksMain },
      React204.createElement(
        "div",
        { className: css(`${jump_links_default.jumpLinks}__header`) },
        expandable && React204.createElement(
          "div",
          { className: jump_links_default.jumpLinksToggle },
          React204.createElement(
            Button,
            { variant: "plain", onClick: () => setIsExpanded(!isExpanded), "aria-label": toggleAriaLabel, "aria-expanded": isExpanded },
            React204.createElement(
              "span",
              { className: jump_links_default.jumpLinksToggleIcon },
              React204.createElement(angle_right_icon_default, null)
            ),
            label && React204.createElement(
              "span",
              { className: css(jump_links_default.jumpLinksToggleText) },
              " ",
              label,
              " "
            )
          )
        ),
        label && alwaysShowLabel && React204.createElement("div", { className: css(jump_links_default.jumpLinksLabel) }, label)
      ),
      React204.createElement("ul", { className: jump_links_default.jumpLinksList, role: "list" }, cloneChildren(children2))
    )
  );
};
JumpLinks.displayName = "JumpLinks";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Label/Label.js
var React205 = __toESM(require_react());
var import_react22 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Label/label.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Label/label.css";
var label_default = {
  "button": "pf-v6-c-button",
  "label": "pf-v6-c-label",
  "labelActions": "pf-v6-c-label__actions",
  "labelContent": "pf-v6-c-label__content",
  "labelIcon": "pf-v6-c-label__icon",
  "labelText": "pf-v6-c-label__text",
  "modifiers": {
    "blue": "pf-m-blue",
    "red": "pf-m-red",
    "orange": "pf-m-orange",
    "orangered": "pf-m-orangered",
    "yellow": "pf-m-yellow",
    "green": "pf-m-green",
    "teal": "pf-m-teal",
    "purple": "pf-m-purple",
    "success": "pf-m-success",
    "warning": "pf-m-warning",
    "danger": "pf-m-danger",
    "info": "pf-m-info",
    "custom": "pf-m-custom",
    "compact": "pf-m-compact",
    "filled": "pf-m-filled",
    "outline": "pf-m-outline",
    "editable": "pf-m-editable",
    "editableActive": "pf-m-editable-active",
    "overflow": "pf-m-overflow",
    "add": "pf-m-add",
    "clickable": "pf-m-clickable",
    "disabled": "pf-m-disabled"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Label/label-group.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Label/label-group.css";
var label_group_default = {
  "button": "pf-v6-c-button",
  "labelGroup": "pf-v6-c-label-group",
  "labelGroupClose": "pf-v6-c-label-group__close",
  "labelGroupLabel": "pf-v6-c-label-group__label",
  "labelGroupList": "pf-v6-c-label-group__list",
  "labelGroupListItem": "pf-v6-c-label-group__list-item",
  "labelGroupMain": "pf-v6-c-label-group__main",
  "labelGroupTextarea": "pf-v6-c-label-group__textarea",
  "modifiers": {
    "category": "pf-m-category",
    "vertical": "pf-m-vertical",
    "editable": "pf-m-editable",
    "textarea": "pf-m-textarea"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Label/Label.js
var colorStyles = {
  blue: label_default.modifiers.blue,
  cyan: label_default.modifiers.cyan,
  green: label_default.modifiers.green,
  orange: label_default.modifiers.orange,
  purple: label_default.modifiers.purple,
  red: label_default.modifiers.red,
  orangered: label_default.modifiers.orangered,
  gold: label_default.modifiers.gold,
  grey: ""
};
var statusIcons3 = {
  success: React205.createElement(check_circle_icon_default, null),
  warning: React205.createElement(exclamation_triangle_icon_default, null),
  danger: React205.createElement(exclamation_circle_icon_default, null),
  info: React205.createElement(info_circle_icon_default, null),
  custom: React205.createElement(bell_icon_default, null)
};
var Label = (_a2) => {
  var { children: children2, className = "", color: color2 = "grey", variant = "filled", status, isCompact = false, isDisabled = false, isEditable = false, editableProps, textMaxWidth, tooltipPosition, icon, onClose, onClick: onLabelClick, onEditCancel, onEditComplete, closeBtn, closeBtnAriaLabel, closeBtnProps, href, render } = _a2, props = __rest(_a2, ["children", "className", "color", "variant", "status", "isCompact", "isDisabled", "isEditable", "editableProps", "textMaxWidth", "tooltipPosition", "icon", "onClose", "onClick", "onEditCancel", "onEditComplete", "closeBtn", "closeBtnAriaLabel", "closeBtnProps", "href", "render"]);
  const [isEditableActive, setIsEditableActive] = (0, import_react22.useState)(false);
  const [currValue, setCurrValue] = (0, import_react22.useState)(children2);
  const editableButtonRef = React205.useRef();
  const editableInputRef = React205.useRef();
  const isOverflowLabel = variant === "overflow";
  const isAddLabel = variant === "add";
  const isClickable = onLabelClick && !isOverflowLabel && !isAddLabel || href;
  let _icon;
  if (status) {
    _icon = statusIcons3[status];
  }
  if (icon) {
    _icon = icon;
  }
  React205.useEffect(() => {
    document.addEventListener("mousedown", onDocMouseDown);
    document.addEventListener("keydown", onKeyDown);
    return () => {
      document.removeEventListener("mousedown", onDocMouseDown);
      document.removeEventListener("keydown", onKeyDown);
    };
  });
  React205.useEffect(() => {
    if (onLabelClick && href) {
      console.warn("Link labels cannot have onClick passed, this results in invalid HTML. Please remove either the href or onClick prop.");
    } else if (onLabelClick && isEditable) {
      console.warn("Editable labels cannot have onClick passed, clicking starts the label edit process. Please remove either the isEditable or onClick prop.");
    }
  }, [onLabelClick, href, isEditable]);
  const onDocMouseDown = (event) => {
    if (isEditableActive && editableInputRef && editableInputRef.current && !editableInputRef.current.contains(event.target)) {
      if (editableInputRef.current.value) {
        onEditComplete && onEditComplete(event, editableInputRef.current.value);
      }
      setIsEditableActive(false);
    }
  };
  const onKeyDown = (event) => {
    var _a3, _b;
    const key = event.key;
    if (!isEditableActive && (!editableButtonRef || !editableButtonRef.current || !editableButtonRef.current.contains(event.target)) || isEditableActive && (!editableInputRef || !editableInputRef.current || !editableInputRef.current.contains(event.target))) {
      return;
    }
    if (isEditableActive && (key === "Enter" || key === "Tab")) {
      event.preventDefault();
      event.stopImmediatePropagation();
      if (editableInputRef.current.value) {
        onEditComplete && onEditComplete(event, editableInputRef.current.value);
      }
      setIsEditableActive(false);
      (_a3 = editableButtonRef === null || editableButtonRef === void 0 ? void 0 : editableButtonRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
    }
    if (isEditableActive && key === "Escape") {
      event.preventDefault();
      event.stopImmediatePropagation();
      if (editableInputRef.current.value) {
        editableInputRef.current.value = children2;
        onEditCancel && onEditCancel(event, children2);
      }
      setIsEditableActive(false);
      (_b = editableButtonRef === null || editableButtonRef === void 0 ? void 0 : editableButtonRef.current) === null || _b === void 0 ? void 0 : _b.focus();
    }
    if (!isEditableActive && key === "Enter") {
      event.preventDefault();
      event.stopImmediatePropagation();
      setIsEditableActive(true);
      const el = event.target;
      const range4 = document.createRange();
      const sel = window.getSelection();
      range4.selectNodeContents(el);
      range4.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range4);
    }
  };
  const isClickableDisabled = (href || onLabelClick) && isDisabled;
  const defaultCloseButton = React205.createElement(
    Button,
    Object.assign({ type: "button", variant: "plain", hasNoPadding: true, onClick: onClose, "aria-label": closeBtnAriaLabel || `Close ${children2}` }, isClickableDisabled && { isDisabled: true }, closeBtnProps),
    React205.createElement(times_icon_default, null)
  );
  const closeButton = React205.createElement("span", { className: css(label_default.labelActions) }, closeBtn || defaultCloseButton);
  const textRef = React205.createRef();
  const componentRef = React205.useRef();
  const [isTooltipVisible, setIsTooltipVisible] = React205.useState(false);
  useIsomorphicLayoutEffect(() => {
    const currTextRef = isEditable ? editableButtonRef : textRef;
    if (!isEditableActive) {
      setIsTooltipVisible(currTextRef.current && currTextRef.current.offsetWidth < currTextRef.current.scrollWidth);
    }
  }, [isEditableActive]);
  const content = React205.createElement(
    React205.Fragment,
    null,
    _icon && React205.createElement("span", { className: css(label_default.labelIcon) }, _icon),
    React205.createElement("span", Object.assign({ ref: textRef, className: css(label_default.labelText) }, textMaxWidth && {
      style: {
        [c_label_text_MaxWidth_default.name]: textMaxWidth
      }
    }), children2)
  );
  React205.useEffect(() => {
    if (isEditableActive && editableInputRef) {
      editableInputRef.current && editableInputRef.current.focus();
    }
  }, [editableInputRef, isEditableActive]);
  const updateVal = () => {
    setCurrValue(editableInputRef.current.value);
  };
  let LabelComponentChildElement = "span";
  if (href) {
    LabelComponentChildElement = "a";
  } else if (isEditable || onLabelClick && !isOverflowLabel && !isAddLabel) {
    LabelComponentChildElement = "button";
  }
  const clickableLabelProps = {
    type: "button",
    onClick: onLabelClick
  };
  const isButton = LabelComponentChildElement === "button";
  const labelComponentChildProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ className: css(label_default.labelContent, isClickable && label_default.modifiers.clickable) }, isTooltipVisible && { tabIndex: 0 }), href && { href }), href && isDisabled && { onClick: (event) => event.preventDefault() }), isButton && clickableLabelProps), isEditable && Object.assign({ ref: editableButtonRef, onClick: (e) => {
    setIsEditableActive(true);
    e.stopPropagation();
  } }, editableProps)), isClickableDisabled && isButton && { disabled: true }), isClickableDisabled && href && { tabIndex: -1, "aria-disabled": true });
  let labelComponentChild = React205.createElement(LabelComponentChildElement, Object.assign({}, labelComponentChildProps), content);
  if (render) {
    labelComponentChild = React205.createElement(
      React205.Fragment,
      null,
      isTooltipVisible && React205.createElement(Tooltip, { triggerRef: componentRef, content: children2, position: tooltipPosition }),
      render({
        className: label_default.labelContent,
        content,
        componentRef
      })
    );
  } else if (isTooltipVisible) {
    labelComponentChild = React205.createElement(Tooltip, { content: children2, position: tooltipPosition }, labelComponentChild);
  }
  const LabelComponent = isOverflowLabel ? "button" : "span";
  return React205.createElement(
    LabelComponent,
    Object.assign({}, props, { className: css(label_default.label, isClickableDisabled && label_default.modifiers.disabled, colorStyles[color2], variant === "filled" && label_default.modifiers.filled, variant === "outline" && label_default.modifiers.outline, status && label_default.modifiers[status], isOverflowLabel && label_default.modifiers.overflow, isCompact && label_default.modifiers.compact, isEditable && label_group_default.modifiers.editable, isEditableActive && label_default.modifiers.editableActive, isClickable && label_default.modifiers.clickable, isAddLabel && label_default.modifiers.add, className), onClick: isOverflowLabel || isAddLabel ? onLabelClick : void 0 }),
    !isEditableActive && labelComponentChild,
    !isEditableActive && onClose && closeButton,
    isEditableActive && React205.createElement("input", Object.assign({ className: css(label_default.labelContent), type: "text", id: "editable-input", ref: editableInputRef, value: currValue, onChange: updateVal }, editableProps))
  );
};
Label.displayName = "Label";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Label/LabelGroup.js
var React206 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/times-circle-icon.js
var TimesCircleIconConfig = {
  name: "TimesCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z",
  yOffset: 0,
  xOffset: 0
};
var TimesCircleIcon = createIcon(TimesCircleIconConfig);
var times_circle_icon_default = TimesCircleIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Label/LabelGroup.js
var LabelGroup = class extends React206.Component {
  constructor(props) {
    super(props);
    this.headingRef = React206.createRef();
    this.toggleCollapse = () => {
      this.setState((prevState) => ({
        isOpen: !prevState.isOpen,
        isTooltipVisible: Boolean(this.headingRef.current && this.headingRef.current.offsetWidth < this.headingRef.current.scrollWidth)
      }));
    };
    this.state = {
      isOpen: this.props.defaultIsOpen,
      isTooltipVisible: false
    };
  }
  componentDidMount() {
    this.setState({
      isTooltipVisible: Boolean(this.headingRef.current && this.headingRef.current.offsetWidth < this.headingRef.current.scrollWidth)
    });
  }
  renderLabel(id2) {
    const { categoryName, tooltipPosition } = this.props;
    const { isTooltipVisible } = this.state;
    return isTooltipVisible ? React206.createElement(
      Tooltip,
      { position: tooltipPosition, content: categoryName },
      React206.createElement(
        "span",
        { tabIndex: 0, ref: this.headingRef, className: css(label_group_default.labelGroupLabel) },
        React206.createElement("span", { "aria-hidden": "true", id: id2 }, categoryName)
      )
    ) : React206.createElement("span", { ref: this.headingRef, className: css(label_group_default.labelGroupLabel), "aria-hidden": "true", id: id2 }, categoryName);
  }
  render() {
    const _a2 = this.props, {
      categoryName,
      children: children2,
      className,
      isClosable,
      isCompact,
      closeBtnAriaLabel,
      "aria-label": ariaLabel,
      onClick,
      numLabels,
      expandedText,
      collapsedText,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      defaultIsOpen,
      tooltipPosition,
      isVertical,
      isEditable,
      hasEditableTextArea,
      editableTextAreaProps,
      addLabelControl
    } = _a2, rest = __rest(_a2, ["categoryName", "children", "className", "isClosable", "isCompact", "closeBtnAriaLabel", "aria-label", "onClick", "numLabels", "expandedText", "collapsedText", "defaultIsOpen", "tooltipPosition", "isVertical", "isEditable", "hasEditableTextArea", "editableTextAreaProps", "addLabelControl"]);
    const { isOpen } = this.state;
    const renderedChildren = React206.Children.toArray(children2);
    const numChildren = renderedChildren.length;
    const collapsedTextResult = fillTemplate(collapsedText, {
      remaining: numChildren - numLabels
    });
    const renderLabelGroup = (id2) => {
      const labelArray = !isOpen ? renderedChildren.slice(0, numLabels) : renderedChildren;
      const content = React206.createElement(
        React206.Fragment,
        null,
        categoryName && this.renderLabel(id2),
        React206.createElement(
          "ul",
          Object.assign({ className: css(label_group_default.labelGroupList) }, categoryName && { "aria-labelledby": id2 }, !categoryName && { "aria-label": ariaLabel }, { role: "list" }, rest),
          labelArray.map((child, i) => React206.createElement("li", { className: css(label_group_default.labelGroupListItem), key: i }, child)),
          numChildren > numLabels && React206.createElement(
            "li",
            { className: css(label_group_default.labelGroupListItem) },
            React206.createElement(Label, { variant: "overflow", onClick: this.toggleCollapse, className: css(isCompact && label_default.modifiers.compact) }, isOpen ? expandedText : collapsedTextResult)
          ),
          addLabelControl && React206.createElement("li", { className: css(label_group_default.labelGroupListItem) }, addLabelControl),
          isEditable && hasEditableTextArea && React206.createElement(
            "li",
            { className: css(label_group_default.labelGroupListItem, label_group_default.modifiers.textarea) },
            React206.createElement("textarea", Object.assign({ className: css(label_group_default.labelGroupTextarea), rows: 1, tabIndex: 0 }, editableTextAreaProps))
          )
        )
      );
      const close = React206.createElement(
        "div",
        { className: css(label_group_default.labelGroupClose) },
        React206.createElement(
          Button,
          { variant: "plain", hasNoPadding: true, "aria-label": closeBtnAriaLabel, onClick, id: `remove_group_${id2}`, "aria-labelledby": `remove_group_${id2} ${id2}` },
          React206.createElement(times_circle_icon_default, { "aria-hidden": "true" })
        )
      );
      return React206.createElement(
        "div",
        { className: css(label_group_default.labelGroup, className, categoryName && label_group_default.modifiers.category, isVertical && label_group_default.modifiers.vertical, isEditable && label_group_default.modifiers.editable) },
        React206.createElement("div", { className: css(label_group_default.labelGroupMain) }, content),
        isClosable && close
      );
    };
    return numChildren === 0 && addLabelControl === void 0 ? null : React206.createElement(GenerateId, null, (randomId) => renderLabelGroup(this.props.id || randomId));
  }
};
LabelGroup.displayName = "LabelGroup";
LabelGroup.defaultProps = {
  expandedText: "Show Less",
  collapsedText: "${remaining} more",
  categoryName: "",
  defaultIsOpen: false,
  numLabels: 3,
  isClosable: false,
  isCompact: false,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onClick: (_e) => void 0,
  closeBtnAriaLabel: "Close label group",
  tooltipPosition: "top",
  "aria-label": "Label group category",
  isVertical: false,
  isEditable: false,
  hasEditableTextArea: false
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/List/List.js
var React207 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/List/list.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/List/list.css";
var list_default = {
  "list": "pf-v6-c-list",
  "listItem": "pf-v6-c-list__item",
  "listItemIcon": "pf-v6-c-list__item-icon",
  "modifiers": {
    "iconLg": "pf-m-icon-lg",
    "plain": "pf-m-plain",
    "inline": "pf-m-inline",
    "bordered": "pf-m-bordered"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/List/List.js
var OrderType;
(function(OrderType2) {
  OrderType2["number"] = "1";
  OrderType2["lowercaseLetter"] = "a";
  OrderType2["uppercaseLetter"] = "A";
  OrderType2["lowercaseRomanNumber"] = "i";
  OrderType2["uppercaseRomanNumber"] = "I";
})(OrderType || (OrderType = {}));
var ListVariant;
(function(ListVariant2) {
  ListVariant2["inline"] = "inline";
})(ListVariant || (ListVariant = {}));
var ListComponent;
(function(ListComponent2) {
  ListComponent2["ol"] = "ol";
  ListComponent2["ul"] = "ul";
})(ListComponent || (ListComponent = {}));
var List = (_a2) => {
  var { className = "", children: children2 = null, variant = null, isBordered = false, isPlain = false, iconSize = "default", type: type2 = OrderType.number, ref = null, component = ListComponent.ul } = _a2, props = __rest(_a2, ["className", "children", "variant", "isBordered", "isPlain", "iconSize", "type", "ref", "component"]);
  return component === ListComponent.ol ? React207.createElement("ol", Object.assign({ ref, type: type2 }, isPlain && { role: "list" }, props, { className: css(list_default.list, variant && list_default.modifiers[variant], isBordered && list_default.modifiers.bordered, isPlain && list_default.modifiers.plain, iconSize && iconSize === "large" && list_default.modifiers.iconLg, className) }), children2) : React207.createElement("ul", Object.assign({ ref }, isPlain && { role: "list" }, props, { className: css(list_default.list, variant && list_default.modifiers[variant], isBordered && list_default.modifiers.bordered, isPlain && list_default.modifiers.plain, iconSize && iconSize === "large" && list_default.modifiers.iconLg, className) }), children2);
};
List.displayName = "List";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/List/ListItem.js
var React208 = __toESM(require_react());
var ListItem = (_a2) => {
  var { icon = null, children: children2 = null } = _a2, props = __rest(_a2, ["icon", "children"]);
  return React208.createElement(
    "li",
    Object.assign({ className: css(icon && list_default.listItem) }, props),
    icon && React208.createElement("span", { className: css(list_default.listItemIcon) }, icon),
    React208.createElement("span", { className: icon && css(`${list_default.list}__item-text`) }, children2)
  );
};
ListItem.displayName = "ListItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginPage.js
var React215 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/Login.js
var React209 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Login/login.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Login/login.css";
var login_default = {
  "brand": "pf-v6-c-brand",
  "button": "pf-v6-c-button",
  "list": "pf-v6-c-list",
  "login": "pf-v6-c-login",
  "loginContainer": "pf-v6-c-login__container",
  "loginFooter": "pf-v6-c-login__footer",
  "loginHeader": "pf-v6-c-login__header",
  "loginMain": "pf-v6-c-login__main",
  "loginMainBody": "pf-v6-c-login__main-body",
  "loginMainFooter": "pf-v6-c-login__main-footer",
  "loginMainFooterBand": "pf-v6-c-login__main-footer-band",
  "loginMainFooterLinks": "pf-v6-c-login__main-footer-links",
  "loginMainFooterLinksItem": "pf-v6-c-login__main-footer-links-item",
  "loginMainHeader": "pf-v6-c-login__main-header",
  "loginMainHeaderDesc": "pf-v6-c-login__main-header-desc",
  "loginMainHeaderUtilities": "pf-v6-c-login__main-header-utilities",
  "menuToggle": "pf-v6-c-menu-toggle",
  "title": "pf-v6-c-title"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/Login.js
var Login = (_a2) => {
  var { className = "", children: children2 = null, footer = null, header = null } = _a2, props = __rest(_a2, ["className", "children", "footer", "header"]);
  return React209.createElement(
    "div",
    Object.assign({}, props, { className: css(login_default.login, className) }),
    React209.createElement(
      "div",
      { className: css(login_default.loginContainer) },
      header,
      React209.createElement("main", { className: css(login_default.loginMain) }, children2),
      footer
    )
  );
};
Login.displayName = "Login";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginHeader.js
var React210 = __toESM(require_react());
var LoginHeader = (_a2) => {
  var { className = "", children: children2 = null, headerBrand = null } = _a2, props = __rest(_a2, ["className", "children", "headerBrand"]);
  return React210.createElement(
    "header",
    Object.assign({ className: css(login_default.loginHeader, className) }, props),
    headerBrand,
    children2
  );
};
LoginHeader.displayName = "LoginHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginFooter.js
var React211 = __toESM(require_react());
var LoginFooter = (_a2) => {
  var { className = "", children: children2 = null } = _a2, props = __rest(_a2, ["className", "children"]);
  return React211.createElement("footer", Object.assign({ className: css(login_default.loginFooter, className) }, props), children2);
};
LoginFooter.displayName = "LoginFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginMainHeader.js
var React212 = __toESM(require_react());
var LoginMainHeader = (_a2) => {
  var { children: children2 = null, className = "", title = "", subtitle = "", headerUtilities = null } = _a2, props = __rest(_a2, ["children", "className", "title", "subtitle", "headerUtilities"]);
  return React212.createElement(
    "header",
    Object.assign({ className: css(login_default.loginMainHeader, className) }, props),
    title && React212.createElement(Title, { headingLevel: "h2", size: TitleSizes["3xl"] }, title),
    subtitle && React212.createElement("p", { className: css(login_default.loginMainHeaderDesc) }, subtitle),
    headerUtilities && React212.createElement("div", { className: css(login_default.loginMainHeaderUtilities) }, headerUtilities),
    children2
  );
};
LoginMainHeader.displayName = "LoginMainHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginMainBody.js
var React213 = __toESM(require_react());
var LoginMainBody = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React213.createElement("div", Object.assign({ className: css(login_default.loginMainBody, className) }, props), children2);
};
LoginMainBody.displayName = "LoginMainBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginMainFooter.js
var React214 = __toESM(require_react());
var LoginMainFooter = (_a2) => {
  var { children: children2 = null, socialMediaLoginContent = null, signUpForAccountMessage = null, forgotCredentials = null, className = "", socialMediaLoginAriaLabel } = _a2, props = __rest(_a2, ["children", "socialMediaLoginContent", "signUpForAccountMessage", "forgotCredentials", "className", "socialMediaLoginAriaLabel"]);
  return React214.createElement(
    "div",
    Object.assign({ className: css(login_default.loginMainFooter, className) }, props),
    children2,
    socialMediaLoginContent && React214.createElement("ul", { className: css(login_default.loginMainFooterLinks), "aria-label": socialMediaLoginAriaLabel, role: "list" }, socialMediaLoginContent),
    (signUpForAccountMessage || forgotCredentials) && React214.createElement(
      "div",
      { className: css(login_default.loginMainFooterBand) },
      signUpForAccountMessage,
      forgotCredentials
    )
  );
};
LoginMainFooter.displayName = "LoginMainFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginPage.js
var LoginPage = (_a2) => {
  var { children: children2 = null, className = "", brandImgSrc = "", brandImgAlt = "", backgroundImgSrc = "", footerListItems = null, textContent = "", footerListVariants, loginTitle, loginSubtitle, headerUtilities, signUpForAccountMessage = null, forgotCredentials = null, socialMediaLoginContent = null, socialMediaLoginAriaLabel } = _a2, props = __rest(_a2, ["children", "className", "brandImgSrc", "brandImgAlt", "backgroundImgSrc", "footerListItems", "textContent", "footerListVariants", "loginTitle", "loginSubtitle", "headerUtilities", "signUpForAccountMessage", "forgotCredentials", "socialMediaLoginContent", "socialMediaLoginAriaLabel"]);
  const HeaderBrand = React215.createElement(
    React215.Fragment,
    null,
    React215.createElement(Brand, { src: brandImgSrc, alt: brandImgAlt })
  );
  const Header = React215.createElement(LoginHeader, { headerBrand: HeaderBrand });
  const Footer = React215.createElement(
    LoginFooter,
    null,
    React215.createElement("p", null, textContent),
    React215.createElement(List, { variant: footerListVariants }, footerListItems)
  );
  return React215.createElement(
    React215.Fragment,
    null,
    backgroundImgSrc && React215.createElement(BackgroundImage, { src: backgroundImgSrc }),
    React215.createElement(
      Login,
      Object.assign({ header: Header, footer: Footer, className: css(className) }, props),
      React215.createElement(LoginMainHeader, { title: loginTitle, subtitle: loginSubtitle, headerUtilities }),
      React215.createElement(LoginMainBody, null, children2),
      (socialMediaLoginContent || forgotCredentials || signUpForAccountMessage) && React215.createElement(LoginMainFooter, { socialMediaLoginContent, socialMediaLoginAriaLabel, forgotCredentials, signUpForAccountMessage })
    )
  );
};
LoginPage.displayName = "LoginPage";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginForm.js
var React216 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/eye-slash-icon.js
var EyeSlashIconConfig = {
  name: "EyeSlashIcon",
  height: 512,
  width: 640,
  svgPath: "M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z",
  yOffset: 0,
  xOffset: 0
};
var EyeSlashIcon = createIcon(EyeSlashIconConfig);
var eye_slash_icon_default = EyeSlashIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/eye-icon.js
var EyeIconConfig = {
  name: "EyeIcon",
  height: 512,
  width: 576,
  svgPath: "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z",
  yOffset: 0,
  xOffset: 0
};
var EyeIcon = createIcon(EyeIconConfig);
var eye_icon_default = EyeIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginForm.js
var LoginForm = (_a2) => {
  var { noAutoFocus = false, className = "", showHelperText = false, helperText = null, helperTextIcon = null, usernameLabel = "Username", usernameValue = "", onChangeUsername = () => void 0, isValidUsername = true, passwordLabel = "Password", passwordValue = "", onChangePassword = () => void 0, isShowPasswordEnabled = false, hidePasswordAriaLabel = "Hide password", showPasswordAriaLabel = "Show password", isValidPassword = true, loginButtonLabel = "Log In", isLoginButtonDisabled = false, onLoginButtonClick = () => void 0, rememberMeLabel = "", isRememberMeChecked = false, onChangeRememberMe = () => void 0 } = _a2, props = __rest(_a2, ["noAutoFocus", "className", "showHelperText", "helperText", "helperTextIcon", "usernameLabel", "usernameValue", "onChangeUsername", "isValidUsername", "passwordLabel", "passwordValue", "onChangePassword", "isShowPasswordEnabled", "hidePasswordAriaLabel", "showPasswordAriaLabel", "isValidPassword", "loginButtonLabel", "isLoginButtonDisabled", "onLoginButtonClick", "rememberMeLabel", "isRememberMeChecked", "onChangeRememberMe"]);
  const [passwordHidden, setPasswordHidden] = React216.useState(true);
  const passwordInput = React216.createElement(TextInput, { isRequired: true, type: passwordHidden ? "password" : "text", id: "pf-login-password-id", name: "pf-login-password-id", validated: isValidPassword ? ValidatedOptions.default : ValidatedOptions.error, value: passwordValue, onChange: onChangePassword });
  return React216.createElement(
    Form,
    Object.assign({ className }, props),
    showHelperText && React216.createElement(
      FormHelperText,
      null,
      React216.createElement(
        HelperText,
        null,
        React216.createElement(HelperTextItem, { variant: !isValidUsername || !isValidPassword ? "error" : "default", icon: helperTextIcon }, helperText)
      )
    ),
    React216.createElement(
      FormGroup,
      { label: usernameLabel, isRequired: true, fieldId: "pf-login-username-id" },
      React216.createElement(TextInput, { autoFocus: !noAutoFocus, id: "pf-login-username-id", isRequired: true, validated: isValidUsername ? ValidatedOptions.default : ValidatedOptions.error, type: "text", name: "pf-login-username-id", value: usernameValue, onChange: onChangeUsername })
    ),
    React216.createElement(
      FormGroup,
      { label: passwordLabel, isRequired: true, fieldId: "pf-login-password-id" },
      isShowPasswordEnabled && React216.createElement(
        InputGroup,
        null,
        React216.createElement(InputGroupItem, { isFill: true }, passwordInput),
        React216.createElement(
          InputGroupItem,
          null,
          React216.createElement(Button, { variant: "control", onClick: () => setPasswordHidden(!passwordHidden), "aria-label": passwordHidden ? showPasswordAriaLabel : hidePasswordAriaLabel }, passwordHidden ? React216.createElement(eye_icon_default, null) : React216.createElement(eye_slash_icon_default, null))
        )
      ),
      !isShowPasswordEnabled && passwordInput
    ),
    rememberMeLabel.length > 0 && React216.createElement(
      FormGroup,
      { fieldId: "pf-login-remember-me-id" },
      React216.createElement(Checkbox, { id: "pf-login-remember-me-id", label: rememberMeLabel, isChecked: isRememberMeChecked, onChange: onChangeRememberMe })
    ),
    React216.createElement(
      ActionGroup,
      null,
      React216.createElement(Button, { variant: "primary", type: "submit", onClick: onLoginButtonClick, isBlock: true, isDisabled: isLoginButtonDisabled }, loginButtonLabel)
    )
  );
};
LoginForm.displayName = "LoginForm";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginFooterItem.js
var React217 = __toESM(require_react());
var LoginFooterItem = (_a2) => {
  var { children: children2 = null, href = "#", target = "_blank" } = _a2, props = __rest(_a2, ["children", "href", "target"]);
  return React217.isValidElement(children2) ? children2 : React217.createElement("a", Object.assign({ target, href }, props), children2);
};
LoginFooterItem.displayName = "LoginFooterItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginMainFooterBandItem.js
var React218 = __toESM(require_react());
var LoginMainFooterBandItem = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React218.createElement("p", Object.assign({ className: css(`${login_default.loginMainFooterBand}-item`, className) }, props), children2);
};
LoginMainFooterBandItem.displayName = "LoginMainFooterBandItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/LoginPage/LoginMainFooterLinksItem.js
var React219 = __toESM(require_react());
var LoginMainFooterLinksItem = (_a2) => {
  var { children: children2 = null, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React219.createElement("li", Object.assign({ className: css(login_default.loginMainFooterLinksItem, className) }, props), children2);
};
LoginMainFooterLinksItem.displayName = "LoginMainFooterLinksItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Masthead/Masthead.js
var React221 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Masthead/masthead.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Masthead/masthead.css";
var masthead_default = {
  "masthead": "pf-v6-c-masthead",
  "mastheadBrand": "pf-v6-c-masthead__brand",
  "mastheadContent": "pf-v6-c-masthead__content",
  "mastheadExpandableContent": "pf-v6-c-masthead__expandable-content",
  "mastheadLogo": "pf-v6-c-masthead__logo",
  "mastheadMain": "pf-v6-c-masthead__main",
  "mastheadToggle": "pf-v6-c-masthead__toggle",
  "modifiers": {
    "resizeObserver": "pf-m-resize-observer",
    "displayStack": "pf-m-display-stack",
    "displayInline": "pf-m-display-inline",
    "insetNone": "pf-m-inset-none",
    "insetSm": "pf-m-inset-sm",
    "insetMd": "pf-m-inset-md",
    "insetLg": "pf-m-inset-lg",
    "insetXl": "pf-m-inset-xl",
    "inset_2xl": "pf-m-inset-2xl",
    "displayStackOnSm": "pf-m-display-stack-on-sm",
    "displayInlineOnSm": "pf-m-display-inline-on-sm",
    "displayStackOnMd": "pf-m-display-stack-on-md",
    "displayInlineOnMd": "pf-m-display-inline-on-md",
    "displayStackOnLg": "pf-m-display-stack-on-lg",
    "displayInlineOnLg": "pf-m-display-inline-on-lg",
    "displayStackOnXl": "pf-m-display-stack-on-xl",
    "displayInlineOnXl": "pf-m-display-inline-on-xl",
    "displayStackOn_2xl": "pf-m-display-stack-on-2xl",
    "displayInlineOn_2xl": "pf-m-display-inline-on-2xl"
  },
  "toolbar": "pf-v6-c-toolbar",
  "toolbarContentSection": "pf-v6-c-toolbar__content-section",
  "toolbarExpandableContent": "pf-v6-c-toolbar__expandable-content"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/PageContext.js
var React220 = __toESM(require_react());
var pageContextDefaults = {
  isManagedSidebar: false,
  isSidebarOpen: false,
  onSidebarToggle: () => null,
  width: null,
  height: null,
  getBreakpoint,
  getVerticalBreakpoint
};
var PageContext = React220.createContext(pageContextDefaults);
var PageContextProvider = PageContext.Provider;
var PageContextConsumer = PageContext.Consumer;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Masthead/Masthead.js
var Masthead = (_a2) => {
  var { children: children2, className, display = {
    md: "inline"
  }, inset } = _a2, props = __rest(_a2, ["children", "className", "display", "inset"]);
  const { width, getBreakpoint: getBreakpoint2 } = React221.useContext(PageContext);
  return React221.createElement("header", Object.assign({ className: css(masthead_default.masthead, formatBreakpointMods(display, masthead_default, "display-", getBreakpoint2(width)), formatBreakpointMods(inset, masthead_default, "", getBreakpoint2(width)), className) }, props), children2);
};
Masthead.displayName = "Masthead";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Masthead/MastheadBrand.js
var React222 = __toESM(require_react());
var MastheadBrand = (_a2) => {
  var { children: children2, className, component } = _a2, props = __rest(_a2, ["children", "className", "component"]);
  let Component50 = component;
  if (!component) {
    if ((props === null || props === void 0 ? void 0 : props.href) !== void 0) {
      Component50 = "a";
    } else {
      Component50 = "span";
    }
  }
  return React222.createElement(Component50, Object.assign({ className: css(masthead_default.mastheadBrand, className) }, Component50 === "a" && { tabIndex: 0 }, props), children2);
};
MastheadBrand.displayName = "MastheadBrand";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Masthead/MastheadContent.js
var React223 = __toESM(require_react());
var MastheadContent = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React223.createElement("div", Object.assign({ className: css(masthead_default.mastheadContent, className) }, props), children2);
};
MastheadContent.displayName = "MastheadContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Masthead/MastheadMain.js
var React224 = __toESM(require_react());
var MastheadMain = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React224.createElement("div", Object.assign({ className: css(masthead_default.mastheadMain, className) }, props), children2);
};
MastheadMain.displayName = "MastheadMain";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Masthead/MastheadToggle.js
var React225 = __toESM(require_react());
var MastheadToggle = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React225.createElement("span", Object.assign({ className: css(masthead_default.mastheadToggle, className) }, props), children2);
};
MastheadToggle.displayName = "MastheadToggle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/Modal.js
var React229 = __toESM(require_react());
var ReactDOM5 = __toESM(require_react_dom());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalContent.js
var React228 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalBoxCloseButton.js
var React226 = __toESM(require_react());
var ModalBoxCloseButton2 = (_a2) => {
  var { className, onClose, "aria-label": ariaLabel = "Close", ouiaId } = _a2, props = __rest(_a2, ["className", "onClose", "aria-label", "ouiaId"]);
  return React226.createElement(
    "div",
    { className: css(modal_box_default.modalBoxClose, className) },
    React226.createElement(
      Button,
      Object.assign({ variant: "plain", onClick: (event) => onClose(event), "aria-label": ariaLabel }, ouiaId && { ouiaId: `${ouiaId}-${ModalBoxCloseButton2.displayName}` }, props),
      React226.createElement(times_icon_default, null)
    )
  );
};
ModalBoxCloseButton2.displayName = "ModalBoxCloseButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalBox.js
var React227 = __toESM(require_react());
var ModalBox2 = (_a2) => {
  var { children: children2, className, variant = "default", position, positionOffset, "aria-labelledby": ariaLabelledby, "aria-label": ariaLabel, "aria-describedby": ariaDescribedby, style } = _a2, props = __rest(_a2, ["children", "className", "variant", "position", "positionOffset", "aria-labelledby", "aria-label", "aria-describedby", "style"]);
  if (positionOffset) {
    style = style || {};
    style[c_modal_box_m_align_top_spacer_default.name] = positionOffset;
  }
  return React227.createElement("div", Object.assign({ role: "dialog", "aria-label": ariaLabel || null, "aria-labelledby": ariaLabelledby || null, "aria-describedby": ariaDescribedby, "aria-modal": "true", className: css(modal_box_default.modalBox, className, position === "top" && modal_box_default.modifiers.alignTop, variant === "large" && modal_box_default.modifiers.lg, variant === "small" && modal_box_default.modifiers.sm, variant === "medium" && modal_box_default.modifiers.md), style }, props), children2);
};
ModalBox2.displayName = "ModalBox";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalContent.js
var ModalContent2 = (_a2) => {
  var { children: children2, className, isOpen = false, "aria-label": ariaLabel, "aria-describedby": ariaDescribedby, "aria-labelledby": ariaLabelledby, onClose, variant = "default", position, positionOffset, width, maxWidth, boxId, disableFocusTrap = false, ouiaId, ouiaSafe = true, elementToFocus } = _a2, props = __rest(_a2, ["children", "className", "isOpen", "aria-label", "aria-describedby", "aria-labelledby", "onClose", "variant", "position", "positionOffset", "width", "maxWidth", "boxId", "disableFocusTrap", "ouiaId", "ouiaSafe", "elementToFocus"]);
  if (!isOpen) {
    return null;
  }
  const ariaLabelledbyFormatted = () => {
    const idRefList = [];
    if (ariaLabel && boxId) {
      idRefList.push(ariaLabel && boxId);
    }
    if (ariaLabelledby) {
      idRefList.push(ariaLabelledby);
    }
    if (idRefList.length === 0) {
      return void 0;
    } else {
      return idRefList.join(" ");
    }
  };
  const modalBox = React228.createElement(
    ModalBox2,
    Object.assign({ className: css(className), variant, position, positionOffset, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledbyFormatted(), "aria-describedby": ariaDescribedby }, getOUIAProps(ModalContent2.displayName, ouiaId, ouiaSafe), { style: Object.assign(Object.assign({}, width && { "--pf-v6-c-modal-box--Width": typeof width !== "number" ? width : `${width}px` }), maxWidth && {
      "--pf-v6-c-modal-box--MaxWidth": typeof maxWidth !== "number" ? maxWidth : `${maxWidth}px`
    }) }, props, { id: boxId }),
    onClose && React228.createElement(ModalBoxCloseButton2, { onClose: (event) => onClose(event), ouiaId }),
    children2
  );
  return React228.createElement(
    Backdrop,
    null,
    React228.createElement(FocusTrap, { active: !disableFocusTrap, focusTrapOptions: {
      clickOutsideDeactivates: true,
      tabbableOptions: { displayCheck: "none" },
      // FocusTrap's initialFocus can accept false as a value to prevent initial focus.
      // We want to prevent this in case false is ever passed in.
      initialFocus: elementToFocus || void 0
    }, className: css(bullseye_default.bullseye) }, modalBox)
  );
};
ModalContent2.displayName = "ModalContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/Modal.js
var ModalVariant2;
(function(ModalVariant3) {
  ModalVariant3["small"] = "small";
  ModalVariant3["medium"] = "medium";
  ModalVariant3["large"] = "large";
  ModalVariant3["default"] = "default";
})(ModalVariant2 || (ModalVariant2 = {}));
var Modal2 = class _Modal extends React229.Component {
  constructor(props) {
    super(props);
    this.boxId = "";
    this.handleEscKeyClick = (event) => {
      var _a2, _b;
      const { onEscapePress } = this.props;
      if (event.key === KeyTypes.Escape && this.props.isOpen) {
        onEscapePress ? onEscapePress(event) : (_b = (_a2 = this.props).onClose) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      }
    };
    this.getElement = (appendTo) => {
      if (typeof appendTo === "function") {
        return appendTo();
      }
      return appendTo || document.body;
    };
    this.toggleSiblingsFromScreenReaders = (hide3) => {
      const { appendTo } = this.props;
      const target = this.getElement(appendTo);
      const bodyChildren = target.children;
      for (const child of Array.from(bodyChildren)) {
        if (child !== this.state.container) {
          hide3 ? child.setAttribute("aria-hidden", "" + hide3) : child.removeAttribute("aria-hidden");
        }
      }
    };
    this.isEmpty = (value) => value === null || value === void 0 || value === "";
    const boxIdNum = _Modal.currentId++;
    this.boxId = props.id || `pf-modal-part-${boxIdNum}`;
    this.state = {
      container: void 0,
      ouiaStateId: getDefaultOUIAId(_Modal.displayName, props.variant)
    };
  }
  componentDidMount() {
    const { appendTo, "aria-describedby": ariaDescribedby, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby } = this.props;
    const target = this.getElement(appendTo);
    const container = document.createElement("div");
    this.setState({ container });
    target.appendChild(container);
    target.addEventListener("keydown", this.handleEscKeyClick, false);
    if (this.props.isOpen) {
      target.classList.add(css(backdrop_default.backdropOpen));
    } else {
      target.classList.remove(css(backdrop_default.backdropOpen));
    }
    if (!ariaDescribedby && !ariaLabel && !ariaLabelledby) {
      console.error("Modal: Specify at least one of: aria-describedby, aria-label, aria-labelledby.");
    }
  }
  componentDidUpdate() {
    const { appendTo } = this.props;
    const target = this.getElement(appendTo);
    if (this.props.isOpen) {
      target.classList.add(css(backdrop_default.backdropOpen));
      this.toggleSiblingsFromScreenReaders(true);
    } else {
      target.classList.remove(css(backdrop_default.backdropOpen));
      this.toggleSiblingsFromScreenReaders(false);
    }
  }
  componentWillUnmount() {
    const { appendTo } = this.props;
    const target = this.getElement(appendTo);
    if (this.state.container) {
      target.removeChild(this.state.container);
    }
    target.removeEventListener("keydown", this.handleEscKeyClick, false);
    target.classList.remove(css(backdrop_default.backdropOpen));
    this.toggleSiblingsFromScreenReaders(false);
  }
  render() {
    const _a2 = this.props, {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      appendTo,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onEscapePress,
      "aria-labelledby": ariaLabelledby,
      "aria-label": ariaLabel,
      "aria-describedby": ariaDescribedby,
      ouiaId,
      ouiaSafe,
      position,
      elementToFocus
    } = _a2, props = __rest(_a2, ["appendTo", "onEscapePress", "aria-labelledby", "aria-label", "aria-describedby", "ouiaId", "ouiaSafe", "position", "elementToFocus"]);
    const { container } = this.state;
    if (!canUseDOM || !container) {
      return null;
    }
    return ReactDOM5.createPortal(React229.createElement(ModalContent2, Object.assign({ boxId: this.boxId, "aria-label": ariaLabel, "aria-describedby": ariaDescribedby, "aria-labelledby": ariaLabelledby, ouiaId: ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe, position, elementToFocus }, props)), container);
  }
};
Modal2.displayName = "Modal";
Modal2.currentId = 0;
Modal2.defaultProps = {
  isOpen: false,
  variant: "default",
  appendTo: () => document.body,
  ouiaSafe: true,
  position: "default"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalBody.js
var React230 = __toESM(require_react());
var ModalBody = (_a2) => {
  var { children: children2, className, "aria-label": ariaLabel, role } = _a2, props = __rest(_a2, ["children", "className", "aria-label", "role"]);
  const defaultModalBodyRole = ariaLabel ? "region" : void 0;
  return React230.createElement("div", Object.assign({ "aria-label": ariaLabel, role: role || defaultModalBodyRole, className: css(modal_box_default.modalBoxBody, className) }, props), children2);
};
ModalBody.displayName = "ModalBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalHeader.js
var React233 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalBoxDescription.js
var React231 = __toESM(require_react());
var ModalBoxDescription2 = (_a2) => {
  var { children: children2 = null, className = "", id: id2 = "" } = _a2, props = __rest(_a2, ["children", "className", "id"]);
  return React231.createElement("div", Object.assign({}, props, { id: id2, className: css(modal_box_default.modalBoxDescription, className) }), children2);
};
ModalBoxDescription2.displayName = "ModalBoxDescription";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalBoxTitle.js
var React232 = __toESM(require_react());
var isVariantIcon2 = (icon) => ["success", "danger", "warning", "info", "custom"].includes(icon);
var ModalBoxTitle2 = (_a2) => {
  var { className, id: id2, title, titleIconVariant, titleScreenReaderText } = _a2, props = __rest(_a2, ["className", "id", "title", "titleIconVariant", "titleScreenReaderText"]);
  const [hasTooltip, setHasTooltip] = React232.useState(false);
  const h1 = React232.useRef(null);
  const label = titleScreenReaderText || (isVariantIcon2(titleIconVariant) ? `${capitalize(titleIconVariant)} alert:` : titleScreenReaderText);
  const variantIcons4 = {
    success: React232.createElement(check_circle_icon_default, null),
    danger: React232.createElement(exclamation_circle_icon_default, null),
    warning: React232.createElement(exclamation_triangle_icon_default, null),
    info: React232.createElement(info_circle_icon_default, null),
    custom: React232.createElement(bell_icon_default, null)
  };
  const CustomIcon = !isVariantIcon2(titleIconVariant) && titleIconVariant;
  useIsomorphicLayoutEffect(() => {
    setHasTooltip(h1.current && h1.current.offsetWidth < h1.current.scrollWidth);
  }, []);
  const content = React232.createElement(
    "h1",
    Object.assign({ id: id2, ref: h1, className: css(modal_box_default.modalBoxTitle, titleIconVariant && modal_box_default.modifiers.icon, isVariantIcon2(titleIconVariant) && modal_box_default.modifiers[titleIconVariant], className) }, props),
    titleIconVariant && React232.createElement("span", { className: css(modal_box_default.modalBoxTitleIcon) }, isVariantIcon2(titleIconVariant) ? variantIcons4[titleIconVariant] : React232.createElement(CustomIcon, null)),
    label && React232.createElement("span", { className: "pf-v6-screen-reader" }, label),
    React232.createElement("span", { className: css(modal_box_default.modalBoxTitleText) }, title)
  );
  return hasTooltip ? React232.createElement(Tooltip, { content: title }, content) : content;
};
ModalBoxTitle2.displayName = "ModalBoxTitle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalHeader.js
var ModalHeader = (_a2) => {
  var { children: children2, className, descriptorId, description, labelId, title, titleIconVariant, titleScreenReaderText, help } = _a2, props = __rest(_a2, ["children", "className", "descriptorId", "description", "labelId", "title", "titleIconVariant", "titleScreenReaderText", "help"]);
  const headerContent = children2 ? children2 : React233.createElement(
    React233.Fragment,
    null,
    React233.createElement(ModalBoxTitle2, { title, titleIconVariant, titleScreenReaderText, id: labelId }),
    description && React233.createElement(ModalBoxDescription2, { id: descriptorId }, description)
  );
  return React233.createElement(
    "header",
    Object.assign({ className: css(modal_box_default.modalBoxHeader, help && modal_box_default.modifiers.help, className) }, props),
    help && React233.createElement(
      React233.Fragment,
      null,
      React233.createElement("div", { className: css(modal_box_default.modalBoxHeaderMain) }, headerContent),
      React233.createElement("div", { className: `${modal_box_default.modalBoxHeader}-help` }, help)
    ),
    !help && headerContent
  );
};
ModalHeader.displayName = "ModalHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Modal/ModalFooter.js
var React234 = __toESM(require_react());
var ModalFooter = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React234.createElement("footer", Object.assign({}, props, { className: css(modal_box_default.modalBoxFooter, className) }), children2);
};
ModalFooter.displayName = "ModalFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUpload.js
var React235 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/MultipleFileUpload/multiple-file-upload.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/MultipleFileUpload/multiple-file-upload.css";
var multiple_file_upload_default = {
  "modifiers": {
    "horizontal": "pf-m-horizontal",
    "dragOver": "pf-m-drag-over"
  },
  "multipleFileUpload": "pf-v6-c-multiple-file-upload",
  "multipleFileUploadInfo": "pf-v6-c-multiple-file-upload__info",
  "multipleFileUploadMain": "pf-v6-c-multiple-file-upload__main",
  "multipleFileUploadStatus": "pf-v6-c-multiple-file-upload__status",
  "multipleFileUploadStatusItem": "pf-v6-c-multiple-file-upload__status-item",
  "multipleFileUploadStatusItemIcon": "pf-v6-c-multiple-file-upload__status-item-icon",
  "multipleFileUploadStatusItemMain": "pf-v6-c-multiple-file-upload__status-item-main",
  "multipleFileUploadStatusItemProgress": "pf-v6-c-multiple-file-upload__status-item-progress",
  "multipleFileUploadStatusItemProgressSize": "pf-v6-c-multiple-file-upload__status-item-progress-size",
  "multipleFileUploadStatusItemProgressText": "pf-v6-c-multiple-file-upload__status-item-progress-text",
  "multipleFileUploadStatusProgress": "pf-v6-c-multiple-file-upload__status-progress",
  "multipleFileUploadStatusProgressIcon": "pf-v6-c-multiple-file-upload__status-progress-icon",
  "multipleFileUploadTitle": "pf-v6-c-multiple-file-upload__title",
  "multipleFileUploadTitleIcon": "pf-v6-c-multiple-file-upload__title-icon",
  "multipleFileUploadTitleText": "pf-v6-c-multiple-file-upload__title-text",
  "multipleFileUploadTitleTextSeparator": "pf-v6-c-multiple-file-upload__title-text-separator",
  "multipleFileUploadUpload": "pf-v6-c-multiple-file-upload__upload"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUpload.js
var MultipleFileUploadContext = React235.createContext({
  open: () => {
  }
});
var MultipleFileUpload = (_a2) => {
  var { className, children: children2, dropzoneProps = {}, isHorizontal, onFileDrop = () => {
  } } = _a2, props = __rest(_a2, ["className", "children", "dropzoneProps", "isHorizontal", "onFileDrop"]);
  const onDropAccepted = (acceptedFiles, event) => {
    onFileDrop(event, acceptedFiles);
    dropzoneProps.onDropAccepted && dropzoneProps.onDropAccepted(acceptedFiles, event);
  };
  const { getRootProps, getInputProps, isDragActive, open } = useDropzone(Object.assign(Object.assign({ multiple: true }, dropzoneProps), { onDropAccepted }));
  const rootProps = getRootProps(Object.assign(Object.assign({}, props), {
    onClick: (event) => event.stopPropagation()
    // Prevents clicking TextArea from opening file dialog
  }));
  return React235.createElement(
    MultipleFileUploadContext.Provider,
    { value: { open } },
    React235.createElement(
      "div",
      Object.assign({ className: css(multiple_file_upload_default.multipleFileUpload, isDragActive && multiple_file_upload_default.modifiers.dragOver, isHorizontal && multiple_file_upload_default.modifiers.horizontal, className) }, rootProps, props),
      React235.createElement("input", Object.assign({}, getInputProps())),
      children2
    )
  );
};
MultipleFileUpload.displayName = "MultipleFileUpload";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadMain.js
var React242 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadTitle.js
var React239 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadTitleIcon.js
var React236 = __toESM(require_react());
var MultipleFileUploadTitleIcon = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React236.createElement("div", Object.assign({ className: css(multiple_file_upload_default.multipleFileUploadTitleIcon, className) }, props), children2);
};
MultipleFileUploadTitleIcon.displayName = "MultipleFileUploadTitleIcon";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadTitleText.js
var React237 = __toESM(require_react());
var MultipleFileUploadTitleText = (_a2) => {
  var { className, children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React237.createElement("div", Object.assign({ className: css(multiple_file_upload_default.multipleFileUploadTitleText, className) }, props), children2);
};
MultipleFileUploadTitleText.displayName = "MultipleFileUploadTitleText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadTitleTextSeparator.js
var React238 = __toESM(require_react());
var MultipleFileUploadTitleTextSeparator = (_a2) => {
  var { className, children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React238.createElement("div", Object.assign({ className: css(multiple_file_upload_default.multipleFileUploadTitleTextSeparator, className) }, props), children2);
};
MultipleFileUploadTitleTextSeparator.displayName = "MultipleFileUploadTitleTextSeparator";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadTitle.js
var MultipleFileUploadTitle = (_a2) => {
  var { className, icon, text = "", textSeparator = "" } = _a2, props = __rest(_a2, ["className", "icon", "text", "textSeparator"]);
  return React239.createElement(
    "div",
    Object.assign({ className: css(multiple_file_upload_default.multipleFileUploadTitle, className) }, props),
    icon && React239.createElement(MultipleFileUploadTitleIcon, null, icon),
    text && React239.createElement(
      MultipleFileUploadTitleText,
      null,
      `${text} `,
      textSeparator && React239.createElement(MultipleFileUploadTitleTextSeparator, null, textSeparator)
    )
  );
};
MultipleFileUploadTitle.displayName = "MultipleFileUploadTitle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadButton.js
var React240 = __toESM(require_react());
var MultipleFileUploadButton = (_a2) => {
  var { className, "aria-label": ariaLabel, browseButtonText = "Upload" } = _a2, props = __rest(_a2, ["className", "aria-label", "browseButtonText"]);
  if (!ariaLabel && !browseButtonText) {
    console.warn("For accessibility reasons an aria-label should be specified on MultipleFileUploadButton if a browseButtonText isn't");
  }
  const { open } = React240.useContext(MultipleFileUploadContext);
  return React240.createElement(
    "div",
    Object.assign({ className: css(multiple_file_upload_default.multipleFileUploadUpload, className) }, props),
    React240.createElement(Button, { variant: "secondary", "aria-label": ariaLabel, onClick: open }, browseButtonText)
  );
};
MultipleFileUploadButton.displayName = "MultipleFileUploadButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadInfo.js
var React241 = __toESM(require_react());
var MultipleFileUploadInfo = (_a2) => {
  var { className, children: children2 } = _a2, props = __rest(_a2, ["className", "children"]);
  return React241.createElement("div", Object.assign({ className: css(multiple_file_upload_default.multipleFileUploadInfo, className) }, props), children2);
};
MultipleFileUploadInfo.displayName = "MultipleFileUploadInfo";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadMain.js
var MultipleFileUploadMain = (_a2) => {
  var { className, titleIcon, titleText, titleTextSeparator, infoText, isUploadButtonHidden, browseButtonText = "Upload" } = _a2, props = __rest(_a2, ["className", "titleIcon", "titleText", "titleTextSeparator", "infoText", "isUploadButtonHidden", "browseButtonText"]);
  const showTitle = !!titleIcon || !!titleText || !!titleTextSeparator;
  return React242.createElement(
    "div",
    Object.assign({ className: css(multiple_file_upload_default.multipleFileUploadMain, className) }, props),
    showTitle && React242.createElement(MultipleFileUploadTitle, { icon: titleIcon, text: titleText, textSeparator: titleTextSeparator }),
    isUploadButtonHidden || React242.createElement(MultipleFileUploadButton, { browseButtonText }),
    !!infoText && React242.createElement(MultipleFileUploadInfo, null, infoText)
  );
};
MultipleFileUploadMain.displayName = "MultipleFileUploadMain";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadStatus.js
var React243 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/in-progress-icon.js
var InProgressIconConfig = {
  name: "InProgressIcon",
  height: 1024,
  width: 1024,
  svgPath: "M513.417211,16.013668 L513.417211,112.013668 C513.406007,120.539653 520.082422,127.576718 528.597211,128.013668 C732.697211,136.513668 896.147211,305.013668 896.147211,511.343668 C896.147211,723.013668 724.007211,895.163668 512.417211,895.163668 C437.186239,895.277345 363.602574,873.135095 300.927211,831.523668 C294.58293,827.2982 286.138663,828.135095 280.747211,833.523668 L211.807211,902.353668 C208.502935,905.676185 206.82123,910.280199 207.20607,914.950237 C207.590911,919.620275 210.00361,923.886884 213.807211,926.623668 C300.709573,989.398037 405.213535,1023.13146 512.417211,1023.01398 C794.537211,1023.01398 1023.91724,793.433668 1023.91724,511.413668 C1024.00721,235.103668 804.007211,9.22366802 529.897211,0.00645736761 C525.571205,-0.116171039 521.377128,1.51204372 518.271915,4.52681369 C515.166702,7.54158367 513.415263,11.6857144 513.417211,16.013668 M97.1272107,212.923668 C64.2190689,258.479443 39.0698895,309.162997 22.6972107,362.923668 C21.2705092,367.756559 22.2039184,372.979173 25.2163356,377.018685 C28.2287528,381.058197 32.9681443,383.442545 38.0072107,383.453683 L139.407211,383.453683 C145.970195,383.46249 151.873012,379.462528 154.297211,373.363668 C164.307669,347.593304 177.068112,322.977652 192.357211,299.943668 C196.579666,293.633658 195.741339,285.216847 190.357211,279.863668 L121.497211,211.013668 C118.186635,207.662531 113.567544,205.940538 108.871166,206.30669 C104.174788,206.672841 99.8783994,209.089927 97.1272107,212.913668 M112.907211,511.433663 L17.0072107,511.433663 C12.679257,511.433663 8.5351263,513.183159 5.52035633,516.288373 C2.50558635,519.393586 0.877371594,523.587662 1.00721065,527.913668 C4.13104542,629.408217 37.6085847,727.635936 97.1172107,809.913668 C99.8539943,813.717268 104.120603,816.129968 108.790642,816.514809 C113.46068,816.899649 118.064693,815.217944 121.387211,811.913668 L190.217211,743.073668 C195.605784,737.682216 196.442679,729.237949 192.217211,722.893668 C153.520825,664.580171 131.611534,596.745437 128.887211,526.813668 C128.553964,518.220138 121.487197,511.427209 112.887211,511.433663",
  yOffset: 0,
  xOffset: 0
};
var InProgressIcon = createIcon(InProgressIconConfig);
var in_progress_icon_default = InProgressIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadStatus.js
var MultipleFileUploadStatus = (_a2) => {
  var { children: children2, className, statusToggleText, statusToggleIcon, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["children", "className", "statusToggleText", "statusToggleIcon", "aria-label"]);
  const [icon, setIcon] = React243.useState();
  const [isOpen, setIsOpen] = React243.useState(true);
  React243.useEffect(() => {
    switch (statusToggleIcon) {
      case "danger":
        setIcon(React243.createElement(times_circle_icon_default, null));
        break;
      case "success":
        setIcon(React243.createElement(check_circle_icon_default, null));
        break;
      case "inProgress":
        setIcon(React243.createElement(in_progress_icon_default, null));
        break;
      default:
        setIcon(statusToggleIcon);
    }
  }, [statusToggleIcon]);
  const toggle = React243.createElement(
    "div",
    { className: multiple_file_upload_default.multipleFileUploadStatusProgress },
    React243.createElement("div", { className: `${multiple_file_upload_default.multipleFileUploadStatusProgress}-icon` }, icon),
    React243.createElement("div", { className: `${multiple_file_upload_default.multipleFileUploadStatusProgress}-text` }, statusToggleText)
  );
  const toggleExpandableSection = () => {
    setIsOpen(!isOpen);
  };
  return React243.createElement(
    "div",
    Object.assign({ className: css(multiple_file_upload_default.multipleFileUploadStatus, className) }, props),
    React243.createElement(GenerateId, { prefix: "pf-expandable-section-" }, (expandableSectionId) => React243.createElement(
      ExpandableSection,
      { contentId: `${expandableSectionId}-content`, toggleId: `${expandableSectionId}-toggle`, toggleContent: toggle, isExpanded: isOpen, onToggle: toggleExpandableSection },
      React243.createElement("ul", { className: `${multiple_file_upload_default.multipleFileUploadStatus}-list`, role: "list", "aria-label": ariaLabel }, children2)
    ))
  );
};
MultipleFileUploadStatus.displayName = "MultipleFileUploadStatus";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadStatusItem.js
var React248 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Progress/Progress.js
var React247 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Progress/progress.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Progress/progress.css";
var progress_default = {
  "modifiers": {
    "sm": "pf-m-sm",
    "lg": "pf-m-lg",
    "inside": "pf-m-inside",
    "outside": "pf-m-outside",
    "staticWidth": "pf-m-static-width",
    "singleline": "pf-m-singleline",
    "success": "pf-m-success",
    "warning": "pf-m-warning",
    "danger": "pf-m-danger",
    "truncate": "pf-m-truncate"
  },
  "progress": "pf-v6-c-progress",
  "progressBar": "pf-v6-c-progress__bar",
  "progressDescription": "pf-v6-c-progress__description",
  "progressHelperText": "pf-v6-c-progress__helper-text",
  "progressIndicator": "pf-v6-c-progress__indicator",
  "progressMeasure": "pf-v6-c-progress__measure",
  "progressStatus": "pf-v6-c-progress__status",
  "progressStatusIcon": "pf-v6-c-progress__status-icon"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Progress/ProgressContainer.js
var React246 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Progress/ProgressBar.js
var React244 = __toESM(require_react());
var ProgressBar = (_a2) => {
  var { progressBarAriaProps, className = "", children: children2 = null, value } = _a2, props = __rest(_a2, ["progressBarAriaProps", "className", "children", "value"]);
  return React244.createElement(
    "div",
    Object.assign({}, props, { className: css(progress_default.progressBar, className) }, progressBarAriaProps),
    React244.createElement(
      "div",
      { className: css(progress_default.progressIndicator), style: { width: `${value}%` } },
      React244.createElement("span", { className: css(progress_default.progressMeasure) }, children2)
    )
  );
};
ProgressBar.displayName = "ProgressBar";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Progress/ProgressHelperText.js
var React245 = __toESM(require_react());
var ProgressHelperText = (_a2) => {
  var { children: children2 } = _a2, props = __rest(_a2, ["children"]);
  return React245.createElement("div", Object.assign({ className: progress_default.progressHelperText }, props), children2);
};
ProgressHelperText.displayName = "ProgressHelperText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Progress/ProgressContainer.js
var ProgressMeasureLocation;
(function(ProgressMeasureLocation2) {
  ProgressMeasureLocation2["outside"] = "outside";
  ProgressMeasureLocation2["inside"] = "inside";
  ProgressMeasureLocation2["top"] = "top";
  ProgressMeasureLocation2["none"] = "none";
})(ProgressMeasureLocation || (ProgressMeasureLocation = {}));
var ProgressVariant;
(function(ProgressVariant2) {
  ProgressVariant2["danger"] = "danger";
  ProgressVariant2["success"] = "success";
  ProgressVariant2["warning"] = "warning";
})(ProgressVariant || (ProgressVariant = {}));
var variantToIcon = {
  danger: times_circle_icon_default,
  success: check_circle_icon_default,
  warning: exclamation_triangle_icon_default
};
var ProgressContainer = ({ progressBarAriaProps, value, title = "", parentId, label = null, variant = null, measureLocation = ProgressMeasureLocation.top, isTitleTruncated = false, tooltipPosition, helperText }) => {
  const StatusIcon2 = variantToIcon.hasOwnProperty(variant) && variantToIcon[variant];
  const [tooltip, setTooltip] = React246.useState("");
  const onMouseEnter = (event) => {
    if (event.target.offsetWidth < event.target.scrollWidth) {
      setTooltip(title || event.target.innerHTML);
    } else {
      setTooltip("");
    }
  };
  const Title2 = React246.createElement("div", { className: css(progress_default.progressDescription, isTitleTruncated && typeof title === "string" && progress_default.modifiers.truncate), id: `${parentId}-description`, "aria-hidden": "true", onMouseEnter: isTitleTruncated && typeof title === "string" ? onMouseEnter : null }, title);
  return React246.createElement(
    React246.Fragment,
    null,
    title && (tooltip ? React246.createElement(Tooltip, { position: tooltipPosition, content: tooltip, isVisible: true }, Title2) : Title2),
    (measureLocation !== ProgressMeasureLocation.none || StatusIcon2) && React246.createElement(
      "div",
      { className: css(progress_default.progressStatus), "aria-hidden": "true" },
      (measureLocation === ProgressMeasureLocation.top || measureLocation === ProgressMeasureLocation.outside) && React246.createElement("span", { className: css(progress_default.progressMeasure) }, label || `${value}%`),
      StatusIcon2 && React246.createElement(
        "span",
        { className: css(progress_default.progressStatusIcon) },
        React246.createElement(StatusIcon2, null)
      )
    ),
    React246.createElement(ProgressBar, { role: "progressbar", progressBarAriaProps, value }, measureLocation === ProgressMeasureLocation.inside && `${value}%`),
    helperText && React246.createElement(ProgressHelperText, null, helperText)
  );
};
ProgressContainer.displayName = "ProgressContainer";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Progress/Progress.js
var ProgressSize;
(function(ProgressSize2) {
  ProgressSize2["sm"] = "sm";
  ProgressSize2["md"] = "md";
  ProgressSize2["lg"] = "lg";
})(ProgressSize || (ProgressSize = {}));
var Progress = class extends React247.Component {
  constructor() {
    super(...arguments);
    this.id = this.props.id || getUniqueId();
  }
  render() {
    const _a2 = this.props, {
      /* eslint-disable @typescript-eslint/no-unused-vars */
      id: id2,
      size,
      /* eslint-enable @typescript-eslint/no-unused-vars */
      className,
      value,
      title,
      label,
      variant,
      measureLocation,
      min: min4,
      max: max5,
      valueText,
      isTitleTruncated,
      tooltipPosition,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      helperText
    } = _a2, props = __rest(_a2, ["id", "size", "className", "value", "title", "label", "variant", "measureLocation", "min", "max", "valueText", "isTitleTruncated", "tooltipPosition", "aria-label", "aria-labelledby", "helperText"]);
    const progressBarAriaProps = {
      "aria-valuemin": min4,
      "aria-valuenow": value,
      "aria-valuemax": max5
    };
    if (title || ariaLabelledBy) {
      progressBarAriaProps["aria-labelledby"] = title ? `${this.id}-description` : ariaLabelledBy;
    }
    if (ariaLabel) {
      progressBarAriaProps["aria-label"] = ariaLabel;
    }
    if (valueText) {
      progressBarAriaProps["aria-valuetext"] = valueText;
    }
    if (!title && !ariaLabelledBy && !ariaLabel) {
      console.warn("One of aria-label or aria-labelledby properties should be passed when using the progress component without a title.");
    }
    const scaledValue = Math.min(100, Math.max(0, Math.floor((value - min4) / (max5 - min4) * 100))) || 0;
    return React247.createElement(
      "div",
      Object.assign({}, props, { className: css(progress_default.progress, progress_default.modifiers[variant], ["inside", "outside"].includes(measureLocation) && progress_default.modifiers[measureLocation], measureLocation === "inside" ? progress_default.modifiers[ProgressSize.lg] : progress_default.modifiers[size], !title && progress_default.modifiers.singleline, className), id: this.id }),
      React247.createElement(ProgressContainer, { parentId: this.id, value: scaledValue, title, label, variant, measureLocation, progressBarAriaProps, isTitleTruncated, tooltipPosition, helperText })
    );
  }
};
Progress.displayName = "Progress";
Progress.defaultProps = {
  className: "",
  measureLocation: ProgressMeasureLocation.top,
  variant: null,
  id: "",
  title: "",
  min: 0,
  max: 100,
  size: null,
  label: null,
  value: 0,
  valueText: null,
  isTitleTruncated: false,
  tooltipPosition: "top",
  "aria-label": null,
  "aria-labelledby": null
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/file-icon.js
var FileIconConfig = {
  name: "FileIcon",
  height: 512,
  width: 384,
  svgPath: "M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm160-14.1v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z",
  yOffset: 0,
  xOffset: 0
};
var FileIcon = createIcon(FileIconConfig);
var file_icon_default = FileIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/MultipleFileUpload/MultipleFileUploadStatusItem.js
var MultipleFileUploadStatusItem = (_a2) => {
  var { className, file, fileIcon, onReadStarted = () => {
  }, onReadFinished = () => {
  }, onReadSuccess = () => {
  }, onReadFail = () => {
  }, onClearClick = () => {
  }, customFileHandler, fileName, fileSize, progressValue, progressVariant, progressAriaLabel, progressAriaLabelledBy, progressId, progressAriaLiveMessage, buttonAriaLabel = "Remove from list", progressHelperText } = _a2, props = __rest(_a2, ["className", "file", "fileIcon", "onReadStarted", "onReadFinished", "onReadSuccess", "onReadFail", "onClearClick", "customFileHandler", "fileName", "fileSize", "progressValue", "progressVariant", "progressAriaLabel", "progressAriaLabelledBy", "progressId", "progressAriaLiveMessage", "buttonAriaLabel", "progressHelperText"]);
  const [loadPercentage, setLoadPercentage] = React248.useState(0);
  const [loadResult, setLoadResult] = React248.useState();
  function readFile2(file2) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(reader.error);
      reader.onprogress = (data) => {
        if (data.lengthComputable) {
          setLoadPercentage(data.loaded / data.total * 100);
        }
      };
      reader.readAsDataURL(file2);
    });
  }
  React248.useEffect(() => {
    if (customFileHandler) {
      customFileHandler(file);
    } else {
      onReadStarted(file);
      readFile2(file).then((data) => {
        setLoadResult("success");
        setLoadPercentage(100);
        onReadFinished(file);
        onReadSuccess(data, file);
      }).catch((error) => {
        onReadFinished(file);
        onReadFail(error, file);
        setLoadResult("danger");
      });
    }
  }, []);
  const getHumanReadableFileSize = (size) => {
    const prefixes2 = ["", "K", "M", "G", "T"];
    let prefixUnit = 0;
    while (size >= 1e3) {
      prefixUnit += 1;
      size = size / 1e3;
    }
    if (prefixUnit >= prefixes2.length) {
      return "File size too large";
    }
    return `${Math.round(size)}${prefixes2[prefixUnit]}B`;
  };
  const value = progressValue || loadPercentage;
  const variant = progressVariant || loadResult;
  const title = React248.createElement(
    "span",
    { className: multiple_file_upload_default.multipleFileUploadStatusItemProgress },
    React248.createElement("span", { className: multiple_file_upload_default.multipleFileUploadStatusItemProgressText }, fileName || (file === null || file === void 0 ? void 0 : file.name) || ""),
    React248.createElement("span", { className: multiple_file_upload_default.multipleFileUploadStatusItemProgressSize }, fileSize || getHumanReadableFileSize((file === null || file === void 0 ? void 0 : file.size) || 0))
  );
  return React248.createElement(
    "li",
    Object.assign({ className: css(multiple_file_upload_default.multipleFileUploadStatusItem, className) }, props),
    React248.createElement("div", { className: multiple_file_upload_default.multipleFileUploadStatusItemIcon }, fileIcon || React248.createElement(file_icon_default, null)),
    React248.createElement(
      "div",
      { className: multiple_file_upload_default.multipleFileUploadStatusItemMain },
      React248.createElement(
        "div",
        { className: "pf-v6-screen-reader", "aria-live": "polite" },
        progressAriaLiveMessage && typeof progressAriaLiveMessage === "function" && progressAriaLiveMessage(+loadPercentage.toFixed(2)),
        progressAriaLiveMessage && typeof progressAriaLiveMessage === "string" && progressAriaLiveMessage,
        !progressAriaLiveMessage && `Progress value is ${progressValue || Math.floor(loadPercentage)}%.`
      ),
      React248.createElement(Progress, { title, value, variant, "aria-label": progressAriaLabel, "aria-labelledby": progressAriaLabelledBy, id: progressId, helperText: progressHelperText })
    ),
    React248.createElement(
      "div",
      { className: `${multiple_file_upload_default.multipleFileUploadStatusItem}-close` },
      React248.createElement(
        Button,
        { variant: "plain", "aria-label": buttonAriaLabel, onClick: onClearClick },
        React248.createElement(times_icon_default, null)
      )
    )
  );
};
MultipleFileUploadStatusItem.displayName = "MultipleFileUploadStatusItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Nav/Nav.js
var React249 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Nav/nav.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Nav/nav.css";
var nav_default = {
  "button": "pf-v6-c-button",
  "dirRtl": "pf-v6-m-dir-rtl",
  "menu": "pf-v6-c-menu",
  "modifiers": {
    "overflowHidden": "pf-m-overflow-hidden",
    "fullWidth": "pf-m-full-width",
    "fill": "pf-m-fill",
    "expanded": "pf-m-expanded",
    "hover": "pf-m-hover",
    "current": "pf-m-current",
    "flyout": "pf-m-flyout",
    "horizontal": "pf-m-horizontal",
    "subnav": "pf-m-subnav",
    "scrollable": "pf-m-scrollable"
  },
  "nav": "pf-v6-c-nav",
  "navItem": "pf-v6-c-nav__item",
  "navLink": "pf-v6-c-nav__link",
  "navLinkIcon": "pf-v6-c-nav__link-icon",
  "navList": "pf-v6-c-nav__list",
  "navNav": "pf-v6-c-nav__nav",
  "navScrollButton": "pf-v6-c-nav__scroll-button",
  "navSection": "pf-v6-c-nav__section",
  "navSectionTitle": "pf-v6-c-nav__section-title",
  "navSubnav": "pf-v6-c-nav__subnav",
  "navToggle": "pf-v6-c-nav__toggle",
  "navToggleIcon": "pf-v6-c-nav__toggle-icon"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Nav/Nav.js
var navContextDefaults = {};
var NavContext = React249.createContext(navContextDefaults);
var Nav = class _Nav extends React249.Component {
  constructor() {
    super(...arguments);
    this.state = {
      isScrollable: false,
      ouiaStateId: getDefaultOUIAId(_Nav.displayName, this.props.variant),
      flyoutRef: null
    };
    this.navRef = React249.createRef();
  }
  // Callback from NavItem
  onSelect(event, groupId, itemId, to, preventDefault, onClick) {
    if (preventDefault) {
      event.preventDefault();
    }
    this.props.onSelect(event, { groupId, itemId, to });
    if (onClick) {
      onClick(event, itemId, groupId, to);
    }
  }
  // Callback from NavExpandable
  onToggle(event, groupId, toggleValue) {
    this.props.onToggle(event, {
      groupId,
      isExpanded: toggleValue
    });
  }
  render() {
    const _a2 = this.props, {
      "aria-label": ariaLabel,
      children: children2,
      className,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onSelect,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onToggle,
      ouiaId,
      ouiaSafe,
      variant
    } = _a2, props = __rest(_a2, ["aria-label", "children", "className", "onSelect", "onToggle", "ouiaId", "ouiaSafe", "variant"]);
    const isHorizontal = ["horizontal", "horizontal-subnav"].includes(variant);
    return React249.createElement(
      NavContext.Provider,
      { value: {
        onSelect: (event, groupId, itemId, to, preventDefault, onClick) => this.onSelect(event, groupId, itemId, to, preventDefault, onClick),
        onToggle: (event, groupId, expanded) => this.onToggle(event, groupId, expanded),
        updateIsScrollable: (isScrollable) => this.setState({ isScrollable }),
        isHorizontal: ["horizontal", "horizontal-subnav"].includes(variant),
        flyoutRef: this.state.flyoutRef,
        setFlyoutRef: (flyoutRef) => this.setState({ flyoutRef }),
        navRef: this.navRef
      } },
      React249.createElement("nav", Object.assign({ className: css(nav_default.nav, isHorizontal && nav_default.modifiers.horizontal, variant === "horizontal-subnav" && nav_default.modifiers.subnav, this.state.isScrollable && nav_default.modifiers.scrollable, className), "aria-label": ariaLabel || (variant === "horizontal-subnav" ? "Local" : "Global"), ref: this.navRef }, getOUIAProps(_Nav.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), props), children2)
    );
  }
};
Nav.displayName = "Nav";
Nav.defaultProps = {
  onSelect: () => void 0,
  onToggle: () => void 0,
  ouiaSafe: true
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Nav/NavList.js
var React251 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/PageSidebar.js
var React250 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Page/page.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Page/page.css";
var page_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "drawer": "pf-v6-c-drawer",
  "masthead": "pf-v6-c-masthead",
  "modifiers": {
    "expanded": "pf-m-expanded",
    "collapsed": "pf-m-collapsed",
    "pageInsets": "pf-m-page-insets",
    "contextSelector": "pf-m-context-selector",
    "insetNone": "pf-m-inset-none",
    "fill": "pf-m-fill",
    "noFill": "pf-m-no-fill",
    "limitWidth": "pf-m-limit-width",
    "alignCenter": "pf-m-align-center",
    "overflowScroll": "pf-m-overflow-scroll",
    "shadowBottom": "pf-m-shadow-bottom",
    "shadowTop": "pf-m-shadow-top",
    "stickyTop": "pf-m-sticky-top",
    "stickyBottom": "pf-m-sticky-bottom",
    "stickyTopOnSmHeight": "pf-m-sticky-top-on-sm-height",
    "stickyBottomOnSmHeight": "pf-m-sticky-bottom-on-sm-height",
    "stickyTopOnMdHeight": "pf-m-sticky-top-on-md-height",
    "stickyBottomOnMdHeight": "pf-m-sticky-bottom-on-md-height",
    "stickyTopOnLgHeight": "pf-m-sticky-top-on-lg-height",
    "stickyBottomOnLgHeight": "pf-m-sticky-bottom-on-lg-height",
    "stickyTopOnXlHeight": "pf-m-sticky-top-on-xl-height",
    "stickyBottomOnXlHeight": "pf-m-sticky-bottom-on-xl-height",
    "stickyTopOn_2xlHeight": "pf-m-sticky-top-on-2xl-height",
    "stickyBottomOn_2xlHeight": "pf-m-sticky-bottom-on-2xl-height",
    "secondary": "pf-m-secondary",
    "padding": "pf-m-padding",
    "noPadding": "pf-m-no-padding",
    "paddingOnSm": "pf-m-padding-on-sm",
    "noPaddingOnSm": "pf-m-no-padding-on-sm",
    "paddingOnMd": "pf-m-padding-on-md",
    "noPaddingOnMd": "pf-m-no-padding-on-md",
    "paddingOnLg": "pf-m-padding-on-lg",
    "noPaddingOnLg": "pf-m-no-padding-on-lg",
    "paddingOnXl": "pf-m-padding-on-xl",
    "noPaddingOnXl": "pf-m-no-padding-on-xl",
    "paddingOn_2xl": "pf-m-padding-on-2xl",
    "noPaddingOn_2xl": "pf-m-no-padding-on-2xl"
  },
  "page": "pf-v6-c-page",
  "pageDrawer": "pf-v6-c-page__drawer",
  "pageMain": "pf-v6-c-page__main",
  "pageMainBody": "pf-v6-c-page__main-body",
  "pageMainBreadcrumb": "pf-v6-c-page__main-breadcrumb",
  "pageMainContainer": "pf-v6-c-page__main-container",
  "pageMainDrawer": "pf-v6-c-page__main-drawer",
  "pageMainGroup": "pf-v6-c-page__main-group",
  "pageMainList": "pf-v6-c-page__main-list",
  "pageMainNav": "pf-v6-c-page__main-nav",
  "pageMainSection": "pf-v6-c-page__main-section",
  "pageMainSubnav": "pf-v6-c-page__main-subnav",
  "pageMainTabs": "pf-v6-c-page__main-tabs",
  "pageMainWizard": "pf-v6-c-page__main-wizard",
  "pageSidebar": "pf-v6-c-page__sidebar",
  "pageSidebarBody": "pf-v6-c-page__sidebar-body",
  "pageSidebarHeader": "pf-v6-c-page__sidebar-header",
  "pageSidebarTitle": "pf-v6-c-page__sidebar-title"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/PageSidebar.js
var pageSidebarContextDefaults = {
  isSidebarOpen: true
};
var PageSidebarContext = React250.createContext(pageSidebarContextDefaults);
var PageSidebar = (_a2) => {
  var { className = "", children: children2, isSidebarOpen = true, id: id2 = "page-sidebar" } = _a2, props = __rest(_a2, ["className", "children", "isSidebarOpen", "id"]);
  return React250.createElement(PageContextConsumer, null, ({ isManagedSidebar, isSidebarOpen: managedIsNavOpen }) => {
    const sidebarOpen = isManagedSidebar ? managedIsNavOpen : isSidebarOpen;
    return React250.createElement(
      "div",
      Object.assign({ id: id2, className: css(page_default.pageSidebar, sidebarOpen && page_default.modifiers.expanded, !sidebarOpen && page_default.modifiers.collapsed, className), "aria-hidden": !sidebarOpen }, props),
      React250.createElement(PageSidebarContext.Provider, { value: { isSidebarOpen: sidebarOpen } }, children2)
    );
  });
};
PageSidebar.displayName = "PageSidebar";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Nav/NavList.js
var NavList = class extends React251.Component {
  constructor() {
    super(...arguments);
    this.direction = "ltr";
    this.state = {
      scrollViewAtStart: false,
      scrollViewAtEnd: false
    };
    this.navList = React251.createRef();
    this.observer = () => {
    };
    this.handleScrollButtons = () => {
      const container = this.navList.current;
      if (container) {
        const scrollViewAtStart = isElementInView(container, container.firstChild, false);
        const scrollViewAtEnd = isElementInView(container, container.lastChild, false);
        this.setState({
          scrollViewAtStart,
          scrollViewAtEnd
        });
        this.context.updateIsScrollable(!scrollViewAtStart || !scrollViewAtEnd);
      }
    };
    this.scrollBack = () => {
      const container = this.navList.current;
      if (container) {
        const childrenArr = Array.from(container.children);
        let firstElementInView;
        let lastElementOutOfView;
        for (let i = 0; i < childrenArr.length && !firstElementInView; i++) {
          if (isElementInView(container, childrenArr[i], false)) {
            firstElementInView = childrenArr[i];
            lastElementOutOfView = childrenArr[i - 1];
          }
        }
        if (lastElementOutOfView) {
          if (this.direction === "ltr") {
            container.scrollLeft -= lastElementOutOfView.scrollWidth;
          } else {
            container.scrollLeft += lastElementOutOfView.scrollWidth;
          }
        }
        this.handleScrollButtons();
      }
    };
    this.scrollForward = () => {
      const container = this.navList.current;
      if (container) {
        const childrenArr = Array.from(container.children);
        let lastElementInView;
        let firstElementOutOfView;
        for (let i = childrenArr.length - 1; i >= 0 && !lastElementInView; i--) {
          if (isElementInView(container, childrenArr[i], false)) {
            lastElementInView = childrenArr[i];
            firstElementOutOfView = childrenArr[i + 1];
          }
        }
        if (firstElementOutOfView) {
          if (this.direction === "ltr") {
            container.scrollLeft += firstElementOutOfView.scrollWidth;
          } else {
            container.scrollLeft -= firstElementOutOfView.scrollWidth;
          }
        }
        this.handleScrollButtons();
      }
    };
  }
  componentDidMount() {
    this.observer = getResizeObserver(this.navList.current, this.handleScrollButtons, true);
    this.direction = getLanguageDirection(this.navList.current);
    this.handleScrollButtons();
  }
  componentWillUnmount() {
    this.observer();
  }
  componentDidUpdate() {
    this.direction = getLanguageDirection(this.navList.current);
  }
  render() {
    const _a2 = this.props, { children: children2, className, backScrollAriaLabel, forwardScrollAriaLabel } = _a2, props = __rest(_a2, ["children", "className", "backScrollAriaLabel", "forwardScrollAriaLabel"]);
    const { scrollViewAtStart, scrollViewAtEnd } = this.state;
    return React251.createElement(NavContext.Consumer, null, ({ isHorizontal }) => React251.createElement(PageSidebarContext.Consumer, null, ({ isSidebarOpen }) => React251.createElement(
      React251.Fragment,
      null,
      isHorizontal && (!scrollViewAtStart || !scrollViewAtEnd) && React251.createElement(
        "div",
        { className: css(nav_default.navScrollButton) },
        React251.createElement(
          Button,
          { variant: "plain", "aria-label": backScrollAriaLabel, onClick: this.scrollBack, isDisabled: scrollViewAtStart, tabIndex: isSidebarOpen ? null : -1 },
          React251.createElement(angle_left_icon_default, null)
        )
      ),
      React251.createElement("ul", Object.assign({ ref: this.navList, className: css(nav_default.navList, className), onScroll: this.handleScrollButtons, role: "list" }, props), children2),
      isHorizontal && (!scrollViewAtStart || !scrollViewAtEnd) && React251.createElement(
        "div",
        { className: css(nav_default.navScrollButton) },
        React251.createElement(
          Button,
          { variant: "plain", "aria-label": forwardScrollAriaLabel, onClick: this.scrollForward, isDisabled: scrollViewAtEnd, tabIndex: isSidebarOpen ? null : -1 },
          React251.createElement(angle_right_icon_default, null)
        )
      )
    )));
  }
};
NavList.displayName = "NavList";
NavList.contextType = NavContext;
NavList.defaultProps = {
  backScrollAriaLabel: "Scroll back",
  forwardScrollAriaLabel: "Scroll foward"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Nav/NavGroup.js
var React252 = __toESM(require_react());
var NavGroup = (_a2) => {
  var { title, children: children2 = null, className = "", id: id2 = getUniqueId() } = _a2, props = __rest(_a2, ["title", "children", "className", "id"]);
  if (!title && !props["aria-label"]) {
    console.warn("For accessibility reasons an aria-label should be specified on nav groups if a title isn't");
  }
  const labelledBy = title ? id2 : void 0;
  return React252.createElement(
    "section",
    Object.assign({ className: css(nav_default.navSection, className), "aria-labelledby": labelledBy }, props),
    title && React252.createElement("h2", { className: css(nav_default.navSectionTitle), id: id2 }, title),
    React252.createElement("ul", { className: css(nav_default.navList, className), role: "list" }, children2)
  );
};
NavGroup.displayName = "NavGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Nav/NavItem.js
var React253 = __toESM(require_react());
var NavItem = (_a2) => {
  var { children: children2, styleChildren = true, className, to, isActive = false, groupId = null, itemId = null, preventDefault = false, onClick, component = "a", flyout, onShowFlyout, ouiaId, ouiaSafe, zIndex = 9999, hasNavLinkWrapper } = _a2, props = __rest(_a2, ["children", "styleChildren", "className", "to", "isActive", "groupId", "itemId", "preventDefault", "onClick", "component", "flyout", "onShowFlyout", "ouiaId", "ouiaSafe", "zIndex", "hasNavLinkWrapper"]);
  const { flyoutRef, setFlyoutRef, navRef } = React253.useContext(NavContext);
  const { isSidebarOpen } = React253.useContext(PageSidebarContext);
  const [flyoutTarget, setFlyoutTarget] = React253.useState(null);
  const [isHovered, setIsHovered] = React253.useState(false);
  const ref = React253.useRef();
  const flyoutVisible = ref === flyoutRef;
  const popperRef = React253.useRef();
  const hasFlyout = flyout !== void 0;
  const Component50 = hasFlyout ? "button" : component;
  if (to && hasFlyout) {
    console.error('NavItem cannot have both "to" and "flyout" props.');
  }
  const showFlyout = (show, override2) => {
    if ((!flyoutVisible || override2) && show) {
      setFlyoutRef(ref);
    } else if ((flyoutVisible || override2) && !show) {
      setFlyoutRef(null);
    }
    onShowFlyout && show && onShowFlyout();
  };
  const onMouseOver = (event) => {
    const evtContainedInFlyout = event.target.closest(`.${nav_default.navItem}.pf-m-flyout`);
    if (hasFlyout && !flyoutVisible) {
      showFlyout(true);
    } else if (flyoutRef !== null && !evtContainedInFlyout) {
      setFlyoutRef(null);
    }
  };
  const onFlyoutClick = (event) => {
    const target = event.target;
    const closestItem = target.closest(".pf-m-flyout");
    if (!closestItem) {
      if (hasFlyout) {
        showFlyout(false, true);
      } else if (flyoutRef !== null) {
        setFlyoutRef(null);
      }
    }
  };
  const handleFlyout = (event) => {
    var _a3, _b;
    const key = event.key;
    const target = event.target;
    if ((key === " " || key === "Enter" || key === "ArrowRight") && hasFlyout && ((_a3 = ref === null || ref === void 0 ? void 0 : ref.current) === null || _a3 === void 0 ? void 0 : _a3.contains(target))) {
      event.stopPropagation();
      event.preventDefault();
      if (!flyoutVisible) {
        showFlyout(true);
        setFlyoutTarget(target);
      }
    }
    if ((key === "Escape" || key === "ArrowLeft") && ((_b = popperRef === null || popperRef === void 0 ? void 0 : popperRef.current) === null || _b === void 0 ? void 0 : _b.querySelectorAll(`.${menu_default.menu}`).length) === 1) {
      if (flyoutVisible) {
        event.stopPropagation();
        event.preventDefault();
        showFlyout(false);
      }
    }
  };
  React253.useEffect(() => {
    if (hasFlyout) {
      window.addEventListener("click", onFlyoutClick);
    }
    return () => {
      if (hasFlyout) {
        window.removeEventListener("click", onFlyoutClick);
      }
    };
  }, []);
  React253.useEffect(() => {
    if (flyoutTarget) {
      if (flyoutVisible) {
        const flyoutItems = Array.from(popperRef.current.getElementsByTagName("UL")[0].children).filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(divider_default.divider)));
        flyoutItems[0].firstChild.focus();
      } else {
        flyoutTarget.focus();
      }
    }
  }, [flyoutVisible, flyoutTarget]);
  const flyoutButton = React253.createElement(
    "span",
    { className: css(nav_default.navToggle) },
    React253.createElement(
      "span",
      { className: css(nav_default.navToggleIcon) },
      React253.createElement(angle_right_icon_default, { "aria-hidden": true })
    )
  );
  const ariaFlyoutProps = {
    "aria-haspopup": "menu",
    "aria-expanded": flyoutVisible
  };
  const tabIndex = isSidebarOpen ? null : -1;
  const renderDefaultLink = (context) => {
    const preventLinkDefault = preventDefault || !to;
    return React253.createElement(
      Component50,
      Object.assign({ href: to, onClick: (e) => context.onSelect(e, groupId, itemId, to, preventLinkDefault, onClick), className: css(nav_default.navLink, isActive && nav_default.modifiers.current, isHovered && nav_default.modifiers.hover, className), "aria-current": isActive ? "page" : null, tabIndex }, hasFlyout && Object.assign({}, ariaFlyoutProps), props),
      hasNavLinkWrapper ? React253.createElement("span", { className: css(`${nav_default.nav}__link-text`) }, children2) : children2,
      flyout && flyoutButton
    );
  };
  const renderClonedChild = (context, child) => React253.cloneElement(child, Object.assign(Object.assign({ onClick: (e) => context.onSelect(e, groupId, itemId, to, preventDefault, onClick), "aria-current": isActive ? "page" : null }, styleChildren && {
    className: css(nav_default.navLink, isActive && nav_default.modifiers.current, child.props && child.props.className)
  }), { tabIndex: child.props.tabIndex || tabIndex, children: hasFlyout ? React253.createElement(
    React253.Fragment,
    null,
    child.props.children,
    flyoutButton
  ) : child.props.children }));
  const ouiaProps = useOUIAProps(NavItem.displayName, ouiaId, ouiaSafe);
  const handleMouseEnter = () => {
    setIsHovered(true);
  };
  const handleMouseLeave = () => {
    setIsHovered(false);
  };
  const flyoutPopper = React253.createElement(Popper, { triggerRef: ref, popper: React253.createElement("div", { ref: popperRef, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave }, flyout), popperRef, placement: "right-start", isVisible: flyoutVisible, onDocumentKeyDown: handleFlyout, zIndex, appendTo: navRef === null || navRef === void 0 ? void 0 : navRef.current });
  const navItem = React253.createElement(
    React253.Fragment,
    null,
    React253.createElement(
      "li",
      Object.assign({ onMouseOver, className: css(nav_default.navItem, hasFlyout && nav_default.modifiers.flyout, className), ref }, ouiaProps),
      React253.createElement(NavContext.Consumer, null, (context) => React253.isValidElement(children2) ? renderClonedChild(context, children2) : renderDefaultLink(context))
    ),
    flyout && flyoutPopper
  );
  return navItem;
};
NavItem.displayName = "NavItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Nav/NavItemSeparator.js
var React254 = __toESM(require_react());
var NavItemSeparator = (_a2) => {
  var { component = "li" } = _a2, props = __rest(_a2, ["component"]);
  return React254.createElement(Divider, Object.assign({ component }, props));
};
NavItemSeparator.displayName = "NavItemSeparator";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Nav/NavExpandable.js
var React255 = __toESM(require_react());
var NavExpandable = class _NavExpandable extends React255.Component {
  constructor() {
    super(...arguments);
    this.id = this.props.id || getUniqueId();
    this.state = {
      expandedState: this.props.isExpanded,
      ouiaStateId: getDefaultOUIAId(_NavExpandable.displayName)
    };
    this.onExpand = (event, onToggle) => {
      const { expandedState } = this.state;
      if (this.props.onExpand) {
        this.props.onExpand(event, !expandedState);
      } else {
        this.setState((prevState) => ({ expandedState: !prevState.expandedState }));
        const { groupId } = this.props;
        onToggle(event, groupId, !expandedState);
      }
    };
  }
  componentDidMount() {
    this.setState({ expandedState: this.props.isExpanded });
  }
  componentDidUpdate(prevProps) {
    if (this.props.isExpanded !== prevProps.isExpanded) {
      this.setState({ expandedState: this.props.isExpanded });
    }
  }
  render() {
    const _a2 = this.props, {
      title,
      srText,
      children: children2,
      className,
      isActive,
      ouiaId,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      groupId,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      id: id2,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      isExpanded,
      buttonProps,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onExpand
    } = _a2, props = __rest(_a2, ["title", "srText", "children", "className", "isActive", "ouiaId", "groupId", "id", "isExpanded", "buttonProps", "onExpand"]);
    const { expandedState, ouiaStateId } = this.state;
    return React255.createElement(NavContext.Consumer, null, (context) => React255.createElement(
      "li",
      Object.assign({ className: css(nav_default.navItem, expandedState && nav_default.modifiers.expanded, isActive && nav_default.modifiers.current, className) }, getOUIAProps(_NavExpandable.displayName, ouiaId !== void 0 ? ouiaId : ouiaStateId), props),
      React255.createElement(PageSidebarContext.Consumer, null, ({ isSidebarOpen }) => React255.createElement(
        "button",
        Object.assign({ className: css(nav_default.navLink), id: srText ? null : this.id, onClick: (event) => this.onExpand(event, context.onToggle), "aria-expanded": expandedState, tabIndex: isSidebarOpen ? null : -1 }, buttonProps),
        typeof title !== "string" ? React255.createElement("span", { className: css(`${nav_default.nav}__link-text`) }, title) : title,
        React255.createElement(
          "span",
          { className: css(nav_default.navToggle) },
          React255.createElement(
            "span",
            { className: css(nav_default.navToggleIcon) },
            React255.createElement(angle_right_icon_default, { "aria-hidden": "true" })
          )
        )
      )),
      React255.createElement(
        "section",
        { className: css(nav_default.navSubnav), "aria-labelledby": this.id, hidden: expandedState ? null : true },
        srText && React255.createElement("h2", { className: "pf-v6-screen-reader", id: this.id }, srText),
        React255.createElement("ul", { className: css(nav_default.navList), role: "list" }, children2)
      )
    ));
  }
};
NavExpandable.displayName = "NavExpandable";
NavExpandable.defaultProps = {
  srText: "",
  isExpanded: false,
  children: "",
  className: "",
  groupId: null,
  isActive: false,
  id: ""
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationBadge/NotificationBadge.js
var React256 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/attention-bell-icon.js
var AttentionBellIconConfig = {
  name: "AttentionBellIcon",
  height: 1024,
  width: 896,
  svgPath: "M448,0 C465.333333,0 480.333333,6.33333333 493,19 C505.666667,31.6666667 512,46.6666667 512,64 L512,106 L514.23,106.45 C587.89,121.39 648.48,157.24 696,214 C744,271.333333 768,338.666667 768,416 C768,500 780,568.666667 804,622 C818.666667,652.666667 841.333333,684 872,716 C873.773676,718.829136 875.780658,721.505113 878,724 C890,737.333333 896,752.333333 896,769 C896,785.666667 890,800.333333 878,813 C866,825.666667 850.666667,832 832,832 L63.3,832 C44.9533333,831.84 29.8533333,825.506667 18,813 C6,800.333333 0,785.666667 0,769 C0,752.333333 6,737.333333 18,724 L24,716 L25.06,714.9 C55.1933333,683.28 77.5066667,652.313333 92,622 C116,568.666667 128,500 128,416 C128,338.666667 152,271.333333 200,214 C248,156.666667 309.333333,120.666667 384,106 L384,63.31 C384.166667,46.27 390.5,31.5 403,19 C415.666667,6.33333333 430.666667,0 448,0 Z M576,896 L576,897.08 C575.74,932.6 563.073333,962.573333 538,987 C512.666667,1011.66667 482.666667,1024 448,1024 C413.333333,1024 383.333333,1011.66667 358,987 C332.666667,962.333333 320,932 320,896 L576,896 Z M475,192 L421,192 C400.565464,192 384,208.565464 384,229 L384,539 C384,559.434536 400.565464,576 421,576 L475,576 C495.434536,576 512,559.434536 512,539 L512,229 C512,208.565464 495.434536,192 475,192 Z M448,640 C412.653776,640 384,668.653776 384,704 C384,739.346224 412.653776,768 448,768 C483.346224,768 512,739.346224 512,704 C512,668.653776 483.346224,640 448,640 Z",
  yOffset: 0,
  xOffset: 0
};
var AttentionBellIcon = createIcon(AttentionBellIconConfig);
var attention_bell_icon_default = AttentionBellIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationBadge/NotificationBadge.js
var NotificationBadgeVariant;
(function(NotificationBadgeVariant2) {
  NotificationBadgeVariant2["read"] = "read";
  NotificationBadgeVariant2["unread"] = "unread";
  NotificationBadgeVariant2["attention"] = "attention";
})(NotificationBadgeVariant || (NotificationBadgeVariant = {}));
var NotificationBadge = (_a2) => {
  var { children: children2, variant = NotificationBadgeVariant.read, count: count3 = 0, attentionIcon = React256.createElement(attention_bell_icon_default, null), icon = React256.createElement(bell_icon_default, null), className, isExpanded = false } = _a2, props = __rest(_a2, ["children", "variant", "count", "attentionIcon", "icon", "className", "isExpanded"]);
  const hasCount = count3 > 0;
  const hasChildren = children2 !== void 0;
  const isAttention = variant === NotificationBadgeVariant.attention;
  const notificationIcon = isAttention ? attentionIcon : icon;
  const notificationContent = hasChildren ? children2 : notificationIcon;
  const [iconProp, notificationChild] = hasCount ? [notificationContent, count3] : [void 0, notificationContent];
  return React256.createElement(Button, Object.assign({ variant: ButtonVariant.stateful, className, "aria-expanded": isExpanded, state: variant, isClicked: isExpanded, icon: iconProp }, props), notificationChild);
};
NotificationBadge.displayName = "NotificationBadge";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawer.js
var React257 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/NotificationDrawer/notification-drawer.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/NotificationDrawer/notification-drawer.css";
var notification_drawer_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "info": "pf-m-info",
    "warning": "pf-m-warning",
    "danger": "pf-m-danger",
    "success": "pf-m-success",
    "custom": "pf-m-custom",
    "read": "pf-m-read",
    "hoverable": "pf-m-hoverable",
    "truncate": "pf-m-truncate",
    "expanded": "pf-m-expanded"
  },
  "notificationDrawer": "pf-v6-c-notification-drawer",
  "notificationDrawerBody": "pf-v6-c-notification-drawer__body",
  "notificationDrawerGroup": "pf-v6-c-notification-drawer__group",
  "notificationDrawerGroupList": "pf-v6-c-notification-drawer__group-list",
  "notificationDrawerGroupToggle": "pf-v6-c-notification-drawer__group-toggle",
  "notificationDrawerGroupToggleCount": "pf-v6-c-notification-drawer__group-toggle-count",
  "notificationDrawerGroupToggleIcon": "pf-v6-c-notification-drawer__group-toggle-icon",
  "notificationDrawerGroupToggleTitle": "pf-v6-c-notification-drawer__group-toggle-title",
  "notificationDrawerHeader": "pf-v6-c-notification-drawer__header",
  "notificationDrawerHeaderAction": "pf-v6-c-notification-drawer__header-action",
  "notificationDrawerHeaderStatus": "pf-v6-c-notification-drawer__header-status",
  "notificationDrawerHeaderTitle": "pf-v6-c-notification-drawer__header-title",
  "notificationDrawerList": "pf-v6-c-notification-drawer__list",
  "notificationDrawerListItem": "pf-v6-c-notification-drawer__list-item",
  "notificationDrawerListItemAction": "pf-v6-c-notification-drawer__list-item-action",
  "notificationDrawerListItemDescription": "pf-v6-c-notification-drawer__list-item-description",
  "notificationDrawerListItemHeader": "pf-v6-c-notification-drawer__list-item-header",
  "notificationDrawerListItemHeaderIcon": "pf-v6-c-notification-drawer__list-item-header-icon",
  "notificationDrawerListItemHeaderTitle": "pf-v6-c-notification-drawer__list-item-header-title",
  "notificationDrawerListItemTimestamp": "pf-v6-c-notification-drawer__list-item-timestamp"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawer.js
var NotificationDrawerBase = (_a2) => {
  var { children: children2, className = "", innerRef } = _a2, props = __rest(_a2, ["children", "className", "innerRef"]);
  return React257.createElement("div", Object.assign({ ref: innerRef }, props, { className: css(notification_drawer_default.notificationDrawer, className) }), children2);
};
var NotificationDrawer = React257.forwardRef((props, ref) => React257.createElement(NotificationDrawerBase, Object.assign({ innerRef: ref }, props)));
NotificationDrawer.displayName = "NotificationDrawer";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawerBody.js
var React258 = __toESM(require_react());
var NotificationDrawerBody = (_a2) => {
  var { children: children2, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React258.createElement("div", Object.assign({}, props, { className: css(notification_drawer_default.notificationDrawerBody, className) }), children2);
};
NotificationDrawerBody.displayName = "NotificationDrawerBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawerGroup.js
var React259 = __toESM(require_react());
var NotificationDrawerGroup = (_a2) => {
  var {
    children: children2,
    className = "",
    count: count3,
    isExpanded,
    isRead = false,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onExpand = (event, expanded) => void 0,
    title,
    truncateTitle = 0,
    tooltipPosition,
    headingLevel: HeadingLevel = "h1"
  } = _a2, props = __rest(_a2, ["children", "className", "count", "isExpanded", "isRead", "onExpand", "title", "truncateTitle", "tooltipPosition", "headingLevel"]);
  const titleRef = React259.useRef(null);
  const [isTooltipVisible, setIsTooltipVisible] = React259.useState(false);
  React259.useEffect(() => {
    const showTooltip = titleRef.current && titleRef.current.offsetHeight < titleRef.current.scrollHeight;
    if (isTooltipVisible !== showTooltip) {
      setIsTooltipVisible(showTooltip);
    }
    if (!titleRef.current || !truncateTitle) {
      return;
    }
    titleRef.current.style.setProperty(c_notification_drawer_group_toggle_title_max_lines_default.name, truncateTitle.toString());
  }, [titleRef, truncateTitle, isTooltipVisible]);
  const Title2 = React259.createElement("div", Object.assign({}, isTooltipVisible && { tabIndex: 0 }, { ref: titleRef, className: css(notification_drawer_default.notificationDrawerGroupToggleTitle) }), title);
  return React259.createElement(
    "section",
    Object.assign({}, props, { className: css(notification_drawer_default.notificationDrawerGroup, isExpanded && notification_drawer_default.modifiers.expanded, className) }),
    React259.createElement(
      HeadingLevel,
      null,
      React259.createElement(
        "button",
        { className: css(notification_drawer_default.notificationDrawerGroupToggle), "aria-expanded": isExpanded, onClick: (e) => onExpand(e, !isExpanded), onKeyDown: (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            onExpand(e, !isExpanded);
          }
        } },
        isTooltipVisible ? React259.createElement(Tooltip, { content: title, position: tooltipPosition }, Title2) : Title2,
        React259.createElement(
          "div",
          { className: css(notification_drawer_default.notificationDrawerGroupToggleCount) },
          React259.createElement(Badge, { isRead }, count3)
        ),
        React259.createElement(
          "span",
          { className: notification_drawer_default.notificationDrawerGroupToggleIcon },
          React259.createElement(angle_right_icon_default, null)
        )
      )
    ),
    children2
  );
};
NotificationDrawerGroup.displayName = "NotificationDrawerGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawerGroupList.js
var React260 = __toESM(require_react());
var NotificationDrawerGroupList = (_a2) => {
  var { children: children2, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React260.createElement("div", Object.assign({}, props, { className: css(notification_drawer_default.notificationDrawerGroupList, className) }), children2);
};
NotificationDrawerGroupList.displayName = "NotificationDrawerGroupList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawerHeader.js
var React261 = __toESM(require_react());
var NotificationDrawerHeader = (_a2) => {
  var { children: children2, className = "", count: count3, closeButtonAriaLabel = "Close", customText, onClose, title = "Notifications", unreadText = "unread" } = _a2, props = __rest(_a2, ["children", "className", "count", "closeButtonAriaLabel", "customText", "onClose", "title", "unreadText"]);
  return React261.createElement(
    "div",
    Object.assign({}, props, { className: css(notification_drawer_default.notificationDrawerHeader, className) }),
    React261.createElement("h1", { className: css(notification_drawer_default.notificationDrawerHeaderTitle) }, title),
    (customText !== void 0 || count3 !== void 0) && React261.createElement("span", { className: css(notification_drawer_default.notificationDrawerHeaderStatus), "aria-live": "polite" }, customText || `${count3} ${unreadText}`),
    (children2 || onClose) && React261.createElement(
      "div",
      { className: css(notification_drawer_default.notificationDrawerHeaderAction) },
      children2,
      onClose && React261.createElement(
        "div",
        null,
        React261.createElement(
          Button,
          { variant: ButtonVariant.plain, "aria-label": closeButtonAriaLabel, onClick: (event) => onClose(event) },
          React261.createElement(times_icon_default, { "aria-hidden": "true" })
        )
      )
    )
  );
};
NotificationDrawerHeader.displayName = "NotificationDrawerHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawerList.js
var React262 = __toESM(require_react());
var NotificationDrawerList = (_a2) => {
  var { children: children2, className = "", isHidden = false, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["children", "className", "isHidden", "aria-label"]);
  return React262.createElement("ul", Object.assign({}, props, { className: css(`${notification_drawer_default.notificationDrawer}__list`, className), hidden: isHidden, role: "list", "aria-label": ariaLabel }), children2);
};
NotificationDrawerList.displayName = "NotificationDrawerList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawerListItem.js
var React263 = __toESM(require_react());
var NotificationDrawerListItem = (_a2) => {
  var {
    children: children2 = null,
    className = "",
    isHoverable = true,
    isRead = false,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onClick = (event) => void 0,
    readStateScreenReaderText,
    tabIndex = 0,
    variant = "custom"
  } = _a2, props = __rest(_a2, ["children", "className", "isHoverable", "isRead", "onClick", "readStateScreenReaderText", "tabIndex", "variant"]);
  const onKeyDown = (event) => {
    if (!event.target.parentElement.classList.contains(notification_drawer_default.notificationDrawerListItemAction)) {
      if (event.key === "Enter" || event.key === " ") {
        event.target.click();
      }
    }
  };
  let readStateSRText;
  if (readStateScreenReaderText) {
    readStateSRText = readStateScreenReaderText;
  } else {
    readStateSRText = isRead ? "read" : "unread";
  }
  return React263.createElement(
    "li",
    Object.assign({}, props, { className: css(notification_drawer_default.notificationDrawerListItem, isHoverable && notification_drawer_default.modifiers.hoverable, notification_drawer_default.modifiers[variant], isRead && notification_drawer_default.modifiers.read, className), tabIndex, onClick: (e) => onClick(e), onKeyDown }),
    React263.createElement("span", { className: "pf-v6-screen-reader" }, readStateSRText),
    children2
  );
};
NotificationDrawerListItem.displayName = "NotificationDrawerListItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawerListItemBody.js
var React264 = __toESM(require_react());
var NotificationDrawerListItemBody = (_a2) => {
  var { children: children2, className = "", timestamp } = _a2, props = __rest(_a2, ["children", "className", "timestamp"]);
  return React264.createElement(
    React264.Fragment,
    null,
    React264.createElement("div", Object.assign({}, props, { className: css(notification_drawer_default.notificationDrawerListItemDescription, className) }), children2),
    timestamp && React264.createElement("div", { className: css(notification_drawer_default.notificationDrawerListItemTimestamp, className) }, timestamp)
  );
};
NotificationDrawerListItemBody.displayName = "NotificationDrawerListItemBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NotificationDrawer/NotificationDrawerListItemHeader.js
var React265 = __toESM(require_react());
var variantIcons2 = {
  success: check_circle_icon_default,
  danger: exclamation_circle_icon_default,
  warning: exclamation_triangle_icon_default,
  info: info_circle_icon_default,
  custom: bell_icon_default
};
var NotificationDrawerListItemHeader = (_a2) => {
  var { children: children2, className = "", icon = null, srTitle, title, variant = "custom", truncateTitle = 0, tooltipPosition, headingLevel: HeadingLevel = "h2" } = _a2, props = __rest(_a2, ["children", "className", "icon", "srTitle", "title", "variant", "truncateTitle", "tooltipPosition", "headingLevel"]);
  const titleRef = React265.useRef(null);
  const [isTooltipVisible, setIsTooltipVisible] = React265.useState(false);
  React265.useEffect(() => {
    if (!titleRef.current || !truncateTitle) {
      return;
    }
    titleRef.current.style.setProperty(c_notification_drawer_list_item_header_title_max_lines_default.name, truncateTitle.toString());
    const showTooltip = titleRef.current && titleRef.current.offsetHeight < titleRef.current.scrollHeight;
    if (isTooltipVisible !== showTooltip) {
      setIsTooltipVisible(showTooltip);
    }
  }, [titleRef, truncateTitle, isTooltipVisible]);
  const Icon2 = variantIcons2[variant];
  const Title2 = React265.createElement(
    HeadingLevel,
    Object.assign({}, isTooltipVisible && { tabIndex: 0 }, { ref: titleRef, className: css(notification_drawer_default.notificationDrawerListItemHeaderTitle, truncateTitle && notification_drawer_default.modifiers.truncate) }),
    srTitle && React265.createElement("span", { className: "pf-v6-screen-reader" }, srTitle),
    title
  );
  return React265.createElement(
    React265.Fragment,
    null,
    React265.createElement(
      "div",
      Object.assign({}, props, { className: css(notification_drawer_default.notificationDrawerListItemHeader, className) }),
      React265.createElement("span", { className: css(notification_drawer_default.notificationDrawerListItemHeaderIcon) }, icon ? icon : React265.createElement(Icon2, null)),
      isTooltipVisible ? React265.createElement(Tooltip, { content: title, position: tooltipPosition }, Title2) : Title2
    ),
    children2 && React265.createElement("div", { className: css(notification_drawer_default.notificationDrawerListItemAction) }, children2)
  );
};
NotificationDrawerListItemHeader.displayName = "NotificationDrawerListItemHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/OverflowMenu/OverflowMenu.js
var React267 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/OverflowMenu/overflow-menu.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/OverflowMenu/overflow-menu.css";
var overflow_menu_default = {
  "modifiers": {
    "buttonGroup": "pf-m-button-group",
    "iconButtonGroup": "pf-m-icon-button-group"
  },
  "overflowMenu": "pf-v6-c-overflow-menu",
  "overflowMenuContent": "pf-v6-c-overflow-menu__content",
  "overflowMenuControl": "pf-v6-c-overflow-menu__control",
  "overflowMenuGroup": "pf-v6-c-overflow-menu__group",
  "overflowMenuItem": "pf-v6-c-overflow-menu__item"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/OverflowMenu/OverflowMenuContext.js
var React266 = __toESM(require_react());
var OverflowMenuContext = React266.createContext({
  isBelowBreakpoint: false
});

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/OverflowMenu/OverflowMenu.js
var OverflowMenu = class extends React267.Component {
  constructor(props) {
    super(props);
    this.observer = () => {
    };
    this.handleResize = () => {
      const breakpointWidth = globalWidthBreakpoints[this.props.breakpoint];
      if (!breakpointWidth) {
        console.error("OverflowMenu will not be visible without a valid breakpoint.");
        return;
      }
      const relativeWidth = this.state.breakpointRef ? this.state.breakpointRef.clientWidth : window.innerWidth;
      const isBelowBreakpoint = relativeWidth < breakpointWidth;
      if (this.state.isBelowBreakpoint !== isBelowBreakpoint) {
        this.setState({ isBelowBreakpoint });
      }
    };
    this.handleResizeWithDelay = debounce(this.handleResize, 250);
    this.state = {
      isBelowBreakpoint: false,
      breakpointRef: void 0
    };
  }
  getBreakpointRef() {
    const { breakpointReference } = this.props;
    if (breakpointReference.current) {
      return breakpointReference.current;
    } else if (typeof breakpointReference === "function") {
      return breakpointReference();
    }
  }
  componentDidMount() {
    const reference2 = this.props.breakpointReference ? this.getBreakpointRef() : void 0;
    this.setState({ breakpointRef: reference2 });
    this.observer = getResizeObserver(reference2, this.handleResizeWithDelay);
    this.handleResize();
  }
  componentDidUpdate(prevProps, prevState) {
    const reference2 = this.props.breakpointReference ? this.getBreakpointRef() : void 0;
    if (prevState.breakpointRef !== reference2) {
      this.observer();
      this.setState({ breakpointRef: reference2 });
      this.observer = getResizeObserver(reference2, this.handleResizeWithDelay);
      this.handleResize();
    }
  }
  componentWillUnmount() {
    this.observer();
  }
  render() {
    const _a2 = this.props, { className, breakpoint, children: children2, breakpointReference } = _a2, props = __rest(_a2, ["className", "breakpoint", "children", "breakpointReference"]);
    return React267.createElement(
      "div",
      Object.assign({}, props, { className: css(overflow_menu_default.overflowMenu, className) }),
      React267.createElement(OverflowMenuContext.Provider, { value: { isBelowBreakpoint: this.state.isBelowBreakpoint } }, children2)
    );
  }
};
OverflowMenu.displayName = "OverflowMenu";
OverflowMenu.contextType = OverflowMenuContext;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/OverflowMenu/OverflowMenuControl.js
var React268 = __toESM(require_react());
var OverflowMenuControl = (_a2) => {
  var { className, children: children2, hasAdditionalOptions } = _a2, props = __rest(_a2, ["className", "children", "hasAdditionalOptions"]);
  return React268.createElement(OverflowMenuContext.Consumer, null, (value) => (value.isBelowBreakpoint || hasAdditionalOptions) && React268.createElement(
    "div",
    Object.assign({ className: css(overflow_menu_default.overflowMenuControl, className) }, props),
    " ",
    children2,
    " "
  ));
};
OverflowMenuControl.displayName = "OverflowMenuControl";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/OverflowMenu/OverflowMenuContent.js
var React269 = __toESM(require_react());
var OverflowMenuContent = ({ className, children: children2, isPersistent }) => React269.createElement(OverflowMenuContext.Consumer, null, (value) => (!value.isBelowBreakpoint || isPersistent) && React269.createElement("div", { className: css(overflow_menu_default.overflowMenuContent, className) }, children2));
OverflowMenuContent.displayName = "OverflowMenuContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/OverflowMenu/OverflowMenuGroup.js
var React270 = __toESM(require_react());
var OverflowMenuGroup = (_a2) => {
  var { className, children: children2, isPersistent = false, groupType } = _a2, props = __rest(_a2, ["className", "children", "isPersistent", "groupType"]);
  return React270.createElement(OverflowMenuContext.Consumer, null, (value) => (isPersistent || !value.isBelowBreakpoint) && React270.createElement("div", Object.assign({ className: css(overflow_menu_default.overflowMenuGroup, groupType === "button" && overflow_menu_default.modifiers.buttonGroup, groupType === "icon" && overflow_menu_default.modifiers.iconButtonGroup, className) }, props), children2));
};
OverflowMenuGroup.displayName = "OverflowMenuGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/OverflowMenu/OverflowMenuItem.js
var React271 = __toESM(require_react());
var OverflowMenuItem = ({ className, children: children2, isPersistent = false }) => React271.createElement(OverflowMenuContext.Consumer, null, (value) => (isPersistent || !value.isBelowBreakpoint) && React271.createElement(
  "div",
  { className: css(overflow_menu_default.overflowMenuItem, className) },
  " ",
  children2,
  " "
));
OverflowMenuItem.displayName = "OverflowMenuItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/OverflowMenu/OverflowMenuDropdownItem.js
var React272 = __toESM(require_react());
var OverflowMenuDropdownItem = (_a2) => {
  var { children: children2, isShared = false, itemId } = _a2, additionalProps = __rest(_a2, ["children", "isShared", "itemId"]);
  return React272.createElement(OverflowMenuContext.Consumer, null, (value) => (!isShared || value.isBelowBreakpoint) && React272.createElement(DropdownItem, Object.assign({ component: "button", value: itemId }, additionalProps), children2));
};
OverflowMenuDropdownItem.displayName = "OverflowMenuDropdownItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/Page.js
var React274 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/PageGroup.js
var React273 = __toESM(require_react());
var PageGroup = (_a2) => {
  var { className = "", children: children2, stickyOnBreakpoint, hasShadowTop = false, hasShadowBottom = false, hasOverflowScroll = false, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["className", "children", "stickyOnBreakpoint", "hasShadowTop", "hasShadowBottom", "hasOverflowScroll", "aria-label"]);
  const { height, getVerticalBreakpoint: getVerticalBreakpoint2 } = React273.useContext(PageContext);
  React273.useEffect(() => {
    if (hasOverflowScroll && !ariaLabel) {
      console.warn("PageGroup: An accessible aria-label is required when hasOverflowScroll is set to true.");
    }
  }, [hasOverflowScroll, ariaLabel]);
  return React273.createElement("div", Object.assign({}, props, { className: css(page_default.pageMainGroup, formatBreakpointMods(stickyOnBreakpoint, page_default, "sticky-", getVerticalBreakpoint2(height), true), hasShadowTop && page_default.modifiers.shadowTop, hasShadowBottom && page_default.modifiers.shadowBottom, hasOverflowScroll && page_default.modifiers.overflowScroll, className) }, hasOverflowScroll && { tabIndex: 0, role: "region", "aria-label": ariaLabel }), children2);
};
PageGroup.displayName = "PageGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/Page.js
var PageLayouts;
(function(PageLayouts2) {
  PageLayouts2["vertical"] = "vertical";
  PageLayouts2["horizontal"] = "horizontal";
})(PageLayouts || (PageLayouts = {}));
var Page = class extends React274.Component {
  constructor(props) {
    super(props);
    this.mainRef = React274.createRef();
    this.pageRef = React274.createRef();
    this.observer = () => {
    };
    this.getWindowWidth = () => {
      if (canUseDOM) {
        return this.pageRef.current ? this.pageRef.current.clientWidth : window.innerWidth;
      } else {
        return 1200;
      }
    };
    this.isMobile = () => (
      // eslint-disable-next-line radix
      this.getWindowWidth() < Number.parseInt(global_breakpoint_xl_default.value, 10)
    );
    this.resize = (_event) => {
      var _a2;
      const { onPageResize } = this.props;
      const mobileView = this.isMobile();
      if (onPageResize) {
        onPageResize(_event, { mobileView, windowSize: this.getWindowWidth() });
      }
      if (mobileView !== this.state.mobileView) {
        this.setState({ mobileView });
      }
      if ((_a2 = this.pageRef) === null || _a2 === void 0 ? void 0 : _a2.current) {
        const currentWidth = this.pageRef.current.clientWidth;
        const currentHeight = this.pageRef.current.clientHeight;
        if (this.state.width !== currentWidth) {
          this.setState({ width: currentWidth });
        }
        if (this.state.height !== currentHeight) {
          this.setState({ height: currentHeight });
        }
      }
    };
    this.handleResize = debounce(this.resize, 250);
    this.handleMainClick = () => {
      if (this.isMobile() && this.state.mobileIsSidebarOpen && this.mainRef.current) {
        this.setState({ mobileIsSidebarOpen: false });
      }
    };
    this.onSidebarToggleMobile = () => {
      this.setState((prevState) => ({
        mobileIsSidebarOpen: !prevState.mobileIsSidebarOpen
      }));
    };
    this.onSidebarToggleDesktop = () => {
      this.setState((prevState) => ({
        desktopIsSidebarOpen: !prevState.desktopIsSidebarOpen
      }));
    };
    const { isManagedSidebar, defaultManagedSidebarIsOpen } = props;
    const managedSidebarOpen = !isManagedSidebar ? true : defaultManagedSidebarIsOpen;
    this.state = {
      desktopIsSidebarOpen: managedSidebarOpen,
      mobileIsSidebarOpen: false,
      mobileView: false,
      width: null,
      height: null
    };
  }
  componentDidMount() {
    const { isManagedSidebar, onPageResize } = this.props;
    if (isManagedSidebar || onPageResize) {
      this.observer = getResizeObserver(this.pageRef.current, this.handleResize);
      const currentRef = this.mainRef.current;
      if (currentRef) {
        currentRef.addEventListener("mousedown", this.handleMainClick);
        currentRef.addEventListener("touchstart", this.handleMainClick);
      }
      this.resize();
    }
  }
  componentWillUnmount() {
    const { isManagedSidebar, onPageResize } = this.props;
    if (isManagedSidebar || onPageResize) {
      this.observer();
      const currentRef = this.mainRef.current;
      if (currentRef) {
        currentRef.removeEventListener("mousedown", this.handleMainClick);
        currentRef.removeEventListener("touchstart", this.handleMainClick);
      }
    }
  }
  render() {
    const _a2 = this.props, {
      breadcrumb,
      isBreadcrumbWidthLimited,
      className,
      children: children2,
      masthead,
      sidebar,
      notificationDrawer,
      isNotificationDrawerExpanded,
      onNotificationDrawerExpand,
      drawerDefaultSize,
      drawerMinSize,
      drawerMaxSize,
      isHorizontalSubnavWidthLimited,
      skipToContent,
      role,
      mainContainerId,
      isManagedSidebar,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      defaultManagedSidebarIsOpen,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onPageResize,
      getBreakpoint: getBreakpoint2,
      getVerticalBreakpoint: getVerticalBreakpoint2,
      mainAriaLabel,
      mainTabIndex,
      mainComponent,
      horizontalSubnav,
      isHorizontalSubnavGrouped,
      isBreadcrumbGrouped,
      additionalGroupedContent,
      groupProps,
      breadcrumbProps
    } = _a2, rest = __rest(_a2, ["breadcrumb", "isBreadcrumbWidthLimited", "className", "children", "masthead", "sidebar", "notificationDrawer", "isNotificationDrawerExpanded", "onNotificationDrawerExpand", "drawerDefaultSize", "drawerMinSize", "drawerMaxSize", "isHorizontalSubnavWidthLimited", "skipToContent", "role", "mainContainerId", "isManagedSidebar", "defaultManagedSidebarIsOpen", "onPageResize", "getBreakpoint", "getVerticalBreakpoint", "mainAriaLabel", "mainTabIndex", "mainComponent", "horizontalSubnav", "isHorizontalSubnavGrouped", "isBreadcrumbGrouped", "additionalGroupedContent", "groupProps", "breadcrumbProps"]);
    const { mobileView, mobileIsSidebarOpen, desktopIsSidebarOpen, width, height } = this.state;
    const context = {
      isManagedSidebar,
      onSidebarToggle: mobileView ? this.onSidebarToggleMobile : this.onSidebarToggleDesktop,
      isSidebarOpen: mobileView ? mobileIsSidebarOpen : desktopIsSidebarOpen,
      width,
      height,
      getBreakpoint: getBreakpoint2,
      getVerticalBreakpoint: getVerticalBreakpoint2
    };
    let nav = null;
    if (horizontalSubnav && isHorizontalSubnavWidthLimited) {
      nav = React274.createElement(
        "div",
        { className: css(page_default.pageMainNav, page_default.modifiers.limitWidth) },
        React274.createElement("div", { className: css(page_default.pageMainBody) }, horizontalSubnav)
      );
    } else if (horizontalSubnav) {
      nav = React274.createElement("div", { className: css(page_default.pageMainNav) }, horizontalSubnav);
    }
    const crumb = breadcrumb ? React274.createElement("section", { className: css(page_default.pageMainBreadcrumb, isBreadcrumbWidthLimited && page_default.modifiers.limitWidth, formatBreakpointMods(breadcrumbProps === null || breadcrumbProps === void 0 ? void 0 : breadcrumbProps.stickyOnBreakpoint, page_default, "sticky-", getVerticalBreakpoint2(height), true)) }, isBreadcrumbWidthLimited ? React274.createElement("div", { className: css(page_default.pageMainBody) }, breadcrumb) : breadcrumb) : null;
    const isGrouped = isHorizontalSubnavGrouped || isBreadcrumbGrouped || additionalGroupedContent;
    const group2 = isGrouped ? React274.createElement(
      PageGroup,
      Object.assign({}, groupProps),
      isHorizontalSubnavGrouped && nav,
      isBreadcrumbGrouped && crumb,
      additionalGroupedContent
    ) : null;
    const Component50 = mainComponent;
    const main2 = React274.createElement(
      "div",
      { className: css(page_default.pageMainContainer) },
      React274.createElement(
        Component50,
        { ref: this.mainRef, role, id: mainContainerId, className: css(page_default.pageMain), tabIndex: mainTabIndex, "aria-label": mainAriaLabel },
        group2,
        !isHorizontalSubnavGrouped && nav,
        !isBreadcrumbGrouped && crumb,
        children2
      )
    );
    const panelContent = React274.createElement(DrawerPanelContent, { defaultSize: drawerDefaultSize, minSize: drawerMinSize, maxSize: drawerMaxSize }, notificationDrawer);
    return React274.createElement(
      PageContextProvider,
      { value: context },
      React274.createElement(
        "div",
        Object.assign({ ref: this.pageRef }, rest, { className: css(page_default.page, width !== null && height !== null && "pf-m-resize-observer", width !== null && `pf-m-breakpoint-${getBreakpoint2(width)}`, height !== null && `pf-m-height-breakpoint-${getVerticalBreakpoint2(height)}`, className) }),
        skipToContent,
        masthead,
        sidebar,
        notificationDrawer && React274.createElement(
          "div",
          { className: css(page_default.pageDrawer) },
          React274.createElement(
            Drawer,
            { isExpanded: isNotificationDrawerExpanded, onExpand: (event) => onNotificationDrawerExpand(event) },
            React274.createElement(
              DrawerContent,
              { panelContent },
              React274.createElement(DrawerContentBody, null, main2)
            )
          )
        ),
        !notificationDrawer && main2
      )
    );
  }
};
Page.displayName = "Page";
Page.defaultProps = {
  isManagedSidebar: false,
  isBreadcrumbWidthLimited: false,
  defaultManagedSidebarIsOpen: true,
  mainTabIndex: -1,
  isNotificationDrawerExpanded: false,
  onNotificationDrawerExpand: () => null,
  mainComponent: "main",
  getBreakpoint,
  getVerticalBreakpoint
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/PageBreadcrumb.js
var React275 = __toESM(require_react());
var PageBreadcrumb = (_a2) => {
  var { className = "", children: children2, isWidthLimited, stickyOnBreakpoint, hasShadowTop = false, hasShadowBottom = false, hasOverflowScroll = false, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["className", "children", "isWidthLimited", "stickyOnBreakpoint", "hasShadowTop", "hasShadowBottom", "hasOverflowScroll", "aria-label"]);
  const { height, getVerticalBreakpoint: getVerticalBreakpoint2 } = React275.useContext(PageContext);
  React275.useEffect(() => {
    if (hasOverflowScroll && !ariaLabel) {
      console.warn("PageBreadcrumb: An accessible aria-label is required when hasOverflowScroll is set to true.");
    }
  }, [hasOverflowScroll, ariaLabel]);
  return React275.createElement(
    "section",
    Object.assign({ className: css(page_default.pageMainBreadcrumb, formatBreakpointMods(stickyOnBreakpoint, page_default, "sticky-", getVerticalBreakpoint2(height), true), isWidthLimited && page_default.modifiers.limitWidth, hasShadowTop && page_default.modifiers.shadowTop, hasShadowBottom && page_default.modifiers.shadowBottom, hasOverflowScroll && page_default.modifiers.overflowScroll, className) }, hasOverflowScroll && { tabIndex: 0 }, { "aria-label": ariaLabel }, props),
    isWidthLimited && React275.createElement("div", { className: css(page_default.pageMainBody) }, children2),
    !isWidthLimited && children2
  );
};
PageBreadcrumb.displayName = "PageBreadcrumb";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/PageSidebarBody.js
var React276 = __toESM(require_react());
var PageSidebarBody = (_a2) => {
  var { children: children2, className, usePageInsets, isFilled } = _a2, props = __rest(_a2, ["children", "className", "usePageInsets", "isFilled"]);
  return React276.createElement("div", Object.assign({ className: css(page_default.pageSidebarBody, usePageInsets && page_default.modifiers.pageInsets, isFilled === false && page_default.modifiers.noFill, isFilled === true && page_default.modifiers.fill, className) }, props), children2);
};
PageSidebarBody.displayName = "PageSidebarBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/PageSection.js
var React277 = __toESM(require_react());
var PageSectionVariants;
(function(PageSectionVariants2) {
  PageSectionVariants2["default"] = "default";
  PageSectionVariants2["secondary"] = "secondary";
})(PageSectionVariants || (PageSectionVariants = {}));
var PageSectionTypes;
(function(PageSectionTypes2) {
  PageSectionTypes2["default"] = "default";
  PageSectionTypes2["nav"] = "nav";
  PageSectionTypes2["subNav"] = "subnav";
  PageSectionTypes2["breadcrumb"] = "breadcrumb";
  PageSectionTypes2["tabs"] = "tabs";
  PageSectionTypes2["wizard"] = "wizard";
})(PageSectionTypes || (PageSectionTypes = {}));
var variantType = {
  [PageSectionTypes.default]: page_default.pageMainSection,
  [PageSectionTypes.nav]: page_default.pageMainNav,
  [PageSectionTypes.subNav]: page_default.pageMainSubnav,
  [PageSectionTypes.breadcrumb]: page_default.pageMainBreadcrumb,
  [PageSectionTypes.tabs]: page_default.pageMainTabs,
  [PageSectionTypes.wizard]: page_default.pageMainWizard
};
var variantStyle = {
  [PageSectionVariants.default]: "",
  [PageSectionVariants.secondary]: page_default.modifiers.secondary
};
var PageSection = (_a2) => {
  var { className = "", children: children2, variant = "default", type: type2 = "default", padding, isFilled, isWidthLimited = false, isCenterAligned = false, stickyOnBreakpoint, hasShadowTop = false, hasShadowBottom = false, hasOverflowScroll = false, "aria-label": ariaLabel, component = "section" } = _a2, props = __rest(_a2, ["className", "children", "variant", "type", "padding", "isFilled", "isWidthLimited", "isCenterAligned", "stickyOnBreakpoint", "hasShadowTop", "hasShadowBottom", "hasOverflowScroll", "aria-label", "component"]);
  const { height, getVerticalBreakpoint: getVerticalBreakpoint2 } = React277.useContext(PageContext);
  React277.useEffect(() => {
    if (hasOverflowScroll && !ariaLabel) {
      console.warn("PageSection: An accessible aria-label is required when hasOverflowScroll is set to true.");
    }
  }, [hasOverflowScroll, ariaLabel]);
  const Component50 = component;
  return React277.createElement(
    Component50,
    Object.assign({}, props, { className: css(variantType[type2], formatBreakpointMods(padding, page_default), formatBreakpointMods(stickyOnBreakpoint, page_default, "sticky-", getVerticalBreakpoint2(height), true), type2 === PageSectionTypes.default && variantStyle[variant], isFilled === false && page_default.modifiers.noFill, isFilled === true && page_default.modifiers.fill, isWidthLimited && page_default.modifiers.limitWidth, isWidthLimited && isCenterAligned && type2 !== PageSectionTypes.subNav && page_default.modifiers.alignCenter, hasShadowTop && page_default.modifiers.shadowTop, hasShadowBottom && page_default.modifiers.shadowBottom, hasOverflowScroll && page_default.modifiers.overflowScroll, className) }, hasOverflowScroll && { tabIndex: 0 }, { "aria-label": ariaLabel }),
    isWidthLimited && React277.createElement("div", { className: css(page_default.pageMainBody) }, children2),
    !isWidthLimited && children2
  );
};
PageSection.displayName = "PageSection";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/PageNavigation.js
var React278 = __toESM(require_react());
var PageNavigation = (_a2) => {
  var { className = "", children: children2, isWidthLimited, stickyOnBreakpoint, hasShadowTop = false, hasShadowBottom = false, hasOverflowScroll = false, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["className", "children", "isWidthLimited", "stickyOnBreakpoint", "hasShadowTop", "hasShadowBottom", "hasOverflowScroll", "aria-label"]);
  const { height, getVerticalBreakpoint: getVerticalBreakpoint2 } = React278.useContext(PageContext);
  React278.useEffect(() => {
    if (hasOverflowScroll && !ariaLabel) {
      console.warn("PageNavigation: An accessible aria-label is required when hasOverflowScroll is set to true.");
    }
  }, [hasOverflowScroll, ariaLabel]);
  return React278.createElement(
    "div",
    Object.assign({ className: css(page_default.pageMainNav, formatBreakpointMods(stickyOnBreakpoint, page_default, "sticky-", getVerticalBreakpoint2(height), true), isWidthLimited && page_default.modifiers.limitWidth, hasShadowTop && page_default.modifiers.shadowTop, hasShadowBottom && page_default.modifiers.shadowBottom, hasOverflowScroll && page_default.modifiers.overflowScroll, className) }, hasOverflowScroll && { tabIndex: 0, role: "region", "aria-label": ariaLabel }, props),
    isWidthLimited && React278.createElement("div", { className: css(page_default.pageMainBody) }, children2),
    !isWidthLimited && children2
  );
};
PageNavigation.displayName = "PageNavigation";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Page/PageToggleButton.js
var React279 = __toESM(require_react());
var PageToggleButton = (_a2) => {
  var { children: children2, isSidebarOpen = true, onSidebarToggle = () => void 0, id: id2 = "nav-toggle" } = _a2, props = __rest(_a2, ["children", "isSidebarOpen", "onSidebarToggle", "id"]);
  return React279.createElement(PageContextConsumer, null, ({ isManagedSidebar, onSidebarToggle: managedOnSidebarToggle, isSidebarOpen: managedIsSidebarOpen }) => {
    const sidebarToggle = isManagedSidebar ? managedOnSidebarToggle : onSidebarToggle;
    const sidebarOpen = isManagedSidebar ? managedIsSidebarOpen : isSidebarOpen;
    return React279.createElement(Button, Object.assign({ id: id2, onClick: sidebarToggle, "aria-label": "Side navigation toggle", "aria-expanded": sidebarOpen ? "true" : "false", variant: ButtonVariant.plain }, props), children2);
  });
};
PageToggleButton.displayName = "PageToggleButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Pagination/Pagination.js
var React283 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Pagination/ToggleTemplate.js
var React280 = __toESM(require_react());
var ToggleTemplate = ({ firstIndex = 0, lastIndex = 0, itemCount = 0, itemsTitle = "items", ofWord = "of" }) => React280.createElement(
  React280.Fragment,
  null,
  React280.createElement(
    "b",
    null,
    firstIndex,
    " - ",
    lastIndex
  ),
  " ",
  ofWord,
  " ",
  React280.createElement("b", null, itemCount),
  " ",
  itemsTitle
);
ToggleTemplate.displayName = "ToggleTemplate";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Pagination/pagination.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Pagination/pagination.css";
var pagination_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "formControl": "pf-v6-c-form-control",
  "modifiers": {
    "bottom": "pf-m-bottom",
    "static": "pf-m-static",
    "first": "pf-m-first",
    "last": "pf-m-last",
    "sticky": "pf-m-sticky",
    "pageInsets": "pf-m-page-insets",
    "displaySummary": "pf-m-display-summary",
    "displayFull": "pf-m-display-full",
    "insetNone": "pf-m-inset-none",
    "insetSm": "pf-m-inset-sm",
    "insetMd": "pf-m-inset-md",
    "insetLg": "pf-m-inset-lg",
    "insetXl": "pf-m-inset-xl",
    "inset_2xl": "pf-m-inset-2xl",
    "displaySummaryOnSm": "pf-m-display-summary-on-sm",
    "displayFullOnSm": "pf-m-display-full-on-sm",
    "insetNoneOnSm": "pf-m-inset-none-on-sm",
    "insetSmOnSm": "pf-m-inset-sm-on-sm",
    "insetMdOnSm": "pf-m-inset-md-on-sm",
    "insetLgOnSm": "pf-m-inset-lg-on-sm",
    "insetXlOnSm": "pf-m-inset-xl-on-sm",
    "inset_2xlOnSm": "pf-m-inset-2xl-on-sm",
    "displaySummaryOnMd": "pf-m-display-summary-on-md",
    "displayFullOnMd": "pf-m-display-full-on-md",
    "insetNoneOnMd": "pf-m-inset-none-on-md",
    "insetSmOnMd": "pf-m-inset-sm-on-md",
    "insetMdOnMd": "pf-m-inset-md-on-md",
    "insetLgOnMd": "pf-m-inset-lg-on-md",
    "insetXlOnMd": "pf-m-inset-xl-on-md",
    "inset_2xlOnMd": "pf-m-inset-2xl-on-md",
    "displaySummaryOnLg": "pf-m-display-summary-on-lg",
    "displayFullOnLg": "pf-m-display-full-on-lg",
    "insetNoneOnLg": "pf-m-inset-none-on-lg",
    "insetSmOnLg": "pf-m-inset-sm-on-lg",
    "insetMdOnLg": "pf-m-inset-md-on-lg",
    "insetLgOnLg": "pf-m-inset-lg-on-lg",
    "insetXlOnLg": "pf-m-inset-xl-on-lg",
    "inset_2xlOnLg": "pf-m-inset-2xl-on-lg",
    "displaySummaryOnXl": "pf-m-display-summary-on-xl",
    "displayFullOnXl": "pf-m-display-full-on-xl",
    "insetNoneOnXl": "pf-m-inset-none-on-xl",
    "insetSmOnXl": "pf-m-inset-sm-on-xl",
    "insetMdOnXl": "pf-m-inset-md-on-xl",
    "insetLgOnXl": "pf-m-inset-lg-on-xl",
    "insetXlOnXl": "pf-m-inset-xl-on-xl",
    "inset_2xlOnXl": "pf-m-inset-2xl-on-xl",
    "displaySummaryOn_2xl": "pf-m-display-summary-on-2xl",
    "displayFullOn_2xl": "pf-m-display-full-on-2xl",
    "insetNoneOn_2xl": "pf-m-inset-none-on-2xl",
    "insetSmOn_2xl": "pf-m-inset-sm-on-2xl",
    "insetMdOn_2xl": "pf-m-inset-md-on-2xl",
    "insetLgOn_2xl": "pf-m-inset-lg-on-2xl",
    "insetXlOn_2xl": "pf-m-inset-xl-on-2xl",
    "inset_2xlOn_2xl": "pf-m-inset-2xl-on-2xl"
  },
  "pagination": "pf-v6-c-pagination",
  "paginationNav": "pf-v6-c-pagination__nav",
  "paginationNavControl": "pf-v6-c-pagination__nav-control",
  "paginationNavPageSelect": "pf-v6-c-pagination__nav-page-select",
  "paginationPageMenu": "pf-v6-c-pagination__page-menu",
  "paginationTotalItems": "pf-v6-c-pagination__total-items"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Pagination/Navigation.js
var React281 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/angle-double-left-icon.js
var AngleDoubleLeftIconConfig = {
  name: "AngleDoubleLeftIcon",
  height: 512,
  width: 448,
  svgPath: "M223.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L319.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L393.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34zm-192 34l136 136c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L127.9 256l96.4-96.4c9.4-9.4 9.4-24.6 0-33.9L201.7 103c-9.4-9.4-24.6-9.4-33.9 0l-136 136c-9.5 9.4-9.5 24.6-.1 34z",
  yOffset: 0,
  xOffset: 0
};
var AngleDoubleLeftIcon = createIcon(AngleDoubleLeftIconConfig);
var angle_double_left_icon_default = AngleDoubleLeftIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/angle-double-right-icon.js
var AngleDoubleRightIconConfig = {
  name: "AngleDoubleRightIcon",
  height: 512,
  width: 448,
  svgPath: "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34zm192-34l-136-136c-9.4-9.4-24.6-9.4-33.9 0l-22.6 22.6c-9.4 9.4-9.4 24.6 0 33.9l96.4 96.4-96.4 96.4c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l136-136c9.4-9.2 9.4-24.4 0-33.8z",
  yOffset: 0,
  xOffset: 0
};
var AngleDoubleRightIcon = createIcon(AngleDoubleRightIconConfig);
var angle_double_right_icon_default = AngleDoubleRightIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Pagination/Navigation.js
var Navigation = class _Navigation extends React281.Component {
  constructor(props) {
    super(props);
    this.handleNewPage = (_evt, newPage) => {
      const { perPage, onSetPage } = this.props;
      const startIdx = (newPage - 1) * perPage;
      const endIdx = newPage * perPage;
      return onSetPage(_evt, newPage, perPage, startIdx, endIdx);
    };
    this.state = { userInputPage: this.props.page };
  }
  static parseInteger(input, lastPage) {
    let inputPage = Number.parseInt(input, 10);
    if (!Number.isNaN(inputPage)) {
      inputPage = inputPage > lastPage ? lastPage : inputPage;
      inputPage = inputPage < 1 ? 1 : inputPage;
    }
    return inputPage;
  }
  onChange(event, lastPage) {
    const inputPage = _Navigation.parseInteger(event.currentTarget.value, lastPage);
    this.setState({ userInputPage: Number.isNaN(inputPage) ? event.currentTarget.value : inputPage });
  }
  onKeyDown(event, page, lastPage, onPageInput) {
    const allowedKeys = [
      "Tab",
      "Backspace",
      "Delete",
      "ArrowLeft",
      "ArrowRight",
      "Home",
      "End",
      "ArrowUp",
      "ArrowDown"
    ];
    if (event.key === KeyTypes.Enter) {
      const inputPage = _Navigation.parseInteger(this.state.userInputPage, lastPage);
      onPageInput(event, Number.isNaN(inputPage) ? page : inputPage);
      this.handleNewPage(event, Number.isNaN(inputPage) ? page : inputPage);
    } else if (!/^\d*$/.test(event.key) && !allowedKeys.includes(event.key)) {
      event.preventDefault();
    }
  }
  componentDidUpdate(lastState) {
    if (this.props.page !== lastState.page && this.props.page <= this.props.lastPage && this.state.userInputPage !== this.props.page) {
      this.setState({ userInputPage: this.props.page });
    }
  }
  render() {
    const _a2 = this.props, {
      page,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      perPage,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onSetPage,
      isDisabled,
      itemCount,
      lastPage,
      firstPage,
      pagesTitle,
      pagesTitlePlural,
      toLastPageAriaLabel,
      toNextPageAriaLabel,
      toFirstPageAriaLabel,
      toPreviousPageAriaLabel,
      currPageAriaLabel,
      paginationAriaLabel,
      ofWord,
      onNextClick,
      onPreviousClick,
      onFirstClick,
      onLastClick,
      onPageInput,
      className,
      isCompact
    } = _a2, props = __rest(_a2, ["page", "perPage", "onSetPage", "isDisabled", "itemCount", "lastPage", "firstPage", "pagesTitle", "pagesTitlePlural", "toLastPageAriaLabel", "toNextPageAriaLabel", "toFirstPageAriaLabel", "toPreviousPageAriaLabel", "currPageAriaLabel", "paginationAriaLabel", "ofWord", "onNextClick", "onPreviousClick", "onFirstClick", "onLastClick", "onPageInput", "className", "isCompact"]);
    const { userInputPage } = this.state;
    return React281.createElement(
      "nav",
      Object.assign({ className: css(pagination_default.paginationNav, className), "aria-label": paginationAriaLabel }, props),
      !isCompact && React281.createElement(
        "div",
        { className: css(pagination_default.paginationNavControl, pagination_default.modifiers.first) },
        React281.createElement(
          Button,
          { variant: ButtonVariant.plain, isDisabled: isDisabled || page === firstPage || page === 0, "aria-label": toFirstPageAriaLabel, "data-action": "first", onClick: (event) => {
            onFirstClick(event, 1);
            this.handleNewPage(event, 1);
            this.setState({ userInputPage: 1 });
          } },
          React281.createElement(angle_double_left_icon_default, null)
        )
      ),
      React281.createElement(
        "div",
        { className: pagination_default.paginationNavControl },
        React281.createElement(
          Button,
          { variant: ButtonVariant.plain, isDisabled: isDisabled || page === firstPage || page === 0, "data-action": "previous", onClick: (event) => {
            const newPage = page - 1 >= 1 ? page - 1 : 1;
            onPreviousClick(event, newPage);
            this.handleNewPage(event, newPage);
            this.setState({ userInputPage: newPage });
          }, "aria-label": toPreviousPageAriaLabel },
          React281.createElement(angle_left_icon_default, null)
        )
      ),
      !isCompact && React281.createElement(
        "div",
        { className: pagination_default.paginationNavPageSelect },
        React281.createElement(TextInput, { "aria-label": currPageAriaLabel, type: "number", isDisabled: isDisabled || itemCount && page === firstPage && page === lastPage && itemCount >= 0 || page === 0, min: lastPage <= 0 && firstPage <= 0 ? 0 : 1, max: lastPage, value: userInputPage, onKeyDown: (event) => this.onKeyDown(event, page, lastPage, onPageInput), onChange: (event) => this.onChange(event, lastPage) }),
        (itemCount || itemCount === 0) && React281.createElement(
          "span",
          { "aria-hidden": "true" },
          ofWord,
          " ",
          pagesTitle ? pluralize(lastPage, pagesTitle, pagesTitlePlural) : lastPage
        )
      ),
      React281.createElement(
        "div",
        { className: pagination_default.paginationNavControl },
        React281.createElement(
          Button,
          { variant: ButtonVariant.plain, isDisabled: isDisabled || page === lastPage, "aria-label": toNextPageAriaLabel, "data-action": "next", onClick: (event) => {
            const newPage = page + 1 <= lastPage ? page + 1 : lastPage;
            onNextClick(event, newPage);
            this.handleNewPage(event, newPage);
            this.setState({ userInputPage: newPage });
          } },
          React281.createElement(angle_right_icon_default, null)
        )
      ),
      !isCompact && React281.createElement(
        "div",
        { className: css(pagination_default.paginationNavControl, pagination_default.modifiers.last) },
        React281.createElement(
          Button,
          { variant: ButtonVariant.plain, isDisabled: isDisabled || page === lastPage, "aria-label": toLastPageAriaLabel, "data-action": "last", onClick: (event) => {
            onLastClick(event, lastPage);
            this.handleNewPage(event, lastPage);
            this.setState({ userInputPage: lastPage });
          } },
          React281.createElement(angle_double_right_icon_default, null)
        )
      )
    );
  }
};
Navigation.displayName = "Navigation";
Navigation.defaultProps = {
  className: "",
  isDisabled: false,
  isCompact: false,
  lastPage: 0,
  firstPage: 0,
  pagesTitle: "",
  pagesTitlePlural: "",
  toLastPageAriaLabel: "Go to last page",
  toNextPageAriaLabel: "Go to next page",
  toFirstPageAriaLabel: "Go to first page",
  toPreviousPageAriaLabel: "Go to previous page",
  currPageAriaLabel: "Current page",
  paginationAriaLabel: "Pagination",
  ofWord: "of",
  onNextClick: () => void 0,
  onPreviousClick: () => void 0,
  onFirstClick: () => void 0,
  onLastClick: () => void 0,
  onPageInput: () => void 0
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Pagination/PaginationOptionsMenu.js
var React282 = __toESM(require_react());
var PaginationOptionsMenu = ({
  className,
  widgetId,
  page: pageProp,
  itemCount,
  isDisabled = false,
  minWidth,
  dropDirection = "down",
  perPageOptions = [],
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  itemsPerPageTitle = "Items per page",
  perPageSuffix = "per page",
  optionsToggleAriaLabel,
  ofWord = "of",
  perPage = 0,
  firstIndex = 0,
  lastIndex = 0,
  isLastFullPageShown = false,
  itemsTitle = "items",
  toggleTemplate,
  onPerPageSelect = () => null,
  containerRef
}) => {
  const [isOpen, setIsOpen] = React282.useState(false);
  const toggleRef = React282.useRef(null);
  const menuRef = React282.useRef(null);
  const onToggle = () => {
    setIsOpen((prevState) => !prevState);
  };
  const onSelect = () => {
    var _a2;
    setIsOpen((prevState) => !prevState);
    (_a2 = toggleRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
  };
  const handleNewPerPage = (_evt, newPerPage) => {
    let newPage = pageProp;
    while (Math.ceil(itemCount / newPerPage) < newPage) {
      newPage--;
    }
    if (isLastFullPageShown) {
      if (itemCount / newPerPage !== newPage) {
        while (newPage > 1 && itemCount - newPerPage * newPage < 0) {
          newPage--;
        }
      }
    }
    const startIdx = (newPage - 1) * newPerPage;
    const endIdx = newPage * newPerPage;
    return onPerPageSelect(_evt, newPerPage, newPage, startIdx, endIdx);
  };
  React282.useEffect(() => {
    const handleMenuKeys = (event) => {
      var _a2, _b, _c;
      if (isOpen && ((_a2 = menuRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) || ((_b = toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
        if (event.key === "Escape" || event.key === "Tab") {
          setIsOpen(false);
          (_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.focus();
        }
      }
    };
    const handleClick = (event) => {
      var _a2, _b, _c;
      if (isOpen && ((_a2 = toggleRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target))) {
        setTimeout(() => {
          var _a3;
          const firstElement = (_a3 = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a3 === void 0 ? void 0 : _a3.querySelector("li button:not(:disabled)");
          firstElement && firstElement.focus();
        }, 0);
      }
      if (isOpen && !((_b = toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)) && !((_c = menuRef.current) === null || _c === void 0 ? void 0 : _c.contains(event.target))) {
        setIsOpen(false);
      }
    };
    window.addEventListener("keydown", handleMenuKeys);
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("keydown", handleMenuKeys);
      window.removeEventListener("click", handleClick);
    };
  }, [isOpen, menuRef]);
  const renderItems = () => perPageOptions.map(({ value, title }) => React282.createElement(
    MenuItem,
    { key: value, "data-action": `per-page-${value}`, isSelected: perPage === value, onClick: (event) => handleNewPerPage(event, value) },
    title,
    ` ${perPageSuffix}`
  ));
  const toggle = React282.createElement(
    MenuToggle,
    Object.assign({ ref: toggleRef, onClick: onToggle }, optionsToggleAriaLabel && { "aria-label": optionsToggleAriaLabel }, { isDisabled: isDisabled || itemCount && itemCount <= 0, isExpanded: isOpen }, widgetId && { id: `${widgetId}-toggle` }, { variant: "plainText", "aria-haspopup": "listbox" }),
    toggleTemplate && typeof toggleTemplate === "string" && fillTemplate(toggleTemplate, { firstIndex, lastIndex, ofWord, itemCount, itemsTitle }),
    toggleTemplate && typeof toggleTemplate !== "string" && toggleTemplate({
      firstIndex,
      lastIndex,
      ofWord,
      itemCount,
      itemsTitle
    }),
    !toggleTemplate && React282.createElement(ToggleTemplate, { firstIndex, lastIndex, ofWord, itemCount, itemsTitle })
  );
  const menu = React282.createElement(
    Menu,
    { className: css(className), onSelect, ref: menuRef },
    React282.createElement(
      MenuContent,
      null,
      React282.createElement(MenuList, null, renderItems())
    )
  );
  return React282.createElement(Popper, { trigger: toggle, triggerRef: toggleRef, popper: menu, popperRef: menuRef, isVisible: isOpen, direction: dropDirection, appendTo: (containerRef === null || containerRef === void 0 ? void 0 : containerRef.current) || void 0, minWidth: minWidth !== void 0 ? minWidth : "revert" });
};
PaginationOptionsMenu.displayName = "PaginationOptionsMenu";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Pagination/Pagination.js
var PaginationVariant;
(function(PaginationVariant2) {
  PaginationVariant2["bottom"] = "bottom";
  PaginationVariant2["top"] = "top";
})(PaginationVariant || (PaginationVariant = {}));
var defaultPerPageOptions = [
  {
    title: "10",
    value: 10
  },
  {
    title: "20",
    value: 20
  },
  {
    title: "50",
    value: 50
  },
  {
    title: "100",
    value: 100
  }
];
var handleInputWidth = (lastPage, node) => {
  if (!node) {
    return;
  }
  const len = String(lastPage).length;
  if (len >= 3) {
    node.style.setProperty(c_pagination_nav_page_select_c_form_control_width_chars_default.name, `${len}`);
  } else {
    node.style.setProperty(c_pagination_nav_page_select_c_form_control_width_chars_default.name, "2");
  }
};
var Pagination = (_a2) => {
  var { children: children2, className = "", variant = PaginationVariant.top, isDisabled = false, isCompact = false, isSticky = false, isStatic = false, dropDirection: dropDirectionProp, toggleTemplate, perPage = defaultPerPageOptions[0].value, titles = {
    items: "",
    page: "",
    pages: "",
    itemsPerPage: "Items per page",
    perPageSuffix: "per page",
    toFirstPageAriaLabel: "Go to first page",
    toPreviousPageAriaLabel: "Go to previous page",
    toLastPageAriaLabel: "Go to last page",
    toNextPageAriaLabel: "Go to next page",
    optionsToggleAriaLabel: "",
    currPageAriaLabel: "Current page",
    paginationAriaLabel: "Pagination",
    ofWord: "of"
  }, firstPage = 1, page: pageProp = 1, offset: offset3 = null, isLastFullPageShown = false, itemsStart = null, itemsEnd = null, itemCount, perPageOptions = defaultPerPageOptions, widgetId = "options-menu", onSetPage = () => void 0, onPerPageSelect = () => void 0, onFirstClick = () => void 0, onPreviousClick = () => void 0, onNextClick = () => void 0, onPageInput = () => void 0, onLastClick = () => void 0, ouiaId, ouiaSafe = true, usePageInsets, inset } = _a2, props = __rest(_a2, ["children", "className", "variant", "isDisabled", "isCompact", "isSticky", "isStatic", "dropDirection", "toggleTemplate", "perPage", "titles", "firstPage", "page", "offset", "isLastFullPageShown", "itemsStart", "itemsEnd", "itemCount", "perPageOptions", "widgetId", "onSetPage", "onPerPageSelect", "onFirstClick", "onPreviousClick", "onNextClick", "onPageInput", "onLastClick", "ouiaId", "ouiaSafe", "usePageInsets", "inset"]);
  const paginationRef = React283.useRef(null);
  const containerRef = React283.useRef(null);
  const getLastPage = () => (
    // when itemCount is not known let's set lastPage as page+1 as we don't know the total count
    itemCount || itemCount === 0 ? Math.ceil(itemCount / perPage) || 0 : page + 1
  );
  React283.useEffect(() => {
    const node = paginationRef.current;
    handleInputWidth(getLastPage(), node);
  }, [perPage, itemCount]);
  const dropDirection = dropDirectionProp || (variant === "bottom" && !isStatic ? "up" : "down");
  let page = pageProp;
  if (offset3 !== null) {
    itemsStart = offset3 + 1;
    page = Math.max(Math.ceil(itemsStart / perPage), 1);
    itemsEnd = offset3 + perPage;
  }
  const lastPage = getLastPage();
  let firstIndex = (page - 1) * perPage + 1;
  let lastIndex = page * perPage;
  if (itemCount || itemCount === 0) {
    firstIndex = itemCount <= 0 ? 0 : (page - 1) * perPage + 1;
    if (page < firstPage && itemCount > 0) {
      page = firstPage;
    } else if (page > lastPage) {
      page = lastPage;
    }
    if (itemCount >= 0) {
      lastIndex = page === lastPage || itemCount === 0 ? itemCount : page * perPage;
    }
  }
  const PaginationToggleTemplateProps = {
    firstIndex,
    lastIndex,
    itemCount,
    itemsTitle: titles.items,
    ofWord: titles.ofWord
  };
  return React283.createElement(
    "div",
    Object.assign({ ref: paginationRef, className: css(pagination_default.pagination, variant === PaginationVariant.bottom && pagination_default.modifiers.bottom, usePageInsets && pagination_default.modifiers.pageInsets, formatBreakpointMods(inset, pagination_default), isStatic && pagination_default.modifiers.static, isSticky && pagination_default.modifiers.sticky, className) }, widgetId && { id: `${widgetId}-${variant}-pagination` }, useOUIAProps(Pagination.displayName, ouiaId, ouiaSafe, variant), props),
    variant === PaginationVariant.top && React283.createElement(
      "div",
      { className: css(pagination_default.paginationTotalItems) },
      toggleTemplate && typeof toggleTemplate === "string" && fillTemplate(toggleTemplate, PaginationToggleTemplateProps),
      toggleTemplate && typeof toggleTemplate !== "string" && toggleTemplate(PaginationToggleTemplateProps),
      !toggleTemplate && React283.createElement(ToggleTemplate, { firstIndex, lastIndex, itemCount, itemsTitle: titles.items, ofWord: titles.ofWord })
    ),
    perPageOptions && perPageOptions.length > 0 && React283.createElement(PaginationOptionsMenu, { itemsPerPageTitle: titles.itemsPerPage, perPageSuffix: titles.perPageSuffix, itemsTitle: isCompact ? "" : titles.items, optionsToggleAriaLabel: titles.optionsToggleAriaLabel, perPageOptions, firstIndex: itemsStart !== null ? itemsStart : firstIndex, lastIndex: itemsEnd !== null ? itemsEnd : lastIndex, ofWord: titles.ofWord, isLastFullPageShown, itemCount, page, perPage, lastPage, onPerPageSelect, dropDirection, widgetId: `${widgetId}-${variant}`, toggleTemplate, isDisabled, containerRef }),
    React283.createElement(Navigation, { pagesTitle: titles.page, pagesTitlePlural: titles.pages, toLastPageAriaLabel: titles.toLastPageAriaLabel, toPreviousPageAriaLabel: titles.toPreviousPageAriaLabel, toNextPageAriaLabel: titles.toNextPageAriaLabel, toFirstPageAriaLabel: titles.toFirstPageAriaLabel, currPageAriaLabel: titles.currPageAriaLabel, paginationAriaLabel: titles.paginationAriaLabel, ofWord: titles.ofWord, page: itemCount && itemCount <= 0 ? 0 : page, perPage, itemCount, firstPage: itemsStart !== null ? itemsStart : 1, lastPage, onSetPage, onFirstClick, onPreviousClick, onNextClick, onLastClick, onPageInput, isDisabled, isCompact }),
    children2
  );
};
Pagination.displayName = "Pagination";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ProgressStepper/ProgressStepper.js
var React284 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ProgressStepper/progress-stepper.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ProgressStepper/progress-stepper.css";
var progress_stepper_default = {
  "faExclamationTriangle": "fa-exclamation-triangle",
  "modifiers": {
    "center": "pf-m-center",
    "compact": "pf-m-compact",
    "current": "pf-m-current",
    "pending": "pf-m-pending",
    "success": "pf-m-success",
    "danger": "pf-m-danger",
    "warning": "pf-m-warning",
    "info": "pf-m-info",
    "custom": "pf-m-custom",
    "helpText": "pf-m-help-text",
    "horizontal": "pf-m-horizontal",
    "vertical": "pf-m-vertical",
    "horizontalOnSm": "pf-m-horizontal-on-sm",
    "verticalOnSm": "pf-m-vertical-on-sm",
    "horizontalOnMd": "pf-m-horizontal-on-md",
    "verticalOnMd": "pf-m-vertical-on-md",
    "horizontalOnLg": "pf-m-horizontal-on-lg",
    "verticalOnLg": "pf-m-vertical-on-lg",
    "horizontalOnXl": "pf-m-horizontal-on-xl",
    "verticalOnXl": "pf-m-vertical-on-xl",
    "horizontalOn_2xl": "pf-m-horizontal-on-2xl",
    "verticalOn_2xl": "pf-m-vertical-on-2xl"
  },
  "pficon": "pf-v6-pficon",
  "progressStepper": "pf-v6-c-progress-stepper",
  "progressStepperStep": "pf-v6-c-progress-stepper__step",
  "progressStepperStepConnector": "pf-v6-c-progress-stepper__step-connector",
  "progressStepperStepDescription": "pf-v6-c-progress-stepper__step-description",
  "progressStepperStepIcon": "pf-v6-c-progress-stepper__step-icon",
  "progressStepperStepMain": "pf-v6-c-progress-stepper__step-main",
  "progressStepperStepTitle": "pf-v6-c-progress-stepper__step-title"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ProgressStepper/ProgressStepper.js
var ProgressStepper = (_a2) => {
  var { children: children2, className, isCenterAligned, isVertical, isCompact, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["children", "className", "isCenterAligned", "isVertical", "isCompact", "aria-label"]);
  return React284.createElement("ol", Object.assign({ className: css(progress_stepper_default.progressStepper, isCenterAligned && progress_stepper_default.modifiers.center, isVertical && progress_stepper_default.modifiers.vertical, isCompact && progress_stepper_default.modifiers.compact, className), role: "list", "aria-label": ariaLabel }, props), children2);
};
ProgressStepper.displayName = "ProgressStepper";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ProgressStepper/ProgressStep.js
var React285 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/resources-full-icon.js
var ResourcesFullIconConfig = {
  name: "ResourcesFullIcon",
  height: 1024,
  width: 1024,
  svgPath: "M512.1,0 C229.7,0 0,229.8 0,512 C0,794.3 229.8,1024 512.1,1024 C794.4,1024 1024,794.3 1024,512 C1024,229.7 794.4,0 512.1,0 Z M512,896 C300.2,896 128,723.9 128,512 C128,300.3 300.2,128 512,128 C723.7,128 896,300.2 896,512 C896,723.8 723.7,896 512,896 Z M512,224 C671.1,224 800,352.9 800,512 C800,671.1 671.1,800 512,800 C352.9,800 224,671.1 224,512 C224,352.9 352.9,224 512,224",
  yOffset: 0,
  xOffset: 0
};
var ResourcesFullIcon = createIcon(ResourcesFullIconConfig);
var resources_full_icon_default = ResourcesFullIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ProgressStepper/ProgressStep.js
var ProgressStepVariant;
(function(ProgressStepVariant2) {
  ProgressStepVariant2["default"] = "default";
  ProgressStepVariant2["pending"] = "pending";
  ProgressStepVariant2["success"] = "success";
  ProgressStepVariant2["info"] = "info";
  ProgressStepVariant2["danger"] = "danger";
  ProgressStepVariant2["warning"] = "warning";
})(ProgressStepVariant || (ProgressStepVariant = {}));
var variantIcons3 = {
  default: void 0,
  pending: void 0,
  success: React285.createElement(check_circle_icon_default, null),
  info: React285.createElement(resources_full_icon_default, null),
  warning: React285.createElement(exclamation_triangle_icon_default, null),
  danger: React285.createElement(exclamation_circle_icon_default, null)
};
var variantStyle2 = {
  default: "",
  info: progress_stepper_default.modifiers.info,
  success: progress_stepper_default.modifiers.success,
  pending: progress_stepper_default.modifiers.pending,
  warning: progress_stepper_default.modifiers.warning,
  danger: progress_stepper_default.modifiers.danger
};
var ProgressStep = (_a2) => {
  var { children: children2, className, variant, isCurrent, description, icon, titleId, "aria-label": ariaLabel, popoverRender } = _a2, props = __rest(_a2, ["children", "className", "variant", "isCurrent", "description", "icon", "titleId", "aria-label", "popoverRender"]);
  const _icon = icon !== void 0 ? icon : variantIcons3[variant];
  const Component50 = popoverRender !== void 0 ? "button" : "div";
  const stepRef = React285.useRef();
  if (props.id === void 0 || titleId === void 0) {
    console.warn("ProgressStep: The titleId and id properties are required to make this component accessible, and one or both of these properties are missing.");
  }
  return React285.createElement(
    "li",
    Object.assign({
      className: css(progress_stepper_default.progressStepperStep, variantStyle2[variant], isCurrent && progress_stepper_default.modifiers.current, className),
      "aria-label": ariaLabel,
      // CSS style `display: contents` gives this li a generic role, we need to override that
      role: "listitem"
    }, isCurrent && { "aria-current": "step" }, props),
    React285.createElement(
      "div",
      { className: css(progress_stepper_default.progressStepperStepConnector) },
      React285.createElement("span", { className: css(progress_stepper_default.progressStepperStepIcon) }, _icon && _icon)
    ),
    React285.createElement(
      "div",
      { className: css(progress_stepper_default.progressStepperStepMain) },
      React285.createElement(
        Component50,
        Object.assign({ className: css(progress_stepper_default.progressStepperStepTitle, popoverRender && progress_stepper_default.modifiers.helpText), id: titleId, ref: stepRef }, popoverRender && { type: "button" }, props.id !== void 0 && titleId !== void 0 && popoverRender && { "aria-labelledby": `${props.id} ${titleId}` }),
        children2,
        popoverRender && popoverRender(stepRef)
      ),
      description && React285.createElement("div", { className: css(progress_stepper_default.progressStepperStepDescription) }, description)
    )
  );
};
ProgressStep.displayName = "ProgressStep";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Sidebar/Sidebar.js
var React286 = __toESM(require_react());
var SidebarBackgroundVariant;
(function(SidebarBackgroundVariant2) {
  SidebarBackgroundVariant2["default"] = "default";
  SidebarBackgroundVariant2["secondary"] = "secondary";
})(SidebarBackgroundVariant || (SidebarBackgroundVariant = {}));
var Sidebar = (_a2) => {
  var { className, children: children2, orientation, isPanelRight = false, hasGutter, hasNoBackground, hasBorder } = _a2, props = __rest(_a2, ["className", "children", "orientation", "isPanelRight", "hasGutter", "hasNoBackground", "hasBorder"]);
  return React286.createElement(
    "div",
    Object.assign({ className: css(sidebar_default.sidebar, hasGutter && sidebar_default.modifiers.gutter, hasNoBackground && sidebar_default.modifiers.noBackground, isPanelRight && sidebar_default.modifiers.panelRight, sidebar_default.modifiers[orientation], className) }, props),
    React286.createElement("div", { className: css(sidebar_default.sidebarMain, hasBorder && sidebar_default.modifiers.border) }, children2)
  );
};
Sidebar.displayName = "Sidebar";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Sidebar/SidebarContent.js
var React287 = __toESM(require_react());
var SidebarContent = (_a2) => {
  var { className, children: children2, hasNoBackground, hasPadding, backgroundVariant = "default" } = _a2, props = __rest(_a2, ["className", "children", "hasNoBackground", "hasPadding", "backgroundVariant"]);
  return React287.createElement("div", Object.assign({ className: css(sidebar_default.sidebarContent, hasNoBackground && sidebar_default.modifiers.noBackground, hasPadding && sidebar_default.modifiers.padding, backgroundVariant !== "default" && sidebar_default.modifiers[backgroundVariant], className) }, props), children2);
};
SidebarContent.displayName = "SidebarContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Sidebar/SidebarPanel.js
var React288 = __toESM(require_react());
var SidebarPanelWidthType;
(function(SidebarPanelWidthType2) {
  SidebarPanelWidthType2["default"] = "default";
  SidebarPanelWidthType2["width25"] = "width_25";
  SidebarPanelWidthType2["width33"] = "width_33";
  SidebarPanelWidthType2["width50"] = "width_50";
  SidebarPanelWidthType2["width66"] = "width_66";
  SidebarPanelWidthType2["width75"] = "width_75";
  SidebarPanelWidthType2["width100"] = "width_100";
})(SidebarPanelWidthType || (SidebarPanelWidthType = {}));
var SidebarPanel = (_a2) => {
  var { className, children: children2, variant = "default", hasNoBackground, hasPadding, width, backgroundVariant = "default" } = _a2, props = __rest(_a2, ["className", "children", "variant", "hasNoBackground", "hasPadding", "width", "backgroundVariant"]);
  return React288.createElement("div", Object.assign({ className: css(sidebar_default.sidebarPanel, variant !== "default" && sidebar_default.modifiers[variant], hasNoBackground && sidebar_default.modifiers.noBackground, hasPadding && sidebar_default.modifiers.padding, formatBreakpointMods(width, sidebar_default), backgroundVariant !== "default" && sidebar_default.modifiers[backgroundVariant], className) }, props), children2);
};
SidebarPanel.displayName = "SidebarPanel";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SimpleList/SimpleList.js
var React290 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/SimpleList/simple-list.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/SimpleList/simple-list.css";
var simple_list_default = {
  "modifiers": {
    "link": "pf-m-link",
    "current": "pf-m-current"
  },
  "simpleList": "pf-v6-c-simple-list",
  "simpleListItemLink": "pf-v6-c-simple-list__item-link",
  "simpleListSection": "pf-v6-c-simple-list__section",
  "simpleListTitle": "pf-v6-c-simple-list__title"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SimpleList/SimpleListGroup.js
var React289 = __toESM(require_react());
var SimpleListGroup = (_a2) => {
  var { children: children2 = null, className = "", title = "", titleClassName = "", id: id2 = "" } = _a2, props = __rest(_a2, ["children", "className", "title", "titleClassName", "id"]);
  return React289.createElement(
    "section",
    Object.assign({ className: css(simple_list_default.simpleListSection) }, props),
    React289.createElement("h2", { id: id2, className: css(simple_list_default.simpleListTitle, titleClassName), "aria-hidden": "true" }, title),
    React289.createElement("ul", { className: css("pf-v6-c-simple-list__list", className), role: "list", "aria-labelledby": id2 }, children2)
  );
};
SimpleListGroup.displayName = "SimpleListGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SimpleList/SimpleList.js
var SimpleListContext = React290.createContext({});
var SimpleList = class extends React290.Component {
  constructor() {
    super(...arguments);
    this.state = {
      currentRef: null
    };
    this.handleCurrentUpdate = (newCurrentRef, itemProps) => {
      this.setState({ currentRef: newCurrentRef });
      const { onSelect } = this.props;
      onSelect && onSelect(newCurrentRef, itemProps);
    };
  }
  render() {
    const _a2 = this.props, { children: children2, className, onSelect, isControlled, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["children", "className", "onSelect", "isControlled", "aria-label"]);
    let isGrouped = false;
    if (children2) {
      isGrouped = React290.Children.toArray(children2)[0].type === SimpleListGroup;
    }
    return React290.createElement(
      SimpleListContext.Provider,
      { value: {
        currentRef: this.state.currentRef,
        updateCurrentRef: this.handleCurrentUpdate,
        isControlled
      } },
      React290.createElement(
        "div",
        Object.assign({ className: css(simple_list_default.simpleList, className) }, props),
        isGrouped && children2,
        !isGrouped && React290.createElement("ul", { className: css("pf-v6-c-simple-list__list"), role: "list", "aria-label": ariaLabel }, children2)
      )
    );
  }
};
SimpleList.displayName = "SimpleList";
SimpleList.defaultProps = {
  children: null,
  className: "",
  isControlled: true
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SimpleList/SimpleListItem.js
var React291 = __toESM(require_react());
var SimpleListItem = class extends React291.Component {
  constructor() {
    super(...arguments);
    this.ref = React291.createRef();
  }
  render() {
    const _a2 = this.props, {
      children: children2,
      isActive,
      className,
      component: Component50,
      componentClassName,
      componentProps,
      onClick,
      type: type2,
      href,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      itemId
    } = _a2, props = __rest(_a2, ["children", "isActive", "className", "component", "componentClassName", "componentProps", "onClick", "type", "href", "itemId"]);
    return React291.createElement(SimpleListContext.Consumer, null, ({ currentRef, updateCurrentRef, isControlled }) => {
      const isButton = Component50 === "button";
      const isCurrentItem = this.ref && currentRef && isControlled ? currentRef.current === this.ref.current : isActive;
      const additionalComponentProps = isButton ? {
        type: type2
      } : {
        tabIndex: 0,
        href
      };
      return React291.createElement(
        "li",
        Object.assign({ className: css("pf-v6-c-simple-list__item", className) }, props),
        React291.createElement(Component50, Object.assign({ className: css(simple_list_default.simpleListItemLink, isCurrentItem && simple_list_default.modifiers.current, !isButton && simple_list_default.modifiers.link, componentClassName), onClick: (evt) => {
          onClick(evt);
          updateCurrentRef(this.ref, this.props);
        }, ref: this.ref }, componentProps, additionalComponentProps), children2)
      );
    });
  }
};
SimpleListItem.displayName = "SimpleListItem";
SimpleListItem.defaultProps = {
  children: null,
  className: "",
  isActive: false,
  component: "button",
  componentClassName: "",
  type: "button",
  href: "",
  onClick: () => {
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Skeleton/Skeleton.js
var React292 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Skeleton/skeleton.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Skeleton/skeleton.css";
var skeleton_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "circle": "pf-m-circle",
    "square": "pf-m-square",
    "widthSm": "pf-m-width-sm",
    "widthMd": "pf-m-width-md",
    "widthLg": "pf-m-width-lg",
    "width_25": "pf-m-width-25",
    "width_33": "pf-m-width-33",
    "width_50": "pf-m-width-50",
    "width_66": "pf-m-width-66",
    "width_75": "pf-m-width-75",
    "heightSm": "pf-m-height-sm",
    "heightMd": "pf-m-height-md",
    "heightLg": "pf-m-height-lg",
    "height_25": "pf-m-height-25",
    "height_33": "pf-m-height-33",
    "height_50": "pf-m-height-50",
    "height_66": "pf-m-height-66",
    "height_75": "pf-m-height-75",
    "height_100": "pf-m-height-100",
    "text_4xl": "pf-m-text-4xl",
    "text_3xl": "pf-m-text-3xl",
    "text_2xl": "pf-m-text-2xl",
    "textXl": "pf-m-text-xl",
    "textLg": "pf-m-text-lg",
    "textMd": "pf-m-text-md",
    "textSm": "pf-m-text-sm"
  },
  "skeleton": "pf-v6-c-skeleton"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Skeleton/Skeleton.js
var Skeleton = (_a2) => {
  var { className, width, height, fontSize, shape, screenreaderText } = _a2, props = __rest(_a2, ["className", "width", "height", "fontSize", "shape", "screenreaderText"]);
  const fontHeightClassName = fontSize ? Object.values(skeleton_default.modifiers).find((key) => key === `pf-m-text-${fontSize}`) : void 0;
  return React292.createElement(
    "div",
    Object.assign({}, props, { className: css(skeleton_default.skeleton, fontSize && fontHeightClassName, shape === "circle" && skeleton_default.modifiers.circle, shape === "square" && skeleton_default.modifiers.square, className) }, (width || height) && {
      style: Object.assign({ [c_skeleton_Width_default.name]: width ? width : void 0, [c_skeleton_Height_default.name]: height ? height : void 0 }, props.style)
    }),
    React292.createElement("span", { className: "pf-v6-screen-reader" }, screenreaderText)
  );
};
Skeleton.displayName = "Skeleton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SkipToContent/SkipToContent.js
var React293 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/SkipToContent/skip-to-content.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/SkipToContent/skip-to-content.css";
var skip_to_content_default = {
  "skipToContent": "pf-v6-c-skip-to-content"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/SkipToContent/SkipToContent.js
var SkipToContent = (_a2) => {
  var { children: children2 = null, className = "", href } = _a2, props = __rest(_a2, ["children", "className", "href"]);
  return React293.createElement(
    "div",
    Object.assign({ className: css(skip_to_content_default.skipToContent, className) }, props),
    React293.createElement(Button, { variant: ButtonVariant.primary, component: "a", href }, children2)
  );
};
SkipToContent.displayName = "SkipToContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Slider/Slider.js
var React295 = __toESM(require_react());
var import_react23 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Slider/slider.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Slider/slider.css";
var slider_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "formControl": "pf-v6-c-form-control",
  "modifiers": {
    "disabled": "pf-m-disabled",
    "active": "pf-m-active",
    "floating": "pf-m-floating"
  },
  "slider": "pf-v6-c-slider",
  "sliderActions": "pf-v6-c-slider__actions",
  "sliderMain": "pf-v6-c-slider__main",
  "sliderRail": "pf-v6-c-slider__rail",
  "sliderRailTrack": "pf-v6-c-slider__rail-track",
  "sliderStep": "pf-v6-c-slider__step",
  "sliderStepLabel": "pf-v6-c-slider__step-label",
  "sliderStepTick": "pf-v6-c-slider__step-tick",
  "sliderSteps": "pf-v6-c-slider__steps",
  "sliderThumb": "pf-v6-c-slider__thumb",
  "sliderValue": "pf-v6-c-slider__value"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Slider/SliderStep.js
var React294 = __toESM(require_react());
var SliderStep = (_a2) => {
  var { className, label, value, isTickHidden = false, isLabelHidden = false, isActive = false } = _a2, props = __rest(_a2, ["className", "label", "value", "isTickHidden", "isLabelHidden", "isActive"]);
  const style = {
    [c_slider_step_InsetInlineStart_default.name]: `${value ? value : c_slider_step_InsetInlineStart_default.value}%`
  };
  return React294.createElement(
    "div",
    Object.assign({ className: css(slider_default.sliderStep, isActive && slider_default.modifiers.active, className), style }, props),
    !isTickHidden && React294.createElement("div", { className: css(slider_default.sliderStepTick) }),
    !isLabelHidden && label && React294.createElement("div", { className: css(slider_default.sliderStepLabel) }, label)
  );
};
SliderStep.displayName = "SliderStep";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Slider/Slider.js
var getPercentage = (current, max5) => 100 * current / max5;
var Slider = (_a2) => {
  var { className, value = 0, customSteps, areCustomStepsContinuous = false, isDisabled = false, isInputVisible = false, inputValue = 0, inputLabel, inputAriaLabel = "Slider value input", thumbAriaLabel = "Value", hasTooltipOverThumb = false, inputPosition = "end", onChange, leftActions, startActions, rightActions, endActions, step = 1, min: min4 = 0, max: max5 = 100, showTicks = false, showBoundaries = true, "aria-describedby": ariaDescribedby, "aria-labelledby": ariaLabelledby } = _a2, props = __rest(_a2, ["className", "value", "customSteps", "areCustomStepsContinuous", "isDisabled", "isInputVisible", "inputValue", "inputLabel", "inputAriaLabel", "thumbAriaLabel", "hasTooltipOverThumb", "inputPosition", "onChange", "leftActions", "startActions", "rightActions", "endActions", "step", "min", "max", "showTicks", "showBoundaries", "aria-describedby", "aria-labelledby"]);
  const sliderRailRef = React295.useRef();
  const thumbRef = React295.useRef();
  const [localValue, setValue] = (0, import_react23.useState)(value);
  const [localInputValue, setLocalInputValue] = (0, import_react23.useState)(inputValue);
  let isRTL;
  React295.useEffect(() => {
    isRTL = getLanguageDirection(sliderRailRef.current) === "rtl";
  });
  React295.useEffect(() => {
    setValue(value);
  }, [value]);
  React295.useEffect(() => {
    setLocalInputValue(inputValue);
  }, [inputValue]);
  let diff = 0;
  let snapValue;
  const stylePercent = (localValue - min4) * 100 / (max5 - min4);
  const style = { [c_slider_value_default.name]: `${stylePercent}%` };
  const widthChars = React295.useMemo(() => localInputValue.toString().length, [localInputValue]);
  const inputStyle = { [c_slider_value_c_form_control_width_chars_default.name]: widthChars };
  const onChangeHandler = (_event, value2) => {
    setLocalInputValue(Number(value2));
  };
  const handleKeyPressOnInput = (event) => {
    if (event.key === "Enter") {
      event.preventDefault();
      if (onChange) {
        onChange(event, localValue, localInputValue, setLocalInputValue);
      }
    }
  };
  const onInputFocus = (e) => {
    e.stopPropagation();
  };
  const onThumbClick = () => {
    thumbRef.current.focus();
  };
  const onBlur = (event) => {
    if (onChange) {
      onChange(event, localValue, localInputValue, setLocalInputValue);
    }
  };
  const findAriaTextValue = () => {
    if (!areCustomStepsContinuous && customSteps) {
      const matchingStep = customSteps.find((stepObj) => stepObj.value === localValue);
      if (matchingStep) {
        return matchingStep.label;
      }
    }
    return Number(Number(localValue).toFixed(2)).toString();
  };
  const handleThumbDragEnd = () => {
    document.removeEventListener("mousemove", callbackThumbMove);
    document.removeEventListener("mouseup", callbackThumbUp);
    document.removeEventListener("touchmove", callbackThumbMove);
    document.removeEventListener("touchend", callbackThumbUp);
    document.removeEventListener("touchcancel", callbackThumbUp);
  };
  const handleMouseDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    if (isRTL) {
      diff = thumbRef.current.getBoundingClientRect().right - e.clientX;
    } else {
      diff = e.clientX - thumbRef.current.getBoundingClientRect().left;
    }
    document.addEventListener("mousemove", callbackThumbMove);
    document.addEventListener("mouseup", callbackThumbUp);
  };
  const handleTouchStart = (e) => {
    e.stopPropagation();
    if (isRTL) {
      diff = thumbRef.current.getBoundingClientRect().right - e.touches[0].clientX;
    } else {
      diff = e.touches[0].clientX - thumbRef.current.getBoundingClientRect().left;
    }
    document.addEventListener("touchmove", callbackThumbMove, { passive: false });
    document.addEventListener("touchend", callbackThumbUp);
    document.addEventListener("touchcancel", callbackThumbUp);
  };
  const onSliderRailClick = (e) => {
    handleThumbMove(e);
    if (snapValue && !areCustomStepsContinuous) {
      thumbRef.current.style.setProperty(c_slider_value_default.name, `${snapValue}%`);
      setValue(snapValue);
      if (onChange) {
        onChange(e, snapValue);
      }
    }
  };
  const handleThumbMove = (e) => {
    if (e.type === "touchmove") {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
    const clientPosition = e.touches && e.touches.length ? e.touches[0].clientX : e.clientX;
    let newPosition;
    if (isRTL) {
      newPosition = sliderRailRef.current.getBoundingClientRect().right - clientPosition - diff;
    } else {
      newPosition = clientPosition - diff - sliderRailRef.current.getBoundingClientRect().left;
    }
    const end2 = sliderRailRef.current.offsetWidth - thumbRef.current.offsetWidth;
    const start3 = 0;
    if (newPosition < start3) {
      newPosition = 0;
    }
    if (newPosition > end2) {
      newPosition = end2;
    }
    const newPercentage = getPercentage(newPosition, end2);
    thumbRef.current.style.setProperty(c_slider_value_default.name, `${newPercentage}%`);
    const newValue = Math.round((newPercentage * (max5 - min4) / 100 + min4) * 100) / 100;
    setValue(newValue);
    if (!customSteps) {
      snapValue = Math.round((Math.round((newValue - min4) / step) * step + min4) * 100) / 100;
      thumbRef.current.style.setProperty(c_slider_value_default.name, `${snapValue}%`);
      setValue(snapValue);
    }
    if (!areCustomStepsContinuous && customSteps) {
      let percentage = newPercentage;
      if (customSteps[customSteps.length - 1].value !== 100) {
        percentage = newPercentage * (max5 - min4) / 100 + min4;
      }
      const stepIndex = customSteps.findIndex((stepObj) => stepObj.value >= percentage);
      if (customSteps[stepIndex].value === percentage) {
        snapValue = customSteps[stepIndex].value;
      } else {
        const midpoint = (customSteps[stepIndex].value + customSteps[stepIndex - 1].value) / 2;
        if (midpoint > percentage) {
          snapValue = customSteps[stepIndex - 1].value;
        } else {
          snapValue = customSteps[stepIndex].value;
        }
      }
      setValue(snapValue);
    }
    if (onChange) {
      if (snapValue !== void 0) {
        onChange(e, snapValue);
      } else {
        onChange(e, newValue);
      }
    }
  };
  const callbackThumbMove = React295.useCallback(handleThumbMove, [min4, max5, customSteps, onChange]);
  const callbackThumbUp = React295.useCallback(handleThumbDragEnd, [min4, max5, customSteps, onChange]);
  const handleThumbKeys = (e) => {
    const key = e.key;
    if (key !== "ArrowLeft" && key !== "ArrowRight") {
      return;
    }
    e.preventDefault();
    let newValue = localValue;
    if (!areCustomStepsContinuous && customSteps) {
      const stepIndex = customSteps.findIndex((stepObj) => stepObj.value === localValue);
      if (key === "ArrowRight") {
        if (isRTL) {
          if (stepIndex - 1 >= 0) {
            newValue = customSteps[stepIndex - 1].value;
          }
        } else {
          if (stepIndex + 1 < customSteps.length) {
            {
              newValue = customSteps[stepIndex + 1].value;
            }
          }
        }
      } else if (key === "ArrowLeft") {
        if (isRTL) {
          if (stepIndex + 1 < customSteps.length) {
            {
              newValue = customSteps[stepIndex + 1].value;
            }
          }
        } else {
          if (stepIndex - 1 >= 0) {
            newValue = customSteps[stepIndex - 1].value;
          }
        }
      }
    } else {
      if (key === "ArrowRight") {
        if (isRTL) {
          newValue = localValue - step >= min4 ? localValue - step : min4;
        } else {
          newValue = localValue + step <= max5 ? localValue + step : max5;
        }
      } else if (key === "ArrowLeft") {
        if (isRTL) {
          newValue = localValue + step <= max5 ? localValue + step : max5;
        } else {
          newValue = localValue - step >= min4 ? localValue - step : min4;
        }
      }
    }
    if (newValue !== localValue) {
      thumbRef.current.style.setProperty(c_slider_value_default.name, `${newValue}%`);
      setValue(newValue);
      if (onChange) {
        onChange(e, newValue);
      }
    }
  };
  const displayInput = () => {
    const textInput = React295.createElement(TextInput, { isDisabled, type: "number", value: localInputValue, "aria-label": inputAriaLabel, onKeyDown: handleKeyPressOnInput, onChange: onChangeHandler, onClick: onInputFocus, onFocus: onInputFocus, onBlur });
    if (inputLabel) {
      return React295.createElement(
        InputGroup,
        null,
        React295.createElement(InputGroupItem, { isFill: true }, textInput),
        React295.createElement(InputGroupText, { isDisabled }, inputLabel)
      );
    } else {
      return textInput;
    }
  };
  const getStepValue = (val, min5, max6) => (val - min5) * 100 / (max6 - min5);
  const buildSteps2 = () => {
    const builtSteps = [];
    for (let i = min4; i <= max5; i = i + step) {
      const stepValue = getStepValue(i, min4, max5);
      if (!showTicks && showBoundaries && i !== min4 && i !== max5) {
        continue;
      }
      builtSteps.push(React295.createElement(SliderStep, { key: i, value: stepValue, label: i.toString(), isTickHidden: !showTicks, isLabelHidden: (i === min4 || i === max5) && showBoundaries ? false : true, isActive: i <= localValue }));
    }
    return builtSteps;
  };
  const thumbComponent = React295.createElement("div", { className: css(slider_default.sliderThumb), ref: thumbRef, tabIndex: isDisabled ? -1 : 0, role: "slider", "aria-valuemin": customSteps ? customSteps[0].value : min4, "aria-valuemax": customSteps ? customSteps[customSteps.length - 1].value : max5, "aria-valuenow": localValue, "aria-valuetext": findAriaTextValue(), "aria-label": thumbAriaLabel, "aria-disabled": isDisabled, "aria-describedby": ariaDescribedby, "aria-labelledby": ariaLabelledby, onMouseDown: !isDisabled ? handleMouseDown : null, onTouchStart: !isDisabled ? handleTouchStart : null, onKeyDown: !isDisabled ? handleThumbKeys : null, onClick: !isDisabled ? onThumbClick : null });
  return React295.createElement(
    "div",
    Object.assign({ className: css(slider_default.slider, className, isDisabled && slider_default.modifiers.disabled), style: Object.assign(Object.assign({}, style), inputStyle) }, props),
    (leftActions || startActions) && React295.createElement("div", { className: css(slider_default.sliderActions) }, leftActions || startActions),
    React295.createElement(
      "div",
      { className: css(slider_default.sliderMain) },
      React295.createElement(
        "div",
        { className: css(slider_default.sliderRail), ref: sliderRailRef, onClick: !isDisabled ? onSliderRailClick : null },
        React295.createElement("div", { className: css(slider_default.sliderRailTrack) })
      ),
      customSteps && React295.createElement("div", { className: css(slider_default.sliderSteps), "aria-hidden": "true" }, customSteps.map((stepObj) => {
        const minValue = customSteps[0].value;
        const maxValue = customSteps[customSteps.length - 1].value;
        const stepValue = getStepValue(stepObj.value, minValue, maxValue);
        return React295.createElement(SliderStep, { key: stepObj.value, value: stepValue, label: stepObj.label, isLabelHidden: stepObj.isLabelHidden, isActive: stepObj.value <= localValue });
      })),
      !customSteps && (showTicks || showBoundaries) && React295.createElement("div", { className: css(slider_default.sliderSteps), "aria-hidden": "true" }, buildSteps2()),
      hasTooltipOverThumb ? React295.createElement(Tooltip, { triggerRef: thumbRef, entryDelay: 0, content: findAriaTextValue() }, thumbComponent) : thumbComponent,
      isInputVisible && inputPosition === "aboveThumb" && React295.createElement("div", { className: css(slider_default.sliderValue, slider_default.modifiers.floating) }, displayInput())
    ),
    isInputVisible && (inputPosition === "right" || inputPosition === "end") && React295.createElement("div", { className: css(slider_default.sliderValue) }, displayInput()),
    (rightActions || endActions) && React295.createElement("div", { className: css(slider_default.sliderActions) }, rightActions || endActions)
  );
};
Slider.displayName = "Slider";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Switch/Switch.js
var React296 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Switch/switch.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Switch/switch.css";
var switch_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "reverse": "pf-m-reverse"
  },
  "switch": "pf-v6-c-switch",
  "switchInput": "pf-v6-c-switch__input",
  "switchLabel": "pf-v6-c-switch__label",
  "switchToggle": "pf-v6-c-switch__toggle",
  "switchToggleIcon": "pf-v6-c-switch__toggle-icon"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Switch/Switch.js
var Switch = class _Switch extends React296.Component {
  constructor(props) {
    super(props);
    if (!props.label && !props["aria-label"]) {
      console.error("Switch: Switch requires either a label or an aria-label to be specified");
    }
    this.id = props.id || getUniqueId();
    this.state = {
      ouiaStateId: getDefaultOUIAId(_Switch.displayName)
    };
  }
  render() {
    const _a2 = this.props, {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      id: id2,
      className,
      label,
      labelOff,
      isChecked,
      defaultChecked,
      hasCheckIcon,
      isDisabled,
      onChange,
      isReversed,
      ouiaId,
      ouiaSafe
    } = _a2, props = __rest(_a2, ["id", "className", "label", "labelOff", "isChecked", "defaultChecked", "hasCheckIcon", "isDisabled", "onChange", "isReversed", "ouiaId", "ouiaSafe"]);
    const isAriaLabelledBy = props["aria-label"] === "";
    return React296.createElement(
      "label",
      Object.assign({ className: css(switch_default.switch, isReversed && switch_default.modifiers.reverse, className), htmlFor: this.id }, getOUIAProps(_Switch.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe)),
      React296.createElement("input", Object.assign({ id: this.id, className: css(switch_default.switchInput), type: "checkbox", onChange: (event) => onChange(event, event.target.checked) }, defaultChecked !== void 0 ? { defaultChecked } : { checked: isChecked }, { disabled: isDisabled, "aria-labelledby": !isAriaLabelledBy ? null : `${this.id}-${isChecked !== true ? "off" : "on"}` }, props)),
      label !== void 0 ? React296.createElement(
        React296.Fragment,
        null,
        React296.createElement("span", { className: css(switch_default.switchToggle) }, hasCheckIcon && React296.createElement(
          "span",
          { className: css(switch_default.switchToggleIcon), "aria-hidden": "true" },
          React296.createElement(check_icon_default, null)
        )),
        React296.createElement("span", { className: css(switch_default.switchLabel, switch_default.modifiers.on), id: isAriaLabelledBy ? `${this.id}-on` : null, "aria-hidden": "true" }, label),
        React296.createElement("span", { className: css(switch_default.switchLabel, switch_default.modifiers.off), id: isAriaLabelledBy ? `${this.id}-off` : null, "aria-hidden": "true" }, labelOff !== void 0 ? labelOff : label)
      ) : React296.createElement(
        "span",
        { className: css(switch_default.switchToggle) },
        React296.createElement(
          "div",
          { className: css(switch_default.switchToggleIcon), "aria-hidden": "true" },
          React296.createElement(check_icon_default, null)
        )
      )
    );
  }
};
Switch.displayName = "Switch";
Switch.defaultProps = {
  isChecked: true,
  isDisabled: false,
  isReversed: false,
  "aria-label": "",
  onChange: () => void 0
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/Tab.js
var React300 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Tabs/tabs.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Tabs/tabs.css";
var tabs_default = {
  "button": "pf-v6-c-button",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "fill": "pf-m-fill",
    "scrollable": "pf-m-scrollable",
    "noBorderBottom": "pf-m-no-border-bottom",
    "box": "pf-m-box",
    "vertical": "pf-m-vertical",
    "current": "pf-m-current",
    "secondary": "pf-m-secondary",
    "expandable": "pf-m-expandable",
    "nonExpandable": "pf-m-non-expandable",
    "expandableOnSm": "pf-m-expandable-on-sm",
    "nonExpandableOnSm": "pf-m-non-expandable-on-sm",
    "expandableOnMd": "pf-m-expandable-on-md",
    "nonExpandableOnMd": "pf-m-non-expandable-on-md",
    "expandableOnLg": "pf-m-expandable-on-lg",
    "nonExpandableOnLg": "pf-m-non-expandable-on-lg",
    "expandableOnXl": "pf-m-expandable-on-xl",
    "nonExpandableOnXl": "pf-m-non-expandable-on-xl",
    "expandableOn_2xl": "pf-m-expandable-on-2xl",
    "nonExpandableOn_2xl": "pf-m-non-expandable-on-2xl",
    "expanded": "pf-m-expanded",
    "subtab": "pf-m-subtab",
    "pageInsets": "pf-m-page-insets",
    "overflow": "pf-m-overflow",
    "action": "pf-m-action",
    "disabled": "pf-m-disabled",
    "ariaDisabled": "pf-m-aria-disabled",
    "insetNone": "pf-m-inset-none",
    "insetSm": "pf-m-inset-sm",
    "insetMd": "pf-m-inset-md",
    "insetLg": "pf-m-inset-lg",
    "insetXl": "pf-m-inset-xl",
    "inset_2xl": "pf-m-inset-2xl",
    "insetNoneOnSm": "pf-m-inset-none-on-sm",
    "insetSmOnSm": "pf-m-inset-sm-on-sm",
    "insetMdOnSm": "pf-m-inset-md-on-sm",
    "insetLgOnSm": "pf-m-inset-lg-on-sm",
    "insetXlOnSm": "pf-m-inset-xl-on-sm",
    "inset_2xlOnSm": "pf-m-inset-2xl-on-sm",
    "insetNoneOnMd": "pf-m-inset-none-on-md",
    "insetSmOnMd": "pf-m-inset-sm-on-md",
    "insetMdOnMd": "pf-m-inset-md-on-md",
    "insetLgOnMd": "pf-m-inset-lg-on-md",
    "insetXlOnMd": "pf-m-inset-xl-on-md",
    "inset_2xlOnMd": "pf-m-inset-2xl-on-md",
    "insetNoneOnLg": "pf-m-inset-none-on-lg",
    "insetSmOnLg": "pf-m-inset-sm-on-lg",
    "insetMdOnLg": "pf-m-inset-md-on-lg",
    "insetLgOnLg": "pf-m-inset-lg-on-lg",
    "insetXlOnLg": "pf-m-inset-xl-on-lg",
    "inset_2xlOnLg": "pf-m-inset-2xl-on-lg",
    "insetNoneOnXl": "pf-m-inset-none-on-xl",
    "insetSmOnXl": "pf-m-inset-sm-on-xl",
    "insetMdOnXl": "pf-m-inset-md-on-xl",
    "insetLgOnXl": "pf-m-inset-lg-on-xl",
    "insetXlOnXl": "pf-m-inset-xl-on-xl",
    "inset_2xlOnXl": "pf-m-inset-2xl-on-xl",
    "insetNoneOn_2xl": "pf-m-inset-none-on-2xl",
    "insetSmOn_2xl": "pf-m-inset-sm-on-2xl",
    "insetMdOn_2xl": "pf-m-inset-md-on-2xl",
    "insetLgOn_2xl": "pf-m-inset-lg-on-2xl",
    "insetXlOn_2xl": "pf-m-inset-xl-on-2xl",
    "inset_2xlOn_2xl": "pf-m-inset-2xl-on-2xl"
  },
  "tabs": "pf-v6-c-tabs",
  "tabsAdd": "pf-v6-c-tabs__add",
  "tabsItem": "pf-v6-c-tabs__item",
  "tabsItemAction": "pf-v6-c-tabs__item-action",
  "tabsItemActionIcon": "pf-v6-c-tabs__item-action-icon",
  "tabsItemText": "pf-v6-c-tabs__item-text",
  "tabsLink": "pf-v6-c-tabs__link",
  "tabsLinkToggleIcon": "pf-v6-c-tabs__link-toggle-icon",
  "tabsList": "pf-v6-c-tabs__list",
  "tabsScrollButton": "pf-v6-c-tabs__scroll-button",
  "tabsToggle": "pf-v6-c-tabs__toggle",
  "tabsToggleButton": "pf-v6-c-tabs__toggle-button",
  "tabsToggleIcon": "pf-v6-c-tabs__toggle-icon"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/TabButton.js
var React297 = __toESM(require_react());
var TabButton = (_a2) => {
  var {
    children: children2,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    tabContentRef,
    ouiaId,
    parentInnerRef,
    ouiaSafe
  } = _a2, props = __rest(_a2, ["children", "tabContentRef", "ouiaId", "parentInnerRef", "ouiaSafe"]);
  const Component50 = props.href ? "a" : "button";
  return React297.createElement(Component50, Object.assign({}, !props.href && { type: "button" }, { ref: parentInnerRef }, getOUIAProps(TabButton.displayName, ouiaId, ouiaSafe), props), children2);
};
TabButton.displayName = "TabButton";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/TabsContext.js
var React298 = __toESM(require_react());
var TabsContext = React298.createContext({
  variant: "default",
  mountOnEnter: false,
  unmountOnExit: false,
  localActiveKey: "",
  uniqueId: "",
  handleTabClick: () => null,
  handleTabClose: void 0
});
var TabsContextProvider = TabsContext.Provider;
var TabsContextConsumer = TabsContext.Consumer;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/TabAction.js
var React299 = __toESM(require_react());
var TabActionBase = (_a2) => {
  var {
    children: children2,
    className,
    onClick,
    isDisabled,
    "aria-label": ariaLabel = "Tab action",
    innerRef,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ouiaId,
    ouiaSafe
  } = _a2, props = __rest(_a2, ["children", "className", "onClick", "isDisabled", "aria-label", "innerRef", "ouiaId", "ouiaSafe"]);
  return React299.createElement(
    "span",
    { className: css(tabs_default.tabsItemAction, className) },
    React299.createElement(
      Button,
      Object.assign({ ref: innerRef, type: "button", variant: "plain", "aria-label": ariaLabel, onClick, isDisabled }, getOUIAProps(TabAction.displayName, ouiaId, ouiaSafe), props),
      React299.createElement("span", { className: css(tabs_default.tabsItemActionIcon) }, children2)
    )
  );
};
var TabAction = React299.forwardRef((props, ref) => React299.createElement(TabActionBase, Object.assign({}, props, { innerRef: ref })));
TabAction.displayName = "TabAction";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/Tab.js
var TabBase = (_a2) => {
  var { title, eventKey, tabContentRef, id: childId, tabContentId, className: childClassName = "", ouiaId: childOuiaId, isDisabled, isAriaDisabled, inoperableEvents = ["onClick", "onKeyPress"], href, innerRef, tooltip, closeButtonAriaLabel, isCloseDisabled = false, actions } = _a2, props = __rest(_a2, ["title", "eventKey", "tabContentRef", "id", "tabContentId", "className", "ouiaId", "isDisabled", "isAriaDisabled", "inoperableEvents", "href", "innerRef", "tooltip", "closeButtonAriaLabel", "isCloseDisabled", "actions"]);
  const preventedEvents = inoperableEvents.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), { [eventToPrevent]: (event) => {
    event.preventDefault();
  } }), {});
  const { mountOnEnter, localActiveKey, unmountOnExit, uniqueId, handleTabClick, handleTabClose } = React300.useContext(TabsContext);
  let ariaControls = tabContentId ? `${tabContentId}` : `pf-tab-section-${eventKey}-${childId || uniqueId}`;
  if ((mountOnEnter || unmountOnExit) && eventKey !== localActiveKey) {
    ariaControls = void 0;
  }
  const isButtonElement = Boolean(!href);
  const getDefaultTabIdx = () => {
    if (isDisabled) {
      return isButtonElement ? null : -1;
    } else if (isAriaDisabled) {
      return null;
    }
  };
  const tabButton = React300.createElement(TabButton, Object.assign({ parentInnerRef: innerRef, className: css(tabs_default.tabsLink, isDisabled && href && tabs_default.modifiers.disabled, isAriaDisabled && tabs_default.modifiers.ariaDisabled), disabled: isButtonElement ? isDisabled : null, "aria-disabled": isDisabled || isAriaDisabled, tabIndex: getDefaultTabIdx(), onClick: (event) => handleTabClick(event, eventKey, tabContentRef) }, isAriaDisabled ? preventedEvents : null, { id: `pf-tab-${eventKey}-${childId || uniqueId}`, "aria-controls": ariaControls, tabContentRef, ouiaId: childOuiaId, href, role: "tab", "aria-selected": eventKey === localActiveKey }, props), title);
  return React300.createElement(
    "li",
    { className: css(tabs_default.tabsItem, eventKey === localActiveKey && tabs_default.modifiers.current, (handleTabClose || actions) && tabs_default.modifiers.action, (isDisabled || isAriaDisabled) && tabs_default.modifiers.disabled, childClassName), role: "presentation" },
    tooltip ? React300.createElement(Tooltip, Object.assign({}, tooltip.props), tabButton) : tabButton,
    actions && actions,
    handleTabClose !== void 0 && React300.createElement(
      TabAction,
      { "aria-label": closeButtonAriaLabel || "Close tab", onClick: (event) => handleTabClose(event, eventKey, tabContentRef), isDisabled: isCloseDisabled },
      React300.createElement(times_icon_default, null)
    )
  );
};
var Tab = React300.forwardRef((props, ref) => React300.createElement(TabBase, Object.assign({ innerRef: ref }, props)));
Tab.displayName = "Tab";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/Tabs.js
var React304 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/plus-icon.js
var PlusIconConfig = {
  name: "PlusIcon",
  height: 512,
  width: 448,
  svgPath: "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
  yOffset: 0,
  xOffset: 0
};
var PlusIcon = createIcon(PlusIconConfig);
var plus_icon_default = PlusIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/TabContent.js
var React301 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/TabContent/tab-content.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/TabContent/tab-content.css";
var tab_content_default = {
  "modifiers": {
    "secondary": "pf-m-secondary",
    "padding": "pf-m-padding"
  },
  "tabContent": "pf-v6-c-tab-content",
  "tabContentBody": "pf-v6-c-tab-content__body"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/TabContent.js
var variantStyle3 = {
  default: "",
  secondary: tab_content_default.modifiers.secondary
};
var TabContentBase = (_a2) => {
  var {
    id: id2,
    activeKey,
    "aria-label": ariaLabel,
    child,
    children: children2,
    className,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    eventKey,
    innerRef,
    ouiaId,
    ouiaSafe
  } = _a2, props = __rest(_a2, ["id", "activeKey", "aria-label", "child", "children", "className", "eventKey", "innerRef", "ouiaId", "ouiaSafe"]);
  if (children2 || child) {
    let labelledBy;
    if (ariaLabel) {
      labelledBy = null;
    } else {
      labelledBy = children2 ? `${id2}` : `pf-tab-${child.props.eventKey}-${id2}`;
    }
    return React301.createElement(TabsContextConsumer, null, ({ variant }) => {
      const variantClass = variantStyle3[variant];
      return React301.createElement("section", Object.assign({ ref: innerRef, hidden: children2 ? null : child.props.eventKey !== activeKey, className: children2 ? css(tab_content_default.tabContent, className, variantClass) : css(tab_content_default.tabContent, child.props.className, variantClass), id: children2 ? id2 : `pf-tab-section-${child.props.eventKey}-${id2}`, "aria-label": ariaLabel, "aria-labelledby": labelledBy, role: "tabpanel", tabIndex: 0 }, getOUIAProps("TabContent", ouiaId, ouiaSafe), props), children2 || child.props.children);
    });
  }
  return null;
};
var TabContent = React301.forwardRef((props, ref) => React301.createElement(TabContentBase, Object.assign({}, props, { innerRef: ref })));

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/OverflowTab.js
var import_react24 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/TabTitleText.js
var React302 = __toESM(require_react());
var TabTitleText = (_a2) => {
  var { children: children2, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React302.createElement("span", Object.assign({ className: css(tabs_default.tabsItemText, className) }, props), children2);
};
TabTitleText.displayName = "TabTitleText";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/OverflowTab.js
var OverflowTab = (_a2) => {
  var { className, overflowingTabs = [], showTabCount, defaultTitleText = "More", toggleAriaLabel, zIndex = 9999 } = _a2, props = __rest(_a2, ["className", "overflowingTabs", "showTabCount", "defaultTitleText", "toggleAriaLabel", "zIndex"]);
  const menuRef = import_react24.default.useRef();
  const overflowTabRef = import_react24.default.useRef();
  const overflowLIRef = import_react24.default.useRef();
  const [isExpanded, setIsExpanded] = import_react24.default.useState(false);
  const { localActiveKey, handleTabClick } = import_react24.default.useContext(TabsContext);
  const closeMenu = () => {
    setIsExpanded(false);
    overflowTabRef.current.focus();
  };
  const handleMenuKeys = (ev) => {
    var _a3;
    const menuContainsEventTarget = (_a3 = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a3 === void 0 ? void 0 : _a3.contains(ev.target);
    if (isExpanded && menuContainsEventTarget && ev.key === "Escape") {
      closeMenu();
    }
  };
  const handleClick = (ev) => {
    var _a3, _b;
    const clickIsOutsideMenu = !((_a3 = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a3 === void 0 ? void 0 : _a3.contains(ev.target));
    const clickIsOutsideOverflowTab = !((_b = overflowTabRef === null || overflowTabRef === void 0 ? void 0 : overflowTabRef.current) === null || _b === void 0 ? void 0 : _b.contains(ev.target));
    if (isExpanded && clickIsOutsideMenu && clickIsOutsideOverflowTab) {
      closeMenu();
    }
  };
  import_react24.default.useEffect(() => {
    window.addEventListener("click", handleClick);
    window.addEventListener("keydown", handleMenuKeys);
    return () => {
      window.removeEventListener("click", handleClick);
      window.removeEventListener("keydown", handleMenuKeys);
    };
  }, [isExpanded, menuRef, overflowTabRef]);
  const selectedTab = overflowingTabs.find((tab) => tab.eventKey === localActiveKey);
  const tabTitle = (selectedTab === null || selectedTab === void 0 ? void 0 : selectedTab.title) ? selectedTab.title : defaultTitleText;
  const toggleMenu = () => {
    setIsExpanded((prevIsExpanded) => !prevIsExpanded);
    setTimeout(() => {
      if (menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) {
        const firstElement = menuRef.current.querySelector("li > button,input:not(:disabled)");
        firstElement && firstElement.focus();
      }
    }, 0);
  };
  const overflowTab = import_react24.default.createElement(
    "li",
    Object.assign({ className: css(tabs_default.tabsItem, tabs_default.modifiers.overflow, selectedTab && tabs_default.modifiers.current, className), role: "presentation", ref: overflowLIRef }, props),
    import_react24.default.createElement(
      "button",
      { type: "button", className: css(tabs_default.tabsLink, isExpanded && tabs_default.modifiers.expanded), onClick: () => toggleMenu(), "aria-label": toggleAriaLabel, "aria-haspopup": "menu", "aria-expanded": isExpanded, role: "tab", ref: overflowTabRef },
      import_react24.default.createElement(
        TabTitleText,
        null,
        tabTitle,
        showTabCount && tabTitle === defaultTitleText && ` (${overflowingTabs.length})`
      ),
      import_react24.default.createElement(
        "span",
        { className: tabs_default.tabsLinkToggleIcon },
        import_react24.default.createElement(angle_right_icon_default, null)
      )
    )
  );
  const tabs = overflowingTabs.map((tab) => import_react24.default.createElement(MenuItem, { key: tab.eventKey, itemId: tab.eventKey, isSelected: localActiveKey === tab.eventKey }, tab.title));
  const onTabSelect = (event, key) => {
    closeMenu();
    const selectedTabRef = overflowingTabs.find((tab) => tab.eventKey === key).tabContentRef;
    handleTabClick(event, key, selectedTabRef);
  };
  const overflowMenu = import_react24.default.createElement(
    Menu,
    { ref: menuRef, onSelect: (ev, itemId) => onTabSelect(ev, itemId) },
    import_react24.default.createElement(
      MenuContent,
      null,
      import_react24.default.createElement(MenuList, null, tabs)
    )
  );
  return import_react24.default.createElement(
    import_react24.default.Fragment,
    null,
    overflowTab,
    import_react24.default.createElement(Popper, { triggerRef: overflowTabRef, popper: overflowMenu, popperRef: menuRef, isVisible: isExpanded, minWidth: "revert", appendTo: overflowLIRef.current, zIndex })
  );
};
OverflowTab.displayName = "OverflowTab";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/Tabs.js
var TabsComponent;
(function(TabsComponent2) {
  TabsComponent2["div"] = "div";
  TabsComponent2["nav"] = "nav";
})(TabsComponent || (TabsComponent = {}));
var variantStyle4 = {
  default: "",
  secondary: tabs_default.modifiers.secondary
};
var Tabs = class _Tabs extends React304.Component {
  constructor(props) {
    super(props);
    this.tabList = React304.createRef();
    this.leftScrollButtonRef = React304.createRef();
    this.direction = "ltr";
    this.scrollTimeout = null;
    this.countOverflowingElements = (container) => {
      const elements = Array.from(container.children);
      return elements.filter((element) => !isElementInView(container, element, false)).length;
    };
    this.handleScrollButtons = () => {
      const { isOverflowHorizontal } = this.props;
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = setTimeout(() => {
        const container = this.tabList.current;
        let disableBackScrollButton = true;
        let disableForwardScrollButton = true;
        let enableScrollButtons = false;
        let overflowingTabCount = 0;
        if (container && !this.props.isVertical && !isOverflowHorizontal) {
          const overflowOnLeft = !isElementInView(container, container.firstChild, false);
          const overflowOnRight = !isElementInView(container, container.lastChild, false);
          enableScrollButtons = overflowOnLeft || overflowOnRight;
          disableBackScrollButton = !overflowOnLeft;
          disableForwardScrollButton = !overflowOnRight;
        }
        if (isOverflowHorizontal) {
          overflowingTabCount = this.countOverflowingElements(container);
        }
        this.setState({
          enableScrollButtons,
          disableBackScrollButton,
          disableForwardScrollButton,
          overflowingTabCount
        });
      }, 100);
    };
    this.scrollBack = () => {
      if (this.tabList.current) {
        const container = this.tabList.current;
        const childrenArr = Array.from(container.children);
        let firstElementInView;
        let lastElementOutOfView;
        let i;
        for (i = 0; i < childrenArr.length && !firstElementInView; i++) {
          if (isElementInView(container, childrenArr[i], false)) {
            firstElementInView = childrenArr[i];
            lastElementOutOfView = childrenArr[i - 1];
          }
        }
        if (lastElementOutOfView) {
          if (this.direction === "ltr") {
            container.scrollLeft -= lastElementOutOfView.scrollWidth;
          } else {
            container.scrollLeft += lastElementOutOfView.scrollWidth;
          }
        }
      }
    };
    this.scrollForward = () => {
      if (this.tabList.current) {
        const container = this.tabList.current;
        const childrenArr = Array.from(container.children);
        let lastElementInView;
        let firstElementOutOfView;
        for (let i = childrenArr.length - 1; i >= 0 && !lastElementInView; i--) {
          if (isElementInView(container, childrenArr[i], false)) {
            lastElementInView = childrenArr[i];
            firstElementOutOfView = childrenArr[i + 1];
          }
        }
        if (firstElementOutOfView) {
          if (this.direction === "ltr") {
            container.scrollLeft += firstElementOutOfView.scrollWidth;
          } else {
            container.scrollLeft -= firstElementOutOfView.scrollWidth;
          }
        }
      }
    };
    this.hideScrollButtons = () => {
      const { enableScrollButtons, renderScrollButtons, showScrollButtons } = this.state;
      if (!enableScrollButtons && !showScrollButtons && renderScrollButtons) {
        this.setState({ renderScrollButtons: false });
      }
    };
    this.state = {
      enableScrollButtons: false,
      showScrollButtons: false,
      renderScrollButtons: false,
      disableBackScrollButton: true,
      disableForwardScrollButton: true,
      shownKeys: this.props.defaultActiveKey !== void 0 ? [this.props.defaultActiveKey] : [this.props.activeKey],
      // only for mountOnEnter case
      uncontrolledActiveKey: this.props.defaultActiveKey,
      uncontrolledIsExpandedLocal: this.props.defaultIsExpanded,
      ouiaStateId: getDefaultOUIAId(_Tabs.displayName),
      overflowingTabCount: 0
    };
    if (this.props.isVertical && this.props.expandable !== void 0) {
      if (!this.props.toggleAriaLabel && !this.props.toggleText) {
        console.error("Tabs:", "toggleAriaLabel or the toggleText prop is required to make the toggle button accessible");
      }
    }
  }
  handleTabClick(event, eventKey, tabContentRef) {
    const { shownKeys } = this.state;
    const { onSelect, defaultActiveKey } = this.props;
    if (defaultActiveKey !== void 0) {
      this.setState({
        uncontrolledActiveKey: eventKey
      });
    } else {
      onSelect(event, eventKey);
    }
    if (tabContentRef) {
      React304.Children.toArray(this.props.children).filter((child) => React304.isValidElement(child)).filter(({ props }) => props.tabContentRef && props.tabContentRef.current).forEach((child) => child.props.tabContentRef.current.hidden = true);
      if (tabContentRef.current) {
        tabContentRef.current.hidden = false;
      }
    }
    if (this.props.mountOnEnter) {
      this.setState({
        shownKeys: shownKeys.concat(eventKey)
      });
    }
  }
  componentDidMount() {
    if (!this.props.isVertical) {
      if (canUseDOM) {
        window.addEventListener("resize", this.handleScrollButtons, false);
      }
      this.direction = getLanguageDirection(this.tabList.current);
      this.handleScrollButtons();
    }
  }
  componentWillUnmount() {
    var _a2;
    if (!this.props.isVertical) {
      if (canUseDOM) {
        window.removeEventListener("resize", this.handleScrollButtons, false);
      }
    }
    clearTimeout(this.scrollTimeout);
    (_a2 = this.leftScrollButtonRef.current) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("transitionend", this.hideScrollButtons);
  }
  componentDidUpdate(prevProps, prevState) {
    const { activeKey, mountOnEnter, isOverflowHorizontal, children: children2 } = this.props;
    const { shownKeys, overflowingTabCount, enableScrollButtons } = this.state;
    if (prevProps.activeKey !== activeKey && mountOnEnter && shownKeys.indexOf(activeKey) < 0) {
      this.setState({
        shownKeys: shownKeys.concat(activeKey)
      });
    }
    if (prevProps.children && children2 && React304.Children.toArray(prevProps.children).length !== React304.Children.toArray(children2).length) {
      this.handleScrollButtons();
    }
    const currentOverflowingTabCount = this.countOverflowingElements(this.tabList.current);
    if (isOverflowHorizontal && currentOverflowingTabCount) {
      this.setState({ overflowingTabCount: currentOverflowingTabCount + overflowingTabCount });
    }
    if (!prevState.enableScrollButtons && enableScrollButtons) {
      this.setState({ renderScrollButtons: true });
      setTimeout(() => {
        var _a2;
        (_a2 = this.leftScrollButtonRef.current) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("transitionend", this.hideScrollButtons);
        this.setState({ showScrollButtons: true });
      }, 100);
    } else if (prevState.enableScrollButtons && !enableScrollButtons) {
      this.setState({ showScrollButtons: false });
    }
    this.direction = getLanguageDirection(this.tabList.current);
  }
  static getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.uncontrolledActiveKey === void 0) {
      return null;
    }
    const childrenHasTabWithActiveEventKey = React304.Children.toArray(nextProps.children).filter((child) => React304.isValidElement(child)).some(({ props }) => props.eventKey === prevState.uncontrolledActiveKey);
    if (childrenHasTabWithActiveEventKey) {
      return null;
    }
    return {
      uncontrolledActiveKey: nextProps.defaultActiveKey,
      shownKeys: nextProps.defaultActiveKey !== void 0 ? [nextProps.defaultActiveKey] : [nextProps.activeKey]
      // only for mountOnEnter case
    };
  }
  render() {
    const _a2 = this.props, { className, children: children2, activeKey, defaultActiveKey, id: id2, isFilled, isSubtab, isVertical, isBox, hasNoBorderBottom, leftScrollAriaLabel, rightScrollAriaLabel, backScrollAriaLabel, forwardScrollAriaLabel, "aria-label": ariaLabel, component, ouiaId, ouiaSafe, mountOnEnter, unmountOnExit, usePageInsets, inset, variant, expandable, isExpanded, defaultIsExpanded, toggleText, toggleAriaLabel, addButtonAriaLabel, onToggle, onClose, onAdd: onAdd2, isOverflowHorizontal } = _a2, props = __rest(_a2, ["className", "children", "activeKey", "defaultActiveKey", "id", "isFilled", "isSubtab", "isVertical", "isBox", "hasNoBorderBottom", "leftScrollAriaLabel", "rightScrollAriaLabel", "backScrollAriaLabel", "forwardScrollAriaLabel", "aria-label", "component", "ouiaId", "ouiaSafe", "mountOnEnter", "unmountOnExit", "usePageInsets", "inset", "variant", "expandable", "isExpanded", "defaultIsExpanded", "toggleText", "toggleAriaLabel", "addButtonAriaLabel", "onToggle", "onClose", "onAdd", "isOverflowHorizontal"]);
    const { showScrollButtons, renderScrollButtons, disableBackScrollButton, disableForwardScrollButton, shownKeys, uncontrolledActiveKey, uncontrolledIsExpandedLocal, overflowingTabCount } = this.state;
    const filteredChildren = React304.Children.toArray(children2).filter((child) => React304.isValidElement(child)).filter(({ props: props2 }) => !props2.isHidden);
    const filteredChildrenWithoutOverflow = filteredChildren.slice(0, filteredChildren.length - overflowingTabCount);
    const filteredChildrenOverflowing = filteredChildren.slice(filteredChildren.length - overflowingTabCount);
    const overflowingTabProps = filteredChildrenOverflowing.map((child) => child.props);
    const uniqueId = id2 || getUniqueId();
    const Component50 = component === TabsComponent.nav ? "nav" : "div";
    const localActiveKey = defaultActiveKey !== void 0 ? uncontrolledActiveKey : activeKey;
    const isExpandedLocal = defaultIsExpanded !== void 0 ? uncontrolledIsExpandedLocal : isExpanded;
    const toggleTabs = (event, newValue) => {
      if (isExpanded === void 0) {
        this.setState({ uncontrolledIsExpandedLocal: newValue });
      } else {
        onToggle(event, newValue);
      }
    };
    const hasOverflowTab = isOverflowHorizontal && overflowingTabCount > 0;
    const overflowObjectProps = typeof isOverflowHorizontal === "object" ? Object.assign({}, isOverflowHorizontal) : {};
    return React304.createElement(
      TabsContextProvider,
      { value: {
        variant,
        mountOnEnter,
        unmountOnExit,
        localActiveKey,
        uniqueId,
        handleTabClick: (...args) => this.handleTabClick(...args),
        handleTabClose: onClose
      } },
      React304.createElement(
        Component50,
        Object.assign({ "aria-label": ariaLabel, className: css(tabs_default.tabs, isFilled && tabs_default.modifiers.fill, isSubtab && tabs_default.modifiers.subtab, isVertical && tabs_default.modifiers.vertical, isVertical && expandable && formatBreakpointMods(expandable, tabs_default), isVertical && expandable && isExpandedLocal && tabs_default.modifiers.expanded, isBox && tabs_default.modifiers.box, showScrollButtons && tabs_default.modifiers.scrollable, usePageInsets && tabs_default.modifiers.pageInsets, hasNoBorderBottom && tabs_default.modifiers.noBorderBottom, formatBreakpointMods(inset, tabs_default), variantStyle4[variant], hasOverflowTab && tabs_default.modifiers.overflow, className) }, getOUIAProps(_Tabs.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), { id: id2 && id2 }, props),
        expandable && isVertical && React304.createElement(GenerateId, null, (randomId) => React304.createElement(
          "div",
          { className: css(tabs_default.tabsToggle) },
          React304.createElement(
            "div",
            { className: css(tabs_default.tabsToggleButton) },
            React304.createElement(
              Button,
              { onClick: (event) => toggleTabs(event, !isExpandedLocal), variant: "plain", "aria-label": toggleAriaLabel, "aria-expanded": isExpandedLocal, id: `${randomId}-button`, "aria-labelledby": `${randomId}-text ${randomId}-button` },
              React304.createElement(
                "span",
                { className: css(tabs_default.tabsToggleIcon) },
                React304.createElement(angle_right_icon_default, { "arian-hidden": "true" })
              ),
              toggleText && React304.createElement("span", { className: css(tabs_default.tabsToggleText), id: `${randomId}-text` }, toggleText)
            )
          )
        )),
        renderScrollButtons && React304.createElement(
          "div",
          { className: css(tabs_default.tabsScrollButton) },
          React304.createElement(
            Button,
            { "aria-label": backScrollAriaLabel || leftScrollAriaLabel, onClick: this.scrollBack, isDisabled: disableBackScrollButton, "aria-hidden": disableBackScrollButton, ref: this.leftScrollButtonRef, variant: "plain" },
            React304.createElement(angle_left_icon_default, null)
          )
        ),
        React304.createElement(
          "ul",
          { className: css(tabs_default.tabsList), ref: this.tabList, onScroll: this.handleScrollButtons, role: "tablist" },
          isOverflowHorizontal ? filteredChildrenWithoutOverflow : filteredChildren,
          hasOverflowTab && React304.createElement(OverflowTab, Object.assign({ overflowingTabs: overflowingTabProps }, overflowObjectProps))
        ),
        renderScrollButtons && React304.createElement(
          "div",
          { className: css(tabs_default.tabsScrollButton) },
          React304.createElement(
            Button,
            { "aria-label": forwardScrollAriaLabel || rightScrollAriaLabel, onClick: this.scrollForward, isDisabled: disableForwardScrollButton, "aria-hidden": disableForwardScrollButton, variant: "plain" },
            React304.createElement(angle_right_icon_default, null)
          )
        ),
        onAdd2 !== void 0 && React304.createElement(
          "span",
          { className: css(tabs_default.tabsAdd) },
          React304.createElement(
            Button,
            { variant: "plain", "aria-label": addButtonAriaLabel || "Add tab", onClick: onAdd2 },
            React304.createElement(plus_icon_default, null)
          )
        )
      ),
      filteredChildren.filter((child) => child.props.children && !(unmountOnExit && child.props.eventKey !== localActiveKey) && !(mountOnEnter && shownKeys.indexOf(child.props.eventKey) === -1)).map((child) => React304.createElement(TabContent, { key: child.props.eventKey, activeKey: localActiveKey, child, id: child.props.id || uniqueId, ouiaId: child.props.ouiaId }))
    );
  }
};
Tabs.displayName = "Tabs";
Tabs.defaultProps = {
  activeKey: 0,
  onSelect: () => void 0,
  isFilled: false,
  isSubtab: false,
  isVertical: false,
  isBox: false,
  hasNoBorderBottom: false,
  leftScrollAriaLabel: "Scroll left",
  backScrollAriaLabel: "Scroll back",
  rightScrollAriaLabel: "Scroll right",
  forwardScrollAriaLabel: "Scroll forward",
  component: TabsComponent.div,
  mountOnEnter: false,
  unmountOnExit: false,
  ouiaSafe: true,
  variant: "default",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onToggle: (_event, _isExpanded) => void 0
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/TabContentBody.js
var React305 = __toESM(require_react());
var TabContentBody = (_a2) => {
  var { children: children2, className, hasPadding } = _a2, props = __rest(_a2, ["children", "className", "hasPadding"]);
  return React305.createElement("div", Object.assign({ className: css(tab_content_default.tabContentBody, hasPadding && tab_content_default.modifiers.padding, className) }, props), children2);
};
TabContentBody.displayName = "TabContentBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tabs/TabTitleIcon.js
var React306 = __toESM(require_react());
var TabTitleIcon = (_a2) => {
  var { children: children2, className = "" } = _a2, props = __rest(_a2, ["children", "className"]);
  return React306.createElement("span", Object.assign({ className: css(`${tabs_default.tabs}__item-icon`, className) }, props), children2);
};
TabTitleIcon.displayName = "TabTitleIcon";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Text/TextContent.js
var React307 = __toESM(require_react());
var TextContent = (_a2) => {
  var { children: children2, className = "", isVisited = false } = _a2, props = __rest(_a2, ["children", "className", "isVisited"]);
  return React307.createElement("div", Object.assign({}, props, { className: css(content_default.content, isVisited && content_default.modifiers.visited, className) }), children2);
};
TextContent.displayName = "TextContent";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Text/Text.js
var React308 = __toESM(require_react());
var TextVariants;
(function(TextVariants2) {
  TextVariants2["h1"] = "h1";
  TextVariants2["h2"] = "h2";
  TextVariants2["h3"] = "h3";
  TextVariants2["h4"] = "h4";
  TextVariants2["h5"] = "h5";
  TextVariants2["h6"] = "h6";
  TextVariants2["p"] = "p";
  TextVariants2["a"] = "a";
  TextVariants2["small"] = "small";
  TextVariants2["blockquote"] = "blockquote";
  TextVariants2["pre"] = "pre";
})(TextVariants || (TextVariants = {}));
var componentStyles = {
  h1: content_default.contentH1,
  h2: content_default.contentH2,
  h3: content_default.contentH3,
  h4: content_default.contentH4,
  h5: content_default.contentH5,
  h6: content_default.contentH6,
  p: content_default.contentP,
  a: content_default.contentA,
  small: content_default.contentSmall,
  blockquote: content_default.contentBlockquote,
  pre: content_default.contentPre
};
var Text = (_a2) => {
  var { children: children2 = null, className = "", component = TextVariants.p, isVisitedLink = false, ouiaId, ouiaSafe = true } = _a2, props = __rest(_a2, ["children", "className", "component", "isVisitedLink", "ouiaId", "ouiaSafe"]);
  const Component50 = component;
  const ouiaProps = useOUIAProps(Text.displayName, ouiaId, ouiaSafe);
  return React308.createElement(Component50, Object.assign({}, ouiaProps, props, { "data-pf-content": true, className: css(isVisitedLink && component === TextVariants.a && content_default.modifiers.visited, componentStyles[component], className) }), children2);
};
Text.displayName = "Text";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Text/TextList.js
var React309 = __toESM(require_react());
var TextListVariants;
(function(TextListVariants2) {
  TextListVariants2["ul"] = "ul";
  TextListVariants2["ol"] = "ol";
  TextListVariants2["dl"] = "dl";
})(TextListVariants || (TextListVariants = {}));
var componentStyles2 = {
  ul: content_default.contentUl,
  ol: content_default.contentOl,
  dl: content_default.contentDl
};
var TextList = (_a2) => {
  var { children: children2 = null, className = "", component = TextListVariants.ul, isPlain = false } = _a2, props = __rest(_a2, ["children", "className", "component", "isPlain"]);
  const Component50 = component;
  return React309.createElement(Component50, Object.assign({}, props, { className: css(isPlain && content_default.modifiers.plain, componentStyles2[component], className) }), children2);
};
TextList.displayName = "TextList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Text/TextListItem.js
var React310 = __toESM(require_react());
var TextListItemVariants;
(function(TextListItemVariants2) {
  TextListItemVariants2["li"] = "li";
  TextListItemVariants2["dt"] = "dt";
  TextListItemVariants2["dd"] = "dd";
})(TextListItemVariants || (TextListItemVariants = {}));
var componentStyles3 = {
  li: content_default.contentLi,
  dt: content_default.contentDt,
  dd: content_default.contentDd
};
var TextListItem = (_a2) => {
  var { children: children2 = null, className = "", component = TextListItemVariants.li } = _a2, props = __rest(_a2, ["children", "className", "component"]);
  const Component50 = component;
  return React310.createElement(Component50, Object.assign({}, props, { className: css(componentStyles3[component], className) }), children2);
};
TextListItem.displayName = "TextListItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tile/Tile.js
var React311 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Tile/tile.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Tile/tile.css";
var tile_default = {
  "modifiers": {
    "selected": "pf-m-selected",
    "disabled": "pf-m-disabled",
    "displayLg": "pf-m-display-lg",
    "stacked": "pf-m-stacked"
  },
  "tile": "pf-v6-c-tile",
  "tileBody": "pf-v6-c-tile__body",
  "tileHeader": "pf-v6-c-tile__header",
  "tileIcon": "pf-v6-c-tile__icon",
  "tileTitle": "pf-v6-c-tile__title"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Tile/Tile.js
var Tile = (_a2) => {
  var { children: children2, title, icon, isStacked, isSelected, isDisabled, isDisplayLarge, className } = _a2, props = __rest(_a2, ["children", "title", "icon", "isStacked", "isSelected", "isDisabled", "isDisplayLarge", "className"]);
  return React311.createElement(
    "div",
    Object.assign({ role: "option", "aria-selected": isSelected }, isDisabled && { "aria-disabled": isDisabled }, { className: css(tile_default.tile, isSelected && tile_default.modifiers.selected, isDisabled && tile_default.modifiers.disabled, isDisplayLarge && tile_default.modifiers.displayLg, className), tabIndex: 0 }, props),
    React311.createElement(
      "div",
      { className: css(tile_default.tileHeader, isStacked && tile_default.modifiers.stacked) },
      icon && React311.createElement("div", { className: css(tile_default.tileIcon) }, icon),
      React311.createElement("div", { className: css(tile_default.tileTitle) }, title)
    ),
    children2 && React311.createElement("div", { className: css(tile_default.tileBody) }, children2)
  );
};
Tile.displayName = "Tile";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TimePicker/TimePicker.js
var React312 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TimePicker/TimePickerUtils.js
var amSuffix = " AM";
var pmSuffix = " PM";
var makeTimeOptions = (stepMinutes, hour12, delimiter, minTime, maxTime, includeSeconds) => {
  const res = [];
  const iter = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
  const iterDay = iter.getDay();
  while (iter.getDay() === iterDay) {
    let hour = iter.getHours();
    let suffix = amSuffix;
    if (hour12) {
      if (hour === 0) {
        hour = 12;
      } else if (hour >= 12) {
        suffix = pmSuffix;
      }
      if (hour > 12) {
        hour %= 12;
      }
    }
    hour = hour12 ? hour.toString() : hour.toString().padStart(2, "0");
    const minutes = iter.getMinutes().toString().padStart(2, "0");
    const timeOption = `${hour}${delimiter}${minutes}${hour12 ? suffix : ""}`;
    if (isWithinMinMax(minTime, maxTime, timeOption, delimiter, includeSeconds)) {
      res.push(timeOption);
    }
    iter.setMinutes(iter.getMinutes() + stepMinutes);
  }
  return res;
};
var parseTime = (time2, timeRegex, delimiter, is12Hour, includeSeconds) => {
  const date2 = new Date(time2);
  if (!isNaN(date2.getDate()) && (time2 instanceof Date || time2.includes("T"))) {
    const hours = is12Hour ? `${date2.getHours() > 12 ? date2.getHours() - 12 : date2.getHours()}` : `${date2.getHours()}`.padStart(2, "0");
    const minutes = `${date2.getMinutes()}`.padStart(2, "0");
    const seconds2 = includeSeconds ? `${date2.getSeconds()}`.padStart(2, "0") : "";
    const secondsWithDelimiter = seconds2 ? `${delimiter}${seconds2}` : "";
    let ampm = "";
    if (is12Hour && date2.getHours() > 11) {
      ampm = pmSuffix;
    } else if (is12Hour) {
      ampm = amSuffix;
    }
    return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;
  } else if (typeof time2 === "string") {
    time2 = time2.trim();
    if (time2 !== "" && validateTime(time2, timeRegex, delimiter, is12Hour)) {
      const [, hours, minutes, seconds2, suffix = ""] = timeRegex.exec(time2);
      const secondsWithDelimiter = includeSeconds ? `${delimiter}${seconds2 !== null && seconds2 !== void 0 ? seconds2 : "00"}` : "";
      let ampm = "";
      if (is12Hour) {
        const uppercaseSuffix = suffix.toUpperCase();
        if (uppercaseSuffix === amSuffix.toUpperCase().trim()) {
          ampm = amSuffix;
        } else if (uppercaseSuffix === pmSuffix.toUpperCase().trim()) {
          ampm = pmSuffix;
        } else {
          ampm = (/* @__PURE__ */ new Date()).getHours() > 11 ? pmSuffix : amSuffix;
        }
      }
      return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;
    }
  }
  return time2.toString();
};
var validateTime = (time2, timeRegex, delimiter, is12Hour) => {
  const date2 = new Date(time2);
  if (!isNaN(date2.getDate()) && time2.includes("T")) {
    return true;
  }
  const hours = parseInt(time2.split(delimiter)[0]);
  const validHours = hours >= (is12Hour ? 1 : 0) && hours <= (is12Hour ? 12 : 23);
  return time2 === "" || timeRegex.test(time2) && validHours;
};
var getHours = (time2, timeRegex) => {
  const parts = time2.match(timeRegex);
  if (parts && parts.length) {
    if (/pm/i.test(parts[4])) {
      return parseInt(parts[1]) === 12 ? parseInt(parts[1]) : parseInt(parts[1]) + 12;
    }
    if (/am/i.test(parts[4])) {
      return parseInt(parts[1]) === 12 ? 0 : parseInt(parts[1]);
    }
    return parseInt(parts[1]);
  }
  return null;
};
var getMinutes = (time2, timeRegex) => {
  const parts = time2.match(timeRegex);
  return parts && parts.length ? parseInt(parts[2]) : null;
};
var getSeconds = (time2, timeRegex) => {
  var _a2;
  const seconds2 = (_a2 = time2.match(timeRegex)) === null || _a2 === void 0 ? void 0 : _a2[3];
  return seconds2 ? parseInt(seconds2) : null;
};
var isWithinMinMax = (minTime, maxTime, time2, delimiter, includeSeconds) => {
  if (time2.trim() === "") {
    return true;
  }
  const min24HourTime = convertTo24Hour(minTime, delimiter, includeSeconds);
  const selected24HourTime = convertTo24Hour(time2, delimiter, includeSeconds);
  const max24HourTime = convertTo24Hour(maxTime, delimiter, includeSeconds);
  return min24HourTime <= selected24HourTime && selected24HourTime <= max24HourTime;
};
var convertTo24Hour = (time2, delimiter, includeSeconds) => {
  const timeReg = new RegExp(`^\\s*(\\d\\d?)${delimiter}([0-5]\\d)${delimiter}?([0-5]\\d)?\\s*([AaPp][Mm])?\\s*$`);
  const regMatches = timeReg.exec(time2);
  if (!regMatches || !regMatches.length) {
    return;
  }
  let hours = regMatches[1].padStart(2, "0");
  const minutes = regMatches[2];
  let seconds2 = regMatches[3] ? `${delimiter}${regMatches[3]}` : "";
  if (!seconds2 && includeSeconds) {
    seconds2 = `${delimiter}00`;
  }
  const suffix = regMatches[4] || "";
  if (suffix.toUpperCase() === "PM" && hours !== "12") {
    hours = `${parseInt(hours) + 12}`;
  } else if (suffix.toUpperCase() === "AM" && hours === "12") {
    hours = "00";
  }
  return `${hours}${delimiter}${minutes}${seconds2}`;
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-icons/dist/esm/icons/outlined-clock-icon.js
var OutlinedClockIconConfig = {
  name: "OutlinedClockIcon",
  height: 512,
  width: 512,
  svgPath: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm61.8-104.4l-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z",
  yOffset: 0,
  xOffset: 0
};
var OutlinedClockIcon = createIcon(OutlinedClockIconConfig);
var outlined_clock_icon_default = OutlinedClockIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TimePicker/TimePicker.js
var TimePicker = class extends React312.Component {
  constructor(props) {
    super(props);
    this.baseComponentRef = React312.createRef();
    this.toggleRef = React312.createRef();
    this.inputRef = React312.createRef();
    this.menuRef = React312.createRef();
    this.onDocClick = (event) => {
      var _a2, _b, _c, _d;
      const clickedOnToggle = (_b = (_a2 = this.toggleRef) === null || _a2 === void 0 ? void 0 : _a2.current) === null || _b === void 0 ? void 0 : _b.contains(event.target);
      const clickedWithinMenu = (_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target);
      if (this.state.isTimeOptionsOpen && !(clickedOnToggle || clickedWithinMenu)) {
        this.onToggle(false);
      }
    };
    this.handleGlobalKeys = (event) => {
      var _a2, _b, _c, _d;
      const { isTimeOptionsOpen, focusedIndex, scrollIndex } = this.state;
      if ((_b = (_a2 = this.inputRef) === null || _a2 === void 0 ? void 0 : _a2.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)) {
        if (!isTimeOptionsOpen && event.key !== KeyTypes.Tab && event.key !== KeyTypes.Escape) {
          this.onToggle(true);
        } else if (isTimeOptionsOpen) {
          if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {
            this.onToggle(false);
          } else if (event.key === KeyTypes.Enter) {
            if (focusedIndex !== null) {
              this.focusSelection(focusedIndex);
              event.stopPropagation();
            } else {
              this.onToggle(false);
            }
          } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {
            this.focusSelection(scrollIndex);
            this.updateFocusedIndex(0);
            event.preventDefault();
          }
        }
      } else if ((_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {
        if (event.key === KeyTypes.ArrowDown) {
          this.updateFocusedIndex(1);
          event.preventDefault();
        } else if (event.key === KeyTypes.ArrowUp) {
          this.updateFocusedIndex(-1);
          event.preventDefault();
        } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {
          this.inputRef.current.focus();
          this.onToggle(false);
        }
      }
    };
    this.updateFocusedIndex = (increment) => {
      this.setState((prevState) => {
        const maxIndex2 = this.getOptions().length - 1;
        let nextIndex = prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;
        if (nextIndex < 0) {
          nextIndex = maxIndex2;
        } else if (nextIndex > maxIndex2) {
          nextIndex = 0;
        }
        this.scrollToIndex(nextIndex);
        return {
          focusedIndex: nextIndex
        };
      });
    };
    this.getIndexToScroll = (index4) => {
      if (this.props.menuAppendTo === "inline") {
        return index4 > 0 ? index4 - 1 : 0;
      }
      return index4;
    };
    this.scrollToIndex = (index4) => {
      this.getOptions()[index4].closest(`.${menu_default.menuContent}`).scrollTop = this.getOptions()[this.getIndexToScroll(index4)].offsetTop;
    };
    this.focusSelection = (index4) => {
      var _a2;
      const indexToFocus = index4 !== -1 ? index4 : 0;
      if ((_a2 = this.menuRef) === null || _a2 === void 0 ? void 0 : _a2.current) {
        this.getOptions()[indexToFocus].querySelector(`.${menu_default.menuItem}`).focus();
      }
    };
    this.scrollToSelection = (time3) => {
      const { delimiter: delimiter2, is24Hour: is24Hour2 } = this.props;
      let splitTime = time3.split(this.props.delimiter);
      let focusedIndex = null;
      if (splitTime.length < 2) {
        time3 = `${time3}${delimiter2}00`;
        splitTime = time3.split(delimiter2);
      } else if (splitTime.length > 2) {
        time3 = parseTime(time3, this.state.timeRegex, delimiter2, !is24Hour2, false);
        splitTime = time3.split(delimiter2);
      }
      if (!is24Hour2 && splitTime.length > 1 && splitTime[1].length < 2) {
        const minutes = splitTime[1].length === 0 ? "00" : splitTime[1] + "0";
        time3 = `${splitTime[0]}${delimiter2}${minutes}${(/* @__PURE__ */ new Date()).getHours() > 11 ? pmSuffix : amSuffix}`;
      } else if (!is24Hour2 && splitTime.length > 1 && splitTime[1].length === 2 && !time3.toUpperCase().includes(amSuffix.toUpperCase().trim()) && !time3.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {
        time3 = `${time3}${(/* @__PURE__ */ new Date()).getHours() > 11 ? pmSuffix : amSuffix}`;
      }
      let scrollIndex = this.getOptions().findIndex((option) => option.textContent === time3);
      if (scrollIndex !== -1) {
        this.scrollToIndex(scrollIndex);
        focusedIndex = scrollIndex;
      } else if (splitTime.length === 2) {
        let amPm = "";
        if (!is24Hour2) {
          if (splitTime[1].toUpperCase().includes("P")) {
            amPm = pmSuffix;
          } else if (splitTime[1].toUpperCase().includes("A")) {
            amPm = amSuffix;
          }
        }
        time3 = `${splitTime[0]}${delimiter2}00${amPm}`;
        scrollIndex = this.getOptions().findIndex((option) => option.textContent === time3);
        if (scrollIndex !== -1) {
          this.scrollToIndex(scrollIndex);
        }
      }
      this.setState({
        focusedIndex,
        scrollIndex
      });
    };
    this.getRegExp = (includeSeconds2 = true) => {
      const { is24Hour: is24Hour2, delimiter: delimiter2 } = this.props;
      let baseRegex = `\\s*(\\d\\d?)${delimiter2}([0-5]\\d)`;
      if (includeSeconds2) {
        baseRegex += `${delimiter2}?([0-5]\\d)?`;
      }
      return new RegExp(`^${baseRegex}${is24Hour2 ? "" : "\\s*([AaPp][Mm])?"}\\s*$`);
    };
    this.getOptions = () => {
      var _a2;
      return ((_a2 = this.menuRef) === null || _a2 === void 0 ? void 0 : _a2.current) ? Array.from(this.menuRef.current.querySelectorAll(`.${menu_default.menuListItem}`)) : [];
    };
    this.isValidFormat = (time3) => {
      if (this.props.validateTime) {
        return this.props.validateTime(time3);
      }
      const { delimiter: delimiter2, is24Hour: is24Hour2, includeSeconds: includeSeconds2 } = this.props;
      return validateTime(time3, this.getRegExp(includeSeconds2), delimiter2, !is24Hour2);
    };
    this.isValidTime = (time3) => {
      const { delimiter: delimiter2, includeSeconds: includeSeconds2 } = this.props;
      const { minTimeState, maxTimeState } = this.state;
      return isWithinMinMax(minTimeState, maxTimeState, time3, delimiter2, includeSeconds2);
    };
    this.isValid = (time3) => this.isValidFormat(time3) && this.isValidTime(time3);
    this.onToggle = (isOpen2) => {
      this.setState((prevState) => {
        const { timeRegex: timeRegex2, isInvalid, timeState } = prevState;
        const { delimiter: delimiter2, is24Hour: is24Hour2, includeSeconds: includeSeconds2, onChange } = this.props;
        const time3 = parseTime(timeState, timeRegex2, delimiter2, !is24Hour2, includeSeconds2);
        if (onChange && !isOpen2 && time3 !== timeState) {
          onChange(null, time3, getHours(time3, timeRegex2), getMinutes(time3, timeRegex2), getSeconds(time3, timeRegex2), this.isValid(time3));
        }
        return {
          isTimeOptionsOpen: isOpen2,
          timeState: time3,
          isInvalid: isOpen2 ? isInvalid : !this.isValid(time3)
        };
      });
      this.props.setIsOpen(isOpen2);
      if (!isOpen2) {
        this.inputRef.current.focus();
      }
    };
    this.onSelect = (e) => {
      const { timeRegex: timeRegex2, timeState } = this.state;
      const { delimiter: delimiter2, is24Hour: is24Hour2, includeSeconds: includeSeconds2, setIsOpen } = this.props;
      const time3 = parseTime(e.target.textContent, timeRegex2, delimiter2, !is24Hour2, includeSeconds2);
      if (time3 !== timeState) {
        this.onInputChange(e, time3);
      }
      this.inputRef.current.focus();
      this.setState({
        isTimeOptionsOpen: false,
        isInvalid: false
      });
      setIsOpen(false);
    };
    this.onInputClick = (e) => {
      if (!this.state.isTimeOptionsOpen) {
        this.onToggle(true);
      }
      e.stopPropagation();
    };
    this.onInputChange = (event, newTime) => {
      const { onChange } = this.props;
      const { timeRegex: timeRegex2 } = this.state;
      if (onChange) {
        onChange(event, newTime, getHours(newTime, timeRegex2), getMinutes(newTime, timeRegex2), getSeconds(newTime, timeRegex2), this.isValid(newTime));
      }
      this.scrollToSelection(newTime);
      this.setState({
        timeState: newTime
      });
    };
    const { is24Hour, delimiter, time: time2, includeSeconds, isOpen } = this.props;
    let { minTime, maxTime } = this.props;
    if (minTime === "") {
      const minSeconds = includeSeconds ? `${delimiter}00` : "";
      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;
    }
    if (maxTime === "") {
      const maxSeconds = includeSeconds ? `${delimiter}59` : "";
      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;
    }
    const timeRegex = this.getRegExp();
    this.state = {
      isInvalid: false,
      isTimeOptionsOpen: isOpen,
      timeState: parseTime(time2, timeRegex, delimiter, !is24Hour, includeSeconds),
      focusedIndex: null,
      scrollIndex: 0,
      timeRegex,
      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),
      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)
    };
  }
  componentDidMount() {
    document.addEventListener("mousedown", this.onDocClick);
    document.addEventListener("touchstart", this.onDocClick);
    document.addEventListener("keydown", this.handleGlobalKeys);
    this.setState({ isInvalid: !this.isValid(this.state.timeState) });
  }
  componentWillUnmount() {
    document.removeEventListener("mousedown", this.onDocClick);
    document.removeEventListener("touchstart", this.onDocClick);
    document.removeEventListener("keydown", this.handleGlobalKeys);
  }
  componentDidUpdate(prevProps, prevState) {
    const { timeState, isTimeOptionsOpen, isInvalid, timeRegex } = this.state;
    const { time: time2, is24Hour, delimiter, includeSeconds, isOpen, minTime, maxTime } = this.props;
    if (prevProps.isOpen !== isOpen) {
      this.onToggle(isOpen);
    }
    if (isTimeOptionsOpen && !prevState.isTimeOptionsOpen && timeState && !isInvalid) {
      this.scrollToSelection(timeState);
    }
    if (delimiter !== prevProps.delimiter) {
      this.setState({
        timeRegex: this.getRegExp()
      });
    }
    if (time2 !== "" && time2 !== prevProps.time) {
      const parsedTime = parseTime(time2, timeRegex, delimiter, !is24Hour, includeSeconds);
      this.setState({
        timeState: parsedTime,
        isInvalid: !this.isValid(parsedTime)
      });
    }
    if (minTime !== "" && minTime !== prevProps.minTime) {
      this.setState({
        minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds)
      });
    }
    if (maxTime !== "" && maxTime !== prevProps.maxTime) {
      this.setState({
        maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)
      });
    }
  }
  render() {
    const _a2 = this.props, {
      "aria-label": ariaLabel,
      isDisabled,
      className,
      placeholder,
      id: id2,
      menuAppendTo,
      is24Hour,
      invalidFormatErrorMessage,
      invalidMinMaxErrorMessage,
      stepMinutes,
      width,
      delimiter,
      inputProps,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onChange,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      setIsOpen,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      isOpen,
      time: time2,
      validateTime: validateTime2,
      minTime,
      maxTime,
      includeSeconds,
      zIndex
    } = _a2, props = __rest(_a2, ["aria-label", "isDisabled", "className", "placeholder", "id", "menuAppendTo", "is24Hour", "invalidFormatErrorMessage", "invalidMinMaxErrorMessage", "stepMinutes", "width", "delimiter", "inputProps", "onChange", "setIsOpen", "isOpen", "time", "validateTime", "minTime", "maxTime", "includeSeconds", "zIndex"]);
    const { timeState, isTimeOptionsOpen, isInvalid, minTimeState, maxTimeState } = this.state;
    const style = { [c_date_picker_input_c_form_control_Width_default.name]: width };
    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);
    const isValidFormat = this.isValidFormat(timeState);
    const randomId = id2 || getUniqueId("time-picker");
    const getParentElement = () => {
      if (this.baseComponentRef && this.baseComponentRef.current) {
        return this.baseComponentRef.current.parentElement;
      }
      return null;
    };
    const menuContainer = React312.createElement(
      Menu,
      { ref: this.menuRef, isScrollable: true },
      React312.createElement(
        MenuContent,
        { maxMenuHeight: "200px" },
        React312.createElement(MenuList, { "aria-label": ariaLabel }, options.map((option, index4) => React312.createElement(MenuItem, { onClick: this.onSelect, key: option, id: `${randomId}-option-${index4}` }, option)))
      )
    );
    const textInput = React312.createElement(TextInput, Object.assign({ "aria-haspopup": "menu", id: `${randomId}-input`, "aria-label": ariaLabel, validated: isInvalid ? "error" : "default", placeholder, value: timeState || "", type: "text", customIcon: React312.createElement(outlined_clock_icon_default, null), onClick: this.onInputClick, onChange: this.onInputChange, autoComplete: "off", isDisabled, isExpanded: isTimeOptionsOpen, ref: this.inputRef }, inputProps));
    let calculatedAppendTo;
    switch (menuAppendTo) {
      case "inline":
        calculatedAppendTo = () => this.toggleRef.current;
        break;
      case "parent":
        calculatedAppendTo = getParentElement;
        break;
      default:
        calculatedAppendTo = menuAppendTo;
    }
    return React312.createElement(
      "div",
      { ref: this.baseComponentRef, className: css(date_picker_default.datePicker, className) },
      React312.createElement(
        "div",
        Object.assign({ className: css(date_picker_default.datePickerInput), style }, props),
        React312.createElement(
          InputGroup,
          null,
          React312.createElement(
            InputGroupItem,
            null,
            React312.createElement(
              "div",
              { id: randomId },
              React312.createElement(
                "div",
                { ref: this.toggleRef, style: { paddingLeft: "0" } },
                React312.createElement(Popper, { appendTo: calculatedAppendTo, trigger: textInput, triggerRef: this.toggleRef, popper: menuContainer, popperRef: this.menuRef, isVisible: isTimeOptionsOpen, zIndex })
              )
            )
          )
        ),
        isInvalid && React312.createElement(
          "div",
          { className: css(date_picker_default.datePickerHelperText) },
          React312.createElement(
            HelperText,
            null,
            React312.createElement(HelperTextItem, { variant: "error" }, !isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage)
          )
        )
      )
    );
  }
};
TimePicker.displayName = "TimePicker";
TimePicker.defaultProps = {
  className: "",
  isDisabled: false,
  time: "",
  is24Hour: false,
  invalidFormatErrorMessage: "Invalid time format",
  invalidMinMaxErrorMessage: "Invalid time entered",
  placeholder: "hh:mm",
  delimiter: ":",
  "aria-label": "Time picker",
  width: "150px",
  menuAppendTo: "inline",
  stepMinutes: 30,
  inputProps: {},
  minTime: "",
  maxTime: "",
  isOpen: false,
  setIsOpen: () => {
  },
  zIndex: 9999
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Timestamp/Timestamp.js
var React313 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Timestamp/timestamp.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Timestamp/timestamp.css";
var timestamp_default = {
  "modifiers": {
    "helpText": "pf-m-help-text"
  },
  "timestamp": "pf-v6-c-timestamp"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Timestamp/Timestamp.js
var TimestampFormat;
(function(TimestampFormat2) {
  TimestampFormat2["full"] = "full";
  TimestampFormat2["long"] = "long";
  TimestampFormat2["medium"] = "medium";
  TimestampFormat2["short"] = "short";
})(TimestampFormat || (TimestampFormat = {}));
var TimestampTooltipVariant;
(function(TimestampTooltipVariant2) {
  TimestampTooltipVariant2["default"] = "default";
  TimestampTooltipVariant2["custom"] = "custom";
})(TimestampTooltipVariant || (TimestampTooltipVariant = {}));
var Timestamp = (_a2) => {
  var { children: children2, className, customFormat, date: dateProp, dateFormat, displaySuffix = "", is12Hour, locale: locale3, shouldDisplayUTC, timeFormat: timeFormat2, tooltip } = _a2, props = __rest(_a2, ["children", "className", "customFormat", "date", "dateFormat", "displaySuffix", "is12Hour", "locale", "shouldDisplayUTC", "timeFormat", "tooltip"]);
  const [date2, setDate] = React313.useState(() => {
    const initDate = new Date(dateProp);
    if (isValidDate(initDate)) {
      return initDate;
    }
    return /* @__PURE__ */ new Date();
  });
  React313.useEffect(() => {
    const dateFromProp = new Date(dateProp);
    if (isValidDate(dateFromProp) && dateFromProp.toString() !== new Date(date2).toString()) {
      setDate(dateFromProp);
    } else if (!dateProp) {
      setDate(/* @__PURE__ */ new Date());
    }
  }, [dateProp]);
  const hasTimeFormat = timeFormat2 && !customFormat;
  const formatOptions = Object.assign(Object.assign(Object.assign({}, dateFormat && !customFormat && { dateStyle: dateFormat }), customFormat && Object.assign({}, customFormat)), is12Hour !== void 0 && { hour12: is12Hour });
  const dateAsLocaleString = new Date(date2).toLocaleString(locale3, Object.assign(Object.assign({}, formatOptions), hasTimeFormat && { timeStyle: timeFormat2 }));
  const utcTimeFormat = timeFormat2 !== "short" ? "medium" : "short";
  const convertToUTCString = (date3) => new Date(date3).toUTCString().slice(0, -3);
  const utcDateString = new Date(convertToUTCString(date2)).toLocaleString(locale3, Object.assign(Object.assign({}, formatOptions), hasTimeFormat && { timeStyle: utcTimeFormat }));
  const defaultUTCSuffix = timeFormat2 === "full" ? "Coordinated Universal Time" : "UTC";
  const createUTCContent = (customSuffix) => `${utcDateString} ${customSuffix ? customSuffix : defaultUTCSuffix}`;
  const defaultDisplay = shouldDisplayUTC ? createUTCContent(displaySuffix) : `${dateAsLocaleString}${displaySuffix ? " " + displaySuffix : ""}`;
  const { dateTime } = props, propsWithoutDateTime = __rest(props, ["dateTime"]);
  const timestamp = React313.createElement(
    "span",
    Object.assign({ className: css(timestamp_default.timestamp, tooltip && timestamp_default.modifiers.helpText, className) }, tooltip && { tabIndex: 0 }, propsWithoutDateTime),
    React313.createElement("time", { className: `${timestamp_default.timestamp}__text`, dateTime: dateTime || new Date(date2).toISOString() }, !children2 ? defaultDisplay : children2)
  );
  return tooltip ? React313.createElement(Tooltip, Object.assign({ content: tooltip.variant === TimestampTooltipVariant.default ? createUTCContent(tooltip.suffix) : tooltip.content }, tooltip.tooltipProps), timestamp) : timestamp;
};
Timestamp.displayName = "Timestamp";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ToggleGroup/ToggleGroup.js
var React316 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ToggleGroup/toggle-group.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/ToggleGroup/toggle-group.css";
var toggle_group_default = {
  "modifiers": {
    "compact": "pf-m-compact",
    "selected": "pf-m-selected",
    "disabled": "pf-m-disabled"
  },
  "toggleGroup": "pf-v6-c-toggle-group",
  "toggleGroupButton": "pf-v6-c-toggle-group__button",
  "toggleGroupIcon": "pf-v6-c-toggle-group__icon",
  "toggleGroupItem": "pf-v6-c-toggle-group__item",
  "toggleGroupText": "pf-v6-c-toggle-group__text"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ToggleGroup/ToggleGroupItem.js
var React315 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ToggleGroup/ToggleGroupItemElement.js
var React314 = __toESM(require_react());
var ToggleGroupItemVariant;
(function(ToggleGroupItemVariant2) {
  ToggleGroupItemVariant2["icon"] = "icon";
  ToggleGroupItemVariant2["text"] = "text";
})(ToggleGroupItemVariant || (ToggleGroupItemVariant = {}));
var ToggleGroupItemElement = ({ variant, children: children2 }) => React314.createElement("span", { className: css(variant === "icon" && toggle_group_default.toggleGroupIcon, variant === "text" && toggle_group_default.toggleGroupText) }, children2);
ToggleGroupItemElement.displayName = "ToggleGroupItemElement";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ToggleGroup/ToggleGroupItem.js
var ToggleGroupItem = (_a2) => {
  var { text, icon, iconPosition = "start", className, isDisabled = false, isSelected = false, "aria-label": ariaLabel, onChange = () => {
  }, buttonId } = _a2, props = __rest(_a2, ["text", "icon", "iconPosition", "className", "isDisabled", "isSelected", "aria-label", "onChange", "buttonId"]);
  const handleChange = (event) => {
    onChange(event, !isSelected);
  };
  if (!ariaLabel && icon && !text) {
    console.warn("An accessible aria-label is required when using the toggle group item icon variant.");
  }
  const toggleGroupIcon = React315.createElement(ToggleGroupItemElement, { variant: ToggleGroupItemVariant.icon }, icon);
  return React315.createElement(
    "div",
    Object.assign({ className: css(toggle_group_default.toggleGroupItem, className) }, props),
    React315.createElement(
      "button",
      { type: "button", className: css(toggle_group_default.toggleGroupButton, isSelected && toggle_group_default.modifiers.selected), "aria-pressed": isSelected, onClick: handleChange, "aria-label": ariaLabel, disabled: isDisabled, id: buttonId },
      icon && iconPosition === "start" && toggleGroupIcon,
      text && React315.createElement(ToggleGroupItemElement, { variant: ToggleGroupItemVariant.text }, text),
      icon && iconPosition === "end" && toggleGroupIcon
    )
  );
};
ToggleGroupItem.displayName = "ToggleGroupItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/ToggleGroup/ToggleGroup.js
var ToggleGroup = (_a2) => {
  var { className, children: children2, isCompact = false, areAllGroupsDisabled = false, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["className", "children", "isCompact", "areAllGroupsDisabled", "aria-label"]);
  const toggleGroupItemList = React316.Children.map(children2, (child) => !(React316.isValidElement(child) && child.type === ToggleGroupItem) ? child : React316.cloneElement(child, areAllGroupsDisabled ? { isDisabled: true } : {}));
  return React316.createElement("div", Object.assign({ className: css(toggle_group_default.toggleGroup, isCompact && toggle_group_default.modifiers.compact, className), role: "group", "aria-label": ariaLabel }, props), toggleGroupItemList);
};
ToggleGroup.displayName = "ToggleGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/Toolbar.js
var React321 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Toolbar/toolbar.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Toolbar/toolbar.css";
var toolbar_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "hidden": "pf-m-hidden",
    "hiddenOnSm": "pf-m-hidden-on-sm",
    "visibleOnSm": "pf-m-visible-on-sm",
    "hiddenOnMd": "pf-m-hidden-on-md",
    "visibleOnMd": "pf-m-visible-on-md",
    "hiddenOnLg": "pf-m-hidden-on-lg",
    "visibleOnLg": "pf-m-visible-on-lg",
    "hiddenOnXl": "pf-m-hidden-on-xl",
    "visibleOnXl": "pf-m-visible-on-xl",
    "hiddenOn_2xl": "pf-m-hidden-on-2xl",
    "visibleOn_2xl": "pf-m-visible-on-2xl",
    "sticky": "pf-m-sticky",
    "static": "pf-m-static",
    "fullHeight": "pf-m-full-height",
    "pageInsets": "pf-m-page-insets",
    "primary": "pf-m-primary",
    "secondary": "pf-m-secondary",
    "noBackground": "pf-m-no-background",
    "pagination": "pf-m-pagination",
    "expandAll": "pf-m-expand-all",
    "expanded": "pf-m-expanded",
    "label": "pf-m-label",
    "overflowContainer": "pf-m-overflow-container",
    "iconButtonGroup": "pf-m-icon-button-group",
    "filterGroup": "pf-m-filter-group",
    "labelGroupContainer": "pf-m-label-group-container",
    "labelGroup": "pf-m-label-group",
    "alignStart": "pf-m-align-start",
    "alignCenter": "pf-m-align-center",
    "alignEnd": "pf-m-align-end",
    "flexGrow": "pf-m-flex-grow",
    "alignSelfStretch": "pf-m-align-self-stretch",
    "alignSelfBaseline": "pf-m-align-self-baseline",
    "alignSelfStart": "pf-m-align-self-start",
    "alignSelfCenter": "pf-m-align-self-center",
    "alignSelfEnd": "pf-m-align-self-end",
    "insetNone": "pf-m-inset-none",
    "insetXs": "pf-m-inset-xs",
    "insetSm": "pf-m-inset-sm",
    "insetMd": "pf-m-inset-md",
    "insetLg": "pf-m-inset-lg",
    "insetXl": "pf-m-inset-xl",
    "inset_2xl": "pf-m-inset-2xl",
    "inset_3xl": "pf-m-inset-3xl",
    "inset_4xl": "pf-m-inset-4xl",
    "wrap": "pf-m-wrap",
    "nowrap": "pf-m-nowrap",
    "alignItemsStretch": "pf-m-align-items-stretch",
    "alignItemsBaseline": "pf-m-align-items-baseline",
    "alignItemsStart": "pf-m-align-items-start",
    "alignItemsCenter": "pf-m-align-items-center",
    "alignItemsEnd": "pf-m-align-items-end",
    "gapNone": "pf-m-gap-none",
    "gapXs": "pf-m-gap-xs",
    "gapSm": "pf-m-gap-sm",
    "gapMd": "pf-m-gap-md",
    "gapLg": "pf-m-gap-lg",
    "gapXl": "pf-m-gap-xl",
    "gap_2xl": "pf-m-gap-2xl",
    "gap_3xl": "pf-m-gap-3xl",
    "gap_4xl": "pf-m-gap-4xl",
    "columnGapNone": "pf-m-column-gap-none",
    "rowGapNone": "pf-m-row-gap-none",
    "columnGapXs": "pf-m-column-gap-xs",
    "rowGapXs": "pf-m-row-gap-xs",
    "columnGapSm": "pf-m-column-gap-sm",
    "rowGapSm": "pf-m-row-gap-sm",
    "columnGapMd": "pf-m-column-gap-md",
    "rowGapMd": "pf-m-row-gap-md",
    "columnGapLg": "pf-m-column-gap-lg",
    "rowGapLg": "pf-m-row-gap-lg",
    "columnGapXl": "pf-m-column-gap-xl",
    "rowGapXl": "pf-m-row-gap-xl",
    "columnGap_2xl": "pf-m-column-gap-2xl",
    "rowGap_2xl": "pf-m-row-gap-2xl",
    "columnGap_3xl": "pf-m-column-gap-3xl",
    "rowGap_3xl": "pf-m-row-gap-3xl",
    "columnGap_4xl": "pf-m-column-gap-4xl",
    "rowGap_4xl": "pf-m-row-gap-4xl",
    "toggleGroup": "pf-m-toggle-group",
    "show": "pf-m-show",
    "hide": "pf-m-hide",
    "alignStartOnSm": "pf-m-align-start-on-sm",
    "alignCenterOnSm": "pf-m-align-center-on-sm",
    "alignEndOnSm": "pf-m-align-end-on-sm",
    "flexGrowOnSm": "pf-m-flex-grow-on-sm",
    "alignSelfStretchOnSm": "pf-m-align-self-stretch-on-sm",
    "alignSelfBaselineOnSm": "pf-m-align-self-baseline-on-sm",
    "alignSelfStartOnSm": "pf-m-align-self-start-on-sm",
    "alignSelfCenterOnSm": "pf-m-align-self-center-on-sm",
    "alignSelfEndOnSm": "pf-m-align-self-end-on-sm",
    "insetNoneOnSm": "pf-m-inset-none-on-sm",
    "insetXsOnSm": "pf-m-inset-xs-on-sm",
    "insetSmOnSm": "pf-m-inset-sm-on-sm",
    "insetMdOnSm": "pf-m-inset-md-on-sm",
    "insetLgOnSm": "pf-m-inset-lg-on-sm",
    "insetXlOnSm": "pf-m-inset-xl-on-sm",
    "inset_2xlOnSm": "pf-m-inset-2xl-on-sm",
    "inset_3xlOnSm": "pf-m-inset-3xl-on-sm",
    "inset_4xlOnSm": "pf-m-inset-4xl-on-sm",
    "wrapOnSm": "pf-m-wrap-on-sm",
    "nowrapOnSm": "pf-m-nowrap-on-sm",
    "alignItemsStretchOnSm": "pf-m-align-items-stretch-on-sm",
    "alignItemsBaselineOnSm": "pf-m-align-items-baseline-on-sm",
    "alignItemsStartOnSm": "pf-m-align-items-start-on-sm",
    "alignItemsCenterOnSm": "pf-m-align-items-center-on-sm",
    "alignItemsEndOnSm": "pf-m-align-items-end-on-sm",
    "gapNoneOnSm": "pf-m-gap-none-on-sm",
    "gapXsOnSm": "pf-m-gap-xs-on-sm",
    "gapSmOnSm": "pf-m-gap-sm-on-sm",
    "gapMdOnSm": "pf-m-gap-md-on-sm",
    "gapLgOnSm": "pf-m-gap-lg-on-sm",
    "gapXlOnSm": "pf-m-gap-xl-on-sm",
    "gap_2xlOnSm": "pf-m-gap-2xl-on-sm",
    "gap_3xlOnSm": "pf-m-gap-3xl-on-sm",
    "gap_4xlOnSm": "pf-m-gap-4xl-on-sm",
    "columnGapNoneOnSm": "pf-m-column-gap-none-on-sm",
    "rowGapNoneOnSm": "pf-m-row-gap-none-on-sm",
    "columnGapXsOnSm": "pf-m-column-gap-xs-on-sm",
    "rowGapXsOnSm": "pf-m-row-gap-xs-on-sm",
    "columnGapSmOnSm": "pf-m-column-gap-sm-on-sm",
    "rowGapSmOnSm": "pf-m-row-gap-sm-on-sm",
    "columnGapMdOnSm": "pf-m-column-gap-md-on-sm",
    "rowGapMdOnSm": "pf-m-row-gap-md-on-sm",
    "columnGapLgOnSm": "pf-m-column-gap-lg-on-sm",
    "rowGapLgOnSm": "pf-m-row-gap-lg-on-sm",
    "columnGapXlOnSm": "pf-m-column-gap-xl-on-sm",
    "rowGapXlOnSm": "pf-m-row-gap-xl-on-sm",
    "columnGap_2xlOnSm": "pf-m-column-gap-2xl-on-sm",
    "rowGap_2xlOnSm": "pf-m-row-gap-2xl-on-sm",
    "columnGap_3xlOnSm": "pf-m-column-gap-3xl-on-sm",
    "rowGap_3xlOnSm": "pf-m-row-gap-3xl-on-sm",
    "columnGap_4xlOnSm": "pf-m-column-gap-4xl-on-sm",
    "rowGap_4xlOnSm": "pf-m-row-gap-4xl-on-sm",
    "showOnSm": "pf-m-show-on-sm",
    "hideOnSm": "pf-m-hide-on-sm",
    "alignStartOnMd": "pf-m-align-start-on-md",
    "alignCenterOnMd": "pf-m-align-center-on-md",
    "alignEndOnMd": "pf-m-align-end-on-md",
    "flexGrowOnMd": "pf-m-flex-grow-on-md",
    "alignSelfStretchOnMd": "pf-m-align-self-stretch-on-md",
    "alignSelfBaselineOnMd": "pf-m-align-self-baseline-on-md",
    "alignSelfStartOnMd": "pf-m-align-self-start-on-md",
    "alignSelfCenterOnMd": "pf-m-align-self-center-on-md",
    "alignSelfEndOnMd": "pf-m-align-self-end-on-md",
    "insetNoneOnMd": "pf-m-inset-none-on-md",
    "insetXsOnMd": "pf-m-inset-xs-on-md",
    "insetSmOnMd": "pf-m-inset-sm-on-md",
    "insetMdOnMd": "pf-m-inset-md-on-md",
    "insetLgOnMd": "pf-m-inset-lg-on-md",
    "insetXlOnMd": "pf-m-inset-xl-on-md",
    "inset_2xlOnMd": "pf-m-inset-2xl-on-md",
    "inset_3xlOnMd": "pf-m-inset-3xl-on-md",
    "inset_4xlOnMd": "pf-m-inset-4xl-on-md",
    "wrapOnMd": "pf-m-wrap-on-md",
    "nowrapOnMd": "pf-m-nowrap-on-md",
    "alignItemsStretchOnMd": "pf-m-align-items-stretch-on-md",
    "alignItemsBaselineOnMd": "pf-m-align-items-baseline-on-md",
    "alignItemsStartOnMd": "pf-m-align-items-start-on-md",
    "alignItemsCenterOnMd": "pf-m-align-items-center-on-md",
    "alignItemsEndOnMd": "pf-m-align-items-end-on-md",
    "gapNoneOnMd": "pf-m-gap-none-on-md",
    "gapXsOnMd": "pf-m-gap-xs-on-md",
    "gapSmOnMd": "pf-m-gap-sm-on-md",
    "gapMdOnMd": "pf-m-gap-md-on-md",
    "gapLgOnMd": "pf-m-gap-lg-on-md",
    "gapXlOnMd": "pf-m-gap-xl-on-md",
    "gap_2xlOnMd": "pf-m-gap-2xl-on-md",
    "gap_3xlOnMd": "pf-m-gap-3xl-on-md",
    "gap_4xlOnMd": "pf-m-gap-4xl-on-md",
    "columnGapNoneOnMd": "pf-m-column-gap-none-on-md",
    "rowGapNoneOnMd": "pf-m-row-gap-none-on-md",
    "columnGapXsOnMd": "pf-m-column-gap-xs-on-md",
    "rowGapXsOnMd": "pf-m-row-gap-xs-on-md",
    "columnGapSmOnMd": "pf-m-column-gap-sm-on-md",
    "rowGapSmOnMd": "pf-m-row-gap-sm-on-md",
    "columnGapMdOnMd": "pf-m-column-gap-md-on-md",
    "rowGapMdOnMd": "pf-m-row-gap-md-on-md",
    "columnGapLgOnMd": "pf-m-column-gap-lg-on-md",
    "rowGapLgOnMd": "pf-m-row-gap-lg-on-md",
    "columnGapXlOnMd": "pf-m-column-gap-xl-on-md",
    "rowGapXlOnMd": "pf-m-row-gap-xl-on-md",
    "columnGap_2xlOnMd": "pf-m-column-gap-2xl-on-md",
    "rowGap_2xlOnMd": "pf-m-row-gap-2xl-on-md",
    "columnGap_3xlOnMd": "pf-m-column-gap-3xl-on-md",
    "rowGap_3xlOnMd": "pf-m-row-gap-3xl-on-md",
    "columnGap_4xlOnMd": "pf-m-column-gap-4xl-on-md",
    "rowGap_4xlOnMd": "pf-m-row-gap-4xl-on-md",
    "showOnMd": "pf-m-show-on-md",
    "hideOnMd": "pf-m-hide-on-md",
    "alignStartOnLg": "pf-m-align-start-on-lg",
    "alignCenterOnLg": "pf-m-align-center-on-lg",
    "alignEndOnLg": "pf-m-align-end-on-lg",
    "flexGrowOnLg": "pf-m-flex-grow-on-lg",
    "alignSelfStretchOnLg": "pf-m-align-self-stretch-on-lg",
    "alignSelfBaselineOnLg": "pf-m-align-self-baseline-on-lg",
    "alignSelfStartOnLg": "pf-m-align-self-start-on-lg",
    "alignSelfCenterOnLg": "pf-m-align-self-center-on-lg",
    "alignSelfEndOnLg": "pf-m-align-self-end-on-lg",
    "insetNoneOnLg": "pf-m-inset-none-on-lg",
    "insetXsOnLg": "pf-m-inset-xs-on-lg",
    "insetSmOnLg": "pf-m-inset-sm-on-lg",
    "insetMdOnLg": "pf-m-inset-md-on-lg",
    "insetLgOnLg": "pf-m-inset-lg-on-lg",
    "insetXlOnLg": "pf-m-inset-xl-on-lg",
    "inset_2xlOnLg": "pf-m-inset-2xl-on-lg",
    "inset_3xlOnLg": "pf-m-inset-3xl-on-lg",
    "inset_4xlOnLg": "pf-m-inset-4xl-on-lg",
    "wrapOnLg": "pf-m-wrap-on-lg",
    "nowrapOnLg": "pf-m-nowrap-on-lg",
    "alignItemsStretchOnLg": "pf-m-align-items-stretch-on-lg",
    "alignItemsBaselineOnLg": "pf-m-align-items-baseline-on-lg",
    "alignItemsStartOnLg": "pf-m-align-items-start-on-lg",
    "alignItemsCenterOnLg": "pf-m-align-items-center-on-lg",
    "alignItemsEndOnLg": "pf-m-align-items-end-on-lg",
    "gapNoneOnLg": "pf-m-gap-none-on-lg",
    "gapXsOnLg": "pf-m-gap-xs-on-lg",
    "gapSmOnLg": "pf-m-gap-sm-on-lg",
    "gapMdOnLg": "pf-m-gap-md-on-lg",
    "gapLgOnLg": "pf-m-gap-lg-on-lg",
    "gapXlOnLg": "pf-m-gap-xl-on-lg",
    "gap_2xlOnLg": "pf-m-gap-2xl-on-lg",
    "gap_3xlOnLg": "pf-m-gap-3xl-on-lg",
    "gap_4xlOnLg": "pf-m-gap-4xl-on-lg",
    "columnGapNoneOnLg": "pf-m-column-gap-none-on-lg",
    "rowGapNoneOnLg": "pf-m-row-gap-none-on-lg",
    "columnGapXsOnLg": "pf-m-column-gap-xs-on-lg",
    "rowGapXsOnLg": "pf-m-row-gap-xs-on-lg",
    "columnGapSmOnLg": "pf-m-column-gap-sm-on-lg",
    "rowGapSmOnLg": "pf-m-row-gap-sm-on-lg",
    "columnGapMdOnLg": "pf-m-column-gap-md-on-lg",
    "rowGapMdOnLg": "pf-m-row-gap-md-on-lg",
    "columnGapLgOnLg": "pf-m-column-gap-lg-on-lg",
    "rowGapLgOnLg": "pf-m-row-gap-lg-on-lg",
    "columnGapXlOnLg": "pf-m-column-gap-xl-on-lg",
    "rowGapXlOnLg": "pf-m-row-gap-xl-on-lg",
    "columnGap_2xlOnLg": "pf-m-column-gap-2xl-on-lg",
    "rowGap_2xlOnLg": "pf-m-row-gap-2xl-on-lg",
    "columnGap_3xlOnLg": "pf-m-column-gap-3xl-on-lg",
    "rowGap_3xlOnLg": "pf-m-row-gap-3xl-on-lg",
    "columnGap_4xlOnLg": "pf-m-column-gap-4xl-on-lg",
    "rowGap_4xlOnLg": "pf-m-row-gap-4xl-on-lg",
    "showOnLg": "pf-m-show-on-lg",
    "hideOnLg": "pf-m-hide-on-lg",
    "alignStartOnXl": "pf-m-align-start-on-xl",
    "alignCenterOnXl": "pf-m-align-center-on-xl",
    "alignEndOnXl": "pf-m-align-end-on-xl",
    "flexGrowOnXl": "pf-m-flex-grow-on-xl",
    "alignSelfStretchOnXl": "pf-m-align-self-stretch-on-xl",
    "alignSelfBaselineOnXl": "pf-m-align-self-baseline-on-xl",
    "alignSelfStartOnXl": "pf-m-align-self-start-on-xl",
    "alignSelfCenterOnXl": "pf-m-align-self-center-on-xl",
    "alignSelfEndOnXl": "pf-m-align-self-end-on-xl",
    "insetNoneOnXl": "pf-m-inset-none-on-xl",
    "insetXsOnXl": "pf-m-inset-xs-on-xl",
    "insetSmOnXl": "pf-m-inset-sm-on-xl",
    "insetMdOnXl": "pf-m-inset-md-on-xl",
    "insetLgOnXl": "pf-m-inset-lg-on-xl",
    "insetXlOnXl": "pf-m-inset-xl-on-xl",
    "inset_2xlOnXl": "pf-m-inset-2xl-on-xl",
    "inset_3xlOnXl": "pf-m-inset-3xl-on-xl",
    "inset_4xlOnXl": "pf-m-inset-4xl-on-xl",
    "wrapOnXl": "pf-m-wrap-on-xl",
    "nowrapOnXl": "pf-m-nowrap-on-xl",
    "alignItemsStretchOnXl": "pf-m-align-items-stretch-on-xl",
    "alignItemsBaselineOnXl": "pf-m-align-items-baseline-on-xl",
    "alignItemsStartOnXl": "pf-m-align-items-start-on-xl",
    "alignItemsCenterOnXl": "pf-m-align-items-center-on-xl",
    "alignItemsEndOnXl": "pf-m-align-items-end-on-xl",
    "gapNoneOnXl": "pf-m-gap-none-on-xl",
    "gapXsOnXl": "pf-m-gap-xs-on-xl",
    "gapSmOnXl": "pf-m-gap-sm-on-xl",
    "gapMdOnXl": "pf-m-gap-md-on-xl",
    "gapLgOnXl": "pf-m-gap-lg-on-xl",
    "gapXlOnXl": "pf-m-gap-xl-on-xl",
    "gap_2xlOnXl": "pf-m-gap-2xl-on-xl",
    "gap_3xlOnXl": "pf-m-gap-3xl-on-xl",
    "gap_4xlOnXl": "pf-m-gap-4xl-on-xl",
    "columnGapNoneOnXl": "pf-m-column-gap-none-on-xl",
    "rowGapNoneOnXl": "pf-m-row-gap-none-on-xl",
    "columnGapXsOnXl": "pf-m-column-gap-xs-on-xl",
    "rowGapXsOnXl": "pf-m-row-gap-xs-on-xl",
    "columnGapSmOnXl": "pf-m-column-gap-sm-on-xl",
    "rowGapSmOnXl": "pf-m-row-gap-sm-on-xl",
    "columnGapMdOnXl": "pf-m-column-gap-md-on-xl",
    "rowGapMdOnXl": "pf-m-row-gap-md-on-xl",
    "columnGapLgOnXl": "pf-m-column-gap-lg-on-xl",
    "rowGapLgOnXl": "pf-m-row-gap-lg-on-xl",
    "columnGapXlOnXl": "pf-m-column-gap-xl-on-xl",
    "rowGapXlOnXl": "pf-m-row-gap-xl-on-xl",
    "columnGap_2xlOnXl": "pf-m-column-gap-2xl-on-xl",
    "rowGap_2xlOnXl": "pf-m-row-gap-2xl-on-xl",
    "columnGap_3xlOnXl": "pf-m-column-gap-3xl-on-xl",
    "rowGap_3xlOnXl": "pf-m-row-gap-3xl-on-xl",
    "columnGap_4xlOnXl": "pf-m-column-gap-4xl-on-xl",
    "rowGap_4xlOnXl": "pf-m-row-gap-4xl-on-xl",
    "showOnXl": "pf-m-show-on-xl",
    "hideOnXl": "pf-m-hide-on-xl",
    "alignStartOn_2xl": "pf-m-align-start-on-2xl",
    "alignCenterOn_2xl": "pf-m-align-center-on-2xl",
    "alignEndOn_2xl": "pf-m-align-end-on-2xl",
    "flexGrowOn_2xl": "pf-m-flex-grow-on-2xl",
    "alignSelfStretchOn_2xl": "pf-m-align-self-stretch-on-2xl",
    "alignSelfBaselineOn_2xl": "pf-m-align-self-baseline-on-2xl",
    "alignSelfStartOn_2xl": "pf-m-align-self-start-on-2xl",
    "alignSelfCenterOn_2xl": "pf-m-align-self-center-on-2xl",
    "alignSelfEndOn_2xl": "pf-m-align-self-end-on-2xl",
    "insetNoneOn_2xl": "pf-m-inset-none-on-2xl",
    "insetXsOn_2xl": "pf-m-inset-xs-on-2xl",
    "insetSmOn_2xl": "pf-m-inset-sm-on-2xl",
    "insetMdOn_2xl": "pf-m-inset-md-on-2xl",
    "insetLgOn_2xl": "pf-m-inset-lg-on-2xl",
    "insetXlOn_2xl": "pf-m-inset-xl-on-2xl",
    "inset_2xlOn_2xl": "pf-m-inset-2xl-on-2xl",
    "inset_3xlOn_2xl": "pf-m-inset-3xl-on-2xl",
    "inset_4xlOn_2xl": "pf-m-inset-4xl-on-2xl",
    "wrapOn_2xl": "pf-m-wrap-on-2xl",
    "nowrapOn_2xl": "pf-m-nowrap-on-2xl",
    "alignItemsStretchOn_2xl": "pf-m-align-items-stretch-on-2xl",
    "alignItemsBaselineOn_2xl": "pf-m-align-items-baseline-on-2xl",
    "alignItemsStartOn_2xl": "pf-m-align-items-start-on-2xl",
    "alignItemsCenterOn_2xl": "pf-m-align-items-center-on-2xl",
    "alignItemsEndOn_2xl": "pf-m-align-items-end-on-2xl",
    "gapNoneOn_2xl": "pf-m-gap-none-on-2xl",
    "gapXsOn_2xl": "pf-m-gap-xs-on-2xl",
    "gapSmOn_2xl": "pf-m-gap-sm-on-2xl",
    "gapMdOn_2xl": "pf-m-gap-md-on-2xl",
    "gapLgOn_2xl": "pf-m-gap-lg-on-2xl",
    "gapXlOn_2xl": "pf-m-gap-xl-on-2xl",
    "gap_2xlOn_2xl": "pf-m-gap-2xl-on-2xl",
    "gap_3xlOn_2xl": "pf-m-gap-3xl-on-2xl",
    "gap_4xlOn_2xl": "pf-m-gap-4xl-on-2xl",
    "columnGapNoneOn_2xl": "pf-m-column-gap-none-on-2xl",
    "rowGapNoneOn_2xl": "pf-m-row-gap-none-on-2xl",
    "columnGapXsOn_2xl": "pf-m-column-gap-xs-on-2xl",
    "rowGapXsOn_2xl": "pf-m-row-gap-xs-on-2xl",
    "columnGapSmOn_2xl": "pf-m-column-gap-sm-on-2xl",
    "rowGapSmOn_2xl": "pf-m-row-gap-sm-on-2xl",
    "columnGapMdOn_2xl": "pf-m-column-gap-md-on-2xl",
    "rowGapMdOn_2xl": "pf-m-row-gap-md-on-2xl",
    "columnGapLgOn_2xl": "pf-m-column-gap-lg-on-2xl",
    "rowGapLgOn_2xl": "pf-m-row-gap-lg-on-2xl",
    "columnGapXlOn_2xl": "pf-m-column-gap-xl-on-2xl",
    "rowGapXlOn_2xl": "pf-m-row-gap-xl-on-2xl",
    "columnGap_2xlOn_2xl": "pf-m-column-gap-2xl-on-2xl",
    "rowGap_2xlOn_2xl": "pf-m-row-gap-2xl-on-2xl",
    "columnGap_3xlOn_2xl": "pf-m-column-gap-3xl-on-2xl",
    "rowGap_3xlOn_2xl": "pf-m-row-gap-3xl-on-2xl",
    "columnGap_4xlOn_2xl": "pf-m-column-gap-4xl-on-2xl",
    "rowGap_4xlOn_2xl": "pf-m-row-gap-4xl-on-2xl",
    "showOn_2xl": "pf-m-show-on-2xl",
    "hideOn_2xl": "pf-m-hide-on-2xl"
  },
  "pagination": "pf-v6-c-pagination",
  "toolbar": "pf-v6-c-toolbar",
  "toolbarContent": "pf-v6-c-toolbar__content",
  "toolbarContentSection": "pf-v6-c-toolbar__content-section",
  "toolbarExpandAllIcon": "pf-v6-c-toolbar__expand-all-icon",
  "toolbarExpandableContent": "pf-v6-c-toolbar__expandable-content",
  "toolbarGroup": "pf-v6-c-toolbar__group",
  "toolbarItem": "pf-v6-c-toolbar__item",
  "toolbarToggle": "pf-v6-c-toolbar__toggle"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarUtils.js
var React317 = __toESM(require_react());
var ToolbarContext = React317.createContext({
  isExpanded: false,
  toggleIsExpanded: () => {
  },
  chipGroupContentRef: null,
  updateNumberFilters: () => {
  },
  numberOfFilters: 0,
  clearAllFilters: () => {
  }
});
var ToolbarContentContext = React317.createContext({
  expandableContentRef: null,
  expandableContentId: "",
  chipContainerRef: null,
  clearAllFilters: () => {
  }
});
var globalBreakpoints = {
  md: parseInt(global_breakpoint_md_default.value),
  lg: parseInt(global_breakpoint_lg_default.value),
  xl: parseInt(global_breakpoint_xl_default.value),
  "2xl": parseInt(global_breakpoint_2xl_default.value)
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarChipGroupContent.js
var React320 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarItem.js
var React318 = __toESM(require_react());
var ToolbarItemVariant;
(function(ToolbarItemVariant2) {
  ToolbarItemVariant2["separator"] = "separator";
  ToolbarItemVariant2["pagination"] = "pagination";
  ToolbarItemVariant2["label"] = "label";
  ToolbarItemVariant2["chip-group"] = "chip-group";
  ToolbarItemVariant2["expand-all"] = "expand-all";
})(ToolbarItemVariant || (ToolbarItemVariant = {}));
var ToolbarItem = (_a2) => {
  var { className, variant, visibility, gap, columnGap, rowGap, align, alignSelf, alignItems, id: id2, children: children2, isAllExpanded, isOverflowContainer } = _a2, props = __rest(_a2, ["className", "variant", "visibility", "gap", "columnGap", "rowGap", "align", "alignSelf", "alignItems", "id", "children", "isAllExpanded", "isOverflowContainer"]);
  if (variant === ToolbarItemVariant.separator) {
    return React318.createElement(Divider, Object.assign({ className: css(className), orientation: { default: "vertical" } }, props));
  }
  return React318.createElement(PageContext.Consumer, null, ({ width, getBreakpoint: getBreakpoint2 }) => React318.createElement("div", Object.assign({ className: css(toolbar_default.toolbarItem, variant && toolbar_default.modifiers[toCamel(variant)], variant === ToolbarItemVariant["chip-group"] && toolbar_default.modifiers.labelGroup, isAllExpanded && toolbar_default.modifiers.expanded, isOverflowContainer && toolbar_default.modifiers.overflowContainer, formatBreakpointMods(visibility, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(align, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(gap, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(columnGap, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(rowGap, toolbar_default, "", getBreakpoint2(width)), alignItems === "start" && toolbar_default.modifiers.alignItemsStart, alignItems === "center" && toolbar_default.modifiers.alignItemsCenter, alignItems === "baseline" && toolbar_default.modifiers.alignItemsBaseline, alignSelf === "start" && toolbar_default.modifiers.alignSelfStart, alignSelf === "center" && toolbar_default.modifiers.alignSelfCenter, alignSelf === "baseline" && toolbar_default.modifiers.alignSelfBaseline, className) }, variant === "label" && { "aria-hidden": true }, { id: id2 }, props), children2));
};
ToolbarItem.displayName = "ToolbarItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarGroup.js
var React319 = __toESM(require_react());
var ToolbarGroupVariant;
(function(ToolbarGroupVariant2) {
  ToolbarGroupVariant2["filter-group"] = "filter-group";
  ToolbarGroupVariant2["icon-button-group"] = "icon-button-group";
})(ToolbarGroupVariant || (ToolbarGroupVariant = {}));
var ToolbarGroupWithRef = class extends React319.Component {
  render() {
    const _a2 = this.props, { visibility, align, alignItems, alignSelf, gap, columnGap, rowGap, className, variant, children: children2, isOverflowContainer, innerRef } = _a2, props = __rest(_a2, ["visibility", "align", "alignItems", "alignSelf", "gap", "columnGap", "rowGap", "className", "variant", "children", "isOverflowContainer", "innerRef"]);
    return React319.createElement(PageContext.Consumer, null, ({ width, getBreakpoint: getBreakpoint2 }) => React319.createElement("div", Object.assign({ className: css(toolbar_default.toolbarGroup, variant && toolbar_default.modifiers[toCamel(variant)], formatBreakpointMods(visibility, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(align, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(gap, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(columnGap, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(rowGap, toolbar_default, "", getBreakpoint2(width)), alignItems === "start" && toolbar_default.modifiers.alignItemsStart, alignItems === "center" && toolbar_default.modifiers.alignItemsCenter, alignItems === "baseline" && toolbar_default.modifiers.alignItemsBaseline, alignSelf === "start" && toolbar_default.modifiers.alignSelfStart, alignSelf === "center" && toolbar_default.modifiers.alignSelfCenter, alignSelf === "baseline" && toolbar_default.modifiers.alignSelfBaseline, isOverflowContainer && toolbar_default.modifiers.overflowContainer, className) }, props, { ref: innerRef }), children2));
  }
};
var ToolbarGroup = React319.forwardRef((props, ref) => React319.createElement(ToolbarGroupWithRef, Object.assign({}, props, { innerRef: ref })));

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarChipGroupContent.js
var ToolbarChipGroupContent = class extends React320.Component {
  render() {
    const _a2 = this.props, { className, isExpanded, chipGroupContentRef, clearAllFilters, showClearFiltersButton, clearFiltersButtonText, collapseListedFiltersBreakpoint, numberOfFilters, numberOfFiltersText, customChipGroupContent } = _a2, props = __rest(_a2, ["className", "isExpanded", "chipGroupContentRef", "clearAllFilters", "showClearFiltersButton", "clearFiltersButtonText", "collapseListedFiltersBreakpoint", "numberOfFilters", "numberOfFiltersText", "customChipGroupContent"]);
    const clearChipGroups = () => {
      clearAllFilters();
    };
    let collapseListedFilters = false;
    if (collapseListedFiltersBreakpoint === "all") {
      collapseListedFilters = true;
    } else if (canUseDOM) {
      collapseListedFilters = (canUseDOM ? window.innerWidth : 1200) < globalBreakpoints[collapseListedFiltersBreakpoint];
    }
    const isHidden = numberOfFilters === 0 || isExpanded;
    return React320.createElement(
      "div",
      Object.assign({ className: css(toolbar_default.toolbarContent, isHidden && toolbar_default.modifiers.hidden, className) }, (numberOfFilters === 0 || isExpanded) && { hidden: true }, { ref: chipGroupContentRef }, props),
      React320.createElement(ToolbarGroup, Object.assign({ className: css(collapseListedFilters && toolbar_default.modifiers.hidden) }, collapseListedFilters && { hidden: true }, collapseListedFilters && { "aria-hidden": true })),
      collapseListedFilters && numberOfFilters > 0 && !isExpanded && React320.createElement(
        ToolbarGroup,
        null,
        React320.createElement(ToolbarItem, null, numberOfFiltersText(numberOfFilters))
      ),
      showClearFiltersButton && !isExpanded && !customChipGroupContent && React320.createElement(
        ToolbarItem,
        null,
        React320.createElement(Button, { variant: "link", onClick: clearChipGroups, isInline: true }, clearFiltersButtonText)
      ),
      customChipGroupContent && customChipGroupContent
    );
  }
};
ToolbarChipGroupContent.displayName = "ToolbarChipGroupContent";
ToolbarChipGroupContent.defaultProps = {
  clearFiltersButtonText: "Clear all filters",
  collapseListedFiltersBreakpoint: "lg",
  numberOfFiltersText: (numberOfFilters) => `${numberOfFilters} filters applied`
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/Toolbar.js
var ToolbarColorVariant;
(function(ToolbarColorVariant2) {
  ToolbarColorVariant2["default"] = "default";
  ToolbarColorVariant2["primary"] = "primary";
  ToolbarColorVariant2["secondary"] = "secondary";
  ToolbarColorVariant2["noBackground"] = "no-background";
})(ToolbarColorVariant || (ToolbarColorVariant = {}));
var Toolbar = class _Toolbar extends React321.Component {
  constructor() {
    super(...arguments);
    this.chipGroupContentRef = React321.createRef();
    this.staticFilterInfo = {};
    this.state = {
      isManagedToggleExpanded: false,
      filterInfo: {},
      windowWidth: canUseDOM ? window.innerWidth : 1200,
      ouiaStateId: getDefaultOUIAId(_Toolbar.displayName)
    };
    this.isToggleManaged = () => !(this.props.isExpanded || !!this.props.toggleIsExpanded);
    this.toggleIsExpanded = () => {
      this.setState((prevState) => ({
        isManagedToggleExpanded: !prevState.isManagedToggleExpanded
      }));
    };
    this.closeExpandableContent = (e) => {
      if (e.target.innerWidth !== this.state.windowWidth) {
        this.setState(() => ({
          isManagedToggleExpanded: false,
          windowWidth: e.target.innerWidth
        }));
      }
    };
    this.updateNumberFilters = (categoryName, numberOfFilters) => {
      const filterInfoToUpdate = Object.assign({}, this.staticFilterInfo);
      if (!filterInfoToUpdate.hasOwnProperty(categoryName) || filterInfoToUpdate[categoryName] !== numberOfFilters) {
        filterInfoToUpdate[categoryName] = numberOfFilters;
        this.staticFilterInfo = filterInfoToUpdate;
        this.setState({ filterInfo: filterInfoToUpdate });
      }
    };
    this.getNumberOfFilters = () => Object.values(this.state.filterInfo).reduce((acc, cur) => acc + cur, 0);
    this.renderToolbar = (randomId) => {
      const _a2 = this.props, { clearAllFilters, clearFiltersButtonText, collapseListedFiltersBreakpoint, isExpanded: isExpandedProp, toggleIsExpanded, className, children: children2, isFullHeight, isStatic, inset, usePageInsets, isSticky, ouiaId, numberOfFiltersText, customChipGroupContent, colorVariant = ToolbarColorVariant.default } = _a2, props = __rest(_a2, ["clearAllFilters", "clearFiltersButtonText", "collapseListedFiltersBreakpoint", "isExpanded", "toggleIsExpanded", "className", "children", "isFullHeight", "isStatic", "inset", "usePageInsets", "isSticky", "ouiaId", "numberOfFiltersText", "customChipGroupContent", "colorVariant"]);
      const { isManagedToggleExpanded } = this.state;
      const isToggleManaged = this.isToggleManaged();
      const isExpanded = isToggleManaged ? isManagedToggleExpanded : isExpandedProp;
      const numberOfFilters = this.getNumberOfFilters();
      const showClearFiltersButton = numberOfFilters > 0;
      return React321.createElement(PageContext.Consumer, null, ({ width, getBreakpoint: getBreakpoint2 }) => React321.createElement(
        "div",
        Object.assign({ className: css(toolbar_default.toolbar, isFullHeight && toolbar_default.modifiers.fullHeight, isStatic && toolbar_default.modifiers.static, usePageInsets && toolbar_default.modifiers.pageInsets, isSticky && toolbar_default.modifiers.sticky, formatBreakpointMods(inset, toolbar_default, "", getBreakpoint2(width)), colorVariant === "primary" && toolbar_default.modifiers.primary, colorVariant === "secondary" && toolbar_default.modifiers.secondary, colorVariant === "no-background" && toolbar_default.modifiers.noBackground, className), id: randomId }, getOUIAProps(_Toolbar.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId), props),
        React321.createElement(
          ToolbarContext.Provider,
          { value: {
            isExpanded,
            toggleIsExpanded: isToggleManaged ? this.toggleIsExpanded : toggleIsExpanded,
            chipGroupContentRef: this.chipGroupContentRef,
            updateNumberFilters: this.updateNumberFilters,
            numberOfFilters,
            clearAllFilters,
            clearFiltersButtonText,
            showClearFiltersButton,
            toolbarId: randomId,
            customChipGroupContent
          } },
          children2,
          React321.createElement(ToolbarChipGroupContent, { isExpanded, chipGroupContentRef: this.chipGroupContentRef, clearAllFilters, showClearFiltersButton, clearFiltersButtonText, numberOfFilters, numberOfFiltersText, collapseListedFiltersBreakpoint, customChipGroupContent })
        )
      ));
    };
  }
  componentDidMount() {
    if (this.isToggleManaged() && canUseDOM) {
      window.addEventListener("resize", this.closeExpandableContent);
    }
  }
  componentWillUnmount() {
    if (this.isToggleManaged() && canUseDOM) {
      window.removeEventListener("resize", this.closeExpandableContent);
    }
  }
  render() {
    return this.props.id ? this.renderToolbar(this.props.id) : React321.createElement(GenerateId, null, (randomId) => this.renderToolbar(randomId));
  }
};
Toolbar.displayName = "Toolbar";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarContent.js
var React322 = __toESM(require_react());
var ToolbarContent = class _ToolbarContent extends React322.Component {
  constructor() {
    super(...arguments);
    this.expandableContentRef = React322.createRef();
    this.chipContainerRef = React322.createRef();
  }
  render() {
    const _a2 = this.props, { className, children: children2, isExpanded, toolbarId, visibility, alignItems, clearAllFilters, showClearFiltersButton, clearFiltersButtonText, alignSelf } = _a2, props = __rest(_a2, ["className", "children", "isExpanded", "toolbarId", "visibility", "alignItems", "clearAllFilters", "showClearFiltersButton", "clearFiltersButtonText", "alignSelf"]);
    return React322.createElement(PageContext.Consumer, null, ({ width, getBreakpoint: getBreakpoint2 }) => React322.createElement(
      "div",
      Object.assign({ className: css(toolbar_default.toolbarContent, formatBreakpointMods(visibility, toolbar_default, "", getBreakpoint2(width)), className), ref: this.expandableContentRef }, props),
      React322.createElement(ToolbarContext.Consumer, null, ({ clearAllFilters: clearAllFiltersContext, clearFiltersButtonText: clearFiltersButtonContext, showClearFiltersButton: showClearFiltersButtonContext, isExpanded: isExpandedContext, toolbarId: toolbarIdContext }) => {
        const expandableContentId = `${toolbarId || toolbarIdContext}-expandable-content-${_ToolbarContent.currentId++}`;
        return React322.createElement(
          ToolbarContentContext.Provider,
          { value: {
            expandableContentRef: this.expandableContentRef,
            expandableContentId,
            chipContainerRef: this.chipContainerRef,
            isExpanded: isExpanded || isExpandedContext,
            clearAllFilters: clearAllFilters || clearAllFiltersContext,
            clearFiltersButtonText: clearFiltersButtonText || clearFiltersButtonContext,
            showClearFiltersButton: showClearFiltersButton || showClearFiltersButtonContext
          } },
          React322.createElement("div", { className: css(toolbar_default.toolbarContentSection, alignItems === "center" && toolbar_default.modifiers.alignItemsCenter, alignItems === "start" && toolbar_default.modifiers.alignItemsStart, alignItems === "baseline" && toolbar_default.modifiers.alignItemsBaseline, alignSelf === "center" && toolbar_default.modifiers.alignSelfCenter, alignSelf === "start" && toolbar_default.modifiers.alignSelfStart, alignSelf === "baseline" && toolbar_default.modifiers.alignSelfBaseline) }, children2)
        );
      })
    ));
  }
};
ToolbarContent.displayName = "ToolbarContent";
ToolbarContent.currentId = 0;
ToolbarContent.defaultProps = {
  isExpanded: false,
  showClearFiltersButton: false
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarExpandIconWrapper.js
var React323 = __toESM(require_react());
var ToolbarExpandIconWrapper = (_a2) => {
  var { children: children2, className } = _a2, props = __rest(_a2, ["children", "className"]);
  return React323.createElement("span", Object.assign({}, props, { className: css(toolbar_default.toolbarExpandAllIcon, className) }), children2);
};
ToolbarExpandIconWrapper.displayName = "ToolbarExpandIconWrapper";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarExpandableContent.js
var React324 = __toESM(require_react());
var ToolbarExpandableContent = class extends React324.Component {
  render() {
    const _a2 = this.props, { children: children2, className, expandableContentRef, chipContainerRef, isExpanded, clearAllFilters, clearFiltersButtonText, showClearFiltersButton } = _a2, props = __rest(_a2, ["children", "className", "expandableContentRef", "chipContainerRef", "isExpanded", "clearAllFilters", "clearFiltersButtonText", "showClearFiltersButton"]);
    const { numberOfFilters, customChipGroupContent } = this.context;
    const clearChipGroups = () => {
      clearAllFilters();
    };
    return React324.createElement(
      "div",
      Object.assign({ className: css(toolbar_default.toolbarExpandableContent, isExpanded && toolbar_default.modifiers.expanded, className), ref: expandableContentRef }, props),
      React324.createElement(ToolbarGroup, null, children2),
      numberOfFilters > 0 && React324.createElement(
        ToolbarGroup,
        null,
        React324.createElement(ToolbarGroup, { ref: chipContainerRef }),
        showClearFiltersButton && !customChipGroupContent && React324.createElement(
          ToolbarItem,
          null,
          React324.createElement(Button, { variant: "link", onClick: clearChipGroups, isInline: true }, clearFiltersButtonText)
        ),
        customChipGroupContent && customChipGroupContent
      )
    );
  }
};
ToolbarExpandableContent.displayName = "ToolbarExpandableContent";
ToolbarExpandableContent.contextType = ToolbarContext;
ToolbarExpandableContent.defaultProps = {
  isExpanded: false,
  clearFiltersButtonText: "Clear all filters"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarFilter.js
var React325 = __toESM(require_react());
var ReactDOM6 = __toESM(require_react_dom());
var ToolbarFilter = class extends React325.Component {
  constructor(props) {
    super(props);
    this.state = {
      isMounted: false
    };
  }
  componentDidMount() {
    const { categoryName, chips } = this.props;
    this.context.updateNumberFilters(typeof categoryName !== "string" && categoryName.hasOwnProperty("key") ? categoryName.key : categoryName.toString(), chips.length);
    this.setState({ isMounted: true });
  }
  componentDidUpdate() {
    const { categoryName, chips } = this.props;
    this.context.updateNumberFilters(typeof categoryName !== "string" && categoryName.hasOwnProperty("key") ? categoryName.key : categoryName.toString(), chips.length);
  }
  render() {
    const _a2 = this.props, { children: children2, chips, deleteChipGroup, deleteChip, chipGroupExpandedText, chipGroupCollapsedText, categoryName, showToolbarItem, isExpanded, expandableChipContainerRef } = _a2, props = __rest(_a2, ["children", "chips", "deleteChipGroup", "deleteChip", "chipGroupExpandedText", "chipGroupCollapsedText", "categoryName", "showToolbarItem", "isExpanded", "expandableChipContainerRef"]);
    const { isExpanded: managedIsExpanded, chipGroupContentRef } = this.context;
    const _isExpanded = isExpanded !== void 0 ? isExpanded : managedIsExpanded;
    const categoryKey = typeof categoryName !== "string" && categoryName.hasOwnProperty("key") ? categoryName.key : categoryName.toString();
    const chipGroup = chips.length ? React325.createElement(
      ToolbarItem,
      { variant: "chip-group" },
      React325.createElement(LabelGroup, { key: categoryKey, categoryName: typeof categoryName === "string" ? categoryName : categoryName.name, isClosable: deleteChipGroup !== void 0, onClick: () => deleteChipGroup(categoryName), collapsedText: chipGroupCollapsedText, expandedText: chipGroupExpandedText }, chips.map((chip) => typeof chip === "string" ? React325.createElement(Label, { variant: "outline", key: chip, onClose: () => deleteChip(categoryKey, chip) }, chip) : React325.createElement(Label, { key: chip.key, onClose: () => deleteChip(categoryKey, chip) }, chip.node)))
    ) : null;
    if (!_isExpanded && this.state.isMounted) {
      return React325.createElement(
        React325.Fragment,
        null,
        showToolbarItem && React325.createElement(ToolbarItem, Object.assign({}, props), children2),
        ReactDOM6.createPortal(chipGroup, chipGroupContentRef.current.firstElementChild)
      );
    }
    return React325.createElement(ToolbarContentContext.Consumer, null, ({ chipContainerRef }) => React325.createElement(
      React325.Fragment,
      null,
      showToolbarItem && React325.createElement(ToolbarItem, Object.assign({}, props), children2),
      chipContainerRef.current && ReactDOM6.createPortal(chipGroup, chipContainerRef.current),
      expandableChipContainerRef && expandableChipContainerRef.current && ReactDOM6.createPortal(chipGroup, expandableChipContainerRef.current)
    ));
  }
};
ToolbarFilter.displayName = "ToolbarFilter";
ToolbarFilter.contextType = ToolbarContext;
ToolbarFilter.defaultProps = {
  chips: [],
  showToolbarItem: true
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Toolbar/ToolbarToggleGroup.js
var React326 = __toESM(require_react());
var ReactDOM7 = __toESM(require_react_dom());
var ToolbarToggleGroup = class extends React326.Component {
  constructor() {
    super(...arguments);
    this.toggleRef = React326.createRef();
    this.expandableContentRef = React326.createRef();
    this.isContentPopup = () => {
      const viewportSize = canUseDOM ? window.innerWidth : 1200;
      const lgBreakpointValue = parseInt(global_breakpoint_lg_default.value);
      return viewportSize < lgBreakpointValue;
    };
  }
  render() {
    const _a2 = this.props, { toggleIcon, variant, visibility, breakpoint, alignment, gap, columnGap, rowGap, className, children: children2, isExpanded, onToggle, chipContainerRef, clearAllFilters, showClearFiltersButton, clearFiltersButtonText } = _a2, props = __rest(_a2, ["toggleIcon", "variant", "visibility", "breakpoint", "alignment", "gap", "columnGap", "rowGap", "className", "children", "isExpanded", "onToggle", "chipContainerRef", "clearAllFilters", "showClearFiltersButton", "clearFiltersButtonText"]);
    if (!breakpoint && !toggleIcon) {
      console.error("ToolbarToggleGroup will not be visible without a breakpoint or toggleIcon.");
    }
    return React326.createElement(PageContext.Consumer, null, ({ width, getBreakpoint: getBreakpoint2 }) => React326.createElement(ToolbarContext.Consumer, null, ({ toggleIsExpanded: managedOnToggle }) => {
      const _onToggle = onToggle !== void 0 ? onToggle : managedOnToggle;
      return React326.createElement(ToolbarContentContext.Consumer, null, ({ expandableContentRef, expandableContentId, chipContainerRef: managedChipContainerRef, isExpanded: managedIsExpanded, clearAllFilters: clearAllFiltersContext, clearFiltersButtonText: clearFiltersButtonContext, showClearFiltersButton: showClearFiltersButtonContext }) => {
        const _isExpanded = isExpanded !== void 0 ? isExpanded : managedIsExpanded;
        const _chipContainerRef = chipContainerRef !== void 0 ? chipContainerRef : managedChipContainerRef;
        const breakpointMod = {};
        breakpointMod[breakpoint] = "show";
        const expandableContent = React326.createElement(ToolbarExpandableContent, { id: expandableContentId, expandableContentRef: this.expandableContentRef, isExpanded: _isExpanded, clearAllFilters: clearAllFilters || clearAllFiltersContext, showClearFiltersButton: showClearFiltersButton || showClearFiltersButtonContext, clearFiltersButtonText: clearFiltersButtonText || clearFiltersButtonContext, chipContainerRef: _chipContainerRef }, children2);
        const toggleButton = React326.createElement(
          "div",
          { className: css(toolbar_default.toolbarToggle) },
          React326.createElement(Button, Object.assign({ variant: "plain", onClick: _onToggle, "aria-label": "Show Filters" }, _isExpanded && { "aria-expanded": true }, { "aria-haspopup": _isExpanded && this.isContentPopup(), "aria-controls": _isExpanded ? expandableContentId : void 0, ref: this.toggleRef }), toggleIcon)
        );
        return React326.createElement(
          "div",
          Object.assign({ className: css(toolbar_default.toolbarGroup, toolbar_default.modifiers.toggleGroup, variant && toolbar_default.modifiers[toCamel(variant)], formatBreakpointMods(breakpointMod, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(visibility, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(alignment, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(gap, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(columnGap, toolbar_default, "", getBreakpoint2(width)), formatBreakpointMods(rowGap, toolbar_default, "", getBreakpoint2(width)), className) }, props),
          toggleButton,
          _isExpanded && ReactDOM7.createPortal(expandableContent, expandableContentRef.current),
          !_isExpanded && children2
        );
      });
    }));
  }
};
ToolbarToggleGroup.displayName = "ToolbarToggleGroup";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NumberInput/NumberInput.js
var React327 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/NumberInput/number-input.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/NumberInput/number-input.css";
var number_input_default = {
  "formControl": "pf-v6-c-form-control",
  "inputGroup": "pf-v6-c-input-group",
  "numberInput": "pf-v6-c-number-input",
  "numberInputIcon": "pf-v6-c-number-input__icon",
  "numberInputUnit": "pf-v6-c-number-input__unit"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/NumberInput/NumberInput.js
var defaultKeyDownHandler = (args) => (event) => {
  if (KeyTypes.ArrowUp === event.key && args.onPlus) {
    event.preventDefault();
    args.onPlus(null, args.inputName);
  }
  if (KeyTypes.ArrowDown === event.key && args.onMinus) {
    event.preventDefault();
    args.onMinus(null, args.inputName);
  }
};
var DEFAULT_VALUE = 0;
var NumberInput = (_a2) => {
  var { value = DEFAULT_VALUE, className, widthChars, isDisabled = false, validated = ValidatedOptions.default, onMinus = () => {
  }, onChange, onBlur, onPlus = () => {
  }, unit: unit2, unitPosition = "after", min: min4, max: max5, inputName, inputAriaLabel = "Input", minusBtnAriaLabel = "Minus", plusBtnAriaLabel = "Plus", inputProps, minusBtnProps, plusBtnProps } = _a2, props = __rest(_a2, ["value", "className", "widthChars", "isDisabled", "validated", "onMinus", "onChange", "onBlur", "onPlus", "unit", "unitPosition", "min", "max", "inputName", "inputAriaLabel", "minusBtnAriaLabel", "plusBtnAriaLabel", "inputProps", "minusBtnProps", "plusBtnProps"]);
  const numberInputUnit = React327.createElement("div", { className: css(number_input_default.numberInputUnit) }, unit2);
  const keyDownHandler = inputProps && inputProps.onKeyDown ? inputProps.onKeyDown : defaultKeyDownHandler({ inputName, onMinus, onPlus });
  const handleBlur = (event) => {
    event.target.value = Number(event.target.value).toString();
    if (onChange) {
      onChange(event);
    }
    if (onBlur) {
      onBlur(event);
    }
  };
  return React327.createElement(
    "div",
    Object.assign({
      // TODO: Update with issue #9978. Removed "validated !== 'default' && styles.modifiers.status" from classname to get build to work
      className: css(number_input_default.numberInput, className)
    }, widthChars && {
      style: Object.assign({ [c_number_input_c_form_control_width_chars_default.name]: widthChars }, props.style)
    }, props),
    unit2 && unitPosition === "before" && numberInputUnit,
    React327.createElement(
      InputGroup,
      null,
      React327.createElement(
        InputGroupItem,
        null,
        React327.createElement(
          Button,
          Object.assign({ variant: "control", "aria-label": minusBtnAriaLabel, isDisabled: isDisabled || (typeof value === "number" ? value : DEFAULT_VALUE) <= min4, onClick: (evt) => onMinus(evt, inputName) }, minusBtnProps),
          React327.createElement(
            "span",
            { className: css(number_input_default.numberInputIcon) },
            React327.createElement(minus_icon_default, { "aria-hidden": "true" })
          )
        )
      ),
      React327.createElement(
        InputGroupItem,
        null,
        React327.createElement(TextInput, Object.assign({}, inputProps, { type: "number", value, name: inputName, "aria-label": inputAriaLabel }, isDisabled && { isDisabled }, onChange && { onChange: (event, _value) => onChange(event) }, { onBlur: handleBlur }, !onChange && { readOnlyVariant: "default" }, { onKeyDown: keyDownHandler, validated }))
      ),
      React327.createElement(
        InputGroupItem,
        null,
        React327.createElement(
          Button,
          Object.assign({ variant: "control", "aria-label": plusBtnAriaLabel, isDisabled: isDisabled || (typeof value === "number" ? value : DEFAULT_VALUE) >= max5, onClick: (evt) => onPlus(evt, inputName) }, plusBtnProps),
          React327.createElement(
            "span",
            { className: css(number_input_default.numberInputIcon) },
            React327.createElement(plus_icon_default, { "aria-hidden": "true" })
          )
        )
      )
    ),
    unit2 && unitPosition === "after" && numberInputUnit
  );
};
NumberInput.displayName = "NumberInput";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TreeView/TreeView.js
var React331 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TreeView/TreeViewList.js
var React328 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/TreeView/tree-view.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/TreeView/tree-view.css";
var tree_view_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "compact": "pf-m-compact",
    "guides": "pf-m-guides",
    "expanded": "pf-m-expanded",
    "noBackground": "pf-m-no-background",
    "current": "pf-m-current",
    "truncate": "pf-m-truncate"
  },
  "treeView": "pf-v6-c-tree-view",
  "treeViewAction": "pf-v6-c-tree-view__action",
  "treeViewContent": "pf-v6-c-tree-view__content",
  "treeViewListItem": "pf-v6-c-tree-view__list-item",
  "treeViewNode": "pf-v6-c-tree-view__node",
  "treeViewNodeCheck": "pf-v6-c-tree-view__node-check",
  "treeViewNodeContainer": "pf-v6-c-tree-view__node-container",
  "treeViewNodeContent": "pf-v6-c-tree-view__node-content",
  "treeViewNodeCount": "pf-v6-c-tree-view__node-count",
  "treeViewNodeIcon": "pf-v6-c-tree-view__node-icon",
  "treeViewNodeText": "pf-v6-c-tree-view__node-text",
  "treeViewNodeTitle": "pf-v6-c-tree-view__node-title",
  "treeViewNodeToggle": "pf-v6-c-tree-view__node-toggle",
  "treeViewNodeToggleIcon": "pf-v6-c-tree-view__node-toggle-icon",
  "treeViewSearch": "pf-v6-c-tree-view__search"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TreeView/TreeViewList.js
var TreeViewList = (_a2) => {
  var { isNested = false, isMultiSelectable = false, toolbar, children: children2, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby } = _a2, props = __rest(_a2, ["isNested", "isMultiSelectable", "toolbar", "children", "aria-label", "aria-labelledby"]);
  return React328.createElement(
    React328.Fragment,
    null,
    toolbar && React328.createElement(
      React328.Fragment,
      null,
      toolbar,
      React328.createElement(Divider, null)
    ),
    React328.createElement("ul", Object.assign({ className: css(`${tree_view_default.treeView}__list`), role: isNested ? "group" : "tree", "aria-multiselectable": isNested ? void 0 : isMultiSelectable, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby }, props), children2)
  );
};
TreeViewList.displayName = "TreeViewList";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TreeView/TreeViewListItem.js
var import_react25 = __toESM(require_react());
var TreeViewListItemBase = ({
  name,
  title,
  id: id2,
  isExpanded,
  defaultExpanded = false,
  children: children2 = null,
  onSelect,
  onExpand,
  onCollapse,
  onCheck,
  hasCheckbox = false,
  checkProps = {
    checked: false
  },
  hasBadge = false,
  customBadgeContent,
  badgeProps = { isRead: true },
  isSelectable = false,
  isCompact,
  activeItems = [],
  itemData,
  parentItem,
  icon,
  expandedIcon,
  action: action2,
  compareItems,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  useMemo: useMemo26
}) => {
  const [internalIsExpanded, setIsExpanded] = (0, import_react25.useState)(defaultExpanded);
  (0, import_react25.useEffect)(() => {
    if (isExpanded !== void 0 && isExpanded !== null) {
      setIsExpanded(isExpanded);
    } else if (defaultExpanded !== void 0 && defaultExpanded !== null) {
      setIsExpanded(internalIsExpanded || defaultExpanded);
    }
  }, [isExpanded, defaultExpanded]);
  let Component50 = "button";
  if (hasCheckbox) {
    Component50 = "label";
  } else if (isSelectable) {
    Component50 = "div";
  }
  const ToggleComponent = hasCheckbox || isSelectable ? "button" : "span";
  const renderToggle = (randomId) => import_react25.default.createElement(
    ToggleComponent,
    Object.assign({ className: css(tree_view_default.treeViewNodeToggle), onClick: (evt) => {
      if (isSelectable || hasCheckbox) {
        if (internalIsExpanded) {
          onCollapse && onCollapse(evt, itemData, parentItem);
        } else {
          onExpand && onExpand(evt, itemData, parentItem);
        }
        setIsExpanded(!internalIsExpanded);
      }
      if (isSelectable) {
        evt.stopPropagation();
      }
    } }, (hasCheckbox || isSelectable) && { "aria-labelledby": `label-${randomId}` }, ToggleComponent === "button" && { type: "button" }, { tabIndex: -1 }),
    import_react25.default.createElement(
      "span",
      { className: css(tree_view_default.treeViewNodeToggleIcon) },
      import_react25.default.createElement(angle_right_icon_default, { "aria-hidden": "true" })
    )
  );
  const isCheckboxChecked = checkProps.checked === null ? false : checkProps.checked;
  const renderCheck = (randomId) => import_react25.default.createElement(
    "span",
    { className: css(tree_view_default.treeViewNodeCheck) },
    import_react25.default.createElement("input", Object.assign({ type: "checkbox", onChange: (evt) => onCheck && onCheck(evt, itemData, parentItem), onClick: (evt) => evt.stopPropagation(), ref: (elem) => elem && (elem.indeterminate = checkProps.checked === null) }, checkProps, { checked: isCheckboxChecked, id: randomId, tabIndex: -1 }))
  );
  const iconRendered = import_react25.default.createElement(
    "span",
    { className: css(tree_view_default.treeViewNodeIcon) },
    !internalIsExpanded && icon,
    internalIsExpanded && (expandedIcon || icon)
  );
  const renderNodeContent = () => {
    const content = import_react25.default.createElement(
      import_react25.default.Fragment,
      null,
      isCompact && title && import_react25.default.createElement("span", { className: css(tree_view_default.treeViewNodeTitle) }, title),
      isSelectable ? import_react25.default.createElement("button", { tabIndex: -1, className: css(tree_view_default.treeViewNodeText), type: "button" }, name) : import_react25.default.createElement("span", { className: css(tree_view_default.treeViewNodeText) }, name)
    );
    return isCompact ? import_react25.default.createElement("span", { className: css(tree_view_default.treeViewNodeContent) }, content) : content;
  };
  const badgeRendered = import_react25.default.createElement(
    import_react25.default.Fragment,
    null,
    hasBadge && children2 && import_react25.default.createElement(
      "span",
      { className: css(tree_view_default.treeViewNodeCount) },
      import_react25.default.createElement(Badge, Object.assign({}, badgeProps), customBadgeContent ? customBadgeContent : children2.props.data.length)
    ),
    hasBadge && !children2 && customBadgeContent !== void 0 && import_react25.default.createElement(
      "span",
      { className: css(tree_view_default.treeViewNodeCount) },
      import_react25.default.createElement(Badge, Object.assign({}, badgeProps), customBadgeContent)
    )
  );
  const isSelected = (!children2 || isSelectable) && activeItems && activeItems.length > 0 && activeItems.some((item) => compareItems && item && compareItems(item, itemData));
  return import_react25.default.createElement(
    "li",
    Object.assign({ id: id2, className: css(tree_view_default.treeViewListItem, internalIsExpanded && tree_view_default.modifiers.expanded), "aria-expanded": internalIsExpanded, role: "treeitem", tabIndex: -1 }, hasCheckbox && { "aria-checked": isCheckboxChecked }, !hasCheckbox && { "aria-selected": isSelected }),
    import_react25.default.createElement(
      "div",
      { className: css(tree_view_default.treeViewContent) },
      import_react25.default.createElement(GenerateId, { prefix: isSelectable ? "selectable-id" : "checkbox-id" }, (randomId) => import_react25.default.createElement(
        Component50,
        Object.assign({ className: css(tree_view_default.treeViewNode, isSelected && tree_view_default.modifiers.current), onClick: (evt) => {
          if (!hasCheckbox) {
            onSelect && onSelect(evt, itemData, parentItem);
            if (!isSelectable && children2 && evt.isDefaultPrevented() !== true) {
              if (internalIsExpanded) {
                onCollapse && onCollapse(evt, itemData, parentItem);
              } else {
                onExpand && onExpand(evt, itemData, parentItem);
              }
              setIsExpanded(!internalIsExpanded);
            }
          }
        } }, hasCheckbox && { htmlFor: randomId }, (hasCheckbox || isSelectable && children2) && { id: `label-${randomId}` }, Component50 === "button" && { type: "button" }),
        import_react25.default.createElement(
          "span",
          { className: css(tree_view_default.treeViewNodeContainer) },
          children2 && renderToggle(randomId),
          hasCheckbox && renderCheck(randomId),
          icon && iconRendered,
          renderNodeContent(),
          badgeRendered
        )
      )),
      action2 && import_react25.default.createElement("div", { className: css(tree_view_default.treeViewAction) }, action2)
    ),
    internalIsExpanded && children2
  );
};
var TreeViewListItem = import_react25.default.memo(TreeViewListItemBase, (prevProps, nextProps) => {
  if (!nextProps.useMemo) {
    return false;
  }
  const prevIncludes = prevProps.activeItems && prevProps.activeItems.length > 0 && prevProps.activeItems.some((item) => prevProps.compareItems && item && prevProps.compareItems(item, prevProps.itemData));
  const nextIncludes = nextProps.activeItems && nextProps.activeItems.length > 0 && nextProps.activeItems.some((item) => nextProps.compareItems && item && nextProps.compareItems(item, nextProps.itemData));
  if (prevIncludes || nextIncludes) {
    return false;
  }
  if (prevProps.name !== nextProps.name || prevProps.title !== nextProps.title || prevProps.id !== nextProps.id || prevProps.isExpanded !== nextProps.isExpanded || prevProps.defaultExpanded !== nextProps.defaultExpanded || prevProps.onSelect !== nextProps.onSelect || prevProps.onCheck !== nextProps.onCheck || prevProps.onExpand !== nextProps.onExpand || prevProps.onCollapse !== nextProps.onCollapse || prevProps.hasCheckbox !== nextProps.hasCheckbox || prevProps.checkProps !== nextProps.checkProps || prevProps.hasBadge !== nextProps.hasBadge || prevProps.customBadgeContent !== nextProps.customBadgeContent || prevProps.badgeProps !== nextProps.badgeProps || prevProps.isCompact !== nextProps.isCompact || prevProps.icon !== nextProps.icon || prevProps.expandedIcon !== nextProps.expandedIcon || prevProps.action !== nextProps.action || prevProps.parentItem !== nextProps.parentItem || prevProps.itemData !== nextProps.itemData) {
    return false;
  }
  return true;
});
TreeViewListItem.displayName = "TreeViewListItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TreeView/TreeViewRoot.js
var React330 = __toESM(require_react());
var TreeViewRoot = class extends React330.Component {
  constructor() {
    super(...arguments);
    this.displayName = "TreeViewRoot";
    this.treeRef = React330.createRef();
    this.handleKeys = (event) => {
      var _a2, _b, _c, _d, _e, _f, _g;
      if (!this.treeRef.current.contains(event.target) || !event.target.classList.contains(tree_view_default.treeViewNode)) {
        return;
      }
      const activeElement = document.activeElement;
      const key = event.key;
      const treeItems = Array.from((_a2 = this.treeRef.current) === null || _a2 === void 0 ? void 0 : _a2.getElementsByClassName(tree_view_default.treeViewNode)).filter((el) => !el.classList.contains("pf-m-disabled"));
      if (key === KeyTypes.Space) {
        activeElement.click();
        event.preventDefault();
      }
      handleArrows(event, treeItems, (element) => activeElement === element, void 0, [], void 0, true, true);
      if (["ArrowLeft", "ArrowRight"].includes(key)) {
        const isExpandable = (_c = (_b = activeElement === null || activeElement === void 0 ? void 0 : activeElement.firstElementChild) === null || _b === void 0 ? void 0 : _b.firstElementChild) === null || _c === void 0 ? void 0 : _c.classList.contains(tree_view_default.treeViewNodeToggle);
        const isExpanded = (_d = activeElement === null || activeElement === void 0 ? void 0 : activeElement.closest("li")) === null || _d === void 0 ? void 0 : _d.classList.contains("pf-m-expanded");
        if (key === "ArrowLeft") {
          if (isExpandable && isExpanded) {
            activeElement.click();
          } else {
            const parentList = (_e = activeElement === null || activeElement === void 0 ? void 0 : activeElement.closest("ul")) === null || _e === void 0 ? void 0 : _e.parentElement;
            if ((parentList === null || parentList === void 0 ? void 0 : parentList.tagName) !== "DIV") {
              const parentButton = parentList === null || parentList === void 0 ? void 0 : parentList.querySelector("button");
              activeElement.tabIndex = -1;
              if (parentButton) {
                parentButton.tabIndex = 0;
                parentButton.focus();
              }
            }
          }
        } else {
          if (isExpandable && !isExpanded) {
            activeElement.tabIndex = -1;
            activeElement.click();
            const childElement = (_g = (_f = activeElement === null || activeElement === void 0 ? void 0 : activeElement.closest("li")) === null || _f === void 0 ? void 0 : _f.querySelector("ul > li")) === null || _g === void 0 ? void 0 : _g.querySelector("button");
            if (childElement) {
              childElement.tabIndex = 0;
              childElement.focus();
            }
          }
        }
        event.preventDefault();
      }
    };
    this.handleKeysCheckbox = (event) => {
      var _a2, _b, _c, _d, _e;
      if (!this.treeRef.current.contains(event.target)) {
        return;
      }
      const activeElement = document.activeElement;
      const key = event.key;
      if (key === KeyTypes.Space) {
        activeElement.click();
        event.preventDefault();
      }
      const treeNodes = Array.from((_a2 = this.treeRef.current) === null || _a2 === void 0 ? void 0 : _a2.getElementsByClassName(tree_view_default.treeViewNode));
      handleArrows(event, treeNodes, (element) => element.contains(activeElement), (element) => element.querySelector("button,input"), [], void 0, true, true);
      if (["ArrowLeft", "ArrowRight"].includes(key)) {
        if (key === "ArrowLeft") {
          if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "INPUT") {
            ((_b = activeElement === null || activeElement === void 0 ? void 0 : activeElement.parentElement) === null || _b === void 0 ? void 0 : _b.previousSibling) && activeElement.parentElement.previousSibling.focus();
          } else if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.previousSibling) {
            if (((_c = activeElement.previousElementSibling) === null || _c === void 0 ? void 0 : _c.tagName) === "SPAN") {
              activeElement.previousSibling.firstChild.focus();
            } else {
              activeElement.previousSibling.focus();
            }
          }
        } else {
          if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "INPUT") {
            ((_d = activeElement.parentElement) === null || _d === void 0 ? void 0 : _d.nextSibling) && activeElement.parentElement.nextSibling.focus();
          } else if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.nextSibling) {
            if (((_e = activeElement.nextElementSibling) === null || _e === void 0 ? void 0 : _e.tagName) === "SPAN") {
              activeElement.nextSibling.firstChild.focus();
            } else {
              activeElement.nextSibling.focus();
            }
          }
        }
        event.preventDefault();
      }
    };
    this.variantStyleModifiers = {
      default: "",
      compact: tree_view_default.modifiers.compact,
      compactNoBackground: [tree_view_default.modifiers.compact, tree_view_default.modifiers.noBackground]
    };
  }
  componentDidMount() {
    var _a2;
    if (canUseDOM) {
      window.addEventListener("keydown", this.props.hasCheckboxes || this.props.hasSelectableNodes ? this.handleKeysCheckbox : this.handleKeys);
    }
    if (this.props.hasCheckboxes || this.props.hasSelectableNodes) {
      const firstToggle = this.treeRef.current.getElementsByClassName(tree_view_default.treeViewNodeToggle)[0];
      if (firstToggle) {
        firstToggle.tabIndex = 0;
      }
      if (this.props.hasCheckboxes) {
        const firstInput = this.treeRef.current.getElementsByTagName("INPUT")[0];
        if (firstInput) {
          firstInput.tabIndex = 0;
        }
      }
      if (this.props.hasSelectableNodes) {
        const firstTextButton = this.treeRef.current.getElementsByClassName(tree_view_default.treeViewNodeText)[0];
        if (firstTextButton) {
          firstTextButton.tabIndex = 0;
        }
      }
    } else {
      ((_a2 = this.treeRef.current) === null || _a2 === void 0 ? void 0 : _a2.getElementsByClassName(tree_view_default.treeViewNode)[0]).tabIndex = 0;
    }
  }
  componentWillUnmount() {
    if (canUseDOM) {
      window.removeEventListener("keydown", this.props.hasCheckboxes || this.props.hasSelectableNodes ? this.handleKeysCheckbox : this.handleKeys);
    }
  }
  render() {
    const _a2 = this.props, { children: children2, hasCheckboxes, hasGuides, variant, className, hasSelectableNodes } = _a2, props = __rest(_a2, ["children", "hasCheckboxes", "hasGuides", "variant", "className", "hasSelectableNodes"]);
    return React330.createElement("div", Object.assign({ className: css(tree_view_default.treeView, hasGuides && tree_view_default.modifiers.guides, this.variantStyleModifiers[variant], className), ref: this.treeRef }, props), children2);
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TreeView/TreeView.js
var TreeView = (_a2) => {
  var { data, isNested = false, hasCheckboxes = false, hasBadges = false, hasGuides = false, hasSelectableNodes = false, variant = "default", defaultAllExpanded = false, allExpanded, icon, isMultiSelectable = false, expandedIcon, parentItem, onSelect, onCheck, onExpand, onCollapse, toolbar, activeItems, compareItems = (item, itemToCheck) => item.id === itemToCheck.id, className, useMemo: useMemo26, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby } = _a2, props = __rest(_a2, ["data", "isNested", "hasCheckboxes", "hasBadges", "hasGuides", "hasSelectableNodes", "variant", "defaultAllExpanded", "allExpanded", "icon", "isMultiSelectable", "expandedIcon", "parentItem", "onSelect", "onCheck", "onExpand", "onCollapse", "toolbar", "activeItems", "compareItems", "className", "useMemo", "aria-label", "aria-labelledby"]);
  const treeViewList = React331.createElement(TreeViewList, { isNested, toolbar, isMultiSelectable, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby }, data.map((item) => {
    var _a3, _b;
    return React331.createElement(TreeViewListItem, Object.assign({ key: ((_a3 = item.id) === null || _a3 === void 0 ? void 0 : _a3.toString()) || ((_b = item.name) === null || _b === void 0 ? void 0 : _b.toString()), name: item.name, title: item.title, id: item.id, isExpanded: allExpanded, isSelectable: hasSelectableNodes, defaultExpanded: item.defaultExpanded !== void 0 ? item.defaultExpanded : defaultAllExpanded, onSelect, onCheck, onExpand, onCollapse, hasCheckbox: item.hasCheckbox !== void 0 ? item.hasCheckbox : hasCheckboxes, checkProps: item.checkProps, hasBadge: item.hasBadge !== void 0 ? item.hasBadge : hasBadges, customBadgeContent: item.customBadgeContent, badgeProps: item.badgeProps, activeItems, parentItem, itemData: item, icon: item.icon !== void 0 ? item.icon : icon, expandedIcon: item.expandedIcon !== void 0 ? item.expandedIcon : expandedIcon, action: item.action, compareItems, isCompact: variant === "compact" || variant === "compactNoBackground", useMemo: useMemo26 }, item.children && {
      children: React331.createElement(TreeView, { data: item.children, isNested: true, parentItem: item, hasCheckboxes, hasBadges, hasGuides, hasSelectableNodes, variant, allExpanded, defaultAllExpanded, onSelect, onCheck, onExpand, onCollapse, activeItems, icon, expandedIcon })
    }));
  }));
  return React331.createElement(React331.Fragment, null, parentItem ? treeViewList : React331.createElement(TreeViewRoot, Object.assign({ hasSelectableNodes, hasCheckboxes, hasGuides, variant, className }, props), treeViewList));
};
TreeView.displayName = "TreeView";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/TreeView/TreeViewSearch.js
var React332 = __toESM(require_react());
var TreeViewSearch = (_a2) => {
  var { className, onSearch, id: id2, name, "aria-label": ariaLabel } = _a2, props = __rest(_a2, ["className", "onSearch", "id", "name", "aria-label"]);
  return React332.createElement(
    "div",
    { className: css(tree_view_default.treeViewSearch, className) },
    React332.createElement(
      "div",
      { className: css(form_control_default.formControl, form_control_default.modifiers.icon) },
      React332.createElement("input", Object.assign({ onChange: onSearch, id: id2, name, "aria-label": ariaLabel, type: "search" }, props)),
      React332.createElement(
        "div",
        { className: css(form_control_default.formControlUtilities) },
        React332.createElement(
          "div",
          { className: css(form_control_default.formControlIcon) },
          React332.createElement(search_icon_default, null)
        )
      )
    )
  );
};
TreeViewSearch.displayName = "TreeViewSearch";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/Wizard.js
var import_react34 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Wizard/wizard.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Wizard/wizard.css";
var wizard_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "drawer": "pf-v6-c-drawer",
  "modalBox": "pf-v6-c-modal-box",
  "modifiers": {
    "finished": "pf-m-finished",
    "expanded": "pf-m-expanded",
    "danger": "pf-m-danger",
    "success": "pf-m-success",
    "current": "pf-m-current",
    "expandable": "pf-m-expandable",
    "disabled": "pf-m-disabled",
    "noPadding": "pf-m-no-padding"
  },
  "wizard": "pf-v6-c-wizard",
  "wizardClose": "pf-v6-c-wizard__close",
  "wizardDescription": "pf-v6-c-wizard__description",
  "wizardFooter": "pf-v6-c-wizard__footer",
  "wizardHeader": "pf-v6-c-wizard__header",
  "wizardInnerWrap": "pf-v6-c-wizard__inner-wrap",
  "wizardMain": "pf-v6-c-wizard__main",
  "wizardMainBody": "pf-v6-c-wizard__main-body",
  "wizardNav": "pf-v6-c-wizard__nav",
  "wizardNavItem": "pf-v6-c-wizard__nav-item",
  "wizardNavLink": "pf-v6-c-wizard__nav-link",
  "wizardNavLinkMain": "pf-v6-c-wizard__nav-link-main",
  "wizardNavLinkStatusIcon": "pf-v6-c-wizard__nav-link-status-icon",
  "wizardNavLinkText": "pf-v6-c-wizard__nav-link-text",
  "wizardNavLinkToggle": "pf-v6-c-wizard__nav-link-toggle",
  "wizardNavLinkToggleIcon": "pf-v6-c-wizard__nav-link-toggle-icon",
  "wizardNavList": "pf-v6-c-wizard__nav-list",
  "wizardOuterWrap": "pf-v6-c-wizard__outer-wrap",
  "wizardTitle": "pf-v6-c-wizard__title",
  "wizardTitleText": "pf-v6-c-wizard__title-text",
  "wizardToggle": "pf-v6-c-wizard__toggle",
  "wizardToggleIcon": "pf-v6-c-wizard__toggle-icon",
  "wizardToggleList": "pf-v6-c-wizard__toggle-list",
  "wizardToggleListItem": "pf-v6-c-wizard__toggle-list-item",
  "wizardToggleNum": "pf-v6-c-wizard__toggle-num",
  "wizardToggleSeparator": "pf-v6-c-wizard__toggle-separator",
  "wizardToggleStatusIcon": "pf-v6-c-wizard__toggle-status-icon"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/types.js
var import_react26 = __toESM(require_react());
var WizardNavItemStatus;
(function(WizardNavItemStatus2) {
  WizardNavItemStatus2["Default"] = "default";
  WizardNavItemStatus2["Error"] = "error";
})(WizardNavItemStatus || (WizardNavItemStatus = {}));
var WizardStepChangeScope;
(function(WizardStepChangeScope2) {
  WizardStepChangeScope2["Next"] = "next";
  WizardStepChangeScope2["Back"] = "back";
  WizardStepChangeScope2["Nav"] = "nav";
})(WizardStepChangeScope || (WizardStepChangeScope = {}));
function isCustomWizardNav(nav) {
  return typeof nav === "function" || import_react26.default.isValidElement(nav);
}
function isCustomWizardNavItem(navItem) {
  return typeof navItem === "function" || import_react26.default.isValidElement(navItem);
}
function isCustomWizardFooter(footer) {
  return typeof footer === "function" || import_react26.default.isValidElement(footer);
}
function isWizardBasicStep(step) {
  return (step === null || step === void 0 ? void 0 : step.subStepIds) === void 0 && !isWizardSubStep(step);
}
function isWizardSubStep(step) {
  return (step === null || step === void 0 ? void 0 : step.parentId) !== void 0;
}
function isWizardParentStep(step) {
  return (step === null || step === void 0 ? void 0 : step.subStepIds) !== void 0;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/utils.js
var import_react30 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardStep.js
var import_react29 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardContext.js
var import_react28 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardFooter.js
var import_react27 = __toESM(require_react());
var WizardFooterWrapper = ({ children: children2 }) => import_react27.default.createElement("footer", { className: css(wizard_default.wizardFooter) }, children2);
var WizardFooter = (_a2) => {
  var { activeStep } = _a2, internalProps = __rest(_a2, ["activeStep"]);
  const activeStepFooter = !isCustomWizardFooter(activeStep === null || activeStep === void 0 ? void 0 : activeStep.footer) && (activeStep === null || activeStep === void 0 ? void 0 : activeStep.footer);
  return import_react27.default.createElement(InternalWizardFooter, Object.assign({}, internalProps, activeStepFooter));
};
var InternalWizardFooter = ({ onNext, onBack, onClose, isNextDisabled, isBackDisabled, isBackHidden, isCancelHidden, nextButtonText = "Next", backButtonText = "Back", cancelButtonText = "Cancel", nextButtonProps, backButtonProps, cancelButtonProps }) => import_react27.default.createElement(
  WizardFooterWrapper,
  null,
  import_react27.default.createElement(
    ActionList,
    null,
    import_react27.default.createElement(
      ActionListGroup,
      null,
      !isBackHidden && import_react27.default.createElement(
        ActionListItem,
        null,
        import_react27.default.createElement(Button, Object.assign({ variant: ButtonVariant.secondary, onClick: onBack, isDisabled: isBackDisabled }, backButtonProps), backButtonText)
      ),
      import_react27.default.createElement(
        ActionListItem,
        null,
        import_react27.default.createElement(Button, Object.assign({ variant: ButtonVariant.primary, type: "submit", onClick: onNext, isDisabled: isNextDisabled }, nextButtonProps), nextButtonText)
      )
    ),
    !isCancelHidden && import_react27.default.createElement(
      ActionListGroup,
      null,
      import_react27.default.createElement(
        ActionListItem,
        null,
        import_react27.default.createElement(Button, Object.assign({ variant: ButtonVariant.link, onClick: onClose }, cancelButtonProps), cancelButtonText)
      )
    )
  )
);
WizardFooterWrapper.displayName = "WizardFooterWrapper";
WizardFooter.displayName = "WizardFooter";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardContext.js
var WizardContext = import_react28.default.createContext({});
var WizardContextProvider = ({ steps: initialSteps, footer: initialFooter, activeStepIndex, children: children2, onNext, onBack, onClose, goToStepById, goToStepByName, goToStepByIndex, shouldFocusContent, mainWrapperRef }) => {
  const [currentSteps, setCurrentSteps] = import_react28.default.useState(initialSteps);
  const [currentFooter, setCurrentFooter] = import_react28.default.useState();
  const steps = import_react28.default.useMemo(() => currentSteps.map((currentStepProps, index4) => Object.assign(Object.assign({}, currentStepProps), initialSteps[index4])), [initialSteps, currentSteps]);
  const activeStep = import_react28.default.useMemo(() => steps.find((step) => step.index === activeStepIndex), [activeStepIndex, steps]);
  const close = import_react28.default.useCallback(() => onClose === null || onClose === void 0 ? void 0 : onClose(null), [onClose]);
  const goToNextStep = import_react28.default.useCallback(() => onNext(null, steps), [onNext, steps]);
  const goToPrevStep = import_react28.default.useCallback(() => onBack(null, steps), [onBack, steps]);
  const footer = import_react28.default.useMemo(() => {
    const wizardFooter = (activeStep === null || activeStep === void 0 ? void 0 : activeStep.footer) || currentFooter || initialFooter;
    if (isCustomWizardFooter(wizardFooter)) {
      const customFooter = wizardFooter;
      return typeof customFooter === "function" ? customFooter(activeStep, goToNextStep, goToPrevStep, close) : customFooter;
    }
    return import_react28.default.createElement(WizardFooter, Object.assign({ activeStep, onNext: goToNextStep, onBack: goToPrevStep, onClose: close, isBackDisabled: (activeStep === null || activeStep === void 0 ? void 0 : activeStep.index) === 1 || isWizardSubStep(activeStep) && (activeStep === null || activeStep === void 0 ? void 0 : activeStep.index) === 2 }, wizardFooter));
  }, [currentFooter, initialFooter, activeStep, goToNextStep, goToPrevStep, close]);
  const getStep = import_react28.default.useCallback((stepId) => steps.find((step) => step.id === stepId), [steps]);
  const setStep = import_react28.default.useCallback((step) => setCurrentSteps((prevSteps) => prevSteps.map((prevStep) => {
    if (prevStep.id === step.id) {
      return Object.assign(Object.assign({}, prevStep), step);
    }
    return prevStep;
  })), []);
  return import_react28.default.createElement(WizardContext.Provider, { value: {
    steps,
    activeStep,
    footer,
    close,
    getStep,
    setStep,
    goToNextStep,
    goToPrevStep,
    setFooter: setCurrentFooter,
    goToStepById: import_react28.default.useCallback((id2) => goToStepById(steps, id2), [goToStepById, steps]),
    goToStepByName: import_react28.default.useCallback((name) => goToStepByName(steps, name), [goToStepByName, steps]),
    goToStepByIndex: import_react28.default.useCallback((index4) => goToStepByIndex(null, steps, index4), [goToStepByIndex, steps]),
    shouldFocusContent,
    mainWrapperRef
  } }, children2);
};
WizardContextProvider.displayName = "WizardContextProvider";
var useWizardContext = () => import_react28.default.useContext(WizardContext);

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardStep.js
var WizardStep = (_a2) => {
  var { children: children2, steps: _subSteps } = _a2, props = __rest(_a2, ["children", "steps"]);
  const { activeStep, setStep } = useWizardContext();
  const { id: id2, name, body, isDisabled, isHidden, navItem, footer, status } = props;
  const isParentStep = isWizardParentStep(activeStep);
  import_react29.default.useEffect(() => {
    setStep(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      id: id2,
      name
    }, body && { body }), isDisabled && { isDisabled }), isHidden && { isHidden }), navItem && { navItem }), footer && { footer }), status && { status }), !isParentStep && id2 === (activeStep === null || activeStep === void 0 ? void 0 : activeStep.id) && !(activeStep === null || activeStep === void 0 ? void 0 : activeStep.isVisited) && { isVisited: true }));
  }, [
    body,
    footer,
    id2,
    isDisabled,
    isHidden,
    name,
    navItem,
    status,
    isParentStep,
    setStep,
    activeStep === null || activeStep === void 0 ? void 0 : activeStep.id,
    activeStep === null || activeStep === void 0 ? void 0 : activeStep.isVisited
  ]);
  return import_react29.default.createElement(import_react29.default.Fragment, null, children2);
};
WizardStep.displayName = "WizardStep";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/utils.js
var buildSteps = (children2) => import_react30.default.Children.toArray(children2).reduce((acc, child, index4) => {
  if (isWizardStep(child)) {
    const { props: childProps } = child;
    const { steps: childStepComponents, id: id2 } = childProps;
    const stepIndex = acc.length + 1;
    const subSteps = [];
    acc.push(Object.assign(Object.assign(Object.assign({ index: stepIndex, component: child }, index4 === 0 && !(childStepComponents === null || childStepComponents === void 0 ? void 0 : childStepComponents.length) && { isVisited: true }), childStepComponents && {
      subStepIds: childStepComponents === null || childStepComponents === void 0 ? void 0 : childStepComponents.map((childStepComponent, subStepIndex) => {
        subSteps.push(Object.assign(Object.assign({ index: stepIndex + subStepIndex + 1, component: childStepComponent, parentId: id2 }, index4 === 0 && subStepIndex === 0 && { isVisited: true }), normalizeStepProps(childStepComponent.props)));
        return childStepComponent.props.id;
      })
    }), normalizeStepProps(childProps)), ...subSteps);
  } else {
    throw new Error("Wizard only accepts children of type WizardStep.");
  }
  return acc;
}, []);
function isWizardStep(child) {
  return import_react30.default.isValidElement(child) && child.type === WizardStep;
}
var normalizeStepProps = (_a2) => {
  var { children: _children, steps: _steps } = _a2, controlStep = __rest(_a2, ["children", "steps"]);
  return controlStep;
};
var isStepEnabled = (steps, step) => {
  if (!isWizardParentStep(step) && !step.isHidden && !step.isDisabled) {
    if (isWizardSubStep(step)) {
      const parentStep = steps.find((otherStep) => otherStep.id === step.parentId);
      if (!parentStep.isHidden && !parentStep.isDisabled) {
        return true;
      }
    } else {
      return true;
    }
  }
  return false;
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardToggle.js
var import_react32 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardBody.js
var import_react31 = __toESM(require_react());
var WizardBody = ({ children: children2, hasNoPadding = false, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, component = "div" }) => {
  const [hasScrollbar, setHasScrollbar] = import_react31.default.useState(false);
  const [previousWidth, setPreviousWidth] = import_react31.default.useState(void 0);
  const WrapperComponent = component;
  const { activeStep, shouldFocusContent, mainWrapperRef } = import_react31.default.useContext(WizardContext);
  const defaultAriaLabel = ariaLabel || `${activeStep === null || activeStep === void 0 ? void 0 : activeStep.name} content`;
  import_react31.default.useEffect(() => {
    const resize = () => {
      if (mainWrapperRef === null || mainWrapperRef === void 0 ? void 0 : mainWrapperRef.current) {
        const { offsetWidth, offsetHeight, scrollHeight } = mainWrapperRef.current;
        if (previousWidth !== offsetWidth) {
          setPreviousWidth(offsetWidth);
          setHasScrollbar(offsetHeight < scrollHeight);
        }
      }
    };
    const handleResizeWithDelay = debounce(resize, 250);
    let observer3 = () => {
    };
    if (mainWrapperRef === null || mainWrapperRef === void 0 ? void 0 : mainWrapperRef.current) {
      observer3 = getResizeObserver(mainWrapperRef.current, handleResizeWithDelay);
      const { offsetHeight, scrollHeight } = mainWrapperRef.current;
      setHasScrollbar(offsetHeight < scrollHeight);
      setPreviousWidth(mainWrapperRef.current.offsetWidth);
    }
    return () => {
      observer3();
    };
  }, [previousWidth]);
  return import_react31.default.createElement(
    WrapperComponent,
    Object.assign({ ref: mainWrapperRef }, shouldFocusContent && { tabIndex: -1 }, component === "div" && hasScrollbar && { role: "region" }, hasScrollbar && { "aria-label": defaultAriaLabel, "aria-labelledby": ariaLabelledBy, tabIndex: 0 }, { className: css(wizard_default.wizardMain) }),
    import_react31.default.createElement("div", { className: css(wizard_default.wizardMainBody, hasNoPadding && wizard_default.modifiers.noPadding) }, children2)
  );
};
WizardBody.displayName = "WizardBody";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardToggle.js
var WizardToggle = ({ steps, activeStep, footer, nav, isNavExpanded, toggleNavExpanded, "aria-label": ariaLabel = "Wizard toggle" }) => {
  const isActiveSubStep = isWizardSubStep(activeStep);
  const parentStep = isActiveSubStep && steps.find((step) => step.id === activeStep.parentId);
  const nonSubSteps = steps.filter((step) => !isWizardSubStep(step));
  const wizardToggleIndex = nonSubSteps.indexOf(parentStep || activeStep) + 1;
  const isActiveStepStatus = activeStep.status;
  const handleKeyClicks = import_react32.default.useCallback((event) => {
    if (isNavExpanded && event.key === KeyTypes.Escape) {
      toggleNavExpanded === null || toggleNavExpanded === void 0 ? void 0 : toggleNavExpanded(event);
    }
  }, [isNavExpanded, toggleNavExpanded]);
  import_react32.default.useEffect(() => {
    const target = typeof document !== "undefined" ? document.body : null;
    target === null || target === void 0 ? void 0 : target.addEventListener("keydown", handleKeyClicks, false);
    return () => {
      target === null || target === void 0 ? void 0 : target.removeEventListener("keydown", handleKeyClicks, false);
    };
  }, [handleKeyClicks]);
  const bodyContent = steps.map((step) => {
    var _a2;
    const props = ((_a2 = step.component) === null || _a2 === void 0 ? void 0 : _a2.props) || {};
    const { children: children2, body } = props, propsWithoutChildren = __rest(props, ["children", "body"]);
    return import_react32.default.createElement(
      import_react32.default.Fragment,
      { key: step.id },
      (activeStep === null || activeStep === void 0 ? void 0 : activeStep.id) === step.id && (body || body === void 0 ? import_react32.default.createElement(WizardBody, Object.assign({}, body), children2) : children2),
      import_react32.default.createElement(
        "div",
        { key: step.id, style: { display: "none" } },
        import_react32.default.createElement(WizardStep, Object.assign({}, propsWithoutChildren))
      )
    );
  });
  return import_react32.default.createElement(
    import_react32.default.Fragment,
    null,
    import_react32.default.createElement(
      "button",
      { onClick: toggleNavExpanded, className: css(wizard_default.wizardToggle, isNavExpanded && "pf-m-expanded"), "aria-label": ariaLabel, "aria-expanded": isNavExpanded },
      import_react32.default.createElement(
        "span",
        { className: css(wizard_default.wizardToggleList) },
        import_react32.default.createElement(
          "span",
          { className: css(wizard_default.wizardToggleListItem, isActiveStepStatus === "error" && wizard_default.modifiers.danger) },
          isActiveStepStatus === "error" ? import_react32.default.createElement(
            "span",
            { className: css(wizard_default.wizardToggleStatusIcon) },
            import_react32.default.createElement(exclamation_circle_icon_default, null)
          ) : import_react32.default.createElement("span", { className: css(wizard_default.wizardToggleNum) }, wizardToggleIndex),
          " ",
          (parentStep === null || parentStep === void 0 ? void 0 : parentStep.name) || (activeStep === null || activeStep === void 0 ? void 0 : activeStep.name),
          isActiveSubStep && import_react32.default.createElement(angle_right_icon_default, { className: css(wizard_default.wizardToggleSeparator), "aria-hidden": "true" })
        ),
        isActiveSubStep && import_react32.default.createElement("span", { className: css(wizard_default.wizardToggleListItem) }, activeStep === null || activeStep === void 0 ? void 0 : activeStep.name)
      ),
      import_react32.default.createElement(
        "span",
        { className: css(wizard_default.wizardToggleIcon) },
        import_react32.default.createElement(caret_down_icon_default, { "aria-hidden": "true" })
      )
    ),
    import_react32.default.createElement(
      "div",
      { className: css(wizard_default.wizardOuterWrap) },
      import_react32.default.createElement(
        "div",
        { className: css(wizard_default.wizardInnerWrap) },
        nav,
        bodyContent
      ),
      footer
    )
  );
};
WizardToggle.displayName = "WizardToggle";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardNavInternal.js
var import_react33 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardNav.js
var React340 = __toESM(require_react());
var WizardNav = ({ children: children2, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, isExpanded = false, isInnerList = false }) => {
  if (isInnerList) {
    return React340.createElement("ol", { className: css(wizard_default.wizardNavList), role: "list" }, children2);
  }
  return React340.createElement(
    "nav",
    { className: css(wizard_default.wizardNav, isExpanded && wizard_default.modifiers.expanded), "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy },
    React340.createElement("ol", { className: css(wizard_default.wizardNavList), role: "list" }, children2)
  );
};
WizardNav.displayName = "WizardNav";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardNavItem.js
var React341 = __toESM(require_react());
var WizardNavItem = ({
  children: children2 = null,
  content = "",
  isCurrent = false,
  isDisabled = false,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isVisited = false,
  stepIndex,
  onClick,
  component: NavItemComponent = "button",
  href,
  isExpandable = false,
  id: id2,
  status = "default",
  target,
  ouiaId,
  ouiaSafe = true
}) => {
  const [isExpanded, setIsExpanded] = React341.useState(false);
  const ouiaProps = useOUIAProps(WizardNavItem.displayName, ouiaId, ouiaSafe);
  React341.useEffect(() => {
    setIsExpanded(isCurrent);
  }, [isCurrent]);
  if (NavItemComponent === "a" && !href && true) {
    console.error("WizardNavItem: When using an anchor, please provide an href");
  }
  return React341.createElement(
    "li",
    { className: css(wizard_default.wizardNavItem, isExpandable && wizard_default.modifiers.expandable, isExpandable && isExpanded && wizard_default.modifiers.expanded) },
    React341.createElement(
      NavItemComponent,
      Object.assign({}, NavItemComponent === "a" ? { tabIndex: isDisabled ? -1 : void 0, href, target } : { disabled: isDisabled }, id2 && { id: id2.toString() }, { onClick: (e) => {
        e.stopPropagation();
        isExpandable ? setIsExpanded(!isExpanded || isCurrent) : onClick === null || onClick === void 0 ? void 0 : onClick(e, stepIndex);
      }, className: css(wizard_default.wizardNavLink, isCurrent && wizard_default.modifiers.current, isDisabled && wizard_default.modifiers.disabled, status === WizardNavItemStatus.Error && wizard_default.modifiers.danger), "aria-disabled": isDisabled ? true : null, "aria-current": isCurrent && !children2 ? "step" : false }, isExpandable && { "aria-expanded": isExpanded }, ouiaProps),
      status === WizardNavItemStatus.Error && React341.createElement(
        React341.Fragment,
        null,
        React341.createElement(
          "span",
          { className: "pf-v5-screen-reader" },
          ", ",
          status
        ),
        React341.createElement(
          "span",
          { className: css(wizard_default.wizardNavLinkStatusIcon) },
          React341.createElement(exclamation_circle_icon_default, null)
        )
      ),
      React341.createElement("span", { className: css(wizard_default.wizardNavLinkMain) }, isExpandable ? React341.createElement(
        React341.Fragment,
        null,
        React341.createElement("span", { className: css(wizard_default.wizardNavLinkText) }, content),
        React341.createElement(
          "span",
          { className: css(wizard_default.wizardNavLinkToggle) },
          React341.createElement(
            "span",
            { className: css(wizard_default.wizardNavLinkToggleIcon) },
            React341.createElement(angle_right_icon_default, { "aria-label": `${isCurrent ? "Collapse" : "Expand"} step icon` })
          )
        )
      ) : React341.createElement(React341.Fragment, null, content))
    ),
    children2
  );
};
WizardNavItem.displayName = "WizardNavItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardNavInternal.js
var WizardNavInternal = ({ nav, navAriaLabel, isVisitRequired, isProgressive, isNavExpanded }) => {
  const { activeStep, steps, goToStepByIndex } = useWizardContext();
  const wizardNavProps = Object.assign({ isExpanded: isNavExpanded, "aria-label": navAriaLabel || (nav === null || nav === void 0 ? void 0 : nav["aria-label"]) || "Wizard steps" }, (nav === null || nav === void 0 ? void 0 : nav["aria-labelledby"]) && {
    "aria-labelledby": nav["aria-labelledby"]
  });
  return import_react33.default.createElement(WizardNav, Object.assign({}, wizardNavProps), steps.map((step, stepIndex) => {
    var _a2;
    const hasVisitedNextStep = steps.some((step2) => step2.index > stepIndex + 1 && step2.isVisited);
    const isStepDisabled = step.isDisabled || isVisitRequired && !step.isVisited && !hasVisitedNextStep;
    const customStepNavItem = isCustomWizardNavItem(step.navItem) && import_react33.default.createElement(import_react33.default.Fragment, { key: step.id }, typeof step.navItem === "function" ? step.navItem(step, activeStep, steps, goToStepByIndex) : step.navItem);
    if (isWizardParentStep(step) && !step.isHidden) {
      let firstSubStepIndex;
      let hasActiveChild = false;
      const subNavItems = (_a2 = step.subStepIds) === null || _a2 === void 0 ? void 0 : _a2.map((subStepId, subStepIndex) => {
        const subStep = steps.find((step2) => step2.id === subStepId);
        const hasVisitedNextStep2 = steps.some((step2) => step2.index > subStep.index && step2.isVisited);
        const isSubStepDisabled = subStep.isDisabled || isVisitRequired && !subStep.isVisited && !hasVisitedNextStep2;
        const customSubStepNavItem = isCustomWizardNavItem(subStep.navItem) && import_react33.default.createElement(import_react33.default.Fragment, { key: subStep.id }, typeof subStep.navItem === "function" ? subStep.navItem(subStep, activeStep, steps, goToStepByIndex) : subStep.navItem);
        if (subStep.isHidden) {
          return;
        }
        if (subStepIndex === 0) {
          firstSubStepIndex = subStep.index;
        }
        if ((activeStep === null || activeStep === void 0 ? void 0 : activeStep.id) === subStep.id) {
          hasActiveChild = true;
        }
        if (!isProgressive || isProgressive && subStep.index <= activeStep.index) {
          return customSubStepNavItem || import_react33.default.createElement(WizardNavItem, Object.assign({ key: subStep.id, id: subStep.id, content: subStep.name, isCurrent: (activeStep === null || activeStep === void 0 ? void 0 : activeStep.id) === subStep.id, isDisabled: isSubStepDisabled || isStepDisabled, isVisited: subStep.isVisited, stepIndex: subStep.index, onClick: () => goToStepByIndex(subStep.index), status: subStep.status }, subStep.navItem));
        }
      });
      const hasEnabledChildren = import_react33.default.Children.toArray(subNavItems).some((child) => import_react33.default.isValidElement(child) && !child.props.isDisabled);
      if (!isProgressive || isProgressive && step.index <= activeStep.index) {
        return customStepNavItem || import_react33.default.createElement(
          WizardNavItem,
          Object.assign({ key: step.id, id: step.id, content: step.name, isExpandable: step.isExpandable, isCurrent: hasActiveChild, isDisabled: !hasEnabledChildren || isStepDisabled, isVisited: step.isVisited, stepIndex: firstSubStepIndex, onClick: () => goToStepByIndex(firstSubStepIndex), status: step.status }, step.navItem),
          import_react33.default.createElement(WizardNav, Object.assign({}, wizardNavProps, { isInnerList: true }), subNavItems)
        );
      }
    }
    if (isWizardBasicStep(step) && !step.isHidden && (!isProgressive || isProgressive && step.index <= activeStep.index)) {
      return customStepNavItem || import_react33.default.createElement(WizardNavItem, Object.assign({ key: step.id, id: step.id, content: step.name, isCurrent: (activeStep === null || activeStep === void 0 ? void 0 : activeStep.id) === step.id, isDisabled: isStepDisabled, isVisited: step.isVisited, stepIndex: step.index, onClick: () => goToStepByIndex(step.index), status: step.status }, step.navItem));
    }
  }));
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/Wizard.js
var Wizard = (_a2) => {
  var { children: children2, footer, height, width, className, header, nav, navAriaLabel, startIndex = 1, isVisitRequired = false, isProgressive = false, onStepChange, onSave, onClose, shouldFocusContent = false } = _a2, wrapperProps = __rest(_a2, ["children", "footer", "height", "width", "className", "header", "nav", "navAriaLabel", "startIndex", "isVisitRequired", "isProgressive", "onStepChange", "onSave", "onClose", "shouldFocusContent"]);
  const [activeStepIndex, setActiveStepIndex] = import_react34.default.useState(startIndex);
  const initialSteps = buildSteps(children2);
  const firstStepRef = import_react34.default.useRef(initialSteps[startIndex - 1]);
  const wrapperRef = import_react34.default.useRef(null);
  import_react34.default.useEffect(() => {
    if (isWizardParentStep(firstStepRef.current)) {
      setActiveStepIndex(startIndex + 1);
    }
  }, [startIndex]);
  const focusMainContentElement = () => setTimeout(() => {
    var _a3;
    ((_a3 = wrapperRef === null || wrapperRef === void 0 ? void 0 : wrapperRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus) && wrapperRef.current.focus();
  }, 0);
  const goToNextStep = (event, steps = initialSteps) => {
    const newStep = steps.find((step) => step.index > activeStepIndex && isStepEnabled(steps, step));
    if (activeStepIndex >= steps.length || !(newStep === null || newStep === void 0 ? void 0 : newStep.index)) {
      return onSave ? onSave(event) : onClose === null || onClose === void 0 ? void 0 : onClose(event);
    }
    setActiveStepIndex(newStep === null || newStep === void 0 ? void 0 : newStep.index);
    onStepChange === null || onStepChange === void 0 ? void 0 : onStepChange(event, newStep, steps[activeStepIndex - 1], WizardStepChangeScope.Next);
    shouldFocusContent && focusMainContentElement();
  };
  const goToPrevStep = (event, steps = initialSteps) => {
    const newStep = [...steps].reverse().find((step) => step.index < activeStepIndex && isStepEnabled(steps, step));
    setActiveStepIndex(newStep === null || newStep === void 0 ? void 0 : newStep.index);
    onStepChange === null || onStepChange === void 0 ? void 0 : onStepChange(event, newStep, steps[activeStepIndex - 1], WizardStepChangeScope.Back);
    shouldFocusContent && focusMainContentElement();
  };
  const goToStepByIndex = (event, steps = initialSteps, index4) => {
    const lastStepIndex = steps.length + 1;
    if (index4 < 1) {
      index4 = 1;
    } else if (index4 > lastStepIndex) {
      index4 = lastStepIndex;
    }
    const currStep = steps[index4 - 1];
    const prevStep = steps[activeStepIndex - 1];
    setActiveStepIndex(index4);
    onStepChange === null || onStepChange === void 0 ? void 0 : onStepChange(event, currStep, prevStep, WizardStepChangeScope.Nav);
  };
  const goToStepById = (steps = initialSteps, id2) => {
    const step = steps.find((step2) => step2.id === id2);
    const stepIndex = step === null || step === void 0 ? void 0 : step.index;
    const lastStepIndex = steps.length + 1;
    if (stepIndex > 0 && stepIndex < lastStepIndex && !step.isDisabled && !step.isHidden) {
      setActiveStepIndex(stepIndex);
    }
  };
  const goToStepByName = (steps = initialSteps, name) => {
    const step = steps.find((step2) => step2.name === name);
    const stepIndex = step === null || step === void 0 ? void 0 : step.index;
    const lastStepIndex = steps.length + 1;
    if (stepIndex > 0 && stepIndex < lastStepIndex && !step.isDisabled && !step.isHidden) {
      setActiveStepIndex(stepIndex);
    }
  };
  return import_react34.default.createElement(
    WizardContextProvider,
    { steps: initialSteps, activeStepIndex, footer, onNext: goToNextStep, onBack: goToPrevStep, onClose, goToStepById, goToStepByName, goToStepByIndex, shouldFocusContent, mainWrapperRef: wrapperRef },
    import_react34.default.createElement(
      "div",
      Object.assign({ className: css(wizard_default.wizard, className), style: Object.assign(Object.assign({}, height ? { [c_wizard_Height_default.name]: typeof height === "number" ? `${height}px` : height } : {}), width ? { width } : {}) }, wrapperProps),
      header,
      import_react34.default.createElement(WizardInternal, { nav, navAriaLabel, isVisitRequired, isProgressive })
    )
  );
};
var WizardInternal = ({ nav, navAriaLabel, isVisitRequired, isProgressive }) => {
  const { activeStep, steps, footer, goToStepByIndex } = useWizardContext();
  const [isNavExpanded, setIsNavExpanded] = import_react34.default.useState(false);
  const wizardNav = import_react34.default.useMemo(() => {
    if (isCustomWizardNav(nav)) {
      return typeof nav === "function" ? nav(isNavExpanded, steps, activeStep, goToStepByIndex) : nav;
    }
    return import_react34.default.createElement(WizardNavInternal, { nav, navAriaLabel, isNavExpanded, isVisitRequired, isProgressive });
  }, [activeStep, isVisitRequired, isProgressive, goToStepByIndex, isNavExpanded, nav, navAriaLabel, steps]);
  return import_react34.default.createElement(WizardToggle, { nav: wizardNav, footer, steps, activeStep, isNavExpanded, toggleNavExpanded: () => setIsNavExpanded((prevIsExpanded) => !prevIsExpanded) });
};
Wizard.displayName = "Wizard";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/WizardHeader.js
var React344 = __toESM(require_react());
var WizardHeader = ({ onClose = () => void 0, title, description, isCloseHidden, closeButtonAriaLabel, titleId, descriptionComponent: Component50 = "div", descriptionId }) => React344.createElement(
  "div",
  { className: css(wizard_default.wizardHeader) },
  !isCloseHidden && React344.createElement(
    "div",
    { className: css(wizard_default.wizardClose) },
    React344.createElement(
      Button,
      { variant: "plain", "aria-label": closeButtonAriaLabel, onClick: onClose },
      React344.createElement(times_icon_default, { "aria-hidden": "true" })
    )
  ),
  React344.createElement(
    "div",
    { className: css(wizard_default.wizardTitle) },
    React344.createElement("h2", { className: css(wizard_default.wizardTitleText), id: titleId }, title || React344.createElement(React344.Fragment, null, "Â "))
  ),
  description && React344.createElement(Component50, { className: css(wizard_default.wizardDescription), id: descriptionId }, description)
);
WizardHeader.displayName = "WizardHeader";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Wizard/hooks/useWizardFooter.js
var import_react35 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Truncate/Truncate.js
var React346 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Truncate/truncate.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/components/Truncate/truncate.css";
var truncate_default = {
  "dirRtl": "pf-v6-m-dir-rtl",
  "truncate": "pf-v6-c-truncate",
  "truncateEnd": "pf-v6-c-truncate__end",
  "truncateStart": "pf-v6-c-truncate__start"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/components/Truncate/Truncate.js
var TruncatePosition;
(function(TruncatePosition2) {
  TruncatePosition2["start"] = "start";
  TruncatePosition2["end"] = "end";
  TruncatePosition2["middle"] = "middle";
})(TruncatePosition || (TruncatePosition = {}));
var truncateStyles = {
  start: truncate_default.truncateEnd,
  end: truncate_default.truncateStart
};
var minWidthCharacters = 12;
var sliceContent = (str, slice5) => [str.slice(0, str.length - slice5), str.slice(-slice5)];
var Truncate = (_a2) => {
  var { className, position = "end", tooltipPosition = "top", trailingNumChars = 7, content } = _a2, props = __rest(_a2, ["className", "position", "tooltipPosition", "trailingNumChars", "content"]);
  const [isTruncated, setIsTruncated] = React346.useState(true);
  const [parentElement, setParentElement] = React346.useState(null);
  const [textElement, setTextElement] = React346.useState(null);
  const textRef = React346.useRef(null);
  const subParentRef = React346.useRef(null);
  const observer3 = React346.useRef(null);
  const getActualWidth = (element) => {
    const computedStyle = getComputedStyle(element);
    return parseFloat(computedStyle.width) - parseFloat(computedStyle.paddingLeft) - parseFloat(computedStyle.paddingRight) - parseFloat(computedStyle.borderRight) - parseFloat(computedStyle.borderLeft);
  };
  const calculateTotalTextWidth = (element, trailingNumChars2, content2) => {
    const firstTextWidth = element.scrollWidth;
    const firstTextLength = content2.length;
    return firstTextWidth / firstTextLength * trailingNumChars2 + firstTextWidth;
  };
  React346.useEffect(() => {
    if (textRef && textRef.current && !textElement) {
      setTextElement(textRef.current);
    }
    if (subParentRef && subParentRef.current.parentElement.parentElement && !parentElement) {
      setParentElement(subParentRef.current.parentElement.parentElement);
    }
  }, [textRef, subParentRef]);
  React346.useEffect(() => {
    if (textElement && parentElement && !observer3.current) {
      const totalTextWidth = calculateTotalTextWidth(textElement, trailingNumChars, content);
      const textWidth = position === "middle" ? totalTextWidth : textElement.scrollWidth;
      const handleResize = () => {
        const parentWidth = getActualWidth(parentElement);
        setIsTruncated(textWidth >= parentWidth);
      };
      const observer4 = getResizeObserver(parentElement, handleResize);
      return () => {
        observer4();
      };
    }
  }, [textElement, parentElement]);
  const truncateBody = React346.createElement(
    "span",
    Object.assign({ ref: subParentRef, className: css(truncate_default.truncate, className) }, props),
    (position === TruncatePosition.end || position === TruncatePosition.start) && React346.createElement(
      "span",
      { ref: textRef, className: truncateStyles[position] },
      content,
      position === TruncatePosition.start && React346.createElement(React346.Fragment, null, "â€Ž")
    ),
    position === TruncatePosition.middle && content.slice(0, content.length - trailingNumChars).length > minWidthCharacters && React346.createElement(
      React346.Fragment,
      null,
      React346.createElement("span", { ref: textRef, className: truncate_default.truncateStart }, sliceContent(content, trailingNumChars)[0]),
      React346.createElement("span", { className: truncate_default.truncateEnd }, sliceContent(content, trailingNumChars)[1])
    ),
    position === TruncatePosition.middle && content.slice(0, content.length - trailingNumChars).length <= minWidthCharacters && content
  );
  return isTruncated ? React346.createElement(Tooltip, { hidden: !isTruncated, position: tooltipPosition, content }, truncateBody) : truncateBody;
};
Truncate.displayName = "Truncate";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Bullseye/Bullseye.js
var React347 = __toESM(require_react());
var Bullseye = (_a2) => {
  var { children: children2 = null, className = "", component = "div" } = _a2, props = __rest(_a2, ["children", "className", "component"]);
  const Component50 = component;
  return React347.createElement(Component50, Object.assign({ className: css(bullseye_default.bullseye, className) }, props), children2);
};
Bullseye.displayName = "Bullseye";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Flex/Flex.js
var React348 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Flex/flex.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Flex/flex.css";
var flex_default = {
  "flex": "pf-v6-l-flex",
  "modifiers": {
    "flex": "pf-m-flex",
    "inlineFlex": "pf-m-inline-flex",
    "column": "pf-m-column",
    "columnReverse": "pf-m-column-reverse",
    "row": "pf-m-row",
    "rowReverse": "pf-m-row-reverse",
    "wrap": "pf-m-wrap",
    "wrapReverse": "pf-m-wrap-reverse",
    "nowrap": "pf-m-nowrap",
    "justifyContentFlexStart": "pf-m-justify-content-flex-start",
    "justifyContentFlexEnd": "pf-m-justify-content-flex-end",
    "justifyContentCenter": "pf-m-justify-content-center",
    "justifyContentSpaceBetween": "pf-m-justify-content-space-between",
    "justifyContentSpaceAround": "pf-m-justify-content-space-around",
    "justifyContentSpaceEvenly": "pf-m-justify-content-space-evenly",
    "alignItemsFlexStart": "pf-m-align-items-flex-start",
    "alignItemsFlexEnd": "pf-m-align-items-flex-end",
    "alignItemsCenter": "pf-m-align-items-center",
    "alignItemsStretch": "pf-m-align-items-stretch",
    "alignItemsBaseline": "pf-m-align-items-baseline",
    "alignContentFlexStart": "pf-m-align-content-flex-start",
    "alignContentFlexEnd": "pf-m-align-content-flex-end",
    "alignContentCenter": "pf-m-align-content-center",
    "alignContentStretch": "pf-m-align-content-stretch",
    "alignContentSpaceBetween": "pf-m-align-content-space-between",
    "alignContentSpaceAround": "pf-m-align-content-space-around",
    "alignRight": "pf-m-align-right",
    "alignLeft": "pf-m-align-left",
    "grow": "pf-m-grow",
    "shrink": "pf-m-shrink",
    "fullWidth": "pf-m-full-width",
    "flex_1": "pf-m-flex-1",
    "flex_2": "pf-m-flex-2",
    "flex_3": "pf-m-flex-3",
    "flex_4": "pf-m-flex-4",
    "flexDefault": "pf-m-flex-default",
    "flexNone": "pf-m-flex-none",
    "alignSelfFlexStart": "pf-m-align-self-flex-start",
    "alignSelfFlexEnd": "pf-m-align-self-flex-end",
    "alignSelfCenter": "pf-m-align-self-center",
    "alignSelfBaseline": "pf-m-align-self-baseline",
    "alignSelfStretch": "pf-m-align-self-stretch",
    "flexOnSm": "pf-m-flex-on-sm",
    "inlineFlexOnSm": "pf-m-inline-flex-on-sm",
    "columnOnSm": "pf-m-column-on-sm",
    "columnReverseOnSm": "pf-m-column-reverse-on-sm",
    "rowOnSm": "pf-m-row-on-sm",
    "rowReverseOnSm": "pf-m-row-reverse-on-sm",
    "wrapOnSm": "pf-m-wrap-on-sm",
    "wrapReverseOnSm": "pf-m-wrap-reverse-on-sm",
    "nowrapOnSm": "pf-m-nowrap-on-sm",
    "justifyContentFlexStartOnSm": "pf-m-justify-content-flex-start-on-sm",
    "justifyContentFlexEndOnSm": "pf-m-justify-content-flex-end-on-sm",
    "justifyContentCenterOnSm": "pf-m-justify-content-center-on-sm",
    "justifyContentSpaceBetweenOnSm": "pf-m-justify-content-space-between-on-sm",
    "justifyContentSpaceAroundOnSm": "pf-m-justify-content-space-around-on-sm",
    "justifyContentSpaceEvenlyOnSm": "pf-m-justify-content-space-evenly-on-sm",
    "alignItemsFlexStartOnSm": "pf-m-align-items-flex-start-on-sm",
    "alignItemsFlexEndOnSm": "pf-m-align-items-flex-end-on-sm",
    "alignItemsCenterOnSm": "pf-m-align-items-center-on-sm",
    "alignItemsStretchOnSm": "pf-m-align-items-stretch-on-sm",
    "alignItemsBaselineOnSm": "pf-m-align-items-baseline-on-sm",
    "alignContentFlexStartOnSm": "pf-m-align-content-flex-start-on-sm",
    "alignContentFlexEndOnSm": "pf-m-align-content-flex-end-on-sm",
    "alignContentCenterOnSm": "pf-m-align-content-center-on-sm",
    "alignContentStretchOnSm": "pf-m-align-content-stretch-on-sm",
    "alignContentSpaceBetweenOnSm": "pf-m-align-content-space-between-on-sm",
    "alignContentSpaceAroundOnSm": "pf-m-align-content-space-around-on-sm",
    "alignRightOnSm": "pf-m-align-right-on-sm",
    "alignLeftOnSm": "pf-m-align-left-on-sm",
    "growOnSm": "pf-m-grow-on-sm",
    "shrinkOnSm": "pf-m-shrink-on-sm",
    "fullWidthOnSm": "pf-m-full-width-on-sm",
    "flex_1OnSm": "pf-m-flex-1-on-sm",
    "flex_2OnSm": "pf-m-flex-2-on-sm",
    "flex_3OnSm": "pf-m-flex-3-on-sm",
    "flex_4OnSm": "pf-m-flex-4-on-sm",
    "flexDefaultOnSm": "pf-m-flex-default-on-sm",
    "flexNoneOnSm": "pf-m-flex-none-on-sm",
    "alignSelfFlexStartOnSm": "pf-m-align-self-flex-start-on-sm",
    "alignSelfFlexEndOnSm": "pf-m-align-self-flex-end-on-sm",
    "alignSelfCenterOnSm": "pf-m-align-self-center-on-sm",
    "alignSelfBaselineOnSm": "pf-m-align-self-baseline-on-sm",
    "alignSelfStretchOnSm": "pf-m-align-self-stretch-on-sm",
    "flexOnMd": "pf-m-flex-on-md",
    "inlineFlexOnMd": "pf-m-inline-flex-on-md",
    "columnOnMd": "pf-m-column-on-md",
    "columnReverseOnMd": "pf-m-column-reverse-on-md",
    "rowOnMd": "pf-m-row-on-md",
    "rowReverseOnMd": "pf-m-row-reverse-on-md",
    "wrapOnMd": "pf-m-wrap-on-md",
    "wrapReverseOnMd": "pf-m-wrap-reverse-on-md",
    "nowrapOnMd": "pf-m-nowrap-on-md",
    "justifyContentFlexStartOnMd": "pf-m-justify-content-flex-start-on-md",
    "justifyContentFlexEndOnMd": "pf-m-justify-content-flex-end-on-md",
    "justifyContentCenterOnMd": "pf-m-justify-content-center-on-md",
    "justifyContentSpaceBetweenOnMd": "pf-m-justify-content-space-between-on-md",
    "justifyContentSpaceAroundOnMd": "pf-m-justify-content-space-around-on-md",
    "justifyContentSpaceEvenlyOnMd": "pf-m-justify-content-space-evenly-on-md",
    "alignItemsFlexStartOnMd": "pf-m-align-items-flex-start-on-md",
    "alignItemsFlexEndOnMd": "pf-m-align-items-flex-end-on-md",
    "alignItemsCenterOnMd": "pf-m-align-items-center-on-md",
    "alignItemsStretchOnMd": "pf-m-align-items-stretch-on-md",
    "alignItemsBaselineOnMd": "pf-m-align-items-baseline-on-md",
    "alignContentFlexStartOnMd": "pf-m-align-content-flex-start-on-md",
    "alignContentFlexEndOnMd": "pf-m-align-content-flex-end-on-md",
    "alignContentCenterOnMd": "pf-m-align-content-center-on-md",
    "alignContentStretchOnMd": "pf-m-align-content-stretch-on-md",
    "alignContentSpaceBetweenOnMd": "pf-m-align-content-space-between-on-md",
    "alignContentSpaceAroundOnMd": "pf-m-align-content-space-around-on-md",
    "alignRightOnMd": "pf-m-align-right-on-md",
    "alignLeftOnMd": "pf-m-align-left-on-md",
    "growOnMd": "pf-m-grow-on-md",
    "shrinkOnMd": "pf-m-shrink-on-md",
    "fullWidthOnMd": "pf-m-full-width-on-md",
    "flex_1OnMd": "pf-m-flex-1-on-md",
    "flex_2OnMd": "pf-m-flex-2-on-md",
    "flex_3OnMd": "pf-m-flex-3-on-md",
    "flex_4OnMd": "pf-m-flex-4-on-md",
    "flexDefaultOnMd": "pf-m-flex-default-on-md",
    "flexNoneOnMd": "pf-m-flex-none-on-md",
    "alignSelfFlexStartOnMd": "pf-m-align-self-flex-start-on-md",
    "alignSelfFlexEndOnMd": "pf-m-align-self-flex-end-on-md",
    "alignSelfCenterOnMd": "pf-m-align-self-center-on-md",
    "alignSelfBaselineOnMd": "pf-m-align-self-baseline-on-md",
    "alignSelfStretchOnMd": "pf-m-align-self-stretch-on-md",
    "flexOnLg": "pf-m-flex-on-lg",
    "inlineFlexOnLg": "pf-m-inline-flex-on-lg",
    "columnOnLg": "pf-m-column-on-lg",
    "columnReverseOnLg": "pf-m-column-reverse-on-lg",
    "rowOnLg": "pf-m-row-on-lg",
    "rowReverseOnLg": "pf-m-row-reverse-on-lg",
    "wrapOnLg": "pf-m-wrap-on-lg",
    "wrapReverseOnLg": "pf-m-wrap-reverse-on-lg",
    "nowrapOnLg": "pf-m-nowrap-on-lg",
    "justifyContentFlexStartOnLg": "pf-m-justify-content-flex-start-on-lg",
    "justifyContentFlexEndOnLg": "pf-m-justify-content-flex-end-on-lg",
    "justifyContentCenterOnLg": "pf-m-justify-content-center-on-lg",
    "justifyContentSpaceBetweenOnLg": "pf-m-justify-content-space-between-on-lg",
    "justifyContentSpaceAroundOnLg": "pf-m-justify-content-space-around-on-lg",
    "justifyContentSpaceEvenlyOnLg": "pf-m-justify-content-space-evenly-on-lg",
    "alignItemsFlexStartOnLg": "pf-m-align-items-flex-start-on-lg",
    "alignItemsFlexEndOnLg": "pf-m-align-items-flex-end-on-lg",
    "alignItemsCenterOnLg": "pf-m-align-items-center-on-lg",
    "alignItemsStretchOnLg": "pf-m-align-items-stretch-on-lg",
    "alignItemsBaselineOnLg": "pf-m-align-items-baseline-on-lg",
    "alignContentFlexStartOnLg": "pf-m-align-content-flex-start-on-lg",
    "alignContentFlexEndOnLg": "pf-m-align-content-flex-end-on-lg",
    "alignContentCenterOnLg": "pf-m-align-content-center-on-lg",
    "alignContentStretchOnLg": "pf-m-align-content-stretch-on-lg",
    "alignContentSpaceBetweenOnLg": "pf-m-align-content-space-between-on-lg",
    "alignContentSpaceAroundOnLg": "pf-m-align-content-space-around-on-lg",
    "alignRightOnLg": "pf-m-align-right-on-lg",
    "alignLeftOnLg": "pf-m-align-left-on-lg",
    "growOnLg": "pf-m-grow-on-lg",
    "shrinkOnLg": "pf-m-shrink-on-lg",
    "fullWidthOnLg": "pf-m-full-width-on-lg",
    "flex_1OnLg": "pf-m-flex-1-on-lg",
    "flex_2OnLg": "pf-m-flex-2-on-lg",
    "flex_3OnLg": "pf-m-flex-3-on-lg",
    "flex_4OnLg": "pf-m-flex-4-on-lg",
    "flexDefaultOnLg": "pf-m-flex-default-on-lg",
    "flexNoneOnLg": "pf-m-flex-none-on-lg",
    "alignSelfFlexStartOnLg": "pf-m-align-self-flex-start-on-lg",
    "alignSelfFlexEndOnLg": "pf-m-align-self-flex-end-on-lg",
    "alignSelfCenterOnLg": "pf-m-align-self-center-on-lg",
    "alignSelfBaselineOnLg": "pf-m-align-self-baseline-on-lg",
    "alignSelfStretchOnLg": "pf-m-align-self-stretch-on-lg",
    "flexOnXl": "pf-m-flex-on-xl",
    "inlineFlexOnXl": "pf-m-inline-flex-on-xl",
    "columnOnXl": "pf-m-column-on-xl",
    "columnReverseOnXl": "pf-m-column-reverse-on-xl",
    "rowOnXl": "pf-m-row-on-xl",
    "rowReverseOnXl": "pf-m-row-reverse-on-xl",
    "wrapOnXl": "pf-m-wrap-on-xl",
    "wrapReverseOnXl": "pf-m-wrap-reverse-on-xl",
    "nowrapOnXl": "pf-m-nowrap-on-xl",
    "justifyContentFlexStartOnXl": "pf-m-justify-content-flex-start-on-xl",
    "justifyContentFlexEndOnXl": "pf-m-justify-content-flex-end-on-xl",
    "justifyContentCenterOnXl": "pf-m-justify-content-center-on-xl",
    "justifyContentSpaceBetweenOnXl": "pf-m-justify-content-space-between-on-xl",
    "justifyContentSpaceAroundOnXl": "pf-m-justify-content-space-around-on-xl",
    "justifyContentSpaceEvenlyOnXl": "pf-m-justify-content-space-evenly-on-xl",
    "alignItemsFlexStartOnXl": "pf-m-align-items-flex-start-on-xl",
    "alignItemsFlexEndOnXl": "pf-m-align-items-flex-end-on-xl",
    "alignItemsCenterOnXl": "pf-m-align-items-center-on-xl",
    "alignItemsStretchOnXl": "pf-m-align-items-stretch-on-xl",
    "alignItemsBaselineOnXl": "pf-m-align-items-baseline-on-xl",
    "alignContentFlexStartOnXl": "pf-m-align-content-flex-start-on-xl",
    "alignContentFlexEndOnXl": "pf-m-align-content-flex-end-on-xl",
    "alignContentCenterOnXl": "pf-m-align-content-center-on-xl",
    "alignContentStretchOnXl": "pf-m-align-content-stretch-on-xl",
    "alignContentSpaceBetweenOnXl": "pf-m-align-content-space-between-on-xl",
    "alignContentSpaceAroundOnXl": "pf-m-align-content-space-around-on-xl",
    "alignRightOnXl": "pf-m-align-right-on-xl",
    "alignLeftOnXl": "pf-m-align-left-on-xl",
    "growOnXl": "pf-m-grow-on-xl",
    "shrinkOnXl": "pf-m-shrink-on-xl",
    "fullWidthOnXl": "pf-m-full-width-on-xl",
    "flex_1OnXl": "pf-m-flex-1-on-xl",
    "flex_2OnXl": "pf-m-flex-2-on-xl",
    "flex_3OnXl": "pf-m-flex-3-on-xl",
    "flex_4OnXl": "pf-m-flex-4-on-xl",
    "flexDefaultOnXl": "pf-m-flex-default-on-xl",
    "flexNoneOnXl": "pf-m-flex-none-on-xl",
    "alignSelfFlexStartOnXl": "pf-m-align-self-flex-start-on-xl",
    "alignSelfFlexEndOnXl": "pf-m-align-self-flex-end-on-xl",
    "alignSelfCenterOnXl": "pf-m-align-self-center-on-xl",
    "alignSelfBaselineOnXl": "pf-m-align-self-baseline-on-xl",
    "alignSelfStretchOnXl": "pf-m-align-self-stretch-on-xl",
    "flexOn_2xl": "pf-m-flex-on-2xl",
    "inlineFlexOn_2xl": "pf-m-inline-flex-on-2xl",
    "columnOn_2xl": "pf-m-column-on-2xl",
    "columnReverseOn_2xl": "pf-m-column-reverse-on-2xl",
    "rowOn_2xl": "pf-m-row-on-2xl",
    "rowReverseOn_2xl": "pf-m-row-reverse-on-2xl",
    "wrapOn_2xl": "pf-m-wrap-on-2xl",
    "wrapReverseOn_2xl": "pf-m-wrap-reverse-on-2xl",
    "nowrapOn_2xl": "pf-m-nowrap-on-2xl",
    "justifyContentFlexStartOn_2xl": "pf-m-justify-content-flex-start-on-2xl",
    "justifyContentFlexEndOn_2xl": "pf-m-justify-content-flex-end-on-2xl",
    "justifyContentCenterOn_2xl": "pf-m-justify-content-center-on-2xl",
    "justifyContentSpaceBetweenOn_2xl": "pf-m-justify-content-space-between-on-2xl",
    "justifyContentSpaceAroundOn_2xl": "pf-m-justify-content-space-around-on-2xl",
    "justifyContentSpaceEvenlyOn_2xl": "pf-m-justify-content-space-evenly-on-2xl",
    "alignItemsFlexStartOn_2xl": "pf-m-align-items-flex-start-on-2xl",
    "alignItemsFlexEndOn_2xl": "pf-m-align-items-flex-end-on-2xl",
    "alignItemsCenterOn_2xl": "pf-m-align-items-center-on-2xl",
    "alignItemsStretchOn_2xl": "pf-m-align-items-stretch-on-2xl",
    "alignItemsBaselineOn_2xl": "pf-m-align-items-baseline-on-2xl",
    "alignContentFlexStartOn_2xl": "pf-m-align-content-flex-start-on-2xl",
    "alignContentFlexEndOn_2xl": "pf-m-align-content-flex-end-on-2xl",
    "alignContentCenterOn_2xl": "pf-m-align-content-center-on-2xl",
    "alignContentStretchOn_2xl": "pf-m-align-content-stretch-on-2xl",
    "alignContentSpaceBetweenOn_2xl": "pf-m-align-content-space-between-on-2xl",
    "alignContentSpaceAroundOn_2xl": "pf-m-align-content-space-around-on-2xl",
    "alignRightOn_2xl": "pf-m-align-right-on-2xl",
    "alignLeftOn_2xl": "pf-m-align-left-on-2xl",
    "growOn_2xl": "pf-m-grow-on-2xl",
    "shrinkOn_2xl": "pf-m-shrink-on-2xl",
    "fullWidthOn_2xl": "pf-m-full-width-on-2xl",
    "flex_1On_2xl": "pf-m-flex-1-on-2xl",
    "flex_2On_2xl": "pf-m-flex-2-on-2xl",
    "flex_3On_2xl": "pf-m-flex-3-on-2xl",
    "flex_4On_2xl": "pf-m-flex-4-on-2xl",
    "flexDefaultOn_2xl": "pf-m-flex-default-on-2xl",
    "flexNoneOn_2xl": "pf-m-flex-none-on-2xl",
    "alignSelfFlexStartOn_2xl": "pf-m-align-self-flex-start-on-2xl",
    "alignSelfFlexEndOn_2xl": "pf-m-align-self-flex-end-on-2xl",
    "alignSelfCenterOn_2xl": "pf-m-align-self-center-on-2xl",
    "alignSelfBaselineOn_2xl": "pf-m-align-self-baseline-on-2xl",
    "alignSelfStretchOn_2xl": "pf-m-align-self-stretch-on-2xl",
    "spaceItemsNone": "pf-m-space-items-none",
    "spaceItemsXs": "pf-m-space-items-xs",
    "spaceItemsSm": "pf-m-space-items-sm",
    "spaceItemsMd": "pf-m-space-items-md",
    "spaceItemsLg": "pf-m-space-items-lg",
    "spaceItemsXl": "pf-m-space-items-xl",
    "spaceItems_2xl": "pf-m-space-items-2xl",
    "spaceItems_3xl": "pf-m-space-items-3xl",
    "spaceItems_4xl": "pf-m-space-items-4xl",
    "spaceItemsNoneOnSm": "pf-m-space-items-none-on-sm",
    "spaceItemsXsOnSm": "pf-m-space-items-xs-on-sm",
    "spaceItemsSmOnSm": "pf-m-space-items-sm-on-sm",
    "spaceItemsMdOnSm": "pf-m-space-items-md-on-sm",
    "spaceItemsLgOnSm": "pf-m-space-items-lg-on-sm",
    "spaceItemsXlOnSm": "pf-m-space-items-xl-on-sm",
    "spaceItems_2xlOnSm": "pf-m-space-items-2xl-on-sm",
    "spaceItems_3xlOnSm": "pf-m-space-items-3xl-on-sm",
    "spaceItems_4xlOnSm": "pf-m-space-items-4xl-on-sm",
    "spaceItemsNoneOnMd": "pf-m-space-items-none-on-md",
    "spaceItemsXsOnMd": "pf-m-space-items-xs-on-md",
    "spaceItemsSmOnMd": "pf-m-space-items-sm-on-md",
    "spaceItemsMdOnMd": "pf-m-space-items-md-on-md",
    "spaceItemsLgOnMd": "pf-m-space-items-lg-on-md",
    "spaceItemsXlOnMd": "pf-m-space-items-xl-on-md",
    "spaceItems_2xlOnMd": "pf-m-space-items-2xl-on-md",
    "spaceItems_3xlOnMd": "pf-m-space-items-3xl-on-md",
    "spaceItems_4xlOnMd": "pf-m-space-items-4xl-on-md",
    "spaceItemsNoneOnLg": "pf-m-space-items-none-on-lg",
    "spaceItemsXsOnLg": "pf-m-space-items-xs-on-lg",
    "spaceItemsSmOnLg": "pf-m-space-items-sm-on-lg",
    "spaceItemsMdOnLg": "pf-m-space-items-md-on-lg",
    "spaceItemsLgOnLg": "pf-m-space-items-lg-on-lg",
    "spaceItemsXlOnLg": "pf-m-space-items-xl-on-lg",
    "spaceItems_2xlOnLg": "pf-m-space-items-2xl-on-lg",
    "spaceItems_3xlOnLg": "pf-m-space-items-3xl-on-lg",
    "spaceItems_4xlOnLg": "pf-m-space-items-4xl-on-lg",
    "spaceItemsNoneOnXl": "pf-m-space-items-none-on-xl",
    "spaceItemsXsOnXl": "pf-m-space-items-xs-on-xl",
    "spaceItemsSmOnXl": "pf-m-space-items-sm-on-xl",
    "spaceItemsMdOnXl": "pf-m-space-items-md-on-xl",
    "spaceItemsLgOnXl": "pf-m-space-items-lg-on-xl",
    "spaceItemsXlOnXl": "pf-m-space-items-xl-on-xl",
    "spaceItems_2xlOnXl": "pf-m-space-items-2xl-on-xl",
    "spaceItems_3xlOnXl": "pf-m-space-items-3xl-on-xl",
    "spaceItems_4xlOnXl": "pf-m-space-items-4xl-on-xl",
    "spaceItemsNoneOn_2xl": "pf-m-space-items-none-on-2xl",
    "spaceItemsXsOn_2xl": "pf-m-space-items-xs-on-2xl",
    "spaceItemsSmOn_2xl": "pf-m-space-items-sm-on-2xl",
    "spaceItemsMdOn_2xl": "pf-m-space-items-md-on-2xl",
    "spaceItemsLgOn_2xl": "pf-m-space-items-lg-on-2xl",
    "spaceItemsXlOn_2xl": "pf-m-space-items-xl-on-2xl",
    "spaceItems_2xlOn_2xl": "pf-m-space-items-2xl-on-2xl",
    "spaceItems_3xlOn_2xl": "pf-m-space-items-3xl-on-2xl",
    "spaceItems_4xlOn_2xl": "pf-m-space-items-4xl-on-2xl",
    "spacerNone": "pf-m-spacer-none",
    "spacerXs": "pf-m-spacer-xs",
    "spacerSm": "pf-m-spacer-sm",
    "spacerMd": "pf-m-spacer-md",
    "spacerLg": "pf-m-spacer-lg",
    "spacerXl": "pf-m-spacer-xl",
    "spacer_2xl": "pf-m-spacer-2xl",
    "spacer_3xl": "pf-m-spacer-3xl",
    "spacer_4xl": "pf-m-spacer-4xl",
    "spacerNoneOnSm": "pf-m-spacer-none-on-sm",
    "spacerXsOnSm": "pf-m-spacer-xs-on-sm",
    "spacerSmOnSm": "pf-m-spacer-sm-on-sm",
    "spacerMdOnSm": "pf-m-spacer-md-on-sm",
    "spacerLgOnSm": "pf-m-spacer-lg-on-sm",
    "spacerXlOnSm": "pf-m-spacer-xl-on-sm",
    "spacer_2xlOnSm": "pf-m-spacer-2xl-on-sm",
    "spacer_3xlOnSm": "pf-m-spacer-3xl-on-sm",
    "spacer_4xlOnSm": "pf-m-spacer-4xl-on-sm",
    "spacerNoneOnMd": "pf-m-spacer-none-on-md",
    "spacerXsOnMd": "pf-m-spacer-xs-on-md",
    "spacerSmOnMd": "pf-m-spacer-sm-on-md",
    "spacerMdOnMd": "pf-m-spacer-md-on-md",
    "spacerLgOnMd": "pf-m-spacer-lg-on-md",
    "spacerXlOnMd": "pf-m-spacer-xl-on-md",
    "spacer_2xlOnMd": "pf-m-spacer-2xl-on-md",
    "spacer_3xlOnMd": "pf-m-spacer-3xl-on-md",
    "spacer_4xlOnMd": "pf-m-spacer-4xl-on-md",
    "spacerNoneOnLg": "pf-m-spacer-none-on-lg",
    "spacerXsOnLg": "pf-m-spacer-xs-on-lg",
    "spacerSmOnLg": "pf-m-spacer-sm-on-lg",
    "spacerMdOnLg": "pf-m-spacer-md-on-lg",
    "spacerLgOnLg": "pf-m-spacer-lg-on-lg",
    "spacerXlOnLg": "pf-m-spacer-xl-on-lg",
    "spacer_2xlOnLg": "pf-m-spacer-2xl-on-lg",
    "spacer_3xlOnLg": "pf-m-spacer-3xl-on-lg",
    "spacer_4xlOnLg": "pf-m-spacer-4xl-on-lg",
    "spacerNoneOnXl": "pf-m-spacer-none-on-xl",
    "spacerXsOnXl": "pf-m-spacer-xs-on-xl",
    "spacerSmOnXl": "pf-m-spacer-sm-on-xl",
    "spacerMdOnXl": "pf-m-spacer-md-on-xl",
    "spacerLgOnXl": "pf-m-spacer-lg-on-xl",
    "spacerXlOnXl": "pf-m-spacer-xl-on-xl",
    "spacer_2xlOnXl": "pf-m-spacer-2xl-on-xl",
    "spacer_3xlOnXl": "pf-m-spacer-3xl-on-xl",
    "spacer_4xlOnXl": "pf-m-spacer-4xl-on-xl",
    "spacerNoneOn_2xl": "pf-m-spacer-none-on-2xl",
    "spacerXsOn_2xl": "pf-m-spacer-xs-on-2xl",
    "spacerSmOn_2xl": "pf-m-spacer-sm-on-2xl",
    "spacerMdOn_2xl": "pf-m-spacer-md-on-2xl",
    "spacerLgOn_2xl": "pf-m-spacer-lg-on-2xl",
    "spacerXlOn_2xl": "pf-m-spacer-xl-on-2xl",
    "spacer_2xlOn_2xl": "pf-m-spacer-2xl-on-2xl",
    "spacer_3xlOn_2xl": "pf-m-spacer-3xl-on-2xl",
    "spacer_4xlOn_2xl": "pf-m-spacer-4xl-on-2xl",
    "gap": "pf-m-gap",
    "gapNone": "pf-m-gap-none",
    "gapXs": "pf-m-gap-xs",
    "gapSm": "pf-m-gap-sm",
    "gapMd": "pf-m-gap-md",
    "gapLg": "pf-m-gap-lg",
    "gapXl": "pf-m-gap-xl",
    "gap_2xl": "pf-m-gap-2xl",
    "gap_3xl": "pf-m-gap-3xl",
    "gap_4xl": "pf-m-gap-4xl",
    "gapOnSm": "pf-m-gap-on-sm",
    "gapNoneOnSm": "pf-m-gap-none-on-sm",
    "gapXsOnSm": "pf-m-gap-xs-on-sm",
    "gapSmOnSm": "pf-m-gap-sm-on-sm",
    "gapMdOnSm": "pf-m-gap-md-on-sm",
    "gapLgOnSm": "pf-m-gap-lg-on-sm",
    "gapXlOnSm": "pf-m-gap-xl-on-sm",
    "gap_2xlOnSm": "pf-m-gap-2xl-on-sm",
    "gap_3xlOnSm": "pf-m-gap-3xl-on-sm",
    "gap_4xlOnSm": "pf-m-gap-4xl-on-sm",
    "gapOnMd": "pf-m-gap-on-md",
    "gapNoneOnMd": "pf-m-gap-none-on-md",
    "gapXsOnMd": "pf-m-gap-xs-on-md",
    "gapSmOnMd": "pf-m-gap-sm-on-md",
    "gapMdOnMd": "pf-m-gap-md-on-md",
    "gapLgOnMd": "pf-m-gap-lg-on-md",
    "gapXlOnMd": "pf-m-gap-xl-on-md",
    "gap_2xlOnMd": "pf-m-gap-2xl-on-md",
    "gap_3xlOnMd": "pf-m-gap-3xl-on-md",
    "gap_4xlOnMd": "pf-m-gap-4xl-on-md",
    "gapOnLg": "pf-m-gap-on-lg",
    "gapNoneOnLg": "pf-m-gap-none-on-lg",
    "gapXsOnLg": "pf-m-gap-xs-on-lg",
    "gapSmOnLg": "pf-m-gap-sm-on-lg",
    "gapMdOnLg": "pf-m-gap-md-on-lg",
    "gapLgOnLg": "pf-m-gap-lg-on-lg",
    "gapXlOnLg": "pf-m-gap-xl-on-lg",
    "gap_2xlOnLg": "pf-m-gap-2xl-on-lg",
    "gap_3xlOnLg": "pf-m-gap-3xl-on-lg",
    "gap_4xlOnLg": "pf-m-gap-4xl-on-lg",
    "gapOnXl": "pf-m-gap-on-xl",
    "gapNoneOnXl": "pf-m-gap-none-on-xl",
    "gapXsOnXl": "pf-m-gap-xs-on-xl",
    "gapSmOnXl": "pf-m-gap-sm-on-xl",
    "gapMdOnXl": "pf-m-gap-md-on-xl",
    "gapLgOnXl": "pf-m-gap-lg-on-xl",
    "gapXlOnXl": "pf-m-gap-xl-on-xl",
    "gap_2xlOnXl": "pf-m-gap-2xl-on-xl",
    "gap_3xlOnXl": "pf-m-gap-3xl-on-xl",
    "gap_4xlOnXl": "pf-m-gap-4xl-on-xl",
    "gapOn_2xl": "pf-m-gap-on-2xl",
    "gapNoneOn_2xl": "pf-m-gap-none-on-2xl",
    "gapXsOn_2xl": "pf-m-gap-xs-on-2xl",
    "gapSmOn_2xl": "pf-m-gap-sm-on-2xl",
    "gapMdOn_2xl": "pf-m-gap-md-on-2xl",
    "gapLgOn_2xl": "pf-m-gap-lg-on-2xl",
    "gapXlOn_2xl": "pf-m-gap-xl-on-2xl",
    "gap_2xlOn_2xl": "pf-m-gap-2xl-on-2xl",
    "gap_3xlOn_2xl": "pf-m-gap-3xl-on-2xl",
    "gap_4xlOn_2xl": "pf-m-gap-4xl-on-2xl",
    "rowGap": "pf-m-row-gap",
    "rowGapNone": "pf-m-row-gap-none",
    "rowGapXs": "pf-m-row-gap-xs",
    "rowGapSm": "pf-m-row-gap-sm",
    "rowGapMd": "pf-m-row-gap-md",
    "rowGapLg": "pf-m-row-gap-lg",
    "rowGapXl": "pf-m-row-gap-xl",
    "rowGap_2xl": "pf-m-row-gap-2xl",
    "rowGap_3xl": "pf-m-row-gap-3xl",
    "rowGap_4xl": "pf-m-row-gap-4xl",
    "rowGapOnSm": "pf-m-row-gap-on-sm",
    "rowGapNoneOnSm": "pf-m-row-gap-none-on-sm",
    "rowGapXsOnSm": "pf-m-row-gap-xs-on-sm",
    "rowGapSmOnSm": "pf-m-row-gap-sm-on-sm",
    "rowGapMdOnSm": "pf-m-row-gap-md-on-sm",
    "rowGapLgOnSm": "pf-m-row-gap-lg-on-sm",
    "rowGapXlOnSm": "pf-m-row-gap-xl-on-sm",
    "rowGap_2xlOnSm": "pf-m-row-gap-2xl-on-sm",
    "rowGap_3xlOnSm": "pf-m-row-gap-3xl-on-sm",
    "rowGap_4xlOnSm": "pf-m-row-gap-4xl-on-sm",
    "rowGapOnMd": "pf-m-row-gap-on-md",
    "rowGapNoneOnMd": "pf-m-row-gap-none-on-md",
    "rowGapXsOnMd": "pf-m-row-gap-xs-on-md",
    "rowGapSmOnMd": "pf-m-row-gap-sm-on-md",
    "rowGapMdOnMd": "pf-m-row-gap-md-on-md",
    "rowGapLgOnMd": "pf-m-row-gap-lg-on-md",
    "rowGapXlOnMd": "pf-m-row-gap-xl-on-md",
    "rowGap_2xlOnMd": "pf-m-row-gap-2xl-on-md",
    "rowGap_3xlOnMd": "pf-m-row-gap-3xl-on-md",
    "rowGap_4xlOnMd": "pf-m-row-gap-4xl-on-md",
    "rowGapOnLg": "pf-m-row-gap-on-lg",
    "rowGapNoneOnLg": "pf-m-row-gap-none-on-lg",
    "rowGapXsOnLg": "pf-m-row-gap-xs-on-lg",
    "rowGapSmOnLg": "pf-m-row-gap-sm-on-lg",
    "rowGapMdOnLg": "pf-m-row-gap-md-on-lg",
    "rowGapLgOnLg": "pf-m-row-gap-lg-on-lg",
    "rowGapXlOnLg": "pf-m-row-gap-xl-on-lg",
    "rowGap_2xlOnLg": "pf-m-row-gap-2xl-on-lg",
    "rowGap_3xlOnLg": "pf-m-row-gap-3xl-on-lg",
    "rowGap_4xlOnLg": "pf-m-row-gap-4xl-on-lg",
    "rowGapOnXl": "pf-m-row-gap-on-xl",
    "rowGapNoneOnXl": "pf-m-row-gap-none-on-xl",
    "rowGapXsOnXl": "pf-m-row-gap-xs-on-xl",
    "rowGapSmOnXl": "pf-m-row-gap-sm-on-xl",
    "rowGapMdOnXl": "pf-m-row-gap-md-on-xl",
    "rowGapLgOnXl": "pf-m-row-gap-lg-on-xl",
    "rowGapXlOnXl": "pf-m-row-gap-xl-on-xl",
    "rowGap_2xlOnXl": "pf-m-row-gap-2xl-on-xl",
    "rowGap_3xlOnXl": "pf-m-row-gap-3xl-on-xl",
    "rowGap_4xlOnXl": "pf-m-row-gap-4xl-on-xl",
    "rowGapOn_2xl": "pf-m-row-gap-on-2xl",
    "rowGapNoneOn_2xl": "pf-m-row-gap-none-on-2xl",
    "rowGapXsOn_2xl": "pf-m-row-gap-xs-on-2xl",
    "rowGapSmOn_2xl": "pf-m-row-gap-sm-on-2xl",
    "rowGapMdOn_2xl": "pf-m-row-gap-md-on-2xl",
    "rowGapLgOn_2xl": "pf-m-row-gap-lg-on-2xl",
    "rowGapXlOn_2xl": "pf-m-row-gap-xl-on-2xl",
    "rowGap_2xlOn_2xl": "pf-m-row-gap-2xl-on-2xl",
    "rowGap_3xlOn_2xl": "pf-m-row-gap-3xl-on-2xl",
    "rowGap_4xlOn_2xl": "pf-m-row-gap-4xl-on-2xl",
    "columnGap": "pf-m-column-gap",
    "columnGapNone": "pf-m-column-gap-none",
    "columnGapXs": "pf-m-column-gap-xs",
    "columnGapSm": "pf-m-column-gap-sm",
    "columnGapMd": "pf-m-column-gap-md",
    "columnGapLg": "pf-m-column-gap-lg",
    "columnGapXl": "pf-m-column-gap-xl",
    "columnGap_2xl": "pf-m-column-gap-2xl",
    "columnGap_3xl": "pf-m-column-gap-3xl",
    "columnGap_4xl": "pf-m-column-gap-4xl",
    "columnGapOnSm": "pf-m-column-gap-on-sm",
    "columnGapNoneOnSm": "pf-m-column-gap-none-on-sm",
    "columnGapXsOnSm": "pf-m-column-gap-xs-on-sm",
    "columnGapSmOnSm": "pf-m-column-gap-sm-on-sm",
    "columnGapMdOnSm": "pf-m-column-gap-md-on-sm",
    "columnGapLgOnSm": "pf-m-column-gap-lg-on-sm",
    "columnGapXlOnSm": "pf-m-column-gap-xl-on-sm",
    "columnGap_2xlOnSm": "pf-m-column-gap-2xl-on-sm",
    "columnGap_3xlOnSm": "pf-m-column-gap-3xl-on-sm",
    "columnGap_4xlOnSm": "pf-m-column-gap-4xl-on-sm",
    "columnGapOnMd": "pf-m-column-gap-on-md",
    "columnGapNoneOnMd": "pf-m-column-gap-none-on-md",
    "columnGapXsOnMd": "pf-m-column-gap-xs-on-md",
    "columnGapSmOnMd": "pf-m-column-gap-sm-on-md",
    "columnGapMdOnMd": "pf-m-column-gap-md-on-md",
    "columnGapLgOnMd": "pf-m-column-gap-lg-on-md",
    "columnGapXlOnMd": "pf-m-column-gap-xl-on-md",
    "columnGap_2xlOnMd": "pf-m-column-gap-2xl-on-md",
    "columnGap_3xlOnMd": "pf-m-column-gap-3xl-on-md",
    "columnGap_4xlOnMd": "pf-m-column-gap-4xl-on-md",
    "columnGapOnLg": "pf-m-column-gap-on-lg",
    "columnGapNoneOnLg": "pf-m-column-gap-none-on-lg",
    "columnGapXsOnLg": "pf-m-column-gap-xs-on-lg",
    "columnGapSmOnLg": "pf-m-column-gap-sm-on-lg",
    "columnGapMdOnLg": "pf-m-column-gap-md-on-lg",
    "columnGapLgOnLg": "pf-m-column-gap-lg-on-lg",
    "columnGapXlOnLg": "pf-m-column-gap-xl-on-lg",
    "columnGap_2xlOnLg": "pf-m-column-gap-2xl-on-lg",
    "columnGap_3xlOnLg": "pf-m-column-gap-3xl-on-lg",
    "columnGap_4xlOnLg": "pf-m-column-gap-4xl-on-lg",
    "columnGapOnXl": "pf-m-column-gap-on-xl",
    "columnGapNoneOnXl": "pf-m-column-gap-none-on-xl",
    "columnGapXsOnXl": "pf-m-column-gap-xs-on-xl",
    "columnGapSmOnXl": "pf-m-column-gap-sm-on-xl",
    "columnGapMdOnXl": "pf-m-column-gap-md-on-xl",
    "columnGapLgOnXl": "pf-m-column-gap-lg-on-xl",
    "columnGapXlOnXl": "pf-m-column-gap-xl-on-xl",
    "columnGap_2xlOnXl": "pf-m-column-gap-2xl-on-xl",
    "columnGap_3xlOnXl": "pf-m-column-gap-3xl-on-xl",
    "columnGap_4xlOnXl": "pf-m-column-gap-4xl-on-xl",
    "columnGapOn_2xl": "pf-m-column-gap-on-2xl",
    "columnGapNoneOn_2xl": "pf-m-column-gap-none-on-2xl",
    "columnGapXsOn_2xl": "pf-m-column-gap-xs-on-2xl",
    "columnGapSmOn_2xl": "pf-m-column-gap-sm-on-2xl",
    "columnGapMdOn_2xl": "pf-m-column-gap-md-on-2xl",
    "columnGapLgOn_2xl": "pf-m-column-gap-lg-on-2xl",
    "columnGapXlOn_2xl": "pf-m-column-gap-xl-on-2xl",
    "columnGap_2xlOn_2xl": "pf-m-column-gap-2xl-on-2xl",
    "columnGap_3xlOn_2xl": "pf-m-column-gap-3xl-on-2xl",
    "columnGap_4xlOn_2xl": "pf-m-column-gap-4xl-on-2xl"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Flex/Flex.js
var Flex = (_a2) => {
  var { children: children2 = null, className = "", component = "div", spacer, spaceItems, gap, rowGap, columnGap, grow, shrink, flex, direction, alignItems, alignContent, alignSelf, align, justifyContent, display, fullWidth, flexWrap, order: order2, style } = _a2, props = __rest(_a2, ["children", "className", "component", "spacer", "spaceItems", "gap", "rowGap", "columnGap", "grow", "shrink", "flex", "direction", "alignItems", "alignContent", "alignSelf", "align", "justifyContent", "display", "fullWidth", "flexWrap", "order", "style"]);
  const Component50 = component;
  return React348.createElement(Component50, Object.assign({ className: css(flex_default.flex, formatBreakpointMods(spacer, flex_default), formatBreakpointMods(spaceItems, flex_default), formatBreakpointMods(grow, flex_default), formatBreakpointMods(shrink, flex_default), formatBreakpointMods(flex, flex_default), formatBreakpointMods(direction, flex_default), formatBreakpointMods(alignItems, flex_default), formatBreakpointMods(alignContent, flex_default), formatBreakpointMods(alignSelf, flex_default), formatBreakpointMods(align, flex_default), formatBreakpointMods(justifyContent, flex_default), formatBreakpointMods(display, flex_default), formatBreakpointMods(fullWidth, flex_default), formatBreakpointMods(flexWrap, flex_default), formatBreakpointMods(gap, flex_default), formatBreakpointMods(rowGap, flex_default), formatBreakpointMods(columnGap, flex_default), className), style: style || order2 ? Object.assign(Object.assign({}, style), setBreakpointCssVars(order2, l_flex_item_Order.name)) : void 0 }, props), children2);
};
Flex.displayName = "Flex";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Flex/FlexItem.js
var React349 = __toESM(require_react());
var FlexItem = (_a2) => {
  var { children: children2 = null, className = "", component = "div", spacer, grow, shrink, flex, alignSelf, align, fullWidth, order: order2, style } = _a2, props = __rest(_a2, ["children", "className", "component", "spacer", "grow", "shrink", "flex", "alignSelf", "align", "fullWidth", "order", "style"]);
  const Component50 = component;
  return React349.createElement(Component50, Object.assign({}, props, { className: css(formatBreakpointMods(spacer, flex_default), formatBreakpointMods(grow, flex_default), formatBreakpointMods(shrink, flex_default), formatBreakpointMods(flex, flex_default), formatBreakpointMods(alignSelf, flex_default), formatBreakpointMods(align, flex_default), formatBreakpointMods(fullWidth, flex_default), className), style: style || order2 ? Object.assign(Object.assign({}, style), setBreakpointCssVars(order2, l_flex_item_Order.name)) : void 0 }), children2);
};
FlexItem.displayName = "FlexItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Gallery/Gallery.js
var React350 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Gallery/gallery.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Gallery/gallery.css";
var gallery_default = {
  "gallery": "pf-v6-l-gallery",
  "modifiers": {
    "gutter": "pf-m-gutter"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Gallery/Gallery.js
var Gallery = (_a2) => {
  var { children: children2 = null, className = "", component = "div", hasGutter = false, minWidths, maxWidths } = _a2, props = __rest(_a2, ["children", "className", "component", "hasGutter", "minWidths", "maxWidths"]);
  const minWidthStyles = {};
  const Component50 = component;
  if (minWidths) {
    Object.entries(minWidths || {}).map(([breakpoint, value]) => minWidthStyles[`${l_gallery_GridTemplateColumns_min_default.name}${breakpoint !== "default" ? `-on-${breakpoint}` : ""}`] = value);
  }
  const maxWidthStyles = {};
  if (maxWidths) {
    Object.entries(maxWidths || {}).map(([breakpoint, value]) => maxWidthStyles[`${l_gallery_GridTemplateColumns_max_default.name}${breakpoint !== "default" ? `-on-${breakpoint}` : ""}`] = value);
  }
  const widthStyles = Object.assign(Object.assign({}, minWidthStyles), maxWidthStyles);
  return React350.createElement(Component50, Object.assign({ className: css(gallery_default.gallery, hasGutter && gallery_default.modifiers.gutter, className) }, props, (minWidths || maxWidths) && { style: Object.assign(Object.assign({}, widthStyles), props.style) }), children2);
};
Gallery.displayName = "Gallery";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Gallery/GalleryItem.js
var React351 = __toESM(require_react());
var GalleryItem = (_a2) => {
  var { children: children2 = null, component = "div" } = _a2, props = __rest(_a2, ["children", "component"]);
  const Component50 = component;
  return React351.createElement(Component50, Object.assign({}, props), children2);
};
GalleryItem.displayName = "GalleryItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Grid/Grid.js
var React352 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Grid/grid.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Grid/grid.css";
var grid_default = {
  "grid": "pf-v6-l-grid",
  "gridItem": "pf-v6-l-grid__item",
  "modifiers": {
    "all_1Col": "pf-m-all-1-col",
    "all_2Col": "pf-m-all-2-col",
    "all_3Col": "pf-m-all-3-col",
    "all_4Col": "pf-m-all-4-col",
    "all_5Col": "pf-m-all-5-col",
    "all_6Col": "pf-m-all-6-col",
    "all_7Col": "pf-m-all-7-col",
    "all_8Col": "pf-m-all-8-col",
    "all_9Col": "pf-m-all-9-col",
    "all_10Col": "pf-m-all-10-col",
    "all_11Col": "pf-m-all-11-col",
    "all_12Col": "pf-m-all-12-col",
    "all_1ColOnSm": "pf-m-all-1-col-on-sm",
    "all_2ColOnSm": "pf-m-all-2-col-on-sm",
    "all_3ColOnSm": "pf-m-all-3-col-on-sm",
    "all_4ColOnSm": "pf-m-all-4-col-on-sm",
    "all_5ColOnSm": "pf-m-all-5-col-on-sm",
    "all_6ColOnSm": "pf-m-all-6-col-on-sm",
    "all_7ColOnSm": "pf-m-all-7-col-on-sm",
    "all_8ColOnSm": "pf-m-all-8-col-on-sm",
    "all_9ColOnSm": "pf-m-all-9-col-on-sm",
    "all_10ColOnSm": "pf-m-all-10-col-on-sm",
    "all_11ColOnSm": "pf-m-all-11-col-on-sm",
    "all_12ColOnSm": "pf-m-all-12-col-on-sm",
    "all_1ColOnMd": "pf-m-all-1-col-on-md",
    "all_2ColOnMd": "pf-m-all-2-col-on-md",
    "all_3ColOnMd": "pf-m-all-3-col-on-md",
    "all_4ColOnMd": "pf-m-all-4-col-on-md",
    "all_5ColOnMd": "pf-m-all-5-col-on-md",
    "all_6ColOnMd": "pf-m-all-6-col-on-md",
    "all_7ColOnMd": "pf-m-all-7-col-on-md",
    "all_8ColOnMd": "pf-m-all-8-col-on-md",
    "all_9ColOnMd": "pf-m-all-9-col-on-md",
    "all_10ColOnMd": "pf-m-all-10-col-on-md",
    "all_11ColOnMd": "pf-m-all-11-col-on-md",
    "all_12ColOnMd": "pf-m-all-12-col-on-md",
    "all_1ColOnLg": "pf-m-all-1-col-on-lg",
    "all_2ColOnLg": "pf-m-all-2-col-on-lg",
    "all_3ColOnLg": "pf-m-all-3-col-on-lg",
    "all_4ColOnLg": "pf-m-all-4-col-on-lg",
    "all_5ColOnLg": "pf-m-all-5-col-on-lg",
    "all_6ColOnLg": "pf-m-all-6-col-on-lg",
    "all_7ColOnLg": "pf-m-all-7-col-on-lg",
    "all_8ColOnLg": "pf-m-all-8-col-on-lg",
    "all_9ColOnLg": "pf-m-all-9-col-on-lg",
    "all_10ColOnLg": "pf-m-all-10-col-on-lg",
    "all_11ColOnLg": "pf-m-all-11-col-on-lg",
    "all_12ColOnLg": "pf-m-all-12-col-on-lg",
    "all_1ColOnXl": "pf-m-all-1-col-on-xl",
    "all_2ColOnXl": "pf-m-all-2-col-on-xl",
    "all_3ColOnXl": "pf-m-all-3-col-on-xl",
    "all_4ColOnXl": "pf-m-all-4-col-on-xl",
    "all_5ColOnXl": "pf-m-all-5-col-on-xl",
    "all_6ColOnXl": "pf-m-all-6-col-on-xl",
    "all_7ColOnXl": "pf-m-all-7-col-on-xl",
    "all_8ColOnXl": "pf-m-all-8-col-on-xl",
    "all_9ColOnXl": "pf-m-all-9-col-on-xl",
    "all_10ColOnXl": "pf-m-all-10-col-on-xl",
    "all_11ColOnXl": "pf-m-all-11-col-on-xl",
    "all_12ColOnXl": "pf-m-all-12-col-on-xl",
    "all_1ColOn_2xl": "pf-m-all-1-col-on-2xl",
    "all_2ColOn_2xl": "pf-m-all-2-col-on-2xl",
    "all_3ColOn_2xl": "pf-m-all-3-col-on-2xl",
    "all_4ColOn_2xl": "pf-m-all-4-col-on-2xl",
    "all_5ColOn_2xl": "pf-m-all-5-col-on-2xl",
    "all_6ColOn_2xl": "pf-m-all-6-col-on-2xl",
    "all_7ColOn_2xl": "pf-m-all-7-col-on-2xl",
    "all_8ColOn_2xl": "pf-m-all-8-col-on-2xl",
    "all_9ColOn_2xl": "pf-m-all-9-col-on-2xl",
    "all_10ColOn_2xl": "pf-m-all-10-col-on-2xl",
    "all_11ColOn_2xl": "pf-m-all-11-col-on-2xl",
    "all_12ColOn_2xl": "pf-m-all-12-col-on-2xl",
    "1Col": "pf-m-1-col",
    "2Col": "pf-m-2-col",
    "3Col": "pf-m-3-col",
    "4Col": "pf-m-4-col",
    "5Col": "pf-m-5-col",
    "6Col": "pf-m-6-col",
    "7Col": "pf-m-7-col",
    "8Col": "pf-m-8-col",
    "9Col": "pf-m-9-col",
    "10Col": "pf-m-10-col",
    "11Col": "pf-m-11-col",
    "12Col": "pf-m-12-col",
    "offset_1Col": "pf-m-offset-1-col",
    "offset_2Col": "pf-m-offset-2-col",
    "offset_3Col": "pf-m-offset-3-col",
    "offset_4Col": "pf-m-offset-4-col",
    "offset_5Col": "pf-m-offset-5-col",
    "offset_6Col": "pf-m-offset-6-col",
    "offset_7Col": "pf-m-offset-7-col",
    "offset_8Col": "pf-m-offset-8-col",
    "offset_9Col": "pf-m-offset-9-col",
    "offset_10Col": "pf-m-offset-10-col",
    "offset_11Col": "pf-m-offset-11-col",
    "offset_12Col": "pf-m-offset-12-col",
    "1Row": "pf-m-1-row",
    "2Row": "pf-m-2-row",
    "3Row": "pf-m-3-row",
    "4Row": "pf-m-4-row",
    "5Row": "pf-m-5-row",
    "6Row": "pf-m-6-row",
    "7Row": "pf-m-7-row",
    "8Row": "pf-m-8-row",
    "9Row": "pf-m-9-row",
    "10Row": "pf-m-10-row",
    "11Row": "pf-m-11-row",
    "12Row": "pf-m-12-row",
    "1ColOnSm": "pf-m-1-col-on-sm",
    "2ColOnSm": "pf-m-2-col-on-sm",
    "3ColOnSm": "pf-m-3-col-on-sm",
    "4ColOnSm": "pf-m-4-col-on-sm",
    "5ColOnSm": "pf-m-5-col-on-sm",
    "6ColOnSm": "pf-m-6-col-on-sm",
    "7ColOnSm": "pf-m-7-col-on-sm",
    "8ColOnSm": "pf-m-8-col-on-sm",
    "9ColOnSm": "pf-m-9-col-on-sm",
    "10ColOnSm": "pf-m-10-col-on-sm",
    "11ColOnSm": "pf-m-11-col-on-sm",
    "12ColOnSm": "pf-m-12-col-on-sm",
    "offset_1ColOnSm": "pf-m-offset-1-col-on-sm",
    "offset_2ColOnSm": "pf-m-offset-2-col-on-sm",
    "offset_3ColOnSm": "pf-m-offset-3-col-on-sm",
    "offset_4ColOnSm": "pf-m-offset-4-col-on-sm",
    "offset_5ColOnSm": "pf-m-offset-5-col-on-sm",
    "offset_6ColOnSm": "pf-m-offset-6-col-on-sm",
    "offset_7ColOnSm": "pf-m-offset-7-col-on-sm",
    "offset_8ColOnSm": "pf-m-offset-8-col-on-sm",
    "offset_9ColOnSm": "pf-m-offset-9-col-on-sm",
    "offset_10ColOnSm": "pf-m-offset-10-col-on-sm",
    "offset_11ColOnSm": "pf-m-offset-11-col-on-sm",
    "offset_12ColOnSm": "pf-m-offset-12-col-on-sm",
    "1RowOnSm": "pf-m-1-row-on-sm",
    "2RowOnSm": "pf-m-2-row-on-sm",
    "3RowOnSm": "pf-m-3-row-on-sm",
    "4RowOnSm": "pf-m-4-row-on-sm",
    "5RowOnSm": "pf-m-5-row-on-sm",
    "6RowOnSm": "pf-m-6-row-on-sm",
    "7RowOnSm": "pf-m-7-row-on-sm",
    "8RowOnSm": "pf-m-8-row-on-sm",
    "9RowOnSm": "pf-m-9-row-on-sm",
    "10RowOnSm": "pf-m-10-row-on-sm",
    "11RowOnSm": "pf-m-11-row-on-sm",
    "12RowOnSm": "pf-m-12-row-on-sm",
    "1ColOnMd": "pf-m-1-col-on-md",
    "2ColOnMd": "pf-m-2-col-on-md",
    "3ColOnMd": "pf-m-3-col-on-md",
    "4ColOnMd": "pf-m-4-col-on-md",
    "5ColOnMd": "pf-m-5-col-on-md",
    "6ColOnMd": "pf-m-6-col-on-md",
    "7ColOnMd": "pf-m-7-col-on-md",
    "8ColOnMd": "pf-m-8-col-on-md",
    "9ColOnMd": "pf-m-9-col-on-md",
    "10ColOnMd": "pf-m-10-col-on-md",
    "11ColOnMd": "pf-m-11-col-on-md",
    "12ColOnMd": "pf-m-12-col-on-md",
    "offset_1ColOnMd": "pf-m-offset-1-col-on-md",
    "offset_2ColOnMd": "pf-m-offset-2-col-on-md",
    "offset_3ColOnMd": "pf-m-offset-3-col-on-md",
    "offset_4ColOnMd": "pf-m-offset-4-col-on-md",
    "offset_5ColOnMd": "pf-m-offset-5-col-on-md",
    "offset_6ColOnMd": "pf-m-offset-6-col-on-md",
    "offset_7ColOnMd": "pf-m-offset-7-col-on-md",
    "offset_8ColOnMd": "pf-m-offset-8-col-on-md",
    "offset_9ColOnMd": "pf-m-offset-9-col-on-md",
    "offset_10ColOnMd": "pf-m-offset-10-col-on-md",
    "offset_11ColOnMd": "pf-m-offset-11-col-on-md",
    "offset_12ColOnMd": "pf-m-offset-12-col-on-md",
    "1RowOnMd": "pf-m-1-row-on-md",
    "2RowOnMd": "pf-m-2-row-on-md",
    "3RowOnMd": "pf-m-3-row-on-md",
    "4RowOnMd": "pf-m-4-row-on-md",
    "5RowOnMd": "pf-m-5-row-on-md",
    "6RowOnMd": "pf-m-6-row-on-md",
    "7RowOnMd": "pf-m-7-row-on-md",
    "8RowOnMd": "pf-m-8-row-on-md",
    "9RowOnMd": "pf-m-9-row-on-md",
    "10RowOnMd": "pf-m-10-row-on-md",
    "11RowOnMd": "pf-m-11-row-on-md",
    "12RowOnMd": "pf-m-12-row-on-md",
    "1ColOnLg": "pf-m-1-col-on-lg",
    "2ColOnLg": "pf-m-2-col-on-lg",
    "3ColOnLg": "pf-m-3-col-on-lg",
    "4ColOnLg": "pf-m-4-col-on-lg",
    "5ColOnLg": "pf-m-5-col-on-lg",
    "6ColOnLg": "pf-m-6-col-on-lg",
    "7ColOnLg": "pf-m-7-col-on-lg",
    "8ColOnLg": "pf-m-8-col-on-lg",
    "9ColOnLg": "pf-m-9-col-on-lg",
    "10ColOnLg": "pf-m-10-col-on-lg",
    "11ColOnLg": "pf-m-11-col-on-lg",
    "12ColOnLg": "pf-m-12-col-on-lg",
    "offset_1ColOnLg": "pf-m-offset-1-col-on-lg",
    "offset_2ColOnLg": "pf-m-offset-2-col-on-lg",
    "offset_3ColOnLg": "pf-m-offset-3-col-on-lg",
    "offset_4ColOnLg": "pf-m-offset-4-col-on-lg",
    "offset_5ColOnLg": "pf-m-offset-5-col-on-lg",
    "offset_6ColOnLg": "pf-m-offset-6-col-on-lg",
    "offset_7ColOnLg": "pf-m-offset-7-col-on-lg",
    "offset_8ColOnLg": "pf-m-offset-8-col-on-lg",
    "offset_9ColOnLg": "pf-m-offset-9-col-on-lg",
    "offset_10ColOnLg": "pf-m-offset-10-col-on-lg",
    "offset_11ColOnLg": "pf-m-offset-11-col-on-lg",
    "offset_12ColOnLg": "pf-m-offset-12-col-on-lg",
    "1RowOnLg": "pf-m-1-row-on-lg",
    "2RowOnLg": "pf-m-2-row-on-lg",
    "3RowOnLg": "pf-m-3-row-on-lg",
    "4RowOnLg": "pf-m-4-row-on-lg",
    "5RowOnLg": "pf-m-5-row-on-lg",
    "6RowOnLg": "pf-m-6-row-on-lg",
    "7RowOnLg": "pf-m-7-row-on-lg",
    "8RowOnLg": "pf-m-8-row-on-lg",
    "9RowOnLg": "pf-m-9-row-on-lg",
    "10RowOnLg": "pf-m-10-row-on-lg",
    "11RowOnLg": "pf-m-11-row-on-lg",
    "12RowOnLg": "pf-m-12-row-on-lg",
    "1ColOnXl": "pf-m-1-col-on-xl",
    "2ColOnXl": "pf-m-2-col-on-xl",
    "3ColOnXl": "pf-m-3-col-on-xl",
    "4ColOnXl": "pf-m-4-col-on-xl",
    "5ColOnXl": "pf-m-5-col-on-xl",
    "6ColOnXl": "pf-m-6-col-on-xl",
    "7ColOnXl": "pf-m-7-col-on-xl",
    "8ColOnXl": "pf-m-8-col-on-xl",
    "9ColOnXl": "pf-m-9-col-on-xl",
    "10ColOnXl": "pf-m-10-col-on-xl",
    "11ColOnXl": "pf-m-11-col-on-xl",
    "12ColOnXl": "pf-m-12-col-on-xl",
    "offset_1ColOnXl": "pf-m-offset-1-col-on-xl",
    "offset_2ColOnXl": "pf-m-offset-2-col-on-xl",
    "offset_3ColOnXl": "pf-m-offset-3-col-on-xl",
    "offset_4ColOnXl": "pf-m-offset-4-col-on-xl",
    "offset_5ColOnXl": "pf-m-offset-5-col-on-xl",
    "offset_6ColOnXl": "pf-m-offset-6-col-on-xl",
    "offset_7ColOnXl": "pf-m-offset-7-col-on-xl",
    "offset_8ColOnXl": "pf-m-offset-8-col-on-xl",
    "offset_9ColOnXl": "pf-m-offset-9-col-on-xl",
    "offset_10ColOnXl": "pf-m-offset-10-col-on-xl",
    "offset_11ColOnXl": "pf-m-offset-11-col-on-xl",
    "offset_12ColOnXl": "pf-m-offset-12-col-on-xl",
    "1RowOnXl": "pf-m-1-row-on-xl",
    "2RowOnXl": "pf-m-2-row-on-xl",
    "3RowOnXl": "pf-m-3-row-on-xl",
    "4RowOnXl": "pf-m-4-row-on-xl",
    "5RowOnXl": "pf-m-5-row-on-xl",
    "6RowOnXl": "pf-m-6-row-on-xl",
    "7RowOnXl": "pf-m-7-row-on-xl",
    "8RowOnXl": "pf-m-8-row-on-xl",
    "9RowOnXl": "pf-m-9-row-on-xl",
    "10RowOnXl": "pf-m-10-row-on-xl",
    "11RowOnXl": "pf-m-11-row-on-xl",
    "12RowOnXl": "pf-m-12-row-on-xl",
    "1ColOn_2xl": "pf-m-1-col-on-2xl",
    "2ColOn_2xl": "pf-m-2-col-on-2xl",
    "3ColOn_2xl": "pf-m-3-col-on-2xl",
    "4ColOn_2xl": "pf-m-4-col-on-2xl",
    "5ColOn_2xl": "pf-m-5-col-on-2xl",
    "6ColOn_2xl": "pf-m-6-col-on-2xl",
    "7ColOn_2xl": "pf-m-7-col-on-2xl",
    "8ColOn_2xl": "pf-m-8-col-on-2xl",
    "9ColOn_2xl": "pf-m-9-col-on-2xl",
    "10ColOn_2xl": "pf-m-10-col-on-2xl",
    "11ColOn_2xl": "pf-m-11-col-on-2xl",
    "12ColOn_2xl": "pf-m-12-col-on-2xl",
    "offset_1ColOn_2xl": "pf-m-offset-1-col-on-2xl",
    "offset_2ColOn_2xl": "pf-m-offset-2-col-on-2xl",
    "offset_3ColOn_2xl": "pf-m-offset-3-col-on-2xl",
    "offset_4ColOn_2xl": "pf-m-offset-4-col-on-2xl",
    "offset_5ColOn_2xl": "pf-m-offset-5-col-on-2xl",
    "offset_6ColOn_2xl": "pf-m-offset-6-col-on-2xl",
    "offset_7ColOn_2xl": "pf-m-offset-7-col-on-2xl",
    "offset_8ColOn_2xl": "pf-m-offset-8-col-on-2xl",
    "offset_9ColOn_2xl": "pf-m-offset-9-col-on-2xl",
    "offset_10ColOn_2xl": "pf-m-offset-10-col-on-2xl",
    "offset_11ColOn_2xl": "pf-m-offset-11-col-on-2xl",
    "offset_12ColOn_2xl": "pf-m-offset-12-col-on-2xl",
    "1RowOn_2xl": "pf-m-1-row-on-2xl",
    "2RowOn_2xl": "pf-m-2-row-on-2xl",
    "3RowOn_2xl": "pf-m-3-row-on-2xl",
    "4RowOn_2xl": "pf-m-4-row-on-2xl",
    "5RowOn_2xl": "pf-m-5-row-on-2xl",
    "6RowOn_2xl": "pf-m-6-row-on-2xl",
    "7RowOn_2xl": "pf-m-7-row-on-2xl",
    "8RowOn_2xl": "pf-m-8-row-on-2xl",
    "9RowOn_2xl": "pf-m-9-row-on-2xl",
    "10RowOn_2xl": "pf-m-10-row-on-2xl",
    "11RowOn_2xl": "pf-m-11-row-on-2xl",
    "12RowOn_2xl": "pf-m-12-row-on-2xl",
    "gutter": "pf-m-gutter"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/styles/sizes.js
var BaseSizes;
(function(BaseSizes2) {
  BaseSizes2["xs"] = "xs";
  BaseSizes2["sm"] = "sm";
  BaseSizes2["md"] = "md";
  BaseSizes2["lg"] = "lg";
  BaseSizes2["xl"] = "xl";
  BaseSizes2["2xl"] = "2xl";
  BaseSizes2["3xl"] = "3xl";
  BaseSizes2["4xl"] = "4xl";
})(BaseSizes || (BaseSizes = {}));
var DeviceSizes;
(function(DeviceSizes2) {
  DeviceSizes2["sm"] = "Sm";
  DeviceSizes2["md"] = "Md";
  DeviceSizes2["lg"] = "Lg";
  DeviceSizes2["xl"] = "Xl";
  DeviceSizes2["xl2"] = "_2xl";
})(DeviceSizes || (DeviceSizes = {}));

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Grid/Grid.js
var Grid = (_a2) => {
  var { children: children2 = null, className = "", component = "div", hasGutter, span = null, order: order2, style } = _a2, props = __rest(_a2, ["children", "className", "component", "hasGutter", "span", "order", "style"]);
  const classes = [grid_default.grid, span && grid_default.modifiers[`all_${span}Col`]];
  const Component50 = component;
  Object.entries(DeviceSizes).forEach(([propKey, gridSpanModifier]) => {
    const key = propKey;
    const propValue = props[key];
    if (propValue) {
      classes.push(grid_default.modifiers[`all_${propValue}ColOn${gridSpanModifier}`]);
    }
    delete props[key];
  });
  return React352.createElement(Component50, Object.assign({ className: css(...classes, hasGutter && grid_default.modifiers.gutter, className), style: style || order2 ? Object.assign(Object.assign({}, style), setBreakpointCssVars(order2, l_grid_item_Order.name)) : void 0 }, props), children2);
};
Grid.displayName = "Grid";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Grid/GridItem.js
var React353 = __toESM(require_react());
var GridItem = (_a2) => {
  var { children: children2 = null, className = "", component = "div", span = null, rowSpan = null, offset: offset3 = null, order: order2, style } = _a2, props = __rest(_a2, ["children", "className", "component", "span", "rowSpan", "offset", "order", "style"]);
  const classes = [
    grid_default.gridItem,
    span && grid_default.modifiers[`${span}Col`],
    rowSpan && grid_default.modifiers[`${rowSpan}Row`],
    offset3 && grid_default.modifiers[`offset_${offset3}Col`]
  ];
  const Component50 = component;
  Object.entries(DeviceSizes).forEach(([propKey, classModifier]) => {
    const key = propKey;
    const rowSpanKey = `${key}RowSpan`;
    const offsetKey = `${key}Offset`;
    const spanValue = props[key];
    const rowSpanValue = props[rowSpanKey];
    const offsetValue = props[offsetKey];
    if (spanValue) {
      classes.push(grid_default.modifiers[`${spanValue}ColOn${classModifier}`]);
    }
    if (rowSpanValue) {
      classes.push(grid_default.modifiers[`${rowSpanValue}RowOn${classModifier}`]);
    }
    if (offsetValue) {
      classes.push(grid_default.modifiers[`offset_${offsetValue}ColOn${classModifier}`]);
    }
    delete props[key];
    delete props[rowSpanKey];
    delete props[offsetKey];
  });
  return React353.createElement(Component50, Object.assign({ className: css(...classes, className), style: style || order2 ? Object.assign(Object.assign({}, style), setBreakpointCssVars(order2, l_grid_item_Order.name)) : void 0 }, props), children2);
};
GridItem.displayName = "GridItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Level/Level.js
var React354 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Level/level.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Level/level.css";
var level_default = {
  "level": "pf-v6-l-level",
  "modifiers": {
    "gutter": "pf-m-gutter"
  }
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Level/Level.js
var Level = (_a2) => {
  var { hasGutter, className = "", children: children2 = null } = _a2, props = __rest(_a2, ["hasGutter", "className", "children"]);
  return React354.createElement("div", Object.assign({}, props, { className: css(level_default.level, hasGutter && level_default.modifiers.gutter, className) }), children2);
};
Level.displayName = "Level";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Level/LevelItem.js
var React355 = __toESM(require_react());
var LevelItem = (_a2) => {
  var { children: children2 = null } = _a2, props = __rest(_a2, ["children"]);
  return React355.createElement("div", Object.assign({}, props), children2);
};
LevelItem.displayName = "LevelItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Split/Split.js
var React356 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Split/split.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Split/split.css";
var split_default = {
  "modifiers": {
    "wrap": "pf-m-wrap",
    "fill": "pf-m-fill",
    "gutter": "pf-m-gutter"
  },
  "split": "pf-v6-l-split",
  "splitItem": "pf-v6-l-split__item"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Split/Split.js
var Split = (_a2) => {
  var { hasGutter = false, isWrappable = false, className = "", children: children2 = null, component = "div" } = _a2, props = __rest(_a2, ["hasGutter", "isWrappable", "className", "children", "component"]);
  const Component50 = component;
  return React356.createElement(Component50, Object.assign({}, props, { className: css(split_default.split, hasGutter && split_default.modifiers.gutter, isWrappable && split_default.modifiers.wrap, className) }), children2);
};
Split.displayName = "Split";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Split/SplitItem.js
var React357 = __toESM(require_react());
var SplitItem = (_a2) => {
  var { isFilled = false, className = "", children: children2 = null } = _a2, props = __rest(_a2, ["isFilled", "className", "children"]);
  return React357.createElement("div", Object.assign({}, props, { className: css(split_default.splitItem, isFilled && split_default.modifiers.fill, className) }), children2);
};
SplitItem.displayName = "SplitItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Stack/Stack.js
var React358 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Stack/stack.mjs
import "/Users/ishukla/Desktop/Work/Debezium stage/Stage/node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/node_modules/@patternfly/react-styles/css/layouts/Stack/stack.css";
var stack_default = {
  "modifiers": {
    "fill": "pf-m-fill",
    "gutter": "pf-m-gutter"
  },
  "stack": "pf-v6-l-stack",
  "stackItem": "pf-v6-l-stack__item"
};

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Stack/Stack.js
var Stack = (_a2) => {
  var { hasGutter = false, className = "", children: children2 = null, component = "div" } = _a2, props = __rest(_a2, ["hasGutter", "className", "children", "component"]);
  const Component50 = component;
  return React358.createElement(Component50, Object.assign({}, props, { className: css(stack_default.stack, hasGutter && stack_default.modifiers.gutter, className) }), children2);
};
Stack.displayName = "Stack";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-core/dist/esm/layouts/Stack/StackItem.js
var React359 = __toESM(require_react());
var StackItem = (_a2) => {
  var { isFilled = false, className = "", children: children2 = null } = _a2, props = __rest(_a2, ["isFilled", "className", "children"]);
  return React359.createElement("div", Object.assign({}, props, { className: css(stack_default.stackItem, isFilled && stack_default.modifiers.fill, className) }), children2);
};
StackItem.displayName = "StackItem";

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-styles/dist/esm/index.js
function css2(...args) {
  const classes = [];
  const hasOwn = {}.hasOwnProperty;
  args.filter(Boolean).forEach((arg) => {
    const argType = typeof arg;
    if (argType === "string" || argType === "number") {
      classes.push(arg);
    } else if (Array.isArray(arg) && arg.length) {
      const inner2 = css2(...arg);
      if (inner2) {
        classes.push(inner2);
      }
    } else if (argType === "object") {
      for (const key in arg) {
        if (hasOwn.call(arg, key) && arg[key]) {
          classes.push(key);
        }
      }
    }
  });
  return classes.join(" ");
}

// node_modules/@patternfly/react-topology/dist/esm/components/TopologyView/TopologyView.js
var import_topology_view2 = __toESM(require_topology_view());
var import_topology_side_bar2 = __toESM(require_topology_side_bar());
var import_topology_controlbar2 = __toESM(require_topology_controlbar());
var TopologyView = (_a2) => {
  var { className = "", contextToolbar = null, viewToolbar = null, children: children2 = null, controlBar = null, sideBar = null, sideBarResizable = false, sideBarOpen = false, defaultSideBarSize = "500px", minSideBarSize = "150px", maxSideBarSize = "100%", onSideBarResize = () => {
  } } = _a2, props = __rest(_a2, ["className", "contextToolbar", "viewToolbar", "children", "controlBar", "sideBar", "sideBarResizable", "sideBarOpen", "defaultSideBarSize", "minSideBarSize", "maxSideBarSize", "onSideBarResize"]);
  const topologyContent = !sideBarResizable ? React360.createElement(
    StackItem,
    { isFilled: true, className: css2(import_topology_view2.default.topologyContainer, sideBar && import_topology_side_bar2.default.topologyContainerWithSidebar, sideBarOpen && import_topology_side_bar2.default.topologyContainerWithSidebarOpen) },
    React360.createElement(
      "div",
      { className: css2(import_topology_view2.default.topologyContent) },
      children2,
      controlBar && React360.createElement("span", { className: css2(import_topology_controlbar2.default.topologyControlBar) }, controlBar)
    ),
    sideBar
  ) : React360.createElement(
    StackItem,
    { isFilled: true, className: css2(import_topology_view2.default.topologyContainer) },
    React360.createElement(
      Drawer,
      { isExpanded: sideBarOpen, isInline: true },
      React360.createElement(
        DrawerContent,
        { panelContent: React360.createElement(DrawerPanelContent, { isResizable: sideBarResizable, id: "topology-resize-panel", defaultSize: defaultSideBarSize, minSize: minSideBarSize, maxSize: maxSideBarSize, onResize: (_event, width, id2) => onSideBarResize(width, id2) }, sideBar) },
        React360.createElement(
          DrawerContentBody,
          null,
          React360.createElement(
            "div",
            { className: css2(import_topology_view2.default.topologyContent) },
            children2,
            controlBar && React360.createElement("span", { className: css2(import_topology_controlbar2.default.topologyControlBar) }, controlBar)
          )
        )
      )
    )
  );
  return React360.createElement(
    Stack,
    Object.assign({ className }, props),
    contextToolbar || viewToolbar ? React360.createElement(
      StackItem,
      { isFilled: false },
      React360.createElement(GenerateId, { prefix: "pf-topology-view-" }, (randomId) => React360.createElement(
        Toolbar,
        { id: randomId },
        contextToolbar && React360.createElement(
          ToolbarContent,
          null,
          React360.createElement(ToolbarGroup, { className: "pf-topology-view__project-toolbar" }, contextToolbar)
        ),
        viewToolbar && React360.createElement(
          ToolbarContent,
          null,
          React360.createElement(ToolbarGroup, { className: "pf-topology-view__view-toolbar" }, viewToolbar)
        ),
        React360.createElement(Divider, null)
      ))
    ) : null,
    topologyContent
  );
};
TopologyView.displayName = "TopologyView";

// node_modules/@patternfly/react-topology/dist/esm/components/TopologyControlBar/TopologyControlBar.js
var React362 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/createIcon.js
var React361 = __toESM(require_react());
var currentId3 = 0;
function createIcon2({ name, xOffset = 0, yOffset = 0, width, height, svgPath }) {
  var _a2;
  return _a2 = class SVGIcon extends React361.Component {
    constructor() {
      super(...arguments);
      this.id = `icon-title-${currentId3++}`;
    }
    render() {
      const _b = this.props, { title, className } = _b, props = __rest(_b, ["title", "className"]);
      const classes = className ? `pf-v6-svg ${className}` : "pf-v6-svg";
      const hasTitle = Boolean(title);
      const viewBox = [xOffset, yOffset, width, height].join(" ");
      return React361.createElement(
        "svg",
        Object.assign({ className: classes, viewBox, fill: "currentColor", "aria-labelledby": hasTitle ? this.id : null, "aria-hidden": hasTitle ? null : true, role: "img", width: "1em", height: "1em" }, props),
        hasTitle && React361.createElement("title", { id: this.id }, title),
        React361.createElement("path", { d: svgPath })
      );
    }
  }, _a2.displayName = name, _a2;
}

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/expand-icon.js
var ExpandIconConfig = {
  name: "ExpandIcon",
  height: 512,
  width: 448,
  svgPath: "M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H64v84c0 6.6-5.4 12-12 12H12c-6.6 0-12-5.4-12-12zM288 44v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12V56c0-13.3-10.7-24-24-24H300c-6.6 0-12 5.4-12 12zm148 276h-40c-6.6 0-12 5.4-12 12v84h-84c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24V332c0-6.6-5.4-12-12-12zM160 468v-40c0-6.6-5.4-12-12-12H64v-84c0-6.6-5.4-12-12-12H12c-6.6 0-12 5.4-12 12v124c0 13.3 10.7 24 24 24h124c6.6 0 12-5.4 12-12z",
  yOffset: 0,
  xOffset: 0
};
var ExpandIcon = createIcon2(ExpandIconConfig);
var expand_icon_default = ExpandIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/expand-arrows-alt-icon.js
var ExpandArrowsAltIconConfig = {
  name: "ExpandArrowsAltIcon",
  height: 512,
  width: 448,
  svgPath: "M448 344v112a23.94 23.94 0 0 1-24 24H312c-21.39 0-32.09-25.9-17-41l36.2-36.2L224 295.6 116.77 402.9 153 439c15.09 15.1 4.39 41-17 41H24a23.94 23.94 0 0 1-24-24V344c0-21.4 25.89-32.1 41-17l36.19 36.2L184.46 256 77.18 148.7 41 185c-15.1 15.1-41 4.4-41-17V56a23.94 23.94 0 0 1 24-24h112c21.39 0 32.09 25.9 17 41l-36.2 36.2L224 216.4l107.23-107.3L295 73c-15.09-15.1-4.39-41 17-41h112a23.94 23.94 0 0 1 24 24v112c0 21.4-25.89 32.1-41 17l-36.19-36.2L263.54 256l107.28 107.3L407 327.1c15.1-15.2 41-4.5 41 16.9z",
  yOffset: 0,
  xOffset: 0
};
var ExpandArrowsAltIcon = createIcon2(ExpandArrowsAltIconConfig);
var expand_arrows_alt_icon_default = ExpandArrowsAltIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/search-plus-icon.js
var SearchPlusIconConfig = {
  name: "SearchPlusIcon",
  height: 512,
  width: 512,
  svgPath: "M304 192v32c0 6.6-5.4 12-12 12h-56v56c0 6.6-5.4 12-12 12h-32c-6.6 0-12-5.4-12-12v-56h-56c-6.6 0-12-5.4-12-12v-32c0-6.6 5.4-12 12-12h56v-56c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v56h56c6.6 0 12 5.4 12 12zm201 284.7L476.7 505c-9.4 9.4-24.6 9.4-33.9 0L343 405.3c-4.5-4.5-7-10.6-7-17V372c-35.3 27.6-79.7 44-128 44C93.1 416 0 322.9 0 208S93.1 0 208 0s208 93.1 208 208c0 48.3-16.4 92.7-44 128h16.3c6.4 0 12.5 2.5 17 7l99.7 99.7c9.3 9.4 9.3 24.6 0 34zM344 208c0-75.2-60.8-136-136-136S72 132.8 72 208s60.8 136 136 136 136-60.8 136-136z",
  yOffset: 0,
  xOffset: 0
};
var SearchPlusIcon = createIcon2(SearchPlusIconConfig);
var search_plus_icon_default = SearchPlusIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/search-minus-icon.js
var SearchMinusIconConfig = {
  name: "SearchMinusIcon",
  height: 512,
  width: 512,
  svgPath: "M304 192v32c0 6.6-5.4 12-12 12H124c-6.6 0-12-5.4-12-12v-32c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12zm201 284.7L476.7 505c-9.4 9.4-24.6 9.4-33.9 0L343 405.3c-4.5-4.5-7-10.6-7-17V372c-35.3 27.6-79.7 44-128 44C93.1 416 0 322.9 0 208S93.1 0 208 0s208 93.1 208 208c0 48.3-16.4 92.7-44 128h16.3c6.4 0 12.5 2.5 17 7l99.7 99.7c9.3 9.4 9.3 24.6 0 34zM344 208c0-75.2-60.8-136-136-136S72 132.8 72 208s60.8 136 136 136 136-60.8 136-136z",
  yOffset: 0,
  xOffset: 0
};
var SearchMinusIcon = createIcon2(SearchMinusIconConfig);
var search_minus_icon_default = SearchMinusIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/compress-alt-icon.js
var CompressAltIconConfig = {
  name: "CompressAltIcon",
  height: 512,
  width: 448,
  svgPath: "M4.686 427.314L104 328l-32.922-31.029C55.958 281.851 66.666 256 88.048 256h112C213.303 256 224 266.745 224 280v112c0 21.382-25.803 32.09-40.922 16.971L152 376l-99.314 99.314c-6.248 6.248-16.379 6.248-22.627 0L4.686 449.941c-6.248-6.248-6.248-16.379 0-22.627zM443.314 84.686L344 184l32.922 31.029c15.12 15.12 4.412 40.971-16.97 40.971h-112C234.697 256 224 245.255 224 232V120c0-21.382 25.803-32.09 40.922-16.971L296 136l99.314-99.314c6.248-6.248 16.379-6.248 22.627 0l25.373 25.373c6.248 6.248 6.248 16.379 0 22.627z",
  yOffset: 0,
  xOffset: 0
};
var CompressAltIcon = createIcon2(CompressAltIconConfig);
var compress_alt_icon_default = CompressAltIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/expand-alt-icon.js
var ExpandAltIconConfig = {
  name: "ExpandAltIcon",
  height: 512,
  width: 448,
  svgPath: "M212.686 315.314L120 408l32.922 31.029c15.12 15.12 4.412 40.971-16.97 40.971h-112C10.697 480 0 469.255 0 456V344c0-21.382 25.803-32.09 40.922-16.971L72 360l92.686-92.686c6.248-6.248 16.379-6.248 22.627 0l25.373 25.373c6.249 6.248 6.249 16.378 0 22.627zm22.628-118.628L328 104l-32.922-31.029C279.958 57.851 290.666 32 312.048 32h112C437.303 32 448 42.745 448 56v112c0 21.382-25.803 32.09-40.922 16.971L376 152l-92.686 92.686c-6.248 6.248-16.379 6.248-22.627 0l-25.373-25.373c-6.249-6.248-6.249-16.378 0-22.627z",
  yOffset: 0,
  xOffset: 0
};
var ExpandAltIcon = createIcon2(ExpandAltIconConfig);
var expand_alt_icon_default = ExpandAltIcon;

// node_modules/@patternfly/react-topology/dist/esm/components/TopologyControlBar/TopologyControlBar.js
var import_topology_controlbar3 = __toESM(require_topology_controlbar());
var ZOOM_IN = "zoom-in";
var ZOOM_OUT = "zoom-out";
var FIT_TO_SCREEN = "fit-to-screen";
var RESET_VIEW = "reset-view";
var EXPAND_ALL = "expand-all";
var COLLAPSE_ALL = "collapse-all";
var LEGEND = "legend";
var defaultControlButtonsOptions = {
  zoomIn: true,
  zoomInIcon: React362.createElement(search_plus_icon_default, null),
  zoomInTip: "Zoom In",
  zoomInAriaLabel: "Zoom In",
  zoomInCallback: null,
  zoomInDisabled: false,
  zoomInHidden: false,
  zoomOut: true,
  zoomOutIcon: React362.createElement(search_minus_icon_default, null),
  zoomOutTip: "Zoom Out",
  zoomOutAriaLabel: "Zoom Out",
  zoomOutCallback: null,
  zoomOutDisabled: false,
  zoomOutHidden: false,
  fitToScreen: true,
  fitToScreenIcon: React362.createElement(expand_arrows_alt_icon_default, null),
  fitToScreenTip: "Fit to Screen",
  fitToScreenAriaLabel: "Fit to Screen",
  fitToScreenCallback: null,
  fitToScreenDisabled: false,
  fitToScreenHidden: false,
  resetView: true,
  resetViewIcon: React362.createElement(expand_icon_default, null),
  resetViewTip: "Reset View",
  resetViewAriaLabel: "Reset View",
  resetViewCallback: null,
  resetViewDisabled: false,
  resetViewHidden: false,
  expandAll: false,
  expandAllIcon: React362.createElement(expand_alt_icon_default, null),
  expandAllTip: "Expand All",
  expandAllAriaLabel: "Expand All",
  expandAllCallback: null,
  expandAllDisabled: false,
  expandAllHidden: false,
  collapseAll: false,
  collapseAllIcon: React362.createElement(compress_alt_icon_default, null),
  collapseAllTip: "Collapse All",
  collapseAllAriaLabel: "Collapse All",
  collapseAllCallback: null,
  collapseAllDisabled: false,
  collapseAllHidden: false,
  legend: true,
  legendIcon: "Legend",
  legendTip: "",
  legendAriaLabel: null,
  legendCallback: null,
  legendDisabled: false,
  legendHidden: false,
  customButtons: []
};
var createTopologyControlButtons = ({ zoomIn = defaultControlButtonsOptions.zoomIn, zoomInIcon = defaultControlButtonsOptions.zoomInIcon, zoomInTip = defaultControlButtonsOptions.zoomInTip, zoomInAriaLabel = defaultControlButtonsOptions.zoomInAriaLabel, zoomInCallback = defaultControlButtonsOptions.zoomInCallback, zoomInDisabled = defaultControlButtonsOptions.zoomInDisabled, zoomInHidden = defaultControlButtonsOptions.zoomInHidden, zoomOut = defaultControlButtonsOptions.zoomOut, zoomOutIcon = defaultControlButtonsOptions.zoomOutIcon, zoomOutTip = defaultControlButtonsOptions.zoomOutTip, zoomOutAriaLabel = defaultControlButtonsOptions.zoomOutAriaLabel, zoomOutCallback = defaultControlButtonsOptions.zoomOutCallback, zoomOutDisabled = defaultControlButtonsOptions.zoomOutDisabled, zoomOutHidden = defaultControlButtonsOptions.zoomOutHidden, fitToScreen = defaultControlButtonsOptions.fitToScreen, fitToScreenIcon = defaultControlButtonsOptions.fitToScreenIcon, fitToScreenTip = defaultControlButtonsOptions.fitToScreenTip, fitToScreenAriaLabel = defaultControlButtonsOptions.fitToScreenAriaLabel, fitToScreenCallback = defaultControlButtonsOptions.fitToScreenCallback, fitToScreenDisabled = defaultControlButtonsOptions.fitToScreenDisabled, fitToScreenHidden = defaultControlButtonsOptions.fitToScreenHidden, resetView = defaultControlButtonsOptions.resetView, resetViewIcon = defaultControlButtonsOptions.resetViewIcon, resetViewTip = defaultControlButtonsOptions.resetViewTip, resetViewAriaLabel = defaultControlButtonsOptions.resetViewAriaLabel, resetViewCallback = defaultControlButtonsOptions.resetViewCallback, resetViewDisabled = defaultControlButtonsOptions.resetViewDisabled, resetViewHidden = defaultControlButtonsOptions.resetViewHidden, expandAll = defaultControlButtonsOptions.expandAll, expandAllIcon = defaultControlButtonsOptions.expandAllIcon, expandAllTip = defaultControlButtonsOptions.expandAllTip, expandAllAriaLabel = defaultControlButtonsOptions.expandAllAriaLabel, expandAllCallback = defaultControlButtonsOptions.expandAllCallback, expandAllDisabled = defaultControlButtonsOptions.expandAllDisabled, expandAllHidden = defaultControlButtonsOptions.expandAllHidden, collapseAll = defaultControlButtonsOptions.collapseAll, collapseAllIcon = defaultControlButtonsOptions.collapseAllIcon, collapseAllTip = defaultControlButtonsOptions.collapseAllTip, collapseAllAriaLabel = defaultControlButtonsOptions.collapseAllAriaLabel, collapseAllCallback = defaultControlButtonsOptions.collapseAllCallback, collapseAllDisabled = defaultControlButtonsOptions.collapseAllDisabled, collapseAllHidden = defaultControlButtonsOptions.collapseAllHidden, legend = defaultControlButtonsOptions.legend, legendIcon = defaultControlButtonsOptions.legendIcon, legendTip = defaultControlButtonsOptions.legendTip, legendAriaLabel = defaultControlButtonsOptions.legendAriaLabel, legendCallback = defaultControlButtonsOptions.legendCallback, legendDisabled = defaultControlButtonsOptions.legendDisabled, legendHidden = defaultControlButtonsOptions.legendHidden, customButtons = defaultControlButtonsOptions.customButtons } = defaultControlButtonsOptions) => {
  const controlButtons = [];
  if (zoomIn) {
    controlButtons.push({
      id: ZOOM_IN,
      icon: zoomInIcon,
      tooltip: zoomInTip,
      ariaLabel: zoomInAriaLabel,
      callback: zoomInCallback,
      disabled: zoomInDisabled,
      hidden: zoomInHidden
    });
  }
  if (zoomOut) {
    controlButtons.push({
      id: ZOOM_OUT,
      icon: zoomOutIcon,
      tooltip: zoomOutTip,
      ariaLabel: zoomOutAriaLabel,
      callback: zoomOutCallback,
      disabled: zoomOutDisabled,
      hidden: zoomOutHidden
    });
  }
  if (fitToScreen) {
    controlButtons.push({
      id: FIT_TO_SCREEN,
      icon: fitToScreenIcon,
      tooltip: fitToScreenTip,
      ariaLabel: fitToScreenAriaLabel,
      callback: fitToScreenCallback,
      disabled: fitToScreenDisabled,
      hidden: fitToScreenHidden
    });
  }
  if (resetView) {
    controlButtons.push({
      id: RESET_VIEW,
      icon: resetViewIcon,
      tooltip: resetViewTip,
      ariaLabel: resetViewAriaLabel,
      callback: resetViewCallback,
      disabled: resetViewDisabled,
      hidden: resetViewHidden
    });
  }
  if (expandAll) {
    controlButtons.push({
      id: EXPAND_ALL,
      icon: expandAllIcon,
      tooltip: expandAllTip,
      ariaLabel: expandAllAriaLabel,
      callback: expandAllCallback,
      disabled: expandAllDisabled,
      hidden: expandAllHidden
    });
  }
  if (collapseAll) {
    controlButtons.push({
      id: COLLAPSE_ALL,
      icon: collapseAllIcon,
      tooltip: collapseAllTip,
      ariaLabel: collapseAllAriaLabel,
      callback: collapseAllCallback,
      disabled: collapseAllDisabled,
      hidden: collapseAllHidden
    });
  }
  if (customButtons) {
    controlButtons.push(...customButtons);
  }
  if (legend) {
    controlButtons.push({
      id: LEGEND,
      icon: legendIcon,
      tooltip: legendTip,
      ariaLabel: legendAriaLabel,
      callback: legendCallback,
      disabled: legendDisabled,
      hidden: legendHidden
    });
  }
  return controlButtons;
};
var TopologyControlBar = ({ className = null, children: children2 = null, controlButtons = [], onButtonClick = () => void 0 }) => {
  const handleButtonClick = (event, button) => {
    event.preventDefault();
    onButtonClick(button.id);
    if (button.callback) {
      button.callback(button.id);
    }
  };
  const renderButton = (button) => {
    const renderedButton = React362.createElement(
      Button,
      { id: button.id, className: `pf-topology-control-bar__button${button.disabled ? " pf-m-disabled" : ""}`, onClick: (event) => handleButtonClick(event, button), disabled: button.disabled, "aria-disabled": button.disabled, variant: "tertiary" },
      button.icon,
      (button.ariaLabel || button.tooltip) && React362.createElement("span", { className: "pf-v6-screen-reader" }, button.ariaLabel || button.tooltip)
    );
    if (button.tooltip) {
      return React362.createElement(Tooltip, { content: button.tooltip }, renderedButton);
    }
    return renderedButton;
  };
  return React362.createElement(GenerateId, { prefix: "pf-topology-control-bar-" }, (randomId) => React362.createElement(
    Toolbar,
    { className, style: { backgroundColor: "transparent", padding: 0 }, id: randomId },
    React362.createElement(
      ToolbarContent,
      null,
      React362.createElement(
        ToolbarGroup,
        { gap: { default: "gapNone" } },
        controlButtons.map((button) => button.hidden ? null : React362.createElement(ToolbarItem, { key: button.id }, renderButton(button))),
        children2
      )
    )
  ));
};
TopologyControlBar.displayName = "TopologyControlBar";

// node_modules/@patternfly/react-topology/dist/esm/components/TopologySideBar/TopologySideBar.js
var React363 = __toESM(require_react());
var import_topology_side_bar3 = __toESM(require_topology_side_bar());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/times-icon.js
var TimesIconConfig2 = {
  name: "TimesIcon",
  height: 512,
  width: 352,
  svgPath: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z",
  yOffset: 0,
  xOffset: 0
};
var TimesIcon2 = createIcon2(TimesIconConfig2);
var times_icon_default2 = TimesIcon2;

// node_modules/@patternfly/react-topology/dist/esm/components/TopologySideBar/TopologySideBar.js
var TopologySideBar = (_a2) => {
  var { className = "", resizable = false, show, onClose = null, header, children: children2 = null } = _a2, otherProps = __rest(_a2, ["className", "resizable", "show", "onClose", "header", "children"]);
  const [isIn, setIsIn] = React363.useState(false);
  React363.useEffect(() => {
    let timer2 = null;
    if (isIn !== show) {
      clearTimeout(timer2);
      timer2 = setTimeout(() => setIsIn(show), 150);
    }
    return () => {
      clearTimeout(timer2);
    };
  }, [show, isIn]);
  const classNames = resizable ? css2(import_topology_side_bar3.default.topologyResizableSideBar, className) : css2(import_topology_side_bar3.default.topologySideBar, "fade", className, show && import_topology_side_bar3.default.shown, isIn && import_topology_side_bar3.default.in);
  return React363.createElement("div", Object.assign({}, otherProps, { role: "dialog", className: classNames }), (resizable || show) && React363.createElement(
    React363.Fragment,
    null,
    onClose && React363.createElement(
      Button,
      { className: css2(import_topology_side_bar3.default.topologySideBarDismiss), variant: "plain", onClick: onClose, "aria-label": "Close" },
      React363.createElement(times_icon_default2, null)
    ),
    header && React363.createElement("div", { className: import_topology_side_bar3.default.topologySideBarHeader }, header),
    children2
  ));
};
TopologySideBar.displayName = "TopologySideBar";

// node_modules/@patternfly/react-topology/dist/esm/components/VisualizationProvider.js
var React367 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/utils/ControllerContext.js
var import_react36 = __toESM(require_react());
var ControllerContext = (0, import_react36.createContext)(void 0);
var ControllerContext_default = ControllerContext;

// node_modules/mobx/dist/mobx.esm.js
var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function _(annotationType, key) {
    return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
  },
  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function _2(index4, length3) {
    return "[mobx.array] Index out of bounds, " + index4 + " is larger than " + length3;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function _3(other) {
    return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
  },
  20: function _4(other) {
    return "Cannot initialize map from " + other;
  },
  21: function _5(dataStructure) {
    return "Cannot convert to map from '" + dataStructure + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function _6(thing) {
    return "Cannot obtain administration from " + thing;
  },
  25: function _7(property, name) {
    return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
  },
  26: "please specify a property",
  27: function _8(property, name) {
    return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
  },
  28: function _9(thing) {
    return "Cannot obtain atom from " + thing;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function _10(name, derivation) {
    return "Cycle detected in computation " + name + ": " + derivation;
  },
  33: function _11(name) {
    return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function _12(name) {
    return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function _13(method) {
    return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
};
var errors = true ? niceErrors : {};
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (true) {
    var e = typeof error === "string" ? error : errors[error];
    if (typeof e === "function") e = e.apply(null, args);
    throw new Error("[MobX] " + e);
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die(true ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
  }
}
function warnAboutProxyRequirement(msg) {
  if (globalState.verifyProxies) {
    die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
  }
}
function getNextId() {
  return ++globalState.mobxGuid;
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked) {
      return;
    }
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop2() {
};
function isFunction(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t = typeof value;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (!isObject(value)) {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto == null) {
    return true;
  }
  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) {
    return false;
  }
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
    return true;
  }
  return false;
}
function addHiddenProp(object3, propName, value) {
  defineProperty(object3, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object3, propName, value) {
  defineProperty(object3, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function(x4) {
    return isObject(x4) && x4[propName] === true;
  };
}
function isES6Map(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Map]";
}
function isPlainES6Map(thing) {
  var mapProto = Object.getPrototypeOf(thing);
  var objectProto = Object.getPrototypeOf(mapProto);
  var nullProto = Object.getPrototypeOf(objectProto);
  return nullProto === null;
}
function isES6Set(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Set]";
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys(object3) {
  var keys = Object.keys(object3);
  if (!hasGetOwnPropertySymbols) {
    return keys;
  }
  var symbols = Object.getOwnPropertySymbols(object3);
  if (!symbols.length) {
    return keys;
  }
  return [].concat(keys, symbols.filter(function(s2) {
    return objectPrototype.propertyIsEnumerable.call(object3, s2);
  }));
}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function stringifyKey(key) {
  if (typeof key === "string") {
    return key;
  }
  if (typeof key === "symbol") {
    return key.toString();
  }
  return new String(key).toString();
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
  var res = {};
  ownKeys(target).forEach(function(key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};
function _arrayLikeToArray(r, a4) {
  (null == a4 || a4 > r.length) && (a4 = r.length);
  for (var e = 0, n = Array(a4); e < a4; e++) n[e] = r[e];
  return n;
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t) return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function() {
      return o >= r.length ? {
        done: true
      } : {
        done: false,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf(t, e);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r, a4) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a4);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a4) : void 0;
  }
}
var storedAnnotationsSymbol = Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    if (is20223Decorator(property)) {
      return annotation.decorate_20223_(target, property);
    } else {
      storeAnnotation(target, property, annotation);
    }
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  }
  if (isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated(prototype, annotation, key);
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}
function assertNotDecorated(prototype, annotation, key) {
  if (!isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overridden by subclass.");
  }
}
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
function is20223Decorator(context) {
  return typeof context == "object" && typeof context["kind"] == "string";
}
function assert20223DecoratorType(context, types2) {
  if (!types2.includes(context.kind)) {
    die("The decorator applied to '" + String(context.name) + "' cannot be used on a " + context.kind + " element");
  }
}
var $mobx = Symbol("mobx administration");
var Atom = function() {
  function Atom2(name_) {
    if (name_ === void 0) {
      name_ = true ? "Atom@" + getNextId() : "Atom";
    }
    this.name_ = void 0;
    this.isPendingUnobservation = false;
    this.isBeingObserved = false;
    this.observers_ = /* @__PURE__ */ new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  }
  var _proto = Atom2.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  };
  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };
  _proto.toString = function toString3() {
    return this.name_;
  };
  return Atom2;
}();
var isAtom = createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }
  var atom = new Atom(name);
  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a4, b) {
  return a4 === b;
}
function structuralComparer(a4, b) {
  return deepEqual(a4, b);
}
function shallowComparer(a4, b) {
  return deepEqual(a4, b, 1);
}
function defaultComparer(a4, b) {
  if (Object.is) {
    return Object.is(a4, b);
  }
  return a4 === b ? a4 !== 0 || 1 / a4 === 1 / b : a4 !== a4 && b !== b;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(v2, _14, name) {
  if (isObservable(v2)) {
    return v2;
  }
  if (Array.isArray(v2)) {
    return observable.array(v2, {
      name
    });
  }
  if (isPlainObject(v2)) {
    return observable.object(v2, void 0, {
      name
    });
  }
  if (isES6Map(v2)) {
    return observable.map(v2, {
      name
    });
  }
  if (isES6Set(v2)) {
    return observable.set(v2, {
      name
    });
  }
  if (typeof v2 === "function" && !isAction(v2) && !isFlow(v2)) {
    if (isGenerator(v2)) {
      return flow(v2);
    } else {
      return autoAction(name, v2);
    }
  }
  return v2;
}
function shallowEnhancer(v2, _14, name) {
  if (v2 === void 0 || v2 === null) {
    return v2;
  }
  if (isObservableObject(v2) || isObservableArray(v2) || isObservableMap(v2) || isObservableSet(v2)) {
    return v2;
  }
  if (Array.isArray(v2)) {
    return observable.array(v2, {
      name,
      deep: false
    });
  }
  if (isPlainObject(v2)) {
    return observable.object(v2, void 0, {
      name,
      deep: false
    });
  }
  if (isES6Map(v2)) {
    return observable.map(v2, {
      name,
      deep: false
    });
  }
  if (isES6Set(v2)) {
    return observable.set(v2, {
      name,
      deep: false
    });
  }
  if (true) {
    die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
  }
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v2, oldValue) {
  if (isObservable(v2)) {
    die("observable.struct should not be used with observable values");
  }
  if (deepEqual(v2, oldValue)) {
    return oldValue;
  }
  return v2;
}
var OVERRIDE = "override";
var override = createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_,
  extend_,
  decorate_20223_
});
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function make_(adm, key) {
  if (adm.isPlainObject_) {
    die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
  }
  if (!hasProp(adm.appliedAnnotations_, key)) {
    die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', but no such annotated member was found on prototype.");
  }
  return 0;
}
function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}
function decorate_20223_(desc, context) {
  console.warn("'" + this.annotationType_ + "' cannot be used with decorators - this is a no-op");
}
function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1,
    decorate_20223_: decorate_20223_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function decorate_20223_$1(mthd, context) {
  if (true) {
    assert20223DecoratorType(context, ["method", "field"]);
  }
  var kind = context.kind, name = context.name, addInitializer = context.addInitializer;
  var ann = this;
  var _createAction = function _createAction2(m3) {
    var _ann$options_$name, _ann$options_, _ann$options_$autoAct, _ann$options_2;
    return createAction((_ann$options_$name = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.name) != null ? _ann$options_$name : name.toString(), m3, (_ann$options_$autoAct = (_ann$options_2 = ann.options_) == null ? void 0 : _ann$options_2.autoAction) != null ? _ann$options_$autoAct : false);
  };
  if (kind == "field") {
    addInitializer(function() {
      storeAnnotation(this, name, ann);
    });
    return;
  }
  if (kind == "method") {
    var _this$options_2;
    if (!isAction(mthd)) {
      mthd = _createAction(mthd);
    }
    if ((_this$options_2 = this.options_) != null && _this$options_2.bound) {
      addInitializer(function() {
        var self2 = this;
        var bound = self2[name].bind(self2);
        bound.isMobxAction = true;
        self2[name] = bound;
      });
    }
    return mthd;
  }
  die("Cannot apply '" + ann.annotationType_ + "' to '" + String(name) + "' (kind: " + kind + "):" + ("\n'" + ann.annotationType_ + "' can only be used on properties with a function value."));
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (!isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}
function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction(
      (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(),
      value,
      (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
      // https://github.com/mobxjs/mobx/discussions/3140
      (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2,
    decorate_20223_: decorate_20223_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
    if (this.extend_(adm, key, descriptor, false) === null) {
      return 0;
    }
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function decorate_20223_$2(mthd, context) {
  var _this$options_3;
  if (true) {
    assert20223DecoratorType(context, ["method"]);
  }
  var name = context.name, addInitializer = context.addInitializer;
  if (!isFlow(mthd)) {
    mthd = flow(mthd);
  }
  if ((_this$options_3 = this.options_) != null && _this$options_3.bound) {
    addInitializer(function() {
      var self2 = this;
      var bound = self2[name].bind(self2);
      bound.isMobXFlow = true;
      self2[name] = bound;
    });
  }
  return mthd;
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (!isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (!isFlow(value)) {
    value = flow(value);
  }
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    value.isMobXFlow = true;
  }
  return {
    value,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3,
    decorate_20223_: decorate_20223_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function decorate_20223_$3(get5, context) {
  if (true) {
    assert20223DecoratorType(context, ["getter"]);
  }
  var ann = this;
  var key = context.name, addInitializer = context.addInitializer;
  addInitializer(function() {
    var adm = asObservableObject(this)[$mobx];
    var options = _extends({}, ann.options_, {
      get: get5,
      context: this
    });
    options.name || (options.name = true ? adm.name_ + "." + key.toString() : "ObservableObject." + key.toString());
    adm.values_.set(key, new ComputedValue(options));
  });
  return function() {
    return this[$mobx].getObservablePropValue_(key);
  };
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get5 = _ref2.get;
  if (!get5) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}
function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4,
    decorate_20223_: decorate_20223_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function decorate_20223_$4(desc, context) {
  if (true) {
    if (context.kind === "field") {
      throw die("Please use `@observable accessor " + String(context.name) + "` instead of `@observable " + String(context.name) + "`");
    }
    assert20223DecoratorType(context, ["accessor"]);
  }
  var ann = this;
  var kind = context.kind, name = context.name;
  var initializedObjects = /* @__PURE__ */ new WeakSet();
  function initializeObservable(target, value) {
    var _ann$options_$enhance, _ann$options_;
    var adm = asObservableObject(target)[$mobx];
    var observable2 = new ObservableValue(value, (_ann$options_$enhance = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.enhancer) != null ? _ann$options_$enhance : deepEnhancer, true ? adm.name_ + "." + name.toString() : "ObservableObject." + name.toString(), false);
    adm.values_.set(name, observable2);
    initializedObjects.add(target);
  }
  if (kind == "accessor") {
    return {
      get: function get5() {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, desc.get.call(this));
        }
        return this[$mobx].getObservablePropValue_(name);
      },
      set: function set7(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return this[$mobx].setObservablePropValue_(name, value);
      },
      init: function init2(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return value;
      }
    };
  }
  return;
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;
  if (!("value" in descriptor)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}
var AUTO = "true";
var autoAnnotation = createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5,
    decorate_20223_: decorate_20223_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set7 = createAction(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set7
      }) === null ? 0 : 2;
    }
    defineProperty(source, key, {
      configurable: true,
      set: set7
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
      return flowAnnotation2.make_(adm, key, descriptor, source);
    }
    var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation2.make_(adm, key, descriptor, source);
  }
  var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation2.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
}
function decorate_20223_$5(desc, context) {
  die("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;
  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v2, arg2, arg3) {
  if (is20223Decorator(arg2)) {
    return observableAnnotation.decorate_20223_(v2, arg2);
  }
  if (isStringish(arg2)) {
    storeAnnotation(v2, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v2)) {
    return v2;
  }
  if (isPlainObject(v2)) {
    return observable.object(v2, arg2, arg3);
  }
  if (Array.isArray(v2)) {
    return observable.array(v2, arg2);
  }
  if (isES6Map(v2)) {
    return observable.map(v2, arg2);
  }
  if (isES6Set(v2)) {
    return observable.set(v2, arg2);
  }
  if (typeof v2 === "object" && v2 !== null) {
    return v2;
  }
  return observable.box(v2, arg2);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return initObservable(function() {
      return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    });
  },
  ref: createDecoratorAnnotation(observableRefAnnotation),
  shallow: createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: createDecoratorAnnotation(observableStructAnnotation)
};
var observable = assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = createComputedAnnotation(COMPUTED);
var computedStructAnnotation = createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
var computed = function computed2(arg1, arg2) {
  if (is20223Decorator(arg2)) {
    return computedAnnotation.decorate_20223_(arg1, arg2);
  }
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject(arg1)) {
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  if (true) {
    if (!isFunction(arg1)) {
      die("First argument to `computed` should be an expression.");
    }
    if (isFunction(arg2)) {
      die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
    }
  }
  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config;
var _getDescriptor;
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction2, ref) {
  if (autoAction2 === void 0) {
    autoAction2 = false;
  }
  if (true) {
    if (!isFunction(fn)) {
      die("`action` can only be invoked on functions");
    }
    if (typeof actionName !== "string" || !actionName) {
      die("actions should have valid names, got: '" + actionName + "'");
    }
  }
  function res() {
    return executeAction(actionName, autoAction2, fn, ref || this, arguments);
  }
  res.isMobxAction = true;
  res.toString = function() {
    return fn.toString();
  };
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope, args) {
  var notifySpy_ = isSpyEnabled() && !!actionName;
  var startTime_ = 0;
  if (notifySpy_) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) {
    untrackedEnd(runInfo.prevDerivation_);
  }
  if (runInfo.notifySpy_) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges2, func) {
  var prev = allowStateChangesStart(allowStateChanges2);
  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges2) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges2;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
var CREATE = "create";
var ObservableValue = function(_Atom) {
  function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ = true ? "ObservableValue@" + getNextId() : "ObservableValue";
    }
    if (notifySpy === void 0) {
      notifySpy = true;
    }
    if (equals === void 0) {
      equals = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, void 0, name_);
    if (notifySpy && isSpyEnabled()) {
      spyReport({
        type: CREATE,
        object: _this,
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }
    return _this;
  }
  _inheritsLoose(ObservableValue2, _Atom);
  var _proto = ObservableValue2.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.set = function set7(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      if (notifySpy) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue,
          oldValue
        });
      }
      this.setNewValue_(newValue);
      if (notifySpy) {
        spyReportEnd();
      }
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue
      });
      if (!change) {
        return globalState.UNCHANGED;
      }
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get5() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) {
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: void 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON2() {
    return this.get();
  };
  _proto.toString = function toString3() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function() {
    return this.valueOf();
  };
  return ObservableValue2;
}(Atom);
var isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);
function getFlag(flags, mask) {
  return !!(flags & mask);
}
function setFlag(flags, mask, newValue) {
  if (newValue) {
    flags |= mask;
  } else {
    flags &= ~mask;
  }
  return flags;
}
var ComputedValue = function() {
  function ComputedValue2(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.observers_ = /* @__PURE__ */ new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.flags_ = 0;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) {
      die(31);
    }
    this.derivation = options.get;
    this.name_ = options.name || (true ? "ComputedValue@" + getNextId() : "ComputedValue");
    if (options.set) {
      this.setter_ = createAction(true ? this.name_ + "-setter" : "ComputedValue-setter", options.set);
    }
    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }
  var _proto = ComputedValue2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get5() {
    if (this.isComputing) {
      die(32, this.name_, this.derivation);
    }
    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch();
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) {
          globalState.trackingContext = this;
        }
        if (this.trackAndCompute()) {
          propagateChangeConfirmed(this);
        }
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result)) {
      throw result.cause;
    }
    return result;
  };
  _proto.set = function set7(value) {
    if (this.setter_) {
      if (this.isRunningSetter) {
        die(33, this.name_);
      }
      this.isRunningSetter = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter = false;
      }
    } else {
      die(34, this.name_);
    }
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = (
      /* see #1208 */
      this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
    );
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
      if (isSpyEnabled()) {
        spyReport({
          observableKind: "computed",
          debugObjectName: this.name_,
          object: this.scope_,
          type: "update",
          oldValue,
          newValue
        });
      }
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing = true;
    var prev = allowStateChangesStart(false);
    var res;
    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }
    allowStateChangesEnd(prev);
    this.isComputing = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = void 0;
      if (this.isTracing_ !== TraceMode.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    if (false) {
      return;
    }
    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
    if (typeof this.requiresReaction_ === "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };
  _proto.toString = function toString3() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function() {
    return this.valueOf();
  };
  return _createClass(ComputedValue2, [{
    key: "isComputing",
    get: function get5() {
      return getFlag(this.flags_, ComputedValue2.isComputingMask_);
    },
    set: function set7(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isComputingMask_, newValue);
    }
  }, {
    key: "isRunningSetter",
    get: function get5() {
      return getFlag(this.flags_, ComputedValue2.isRunningSetterMask_);
    },
    set: function set7(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isRunningSetterMask_, newValue);
    }
  }, {
    key: "isBeingObserved",
    get: function get5() {
      return getFlag(this.flags_, ComputedValue2.isBeingObservedMask_);
    },
    set: function set7(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isBeingObservedMask_, newValue);
    }
  }, {
    key: "isPendingUnobservation",
    get: function get5() {
      return getFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_);
    },
    set: function set7(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_, newValue);
    }
  }]);
}();
ComputedValue.isComputingMask_ = 1;
ComputedValue.isRunningSetterMask_ = 2;
ComputedValue.isBeingObservedMask_ = 4;
ComputedValue.isPendingUnobservationMask_ = 8;
var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;
(function(IDerivationState_2) {
  IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException2(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l = obs.length;
      for (var i = 0; i < l; i++) {
        var obj = obs[i];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  if (false) {
    return;
  }
  var hasObservers = atom.observers_.size > 0;
  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) {
    console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
  }
}
function checkIfStateReadsAreAllowed(observable2) {
  if (!globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable '" + observable2.name_ + "' being read outside a reactive context.");
  }
}
function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    derivation.runId_ === 0 ? 100 : derivation.observing_.length
  );
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
  if (false) {
    return;
  }
  if (derivation.observing_.length !== 0) {
    return;
  }
  if (typeof derivation.requiresObservable_ === "boolean" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i0 = 0, l = derivation.unboundDepsCount_;
  for (var i = 0; i < l; i++) {
    var dep = observing[i];
    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i) {
        observing[i0] = dep;
      }
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l = prevObserving.length;
  while (l--) {
    var _dep = prevObserving[l];
    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue_ = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;
  while (i--) {
    removeObserver(obs[i], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action2) {
  var prev = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
    return;
  }
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;
  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function MobXGlobals2() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = function() {
  var global2 = getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
    canMergeGlobalState = false;
  }
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
    canMergeGlobalState = false;
  }
  if (!canMergeGlobalState) {
    setTimeout(function() {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED) {
      global2.__mobxGlobals.UNCHANGED = {};
    }
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
    die(36);
  }
  isolateCalled = true;
  if (canMergeGlobalState) {
    var global2 = getGlobal();
    if (--global2.__mobxInstanceCount === 0) {
      global2.__mobxGlobals = void 0;
    }
    globalState = new MobXGlobals();
  }
}
function addObserver(observable2, node) {
  observable2.observers_.add(node);
  if (observable2.lowestObserverState_ > node.dependenciesState_) {
    observable2.lowestObserverState_ = node.dependenciesState_;
  }
}
function removeObserver(observable2, node) {
  observable2.observers_["delete"](node);
  if (observable2.observers_.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation === false) {
    observable2.isPendingUnobservation = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i = 0; i < list.length; i++) {
      var observable2 = list[i];
      observable2.isPendingUnobservation = false;
      if (observable2.observers_.size === 0) {
        if (observable2.isBeingObserved) {
          observable2.isBeingObserved = false;
          observable2.onBUO();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  checkIfStateReadsAreAllowed(observable2);
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable2.lastAccessedBy_) {
      observable2.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
      if (!observable2.isBeingObserved && globalState.trackingContext) {
        observable2.isBeingObserved = true;
        observable2.onBO();
      }
    }
    return observable2.isBeingObserved;
  } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if (d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable2);
      }
      d.onBecomeStale_();
    }
    d.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d) {
    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d.dependenciesState_ = IDerivationState_.STALE_;
      if (d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable2);
      }
    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable2.observers_.forEach(function(d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d.onBecomeStale_();
    }
  });
}
function logTraceInfo(derivation, observable2) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable2.name_ + "'");
  if (derivation.isTracing_ === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1);
    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable2.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}
function printDepTree(tree, lines, depth) {
  if (lines.length >= 1e3) {
    lines.push("(and many more)");
    return;
  }
  lines.push("" + "	".repeat(depth - 1) + tree.name);
  if (tree.dependencies) {
    tree.dependencies.forEach(function(child) {
      return printDepTree(child, lines, depth + 1);
    });
  }
}
var Reaction = function() {
  function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = true ? "Reaction@" + getNextId() : "Reaction";
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };
  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending_ = true;
        try {
          this.onInvalidate_();
          if (this.isTrackPending_ && isSpyEnabled()) {
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }
      globalState.trackingContext = prev;
      endBatch();
    }
  };
  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return;
    }
    startBatch();
    var notify = isSpyEnabled();
    var startTime;
    if (notify) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }
    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext;
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, void 0);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;
    if (this.isDisposed_) {
      clearObserving(this);
    }
    if (isCaughtException(result)) {
      this.reportExceptionInDerivation_(result.cause);
    }
    if (notify) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries) {
      throw error;
    }
    var message = true ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
    } else if (true) {
      console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
    }
    if (isSpyEnabled()) {
      spyReport({
        type: "error",
        name: this.name_,
        message,
        error: "" + error
      });
    }
    globalState.globalReactionErrorHandlers.forEach(function(f) {
      return f(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;
      if (!this.isRunning_) {
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_(abortSignal) {
    var _this2 = this;
    var dispose = function dispose2() {
      _this2.dispose();
      abortSignal == null || abortSignal.removeEventListener == null || abortSignal.removeEventListener("abort", dispose2);
    };
    abortSignal == null || abortSignal.addEventListener == null || abortSignal.addEventListener("abort", dispose);
    dispose[$mobx] = this;
    return dispose;
  };
  _proto.toString = function toString3() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }
    trace(this, enterBreakPoint);
  };
  return Reaction2;
}();
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler2(f) {
  return f();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
    return;
  }
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations2 = 0;
  while (allReactions.length > 0) {
    if (++iterations2 === MAX_REACTION_ITERATIONS) {
      console.error(true ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : "[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i = 0, l = remainingReactions.length; i < l; i++) {
      remainingReactions[i].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function reactionScheduler3(f) {
    return fn(function() {
      return baseScheduler(f);
    });
  };
}
function isSpyEnabled() {
  return !!globalState.spyListeners.length;
}
function spyReport(event) {
  if (false) {
    return;
  }
  if (!globalState.spyListeners.length) {
    return;
  }
  var listeners = globalState.spyListeners;
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](event);
  }
}
function spyReportStart(event) {
  if (false) {
    return;
  }
  var change = _extends({}, event, {
    spyReportStart: true
  });
  spyReport(change);
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: true
};
function spyReportEnd(change) {
  if (false) {
    return;
  }
  if (change) {
    spyReport(_extends({}, change, {
      type: "report-end",
      spyReportEnd: true
    }));
  } else {
    spyReport(END_EVENT);
  }
}
function spy(listener) {
  if (false) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  } else {
    globalState.spyListeners.push(listener);
    return once(function() {
      globalState.spyListeners = globalState.spyListeners.filter(function(l) {
        return l !== listener;
      });
    });
  }
}
var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = createActionAnnotation(ACTION);
var actionBoundAnnotation = createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction2) {
  var res = function action2(arg1, arg2) {
    if (isFunction(arg1)) {
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
    }
    if (isFunction(arg2)) {
      return createAction(arg1, arg2, autoAction2);
    }
    if (is20223Decorator(arg2)) {
      return (autoAction2 ? autoActionAnnotation : actionAnnotation).decorate_20223_(arg1, arg2);
    }
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction2
      }));
    }
    if (true) {
      die("Invalid arguments for `action`");
    }
  };
  return res;
}
var action = createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, void 0);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts, _opts2, _opts3;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (true) {
    if (!isFunction(view)) {
      die("Autorun expects a function as first argument");
    }
    if (isAction(view)) {
      die("Autorun does not accept actions since actions are untrackable");
    }
  }
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : true ? view.name || "Autorun@" + getNextId() : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction2;
  if (runSync) {
    reaction2 = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction2 = new Reaction(name, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function() {
          isScheduled = false;
          if (!reaction2.isDisposed_) {
            reaction2.track(reactionRunner);
          }
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction2);
  }
  if (!((_opts2 = opts) != null && (_opts2 = _opts2.signal) != null && _opts2.aborted)) {
    reaction2.schedule_();
  }
  return reaction2.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);
}
var run = function run2(f) {
  return f();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {
    return setTimeout(f, opts.delay);
  } : run;
}
function reaction(expression, effect4, opts) {
  var _opts$name2, _opts4, _opts5;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (true) {
    if (!isFunction(expression) || !isFunction(effect4)) {
      die("First and second argument to reaction should be functions");
    }
    if (!isPlainObject(opts)) {
      die("Third argument of reactions should be an object");
    }
  }
  var name = (_opts$name2 = opts.name) != null ? _opts$name2 : true ? "Reaction@" + getNextId() : "Reaction";
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect4) : effect4);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r = new Reaction(name, function() {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    isScheduled = false;
    if (r.isDisposed_) {
      return;
    }
    var changed = false;
    var oldValue = value;
    r.track(function() {
      var nextValue = allowStateChanges(false, function() {
        return expression(r);
      });
      changed = firstTime || !equals(value, nextValue);
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) {
      effectAction(value, oldValue, r);
    } else if (!firstTime && changed) {
      effectAction(value, oldValue, r);
    }
    firstTime = false;
  }
  if (!((_opts4 = opts) != null && (_opts4 = _opts4.signal) != null && _opts4.aborted)) {
    r.schedule_();
  }
  return r.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);
}
function wrapErrorHandler(errorHandler, baseFn) {
  return function() {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}
var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed";
function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }
  var useProxies = options.useProxies, enforceActions = options.enforceActions;
  if (useProxies !== void 0) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }
  if (useProxies === "ifavailable") {
    globalState.verifyProxies = true;
  }
  if (enforceActions !== void 0) {
    var ea2 = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea2;
    globalState.allowStateChanges = ea2 === true || ea2 === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
    if (key in options) {
      globalState[key] = !!options[key];
    }
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;
  if (globalState.disableErrorBoundaries === true) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }
  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}
function extendObservable(target, properties, annotations, options) {
  if (true) {
    if (arguments.length > 4) {
      die("'extendObservable' expected 2-4 arguments");
    }
    if (typeof target !== "object") {
      die("'extendObservable' expects an object as first argument");
    }
    if (isObservableMap(target)) {
      die("'extendObservable' should not be used on maps, use map.merge instead");
    }
    if (!isPlainObject(properties)) {
      die("'extendObservable' only accepts plain objects as second argument");
    }
    if (isObservable(properties) || isObservable(annotations)) {
      die("Extending an object with another observable (object) is not supported");
    }
  }
  var descriptors = getOwnPropertyDescriptors(properties);
  initObservable(function() {
    var adm = asObservableObject(target, options)[$mobx];
    ownKeys(descriptors).forEach(function(key) {
      adm.extend_(
        key,
        descriptors[key],
        // must pass "undefined" for { key: undefined }
        !annotations ? true : key in annotations ? annotations[key] : true
      );
    });
  });
  return target;
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) {
    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  }
  return result;
}
function unique(list) {
  return Array.from(new Set(list));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = Object.create(Error.prototype);
var flowAnnotation = createFlowAnnotation("flow");
var flowBoundAnnotation = createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = Object.assign(function flow2(arg1, arg2) {
  if (is20223Decorator(arg2)) {
    return flowAnnotation.decorate_20223_(arg1, arg2);
  }
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  if (arguments.length !== 1) {
    die("Flow expects single argument with generator function");
  }
  var generator = arg1;
  var name = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          ret.then(next, reject);
          return;
        }
        if (ret.done) {
          return resolve(ret.value);
        }
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise) {
          cancelPromise(pendingPromise);
        }
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise);
        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction(promise.cancel)) {
    promise.cancel();
  }
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}
function _isObservable(value, property) {
  if (!value) {
    return false;
  }
  if (property !== void 0) {
    if (isObservableMap(value) || isObservableArray(value)) {
      return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
    }
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  if (arguments.length !== 1) {
    die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  }
  return _isObservable(value);
}
function trace() {
  if (false) {
    return;
  }
  var enterBreakPoint = false;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[args.length - 1] === "boolean") {
    enterBreakPoint = args.pop();
  }
  var derivation = getAtomFromArgs(args);
  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }
  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }
  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(args[0]);
    case 2:
      return getAtom(args[0], args[1]);
  }
}
function transaction(action2, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
var objectProxyTraps = {
  has: function has(target, name) {
    if (globalState.trackingDerivation) {
      warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    }
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set2(target, name, value) {
    var _getAdm$set_;
    if (!isStringish(name)) {
      return false;
    }
    if (!getAdm(target).values_.has(name)) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    }
    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;
    if (true) {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }
    if (!isStringish(name)) {
      return false;
    }
    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty2(target, name, descriptor) {
    var _getAdm$definePropert;
    if (true) {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    }
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys2(target) {
    if (globalState.trackingDerivation) {
      warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    }
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) {
      interceptors.splice(idx, 1);
    }
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      if (change && !change.type) {
        die(14);
      }
      if (!change) {
        break;
      }
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) {
    return;
  }
  listeners = listeners.slice();
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }
  untrackedEnd(prevU);
}
function makeObservable(target, annotations, options) {
  initObservable(function() {
    var _annotations;
    var adm = asObservableObject(target, options)[$mobx];
    if (annotations && target[storedAnnotationsSymbol]) {
      die("makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.");
    }
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    ownKeys(annotations).forEach(function(key) {
      return adm.make_(key, annotations[key]);
    });
  });
  return target;
}
var keysSymbol = Symbol("mobx-keys");
var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function get2(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) {
      return adm;
    }
    if (name === "length") {
      return adm.getArrayLength_();
    }
    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }
    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }
    return target[name];
  },
  set: function set3(target, name, value) {
    var adm = target[$mobx];
    if (name === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      adm.set_(parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions2() {
    die(15);
  }
};
var ObservableArrayAdministration = function() {
  function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, true ? name + "[..]" : "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== void 0 && values.length > 0) {
      return values.map(this.dehancer);
    }
    return values;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
      die("Out of range: " + newLength);
    }
    var currentLength = this.values_.length;
    if (newLength === currentLength) {
      return;
    } else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else {
      this.spliceWithArray_(newLength, currentLength - newLength);
    }
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) {
      die(16);
    }
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) {
      reserveArrayBuffer(oldLength + delta + 1);
    }
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index4, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length3 = this.values_.length;
    if (index4 === void 0) {
      index4 = 0;
    } else if (index4 > length3) {
      index4 = length3;
    } else if (index4 < 0) {
      index4 = Math.max(0, length3 + index4);
    }
    if (arguments.length === 1) {
      deleteCount = length3 - index4;
    } else if (deleteCount === void 0 || deleteCount === null) {
      deleteCount = 0;
    } else {
      deleteCount = Math.max(0, Math.min(deleteCount, length3 - index4));
    }
    if (newItems === void 0) {
      newItems = EMPTY_ARRAY;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index4,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) {
        return EMPTY_ARRAY;
      }
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v2) {
      return _this.enhancer_(v2, void 0);
    });
    if (this.legacyMode_ || true) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length3, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index4, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) {
      this.notifyArraySplice_(index4, newItems, res);
    }
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index4, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index4, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index4, index4 + deleteCount);
      var oldItems = this.values_.slice(index4 + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i = 0; i < newItems.length; i++) {
        this.values_[index4 + i] = newItems[i];
      }
      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index4 + newItems.length + _i] = oldItems[_i];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index4, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index4,
      newValue,
      oldValue
    } : null;
    if (notifySpy) {
      spyReportStart(change);
    }
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
    if (notifySpy) {
      spyReportEnd();
    }
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index4, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index4,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if (notifySpy) {
      spyReportStart(change);
    }
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
    if (notifySpy) {
      spyReportEnd();
    }
  };
  _proto.get_ = function get_(index4) {
    if (this.legacyMode_ && index4 >= this.values_.length) {
      console.warn(true ? "[mobx.array] Attempt to read an array index (" + index4 + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX" : "[mobx] Out of bounds read: " + index4);
      return void 0;
    }
    this.atom_.reportObserved();
    return this.dehanceValue_(this.values_[index4]);
  };
  _proto.set_ = function set_(index4, newValue) {
    var values = this.values_;
    if (this.legacyMode_ && index4 > values.length) {
      die(17, index4, values.length);
    }
    if (index4 < values.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index4];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: index4,
          newValue
        });
        if (!change) {
          return;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values[index4] = newValue;
        this.notifyArrayChildUpdate_(index4, newValue, oldValue);
      }
    } else {
      var newItems = new Array(index4 + 1 - values.length);
      for (var i = 0; i < newItems.length - 1; i++) {
        newItems[i] = void 0;
      }
      newItems[newItems.length - 1] = newValue;
      this.spliceWithArray_(values.length, 0, newItems);
    }
  };
  return ObservableArrayAdministration2;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  return initObservable(function() {
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      adm.spliceWithArray_(0, 0, initialValues);
    }
    return proxy;
  });
}
var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index4, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index4);
      case 2:
        return adm.spliceWithArray_(index4, deleteCount);
    }
    return adm.spliceWithArray_(index4, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index4, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index4, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy3 = this.slice();
    copy3.sort.apply(copy3, arguments);
    this.replace(copy3);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension("at", simpleFunc);
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("toSorted", simpleFunc);
addArrayExtension("toSpliced", simpleFunc);
addArrayExtension("with", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("findLast", mapLikeFunc);
addArrayExtension("findLastIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("toReversed", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index4) {
      return callback.call(thisArg, element, index4, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index4) {
      return callback(accumulator, currentValue, index4, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
var ObservableMap = function() {
  function ObservableMap2(initialData, enhancer_, name_) {
    var _this = this;
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = true ? "ObservableMap@" + getNextId() : "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction(Map)) {
      die(18);
    }
    initObservable(function() {
      _this.keysAtom_ = createAtom(true ? _this.name_ + ".keys()" : "ObservableMap.keys()");
      _this.data_ = /* @__PURE__ */ new Map();
      _this.hasMap_ = /* @__PURE__ */ new Map();
      if (initialData) {
        _this.merge(initialData);
      }
    });
  }
  var _proto = ObservableMap2.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has2(key) {
    var _this2 = this;
    if (!globalState.trackingDerivation) {
      return this.has_(key);
    }
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function() {
        return _this2.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set7(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) {
        return false;
      }
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      if (notifySpy) {
        spyReportStart(_change);
      }
      transaction(function() {
        var _this3$hasMap_$get;
        _this3.keysAtom_.reportChanged();
        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null || _this3$hasMap_$get.setNewValue_(false);
        var observable2 = _this3.data_.get(key);
        observable2.setNewValue_(void 0);
        _this3.data_["delete"](key);
      });
      if (notify) {
        notifyListeners(this, _change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable2 = this.data_.get(key);
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this4 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function() {
      var _this4$hasMap_$get;
      var observable2 = new ObservableValue(newValue, _this4.enhancer_, true ? _this4.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
      _this4.data_.set(key, observable2);
      newValue = observable2.value_;
      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null || _this4$hasMap_$get.setNewValue_(true);
      _this4.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue
    } : null;
    if (notifySpy) {
      spyReportStart(change);
    }
    if (notify) {
      notifyListeners(this, change);
    }
    if (notifySpy) {
      spyReportEnd();
    }
  };
  _proto.get = function get5(key) {
    if (this.has(key)) {
      return this.dehanceValue_(this.data_.get(key).get());
    }
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values() {
    var self2 = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries() {
    var self2 = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[Symbol.iterator] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  };
  _proto.merge = function merge2(other) {
    var _this5 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function() {
      if (isPlainObject(other)) {
        getPlainObjectKeys(other).forEach(function(key) {
          return _this5.set(key, other[key]);
        });
      } else if (Array.isArray(other)) {
        other.forEach(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return _this5.set(key, value);
        });
      } else if (isES6Map(other)) {
        if (!isPlainES6Map(other)) {
          die(19, other);
        }
        other.forEach(function(value, key) {
          return _this5.set(key, value);
        });
      } else if (other !== null && other !== void 0) {
        die(20, other);
      }
    });
    return this;
  };
  _proto.clear = function clear2() {
    var _this6 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key = _step2.value;
          _this6["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace2(values) {
    var _this7 = this;
    transaction(function() {
      var replacementMap = convertToMap(values);
      var orderedData = /* @__PURE__ */ new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key = _step3.value;
        if (!replacementMap.has(key)) {
          var deleted = _this7["delete"](key);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this7.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this7.data_.has(_key);
        _this7.set(_key, _value);
        if (_this7.data_.has(_key)) {
          var _value2 = _this7.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this7.data_.size !== orderedData.size) {
          _this7.keysAtom_.reportChanged();
        } else {
          var iter1 = _this7.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this7.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this7.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString3() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === true) {
      die("`observe` doesn't support fireImmediately=true in combination with maps.");
    }
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  return _createClass(ObservableMap2, [{
    key: "size",
    get: function get5() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get5() {
      return "Map";
    }
  }]);
}();
var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map5 = /* @__PURE__ */ new Map();
    for (var key in dataStructure) {
      map5.set(key, dataStructure[key]);
    }
    return map5;
  } else {
    return die(21, dataStructure);
  }
}
var ObservableSetMarker = {};
var ObservableSet = function() {
  function ObservableSet2(initialData, enhancer, name_) {
    var _this = this;
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = true ? "ObservableSet@" + getNextId() : "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = /* @__PURE__ */ new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction(Set)) {
      die(22);
    }
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    initObservable(function() {
      _this.atom_ = createAtom(_this.name_);
      if (initialData) {
        _this.replace(initialData);
      }
    });
  }
  var _proto = ObservableSet2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear2() {
    var _this2 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this2["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add2(value) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) {
        return this;
      }
    }
    if (!this.has(value)) {
      transaction(function() {
        _this3.data_.add(_this3.enhancer_(value, void 0));
        _this3.atom_.reportChanged();
      });
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notifySpy && true) {
        spyReportStart(_change);
      }
      if (notify) {
        notifyListeners(this, _change);
      }
      if (notifySpy && true) {
        spyReportEnd();
      }
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this4 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) {
        return false;
      }
    }
    if (this.has(value)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      if (notifySpy && true) {
        spyReportStart(_change2);
      }
      transaction(function() {
        _this4.atom_.reportChanged();
        _this4.data_["delete"](value);
      });
      if (notify) {
        notifyListeners(this, _change2);
      }
      if (notifySpy && true) {
        spyReportEnd();
      }
      return true;
    }
    return false;
  };
  _proto.has = function has2(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index4 = nextIndex;
        nextIndex += 1;
        return index4 < values.length ? {
          value: [keys[index4], values[index4]],
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.keys = function keys() {
    return this.values();
  };
  _proto.values = function values() {
    this.atom_.reportObserved();
    var self2 = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self2.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.intersection = function intersection2(otherSet) {
    if (isES6Set(otherSet)) {
      return otherSet.intersection(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.intersection(otherSet);
    }
  };
  _proto.union = function union2(otherSet) {
    if (isES6Set(otherSet)) {
      return otherSet.union(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.union(otherSet);
    }
  };
  _proto.difference = function difference2(otherSet) {
    return new Set(this).difference(otherSet);
  };
  _proto.symmetricDifference = function symmetricDifference(otherSet) {
    if (isES6Set(otherSet)) {
      return otherSet.symmetricDifference(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.symmetricDifference(otherSet);
    }
  };
  _proto.isSubsetOf = function isSubsetOf(otherSet) {
    return new Set(this).isSubsetOf(otherSet);
  };
  _proto.isSupersetOf = function isSupersetOf(otherSet) {
    return new Set(this).isSupersetOf(otherSet);
  };
  _proto.isDisjointFrom = function isDisjointFrom(otherSet) {
    if (isES6Set(otherSet)) {
      return otherSet.isDisjointFrom(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.isDisjointFrom(otherSet);
    }
  };
  _proto.replace = function replace2(other) {
    var _this5 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function() {
      if (Array.isArray(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (isES6Set(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === true) {
      die("`observe` doesn't support fireImmediately=true in combination with sets.");
    }
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.toString = function toString3() {
    return "[object ObservableSet]";
  };
  _proto[Symbol.iterator] = function() {
    return this.values();
  };
  return _createClass(ObservableSet2, [{
    key: "size",
    get: function get5() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get5() {
      return "Set";
    }
  }]);
}();
var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);
var descriptorCache = /* @__PURE__ */ Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = function() {
  function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = /* @__PURE__ */ new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom(true ? this.name_ + ".keys" : "ObservableObject.keys");
    this.isPlainObject_ = isPlainObject(this.target_);
    if (!isAnnotation(this.defaultAnnotation_)) {
      die("defaultAnnotation must be valid annotation");
    }
    if (true) {
      this.appliedAnnotations_ = {};
    }
  }
  var _proto = ObservableObjectAdministration2.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable2 = this.values_.get(key);
    if (observable2 instanceof ComputedValue) {
      observable2.set(newValue);
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue
      });
      if (!change) {
        return null;
      }
      newValue = change.newValue;
    }
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      if (notifySpy) {
        spyReportStart(_change);
      }
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, _change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      this.has_(key);
    }
    return this.target_[key];
  };
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp(this.target_, key)) {
      if (this.values_.has(key)) {
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key, value);
      } else {
        this.target_[key] = value;
        return true;
      }
    } else {
      return this.extend_(key, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_2(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    assertAnnotable(this, annotation, key);
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
        return;
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0) {
          return;
        }
        if (outcome === 1) {
          break;
        }
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key);
  };
  _proto.extend_ = function extend_2(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) {
          return null;
        }
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) {
          return null;
        }
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      var observable2 = new ObservableValue(value, enhancer, true ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable2);
      this.notifyPropertyAddition_(key, observable2.value_);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: void 0
        });
        if (!change) {
          return null;
        }
      }
      options.name || (options.name = true ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue(options));
      this.notifyPropertyAddition_(key, void 0);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (!hasProp(this.target_, key)) {
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      });
      if (!change) {
        return null;
      }
    }
    try {
      var _this$pendingKeys_;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      var observable2 = this.values_.get(key);
      var value = void 0;
      if (!observable2 && (notify || notifySpy)) {
        var _getDescriptor2;
        value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      if (true) {
        delete this.appliedAnnotations_[key];
      }
      if (observable2) {
        this.values_["delete"](key);
        if (observable2 instanceof ObservableValue) {
          value = observable2.value_;
        }
        propagateChanged(observable2);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null || (_this$pendingKeys_ = _this$pendingKeys_.get(key)) == null || _this$pendingKeys_.set(key in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (notifySpy) {
          spyReportStart(_change2);
        }
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      }
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    if (fireImmediately === true) {
      die("`observe` doesn't support the fire immediately property for observable objects.");
    }
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2;
    var notify = hasListeners(this);
    var notifySpy = isSpyEnabled();
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null || (_this$pendingKeys_2 = _this$pendingKeys_2.get(key)) == null || _this$pendingKeys_2.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration2;
}();
function asObservableObject(target, options) {
  var _options$name;
  if (options && isObservableObject(target)) {
    die("Options can't be provided for already observable objects.");
  }
  if (hasProp(target, $mobx)) {
    if (!(getAdministration(target) instanceof ObservableObjectAdministration)) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
    }
    return target;
  }
  if (!Object.isExtensible(target)) {
    die("Cannot make the designated object observable; it is not extensible");
  }
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : true ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get5() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set7(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  if (true) {
    adm.appliedAnnotations_[key] = annotation;
  }
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null || delete _adm$target_$storedAn[key];
}
function assertAnnotable(adm, annotation, key) {
  if (!isAnnotation(annotation)) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  if (!isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overridden by subclass.");
  }
}
var ENTRY_0 = createArrayEntryDescriptor(0);
var safariPrototypeSetterInheritanceBug = function() {
  var v2 = false;
  var p = {};
  Object.defineProperty(p, "0", {
    set: function set7() {
      v2 = true;
    }
  });
  Object.create(p)["0"] = 1;
  return v2 === false;
}();
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
var StubArray = function StubArray2() {
};
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = function(_StubArray) {
  function LegacyObservableArray2(initialValues, enhancer, name, owned) {
    var _this;
    if (name === void 0) {
      name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    initObservable(function() {
      var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
      adm.proxy_ = _this;
      addHiddenFinalProp(_this, $mobx, adm);
      if (initialValues && initialValues.length) {
        _this.spliceWithArray(0, 0, initialValues);
      }
      if (safariPrototypeSetterInheritanceBug) {
        Object.defineProperty(_this, "0", ENTRY_0);
      }
    });
    return _this;
  }
  _inheritsLoose(LegacyObservableArray2, _StubArray);
  var _proto = LegacyObservableArray2.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      arrays.map(function(a4) {
        return isObservableArray(a4) ? a4.slice() : a4;
      })
    );
  };
  _proto[Symbol.iterator] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  return _createClass(LegacyObservableArray2, [{
    key: "length",
    get: function get5() {
      return this[$mobx].getArrayLength_();
    },
    set: function set7(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get5() {
      return "Array";
    }
  }]);
}(StubArray);
Object.entries(arrayExtensions).forEach(function(_ref) {
  var prop = _ref[0], fn = _ref[1];
  if (prop !== "concat") {
    addHiddenProp(LegacyObservableArray.prototype, prop, fn);
  }
});
function createArrayEntryDescriptor(index4) {
  return {
    enumerable: false,
    configurable: true,
    get: function get5() {
      return this[$mobx].get_(index4);
    },
    set: function set7(value) {
      this[$mobx].set_(index4, value);
    }
  };
}
function createArrayBufferItem(index4) {
  defineProperty(LegacyObservableArray.prototype, "" + index4, createArrayEntryDescriptor(index4));
}
function reserveArrayBuffer(max5) {
  if (max5 > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index4 = OBSERVABLE_ARRAY_BUFFER_SIZE; index4 < max5 + 100; index4++) {
      createArrayBufferItem(index4);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max5;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0) {
        die(23);
      }
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing.atom_;
    }
    if (isObservableMap(thing)) {
      if (property === void 0) {
        return thing.keysAtom_;
      }
      var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable2) {
        die(25, property, getDebugName(thing));
      }
      return observable2;
    }
    if (isObservableObject(thing)) {
      if (!property) {
        return die(26);
      }
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable) {
        die(27, property, getDebugName(thing));
      }
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing) {
    die(29);
  }
  if (property !== void 0) {
    return getAdministration(getAtom(thing, property));
  }
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
    return thing;
  }
  if (isObservableMap(thing) || isObservableSet(thing)) {
    return thing;
  }
  if (thing[$mobx]) {
    return thing[$mobx];
  }
  die(24, thing);
}
function getDebugName(thing, property) {
  var named2;
  if (property !== void 0) {
    named2 = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named2 = getAdministration(thing);
  } else {
    named2 = getAtom(thing);
  }
  return named2.name_;
}
function initObservable(cb) {
  var derivation = untrackedStart();
  var allowStateChanges2 = allowStateChangesStart(true);
  startBatch();
  try {
    return cb();
  } finally {
    endBatch();
    allowStateChangesEnd(allowStateChanges2);
    untrackedEnd(derivation);
  }
}
var toString2 = objectPrototype.toString;
function deepEqual(a4, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a4, b, depth);
}
function eq(a4, b, depth, aStack, bStack) {
  if (a4 === b) {
    return a4 !== 0 || 1 / a4 === 1 / b;
  }
  if (a4 == null || b == null) {
    return false;
  }
  if (a4 !== a4) {
    return b !== b;
  }
  var type2 = typeof a4;
  if (type2 !== "function" && type2 !== "object" && typeof b != "object") {
    return false;
  }
  var className = toString2.call(a4);
  if (className !== toString2.call(b)) {
    return false;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a4 === "" + b;
    case "[object Number]":
      if (+a4 !== +a4) {
        return +b !== +b;
      }
      return +a4 === 0 ? 1 / +a4 === 1 / b : +a4 === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a4 === +b;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a4) === Symbol.valueOf.call(b);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a4 = unwrap(a4);
  b = unwrap(b);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a4 != "object" || typeof b != "object") {
      return false;
    }
    var aCtor = a4.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a4 && "constructor" in b) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length3 = aStack.length;
  while (length3--) {
    if (aStack[length3] === a4) {
      return bStack[length3] === b;
    }
  }
  aStack.push(a4);
  bStack.push(b);
  if (areArrays) {
    length3 = a4.length;
    if (length3 !== b.length) {
      return false;
    }
    while (length3--) {
      if (!eq(a4[length3], b[length3], depth - 1, aStack, bStack)) {
        return false;
      }
    }
  } else {
    var keys = Object.keys(a4);
    var key;
    length3 = keys.length;
    if (Object.keys(b).length !== length3) {
      return false;
    }
    while (length3--) {
      key = keys[length3];
      if (!(hasProp(b, key) && eq(a4[key], b[key], depth - 1, aStack, bStack))) {
        return false;
      }
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a4) {
  if (isObservableArray(a4)) {
    return a4.slice();
  }
  if (isES6Map(a4) || isObservableMap(a4)) {
    return Array.from(a4.entries());
  }
  if (isES6Set(a4) || isObservableSet(a4)) {
    return Array.from(a4.entries());
  }
  return a4;
}
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}
function getSelf() {
  return this;
}
function isAnnotation(thing) {
  return (
    // Can be function
    thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
  );
}
["Symbol", "Map", "Set"].forEach(function(m3) {
  var g = getGlobal();
  if (typeof g[m3] === "undefined") {
    die("MobX requires global '" + m3 + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}

// node_modules/@patternfly/react-topology/dist/esm/types.js
var AnchorEnd;
(function(AnchorEnd2) {
  AnchorEnd2[AnchorEnd2["target"] = 0] = "target";
  AnchorEnd2[AnchorEnd2["source"] = 1] = "source";
  AnchorEnd2[AnchorEnd2["both"] = 2] = "both";
})(AnchorEnd || (AnchorEnd = {}));
var TopologyQuadrant;
(function(TopologyQuadrant2) {
  TopologyQuadrant2["upperLeft"] = "upperLeft";
  TopologyQuadrant2["upperRight"] = "upperRight";
  TopologyQuadrant2["lowerLeft"] = "lowerLeft";
  TopologyQuadrant2["lowerRight"] = "lowerRight";
})(TopologyQuadrant || (TopologyQuadrant = {}));
var NodeShape;
(function(NodeShape2) {
  NodeShape2["circle"] = "circle";
  NodeShape2["ellipse"] = "ellipse";
  NodeShape2["rect"] = "rect";
  NodeShape2["rhombus"] = "rhombus";
  NodeShape2["trapezoid"] = "trapezoid";
  NodeShape2["hexagon"] = "hexagon";
  NodeShape2["octagon"] = "octagon";
  NodeShape2["stadium"] = "stadium";
})(NodeShape || (NodeShape = {}));
var NodeStatus;
(function(NodeStatus2) {
  NodeStatus2["default"] = "default";
  NodeStatus2["info"] = "info";
  NodeStatus2["success"] = "success";
  NodeStatus2["warning"] = "warning";
  NodeStatus2["danger"] = "danger";
})(NodeStatus || (NodeStatus = {}));
var EdgeStyle;
(function(EdgeStyle2) {
  EdgeStyle2["default"] = "default";
  EdgeStyle2["solid"] = "solid";
  EdgeStyle2["dotted"] = "dotted";
  EdgeStyle2["dashed"] = "dashed";
  EdgeStyle2["dashedMd"] = "dashedMd";
  EdgeStyle2["dashedLg"] = "dashedLg";
  EdgeStyle2["dashedXl"] = "dashedXl";
})(EdgeStyle || (EdgeStyle = {}));
var EdgeAnimationSpeed;
(function(EdgeAnimationSpeed2) {
  EdgeAnimationSpeed2["none"] = "none";
  EdgeAnimationSpeed2["slow"] = "slow";
  EdgeAnimationSpeed2["mediumSlow"] = "mediumSlow";
  EdgeAnimationSpeed2["medium"] = "medium";
  EdgeAnimationSpeed2["mediumFast"] = "mediumFast";
  EdgeAnimationSpeed2["fast"] = "fast";
})(EdgeAnimationSpeed || (EdgeAnimationSpeed = {}));
var EdgeTerminalType;
(function(EdgeTerminalType2) {
  EdgeTerminalType2["none"] = "none";
  EdgeTerminalType2["directional"] = "directional";
  EdgeTerminalType2["directionalAlt"] = "directionalAlt";
  EdgeTerminalType2["circle"] = "circle";
  EdgeTerminalType2["square"] = "square";
  EdgeTerminalType2["cross"] = "cross";
})(EdgeTerminalType || (EdgeTerminalType = {}));
var LabelPosition;
(function(LabelPosition2) {
  LabelPosition2[LabelPosition2["top"] = 0] = "top";
  LabelPosition2[LabelPosition2["left"] = 1] = "left";
  LabelPosition2[LabelPosition2["right"] = 2] = "right";
  LabelPosition2[LabelPosition2["bottom"] = 3] = "bottom";
})(LabelPosition || (LabelPosition = {}));
var BadgeLocation;
(function(BadgeLocation2) {
  BadgeLocation2[BadgeLocation2["inner"] = 0] = "inner";
  BadgeLocation2[BadgeLocation2["below"] = 1] = "below";
})(BadgeLocation || (BadgeLocation = {}));
var ModelKind;
(function(ModelKind2) {
  ModelKind2["graph"] = "graph";
  ModelKind2["node"] = "node";
  ModelKind2["edge"] = "edge";
})(ModelKind || (ModelKind = {}));
var ScaleDetailsLevel;
(function(ScaleDetailsLevel2) {
  ScaleDetailsLevel2["high"] = "high";
  ScaleDetailsLevel2["medium"] = "medium";
  ScaleDetailsLevel2["low"] = "low";
})(ScaleDetailsLevel || (ScaleDetailsLevel = {}));
var isGraph = (element) => element && element.getKind() === ModelKind.graph;
var isNode = (element) => element && element.getKind() === ModelKind.node;
var isEdge = (element) => element && element.getKind() === ModelKind.edge;
var ADD_CHILD_EVENT = "element-add-child";
var ELEMENT_VISIBILITY_CHANGE_EVENT = "element-visibility-change";
var REMOVE_CHILD_EVENT = "element-remove-child";
var NODE_COLLAPSE_CHANGE_EVENT = "node-collapse-change";
var NODE_POSITIONED_EVENT = "node-positioned";
var GRAPH_LAYOUT_END_EVENT = "graph-layout-end";
var GRAPH_POSITION_CHANGE_EVENT = "graph-position-change";

// node_modules/@patternfly/react-topology/dist/esm/geom/Point.js
var Point = class _Point {
  constructor(x4 = 0, y4 = 0) {
    this.x = x4;
    this.y = y4;
  }
  static singleUse(x4 = 0, y4 = 0) {
    _Point.SINGLETON.x = x4;
    _Point.SINGLETON.y = y4;
    return _Point.SINGLETON;
  }
  static fromPoint(point7) {
    return new _Point(point7.x, point7.y);
  }
  setLocation(x4, y4) {
    this.x = x4;
    this.y = y4;
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  translate(dx, dy) {
    this.x += dx;
    this.y += dy;
    return this;
  }
  scale(scaleX, scaleY) {
    this.x *= scaleX;
    this.y *= scaleY != null ? scaleY : scaleX;
    return this;
  }
  clone() {
    return _Point.fromPoint(this);
  }
  equals(p) {
    return p.x === this.x && p.y === this.y;
  }
};
Point.EMPTY = new Point();
Point.SINGLETON = new Point();

// node_modules/@patternfly/react-topology/dist/esm/utils/anchor-utils.js
var getEllipseAnchorPoint = (center2, width, height, reference2) => {
  const { x: x4, y: y4 } = reference2;
  if (width === 0 || height === 0 || center2.x === x4 && center2.y === y4) {
    return center2;
  }
  const dispX = (center2.x - x4) / (width / 2);
  const dispY = (center2.y - y4) / (height / 2);
  const len = Math.sqrt(dispX * dispX + dispY * dispY);
  const newLength = len - 1;
  const lenProportion = newLength / len;
  return new Point((center2.x - x4) * lenProportion + x4, (center2.y - y4) * lenProportion + y4);
};
var getRectAnchorPoint = (center2, width, height, reference2) => {
  let dx = reference2.x - center2.x;
  let dy = reference2.y - center2.y;
  if (dx === 0 && dy === 0 || width === 0 && height === 0) {
    return center2;
  }
  const scale2 = 0.5 / Math.max(width === 0 ? 0 : Math.abs(dx) / width, height === 0 ? 0 : Math.abs(dy) / height);
  dx *= scale2;
  dy *= scale2;
  return center2.clone().translate(dx, dy);
};
var svgPointToPoint = (p) => new Point(p.x, p.y);
var distanceToPoint = (p, reference2) => {
  const dx = p.x - reference2.x;
  const dy = p.y - reference2.y;
  return dx * dx + dy * dy;
};
var isBetween = (a4, b12, b22) => Math.ceil(a4) >= Math.min(b12, b22) && Math.floor(a4) <= Math.max(b12, b22);
var getLinesIntersection = (line1, line2) => {
  const line1xDelta = line1[0].x - line1[1].x;
  const line1yDelta = line1[0].y - line1[1].y;
  const line2xDelta = line2[0].x - line2[1].x;
  const line2yDelta = line2[0].y - line2[1].y;
  const denominator = line1xDelta * line2yDelta - line1yDelta * line2xDelta;
  if (denominator === 0) {
    return null;
  }
  const d1 = line1[0].x * line1[1].y - line1[0].y * line1[1].x;
  const d2 = line2[0].x * line2[1].y - line2[0].y * line2[1].x;
  const xValue = d1 * line2xDelta - line1xDelta * d2;
  const yValue = d1 * line2yDelta - d2 * line1yDelta;
  const intersection2 = new Point(xValue / denominator, yValue / denominator);
  if (!isBetween(intersection2.x, line1[0].x, line1[1].x) || !isBetween(intersection2.y, line1[0].y, line1[1].y) || !isBetween(intersection2.x, line2[0].x, line2[1].x) || !isBetween(intersection2.y, line2[0].y, line2[1].y)) {
    return null;
  }
  return intersection2;
};
var getPathIntersectionPoint = (pathNode, line) => {
  const pathLength = pathNode.getTotalLength();
  const numSegments = Math.min(Math.round(pathLength / 5), 100);
  for (let i = 0; i < numSegments; i++) {
    const pos1 = pathNode.getPointAtLength(pathLength * i / numSegments);
    const pos2 = pathNode.getPointAtLength(pathLength * (i + 1) / numSegments);
    const intersectPoint = getLinesIntersection([svgPointToPoint(pos1), svgPointToPoint(pos2)], line);
    if (intersectPoint) {
      return intersectPoint;
    }
  }
  const pathBox = pathNode.getBBox();
  return new Point(pathBox.x + pathBox.width / 2, pathBox.y + pathBox.height / 2);
};
var getPathClosestPoint = (pathNode, reference2) => {
  const pathLength = pathNode.getTotalLength();
  let precision = 8;
  let best = pathNode.getPointAtLength(0);
  let bestLength = 0;
  let bestDistance = Infinity;
  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {
    const scan2 = pathNode.getPointAtLength(scanLength);
    const scanDistance = distanceToPoint(svgPointToPoint(scan2), reference2);
    if (scanDistance < bestDistance) {
      best = scan2;
      bestLength = scanLength;
      bestDistance = scanDistance;
    }
  }
  precision /= 2;
  while (precision > 0.5) {
    const beforeLength = bestLength - precision;
    const before = pathNode.getPointAtLength(beforeLength);
    const beforeDistance = distanceToPoint(svgPointToPoint(before), reference2);
    if (beforeLength >= 0 && beforeDistance < bestDistance) {
      best = before;
      bestLength = beforeLength;
      bestDistance = beforeDistance;
    } else {
      const afterLength = bestLength + precision;
      const after = pathNode.getPointAtLength(afterLength);
      const afterDistance = distanceToPoint(svgPointToPoint(after), reference2);
      if (afterLength <= pathLength && afterDistance < bestDistance) {
        best = after;
        bestLength = afterLength;
        bestDistance = afterDistance;
      } else {
        precision /= 2;
      }
    }
  }
  return svgPointToPoint(best);
};
var getPathAnchorPoint = (pathNode, reference2, useClosestPathPoint = false) => {
  if (useClosestPathPoint) {
    return getPathClosestPoint(pathNode, reference2);
  }
  const pathBox = pathNode.getBBox();
  const pathCenter = new Point(pathBox.x + pathBox.width / 2, pathBox.y + pathBox.height / 2);
  return getPathIntersectionPoint(pathNode, [reference2, pathCenter]);
};
var getPolygonAnchorPoint = (polygonNode, reference2) => {
  const polygonBox = polygonNode.getBBox();
  const polygonCenter = new Point(polygonBox.x + polygonBox.width / 2, polygonBox.y + polygonBox.height / 2);
  const { points } = polygonNode;
  let bestPoint = polygonCenter;
  let bestDistance = Infinity;
  for (let i = 0; i < points.length; i++) {
    const intersectPoint = getLinesIntersection([svgPointToPoint(points[i]), svgPointToPoint(points[i === points.length - 1 ? 0 : i + 1])], [polygonCenter, reference2]);
    if (intersectPoint) {
      const intersectDistance = distanceToPoint(intersectPoint, reference2);
      if (intersectDistance < bestDistance) {
        bestPoint = intersectPoint;
        bestDistance = intersectDistance;
      }
    }
  }
  return bestPoint;
};

// node_modules/@patternfly/react-topology/dist/esm/utils/ElementContext.js
var import_react37 = __toESM(require_react());
var ElementContext = (0, import_react37.createContext)(void 0);
var ElementContext_default = ElementContext;

// node_modules/@patternfly/react-topology/dist/esm/geom/Rect.js
var Rect = class _Rect {
  constructor(x4 = 0, y4 = 0, width = 0, height = 0) {
    this.width = 0;
    this.height = 0;
    this.x = 0;
    this.y = 0;
    this.x = x4;
    this.y = y4;
    this.width = width;
    this.height = height;
  }
  static singleUse(x4 = 0, y4 = 0, width = 0, height = 0) {
    _Rect.SINGLETON.x = x4;
    _Rect.SINGLETON.y = y4;
    _Rect.SINGLETON.width = width;
    _Rect.SINGLETON.height = height;
    return _Rect.SINGLETON;
  }
  static fromRect(rect) {
    return new _Rect(rect.x, rect.y, rect.width, rect.height);
  }
  isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }
  setLocation(x4, y4) {
    this.x = x4;
    this.y = y4;
    return this;
  }
  setSize(w, h) {
    this.width = w;
    this.height = h;
    return this;
  }
  getCenter() {
    return new Point(this.x + this.width / 2, this.y + this.height / 2);
  }
  setCenter(x4, y4) {
    this.x = x4 - this.width / 2;
    this.y = y4 - this.height / 2;
    return this;
  }
  translate(dx, dy) {
    this.x += dx;
    this.y += dy;
    return this;
  }
  scale(scaleX, scaleY) {
    const sy = scaleY != null ? scaleY : scaleX;
    const xx = this.x;
    const yy = this.y;
    this.x *= scaleX;
    this.y *= sy;
    this.width = (xx + this.width) * scaleX - this.x;
    this.height = (yy + this.height) * sy - this.y;
    return this;
  }
  resize(dw, dh) {
    this.width += dw;
    this.height += dh;
    return this;
  }
  bottom() {
    return this.y + this.height;
  }
  right() {
    return this.x + this.width;
  }
  union({ x: x4, y: y4, width, height }) {
    const right3 = Math.max(this.x + this.width, x4 + width);
    const bottom3 = Math.max(this.y + this.height, y4 + height);
    this.x = Math.min(this.x, x4);
    this.y = Math.min(this.y, y4);
    this.width = right3 - this.x;
    this.height = bottom3 - this.y;
    return this;
  }
  expand(h, v2) {
    this.y -= v2;
    this.height += v2 * 2;
    this.x -= h;
    this.width += h * 2;
    return this;
  }
  //
  // Padding Format:  [all], [vertical, horizontal], [top, horizontal, bottom], [top, right, bottom, left]
  //
  padding(padding) {
    if (padding) {
      if (typeof padding === "number") {
        this.expand(padding, padding);
      } else if (padding.length === 1) {
        this.expand(padding[0], padding[0]);
      } else if (padding.length === 2) {
        this.expand(padding[1], padding[0]);
      } else if (padding.length === 3) {
        this.y -= padding[0];
        this.height += padding[0] + padding[2];
        this.width += padding[1];
      } else if (padding.length === 4) {
        this.y -= padding[0];
        this.height += padding[0] + padding[2];
        this.x -= padding[1];
        this.width += padding[1] + padding[3];
      }
    }
    return this;
  }
  setBounds(x4, y4, width, height) {
    this.x = x4;
    this.y = y4;
    this.width = width;
    this.height = height;
    return this;
  }
  clone() {
    return _Rect.fromRect(this);
  }
  equals(r) {
    return r.x === this.x && r.y === this.y && r.width === this.width && r.height === this.height;
  }
};
Rect.EMPTY = new Rect();
Rect.SINGLETON = new Rect();

// node_modules/@patternfly/react-topology/dist/esm/geom/Dimensions.js
var Dimensions = class _Dimensions {
  constructor(width = 0, height = 0) {
    this.width = 0;
    this.height = 0;
    this.width = width;
    this.height = height;
  }
  static singleUse(width = 0, height = 0) {
    _Dimensions.SINGLETON.width = width;
    _Dimensions.SINGLETON.height = height;
    return _Dimensions.SINGLETON;
  }
  static fromDimensions(dimension) {
    return new _Dimensions(dimension.width, dimension.height);
  }
  isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }
  setSize(w, h) {
    this.width = w;
    this.height = h;
    return this;
  }
  scale(scaleX, scaleY) {
    const sy = scaleY != null ? scaleY : scaleX;
    this.width *= scaleX;
    this.height *= sy;
    return this;
  }
  resize(dw, dh) {
    this.width += dw;
    this.height += dh;
    return this;
  }
  expand(h, v2) {
    this.height += v2 * 2;
    this.width += h * 2;
    return this;
  }
  clone() {
    return _Dimensions.fromDimensions(this);
  }
  equals(r) {
    return r.width === this.width && r.height === this.height;
  }
};
Dimensions.EMPTY = new Dimensions();
Dimensions.SINGLETON = new Dimensions();

// node_modules/@patternfly/react-topology/dist/esm/utils/element-utils.js
var groupNodeElements = (nodes) => {
  if (!nodes.length) {
    return [];
  }
  const groupNodes = [];
  nodes.forEach((nextNode) => {
    if (isNode(nextNode) && nextNode.isGroup() && !nextNode.isCollapsed()) {
      groupNodes.push(nextNode);
      groupNodes.push(...groupNodeElements(nextNode.getChildren()));
    }
  });
  return groupNodes;
};
var leafNodeElements = (nodeElements) => {
  const nodes = [];
  if (!nodeElements) {
    return nodes;
  }
  if (Array.isArray(nodeElements)) {
    nodeElements.forEach((nodeElement) => {
      nodes.push(...leafNodeElements(nodeElement));
    });
    return nodes;
  }
  if (nodeElements.isGroup() && !nodeElements.isCollapsed()) {
    const leafNodes = [];
    const children2 = nodeElements.getChildren().filter((e) => isNode(e));
    children2.forEach((element) => leafNodes.push(...leafNodeElements(element)));
    return leafNodes;
  }
  return [nodeElements];
};
var getTopCollapsedParent = (node) => {
  let returnNode = node;
  try {
    let parent = !isGraph(node) && node.getParent();
    while (parent && !isGraph(parent)) {
      if (parent.isCollapsed()) {
        returnNode = parent;
      }
      parent = parent.getParent();
    }
  } catch (e) {
  }
  return returnNode;
};
var getClosestVisibleParent = (node) => {
  if (!node) {
    return null;
  }
  let returnNode = null;
  try {
    let parent = node.getParent();
    while (parent) {
      if (!parent.isVisible()) {
        returnNode = null;
      } else if (parent.isCollapsed() || !returnNode) {
        returnNode = parent;
      }
      parent = parent.getParent();
    }
  } catch (e) {
  }
  return returnNode;
};
var getElementPadding = (element) => {
  const stylePadding = element.getStyle().padding;
  if (!stylePadding) {
    return 0;
  }
  if (Array.isArray(stylePadding)) {
    return stylePadding.reduce((val, current) => Math.max(val, current), 0);
  }
  return stylePadding;
};
var getGroupPadding = (element, padding = 0) => {
  if (isGraph(element)) {
    return padding;
  }
  let newPadding = padding;
  if (isNode(element) && element.isGroup() && !element.isCollapsed()) {
    newPadding += getElementPadding(element);
  }
  if (element.getParent()) {
    return getGroupPadding(element.getParent(), newPadding);
  }
  return newPadding;
};
var getGroupChildrenDimensions = (group2) => {
  const children2 = group2.getChildren().filter(isNode).filter((n) => n.isVisible());
  if (!children2.length) {
    return new Dimensions(0, 0);
  }
  let rect;
  children2.forEach((c6) => {
    if (isNode(c6)) {
      const { padding: padding2 } = c6.getStyle();
      const b = c6.getBounds();
      if (!c6.isGroup() && padding2) {
        b.padding(c6.getStyle().padding);
      }
      if (!rect) {
        rect = b.clone();
      } else {
        rect.union(b);
      }
    }
  });
  if (!rect) {
    rect = new Rect();
  }
  const { padding } = group2.getStyle();
  const paddedRect = rect.padding(padding);
  return new Dimensions(paddedRect.width, paddedRect.height);
};

// node_modules/@patternfly/react-topology/dist/esm/utils/geom-utils.js
var maxPadding = (padding) => {
  if (typeof padding === "number") {
    return +padding;
  }
  if (Array.isArray(padding)) {
    return padding.reduce((max5, p) => Math.max(max5, p), 0);
  }
  return 0;
};

// node_modules/@patternfly/react-topology/dist/esm/utils/svg-utils.js
function createSvgIdUrl(id2) {
  return `url(${`${location.pathname}${location.search}`}#${id2})`;
}
function vecScale(scale2, v2) {
  return [scale2 * v2[0], scale2 * v2[1]];
}
function vecSum(pv1, pv2) {
  return [pv1[0] + pv2[0], pv1[1] + pv2[1]];
}
function unitNormal(p02, p1) {
  const n = [p02[1] - p1[1], p1[0] - p02[0]];
  const nLength = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
  return nLength > 0 ? [n[0] / nLength, n[1] / nLength] : [0, 0];
}
function roundedHull1(polyPoints, hp) {
  const padding = hp(polyPoints[0]);
  const p1 = [polyPoints[0][0], polyPoints[0][1] - padding];
  const p2 = [polyPoints[0][0], polyPoints[0][1] + padding];
  return `M ${p1} A ${padding},${padding},0,0,0,${p2} A ${padding},${padding},0,0,0,${p1}`;
}
function boundingBoxForLine(startPoint, endPoint, padding = 0) {
  const hp = typeof padding === "number" ? () => padding : padding;
  const offsetVector1 = vecScale(hp(startPoint), unitNormal(startPoint, endPoint));
  const invOffsetVector1 = vecScale(-1, offsetVector1);
  const offsetVector2 = vecScale(hp(endPoint), unitNormal(startPoint, endPoint));
  const invOffsetVector2 = vecScale(-1, offsetVector2);
  const p02 = vecSum(startPoint, offsetVector1);
  const p1 = vecSum(endPoint, offsetVector2);
  const p2 = vecSum(endPoint, invOffsetVector2);
  const p3 = vecSum(startPoint, invOffsetVector1);
  return [p02, p1, p2, p3];
}
function roundedHull2(polyPoints, hp) {
  const points = boundingBoxForLine(polyPoints[0], polyPoints[1], hp);
  return `M ${points[0]} L ${points[1]} A ${hp(polyPoints[1])},${hp(polyPoints[1])},0,0,0,${points[2]} ${" "}
   L ${points[3]} A ${hp(polyPoints[0])},${hp(polyPoints[0])},0,0,0,${points[0]}`;
}
var pointTuplesToPath = (segments) => {
  const pathSegments = segments.map((segment, index4) => `${index4 === 0 ? "M" : "L"} ${segments[index4][0]}  ${segments[index4][1]}`);
  pathSegments.push(`L ${segments[0][0]}  ${segments[0][1]}`);
  return pathSegments.join(" ");
};
function hullPath(polyPoints, hullPadding = 0) {
  const hp = typeof hullPadding === "number" ? () => hullPadding : hullPadding;
  if (!polyPoints || polyPoints.length < 1) {
    return "";
  }
  if (polyPoints.length === 1) {
    return roundedHull1(polyPoints, hp);
  }
  if (polyPoints.length === 2) {
    return roundedHull2(polyPoints, hp);
  }
  const segments = new Array(polyPoints.length);
  for (let segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {
    const p02 = segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];
    const p1 = polyPoints[segmentIndex];
    segments[segmentIndex] = [
      vecSum(p02, vecScale(hp(p02), unitNormal(p02, p1))),
      vecSum(p1, vecScale(hp(p1), unitNormal(p02, p1)))
    ];
  }
  return segments.map((segment, index4) => {
    const p02 = index4 === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[index4 - 1];
    return `${index4 === 0 ? `M ${segments[segments.length - 1][1]} ` : ""}A ${hp(p02)},${hp(p02)},0,0,0,${segment[0]} L ${segment[1]}`;
  }).join(" ");
}

// node_modules/@patternfly/react-topology/dist/esm/utils/style-utils.js
var import_topology_components2 = __toESM(require_topology_components());
var StatusModifier = {
  [NodeStatus.default]: "",
  [NodeStatus.info]: import_topology_components2.default.modifiers.info,
  [NodeStatus.success]: import_topology_components2.default.modifiers.success,
  [NodeStatus.warning]: import_topology_components2.default.modifiers.warning,
  [NodeStatus.danger]: import_topology_components2.default.modifiers.danger
};
var getEdgeStyleClassModifier = (edgeType) => {
  switch (edgeType) {
    case EdgeStyle.solid:
      return "pf-m-solid";
    case EdgeStyle.dotted:
      return "pf-m-dotted";
    case EdgeStyle.dashed:
      return "pf-m-dashed";
    case EdgeStyle.dashedMd:
      return "pf-m-dashed-md";
    case EdgeStyle.dashedLg:
      return "pf-m-dashed-lg";
    case EdgeStyle.dashedXl:
      return "pf-m-dashed-xl";
    default:
      return "";
  }
};
var getEdgeAnimationDuration = (speed) => {
  switch (speed) {
    case EdgeAnimationSpeed.slow:
      return 1.25;
    case EdgeAnimationSpeed.mediumSlow:
      return 1;
    case EdgeAnimationSpeed.medium:
      return 0.75;
    case EdgeAnimationSpeed.mediumFast:
      return 0.5;
    case EdgeAnimationSpeed.fast:
      return 0.25;
    default:
      return 0;
  }
};

// node_modules/@patternfly/react-topology/dist/esm/utils/getNodeScaleTranslation.js
var getNodeScaleTranslation = (element, nodeScale, scaleNode) => {
  if (!scaleNode) {
    return { translateX: 0, translateY: 0 };
  }
  const bounds = element.getBounds();
  const translateX2 = bounds.width / 2 - bounds.width / 2 * nodeScale;
  const translateY2 = bounds.height / 2 - bounds.height / 2 * nodeScale;
  return { translateX: translateX2, translateY: translateY2 };
};

// node_modules/@patternfly/react-topology/dist/esm/utils/useCallbackRef.js
var import_react38 = __toESM(require_react());
function useCallbackRef(rawCallback) {
  const cleanupRef = (0, import_react38.useRef)(null);
  return (0, import_react38.useCallback)((node) => {
    if (cleanupRef.current) {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (node) {
      cleanupRef.current = rawCallback(node);
    }
  }, [rawCallback]);
}

// node_modules/@patternfly/react-topology/dist/esm/utils/useCombineRefs.js
var React364 = __toESM(require_react());
var useCombineRefs = (...refs) => React364.useCallback(
  (element) => refs.forEach((ref) => {
    if (ref) {
      if (typeof ref === "function") {
        ref(element);
      } else {
        ref.current = element;
      }
    }
  }),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  refs
);
var useCombineRefs_default = useCombineRefs;

// node_modules/@patternfly/react-topology/dist/esm/utils/useHover.js
var React365 = __toESM(require_react());
var useHover = (delayIn = 200, delayOut = 200) => {
  const [hover, setHover] = React365.useState(false);
  const mountRef = React365.useRef(true);
  React365.useEffect(() => () => {
    mountRef.current = false;
  }, []);
  const unsetHandle = React365.useRef();
  const callbackRef = useCallbackRef(React365.useCallback((node) => {
    if (node) {
      let delayHandle;
      const delayedStateChange = (newState, delay) => {
        clearTimeout(unsetHandle.current);
        clearTimeout(delayHandle);
        if (delay != null) {
          delayHandle = setTimeout(() => {
            clearTimeout(unsetHandle.current);
            setHover(newState);
          }, delay);
        } else {
          setHover(newState);
        }
      };
      const onMouseEnter = () => {
        delayedStateChange(true, delayIn);
      };
      const onMouseLeave = () => {
        delayedStateChange(false, delayOut);
      };
      node.addEventListener("mouseenter", onMouseEnter);
      node.addEventListener("mouseleave", onMouseLeave);
      return () => {
        node.removeEventListener("mouseenter", onMouseEnter);
        node.removeEventListener("mouseleave", onMouseLeave);
        clearTimeout(delayHandle);
        if (mountRef.current) {
          unsetHandle.current = setTimeout(() => {
            if (mountRef.current) {
              setHover(false);
            }
          }, Math.max(delayIn, delayOut));
        }
      };
    }
    return void 0;
  }, [delayIn, delayOut]));
  return [hover, callbackRef];
};
var useHover_default = useHover;

// node_modules/@patternfly/react-topology/dist/esm/utils/useSize.js
var React366 = __toESM(require_react());
var EMPTY = [];
var useSize = (dependencies = EMPTY) => {
  const [size, setSize] = React366.useState();
  const sizeRef = React366.useRef();
  sizeRef.current = size;
  const callbackRef = React366.useCallback((node) => {
    if (node != null) {
      const bb2 = node.getBBox();
      if (!sizeRef.current || sizeRef.current.width !== bb2.width || sizeRef.current.height !== bb2.height) {
        setSize({ width: bb2.width, height: bb2.height });
      }
    }
  }, dependencies);
  return [size, callbackRef];
};

// node_modules/@patternfly/react-topology/dist/esm/utils/createAggregateEdges.js
var getNodeParent = (nodeId, nodes) => nodes.find((n) => n.children ? n.children.includes(nodeId) : null);
var getDisplayedNodeForNode = (nodeId, nodes) => {
  if (!nodeId || !nodes) {
    return "";
  }
  let displayedNode = nodes && nodes.find((n) => n.id === nodeId);
  let parent = displayedNode ? getNodeParent(displayedNode.id, nodes) : null;
  while (parent) {
    if (parent.collapsed) {
      displayedNode = parent;
    }
    parent = getNodeParent(parent.id, nodes);
  }
  return displayedNode ? displayedNode.id : "";
};
var createAggregateEdges = (aggregateEdgeType, edges, nodes) => {
  if (!edges) {
    return [];
  }
  const aggregateEdges = [];
  return edges.reduce((newEdges, edge) => {
    var _a2;
    const source = getDisplayedNodeForNode(edge.source, nodes);
    const target = getDisplayedNodeForNode(edge.target, nodes);
    edge.visible = "visible" in edge ? edge.visible : true;
    if (source !== edge.source || target !== edge.target) {
      if (source !== target) {
        const existing = aggregateEdges.find((e) => (e.source === source || e.source === target) && (e.target === target || e.target === source));
        if (existing) {
          existing.children && existing.children.push(edge.id);
          edge.visible = false;
          (_a2 = existing.children) === null || _a2 === void 0 ? void 0 : _a2.forEach((existingChild) => {
            const updateEdge = newEdges.find((newEdge) => newEdge.id === existingChild);
            if (updateEdge) {
              updateEdge.visible = false;
            }
          });
          existing.data.bidirectional = existing.data.bidirectional || existing.source !== edge.source;
          if (!newEdges.find((e) => (e.source === source || e.source === target) && (e.target === target || e.target === source))) {
            newEdges.push(existing);
          }
        } else {
          const newEdge = {
            data: { bidirectional: false },
            children: [edge.id],
            source,
            target,
            id: `aggregate_${source}_${target}`,
            type: aggregateEdgeType
          };
          aggregateEdges.push(newEdge);
        }
      } else {
        edge.visible = false;
      }
    }
    newEdges.push(edge);
    return newEdges;
  }, []);
};

// node_modules/@patternfly/react-topology/dist/esm/utils/Stateful.js
var Stateful = class {
  constructor() {
    this.state = {};
    makeObservable(this, {
      state: observable.shallow,
      setState: action
    });
  }
  getState() {
    return this.state;
  }
  setState(state) {
    if (state) {
      Object.assign(this.state, state);
    }
  }
};

// node_modules/@patternfly/react-topology/dist/esm/elements/BaseElement.js
var BaseElement = class extends Stateful {
  constructor() {
    super();
    this.id = "";
    this.type = "";
    this.data = void 0;
    this.parent = void 0;
    this.visible = true;
    this.children = [];
    this.controller = void 0;
    this.label = void 0;
    this.style = {};
    makeObservable(this, {
      type: observable,
      data: observable.ref,
      parent: observable.ref,
      visible: observable,
      children: observable.shallow,
      controller: observable.ref,
      label: observable,
      style: observable,
      ordering: computed({
        equals: (a4, b) => a4.length === b.length && a4.every((val, i) => val === b[i])
      })
    });
  }
  get ordering() {
    if (!this.parent) {
      return [];
    }
    const idx = this.parent.getChildren().indexOf(this);
    const result = [...this.parent.getOrderKey(), idx];
    return result;
  }
  getLabel() {
    return this.label || "";
  }
  setLabel(label) {
    this.label = label;
  }
  getOrderKey() {
    return this.ordering;
  }
  hasController() {
    return this.controller !== void 0;
  }
  getController() {
    if (!this.controller) {
      throw new Error(`GraphElement with ID '${this.getId()}' has no controller.`);
    }
    return this.controller;
  }
  setController(controller) {
    this.controller = controller;
  }
  getGraph() {
    let p = this;
    while (!isGraph(p)) {
      p = p.getParent();
    }
    return p;
  }
  getParent() {
    if (!this.parent) {
      throw new Error(`GraphElement with ID '${this.getId()}' has no parent.`);
    }
    return this.parent;
  }
  setParent(parent) {
    if (this.parent !== parent) {
      if (this.parent) {
        this.remove();
      }
      this.parent = parent;
    }
  }
  hasParent() {
    return this.parent !== void 0;
  }
  getId() {
    return this.id;
  }
  setId(id2) {
    this.id = id2;
  }
  getType() {
    return this.type;
  }
  setType(type2) {
    this.type = type2;
  }
  setVisible(visible) {
    if (this.visible !== visible) {
      this.visible = visible;
      if (this.controller) {
        this.controller.fireEvent(ELEMENT_VISIBILITY_CHANGE_EVENT, { visible, target: this });
      }
    }
  }
  isVisible() {
    return this.visible && (!this.parent || this.parent.isVisible() && (!isNode(this.parent) || !this.parent.isCollapsed()));
  }
  getData() {
    return this.data;
  }
  setData(data) {
    this.data = data;
  }
  getStyle() {
    return this.style;
  }
  getChildren() {
    return this.children;
  }
  insertChild(child, index4) {
    if (this.children.length === 0 || index4 >= this.children.length || this.children[index4] !== child) {
      const idx = this.children.indexOf(child);
      if (idx !== -1) {
        this.children.splice(idx, 1);
        this.children.splice(index4, 0, child);
      } else {
        child.remove();
        child.setParent(this);
        this.children.splice(index4, 0, child);
        if (this.controller) {
          this.controller.fireEvent(ADD_CHILD_EVENT, { target: this, child });
        }
      }
    }
  }
  appendChild(child) {
    if (this.children.length === 0 || this.children[this.children.length - 1] !== child) {
      const idx = this.children.indexOf(child);
      if (idx !== -1) {
        this.children.splice(idx, 1);
        this.children.push(child);
      } else {
        child.remove();
        child.setParent(this);
        this.children.push(child);
        if (this.controller) {
          this.controller.fireEvent(ADD_CHILD_EVENT, { target: this, child });
        }
      }
    }
  }
  removeChild(child) {
    if (this.children) {
      const idx = this.children.indexOf(child);
      if (idx !== -1) {
        this.children.splice(idx, 1);
        child.setParent(void 0);
        if (this.controller) {
          this.controller.fireEvent(REMOVE_CHILD_EVENT, { target: this, child });
        }
      }
    }
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
  }
  setModel(model) {
    if ("type" in model) {
      this.setType(model.type);
    }
    if ("visible" in model) {
      this.setVisible(!!model.visible);
    }
    if (Array.isArray(model.children)) {
      const controller = this.getController();
      const childElements = model.children.map((id2) => {
        const element = controller.getElementById(id2);
        if (!element) {
          throw new Error(`No element found with ID '${id2}'.`);
        }
        return element;
      });
      this.children.filter((c6) => !childElements.includes(c6)).forEach((child) => this.removeChild(child));
      const toAdd = childElements.filter((c6) => !this.children.includes(c6));
      toAdd.reverse().forEach((child) => this.insertChild(child, 0));
    }
    if ("data" in model) {
      this.data = model.data;
    }
    if ("label" in model) {
      this.label = model.label;
    }
    if ("style" in model) {
      this.style = Object.assign(Object.assign({}, this.style), model.style);
    }
  }
  toModel() {
    return {
      id: this.getId(),
      type: this.getType(),
      label: this.getLabel(),
      visible: this.isVisible(),
      children: this.getChildren().map((c6) => c6.getId()),
      data: this.getData(),
      style: this.getStyle()
    };
  }
  raise() {
    const { parent } = this;
    if (parent) {
      parent.appendChild(this);
      parent.raise();
    }
  }
  translateToAbsolute(t) {
    this.translateToParent(t);
    const { parent } = this;
    if (parent) {
      parent.translateToAbsolute(t);
    }
  }
  translateFromAbsolute(t) {
    const { parent } = this;
    if (parent) {
      parent.translateFromAbsolute(t);
    }
    this.translateFromParent(t);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  translateToParent(t) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  translateFromParent(t) {
  }
  destroy() {
  }
};

// node_modules/@patternfly/react-topology/dist/esm/elements/BaseEdge.js
var BaseEdge = class extends BaseElement {
  constructor() {
    super();
    this.source = void 0;
    this.target = void 0;
    this.edgeStyle = void 0;
    this.animationSpeed = void 0;
    this.bendpoints = void 0;
    this.startPoint = void 0;
    this.endPoint = void 0;
    makeObservable(this, {
      source: observable.ref,
      target: observable.ref,
      edgeStyle: observable.ref,
      animationSpeed: observable.ref,
      bendpoints: observable.shallow,
      startPoint: observable.ref,
      endPoint: observable.ref,
      sourceAnchor: computed,
      targetAnchor: computed
    });
  }
  get sourceAnchor() {
    return this.getSourceAnchorNode().getAnchor(AnchorEnd.source, this.getType());
  }
  get targetAnchor() {
    return this.getTargetAnchorNode().getAnchor(AnchorEnd.target, this.getType());
  }
  getKind() {
    return ModelKind.edge;
  }
  getSource() {
    if (!this.source) {
      throw new Error(`Edge with ID '${this.getId()}' has no source.`);
    }
    return this.source;
  }
  setSource(source) {
    this.source = source;
  }
  getTarget() {
    if (!this.target) {
      throw new Error(`Edge with ID '${this.getId()}' has no target.`);
    }
    return this.target;
  }
  setTarget(target) {
    this.target = target;
  }
  getEdgeStyle() {
    return this.edgeStyle || EdgeStyle.default;
  }
  setEdgeStyle(edgeStyle) {
    this.edgeStyle = edgeStyle;
  }
  getEdgeAnimationSpeed() {
    return this.animationSpeed || EdgeAnimationSpeed.none;
  }
  setEdgeAnimationSpeed(animationSpeed) {
    this.animationSpeed = animationSpeed || EdgeAnimationSpeed.none;
  }
  getSourceAnchorNode() {
    if (!this.source) {
      throw new Error(`Edge with ID '${this.getId()}' has no source.`);
    }
    return getTopCollapsedParent(this.source);
  }
  getTargetAnchorNode() {
    if (!this.target) {
      throw new Error(`Edge with ID '${this.getId()}' has no target.`);
    }
    return getTopCollapsedParent(this.target);
  }
  getBendpoints() {
    return this.bendpoints || [];
  }
  setBendpoints(points) {
    this.bendpoints = points;
  }
  removeBendpoint(point7) {
    if (this.bendpoints) {
      if (typeof point7 === "number") {
        this.bendpoints.splice(point7, 1);
      } else {
        const idx = this.bendpoints.indexOf(point7);
        if (idx !== -1) {
          this.bendpoints.splice(idx, 1);
        }
      }
    }
  }
  getStartPoint() {
    if (this.startPoint) {
      return this.startPoint;
    }
    const bendpoints = this.getBendpoints();
    let referencePoint;
    if (bendpoints && bendpoints.length > 0) {
      [referencePoint] = bendpoints;
    } else if (this.endPoint) {
      referencePoint = this.endPoint;
    } else {
      referencePoint = this.targetAnchor.getReferencePoint();
    }
    return this.sourceAnchor.getLocation(referencePoint);
  }
  setStartPoint(x4, y4) {
    if (x4 == null || y4 == null) {
      this.startPoint = void 0;
    } else {
      this.startPoint = new Point(x4, y4);
    }
  }
  getEndPoint() {
    if (this.endPoint) {
      return this.endPoint;
    }
    const bendpoints = this.getBendpoints();
    let referencePoint;
    if (bendpoints && bendpoints.length > 0) {
      referencePoint = bendpoints[bendpoints.length - 1];
    } else if (this.startPoint) {
      referencePoint = this.startPoint;
    } else {
      referencePoint = this.sourceAnchor.getReferencePoint();
    }
    return this.targetAnchor.getLocation(referencePoint);
  }
  setEndPoint(x4, y4) {
    if (x4 == null || y4 == null) {
      this.endPoint = void 0;
    } else {
      this.endPoint = new Point(x4, y4);
    }
  }
  setModel(model) {
    super.setModel(model);
    if (model.source) {
      const node = this.getController().getNodeById(model.source);
      if (!node) {
        throw new Error(`No source node found with ID '${model.source}'.`);
      }
      this.source = node;
    }
    if (model.target) {
      const node = this.getController().getNodeById(model.target);
      if (!node) {
        throw new Error(`No target node found with ID '${model.target}'.`);
      }
      this.target = node;
    }
    if ("edgeStyle" in model) {
      this.edgeStyle = model.edgeStyle;
    }
    if ("animationSpeed" in model) {
      this.animationSpeed = model.animationSpeed;
    }
    if ("bendpoints" in model) {
      this.bendpoints = model.bendpoints ? model.bendpoints.map((b) => new Point(b[0], b[1])) : [];
    }
  }
  toModel() {
    return Object.assign(Object.assign({}, super.toModel()), { source: this.getSource() ? this.getSource().getId() : void 0, target: this.getTarget() ? this.getTarget().getId() : void 0, edgeStyle: this.edgeStyle, animationSpeed: this.animationSpeed, bendpoints: this.getBendpoints().map((bp) => [bp.x, bp.y]) });
  }
};

// node_modules/@patternfly/react-topology/dist/esm/const.js
var ATTR_DATA_KIND = "data-kind";
var ATTR_DATA_TYPE = "data-type";
var ATTR_DATA_ID = "data-id";
var TOP_LAYER = "top";
var GROUPS_LAYER = "groups";
var DEFAULT_LAYER = "default";
var BOTTOM_LAYER = "bottom";
var DEFAULT_LAYERS = [BOTTOM_LAYER, GROUPS_LAYER, DEFAULT_LAYER, TOP_LAYER];

// node_modules/@patternfly/react-topology/dist/esm/elements/BaseGraph.js
var BaseGraph = class extends BaseElement {
  constructor() {
    super();
    this.layers = DEFAULT_LAYERS;
    this.scale = 1;
    this.layoutType = void 0;
    this.dimensions = new Dimensions();
    this.position = new Point();
    this.currentLayout = void 0;
    this.layoutOptions = void 0;
    this.scaleExtent = [0.25, 4];
    this.scaleDetailsThresholds = {
      low: 0.3,
      medium: 0.5
    };
    this.centerInView = (nodeElement) => {
      if (!nodeElement) {
        return;
      }
      const { x: viewX, y: viewY, width: viewWidth, height: viewHeight } = this.getBounds();
      const boundingBox = nodeElement.getBounds().clone().scale(this.scale).translate(viewX, viewY);
      const { x: x4, y: y4, width, height } = boundingBox;
      const newLocation = {
        x: viewX - (x4 + width / 2) + viewWidth / 2,
        y: viewY - (y4 + height / 2) + viewHeight / 2
      };
      this.setBounds(new Rect(newLocation.x, newLocation.y, viewWidth, viewHeight));
    };
    this.panIntoView = (nodeElement, { offset: offset3 = 0, minimumVisible = 0 } = {}) => {
      if (!nodeElement) {
        return;
      }
      const { x: viewX, y: viewY, width: viewWidth, height: viewHeight } = this.getBounds();
      const boundingBox = nodeElement.getBounds().clone().scale(this.scale).translate(viewX, viewY);
      const { x: x4, y: y4, width, height } = boundingBox;
      let move = false;
      const panOffset = offset3 * this.scale;
      const minVisibleSize = minimumVisible * this.scale;
      const newLocation = {
        x: viewX,
        y: viewY
      };
      if (x4 + width - minVisibleSize < 0) {
        newLocation.x -= x4 - panOffset;
        move = true;
      }
      if (x4 + minVisibleSize > viewWidth) {
        newLocation.x -= x4 + width - viewWidth + panOffset;
        move = true;
      }
      if (y4 + height - minVisibleSize < 0) {
        newLocation.y -= y4 - panOffset;
        move = true;
      }
      if (y4 + minVisibleSize > viewHeight) {
        newLocation.y -= y4 + height - viewHeight + panOffset;
        move = true;
      }
      if (move) {
        this.setBounds(new Rect(newLocation.x, newLocation.y, viewWidth, viewHeight));
      }
    };
    makeObservable(this, {
      layers: observable.ref,
      scale: observable,
      layoutType: observable,
      layoutOptions: observable.deep,
      dimensions: observable.ref,
      position: observable.ref,
      scaleExtent: observable.ref,
      detailsLevel: computed,
      edges: computed,
      nodes: computed,
      scaleDetailsThresholds: observable.ref
    });
  }
  get detailsLevel() {
    if (!this.scaleDetailsThresholds) {
      return ScaleDetailsLevel.high;
    }
    if (this.scale <= this.scaleDetailsThresholds.low) {
      return ScaleDetailsLevel.low;
    } else if (this.scale <= this.scaleDetailsThresholds.medium) {
      return ScaleDetailsLevel.medium;
    }
    return ScaleDetailsLevel.high;
  }
  get edges() {
    return this.getChildren().filter(isEdge);
  }
  get nodes() {
    return this.getChildren().filter(isNode);
  }
  getKind() {
    return ModelKind.graph;
  }
  getLayers() {
    return this.layers;
  }
  setLayers(layers) {
    this.layers = layers;
  }
  getScaleExtent() {
    return this.scaleExtent;
  }
  setScaleExtent(scaleExtent) {
    this.scaleExtent = scaleExtent;
    if (this.hasController()) {
      this.getController().fireEvent(GRAPH_POSITION_CHANGE_EVENT, { graph: this });
    }
  }
  getDetailsLevelThresholds() {
    return this.scaleDetailsThresholds;
  }
  setDetailsLevelThresholds(settings) {
    this.scaleDetailsThresholds = settings;
  }
  getDetailsLevel() {
    return this.detailsLevel;
  }
  getBounds() {
    const { position: { x: x4, y: y4 }, dimensions: { width, height } } = this;
    return new Rect(x4, y4, width, height);
  }
  setBounds(bounds) {
    const { width, height } = this.dimensions;
    if (bounds.width !== width || bounds.height !== height) {
      this.dimensions = new Dimensions(bounds.width, bounds.height);
    }
    const { x: x4, y: y4 } = this.position;
    if (bounds.x !== x4 || bounds.y !== y4) {
      this.setPosition(new Point(bounds.x, bounds.y));
    }
  }
  getPosition() {
    return this.position;
  }
  setPosition(point7) {
    this.position = point7;
    if (this.hasController()) {
      this.getController().fireEvent(GRAPH_POSITION_CHANGE_EVENT, { graph: this });
    }
  }
  getDimensions() {
    return this.dimensions;
  }
  setDimensions(dimensions) {
    this.dimensions = dimensions;
  }
  getNodes() {
    return this.nodes;
  }
  getEdges() {
    return this.edges;
  }
  getLayout() {
    return this.layoutType;
  }
  getLayoutOptions() {
    return this.layoutOptions;
  }
  setLayout(layout3) {
    var _a2, _b;
    if (layout3 === this.layoutType) {
      return;
    }
    if (this.currentLayout) {
      this.currentLayout.destroy();
      this.layoutOptions = void 0;
    }
    this.layoutType = layout3;
    this.currentLayout = layout3 ? this.getController().getLayout(layout3) : void 0;
    this.layoutOptions = (_b = (_a2 = this.currentLayout) === null || _a2 === void 0 ? void 0 : _a2.getLayoutOptions) === null || _b === void 0 ? void 0 : _b.call(_a2);
  }
  layout() {
    if (this.currentLayout) {
      this.currentLayout.layout();
    }
  }
  getScale() {
    return this.scale;
  }
  setScale(scale2) {
    this.scale = scale2;
    if (this.hasController()) {
      this.getController().fireEvent(GRAPH_POSITION_CHANGE_EVENT, { graph: this });
    }
  }
  reset() {
    if (this.currentLayout) {
      this.currentLayout.stop();
    }
    this.setScale(1);
    this.setPosition(new Point(0, 0));
  }
  setAllChildrenCollapsedState(parent, collapsed) {
    console.log(parent.getAllNodeChildren(false));
    parent.getAllNodeChildren(false).forEach((node) => {
      if (node.isGroup()) {
        node.setCollapsed(collapsed);
      }
    });
  }
  expandAll() {
    this.getNodes().forEach((node) => {
      if (node.isGroup()) {
        node.setCollapsed(false);
        this.setAllChildrenCollapsedState(node, false);
      }
    });
  }
  collapseAll() {
    this.getNodes().forEach((node) => {
      if (node.isGroup()) {
        node.setCollapsed(true);
        this.setAllChildrenCollapsedState(node, true);
      }
    });
  }
  scaleBy(scale2, location2) {
    const b = this.getBounds();
    let { x: x4, y: y4 } = b;
    const c6 = location2 || b.getCenter().translate(-x4, -y4);
    x4 = (c6.x - x4) / this.scale;
    y4 = (c6.y - y4) / this.scale;
    const newScale = Math.max(Math.min(this.scale * scale2, this.scaleExtent[1]), this.scaleExtent[0]);
    this.setScale(newScale);
    x4 = c6.x - x4 * this.scale;
    y4 = c6.y - y4 * this.scale;
    this.setPosition(new Point(x4, y4));
  }
  fit(padding = 0, node) {
    let rect;
    if (node) {
      rect = node.getBounds();
    } else {
      this.getNodes().forEach((c6) => {
        const b = c6.getBounds();
        if (!rect) {
          rect = b.clone();
        } else {
          rect.union(b);
        }
      });
    }
    if (!rect) {
      return;
    }
    const { width, height } = rect;
    if (width === 0 || height === 0) {
      return;
    }
    const { width: fullWidth, height: fullHeight } = this.getDimensions();
    const midX = rect.x + width / 2;
    const midY = rect.y + height / 2;
    const maxScale = Math.max(this.getScale(), 1);
    const scale2 = Math.min(1 / Math.max(width / Math.max(1, fullWidth - padding), height / Math.max(1, fullHeight - padding)), maxScale);
    const tx = fullWidth / 2 - midX * scale2;
    const ty = fullHeight / 2 - midY * scale2;
    this.setScale(scale2);
    this.setPosition(new Point(tx, ty));
  }
  isNodeInView(element, { padding = 0 }) {
    const graph = element.getGraph();
    const { x: viewX, y: viewY, width: viewWidth, height: viewHeight } = graph.getBounds();
    const { x: x4, y: y4, width, height } = element.getBounds().clone().scale(this.scale).translate(viewX, viewY);
    return x4 + width > -padding && x4 < viewWidth + padding && y4 + height > -padding && y4 < viewHeight + padding;
  }
  setModel(model) {
    super.setModel(model);
    if ("layers" in model && model.layers) {
      this.setLayers(model.layers);
    }
    if ("layout" in model) {
      this.setLayout(model.layout);
    }
    if (model.scaleExtent && model.scaleExtent.length === 2) {
      this.setScaleExtent(model.scaleExtent);
    }
    if ("scale" in model && typeof model.scale === "number") {
      this.setScale(+model.scale);
    }
    let p;
    if ("x" in model && model.x != null) {
      if (!p) {
        p = this.position.clone();
      }
      p.x = model.x;
    }
    if ("y" in model && model.y != null) {
      if (!p) {
        p = this.position.clone();
      }
      p.y = model.y;
    }
    if (p) {
      this.setPosition(p);
    }
  }
  toModel() {
    return Object.assign(Object.assign({}, super.toModel()), { layout: this.getLayout(), x: this.getPosition().x, y: this.getPosition().y, scale: this.getScale(), scaleExtent: this.getScaleExtent(), layers: this.getLayers() });
  }
  translateToAbsolute() {
  }
  translateFromAbsolute() {
  }
  destroy() {
    if (this.currentLayout) {
      this.currentLayout.destroy();
    }
  }
};

// node_modules/@patternfly/react-topology/dist/esm/anchors/AbstractAnchor.js
var AbstractAnchor = class {
  constructor(owner, offset3 = 0) {
    this.owner = owner;
    this.offset = offset3;
  }
  getReferencePoint() {
    return this.owner.getBounds().getCenter().translate(this.offset, this.offset);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/anchors/CenterAnchor.js
var CenterAnchor = class extends AbstractAnchor {
  getLocation(reference2) {
    const bounds = this.owner.getBounds();
    if (this.offset === 0) {
      return bounds.getCenter();
    }
    const offset2x = this.offset * 2;
    return getEllipseAnchorPoint(bounds.getCenter(), offset2x, offset2x, reference2);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/elements/BaseNode.js
var createAnchorKey = (end2 = AnchorEnd.both, type2 = "") => `${end2}:${type2}`;
var BaseNode = class extends BaseElement {
  constructor() {
    super();
    this.anchors = {
      [createAnchorKey()]: new CenterAnchor(this)
    };
    this.dimensions = new Dimensions();
    this.dimensionsInitialized = false;
    this.positioned = false;
    this.uncollapsedCenter = null;
    this.position = new Point();
    this.group = false;
    this.collapsed = false;
    this.labelPosition = LabelPosition.bottom;
    this.shape = void 0;
    this.status = void 0;
    makeObservable(this, {
      anchors: observable.shallow,
      dimensions: observable.ref,
      dimensionsInitialized: observable,
      position: observable.ref,
      nodes: computed,
      group: observable,
      collapsed: observable,
      labelPosition: observable,
      shape: observable,
      status: observable,
      groupBounds: computed,
      sourceEdges: computed,
      targetEdges: computed,
      setDimensions: action,
      setBounds: action,
      setPosition: action,
      setGroupDimensionInitializedByChildren: action
    });
  }
  get nodes() {
    if (this.isCollapsed()) {
      return [];
    }
    return this.getChildren().filter(isNode);
  }
  get groupBounds() {
    const children2 = this.getChildren().filter(isNode).filter((n) => n.isVisible());
    if (!children2.length) {
      return this.getInternalBounds();
    }
    let rect;
    children2.forEach((c6) => {
      if (isNode(c6)) {
        const { padding: padding2 } = c6.getStyle();
        const b = c6.getBounds();
        if (!c6.isGroup() && padding2) {
          b.padding(c6.getStyle().padding);
        }
        if (!rect) {
          rect = b.clone();
        } else {
          rect.union(b);
        }
      }
    });
    if (!rect) {
      rect = new Rect();
    }
    const { padding } = this.getStyle();
    return rect.padding(padding);
  }
  get sourceEdges() {
    return this.getGraph().getEdges().filter((e) => e.getSource() === this);
  }
  get targetEdges() {
    return this.getGraph().getEdges().filter((e) => e.getTarget() === this);
  }
  getChildren() {
    if (this.isCollapsed()) {
      return super.getChildren().filter(isEdge);
    }
    return super.getChildren();
  }
  // Return all child nodes regardless of collapse status or child groups' collapsed status
  getAllNodeChildren(leafOnly = true) {
    return super.getChildren().reduce((total, nexChild) => {
      if (isNode(nexChild)) {
        if (nexChild.isGroup()) {
          total.push(...nexChild.getAllNodeChildren(leafOnly));
          if (leafOnly) {
            return total;
          }
        }
        total.push(nexChild);
      }
      return total;
    }, []);
  }
  getPositionableChildren() {
    return super.getChildren().reduce((total, nexChild) => {
      if (isNode(nexChild)) {
        if (nexChild.isGroup() && !nexChild.isCollapsed()) {
          return total.concat(nexChild.getPositionableChildren());
        }
        total.push(nexChild);
      }
      return total;
    }, []);
  }
  // Return all children regardless of collapse status
  getAllChildren() {
    return super.getChildren();
  }
  getKind() {
    return ModelKind.node;
  }
  getInternalBounds() {
    const { position, dimensions } = this;
    return new Rect(position.x, position.y, dimensions.width, dimensions.height);
  }
  getBounds() {
    return this.group && !this.collapsed ? this.groupBounds : this.getInternalBounds();
  }
  setBounds(bounds) {
    const { width, height } = this.dimensions;
    if (bounds.width !== width || bounds.height !== height) {
      this.dimensions = new Dimensions(bounds.width, bounds.height);
    }
    const { x: x4, y: y4 } = this.position;
    if (bounds.x !== x4 || bounds.y !== y4) {
      this.setPosition(new Point(bounds.x, bounds.y));
    }
  }
  getPosition() {
    if (this.isGroup() && this.getChildren().length && !this.collapsed) {
      return this.getBounds().getCenter();
    }
    return this.position;
  }
  updateChildrenPositions(point7, prevLocation) {
    const xOffset = point7.x - prevLocation.x;
    const yOffset = point7.y - prevLocation.y;
    this.getPositionableChildren().forEach((child) => {
      if (isNode(child)) {
        const node = child;
        const position = node.getPosition();
        const newPosition = new Point(position.x + xOffset, position.y + yOffset);
        node.setPosition(newPosition);
      }
    });
  }
  setPosition(point7) {
    if (this.isGroup() && this.getChildren().length && !this.collapsed) {
      const prevLocation = this.getBounds().getCenter();
      this.updateChildrenPositions(point7, prevLocation);
      return;
    }
    this.position = point7;
    this.positioned = true;
    try {
      this.getController().fireEvent(NODE_POSITIONED_EVENT, { node: this });
    } catch (e) {
    }
  }
  isPositioned() {
    return this.positioned;
  }
  getDimensions() {
    return this.dimensions;
  }
  setDimensions(dimensions) {
    this.dimensions = dimensions;
    this.dimensionsInitialized = true;
  }
  setGroupDimensionInitializedByChildren() {
    if (!this.dimensionsInitialized && this.isGroup()) {
      const nodes = this.getChildren().filter(isNode);
      if (nodes.length > 0 && nodes.every((c6) => c6.isDimensionsInitialized())) {
        this.dimensionsInitialized = true;
      }
    }
  }
  isDimensionsInitialized() {
    this.setGroupDimensionInitializedByChildren();
    return this.dimensionsInitialized;
  }
  getAnchor(end2, type2) {
    let anchor = this.anchors[createAnchorKey(end2, type2)];
    if (!anchor && type2) {
      anchor = this.anchors[createAnchorKey(end2)];
    }
    if (!anchor && (end2 === AnchorEnd.source || end2 === AnchorEnd.target)) {
      anchor = this.anchors[createAnchorKey(AnchorEnd.both, type2)];
      if (!anchor && type2) {
        anchor = this.anchors[createAnchorKey(AnchorEnd.both)];
      }
    }
    return anchor;
  }
  setAnchor(anchor, end2, type2) {
    const key = createAnchorKey(end2, type2);
    if (anchor) {
      this.anchors[key] = anchor;
    } else {
      delete this.anchors[key];
    }
  }
  getNodes() {
    return this.nodes;
  }
  isGroup() {
    return this.group;
  }
  setGroup(group2) {
    this.group = group2;
  }
  isCollapsed() {
    return this.collapsed;
  }
  setCollapsed(collapsed) {
    if (collapsed !== this.collapsed) {
      const prevCenter = this.getBounds().getCenter();
      if (!collapsed && this.uncollapsedCenter) {
        this.updateChildrenPositions(prevCenter, this.uncollapsedCenter);
        this.uncollapsedCenter = null;
        this.collapsed = collapsed;
      } else {
        this.uncollapsedCenter = collapsed ? prevCenter : null;
        this.collapsed = collapsed;
        this.setBounds(this.getBounds().setCenter(prevCenter.x, prevCenter.y));
      }
      this.getController().fireEvent(NODE_COLLAPSE_CHANGE_EVENT, { node: this });
    }
  }
  getLabelPosition() {
    return this.labelPosition;
  }
  setLabelPosition(position) {
    this.labelPosition = position;
  }
  getNodeShape() {
    return this.shape || (this.group ? NodeShape.rect : NodeShape.ellipse);
  }
  setNodeShape(shape) {
    this.shape = shape;
  }
  getNodeStatus() {
    return this.status || NodeStatus.default;
  }
  setNodeStatus(status) {
    this.status = status;
  }
  getSourceEdges() {
    return this.sourceEdges;
  }
  getTargetEdges() {
    return this.targetEdges;
  }
  isVisible() {
    return super.isVisible() && this.isDimensionsInitialized();
  }
  setModel(model) {
    super.setModel(model);
    let d;
    let p;
    if ("width" in model && model.width != null && model.width !== this.dimensions.width) {
      if (!d) {
        d = this.dimensions.clone();
      }
      d.width = model.width;
    }
    if ("height" in model && model.height != null && model.height !== this.dimensions.height) {
      if (!d) {
        d = this.dimensions.clone();
      }
      d.height = model.height;
    }
    if (d) {
      this.setDimensions(d);
    }
    if ("x" in model && model.x != null && model.x !== this.position.x) {
      if (!p) {
        p = this.position.clone();
      }
      p.x = model.x;
    }
    if ("y" in model && model.y != null && model.y !== this.position.y) {
      if (!p) {
        p = this.position.clone();
      }
      p.y = model.y;
    }
    if (p) {
      this.setPosition(p);
    }
    if ("group" in model) {
      this.setGroup(!!model.group);
    }
    if ("labelPosition" in model) {
      this.labelPosition = model.labelPosition;
    }
    if ("shape" in model) {
      this.shape = model.shape;
    }
    if ("status" in model) {
      this.status = model.status;
    }
    if ("collapsed" in model) {
      this.setCollapsed(!!model.collapsed);
    }
  }
  toModel() {
    return Object.assign(Object.assign({}, super.toModel()), { x: this.isPositioned() ? this.getPosition().x : void 0, y: this.isPositioned() ? this.getPosition().y : void 0, width: this.isDimensionsInitialized() ? this.getDimensions().width : void 0, height: this.isDimensionsInitialized() ? this.getDimensions().height : void 0, collapsed: this.isCollapsed(), group: this.isGroup(), labelPosition: this.labelPosition, shape: this.shape, status: this.status });
  }
  translateToParent(t) {
    if (!this.group || this.isCollapsed()) {
      const { x: x4, y: y4 } = this.getPosition();
      t.translate(x4, y4);
    }
  }
  translateFromParent(t) {
    if (!this.group || this.isCollapsed()) {
      const { x: x4, y: y4 } = this.getPosition();
      t.translate(-x4, -y4);
    }
  }
};

// node_modules/@patternfly/react-topology/dist/esm/elements/defaultElementFactory.js
var defaultElementFactory = (kind) => {
  switch (kind) {
    case ModelKind.graph:
      return new BaseGraph();
    case ModelKind.node:
      return new BaseNode();
    case ModelKind.edge:
      return new BaseEdge();
    default:
      return void 0;
  }
};
var defaultElementFactory_default = defaultElementFactory;

// node_modules/@patternfly/react-topology/dist/esm/Visualization.js
configure({ isolateGlobalState: true });
var Visualization = class extends Stateful {
  constructor() {
    super();
    this.elements = {};
    this.graph = void 0;
    this.viewConstraintsEnabled = true;
    this.viewPaddingSettings = {
      paddingPercentage: 50
    };
    this.layoutFactories = [];
    this.componentFactories = [];
    this.elementFactories = [defaultElementFactory_default];
    this.eventListeners = {};
    this.store = {};
    makeObservable(this, {
      elements: observable.shallow,
      graph: observable.ref,
      viewConstraintsEnabled: observable,
      viewPaddingSettings: observable.ref,
      viewPadding: computed,
      store: observable.shallow,
      fromModel: action,
      setGraph: action
    });
  }
  get viewPadding() {
    const { padding, paddingPercentage } = this.viewPaddingSettings;
    if (paddingPercentage) {
      const graph = this.graph;
      if (!graph) {
        return 0;
      }
      const { width: viewWidth, height: viewHeight } = graph.getBounds();
      return Math.max(viewWidth, viewHeight) * graph.getScale() * (paddingPercentage / 100);
    }
    return padding;
  }
  getStore() {
    return this.store;
  }
  fromModel(model, merge2 = true) {
    const oldGraph = this.graph;
    if (!merge2) {
      Object.keys(this.elements).forEach((element) => this.removeElement(this.elements[element]));
    }
    if (model.graph) {
      this.graph = this.createElement(ModelKind.graph, model.graph);
      if (!merge2 && oldGraph) {
        this.graph.setDimensions(oldGraph.getDimensions());
      }
    }
    const validIds = [];
    const idToElement = {};
    model.nodes && model.nodes.forEach((n) => {
      idToElement[n.id] = n;
      this.createElement(ModelKind.node, n);
      validIds.push(n.id);
    });
    model.edges && model.edges.forEach((e) => {
      idToElement[e.id] = e;
      this.createElement(ModelKind.edge, e);
      validIds.push(e.id);
    });
    if (model.graph && this.graph) {
      this.graph.setModel(model.graph);
    }
    validIds.push(this.graph.getId());
    const processed = {};
    const processElement = (element) => {
      if (element.children) {
        element.children.forEach((id2) => processElement(idToElement[id2]));
      }
      if (!processed[element.id]) {
        processed[element.id] = true;
        this.elements[element.id].setModel(element);
      }
    };
    model.nodes && model.nodes.forEach(processElement);
    model.edges && model.edges.forEach(processElement);
    if (merge2) {
      Object.keys(this.elements).forEach((key) => {
        const element = this.elements[key];
        if (!validIds.includes(element.getId())) {
          this.removeElement(element);
        }
      });
      if (oldGraph && oldGraph !== this.graph) {
        this.removeElement(oldGraph);
      }
    }
    if (this.graph) {
      this.parentOrphansToGraph(this.graph, validIds);
    }
  }
  hasGraph() {
    return !!this.graph;
  }
  getGraph() {
    if (!this.graph) {
      throw new Error("Graph has not been set.");
    }
    return this.graph;
  }
  setGraph(graph) {
    if (this.graph !== graph) {
      if (this.graph) {
        this.graph.setController(void 0);
      }
      this.graph = graph;
      graph.setController(this);
    }
  }
  getElements() {
    return Object.values(this.elements);
  }
  toModel() {
    const graph = this.getGraph();
    const nodes = this.getElements().filter((n) => isNode(n));
    const edges = this.getElements().filter((e) => isEdge(e));
    return {
      graph: graph.toModel(),
      nodes: nodes.map((n) => n.toModel()),
      edges: edges.map((e) => e.toModel())
    };
  }
  addElement(element) {
    if (this.elements[element.getId()]) {
      throw new Error(`Duplicate element for ID '${element.getId()}`);
    }
    element.setController(this);
    this.elements[element.getId()] = element;
  }
  removeElement(element) {
    if (this.elements[element.getId()]) {
      element.remove();
      element.getChildren().slice().forEach((child) => child.remove());
      element.destroy();
      element.setController(void 0);
      delete this.elements[element.getId()];
    }
  }
  getElementById(id2) {
    return this.elements[id2];
  }
  getNodeById(id2) {
    const node = this.elements[id2];
    if (node && isNode(node)) {
      return node;
    }
    return void 0;
  }
  getEdgeById(id2) {
    const edge = this.elements[id2];
    if (edge && isEdge(edge)) {
      return edge;
    }
    return void 0;
  }
  getComponent(kind, type2) {
    for (const factory of this.componentFactories) {
      const component = factory(kind, type2);
      if (component) {
        return component;
      }
    }
    throw new Error(`Could not find component for: Kind '${kind}', Type '${type2}'`);
  }
  registerLayoutFactory(factory) {
    this.layoutFactories.unshift(factory);
  }
  getLayout(type2) {
    for (const factory of this.layoutFactories) {
      const layout3 = factory(type2, this.getGraph());
      if (layout3) {
        return layout3;
      }
    }
    throw new Error(`Could not find layout for type: ${type2}`);
  }
  setRenderConstraint(constrained, viewPadding) {
    this.viewConstraintsEnabled = constrained;
    if (viewPadding !== void 0) {
      this.viewPaddingSettings = viewPadding;
    }
  }
  setFitToScreenOnLayout(fitToScreen, padding = 80) {
    if (this.fitToScreenListener) {
      this.removeEventListener(GRAPH_LAYOUT_END_EVENT, this.fitToScreenListener);
    }
    if (fitToScreen) {
      this.fitToScreenListener = ({ graph }) => {
        graph.fit(padding);
      };
      this.addEventListener(GRAPH_LAYOUT_END_EVENT, this.fitToScreenListener);
      return;
    }
  }
  shouldRenderNode(node) {
    if (!this.viewConstraintsEnabled) {
      return true;
    }
    return this.graph.isNodeInView(node, { padding: this.viewPadding });
  }
  registerComponentFactory(factory) {
    this.componentFactories.unshift(factory);
  }
  registerElementFactory(factory) {
    this.elementFactories.unshift(factory);
  }
  addEventListener(type2, listener) {
    if (!this.eventListeners[type2]) {
      this.eventListeners[type2] = [listener];
    } else {
      this.eventListeners[type2].push(listener);
    }
    return this;
  }
  removeEventListener(type2, listener) {
    if (!this.eventListeners[type2]) {
      return this;
    }
    const listeners = this.eventListeners[type2];
    const l = [];
    for (let i = 0, { length: length3 } = listeners; i < length3; i++) {
      if (listeners[i] !== listener) {
        l.push(listeners[i]);
      }
    }
    if (l.length) {
      this.eventListeners[type2] = l;
    } else {
      delete this.eventListeners[type2];
    }
    return this;
  }
  fireEvent(type2, ...args) {
    const listeners = this.eventListeners[type2];
    if (listeners) {
      for (let i = 0, { length: length3 } = listeners; i < length3; i++) {
        listeners[i](...args);
      }
    }
  }
  createElement(kind, elementModel) {
    const existingElement = this.elements[elementModel.id];
    if (existingElement) {
      return existingElement;
    }
    for (const factory of this.elementFactories) {
      const element = factory(kind, elementModel.type);
      if (element) {
        this.initElement(element, elementModel);
        return element;
      }
    }
    throw new Error(`Could not create element for: ${JSON.stringify(elementModel)}`);
  }
  initElement(element, model) {
    element.setId(model.id);
    element.setType(model.type);
    element.setController(this);
    this.addElement(element);
  }
  parentOrphansToGraph(graph, validIds) {
    this.getElements().forEach((element) => {
      if (element !== this.graph && (!element.hasParent() || !validIds.includes(element.getParent().getId()))) {
        graph.appendChild(element);
      }
    });
  }
};

// node_modules/@patternfly/react-topology/dist/esm/components/VisualizationProvider.js
var VisualizationProvider = ({ controller, children: children2 }) => {
  const controllerRef = React367.useRef();
  if (controller && controllerRef.current !== controller) {
    controllerRef.current = controller;
  } else if (!controllerRef.current) {
    controllerRef.current = new Visualization();
  }
  return React367.createElement(ControllerContext_default.Provider, { value: controllerRef.current }, children2);
};
var VisualizationProvider_default = VisualizationProvider;

// node_modules/@patternfly/react-topology/dist/esm/components/VisualizationSurface.js
var React374 = __toESM(require_react());

// node_modules/mobx-react/batchingForReactDom.js
require_batchingForReactDom();

// node_modules/mobx-react/dist/mobxreact.esm.js
var import_react45 = __toESM(require_react());

// node_modules/mobx-react-lite/es/utils/assertEnvironment.js
var import_react39 = __toESM(require_react());
if (!import_react39.useState) {
  throw new Error("mobx-react-lite requires React with Hooks support");
}
if (!makeObservable) {
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
}

// node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js
var import_react_dom = __toESM(require_react_dom());

// node_modules/mobx-react-lite/es/utils/observerBatching.js
function defaultNoopBatch(callback) {
  callback();
}
function observerBatching(reactionScheduler3) {
  if (!reactionScheduler3) {
    reactionScheduler3 = defaultNoopBatch;
    if (true) {
      console.warn("[MobX] Failed to get unstable_batched updates from react-dom / react-native");
    }
  }
  configure({ reactionScheduler: reactionScheduler3 });
}

// node_modules/mobx-react-lite/es/useObserver.js
var import_react40 = __toESM(require_react());

// node_modules/mobx-react-lite/es/utils/printDebugValue.js
function printDebugValue(v2) {
  return getDependencyTree(v2);
}

// node_modules/mobx-react-lite/es/utils/UniversalFinalizationRegistry.js
var REGISTRY_FINALIZE_AFTER = 1e4;
var REGISTRY_SWEEP_INTERVAL = 1e4;
var TimerBasedFinalizationRegistry = (
  /** @class */
  function() {
    function TimerBasedFinalizationRegistry2(finalize) {
      var _this = this;
      Object.defineProperty(this, "finalize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: finalize
      });
      Object.defineProperty(this, "registrations", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(this, "sweepTimeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "sweep", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function(maxAge) {
          if (maxAge === void 0) {
            maxAge = REGISTRY_FINALIZE_AFTER;
          }
          clearTimeout(_this.sweepTimeout);
          _this.sweepTimeout = void 0;
          var now2 = Date.now();
          _this.registrations.forEach(function(registration, token) {
            if (now2 - registration.registeredAt >= maxAge) {
              _this.finalize(registration.value);
              _this.registrations.delete(token);
            }
          });
          if (_this.registrations.size > 0) {
            _this.scheduleSweep();
          }
        }
      });
      Object.defineProperty(this, "finalizeAllImmediately", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function() {
          _this.sweep(0);
        }
      });
    }
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "register", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(target, value, token) {
        this.registrations.set(token, {
          value,
          registeredAt: Date.now()
        });
        this.scheduleSweep();
      }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "unregister", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(token) {
        this.registrations.delete(token);
      }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "scheduleSweep", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        if (this.sweepTimeout === void 0) {
          this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);
        }
      }
    });
    return TimerBasedFinalizationRegistry2;
  }()
);
var UniversalFinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : TimerBasedFinalizationRegistry;

// node_modules/mobx-react-lite/es/utils/observerFinalizationRegistry.js
var observerFinalizationRegistry = new UniversalFinalizationRegistry(function(adm) {
  var _a2;
  (_a2 = adm.reaction) === null || _a2 === void 0 ? void 0 : _a2.dispose();
  adm.reaction = null;
});

// node_modules/mobx-react-lite/es/staticRendering.js
var globalIsUsingStaticRendering = false;
function isUsingStaticRendering() {
  return globalIsUsingStaticRendering;
}

// node_modules/mobx-react-lite/es/useObserver.js
var __read = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3) return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"])) m3.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
function observerComponentNameFor(baseComponentName) {
  return "observer".concat(baseComponentName);
}
var ObjectToBeRetainedByReact = (
  /** @class */
  /* @__PURE__ */ function() {
    function ObjectToBeRetainedByReact2() {
    }
    return ObjectToBeRetainedByReact2;
  }()
);
function objectToBeRetainedByReactFactory() {
  return new ObjectToBeRetainedByReact();
}
function useObserver(fn, baseComponentName) {
  if (baseComponentName === void 0) {
    baseComponentName = "observed";
  }
  if (isUsingStaticRendering()) {
    return fn();
  }
  var _a2 = __read(import_react40.default.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a2[0];
  var _b = __read(import_react40.default.useState(), 2), setState = _b[1];
  var forceUpdate = function() {
    return setState([]);
  };
  var admRef = import_react40.default.useRef(null);
  if (!admRef.current) {
    admRef.current = {
      reaction: null,
      mounted: false,
      changedBeforeMount: false
    };
  }
  var adm = admRef.current;
  if (!adm.reaction) {
    adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
      if (adm.mounted) {
        forceUpdate();
      } else {
        adm.changedBeforeMount = true;
      }
    });
    observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);
  }
  import_react40.default.useDebugValue(adm.reaction, printDebugValue);
  import_react40.default.useEffect(function() {
    observerFinalizationRegistry.unregister(adm);
    adm.mounted = true;
    if (adm.reaction) {
      if (adm.changedBeforeMount) {
        adm.changedBeforeMount = false;
        forceUpdate();
      }
    } else {
      adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
        forceUpdate();
      });
      forceUpdate();
    }
    return function() {
      adm.reaction.dispose();
      adm.reaction = null;
      adm.mounted = false;
      adm.changedBeforeMount = false;
    };
  }, []);
  var rendering;
  var exception;
  adm.reaction.track(function() {
    try {
      rendering = fn();
    } catch (e) {
      exception = e;
    }
  });
  if (exception) {
    throw exception;
  }
  return rendering;
}

// node_modules/mobx-react-lite/es/observer.js
var import_react41 = __toESM(require_react());
var warnObserverOptionsDeprecated = true;
var hasSymbol = typeof Symbol === "function" && Symbol.for;
var ReactForwardRefSymbol = hasSymbol ? Symbol.for("react.forward_ref") : typeof import_react41.forwardRef === "function" && (0, import_react41.forwardRef)(function(props) {
  return null;
})["$$typeof"];
var ReactMemoSymbol = hasSymbol ? Symbol.for("react.memo") : typeof import_react41.memo === "function" && (0, import_react41.memo)(function(props) {
  return null;
})["$$typeof"];
function observer(baseComponent, options) {
  var _a2;
  if (warnObserverOptionsDeprecated && options) {
    warnObserverOptionsDeprecated = false;
    console.warn("[mobx-react-lite] `observer(fn, { forwardRef: true })` is deprecated, use `observer(React.forwardRef(fn))`");
  }
  if (ReactMemoSymbol && baseComponent["$$typeof"] === ReactMemoSymbol) {
    throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
  }
  if (isUsingStaticRendering()) {
    return baseComponent;
  }
  var useForwardRef = (_a2 = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a2 !== void 0 ? _a2 : false;
  var render = baseComponent;
  var baseComponentName = baseComponent.displayName || baseComponent.name;
  if (ReactForwardRefSymbol && baseComponent["$$typeof"] === ReactForwardRefSymbol) {
    useForwardRef = true;
    render = baseComponent["render"];
    if (typeof render !== "function") {
      throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
    }
  }
  var observerComponent = function(props, ref) {
    return useObserver(function() {
      return render(props, ref);
    }, baseComponentName);
  };
  if (baseComponentName !== "") {
    ;
    observerComponent.displayName = baseComponentName;
  }
  if (baseComponent.contextTypes) {
    ;
    observerComponent.contextTypes = baseComponent.contextTypes;
  }
  if (useForwardRef) {
    observerComponent = (0, import_react41.forwardRef)(observerComponent);
  }
  observerComponent = (0, import_react41.memo)(observerComponent);
  copyStaticProperties(baseComponent, observerComponent);
  if (true) {
    Object.defineProperty(observerComponent, "contextTypes", {
      set: function() {
        var _a3;
        throw new Error("[mobx-react-lite] `".concat(this.displayName || ((_a3 = this.type) === null || _a3 === void 0 ? void 0 : _a3.displayName) || "Component", ".contextTypes` must be set before applying `observer`."));
      }
    });
  }
  return observerComponent;
}
var hoistBlackList = {
  $$typeof: true,
  render: true,
  compare: true,
  type: true,
  // Don't redefine `displayName`,
  // it's defined as getter-setter pair on `memo` (see #3192).
  displayName: true
};
function copyStaticProperties(base, target) {
  Object.keys(base).forEach(function(key) {
    if (!hoistBlackList[key]) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));
    }
  });
}

// node_modules/mobx-react-lite/es/ObserverComponent.js
function ObserverComponent(_a2) {
  var children2 = _a2.children, render = _a2.render;
  var component = children2 || render;
  if (typeof component !== "function") {
    return null;
  }
  return useObserver(component);
}
if (true) {
  ObserverComponent.propTypes = {
    children: ObserverPropsCheck,
    render: ObserverPropsCheck
  };
}
ObserverComponent.displayName = "Observer";
function ObserverPropsCheck(props, key, componentName, location2, propFullName) {
  var extraKey = key === "children" ? "render" : "children";
  var hasProp2 = typeof props[key] === "function";
  var hasExtraProp = typeof props[extraKey] === "function";
  if (hasProp2 && hasExtraProp) {
    return new Error("MobX Observer: Do not use children and render in the same time in`" + componentName);
  }
  if (hasProp2 || hasExtraProp) {
    return null;
  }
  return new Error("Invalid prop `" + propFullName + "` of type `" + typeof props[key] + "` supplied to `" + componentName + "`, expected `function`.");
}

// node_modules/mobx-react-lite/es/useLocalObservable.js
var import_react42 = __toESM(require_react());

// node_modules/mobx-react-lite/es/useLocalStore.js
var import_react44 = __toESM(require_react());

// node_modules/mobx-react-lite/es/useAsObservableSource.js
var import_react43 = __toESM(require_react());

// node_modules/mobx-react-lite/es/index.js
var _a;
observerBatching(import_react_dom.unstable_batchedUpdates);
var clearTimers = (_a = observerFinalizationRegistry["finalizeAllImmediately"]) !== null && _a !== void 0 ? _a : function() {
};

// node_modules/mobx-react/dist/mobxreact.esm.js
var symbolId = 0;
function createSymbol(name) {
  if (typeof Symbol === "function") {
    return Symbol(name);
  }
  var symbol = "__$mobx-react " + name + " (" + symbolId + ")";
  symbolId++;
  return symbol;
}
var createdSymbols = {};
function newSymbol(name) {
  if (!createdSymbols[name]) {
    createdSymbols[name] = createSymbol(name);
  }
  return createdSymbols[name];
}
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (var i = 0; i < keysA.length; i++) {
    if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
function is(x4, y4) {
  if (x4 === y4) {
    return x4 !== 0 || 1 / x4 === 1 / y4;
  } else {
    return x4 !== x4 && y4 !== y4;
  }
}
function setHiddenProp(target, prop, value) {
  if (!Object.hasOwnProperty.call(target, prop)) {
    Object.defineProperty(target, prop, {
      enumerable: false,
      configurable: true,
      writable: true,
      value
    });
  } else {
    target[prop] = value;
  }
}
var mobxMixins = newSymbol("patchMixins");
var mobxPatchedDefinition = newSymbol("patchedDefinition");
function getMixins(target, methodName) {
  var mixins = target[mobxMixins] = target[mobxMixins] || {};
  var methodMixins = mixins[methodName] = mixins[methodName] || {};
  methodMixins.locks = methodMixins.locks || 0;
  methodMixins.methods = methodMixins.methods || [];
  return methodMixins;
}
function wrapper(realMethod, mixins) {
  var _this = this;
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  mixins.locks++;
  try {
    var retVal;
    if (realMethod !== void 0 && realMethod !== null) {
      retVal = realMethod.apply(this, args);
    }
    return retVal;
  } finally {
    mixins.locks--;
    if (mixins.locks === 0) {
      mixins.methods.forEach(function(mx) {
        mx.apply(_this, args);
      });
    }
  }
}
function wrapFunction(realMethod, mixins) {
  var fn = function fn2() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));
  };
  return fn;
}
function patch(target, methodName, mixinMethod) {
  var mixins = getMixins(target, methodName);
  if (mixins.methods.indexOf(mixinMethod) < 0) {
    mixins.methods.push(mixinMethod);
  }
  var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);
  if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {
    return;
  }
  var originalMethod = target[methodName];
  var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : void 0, mixins, originalMethod);
  Object.defineProperty(target, methodName, newDefinition);
}
function createDefinition(target, methodName, enumerable, mixins, originalMethod) {
  var _ref;
  var wrappedFunc = wrapFunction(originalMethod, mixins);
  return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get5() {
    return wrappedFunc;
  }, _ref.set = function set7(value) {
    if (this === target) {
      wrappedFunc = wrapFunction(value, mixins);
    } else {
      var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);
      Object.defineProperty(this, methodName, newDefinition);
    }
  }, _ref.configurable = true, _ref.enumerable = enumerable, _ref;
}
var mobxAdminProperty = $mobx || "$mobx";
var mobxObserverProperty = newSymbol("isMobXReactObserver");
var mobxIsUnmounted = newSymbol("isUnmounted");
var skipRenderKey = newSymbol("skipRender");
var isForcingUpdateKey = newSymbol("isForcingUpdate");
function makeClassComponentObserver(componentClass) {
  var target = componentClass.prototype;
  if (componentClass[mobxObserverProperty]) {
    var displayName = getDisplayName(target);
    console.warn("The provided component class (" + displayName + ")\n                has already been declared as an observer component.");
  } else {
    componentClass[mobxObserverProperty] = true;
  }
  if (target.componentWillReact) {
    throw new Error("The componentWillReact life-cycle event is no longer supported");
  }
  if (componentClass["__proto__"] !== import_react45.PureComponent) {
    if (!target.shouldComponentUpdate) {
      target.shouldComponentUpdate = observerSCU;
    } else if (target.shouldComponentUpdate !== observerSCU) {
      throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");
    }
  }
  makeObservableProp(target, "props");
  makeObservableProp(target, "state");
  if (componentClass.contextType) {
    makeObservableProp(target, "context");
  }
  var originalRender = target.render;
  if (typeof originalRender !== "function") {
    var _displayName = getDisplayName(target);
    throw new Error("[mobx-react] class component (" + _displayName + ") is missing `render` method.\n`observer` requires `render` being a function defined on prototype.\n`render = () => {}` or `render = function() {}` is not supported.");
  }
  target.render = function() {
    this.render = isUsingStaticRendering() ? originalRender : createReactiveRender.call(this, originalRender);
    return this.render();
  };
  patch(target, "componentDidMount", function() {
    this[mobxIsUnmounted] = false;
    if (!this.render[mobxAdminProperty]) {
      import_react45.Component.prototype.forceUpdate.call(this);
    }
  });
  patch(target, "componentWillUnmount", function() {
    if (isUsingStaticRendering()) {
      return;
    }
    var reaction2 = this.render[mobxAdminProperty];
    if (reaction2) {
      reaction2.dispose();
      this.render[mobxAdminProperty] = null;
    } else {
      var _displayName2 = getDisplayName(this);
      console.warn("The reactive render of an observer class component (" + _displayName2 + ")\n                was overridden after MobX attached. This may result in a memory leak if the\n                overridden reactive render was not properly disposed.");
    }
    this[mobxIsUnmounted] = true;
  });
  return componentClass;
}
function getDisplayName(comp) {
  return comp.displayName || comp.name || comp.constructor && (comp.constructor.displayName || comp.constructor.name) || "<component>";
}
function createReactiveRender(originalRender) {
  var _this = this;
  setHiddenProp(this, skipRenderKey, false);
  setHiddenProp(this, isForcingUpdateKey, false);
  var initialName = getDisplayName(this);
  var boundOriginalRender = originalRender.bind(this);
  var isRenderingPending = false;
  var createReaction = function createReaction2() {
    var reaction2 = new Reaction(initialName + ".render()", function() {
      if (!isRenderingPending) {
        isRenderingPending = true;
        if (_this[mobxIsUnmounted] !== true) {
          var hasError = true;
          try {
            setHiddenProp(_this, isForcingUpdateKey, true);
            if (!_this[skipRenderKey]) {
              import_react45.Component.prototype.forceUpdate.call(_this);
            }
            hasError = false;
          } finally {
            setHiddenProp(_this, isForcingUpdateKey, false);
            if (hasError) {
              reaction2.dispose();
              _this.render[mobxAdminProperty] = null;
            }
          }
        }
      }
    });
    reaction2["reactComponent"] = _this;
    return reaction2;
  };
  function reactiveRender() {
    var _reactiveRender$mobxA;
    isRenderingPending = false;
    var reaction2 = (_reactiveRender$mobxA = reactiveRender[mobxAdminProperty]) != null ? _reactiveRender$mobxA : reactiveRender[mobxAdminProperty] = createReaction();
    var exception = void 0;
    var rendering = void 0;
    reaction2.track(function() {
      try {
        rendering = allowStateChanges(false, boundOriginalRender);
      } catch (e) {
        exception = e;
      }
    });
    if (exception) {
      throw exception;
    }
    return rendering;
  }
  return reactiveRender;
}
function observerSCU(nextProps, nextState) {
  if (isUsingStaticRendering()) {
    console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.");
  }
  if (this.state !== nextState) {
    return true;
  }
  return !shallowEqual(this.props, nextProps);
}
function makeObservableProp(target, propName) {
  var valueHolderKey = newSymbol("reactProp_" + propName + "_valueHolder");
  var atomHolderKey = newSymbol("reactProp_" + propName + "_atomHolder");
  function getAtom2() {
    if (!this[atomHolderKey]) {
      setHiddenProp(this, atomHolderKey, createAtom("reactive " + propName));
    }
    return this[atomHolderKey];
  }
  Object.defineProperty(target, propName, {
    configurable: true,
    enumerable: true,
    get: function get5() {
      var prevReadState = false;
      if (allowStateReadsStart && allowStateReadsEnd) {
        prevReadState = allowStateReadsStart(true);
      }
      getAtom2.call(this).reportObserved();
      if (allowStateReadsStart && allowStateReadsEnd) {
        allowStateReadsEnd(prevReadState);
      }
      return this[valueHolderKey];
    },
    set: function set7(v2) {
      if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v2)) {
        setHiddenProp(this, valueHolderKey, v2);
        setHiddenProp(this, skipRenderKey, true);
        getAtom2.call(this).reportChanged();
        setHiddenProp(this, skipRenderKey, false);
      } else {
        setHiddenProp(this, valueHolderKey, v2);
      }
    }
  });
}
function observer2(component) {
  if (component["isMobxInjector"] === true) {
    console.warn("Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`");
  }
  if (Object.prototype.isPrototypeOf.call(import_react45.Component, component) || Object.prototype.isPrototypeOf.call(import_react45.PureComponent, component)) {
    return makeClassComponentObserver(component);
  } else {
    return observer(component);
  }
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["children"];
var MobXProviderContext = import_react45.default.createContext({});
function Provider(props) {
  var children2 = props.children, stores = _objectWithoutPropertiesLoose(props, _excluded);
  var parentValue = import_react45.default.useContext(MobXProviderContext);
  var mutableProviderRef = import_react45.default.useRef(_extends2({}, parentValue, stores));
  var value = mutableProviderRef.current;
  if (true) {
    var newValue = _extends2({}, value, stores);
    if (!shallowEqual(value, newValue)) {
      throw new Error("MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.");
    }
  }
  return import_react45.default.createElement(MobXProviderContext.Provider, {
    value
  }, children2);
}
Provider.displayName = "MobXProvider";
var protoStoreKey = newSymbol("disposeOnUnmountProto");
var instStoreKey = newSymbol("disposeOnUnmountInst");
function createChainableTypeChecker(validator) {
  function checkType(isRequired, props, propName, componentName, location2, propFullName) {
    for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
      rest[_key - 6] = arguments[_key];
    }
    return untracked(function() {
      componentName = componentName || "<<anonymous>>";
      propFullName = propFullName || propName;
      if (props[propName] == null) {
        if (isRequired) {
          var actual = props[propName] === null ? "null" : "undefined";
          return new Error("The " + location2 + " `" + propFullName + "` is marked as required in `" + componentName + "`, but its value is `" + actual + "`.");
        }
        return null;
      } else {
        return validator.apply(void 0, [props, propName, componentName, location2, propFullName].concat(rest));
      }
    });
  }
  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);
  return chainedCheckType;
}
function isSymbol(propType, propValue) {
  if (propType === "symbol") {
    return true;
  }
  if (propValue["@@toStringTag"] === "Symbol") {
    return true;
  }
  if (typeof Symbol === "function" && propValue instanceof Symbol) {
    return true;
  }
  return false;
}
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return "array";
  }
  if (propValue instanceof RegExp) {
    return "object";
  }
  if (isSymbol(propType, propValue)) {
    return "symbol";
  }
  return propType;
}
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === "object") {
    if (propValue instanceof Date) {
      return "date";
    } else if (propValue instanceof RegExp) {
      return "regexp";
    }
  }
  return propType;
}
function createObservableTypeCheckerCreator(allowNativeType, mobxType) {
  return createChainableTypeChecker(function(props, propName, componentName, location2, propFullName) {
    return untracked(function() {
      if (allowNativeType) {
        if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;
      }
      var mobxChecker;
      switch (mobxType) {
        case "Array":
          mobxChecker = isObservableArray;
          break;
        case "Object":
          mobxChecker = isObservableObject;
          break;
        case "Map":
          mobxChecker = isObservableMap;
          break;
        default:
          throw new Error("Unexpected mobxType: " + mobxType);
      }
      var propValue = props[propName];
      if (!mobxChecker(propValue)) {
        var preciseType = getPreciseType(propValue);
        var nativeTypeExpectationMessage = allowNativeType ? " or javascript `" + mobxType.toLowerCase() + "`" : "";
        return new Error("Invalid prop `" + propFullName + "` of type `" + preciseType + "` supplied to `" + componentName + "`, expected `mobx.Observable" + mobxType + "`" + nativeTypeExpectationMessage + ".");
      }
      return null;
    });
  });
}
function createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {
  return createChainableTypeChecker(function(props, propName, componentName, location2, propFullName) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      rest[_key2 - 5] = arguments[_key2];
    }
    return untracked(function() {
      if (typeof typeChecker !== "function") {
        return new Error("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation.");
      } else {
        var error = createObservableTypeCheckerCreator(allowNativeType, "Array")(props, propName, componentName, location2, propFullName);
        if (error instanceof Error) return error;
        var propValue = props[propName];
        for (var i = 0; i < propValue.length; i++) {
          error = typeChecker.apply(void 0, [propValue, i, componentName, location2, propFullName + "[" + i + "]"].concat(rest));
          if (error instanceof Error) return error;
        }
        return null;
      }
    });
  });
}
var observableArray = createObservableTypeCheckerCreator(false, "Array");
var observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false);
var observableMap = createObservableTypeCheckerCreator(false, "Map");
var observableObject = createObservableTypeCheckerCreator(false, "Object");
var arrayOrObservableArray = createObservableTypeCheckerCreator(true, "Array");
var arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true);
var objectOrObservableObject = createObservableTypeCheckerCreator(true, "Object");
if (!import_react45.Component) throw new Error("mobx-react requires React to be available");
if (!observable) throw new Error("mobx-react requires mobx to be available");

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends3() {
  return _extends3 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends3.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose2(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf2(t, e) {
  return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf2(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose2(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf2(t, o);
}

// node_modules/react-measure/dist/index.esm.js
var import_react46 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index4) {
      if (entry[0] === key) {
        result = index4;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index4 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index4];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index4 = getIndex(this.__entries__, key);
        if (~index4) {
          this.__entries__[index4][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index4 = getIndex(entries, key);
        if (~index4) {
          entries.splice(index4, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
          var entry = _a2[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer3) {
      if (!~this.observers_.indexOf(observer3)) {
        this.observers_.push(observer3);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer3) {
      var observers2 = this.observers_;
      var index4 = observers2.indexOf(observer3);
      if (~index4) {
        observers2.splice(index4, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer3) {
        return observer3.gatherActive(), observer3.hasActive();
      });
      activeObservers.forEach(function(observer3) {
        return observer3.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
      var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
    var key = _a2[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles36) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles36["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles36) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles36["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles36 = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles36);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles36.width), height = toFloat(styles36.height);
  if (styles36.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles36, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles36, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a2) {
  var x4 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x4,
    y: y4,
    width,
    height,
    top: y4,
    right: x4 + width,
    bottom: height + y4,
    left: x4
  });
  return rect;
}
function createRectInit(x4, y4, width, height) {
  return { x: x4, y: y4, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer3 = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer3);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a2;
    return (_a2 = observers.get(this))[method].apply(_a2, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
var ResizeObserver_es_default = index;

// node_modules/react-measure/dist/index.esm.js
var types = ["client", "offset", "scroll", "bounds", "margin"];
function getTypes(props) {
  var allowedTypes = [];
  types.forEach(function(type2) {
    if (props[type2]) {
      allowedTypes.push(type2);
    }
  });
  return allowedTypes;
}
function getContentRect2(node, types2) {
  var calculations = {};
  if (types2.indexOf("client") > -1) {
    calculations.client = {
      top: node.clientTop,
      left: node.clientLeft,
      width: node.clientWidth,
      height: node.clientHeight
    };
  }
  if (types2.indexOf("offset") > -1) {
    calculations.offset = {
      top: node.offsetTop,
      left: node.offsetLeft,
      width: node.offsetWidth,
      height: node.offsetHeight
    };
  }
  if (types2.indexOf("scroll") > -1) {
    calculations.scroll = {
      top: node.scrollTop,
      left: node.scrollLeft,
      width: node.scrollWidth,
      height: node.scrollHeight
    };
  }
  if (types2.indexOf("bounds") > -1) {
    var rect = node.getBoundingClientRect();
    calculations.bounds = {
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      width: rect.width,
      height: rect.height
    };
  }
  if (types2.indexOf("margin") > -1) {
    var styles36 = getComputedStyle(node);
    calculations.margin = {
      top: styles36 ? parseInt(styles36.marginTop) : 0,
      right: styles36 ? parseInt(styles36.marginRight) : 0,
      bottom: styles36 ? parseInt(styles36.marginBottom) : 0,
      left: styles36 ? parseInt(styles36.marginLeft) : 0
    };
  }
  return calculations;
}
function getWindowOf2(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || window;
}
function withContentRect(types2) {
  return function(WrappedComponent) {
    var _class, _temp;
    return _temp = _class = function(_Component) {
      _inheritsLoose2(WithContentRect, _Component);
      function WithContentRect() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _this.state = {
          contentRect: {
            entry: {},
            client: {},
            offset: {},
            scroll: {},
            bounds: {},
            margin: {}
          }
        };
        _this._animationFrameID = null;
        _this._resizeObserver = null;
        _this._node = null;
        _this._window = null;
        _this.measure = function(entries) {
          var contentRect = getContentRect2(_this._node, types2 || getTypes(_this.props));
          if (entries) {
            contentRect.entry = entries[0].contentRect;
          }
          _this._animationFrameID = _this._window.requestAnimationFrame(function() {
            if (_this._resizeObserver !== null) {
              _this.setState({
                contentRect
              });
              if (typeof _this.props.onResize === "function") {
                _this.props.onResize(contentRect);
              }
            }
          });
        };
        _this._handleRef = function(node) {
          if (_this._resizeObserver !== null && _this._node !== null) {
            _this._resizeObserver.unobserve(_this._node);
          }
          _this._node = node;
          _this._window = getWindowOf2(_this._node);
          var innerRef = _this.props.innerRef;
          if (innerRef) {
            if (typeof innerRef === "function") {
              innerRef(_this._node);
            } else {
              innerRef.current = _this._node;
            }
          }
          if (_this._resizeObserver !== null && _this._node !== null) {
            _this._resizeObserver.observe(_this._node);
          }
        };
        return _this;
      }
      var _proto = WithContentRect.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this._resizeObserver = this._window !== null && this._window.ResizeObserver ? new this._window.ResizeObserver(this.measure) : new ResizeObserver_es_default(this.measure);
        if (this._node !== null) {
          this._resizeObserver.observe(this._node);
          if (typeof this.props.onResize === "function") {
            this.props.onResize(getContentRect2(this._node, types2 || getTypes(this.props)));
          }
        }
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        if (this._window !== null) {
          this._window.cancelAnimationFrame(this._animationFrameID);
        }
        if (this._resizeObserver !== null) {
          this._resizeObserver.disconnect();
          this._resizeObserver = null;
        }
      };
      _proto.render = function render() {
        var _this$props = this.props, innerRef = _this$props.innerRef, onResize = _this$props.onResize, props = _objectWithoutPropertiesLoose2(_this$props, ["innerRef", "onResize"]);
        return (0, import_react46.createElement)(WrappedComponent, _extends3({}, props, {
          measureRef: this._handleRef,
          measure: this.measure,
          contentRect: this.state.contentRect
        }));
      };
      return WithContentRect;
    }(import_react46.Component), _class.propTypes = {
      client: import_prop_types.default.bool,
      offset: import_prop_types.default.bool,
      scroll: import_prop_types.default.bool,
      bounds: import_prop_types.default.bool,
      margin: import_prop_types.default.bool,
      innerRef: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.func]),
      onResize: import_prop_types.default.func
    }, _temp;
  };
}
var Measure = withContentRect()(function(_ref) {
  var measure = _ref.measure, measureRef = _ref.measureRef, contentRect = _ref.contentRect, children2 = _ref.children;
  return children2({
    measure,
    measureRef,
    contentRect
  });
});
Measure.displayName = "Measure";
Measure.propTypes.children = import_prop_types.default.func;
var index_esm_default = Measure;

// node_modules/@patternfly/react-topology/dist/esm/components/VisualizationSurface.js
var import_topology_components3 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/dist/esm/components/defs/SVGDefsProvider.js
var React370 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/components/defs/SVGDefsContext.js
var import_react47 = __toESM(require_react());
var SVGDefsContext = (0, import_react47.createContext)(void 0);
var SVGDefsContext_default = SVGDefsContext;

// node_modules/@patternfly/react-topology/dist/esm/components/defs/Defs.js
var React369 = __toESM(require_react());
var Defs = class extends React369.PureComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  setDefs(defs) {
    this.setState({ defs: Object.assign({}, defs) });
  }
  render() {
    const { defs } = this.state;
    return defs ? React369.createElement("defs", null, Object.keys(defs).map((id2) => React369.createElement(React369.Fragment, { key: id2 }, defs[id2].node))) : null;
  }
};

// node_modules/@patternfly/react-topology/dist/esm/components/defs/SVGDefsProvider.js
var SVGDefsProvider = class extends React370.Component {
  constructor() {
    super(...arguments);
    this.defsRef = React370.createRef();
    this.defs = {};
    this.contextValue = {
      addDef: (id2, node) => {
        const defObj = this.defs[id2];
        if (defObj) {
          defObj.count++;
        } else {
          this.defs[id2] = {
            count: 1,
            node
          };
          this.updateDefs();
        }
      },
      removeDef: (id2) => {
        const defObj = this.defs[id2];
        if (--defObj.count === 0) {
          delete this.defs[id2];
          this.updateDefs();
        }
      }
    };
  }
  updateDefs() {
    this.defsRef.current && this.defsRef.current.setDefs(this.defs);
  }
  render() {
    return React370.createElement(
      SVGDefsContext_default.Provider,
      { value: this.contextValue },
      React370.createElement(Defs, { ref: this.defsRef }),
      this.props.children
    );
  }
};
var SVGDefsProvider_default = SVGDefsProvider;

// node_modules/@patternfly/react-topology/dist/esm/components/ElementWrapper.js
var React373 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/components/ComputeElementDimensions.js
var React371 = __toESM(require_react());
var ComputeElementDimensions = ({ element, children: children2 }) => {
  const gRef = React371.useRef(null);
  React371.useEffect(() => {
    if (gRef.current && !element.isDimensionsInitialized()) {
      const { width, height } = gRef.current.getBBox();
      element.setDimensions(new Dimensions(width, height));
    }
  }, [element]);
  return React371.createElement("g", { ref: gRef, style: { visibility: "hidden" } }, children2);
};
var ComputeElementDimensions_default = observer2(ComputeElementDimensions);

// node_modules/@patternfly/react-topology/dist/esm/hooks/useVisualizationController.js
var React372 = __toESM(require_react());
var useVisualizationController = () => React372.useContext(ControllerContext_default);
var useVisualizationController_default = useVisualizationController;

// node_modules/@patternfly/react-topology/dist/esm/behavior/useDndManager.js
var nextUniqueId = 0;
var getNextUniqueId = () => nextUniqueId++;
var matchesType = (targetType, draggedItemType) => {
  if (draggedItemType === null) {
    return targetType === null;
  }
  return Array.isArray(targetType) ? targetType.some((t) => t === draggedItemType) : targetType === draggedItemType;
};
var DndManagerImpl = class {
  constructor(state) {
    this.ending = false;
    this.sources = {};
    this.targets = {};
    makeObservable(this, {
      sources: observable.shallow,
      targets: observable.shallow,
      dropHints: computed,
      registerSource: action,
      registerTarget: action,
      beginDrag: action,
      hover: action,
      drop: action,
      drag: action,
      cancel: action
    });
    this.state = state;
  }
  get dropHints() {
    return this.state.targetIds ? this.state.targetIds.map((id2) => {
      const target = this.getTarget(id2);
      return target ? target.dropHint(this) : [];
    }).filter((x4) => x4) : [];
  }
  registerSource(source) {
    const key = `S${getNextUniqueId()}`;
    this.sources[key] = source;
    return [
      key,
      () => {
        delete this.sources[key];
      }
    ];
  }
  registerTarget(target) {
    const key = `T${getNextUniqueId()}`;
    this.targets[key] = target;
    return [
      key,
      () => {
        delete this.targets[key];
      }
    ];
  }
  getDropHints() {
    return this.dropHints;
  }
  canDragSource(sourceId) {
    const source = this.getSource(sourceId);
    if (!source || this.isDragging()) {
      return false;
    }
    return source && source.canDrag(this);
  }
  canDropOnTarget(targetId) {
    const target = this.getTarget(targetId);
    if (!target || !this.isDragging() || this.didDrop()) {
      return false;
    }
    const draggedItemType = this.getItemType();
    return matchesType(target.type, draggedItemType) && target.canDrop(this);
  }
  isDragging() {
    return !!this.state.isDragging;
  }
  isDraggingSource(sourceId) {
    return this.state.sourceId != null && this.state.sourceId === sourceId;
  }
  isOverTarget(targetId, options = { shallow: false }) {
    if (!targetId) {
      return false;
    }
    const { shallow } = options;
    if (!this.isDragging()) {
      return false;
    }
    const target = this.targets[targetId];
    const draggedItemType = this.getItemType();
    if (draggedItemType && !matchesType(target.type, draggedItemType)) {
      return false;
    }
    const targetIds = this.getTargetIds();
    if (!targetIds.length) {
      return false;
    }
    const index4 = targetIds.indexOf(targetId);
    if (shallow) {
      return index4 === targetIds.length - 1;
    }
    return index4 > -1;
  }
  getItemType() {
    return this.state.itemType;
  }
  getItem() {
    return this.state.item;
  }
  getSourceId() {
    return this.state.sourceId;
  }
  getTargetIds() {
    return this.state.targetIds || [];
  }
  hasDropTarget() {
    return !!this.getTargetIds().find((id2) => this.canDropOnTarget(id2));
  }
  getDropResult() {
    return this.state.dropResult;
  }
  didDrop() {
    return !!this.state.didDrop;
  }
  getDragEvent() {
    return this.state.event;
  }
  getOperation() {
    return this.state.operation;
  }
  isCancelled() {
    return !!this.state.cancelled;
  }
  beginDrag(sourceIds, operation, x4, y4, pageX, pageY) {
    const ids = Array.isArray(sourceIds) ? sourceIds : [sourceIds];
    if (ids.length) {
      let sourceId = null;
      for (let i = ids.length - 1; i >= 0; i--) {
        if (this.canDragSource(ids[i])) {
          sourceId = ids[i];
          break;
        }
      }
      if (sourceId) {
        const source = this.getSource(sourceId);
        if (source) {
          this.state.sourceId = sourceId;
          this.state.itemType = source.type;
          this.state.event = {
            initialPageX: pageX,
            initialPageY: pageY,
            pageX,
            pageY,
            initialX: x4,
            initialY: y4,
            x: x4,
            y: y4,
            dx: 0,
            dy: 0
          };
          this.state.operation = operation;
          this.state.isDragging = true;
          this.state.item = source.beginDrag(this);
        }
      }
    }
    this.performHitTests();
  }
  hover(targetIds) {
    const ids = targetIds.filter((id2) => this.getTarget(id2));
    this.state.targetIds = ids;
    ids.forEach((id2) => {
      const target = this.getTarget(id2);
      if (target) {
        target.hover(this);
      }
    });
  }
  endDrag() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.ending) {
        return;
      }
      this.ending = true;
      const source = this.getSource(this.getSourceId());
      try {
        if (source) {
          yield runInAction(() => source.endDrag(this));
        }
      } finally {
        this.ending = false;
        runInAction(() => {
          delete this.state.didDrop;
          delete this.state.dropResult;
          delete this.state.event;
          delete this.state.isDragging;
          delete this.state.item;
          delete this.state.sourceId;
          delete this.state.targetIds;
          delete this.state.operation;
          delete this.state.cancelled;
        });
      }
    });
  }
  drop() {
    this.getTargetIds().filter((id2) => this.canDropOnTarget(id2)).reverse().forEach((id2, idx) => {
      const target = this.getTarget(id2);
      if (target) {
        let result = target.drop(this);
        if (typeof result === "undefined") {
          result = idx === 0 ? {} : this.state.dropResult;
        }
        this.state.dropResult = result;
        this.state.didDrop = true;
      }
    });
  }
  drag(x4, y4, pageX, pageY) {
    if (!this.state.event) {
      throw new Error("Drag event not initialized");
    }
    this.state.event.dx = x4 - this.state.event.x;
    this.state.event.dy = y4 - this.state.event.y;
    this.state.event.x = x4;
    this.state.event.y = y4;
    this.state.event.pageX = pageX;
    this.state.event.pageY = pageY;
    const source = this.getSource(this.getSourceId());
    if (source) {
      source.drag(this);
    }
    this.performHitTests();
  }
  cancel() {
    if (!this.state.event) {
      throw new Error("Drag event not initialized");
    }
    if (this.state.cancelled) {
      return true;
    }
    const source = this.getSource(this.getSourceId());
    if (source && source.canCancel(this)) {
      this.state.cancelled = true;
      this.drag(this.state.event.initialX, this.state.event.initialY, this.state.event.pageX, this.state.event.pageY);
      return true;
    }
    return false;
  }
  performHitTests() {
    const draggedItemType = this.getItemType();
    const event = this.getDragEvent();
    if (event && draggedItemType) {
      const targetIds = [];
      Object.keys(this.targets).forEach((targetId) => {
        const target = this.getTarget(targetId);
        if (target && matchesType(target.type, draggedItemType) && target.hitTest(event.x, event.y)) {
          targetIds.push(targetId);
        }
      });
      this.hover(targetIds);
    }
  }
  getSource(sourceId) {
    return sourceId ? this.sources[sourceId] : void 0;
  }
  getTarget(targetId) {
    return targetId ? this.targets[targetId] : void 0;
  }
};
var useDndManager = () => {
  const controller = useVisualizationController_default();
  const store = controller.getStore();
  let { dndManager } = store;
  if (!dndManager) {
    const state = controller.getState();
    let { dragDrop } = state;
    if (!dragDrop) {
      dragDrop = observable.object({});
      state.dragDrop = dragDrop;
    }
    dndManager = new DndManagerImpl(dragDrop);
    store.dndManager = dndManager;
  }
  return dndManager;
};

// node_modules/@patternfly/react-topology/dist/esm/components/ElementWrapper.js
var NodeElementComponent = observer2(({ element }) => {
  const dndManager = useDndManager();
  const isDragging = dndManager.isDragging();
  const dragItem = dndManager.getItem();
  const controller = element.hasController() && element.getController();
  const isVisible = React373.useMemo(() => computed(() => controller && controller.shouldRenderNode(element)), [element, controller]);
  if (isVisible.get() || isDragging && dragItem === element) {
    return React373.createElement(ElementComponent, { element });
  }
  return null;
});
var ElementComponent = observer2(({ element }) => {
  const kind = element.getKind();
  const type2 = element.getType();
  const controller = element.hasController() && element.getController();
  const Component50 = React373.useMemo(() => controller && controller.getComponent(kind, type2), [controller, kind, type2]);
  if (Component50) {
    return React373.createElement(
      ElementContext_default.Provider,
      { value: element },
      React373.createElement(Component50, Object.assign({}, element.getState(), { element }))
    );
  }
  return null;
});
var ElementChildren = observer2(({ element, level }) => React373.createElement(
  React373.Fragment,
  null,
  element.getChildren().filter(isEdge).map((e) => React373.createElement(ElementWrapper, { key: e.getId(), element: e })),
  element.getChildren().filter(isNode).map((e) => React373.createElement(ElementWrapper, { key: e.getId(), element: e, level }))
));
var ElementWrapper = observer2(({ element, level = 0 }) => {
  if (!element.isVisible()) {
    if (!isNode(element) || element.isDimensionsInitialized()) {
      return null;
    }
  }
  if (isEdge(element)) {
    const source = element.getSourceAnchorNode();
    const target = element.getTargetAnchorNode();
    if (source && !source.isVisible() || target && !target.isVisible()) {
      return null;
    }
  }
  const commonAttrs = {
    [ATTR_DATA_ID]: element.getId(),
    [ATTR_DATA_KIND]: element.getKind(),
    [ATTR_DATA_TYPE]: element.getType()
  };
  if (isGraph(element)) {
    return React373.createElement(
      "g",
      Object.assign({}, commonAttrs),
      React373.createElement(ElementComponent, { element })
    );
  }
  if (isNode(element)) {
    if (!element.isDimensionsInitialized()) {
      return React373.createElement(
        ComputeElementDimensions_default,
        { element },
        React373.createElement(ElementComponent, { element }),
        React373.createElement(ElementChildren, { element })
      );
    }
    if (!element.isGroup() || element.isCollapsed()) {
      const { x: x4, y: y4 } = element.getPosition();
      return React373.createElement(
        "g",
        Object.assign({}, commonAttrs, { transform: `translate(${x4}, ${y4})` }),
        React373.createElement(NodeElementComponent, { element }),
        React373.createElement(ElementChildren, { element })
      );
    }
    return React373.createElement(
      "g",
      Object.assign({}, commonAttrs),
      React373.createElement(NodeElementComponent, { element }),
      React373.createElement(ElementChildren, { element })
    );
  }
  return React373.createElement(
    "g",
    Object.assign({}, commonAttrs, { style: { zIndex: level } }),
    React373.createElement(ElementComponent, { element }),
    React373.createElement(ElementChildren, { element, level: level + 1 })
  );
});
var ElementWrapper_default = ElementWrapper;

// node_modules/@patternfly/react-topology/dist/esm/components/VisualizationSurface.js
var stopEvent = (e) => {
  e.preventDefault();
  e.stopPropagation();
};
var VisualizationSurface = ({ state }) => {
  const controller = useVisualizationController_default();
  const timerId = React374.useRef();
  const debounceMeasure = React374.useCallback((func, delay) => {
    return (contentRect) => {
      if (!timerId.current) {
        func(contentRect);
      }
      clearTimeout(timerId.current);
      timerId.current = setTimeout(() => func(contentRect), delay);
    };
  }, []);
  React374.useEffect(() => {
    state && controller.setState(state);
  }, [controller, state]);
  const onMeasure = React374.useMemo(() => debounceMeasure(action((contentRect) => {
    controller.getGraph().setDimensions(new Dimensions(contentRect.client.width, contentRect.client.height));
  }), 100), [controller, debounceMeasure]);
  React374.useEffect(() => () => clearTimeout(timerId.current), [onMeasure]);
  if (!controller.hasGraph()) {
    return null;
  }
  const graph = controller.getGraph();
  return React374.createElement(index_esm_default, { client: true, onResize: onMeasure }, ({ measureRef }) => (
    // render an outer div because react-measure doesn't seem to fire events properly on svg resize
    React374.createElement(
      "div",
      { "data-test-id": "topology", className: css2(import_topology_components3.default.topologyVisualizationSurface), ref: measureRef },
      React374.createElement(
        "svg",
        { className: css2(import_topology_components3.default.topologyVisualizationSurfaceSvg), onContextMenu: stopEvent },
        React374.createElement(
          SVGDefsProvider_default,
          null,
          React374.createElement(ElementWrapper_default, { element: graph })
        )
      )
    )
  ));
};
var VisualizationSurface_default = observer2(VisualizationSurface);

// node_modules/@patternfly/react-topology/dist/esm/components/DefaultCreateConnector.js
var React376 = __toESM(require_react());
var import_topology_components5 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/add-circle-o-icon.js
var AddCircleOIconConfig = {
  name: "AddCircleOIcon",
  height: 1024,
  width: 1024,
  svgPath: "M576,303 C576,294.715729 569.284271,288 561,288 L463,288 C454.715729,288 448,294.715729 448,303 L448,448 L303,448 C294.715729,448 288,454.715729 288,463 L288,561 C288,569.284271 294.715729,576 303,576 L448,576 L448,720.9 C447.983373,729.207373 454.6927,735.961429 463,736 L561,736 C569.3073,735.961429 576.016627,729.207373 576,720.9 L576,576 L721,576 C724.969024,576.026638 728.784638,574.468589 731.600595,571.671405 C734.416553,568.87422 736.000031,565.069113 736.000031,561.1 L736.000031,463.1 C736.016627,454.792627 729.3073,448.038571 721,448 L576,448 L576,303 Z M512,896 C300.2,896 128,723.9 128,512 C128,300.3 300.2,128 512,128 C723.8,128 896,300.2 896,512 C896,723.8 723.7,896 512,896 Z M512.1,0 C229.7,0 0,229.8 0,512 C0,794.2 229.8,1024 512.1,1024 C794.4,1024 1024,794.3 1024,512 C1024,229.7 794.4,0 512.1,0 Z",
  yOffset: 0,
  xOffset: 0
};
var AddCircleOIcon = createIcon2(AddCircleOIconConfig);
var add_circle_o_icon_default = AddCircleOIcon;

// node_modules/@patternfly/react-topology/dist/esm/components/edges/terminals/ConnectorArrow.js
var React375 = __toESM(require_react());
var import_topology_components4 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/dist/esm/components/edges/terminals/terminalUtils.js
var getConnectorStartPoint = (startPoint, endPoint, size) => {
  const length3 = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));
  if (!length3) {
    return [0, 0];
  }
  const ratio = (length3 - size) / length3;
  return [startPoint.x + (endPoint.x - startPoint.x) * ratio, startPoint.y + (endPoint.y - startPoint.y) * ratio];
};
var getConnectorRotationAngle = (startPoint, endPoint) => 180 - Math.atan2(endPoint.y - startPoint.y, startPoint.x - endPoint.x) * 180 / Math.PI;
var getConnectorBoundingBox = (startPoint, endPoint, size) => {
  const length3 = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));
  if (!length3) {
    return null;
  }
  const padding = Math.max(size, 8);
  const deltaY = padding / 2;
  return [
    [0, -deltaY],
    [padding, -deltaY],
    [padding, deltaY],
    [0, deltaY]
  ];
};

// node_modules/@patternfly/react-topology/dist/esm/components/edges/terminals/ConnectorArrow.js
var pointsStringFromPoints = (points) => {
  var _a2;
  return (_a2 = points === null || points === void 0 ? void 0 : points.reduce((result, nextPoint) => `${result} ${nextPoint[0]},${nextPoint[1]}`, "")) !== null && _a2 !== void 0 ? _a2 : "";
};
var ConnectorArrow = ({ startPoint, endPoint, className = "", size = 14, dragRef }) => {
  const polygonPoints = React375.useMemo(() => pointsStringFromPoints([
    [0, size / 2],
    [0, -size / 2],
    [size, 0]
  ]), [size]);
  const boundingPoints = React375.useMemo(() => {
    if (startPoint || !endPoint) {
      return null;
    }
    return pointsStringFromPoints(getConnectorBoundingBox(startPoint, endPoint, size));
  }, [endPoint, size, startPoint]);
  if (!startPoint || !endPoint) {
    return null;
  }
  const connectorStartPoint = getConnectorStartPoint(startPoint, endPoint, size);
  const angleDeg = getConnectorRotationAngle(startPoint, endPoint);
  const classNames = css2(import_topology_components4.default.topologyConnectorArrow, className, dragRef && "pf-m-draggable");
  return React375.createElement(
    "g",
    { transform: `translate(${connectorStartPoint[0]}, ${connectorStartPoint[1]}) rotate(${angleDeg})`, ref: dragRef, className: classNames },
    React375.createElement("polygon", { points: polygonPoints }),
    React375.createElement("polygon", { points: boundingPoints, fillOpacity: 0, strokeWidth: 0 })
  );
};
var ConnectorArrow_default = ConnectorArrow;

// node_modules/@patternfly/react-topology/dist/esm/components/DefaultCreateConnector.js
var cursorSize = 20;
var DefaultCreateConnector = ({ startPoint, endPoint, hints, dragging, hover, tipContents, className }) => {
  const iconRef = React376.useRef();
  const classes = css2(import_topology_components5.default.topologyDefaultCreateConnector, className, hover && import_topology_components5.default.modifiers.hover, dragging && import_topology_components5.default.modifiers.dragging);
  return React376.createElement(
    "g",
    { className: classes },
    React376.createElement("line", { className: css2(import_topology_components5.default.topologyDefaultCreateConnectorLine), x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }),
    hints && hints[hints.length - 1] === "create" ? React376.createElement(
      "g",
      { transform: `translate(${endPoint.x - cursorSize / 2},${endPoint.y - cursorSize / 2})`, className: css2(import_topology_components5.default.topologyDefaultCreateConnectorCreate) },
      React376.createElement("circle", { className: css2(import_topology_components5.default.topologyDefaultCreateConnectorCreateBg), cx: cursorSize / 2, cy: cursorSize / 2, r: cursorSize / 2 }),
      tipContents ? React376.createElement(
        Tooltip,
        { content: tipContents, trigger: "manual", isVisible: true, animationDuration: 0, entryDelay: 0, exitDelay: 0, triggerRef: iconRef },
        React376.createElement(add_circle_o_icon_default, { className: css2(import_topology_components5.default.topologyDefaultCreateConnectorCreateCursor), style: { fontSize: cursorSize }, ref: iconRef })
      ) : React376.createElement(add_circle_o_icon_default, { className: css2(import_topology_components5.default.topologyDefaultCreateConnectorCreateCursor), style: { fontSize: cursorSize } })
    ) : React376.createElement(ConnectorArrow_default, { className: css2(import_topology_components5.default.topologyDefaultCreateConnectorArrow), startPoint, endPoint })
  );
};
var DefaultCreateConnector_default = DefaultCreateConnector;

// node_modules/@patternfly/react-topology/dist/esm/components/DefaultRemoveConnector.js
var React377 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/trash-icon.js
var TrashIconConfig = {
  name: "TrashIcon",
  height: 512,
  width: 448,
  svgPath: "M432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zM53.2 467a48 48 0 0 0 47.9 45h245.8a48 48 0 0 0 47.9-45L416 128H32z",
  yOffset: 0,
  xOffset: 0
};
var TrashIcon = createIcon2(TrashIconConfig);
var trash_icon_default = TrashIcon;

// node_modules/@patternfly/react-topology/dist/esm/components/DefaultRemoveConnector.js
function computeTooltipPosition(startPoint, endPoint) {
  const angle2 = Math.abs(Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x) * 180 / Math.PI);
  if (angle2 < 135 && angle2 > 90) {
    return TooltipPosition.left;
  }
  if (angle2 > 45 && angle2 <= 90) {
    return TooltipPosition.right;
  }
  return TooltipPosition.top;
}
var DefaultRemoveConnector = ({ startPoint, endPoint, onRemove: onRemove2, size = 14 }) => {
  const DefaultRemoveConnectorRef = React377.useRef();
  return React377.createElement(
    Tooltip,
    { triggerRef: DefaultRemoveConnectorRef, content: "Delete Connector", position: computeTooltipPosition(startPoint, endPoint) },
    React377.createElement(
      "g",
      { transform: `translate(${startPoint.x + (endPoint.x - startPoint.x) * 0.5}, ${startPoint.y + (endPoint.y - startPoint.y) * 0.5})`, onClick: (e) => {
        e.stopPropagation();
        onRemove2();
      }, ref: DefaultRemoveConnectorRef },
      React377.createElement("circle", { className: "topology-connector__remove-bg", cx: 0, cy: 0, r: size }),
      React377.createElement(
        "g",
        { transform: `translate(-${size / 2}, -${size / 2})` },
        React377.createElement(trash_icon_default, { className: "topology-connector__remove-icon", style: { fontSize: size } })
      )
    )
  );
};
var DefaultRemoveConnector_default = DefaultRemoveConnector;

// node_modules/@patternfly/react-topology/dist/esm/components/GraphComponent.js
var React379 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/components/layers/LayersProvider.js
var React378 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/components/layers/LayersContext.js
var import_react48 = __toESM(require_react());
var LayersContext = (0, import_react48.createContext)(void 0);
var LayersContext_default = LayersContext;

// node_modules/@patternfly/react-topology/dist/esm/components/layers/LayersProvider.js
var LayersProvider = class extends React378.Component {
  constructor(props) {
    super(props);
    this.contextValue = (id2) => {
      if (this.state[id2]) {
        return this.state[id2];
      }
      throw new Error(`Unknown layer '${id2}'`);
    };
    this.setDomLayers = (node, id2) => {
      if (node && this.state[id2] !== node) {
        this.setState((state) => Object.assign(Object.assign({}, state), { [id2]: node }));
      }
    };
    this.getLayerNode = (id2) => {
      const node = this.state[id2];
      if (node) {
        return node;
      }
      throw new Error(`Unknown layer '${id2}'`);
    };
    this.state = {};
  }
  render() {
    const { layers, children: children2 } = this.props;
    if (layers && !layers.includes(DEFAULT_LAYER)) {
      throw new Error("Missing default layer.");
    }
    const layerIds = layers || [DEFAULT_LAYER];
    return React378.createElement(LayersContext_default.Provider, { value: this.contextValue }, layerIds.map((id2) => React378.createElement("g", { key: id2, "data-layer-id": id2, ref: (r) => this.setDomLayers(r, id2) }, id2 === DEFAULT_LAYER && this.state[id2] ? children2 : void 0)));
  }
};

// node_modules/@patternfly/react-topology/dist/esm/components/GraphComponent.js
var ElementChildren2 = observer2(({ element }) => React379.createElement(
  React379.Fragment,
  null,
  element.getEdges().map((e) => React379.createElement(ElementWrapper_default, { key: e.getId(), element: e })),
  element.getNodes().map((e) => React379.createElement(ElementWrapper_default, { key: e.getId(), element: e }))
));
var Inner = React379.memo(observer2(({ element }) => React379.createElement(
  LayersProvider,
  { layers: element.getLayers() },
  React379.createElement(ElementChildren2, { element })
)));
var GraphComponent = ({ element, panZoomRef, dndDropRef, onSelect, onContextMenu }) => {
  if (!isGraph(element)) {
    return null;
  }
  const graphElement = element;
  const { x: x4, y: y4, width, height } = graphElement.getBounds();
  return React379.createElement(
    React379.Fragment,
    null,
    React379.createElement("rect", { ref: dndDropRef, x: 0, y: 0, width, height, fillOpacity: 0, onClick: onSelect, onContextMenu }),
    React379.createElement(
      "g",
      { "data-surface": "true", ref: panZoomRef, transform: `translate(${x4}, ${y4}) scale(${graphElement.getScale()})` },
      React379.createElement(Inner, { element: graphElement })
    )
  );
};
var GraphComponent_default = observer2(GraphComponent);

// node_modules/@patternfly/react-topology/dist/esm/components/SVGArrowMarker.js
var React382 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/components/defs/SVGDefs.js
var React381 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/components/defs/SVGDefsSetter.js
var React380 = __toESM(require_react());
var SVGDefsSetter = class extends React380.Component {
  componentDidMount() {
    const { addDef, id: id2, children: children2 } = this.props;
    addDef(id2, children2);
  }
  componentDidUpdate() {
    const { addDef, id: id2, children: children2 } = this.props;
    addDef(id2, children2);
  }
  componentWillUnmount() {
    const { removeDef, id: id2 } = this.props;
    removeDef(id2);
  }
  render() {
    return null;
  }
};
SVGDefsSetter.displayName = "SVGDefsSetter";
SVGDefsSetter.contextType = SVGDefsContext_default;

// node_modules/@patternfly/react-topology/dist/esm/components/defs/SVGDefs.js
var SVGDefs = class extends React381.Component {
  shouldComponentUpdate() {
    return false;
  }
  render() {
    return React381.createElement(SVGDefsContext_default.Consumer, null, ({ addDef, removeDef }) => React381.createElement(SVGDefsSetter, Object.assign({}, this.props, { addDef, removeDef })));
  }
};

// node_modules/@patternfly/react-topology/dist/esm/components/SVGArrowMarker.js
var SVGArrowMarker = ({ id: id2, nodeSize, markerSize, className }) => React382.createElement(
  SVGDefs,
  { id: id2 },
  React382.createElement(
    "marker",
    { id: id2, markerWidth: markerSize, markerHeight: markerSize, refX: nodeSize / 2 + markerSize - 1, refY: markerSize / 2, orient: "auto", markerUnits: "userSpaceOnUse" },
    React382.createElement("path", { d: `M0,0 L0,${markerSize} L${markerSize},${markerSize / 2} z`, className })
  )
);
var SVGArrowMarker_default = SVGArrowMarker;

// node_modules/@patternfly/react-topology/dist/esm/components/contextmenu/ContextMenu.js
var React385 = __toESM(require_react());
var import_topology_components6 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/dist/esm/components/popper/Popper.js
var React384 = __toESM(require_react());

// node_modules/popper.js/dist/esm/popper.js
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
var timeoutDuration = function() {
  var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser2 && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();
function microtaskDebounce(fn) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function() {
      called = false;
      fn();
    });
  };
}
function taskDebounce(fn) {
  var scheduled = false;
  return function() {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function() {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}
var supportsMicroTasks = isBrowser2 && window.Promise;
var debounce3 = supportsMicroTasks ? microtaskDebounce : taskDebounce;
function isFunction2(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
}
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  var window2 = element.ownerDocument.defaultView;
  var css3 = window2.getComputedStyle(element, null);
  return property ? css3[property] : css3;
}
function getParentNode2(element) {
  if (element.nodeName === "HTML") {
    return element;
  }
  return element.parentNode || element.host;
}
function getScrollParent2(element) {
  if (!element) {
    return document.body;
  }
  switch (element.nodeName) {
    case "HTML":
    case "BODY":
      return element.ownerDocument.body;
    case "#document":
      return element.body;
  }
  var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }
  return getScrollParent2(getParentNode2(element));
}
function getReferenceNode(reference2) {
  return reference2 && reference2.referenceNode ? reference2.referenceNode : reference2;
}
var isIE11 = isBrowser2 && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser2 && /MSIE 10/.test(navigator.userAgent);
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}
function getOffsetParent2(element) {
  if (!element) {
    return document.documentElement;
  }
  var noOffsetParent = isIE(10) ? document.body : null;
  var offsetParent = element.offsetParent || null;
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }
  var nodeName = offsetParent && offsetParent.nodeName;
  if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }
  if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
    return getOffsetParent2(offsetParent);
  }
  return offsetParent;
}
function isOffsetContainer(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY") {
    return false;
  }
  return nodeName === "HTML" || getOffsetParent2(element.firstElementChild) === element;
}
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }
  return node;
}
function findCommonOffsetParent(element1, element2) {
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }
  var order2 = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start3 = order2 ? element1 : element2;
  var end2 = order2 ? element2 : element1;
  var range4 = document.createRange();
  range4.setStart(start3, 0);
  range4.setEnd(end2, 0);
  var commonAncestorContainer = range4.commonAncestorContainer;
  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start3.contains(end2)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }
    return getOffsetParent2(commonAncestorContainer);
  }
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
  var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    var html2 = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html2;
    return scrollingElement[upperSide];
  }
  return element[upperSide];
}
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var scrollTop = getScroll(element, "top");
  var scrollLeft = getScroll(element, "left");
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
function getBordersSize2(styles36, axis2) {
  var sideA = axis2 === "x" ? "Left" : "Top";
  var sideB = sideA === "Left" ? "Right" : "Bottom";
  return parseFloat(styles36["border" + sideA + "Width"]) + parseFloat(styles36["border" + sideB + "Width"]);
}
function getSize(axis2, body, html2, computedStyle) {
  return Math.max(body["offset" + axis2], body["scroll" + axis2], html2["client" + axis2], html2["offset" + axis2], html2["scroll" + axis2], isIE(10) ? parseInt(html2["offset" + axis2]) + parseInt(computedStyle["margin" + (axis2 === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis2 === "Height" ? "Bottom" : "Right")]) : 0);
}
function getWindowSizes(document2) {
  var body = document2.body;
  var html2 = document2.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html2);
  return {
    height: getSize("Height", body, html2, computedStyle),
    width: getSize("Width", body, html2, computedStyle)
  };
}
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var defineProperty3 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _extends4 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function getClientRect(offsets) {
  return _extends4({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
function getBoundingClientRect2(element) {
  var rect = {};
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, "top");
      var scrollLeft = getScroll(element, "left");
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {
  }
  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };
  var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;
  if (horizScrollbar || vertScrollbar) {
    var styles36 = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize2(styles36, "x");
    vertScrollbar -= getBordersSize2(styles36, "y");
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }
  return getClientRect(result);
}
function getOffsetRectRelativeToArbitraryNode(children2, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isIE102 = isIE(10);
  var isHTML = parent.nodeName === "HTML";
  var childrenRect = getBoundingClientRect2(children2);
  var parentRect = getBoundingClientRect2(parent);
  var scrollParent = getScrollParent2(children2);
  var styles36 = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles36.borderTopWidth);
  var borderLeftWidth = parseFloat(styles36.borderLeftWidth);
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;
  if (!isIE102 && isHTML) {
    var marginTop = parseFloat(styles36.marginTop);
    var marginLeft = parseFloat(styles36.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }
  if (isIE102 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
    offsets = includeScroll(offsets, parent);
  }
  return offsets;
}
function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var html2 = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html2);
  var width = Math.max(html2.clientWidth, window.innerWidth || 0);
  var height = Math.max(html2.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html2) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html2, "left") : 0;
  var offset3 = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width,
    height
  };
  return getClientRect(offset3);
}
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (getStyleComputedProperty(element, "position") === "fixed") {
    return true;
  }
  var parentNode = getParentNode2(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}
function getFixedPositionOffsetParent(element) {
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, "transform") === "none") {
    el = el.parentElement;
  }
  return el || document.documentElement;
}
function getBoundaries(popper2, reference2, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper2) : findCommonOffsetParent(popper2, getReferenceNode(reference2));
  if (boundariesElement === "viewport") {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    var boundariesNode = void 0;
    if (boundariesElement === "scrollParent") {
      boundariesNode = getScrollParent2(getParentNode2(reference2));
      if (boundariesNode.nodeName === "BODY") {
        boundariesNode = popper2.ownerDocument.documentElement;
      }
    } else if (boundariesElement === "window") {
      boundariesNode = popper2.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }
    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
    if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper2.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width;
      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      boundaries = offsets;
    }
  }
  padding = padding || 0;
  var isPaddingNumber = typeof padding === "number";
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}
function getArea(_ref) {
  var width = _ref.width, height = _ref.height;
  return width * height;
}
function computeAutoPlacement2(placement, refRect, popper2, reference2, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
  if (placement.indexOf("auto") === -1) {
    return placement;
  }
  var boundaries = getBoundaries(popper2, reference2, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function(key) {
    return _extends4({
      key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function(a4, b) {
    return b.area - a4.area;
  });
  var filteredAreas = sortedAreas.filter(function(_ref2) {
    var width = _ref2.width, height = _ref2.height;
    return width >= popper2.clientWidth && height >= popper2.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split("-")[1];
  return computedPlacement + (variation ? "-" + variation : "");
}
function getReferenceOffsets(state, popper2, reference2) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper2) : findCommonOffsetParent(popper2, getReferenceNode(reference2));
  return getOffsetRectRelativeToArbitraryNode(reference2, commonOffsetParent, fixedPosition);
}
function getOuterSizes(element) {
  var window2 = element.ownerDocument.defaultView;
  var styles36 = window2.getComputedStyle(element);
  var x4 = parseFloat(styles36.marginTop || 0) + parseFloat(styles36.marginBottom || 0);
  var y4 = parseFloat(styles36.marginLeft || 0) + parseFloat(styles36.marginRight || 0);
  var result = {
    width: element.offsetWidth + y4,
    height: element.offsetHeight + x4
  };
  return result;
}
function getOppositePlacement3(placement) {
  var hash4 = { left: "right", right: "left", bottom: "top", top: "bottom" };
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash4[matched];
  });
}
function getPopperOffsets(popper2, referenceOffsets, placement) {
  placement = placement.split("-")[0];
  var popperRect = getOuterSizes(popper2);
  var popperOffsets2 = {
    width: popperRect.width,
    height: popperRect.height
  };
  var isHoriz = ["right", "left"].indexOf(placement) !== -1;
  var mainSide = isHoriz ? "top" : "left";
  var secondarySide = isHoriz ? "left" : "top";
  var measurement = isHoriz ? "height" : "width";
  var secondaryMeasurement = !isHoriz ? "height" : "width";
  popperOffsets2[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets2[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets2[secondarySide] = referenceOffsets[getOppositePlacement3(secondarySide)];
  }
  return popperOffsets2;
}
function find(arr, check) {
  if (Array.prototype.find) {
    return arr.find(check);
  }
  return arr.filter(check)[0];
}
function findIndex(arr, prop, value) {
  if (Array.prototype.findIndex) {
    return arr.findIndex(function(cur) {
      return cur[prop] === value;
    });
  }
  var match = find(arr, function(obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
function runModifiers(modifiers2, data, ends) {
  var modifiersToRun = ends === void 0 ? modifiers2 : modifiers2.slice(0, findIndex(modifiers2, "name", ends));
  modifiersToRun.forEach(function(modifier) {
    if (modifier["function"]) {
      console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
    }
    var fn = modifier["function"] || modifier.fn;
    if (modifier.enabled && isFunction2(fn)) {
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
function update() {
  if (this.state.isDestroyed) {
    return;
  }
  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
  data.placement = computeAutoPlacement2(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed;
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
  data = runModifiers(this.modifiers, data);
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
function isModifierEnabled(modifiers2, modifierName) {
  return modifiers2.some(function(_ref) {
    var name = _ref.name, enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
function getSupportedPropertyName(property) {
  var prefixes2 = [false, "ms", "Webkit", "Moz", "O"];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
  for (var i = 0; i < prefixes2.length; i++) {
    var prefix = prefixes2[i];
    var toCheck = prefix ? "" + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== "undefined") {
      return toCheck;
    }
  }
  return null;
}
function destroy() {
  this.state.isDestroyed = true;
  if (isModifierEnabled(this.modifiers, "applyStyle")) {
    this.popper.removeAttribute("x-placement");
    this.popper.style.position = "";
    this.popper.style.top = "";
    this.popper.style.left = "";
    this.popper.style.right = "";
    this.popper.style.bottom = "";
    this.popper.style.willChange = "";
    this.popper.style[getSupportedPropertyName("transform")] = "";
  }
  this.disableEventListeners();
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}
function getWindow2(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}
function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === "BODY";
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });
  if (!isBody) {
    attachToScrollParents(getScrollParent2(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}
function setupEventListeners(reference2, options, state, updateBound) {
  state.updateBound = updateBound;
  getWindow2(reference2).addEventListener("resize", state.updateBound, { passive: true });
  var scrollElement = getScrollParent2(reference2);
  attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
function removeEventListeners(reference2, state) {
  getWindow2(reference2).removeEventListener("resize", state.updateBound);
  state.scrollParents.forEach(function(target) {
    target.removeEventListener("scroll", state.updateBound);
  });
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
function isNumeric(n) {
  return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
}
function setStyles(element, styles36) {
  Object.keys(styles36).forEach(function(prop) {
    var unit2 = "";
    if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric(styles36[prop])) {
      unit2 = "px";
    }
    element.style[prop] = styles36[prop] + unit2;
  });
}
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function(prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
function applyStyle(data) {
  setStyles(data.instance.popper, data.styles);
  setAttributes(data.instance.popper, data.attributes);
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }
  return data;
}
function applyStyleOnLoad(reference2, popper2, options, modifierOptions, state) {
  var referenceOffsets = getReferenceOffsets(state, popper2, reference2, options.positionFixed);
  var placement = computeAutoPlacement2(options.placement, referenceOffsets, popper2, reference2, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper2.setAttribute("x-placement", placement);
  setStyles(popper2, { position: options.positionFixed ? "fixed" : "absolute" });
  return options;
}
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference2 = _data$offsets.reference;
  var round = Math.round, floor = Math.floor;
  var noRound = function noRound2(v2) {
    return v2;
  };
  var referenceWidth = round(reference2.width);
  var popperWidth = round(popper2.width);
  var isVertical = ["left", "right"].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf("-") !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper2.left - 1 : popper2.left),
    top: verticalToInteger(popper2.top),
    bottom: verticalToInteger(popper2.bottom),
    right: horizontalToInteger(popper2.right)
  };
}
var isFirefox = isBrowser2 && /Firefox/i.test(navigator.userAgent);
function computeStyle(data, options) {
  var x4 = options.x, y4 = options.y;
  var popper2 = data.offsets.popper;
  var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
    return modifier.name === "applyStyle";
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== void 0) {
    console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== void 0 ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent2(data.instance.popper);
  var offsetParentRect = getBoundingClientRect2(offsetParent);
  var styles36 = {
    position: popper2.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x4 === "bottom" ? "top" : "bottom";
  var sideB = y4 === "right" ? "left" : "right";
  var prefixedProperty = getSupportedPropertyName("transform");
  var left3 = void 0, top3 = void 0;
  if (sideA === "bottom") {
    if (offsetParent.nodeName === "HTML") {
      top3 = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top3 = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top3 = offsets.top;
  }
  if (sideB === "right") {
    if (offsetParent.nodeName === "HTML") {
      left3 = -offsetParent.clientWidth + offsets.right;
    } else {
      left3 = -offsetParentRect.width + offsets.right;
    }
  } else {
    left3 = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles36[prefixedProperty] = "translate3d(" + left3 + "px, " + top3 + "px, 0)";
    styles36[sideA] = 0;
    styles36[sideB] = 0;
    styles36.willChange = "transform";
  } else {
    var invertTop = sideA === "bottom" ? -1 : 1;
    var invertLeft = sideB === "right" ? -1 : 1;
    styles36[sideA] = top3 * invertTop;
    styles36[sideB] = left3 * invertLeft;
    styles36.willChange = sideA + ", " + sideB;
  }
  var attributes = {
    "x-placement": data.placement
  };
  data.attributes = _extends4({}, attributes, data.attributes);
  data.styles = _extends4({}, styles36, data.styles);
  data.arrowStyles = _extends4({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
function isModifierRequired(modifiers2, requestingName, requestedName) {
  var requesting = find(modifiers2, function(_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers2.some(function(modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });
  if (!isRequired) {
    var _requesting = "`" + requestingName + "`";
    var requested = "`" + requestedName + "`";
    console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
  }
  return isRequired;
}
function arrow2(data, options) {
  var _data$offsets$arrow;
  if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
    return data;
  }
  var arrowElement = options.element;
  if (typeof arrowElement === "string") {
    arrowElement = data.instance.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return data;
    }
  } else {
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn("WARNING: `arrow.element` must be child of its popper element!");
      return data;
    }
  }
  var placement = data.placement.split("-")[0];
  var _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference2 = _data$offsets.reference;
  var isVertical = ["left", "right"].indexOf(placement) !== -1;
  var len = isVertical ? "height" : "width";
  var sideCapitalized = isVertical ? "Top" : "Left";
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? "left" : "top";
  var opSide = isVertical ? "bottom" : "right";
  var arrowElementSize = getOuterSizes(arrowElement)[len];
  if (reference2[opSide] - arrowElementSize < popper2[side]) {
    data.offsets.popper[side] -= popper2[side] - (reference2[opSide] - arrowElementSize);
  }
  if (reference2[side] + arrowElementSize > popper2[opSide]) {
    data.offsets.popper[side] += reference2[side] + arrowElementSize - popper2[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);
  var center2 = reference2[side] + reference2[len] / 2 - arrowElementSize / 2;
  var css3 = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css3["margin" + sideCapitalized]);
  var popperBorderSide = parseFloat(css3["border" + sideCapitalized + "Width"]);
  var sideValue = center2 - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
  sideValue = Math.max(Math.min(popper2[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty3(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty3(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
  return data;
}
function getOppositeVariation(variation) {
  if (variation === "end") {
    return "start";
  } else if (variation === "start") {
    return "end";
  }
  return variation;
}
var placements2 = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
var validPlacements = placements2.slice(3);
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var index4 = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index4 + 1).concat(validPlacements.slice(0, index4));
  return counter ? arr.reverse() : arr;
}
var BEHAVIORS = {
  FLIP: "flip",
  CLOCKWISE: "clockwise",
  COUNTERCLOCKWISE: "counterclockwise"
};
function flip2(data, options) {
  if (isModifierEnabled(data.instance.modifiers, "inner")) {
    return data;
  }
  if (data.flipped && data.placement === data.originalPlacement) {
    return data;
  }
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split("-")[0];
  var placementOpposite = getOppositePlacement3(placement);
  var variation = data.placement.split("-")[1] || "";
  var flipOrder = [];
  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }
  flipOrder.forEach(function(step, index4) {
    if (placement !== step || flipOrder.length === index4 + 1) {
      return data;
    }
    placement = data.placement.split("-")[0];
    placementOpposite = getOppositePlacement3(placement);
    var popperOffsets2 = data.offsets.popper;
    var refOffsets = data.offsets.reference;
    var floor = Math.floor;
    var overlapsRef = placement === "left" && floor(popperOffsets2.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets2.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets2.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets2.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets2.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets2.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets2.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets2.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
    var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      data.flipped = true;
      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index4 + 1];
      }
      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }
      data.placement = placement + (variation ? "-" + variation : "");
      data.offsets.popper = _extends4({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, "flip");
    }
  });
  return data;
}
function keepTogether(data) {
  var _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference2 = _data$offsets.reference;
  var placement = data.placement.split("-")[0];
  var floor = Math.floor;
  var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
  var side = isVertical ? "right" : "bottom";
  var opSide = isVertical ? "left" : "top";
  var measurement = isVertical ? "width" : "height";
  if (popper2[side] < floor(reference2[opSide])) {
    data.offsets.popper[opSide] = floor(reference2[opSide]) - popper2[measurement];
  }
  if (popper2[opSide] > floor(reference2[side])) {
    data.offsets.popper[opSide] = floor(reference2[side]);
  }
  return data;
}
function toValue(str, measurement, popperOffsets2, referenceOffsets) {
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit2 = split[2];
  if (!value) {
    return str;
  }
  if (unit2.indexOf("%") === 0) {
    var element = void 0;
    switch (unit2) {
      case "%p":
        element = popperOffsets2;
        break;
      case "%":
      case "%r":
      default:
        element = referenceOffsets;
    }
    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit2 === "vh" || unit2 === "vw") {
    var size = void 0;
    if (unit2 === "vh") {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    return value;
  }
}
function parseOffset(offset3, popperOffsets2, referenceOffsets, basePlacement) {
  var offsets = [0, 0];
  var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
  var fragments = offset3.split(/(\+|\-)/).map(function(frag) {
    return frag.trim();
  });
  var divider = fragments.indexOf(find(fragments, function(frag) {
    return frag.search(/,|\s/) !== -1;
  }));
  if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
    console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
  }
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
  ops = ops.map(function(op, index4) {
    var measurement = (index4 === 1 ? !useHeight : useHeight) ? "height" : "width";
    var mergeWithPrevious = false;
    return op.reduce(function(a4, b) {
      if (a4[a4.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
        a4[a4.length - 1] = b;
        mergeWithPrevious = true;
        return a4;
      } else if (mergeWithPrevious) {
        a4[a4.length - 1] += b;
        mergeWithPrevious = false;
        return a4;
      } else {
        return a4.concat(b);
      }
    }, []).map(function(str) {
      return toValue(str, measurement, popperOffsets2, referenceOffsets);
    });
  });
  ops.forEach(function(op, index4) {
    op.forEach(function(frag, index22) {
      if (isNumeric(frag)) {
        offsets[index4] += frag * (op[index22 - 1] === "-" ? -1 : 1);
      }
    });
  });
  return offsets;
}
function offset2(data, _ref) {
  var offset3 = _ref.offset;
  var placement = data.placement, _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference2 = _data$offsets.reference;
  var basePlacement = placement.split("-")[0];
  var offsets = void 0;
  if (isNumeric(+offset3)) {
    offsets = [+offset3, 0];
  } else {
    offsets = parseOffset(offset3, popper2, reference2, basePlacement);
  }
  if (basePlacement === "left") {
    popper2.top += offsets[0];
    popper2.left -= offsets[1];
  } else if (basePlacement === "right") {
    popper2.top += offsets[0];
    popper2.left += offsets[1];
  } else if (basePlacement === "top") {
    popper2.left += offsets[0];
    popper2.top -= offsets[1];
  } else if (basePlacement === "bottom") {
    popper2.left += offsets[0];
    popper2.top += offsets[1];
  }
  data.popper = popper2;
  return data;
}
function preventOverflow2(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent2(data.instance.popper);
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent2(boundariesElement);
  }
  var transformProp = getSupportedPropertyName("transform");
  var popperStyles = data.instance.popper.style;
  var top3 = popperStyles.top, left3 = popperStyles.left, transform2 = popperStyles[transformProp];
  popperStyles.top = "";
  popperStyles.left = "";
  popperStyles[transformProp] = "";
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
  popperStyles.top = top3;
  popperStyles.left = left3;
  popperStyles[transformProp] = transform2;
  options.boundaries = boundaries;
  var order2 = options.priority;
  var popper2 = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper2[placement];
      if (popper2[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper2[placement], boundaries[placement]);
      }
      return defineProperty3({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === "right" ? "left" : "top";
      var value = popper2[mainSide];
      if (popper2[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper2[mainSide], boundaries[placement] - (placement === "right" ? popper2.width : popper2.height));
      }
      return defineProperty3({}, mainSide, value);
    }
  };
  order2.forEach(function(placement) {
    var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
    popper2 = _extends4({}, popper2, check[side](placement));
  });
  data.offsets.popper = popper2;
  return data;
}
function shift2(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var shiftvariation = placement.split("-")[1];
  if (shiftvariation) {
    var _data$offsets = data.offsets, reference2 = _data$offsets.reference, popper2 = _data$offsets.popper;
    var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
    var side = isVertical ? "left" : "top";
    var measurement = isVertical ? "width" : "height";
    var shiftOffsets = {
      start: defineProperty3({}, side, reference2[side]),
      end: defineProperty3({}, side, reference2[side] + reference2[measurement] - popper2[measurement])
    };
    data.offsets.popper = _extends4({}, popper2, shiftOffsets[shiftvariation]);
  }
  return data;
}
function hide2(data) {
  if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
    return data;
  }
  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function(modifier) {
    return modifier.name === "preventOverflow";
  }).boundaries;
  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    if (data.hide === true) {
      return data;
    }
    data.hide = true;
    data.attributes["x-out-of-boundaries"] = "";
  } else {
    if (data.hide === false) {
      return data;
    }
    data.hide = false;
    data.attributes["x-out-of-boundaries"] = false;
  }
  return data;
}
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var _data$offsets = data.offsets, popper2 = _data$offsets.popper, reference2 = _data$offsets.reference;
  var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
  var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
  popper2[isHoriz ? "left" : "top"] = reference2[basePlacement] - (subtractLength ? popper2[isHoriz ? "width" : "height"] : 0);
  data.placement = getOppositePlacement3(placement);
  data.offsets.popper = getClientRect(popper2);
  return data;
}
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift2
  },
  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset2,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },
  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" â€” or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow2,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ["left", "right", "top", "bottom"],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: "scrollParent"
  },
  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },
  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow2,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: "[x-arrow]"
  },
  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip2,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: "flip",
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: "viewport",
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },
  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },
  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide2
  },
  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: "bottom",
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: "right"
  },
  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: void 0
  }
};
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: "bottom",
  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,
  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,
  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,
  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {
  },
  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {
  },
  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers
};
var Popper2 = function() {
  function Popper4(reference2, popper2) {
    var _this = this;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    classCallCheck(this, Popper4);
    this.scheduleUpdate = function() {
      return requestAnimationFrame(_this.update);
    };
    this.update = debounce3(this.update.bind(this));
    this.options = _extends4({}, Popper4.Defaults, options);
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };
    this.reference = reference2 && reference2.jquery ? reference2[0] : reference2;
    this.popper = popper2 && popper2.jquery ? popper2[0] : popper2;
    this.options.modifiers = {};
    Object.keys(_extends4({}, Popper4.Defaults.modifiers, options.modifiers)).forEach(function(name) {
      _this.options.modifiers[name] = _extends4({}, Popper4.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });
    this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
      return _extends4({
        name
      }, _this.options.modifiers[name]);
    }).sort(function(a4, b) {
      return a4.order - b.order;
    });
    this.modifiers.forEach(function(modifierOptions) {
      if (modifierOptions.enabled && isFunction2(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });
    this.update();
    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      this.enableEventListeners();
    }
    this.state.eventsEnabled = eventsEnabled;
  }
  createClass(Popper4, [{
    key: "update",
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: "destroy",
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: "enableEventListeners",
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: "disableEventListeners",
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */
  }]);
  return Popper4;
}();
Popper2.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
Popper2.placements = placements2;
Popper2.Defaults = Defaults;
var popper_default = Popper2;

// node_modules/@patternfly/react-topology/dist/esm/components/popper/Portal.js
var React383 = __toESM(require_react());
var ReactDOM8 = __toESM(require_react_dom());
var getContainer = (container) => typeof container === "function" ? container() : container;
var Portal = ({ children: children2, container }) => {
  const [containerNode, setContainerNode] = React383.useState();
  useIsomorphicLayoutEffect(() => {
    setContainerNode(getContainer(container) || document.body);
  }, [container]);
  return containerNode ? ReactDOM8.createPortal(children2, containerNode) : null;
};
var Portal_default = Portal;

// node_modules/@patternfly/react-topology/dist/esm/components/popper/Popper.js
var VirtualReference = class {
  constructor({ height = 0, width = 0, x: x4, y: y4 }) {
    this.rect = {
      bottom: y4 + height,
      height,
      left: x4,
      right: x4 + width,
      top: y4,
      width,
      x: x4,
      y: y4,
      toJSON: () => {
      }
    };
  }
  getBoundingClientRect() {
    return this.rect;
  }
  get clientWidth() {
    return this.rect.width || 0;
  }
  get clientHeight() {
    return this.rect.height || 0;
  }
};
var getReference = (reference2) => "getBoundingClientRect" in reference2 ? reference2 : new VirtualReference(reference2);
var DEFAULT_POPPER_OPTIONS = {};
var Popper3 = ({ children: children2, container, className, open, placement = "bottom-start", reference: reference2, popperOptions = DEFAULT_POPPER_OPTIONS, closeOnEsc, closeOnOutsideClick, onRequestClose, popperRef: popperRefIn, zIndex = 9999, returnFocus }) => {
  const controlled = typeof open === "boolean";
  const openProp = controlled ? open || false : true;
  const nodeRef = React384.useRef();
  const popperRef = React384.useRef(null);
  const popperRefs = useCombineRefs_default(popperRef, popperRefIn);
  const [isOpen, setOpenState] = React384.useState(openProp);
  const focusRef = React384.useRef();
  const onRequestCloseRef = React384.useRef(onRequestClose);
  onRequestCloseRef.current = onRequestClose;
  const setOpen = React384.useCallback((newOpen) => {
    if (returnFocus && newOpen !== isOpen) {
      if (newOpen) {
        if (document.activeElement) {
          focusRef.current = document.activeElement;
        }
      } else if (focusRef.current instanceof HTMLElement && focusRef.current.ownerDocument) {
        focusRef.current.focus();
      }
    }
    setOpenState(newOpen);
  }, [returnFocus, isOpen]);
  React384.useEffect(() => {
    setOpen(openProp);
  }, [openProp, setOpen]);
  const onKeyDown = React384.useCallback((e) => {
    if (e.key === "Escape") {
      controlled ? onRequestCloseRef.current && onRequestCloseRef.current() : setOpen(false);
    }
  }, [controlled, setOpen]);
  const onClickOutside = React384.useCallback((e) => {
    if (!nodeRef.current || e.target instanceof Node && !nodeRef.current.contains(e.target)) {
      controlled ? onRequestCloseRef.current && onRequestCloseRef.current(e) : setOpen(false);
    }
  }, [controlled, setOpen]);
  const destroy2 = React384.useCallback(() => {
    if (popperRef.current) {
      popperRef.current.destroy();
      popperRefs(null);
      document.removeEventListener("keydown", onKeyDown, true);
      document.removeEventListener("mousedown", onClickOutside, true);
      document.removeEventListener("touchstart", onClickOutside, true);
    }
  }, [onClickOutside, onKeyDown, popperRefs]);
  const initialize = React384.useCallback(() => {
    if (!nodeRef.current || !reference2 || !isOpen) {
      return;
    }
    destroy2();
    popperRefs(new popper_default(getReference(typeof reference2 === "function" ? reference2() : reference2), nodeRef.current, Object.assign(Object.assign({ placement }, popperOptions), { modifiers: Object.assign({ preventOverflow: {
      boundariesElement: "viewport"
    } }, popperOptions.modifiers) })));
    if (closeOnEsc) {
      document.addEventListener("keydown", onKeyDown, true);
    }
    if (closeOnOutsideClick) {
      document.addEventListener("mousedown", onClickOutside, true);
      document.addEventListener("touchstart", onClickOutside, true);
    }
  }, [
    popperRefs,
    reference2,
    isOpen,
    destroy2,
    placement,
    popperOptions,
    closeOnEsc,
    closeOnOutsideClick,
    onKeyDown,
    onClickOutside
  ]);
  const nodeRefCallback = React384.useCallback((node) => {
    nodeRef.current = node;
    initialize();
  }, [initialize]);
  React384.useEffect(() => {
    initialize();
  }, [initialize]);
  React384.useEffect(() => () => {
    destroy2();
  }, [destroy2]);
  React384.useEffect(() => {
    if (!isOpen) {
      destroy2();
    }
  }, [destroy2, isOpen]);
  return isOpen ? React384.createElement(
    Portal_default,
    { container },
    React384.createElement("div", { ref: nodeRefCallback, className, style: { zIndex } }, children2)
  ) : null;
};
var Popper_default = Popper3;

// node_modules/@patternfly/react-topology/dist/esm/components/contextmenu/ContextMenu.js
var ContextMenu = (_a2) => {
  var { children: children2, open = true, onRequestClose } = _a2, other = __rest(_a2, ["children", "open", "onRequestClose"]);
  const [isOpen, setOpen] = React385.useState(!!open);
  React385.useEffect(() => {
    setOpen(open);
  }, [open]);
  const handleOnRequestClose = React385.useCallback(() => {
    onRequestClose ? onRequestClose() : setOpen(false);
  }, [onRequestClose]);
  return React385.createElement(
    Popper_default,
    Object.assign({}, other, { closeOnEsc: true, closeOnOutsideClick: true, open: isOpen, onRequestClose: handleOnRequestClose }),
    React385.createElement(Dropdown, { onSelect: handleOnRequestClose, toggle: () => React385.createElement(React385.Fragment, null), className: css2(import_topology_components6.default.topologyContextMenuCDropdownMenu) }, children2)
  );
};
var ContextMenu_default = ContextMenu;

// node_modules/@patternfly/react-topology/dist/esm/components/contextmenu/ContextSubMenuItem.js
var React386 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/angle-right-icon.js
var AngleRightIconConfig2 = {
  name: "AngleRightIcon",
  height: 512,
  width: 256,
  svgPath: "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z",
  yOffset: 0,
  xOffset: 0
};
var AngleRightIcon2 = createIcon2(AngleRightIconConfig2);
var angle_right_icon_default2 = AngleRightIcon2;

// node_modules/@patternfly/react-topology/dist/esm/components/contextmenu/ContextSubMenuItem.js
var import_topology_components7 = __toESM(require_topology_components());
var ContextSubMenuItem = (_a2) => {
  var { label, children: children2 } = _a2, other = __rest(_a2, ["label", "children"]);
  const nodeRef = React386.useRef(null);
  const subMenuRef = React386.useRef(null);
  const [open, setOpen] = React386.useState(false);
  const referenceCb = React386.useCallback(() => nodeRef.current || { x: 0, y: 0 }, []);
  return React386.createElement(
    React386.Fragment,
    null,
    React386.createElement(
      DropdownItem,
      Object.assign({}, other, {
        className: css2(import_topology_components7.default.topologyContextSubMenu),
        ref: nodeRef,
        // prevent this DropdownItem from executing like a normal action item
        onClick: (e) => e.stopPropagation(),
        // mouse enter will open the sub menu
        onMouseEnter: () => setOpen(true),
        onMouseLeave: (e) => {
          if (!subMenuRef.current || !subMenuRef.current.contains(e.relatedTarget)) {
            setOpen(false);
          }
        },
        onKeyDown: (e) => {
          if (e.key === "ArrowRight" || e.key === "Enter") {
            setOpen(true);
            e.stopPropagation();
          }
        }
      }),
      label,
      React386.createElement(angle_right_icon_default2, { className: css2(import_topology_components7.default.topologyContextSubMenuArrow) })
    ),
    React386.createElement(
      Popper_default,
      {
        open,
        placement: "right-start",
        closeOnEsc: true,
        closeOnOutsideClick: true,
        onRequestClose: (e) => {
          if (!e || !nodeRef.current || !nodeRef.current.contains(e.target)) {
            setOpen(false);
          }
        },
        reference: referenceCb,
        // use the parent node to capture the li
        container: nodeRef.current ? nodeRef.current.parentElement : nodeRef.current,
        returnFocus: true
      },
      React386.createElement(
        "div",
        { ref: subMenuRef, role: "presentation", className: "pf-v6-c-dropdown pf-m-expanded", onMouseLeave: (e) => {
          if (!nodeRef.current || !nodeRef.current.contains(e.relatedTarget)) {
            setOpen(false);
          }
        }, onKeyDown: (e) => {
          if (e.key === "ArrowLeft") {
            setOpen(false);
            e.stopPropagation();
          }
        } },
        React386.createElement(Dropdown, { toggle: () => React386.createElement(React386.Fragment, null), className: css2(import_topology_components7.default.topologyContextMenuCDropdownMenu) }, children2)
      )
    )
  );
};
var ContextSubMenuItem_default = ContextSubMenuItem;

// node_modules/@patternfly/react-topology/dist/esm/components/decorators/Decorator.js
var React418 = __toESM(require_react());
var import_topology_components20 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/dist/esm/components/svg/SvgDropShadowFilter.js
var React387 = __toESM(require_react());
var import_color_black = __toESM(require_color_black());
var SvgDropShadowFilter = ({ id: id2, dx = 0, dy = 1, stdDeviation = 2, floodColor = import_color_black.color_black.value, floodOpacity = 0.2 }) => {
  if (navigator.userAgent.includes("Edge")) {
    return React387.createElement(
      SVGDefs,
      { id: id2 },
      React387.createElement(
        "filter",
        { id: id2, x: `-${stdDeviation * 12.5}%`, y: `-${stdDeviation * 12.5}%`, width: `${100 + stdDeviation * 25}%`, height: `${100 + stdDeviation * 25}%` },
        React387.createElement("feGaussianBlur", { in: "SourceAlpha", stdDeviation }),
        React387.createElement("feOffset", { dx, dy, result: "offsetblur" }),
        React387.createElement("feFlood", { floodColor, floodOpacity }),
        React387.createElement("feComposite", { in2: "offsetblur", operator: "in" }),
        React387.createElement(
          "feMerge",
          null,
          React387.createElement("feMergeNode", null),
          React387.createElement("feMergeNode", { in: "SourceGraphic" })
        )
      )
    );
  }
  return React387.createElement(
    SVGDefs,
    { id: id2 },
    React387.createElement(
      "filter",
      { id: id2, x: `-${stdDeviation * 12.5}%`, y: `-${stdDeviation * 12.5}%`, width: `${100 + stdDeviation * 25}%`, height: `${100 + stdDeviation * 25}%` },
      React387.createElement("feDropShadow", { dx, dy, stdDeviation, floodColor, floodOpacity })
    )
  );
};
var SvgDropShadowFilter_default = SvgDropShadowFilter;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/DefaultNode.js
var React417 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/check-circle-icon.js
var CheckCircleIconConfig2 = {
  name: "CheckCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z",
  yOffset: 0,
  xOffset: 0
};
var CheckCircleIcon2 = createIcon2(CheckCircleIconConfig2);
var check_circle_icon_default2 = CheckCircleIcon2;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/exclamation-circle-icon.js
var ExclamationCircleIconConfig2 = {
  name: "ExclamationCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z",
  yOffset: 0,
  xOffset: 0
};
var ExclamationCircleIcon2 = createIcon2(ExclamationCircleIconConfig2);
var exclamation_circle_icon_default2 = ExclamationCircleIcon2;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/exclamation-triangle-icon.js
var ExclamationTriangleIconConfig2 = {
  name: "ExclamationTriangleIcon",
  height: 512,
  width: 576,
  svgPath: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z",
  yOffset: 0,
  xOffset: 0
};
var ExclamationTriangleIcon2 = createIcon2(ExclamationTriangleIconConfig2);
var exclamation_triangle_icon_default2 = ExclamationTriangleIcon2;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/DefaultNode.js
var import_topology_components19 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/dist/esm/components/layers/Layer.js
var React389 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/@patternfly/react-topology/dist/esm/components/layers/LayerContainer.js
var React388 = __toESM(require_react());
var LayerContainer = ({ children: children2 }, ref) => {
  const element = React388.useContext(ElementContext_default);
  let p = element;
  let x4 = 0;
  let y4 = 0;
  while (isNode(p)) {
    if (!p.isGroup() || p.isCollapsed()) {
      const { x: px, y: py } = p.getPosition();
      x4 += px;
      y4 += py;
    }
    p = p.getParent();
  }
  const commonAttrs = {
    [ATTR_DATA_ID]: element.getId(),
    [ATTR_DATA_KIND]: element.getKind(),
    [ATTR_DATA_TYPE]: element.getType()
  };
  return React388.createElement("g", Object.assign({ ref, transform: `translate(${x4}, ${y4})` }, commonAttrs), children2);
};
var LayerContainer_default = observer2(React388.forwardRef(LayerContainer));

// node_modules/@patternfly/react-topology/dist/esm/components/layers/Layer.js
var ORDER_KEY = "__order__";
var compare = (a4, b) => {
  if (a4 === b) {
    return 0;
  }
  const ao = a4[ORDER_KEY];
  const bo = b[ORDER_KEY];
  if (ao == null || bo == null) {
    return 0;
  }
  for (let i = 0; i < ao.length; i++) {
    if (ao[i] !== bo[i]) {
      return ao[i] - bo[i];
    }
  }
  return ao.length === bo.length ? 0 : ao.length - bo.length;
};
var LayerDelegate = observer2(({ id: id2, children: children2, orderKey }) => {
  const getLayerNode = React389.useContext(LayersContext_default);
  const layerNode = getLayerNode(id2);
  const element = React389.useContext(ElementContext_default);
  const nodeRef = React389.useRef(null);
  let order2;
  if (id2 && orderKey == null) {
    order2 = element.getOrderKey();
  } else if (id2) {
    order2 = orderKey;
  }
  React389.useEffect(() => {
    if (nodeRef.current && layerNode != null) {
      nodeRef.current[ORDER_KEY] = order2;
      const { childNodes } = layerNode;
      for (let i = 0; i < childNodes.length; i++) {
        const result = compare(nodeRef.current, childNodes[i]);
        if (result < 0) {
          if (i > 0 && childNodes[i - 1] !== nodeRef.current) {
            layerNode.insertBefore(nodeRef.current, childNodes[i]);
          }
          return;
        }
      }
      if (childNodes[childNodes.length - 1] !== nodeRef.current) {
        layerNode.appendChild(nodeRef.current);
      }
    }
  }, [order2, layerNode]);
  return (0, import_react_dom2.createPortal)(React389.createElement(LayerContainer_default, { ref: nodeRef }, children2), layerNode);
});
var Layer = ({ id: id2, children: children2, orderKey }) => id2 ? React389.createElement(LayerDelegate, { id: id2, orderKey }, children2) : React389.createElement(React389.Fragment, null, children2);
var Layer_default = Layer;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/labels/NodeLabel.js
var React395 = __toESM(require_react());
var import_topology_components11 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/dist/esm/utils/truncate-middle.js
var DEFAULT_OPTIONS2 = {
  length: 20,
  truncateEnd: false,
  omission: "â€¦",
  minTruncateChars: 3
};
var truncateMiddle = (text, options = {}) => {
  const { length: length3, truncateEnd, omission, minTruncateChars } = Object.assign(Object.assign({}, DEFAULT_OPTIONS2), options);
  if (!text) {
    return text;
  }
  if (text.length <= length3 + minTruncateChars) {
    return text;
  }
  if (length3 <= omission.length) {
    return omission;
  }
  if (truncateEnd) {
    return `${text.substr(0, length3 - 1)}${omission}`;
  }
  const startLength = Math.ceil((length3 - omission.length) / 2);
  const endLength = length3 - startLength - omission.length;
  const startFragment = text.substr(0, startLength);
  const endFragment = text.substr(text.length - endLength);
  return `${startFragment}${omission}${endFragment}`;
};

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/NodeShadows.js
var React390 = __toESM(require_react());
var NODE_SHADOW_FILTER_ID = "NodeShadowsFilterId";
var NODE_SHADOW_FILTER_ID_HOVER = "NodeShadowsFilterId--hover";
var NODE_SHADOW_FILTER_ID_DANGER = "NodeShadowsFilterId--danger";
var NodeShadows = () => React390.createElement(
  React390.Fragment,
  null,
  React390.createElement(SvgDropShadowFilter_default, { id: NODE_SHADOW_FILTER_ID }),
  React390.createElement(SvgDropShadowFilter_default, { id: NODE_SHADOW_FILTER_ID_HOVER, dx: 0, dy: 3, stdDeviation: 2, floodOpacity: 0.2 }),
  React390.createElement(SvgDropShadowFilter_default, { id: NODE_SHADOW_FILTER_ID_DANGER, dx: 0, dy: 0, stdDeviation: 4, floodColor: "#DB0000", floodOpacity: 0.5 })
);
var NodeShadows_default = NodeShadows;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/labels/LabelBadge.js
var React391 = __toESM(require_react());
var import_color_blue_10 = __toESM(require_color_blue_10());
var import_color_blue_30 = __toESM(require_color_blue_30());
var import_color_blue_302 = __toESM(require_color_blue_30());
var import_topology_components8 = __toESM(require_topology_components());
var LabelBadge = React391.forwardRef(({ badge, badgeTextColor, badgeColor, badgeBorderColor, badgeClassName, className, x: x4, y: y4, innerRef }, iconRef) => {
  const [textSize, textRef] = useSize([]);
  const classes = css2(import_topology_components8.default.topologyNodeLabelBadge, badgeClassName && badgeClassName, className && className);
  let rect = null;
  let paddingX = 0;
  let paddingY = 0;
  let width = 0;
  let height = 0;
  if (textSize) {
    ({ height, width } = textSize);
    paddingX = height / 2;
    paddingY = height / 14;
    height += paddingY * 2;
    rect = React391.createElement("rect", { fill: badgeColor || (badgeClassName ? void 0 : import_color_blue_10.color_blue_10.value), stroke: badgeBorderColor || (badgeClassName ? void 0 : import_color_blue_30.color_blue_30.value), ref: iconRef, x: 0, width: width + paddingX * 2, y: 0, height, rx: height / 2, ry: height / 2 });
  }
  return React391.createElement(
    "g",
    { className: classes, transform: `translate(${x4}, ${y4})`, ref: innerRef },
    rect,
    React391.createElement("text", { fill: badgeTextColor || badgeClassName ? badgeTextColor : import_color_blue_302.color_blue_30.value, ref: textRef, x: width / 2 + paddingX, y: height / 2, textAnchor: "middle", dy: "0.35em" }, badge)
  );
});
var LabelBadge_default = LabelBadge;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/labels/LabelContextMenu.js
var React393 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/ellipsis-v-icon.js
var EllipsisVIconConfig = {
  name: "EllipsisVIcon",
  height: 512,
  width: 192,
  svgPath: "M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z",
  yOffset: 0,
  xOffset: 0
};
var EllipsisVIcon = createIcon2(EllipsisVIconConfig);
var ellipsis_v_icon_default = EllipsisVIcon;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/labels/LabelActionIcon.js
var React392 = __toESM(require_react());
var import_topology_components9 = __toESM(require_topology_components());
var LabelActionIcon = React392.forwardRef(({ icon, onClick, className, x: x4, y: y4, paddingX, height, iconOffsetX = 0, iconOffsetY = 0 }, actionRef) => {
  var _a2, _b;
  const [iconSize, iconRef] = useSize([icon, paddingX]);
  const iconWidth = (_a2 = iconSize === null || iconSize === void 0 ? void 0 : iconSize.width) !== null && _a2 !== void 0 ? _a2 : 0;
  const iconHeight = (_b = iconSize === null || iconSize === void 0 ? void 0 : iconSize.height) !== null && _b !== void 0 ? _b : 0;
  const iconY = (height - iconHeight) / 2;
  const classes = css2(import_topology_components9.default.topologyNodeActionIcon, className);
  const handleClick = (e) => {
    if (onClick) {
      e.stopPropagation();
      onClick(e);
    }
  };
  return React392.createElement(
    "g",
    { className: classes, onClick: handleClick },
    iconSize && React392.createElement("rect", { ref: actionRef, className: css2(import_topology_components9.default.topologyNodeActionIconBackground), x: x4, y: y4, width: iconWidth + paddingX * 2, height }),
    React392.createElement("g", { className: css2(import_topology_components9.default.topologyNodeActionIconIcon), transform: `translate(${x4 + paddingX + iconOffsetX}, ${y4 + iconY + iconOffsetY})`, ref: iconRef }, icon)
  );
});
var LabelActionIcon_default = LabelActionIcon;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/labels/LabelContextMenu.js
var LabelContextMenu = React393.forwardRef(({ onContextMenu, className, x: x4, y: y4, paddingX, paddingY, height }, menuRef) => React393.createElement(LabelActionIcon_default, { ref: menuRef, icon: React393.createElement(ellipsis_v_icon_default, null), iconOffsetX: -6, className, onClick: onContextMenu, x: x4, y: y4, height, paddingX, paddingY }));
var LabelContextMenu_default = LabelContextMenu;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/labels/LabelIcon.js
var React394 = __toESM(require_react());
var import_topology_components10 = __toESM(require_topology_components());
var LabelIcon = React394.forwardRef(({ className, x: x4, y: y4, width, height, iconClass, icon, padding = 4, innerRef }, circleRef) => {
  const radius = width / 2;
  const cx = x4 - radius;
  const cy = y4 + height / 2;
  const innerX = x4 - width + padding + 1;
  const innerY = y4 + padding + 1;
  const innerWidth = width - padding * 2 - 2;
  const innerHeight = height - padding * 2 - 2;
  return React394.createElement(
    "g",
    { className: css2(import_topology_components10.default.topologyNodeLabelIcon, className), ref: innerRef },
    React394.createElement("circle", { className: css2(import_topology_components10.default.topologyNodeLabelIconBackground), ref: circleRef, cx, cy, r: radius }),
    icon ? React394.createElement("foreignObject", { className: css2(import_topology_components10.default.topologyNodeLabelIcon), x: innerX, y: innerY, width: Math.max(innerWidth, 0), height: Math.max(innerHeight, 0) }, icon) : React394.createElement("image", { x: innerX, y: innerY, width: Math.max(innerWidth, 0), height: Math.max(innerHeight, 0), xlinkHref: iconClass })
  );
});
var LabelIcon_default = LabelIcon;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/labels/NodeLabel.js
var NodeLabel = (_a2) => {
  var _b;
  var { children: children2, className, paddingX = 0, paddingY = 0, cornerRadius = 4, x: x4 = 0, y: y4 = 0, position = LabelPosition.bottom, centerLabelOnEdge, secondaryLabel, status, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation = BadgeLocation.inner, labelIconClass, labelIcon, labelIconPadding = 4, truncateLength, dragRef, hover, dragging, edgeDragging, dropTarget, onContextMenu, contextMenuOpen, actionIcon, actionIconClassName, onActionIconClick, boxRef } = _a2, other = __rest(_a2, ["children", "className", "paddingX", "paddingY", "cornerRadius", "x", "y", "position", "centerLabelOnEdge", "secondaryLabel", "status", "badge", "badgeColor", "badgeTextColor", "badgeBorderColor", "badgeClassName", "badgeLocation", "labelIconClass", "labelIcon", "labelIconPadding", "truncateLength", "dragRef", "hover", "dragging", "edgeDragging", "dropTarget", "onContextMenu", "contextMenuOpen", "actionIcon", "actionIconClassName", "onActionIconClick", "boxRef"]);
  const [labelHover, labelHoverRef] = useHover_default();
  const refs = useCombineRefs_default(dragRef, typeof truncateLength === "number" ? labelHoverRef : void 0);
  const [textSize, textRef] = useSize([children2, truncateLength, className, labelHover]);
  const [secondaryTextSize, secondaryTextRef] = useSize([secondaryLabel, truncateLength, className, labelHover]);
  const [badgeSize, badgeRef] = useSize([badge]);
  const [actionSize, actionRef] = useSize([actionIcon, paddingX]);
  const [contextSize, contextRef] = useSize([onContextMenu, paddingX]);
  const { width, height, backgroundHeight, startX, startY, badgeStartX, badgeStartY, actionStartX, contextStartX, iconSpace, badgeSpace } = React395.useMemo(() => {
    var _a3;
    if (!textSize) {
      return {
        width: 0,
        height: 0,
        backgroundHeight: 0,
        startX: 0,
        startY: 0,
        badgeStartX: 0,
        badgeStartY: 0,
        actionStartX: 0,
        contextStartX: 0,
        iconSpace: 0,
        badgeSpace: 0
      };
    }
    const badgeSpace2 = badge && badgeSize && badgeLocation === BadgeLocation.inner ? badgeSize.width + paddingX : 0;
    const height2 = Math.max(textSize.height, (_a3 = badgeSize === null || badgeSize === void 0 ? void 0 : badgeSize.height) !== null && _a3 !== void 0 ? _a3 : 0) + paddingY * 2;
    const iconSpace2 = labelIconClass || labelIcon ? (height2 + paddingY * 0.5) / 2 : 0;
    const actionSpace = actionIcon && actionSize ? actionSize.width : 0;
    const contextSpace = onContextMenu && contextSize ? contextSize.width : 0;
    const primaryWidth = iconSpace2 + badgeSpace2 + paddingX + textSize.width + actionSpace + contextSpace + paddingX;
    const secondaryWidth = secondaryLabel && secondaryTextSize ? secondaryTextSize.width + 2 * paddingX : 0;
    const width2 = Math.max(primaryWidth, secondaryWidth);
    const backgroundHeight2 = height2 + (secondaryLabel && secondaryTextSize ? secondaryTextSize.height + paddingY * 2 : 0);
    let startX2;
    let startY2;
    if (position === LabelPosition.top) {
      startX2 = x4 - width2 / 2;
      startY2 = -y4 - height2 - (centerLabelOnEdge ? -backgroundHeight2 / 2 : paddingY);
    } else if (position === LabelPosition.right) {
      startX2 = x4 + iconSpace2 - (centerLabelOnEdge ? width2 / 2 : 0);
      startY2 = y4 - height2 / 2;
    } else if (position === LabelPosition.left) {
      startX2 = centerLabelOnEdge ? x4 - width2 / 2 : -width2 - paddingX;
      startY2 = y4 - height2 / 2;
    } else {
      startX2 = x4 - width2 / 2 + iconSpace2 / 2;
      startY2 = y4 - (centerLabelOnEdge ? backgroundHeight2 / 2 : 0);
    }
    const actionStartX2 = iconSpace2 + badgeSpace2 + paddingX + textSize.width + paddingX;
    const contextStartX2 = actionStartX2 + actionSpace;
    let badgeStartX2 = 0;
    let badgeStartY2 = 0;
    if (badgeSize) {
      if (badgeLocation === BadgeLocation.below) {
        badgeStartX2 = (width2 - badgeSize.width) / 2;
        badgeStartY2 = height2 + paddingY;
      } else {
        badgeStartX2 = iconSpace2 + paddingX;
        badgeStartY2 = (height2 - badgeSize.height) / 2;
      }
    }
    return {
      width: width2,
      height: height2,
      backgroundHeight: backgroundHeight2,
      startX: startX2,
      startY: startY2,
      actionStartX: actionStartX2,
      contextStartX: contextStartX2,
      badgeStartX: badgeStartX2,
      badgeStartY: badgeStartY2,
      iconSpace: iconSpace2,
      badgeSpace: badgeSize && badgeLocation === BadgeLocation.inner ? badgeSpace2 : 0
    };
  }, [
    textSize,
    badge,
    badgeSize,
    badgeLocation,
    paddingX,
    paddingY,
    labelIconClass,
    labelIcon,
    actionIcon,
    actionSize,
    onContextMenu,
    contextSize,
    secondaryLabel,
    secondaryTextSize,
    centerLabelOnEdge,
    position,
    x4,
    y4
  ]);
  let filterId;
  if (status === "danger") {
    filterId = NODE_SHADOW_FILTER_ID_DANGER;
  } else if (hover || dragging || edgeDragging || dropTarget) {
    filterId = NODE_SHADOW_FILTER_ID_HOVER;
  }
  return React395.createElement(
    "g",
    { className, ref: refs, transform: `translate(${startX}, ${startY})` },
    React395.createElement(NodeShadows_default, null),
    textSize && React395.createElement("rect", { ref: boxRef, className: css2(import_topology_components11.default.topologyNodeLabelBackground), key: `rect-${filterId}-${width}`, filter: filterId && createSvgIdUrl(filterId), x: 0, y: 0, width, height: backgroundHeight, rx: cornerRadius, ry: cornerRadius }),
    textSize && badge && React395.createElement(LabelBadge_default, { ref: badgeRef, x: badgeStartX, y: badgeStartY, badge, badgeClassName, badgeColor, badgeTextColor, badgeBorderColor }),
    textSize && secondaryLabel && React395.createElement(
      React395.Fragment,
      null,
      React395.createElement("line", { className: css2(import_topology_components11.default.topologyNodeSeparator), x1: 0, y1: height, x2: width, y2: height, shapeRendering: "crispEdges" }),
      React395.createElement("text", { className: "pf-m-secondary", ref: secondaryTextRef, x: width / 2, y: height + paddingY + ((_b = secondaryTextSize === null || secondaryTextSize === void 0 ? void 0 : secondaryTextSize.height) !== null && _b !== void 0 ? _b : 0) / 2, dy: "0.35em", textAnchor: "middle" }, truncateLength > 0 && !labelHover ? truncateMiddle(secondaryLabel, { length: truncateLength }) : secondaryLabel)
    ),
    textSize && (labelIconClass || labelIcon) && React395.createElement(LabelIcon_default, { x: iconSpace, y: paddingY * -0.25, width: iconSpace * 2, height: iconSpace * 2, iconClass: labelIconClass, icon: labelIcon, padding: labelIconPadding }),
    React395.createElement("text", Object.assign({}, other, { ref: textRef, x: iconSpace + badgeSpace + paddingX, y: height / 2, dy: "0.35em" }), truncateLength > 0 && !labelHover ? truncateMiddle(children2, { length: truncateLength }) : children2),
    textSize && actionIcon && React395.createElement(
      React395.Fragment,
      null,
      React395.createElement("line", { className: css2(import_topology_components11.default.topologyNodeSeparator), x1: actionStartX, y1: 0, x2: actionStartX, y2: height, shapeRendering: "crispEdges" }),
      React395.createElement(LabelActionIcon_default, { ref: actionRef, x: actionStartX, y: 0, height, paddingX, paddingY, icon: actionIcon, className: actionIconClassName, onClick: onActionIconClick })
    ),
    textSize && onContextMenu && React395.createElement(
      React395.Fragment,
      null,
      React395.createElement("line", { className: css2(import_topology_components11.default.topologyNodeSeparator), x1: contextStartX, y1: 0, x2: contextStartX, y2: height, shapeRendering: "crispEdges" }),
      React395.createElement(LabelContextMenu_default, { ref: contextRef, x: contextStartX, y: 0, height, paddingX, paddingY, onContextMenu, contextMenuOpen })
    )
  );
};
var NodeLabel_default = NodeLabel;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/Ellipse.js
var import_topology_components13 = __toESM(require_topology_components());
var React409 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/behavior/useAnchor.js
var React396 = __toESM(require_react());
var useAnchor = (anchorCallback, end2 = AnchorEnd.both, type2) => {
  const element = React396.useContext(ElementContext_default);
  if (!isNode(element)) {
    throw new Error("useAnchor must be used within the scope of a Node");
  }
  React396.useEffect(() => {
    runInAction(() => {
      const anchor = anchorCallback.prototype ? new anchorCallback(element) : anchorCallback(element);
      if (anchor) {
        element.setAnchor(anchor, end2, type2);
      }
    });
  }, [anchorCallback, element, end2, type2]);
};
var withAnchor = (anchor, end2, type2) => (WrappedComponent) => {
  const Component50 = (props) => {
    useAnchor(React396.useCallback(() => anchor, []), end2, type2);
    return React396.createElement(WrappedComponent, Object.assign({}, props));
  };
  Component50.displayName = `withAnchor(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/useBendpoint.js
var React398 = __toESM(require_react());

// node_modules/d3/src/index.js
var src_exports = {};
__export(src_exports, {
  Adder: () => Adder,
  Delaunay: () => Delaunay,
  FormatSpecifier: () => FormatSpecifier,
  InternMap: () => InternMap,
  InternSet: () => InternSet,
  Node: () => Node2,
  Path: () => Path,
  Voronoi: () => Voronoi,
  ZoomTransform: () => Transform,
  active: () => active_default,
  arc: () => arc_default,
  area: () => area_default5,
  areaRadial: () => areaRadial_default,
  ascending: () => ascending,
  autoType: () => autoType,
  axisBottom: () => axisBottom,
  axisLeft: () => axisLeft,
  axisRight: () => axisRight,
  axisTop: () => axisTop,
  bin: () => bin,
  bisect: () => bisect_default,
  bisectCenter: () => bisectCenter,
  bisectLeft: () => bisectLeft,
  bisectRight: () => bisectRight,
  bisector: () => bisector,
  blob: () => blob_default,
  blur: () => blur,
  blur2: () => blur2,
  blurImage: () => blurImage,
  brush: () => brush_default,
  brushSelection: () => brushSelection,
  brushX: () => brushX,
  brushY: () => brushY,
  buffer: () => buffer_default,
  chord: () => chord_default,
  chordDirected: () => chordDirected,
  chordTranspose: () => chordTranspose,
  cluster: () => cluster_default,
  color: () => color,
  contourDensity: () => density_default,
  contours: () => contours_default,
  count: () => count,
  create: () => create_default,
  creator: () => creator_default,
  cross: () => cross,
  csv: () => csv2,
  csvFormat: () => csvFormat,
  csvFormatBody: () => csvFormatBody,
  csvFormatRow: () => csvFormatRow,
  csvFormatRows: () => csvFormatRows,
  csvFormatValue: () => csvFormatValue,
  csvParse: () => csvParse,
  csvParseRows: () => csvParseRows,
  cubehelix: () => cubehelix,
  cumsum: () => cumsum,
  curveBasis: () => basis_default2,
  curveBasisClosed: () => basisClosed_default2,
  curveBasisOpen: () => basisOpen_default,
  curveBumpX: () => bumpX,
  curveBumpY: () => bumpY,
  curveBundle: () => bundle_default,
  curveCardinal: () => cardinal_default,
  curveCardinalClosed: () => cardinalClosed_default,
  curveCardinalOpen: () => cardinalOpen_default,
  curveCatmullRom: () => catmullRom_default,
  curveCatmullRomClosed: () => catmullRomClosed_default,
  curveCatmullRomOpen: () => catmullRomOpen_default,
  curveLinear: () => linear_default,
  curveLinearClosed: () => linearClosed_default,
  curveMonotoneX: () => monotoneX,
  curveMonotoneY: () => monotoneY,
  curveNatural: () => natural_default,
  curveStep: () => step_default,
  curveStepAfter: () => stepAfter,
  curveStepBefore: () => stepBefore,
  descending: () => descending,
  deviation: () => deviation,
  difference: () => difference,
  disjoint: () => disjoint,
  dispatch: () => dispatch_default,
  drag: () => drag_default,
  dragDisable: () => nodrag_default,
  dragEnable: () => yesdrag,
  dsv: () => dsv,
  dsvFormat: () => dsv_default,
  easeBack: () => backInOut,
  easeBackIn: () => backIn,
  easeBackInOut: () => backInOut,
  easeBackOut: () => backOut,
  easeBounce: () => bounceOut,
  easeBounceIn: () => bounceIn,
  easeBounceInOut: () => bounceInOut,
  easeBounceOut: () => bounceOut,
  easeCircle: () => circleInOut,
  easeCircleIn: () => circleIn,
  easeCircleInOut: () => circleInOut,
  easeCircleOut: () => circleOut,
  easeCubic: () => cubicInOut,
  easeCubicIn: () => cubicIn,
  easeCubicInOut: () => cubicInOut,
  easeCubicOut: () => cubicOut,
  easeElastic: () => elasticOut,
  easeElasticIn: () => elasticIn,
  easeElasticInOut: () => elasticInOut,
  easeElasticOut: () => elasticOut,
  easeExp: () => expInOut,
  easeExpIn: () => expIn,
  easeExpInOut: () => expInOut,
  easeExpOut: () => expOut,
  easeLinear: () => linear2,
  easePoly: () => polyInOut,
  easePolyIn: () => polyIn,
  easePolyInOut: () => polyInOut,
  easePolyOut: () => polyOut,
  easeQuad: () => quadInOut,
  easeQuadIn: () => quadIn,
  easeQuadInOut: () => quadInOut,
  easeQuadOut: () => quadOut,
  easeSin: () => sinInOut,
  easeSinIn: () => sinIn,
  easeSinInOut: () => sinInOut,
  easeSinOut: () => sinOut,
  every: () => every,
  extent: () => extent,
  fcumsum: () => fcumsum,
  filter: () => filter,
  flatGroup: () => flatGroup,
  flatRollup: () => flatRollup,
  forceCenter: () => center_default,
  forceCollide: () => collide_default,
  forceLink: () => link_default,
  forceManyBody: () => manyBody_default,
  forceRadial: () => radial_default,
  forceSimulation: () => simulation_default,
  forceX: () => x_default2,
  forceY: () => y_default2,
  format: () => format2,
  formatDefaultLocale: () => defaultLocale,
  formatLocale: () => locale_default,
  formatPrefix: () => formatPrefix,
  formatSpecifier: () => formatSpecifier,
  fsum: () => fsum,
  geoAlbers: () => albers_default,
  geoAlbersUsa: () => albersUsa_default,
  geoArea: () => area_default2,
  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
  geoBounds: () => bounds_default,
  geoCentroid: () => centroid_default,
  geoCircle: () => circle_default,
  geoClipAntimeridian: () => antimeridian_default,
  geoClipCircle: () => circle_default2,
  geoClipExtent: () => extent_default2,
  geoClipRectangle: () => clipRectangle,
  geoConicConformal: () => conicConformal_default,
  geoConicConformalRaw: () => conicConformalRaw,
  geoConicEqualArea: () => conicEqualArea_default,
  geoConicEqualAreaRaw: () => conicEqualAreaRaw,
  geoConicEquidistant: () => conicEquidistant_default,
  geoConicEquidistantRaw: () => conicEquidistantRaw,
  geoContains: () => contains_default2,
  geoDistance: () => distance_default,
  geoEqualEarth: () => equalEarth_default,
  geoEqualEarthRaw: () => equalEarthRaw,
  geoEquirectangular: () => equirectangular_default,
  geoEquirectangularRaw: () => equirectangularRaw,
  geoGnomonic: () => gnomonic_default,
  geoGnomonicRaw: () => gnomonicRaw,
  geoGraticule: () => graticule,
  geoGraticule10: () => graticule10,
  geoIdentity: () => identity_default4,
  geoInterpolate: () => interpolate_default2,
  geoLength: () => length_default,
  geoMercator: () => mercator_default,
  geoMercatorRaw: () => mercatorRaw,
  geoNaturalEarth1: () => naturalEarth1_default,
  geoNaturalEarth1Raw: () => naturalEarth1Raw,
  geoOrthographic: () => orthographic_default,
  geoOrthographicRaw: () => orthographicRaw,
  geoPath: () => path_default,
  geoProjection: () => projection,
  geoProjectionMutator: () => projectionMutator,
  geoRotation: () => rotation_default,
  geoStereographic: () => stereographic_default,
  geoStereographicRaw: () => stereographicRaw,
  geoStream: () => stream_default,
  geoTransform: () => transform_default,
  geoTransverseMercator: () => transverseMercator_default,
  geoTransverseMercatorRaw: () => transverseMercatorRaw,
  gray: () => gray,
  greatest: () => greatest,
  greatestIndex: () => greatestIndex,
  group: () => group,
  groupSort: () => groupSort,
  groups: () => groups,
  hcl: () => hcl,
  hierarchy: () => hierarchy,
  histogram: () => bin,
  hsl: () => hsl,
  html: () => html,
  image: () => image_default,
  index: () => index2,
  indexes: () => indexes,
  interpolate: () => value_default,
  interpolateArray: () => array_default,
  interpolateBasis: () => basis_default,
  interpolateBasisClosed: () => basisClosed_default,
  interpolateBlues: () => Blues_default,
  interpolateBrBG: () => BrBG_default,
  interpolateBuGn: () => BuGn_default,
  interpolateBuPu: () => BuPu_default,
  interpolateCividis: () => cividis_default,
  interpolateCool: () => cool,
  interpolateCubehelix: () => cubehelix_default,
  interpolateCubehelixDefault: () => cubehelix_default2,
  interpolateCubehelixLong: () => cubehelixLong,
  interpolateDate: () => date_default,
  interpolateDiscrete: () => discrete_default,
  interpolateGnBu: () => GnBu_default,
  interpolateGreens: () => Greens_default,
  interpolateGreys: () => Greys_default,
  interpolateHcl: () => hcl_default,
  interpolateHclLong: () => hclLong,
  interpolateHsl: () => hsl_default,
  interpolateHslLong: () => hslLong,
  interpolateHue: () => hue_default,
  interpolateInferno: () => inferno,
  interpolateLab: () => lab2,
  interpolateMagma: () => magma,
  interpolateNumber: () => number_default,
  interpolateNumberArray: () => numberArray_default,
  interpolateObject: () => object_default,
  interpolateOrRd: () => OrRd_default,
  interpolateOranges: () => Oranges_default,
  interpolatePRGn: () => PRGn_default,
  interpolatePiYG: () => PiYG_default,
  interpolatePlasma: () => plasma,
  interpolatePuBu: () => PuBu_default,
  interpolatePuBuGn: () => PuBuGn_default,
  interpolatePuOr: () => PuOr_default,
  interpolatePuRd: () => PuRd_default,
  interpolatePurples: () => Purples_default,
  interpolateRainbow: () => rainbow_default,
  interpolateRdBu: () => RdBu_default,
  interpolateRdGy: () => RdGy_default,
  interpolateRdPu: () => RdPu_default,
  interpolateRdYlBu: () => RdYlBu_default,
  interpolateRdYlGn: () => RdYlGn_default,
  interpolateReds: () => Reds_default,
  interpolateRgb: () => rgb_default,
  interpolateRgbBasis: () => rgbBasis,
  interpolateRgbBasisClosed: () => rgbBasisClosed,
  interpolateRound: () => round_default,
  interpolateSinebow: () => sinebow_default,
  interpolateSpectral: () => Spectral_default,
  interpolateString: () => string_default,
  interpolateTransformCss: () => interpolateTransformCss,
  interpolateTransformSvg: () => interpolateTransformSvg,
  interpolateTurbo: () => turbo_default,
  interpolateViridis: () => viridis_default,
  interpolateWarm: () => warm,
  interpolateYlGn: () => YlGn_default,
  interpolateYlGnBu: () => YlGnBu_default,
  interpolateYlOrBr: () => YlOrBr_default,
  interpolateYlOrRd: () => YlOrRd_default,
  interpolateZoom: () => zoom_default,
  interrupt: () => interrupt_default,
  intersection: () => intersection,
  interval: () => interval_default,
  isoFormat: () => isoFormat_default,
  isoParse: () => isoParse_default,
  json: () => json_default,
  lab: () => lab,
  lch: () => lch,
  least: () => least,
  leastIndex: () => leastIndex,
  line: () => line_default2,
  lineRadial: () => lineRadial_default,
  link: () => link2,
  linkHorizontal: () => linkHorizontal,
  linkRadial: () => linkRadial,
  linkVertical: () => linkVertical,
  local: () => local,
  map: () => map3,
  matcher: () => matcher_default,
  max: () => max,
  maxIndex: () => maxIndex,
  mean: () => mean,
  median: () => median,
  medianIndex: () => medianIndex,
  merge: () => merge,
  min: () => min,
  minIndex: () => minIndex,
  mode: () => mode,
  namespace: () => namespace_default,
  namespaces: () => namespaces_default,
  nice: () => nice,
  now: () => now,
  pack: () => pack_default,
  packEnclose: () => enclose_default,
  packSiblings: () => siblings_default,
  pairs: () => pairs,
  partition: () => partition_default,
  path: () => path,
  pathRound: () => pathRound,
  permute: () => permute,
  pie: () => pie_default,
  piecewise: () => piecewise,
  pointRadial: () => pointRadial_default,
  pointer: () => pointer_default,
  pointers: () => pointers_default,
  polygonArea: () => area_default4,
  polygonCentroid: () => centroid_default3,
  polygonContains: () => contains_default3,
  polygonHull: () => hull_default,
  polygonLength: () => length_default2,
  precisionFixed: () => precisionFixed_default,
  precisionPrefix: () => precisionPrefix_default,
  precisionRound: () => precisionRound_default,
  quadtree: () => quadtree,
  quantile: () => quantile,
  quantileIndex: () => quantileIndex,
  quantileSorted: () => quantileSorted,
  quantize: () => quantize_default,
  quickselect: () => quickselect,
  radialArea: () => areaRadial_default,
  radialLine: () => lineRadial_default,
  randomBates: () => bates_default,
  randomBernoulli: () => bernoulli_default,
  randomBeta: () => beta_default,
  randomBinomial: () => binomial_default,
  randomCauchy: () => cauchy_default,
  randomExponential: () => exponential_default,
  randomGamma: () => gamma_default,
  randomGeometric: () => geometric_default,
  randomInt: () => int_default,
  randomIrwinHall: () => irwinHall_default,
  randomLcg: () => lcg,
  randomLogNormal: () => logNormal_default,
  randomLogistic: () => logistic_default,
  randomNormal: () => normal_default,
  randomPareto: () => pareto_default,
  randomPoisson: () => poisson_default,
  randomUniform: () => uniform_default,
  randomWeibull: () => weibull_default,
  range: () => range,
  rank: () => rank,
  reduce: () => reduce,
  reverse: () => reverse2,
  rgb: () => rgb,
  ribbon: () => ribbon_default,
  ribbonArrow: () => ribbonArrow,
  rollup: () => rollup,
  rollups: () => rollups,
  scaleBand: () => band,
  scaleDiverging: () => diverging,
  scaleDivergingLog: () => divergingLog,
  scaleDivergingPow: () => divergingPow,
  scaleDivergingSqrt: () => divergingSqrt,
  scaleDivergingSymlog: () => divergingSymlog,
  scaleIdentity: () => identity4,
  scaleImplicit: () => implicit,
  scaleLinear: () => linear3,
  scaleLog: () => log2,
  scaleOrdinal: () => ordinal,
  scalePoint: () => point,
  scalePow: () => pow3,
  scaleQuantile: () => quantile2,
  scaleQuantize: () => quantize,
  scaleRadial: () => radial,
  scaleSequential: () => sequential,
  scaleSequentialLog: () => sequentialLog,
  scaleSequentialPow: () => sequentialPow,
  scaleSequentialQuantile: () => sequentialQuantile,
  scaleSequentialSqrt: () => sequentialSqrt,
  scaleSequentialSymlog: () => sequentialSymlog,
  scaleSqrt: () => sqrt2,
  scaleSymlog: () => symlog,
  scaleThreshold: () => threshold,
  scaleTime: () => time,
  scaleUtc: () => utcTime,
  scan: () => scan,
  schemeAccent: () => Accent_default,
  schemeBlues: () => scheme22,
  schemeBrBG: () => scheme,
  schemeBuGn: () => scheme10,
  schemeBuPu: () => scheme11,
  schemeCategory10: () => category10_default,
  schemeDark2: () => Dark2_default,
  schemeGnBu: () => scheme12,
  schemeGreens: () => scheme23,
  schemeGreys: () => scheme24,
  schemeObservable10: () => observable10_default,
  schemeOrRd: () => scheme13,
  schemeOranges: () => scheme27,
  schemePRGn: () => scheme2,
  schemePaired: () => Paired_default,
  schemePastel1: () => Pastel1_default,
  schemePastel2: () => Pastel2_default,
  schemePiYG: () => scheme3,
  schemePuBu: () => scheme15,
  schemePuBuGn: () => scheme14,
  schemePuOr: () => scheme4,
  schemePuRd: () => scheme16,
  schemePurples: () => scheme25,
  schemeRdBu: () => scheme5,
  schemeRdGy: () => scheme6,
  schemeRdPu: () => scheme17,
  schemeRdYlBu: () => scheme7,
  schemeRdYlGn: () => scheme8,
  schemeReds: () => scheme26,
  schemeSet1: () => Set1_default,
  schemeSet2: () => Set2_default,
  schemeSet3: () => Set3_default,
  schemeSpectral: () => scheme9,
  schemeTableau10: () => Tableau10_default,
  schemeYlGn: () => scheme19,
  schemeYlGnBu: () => scheme18,
  schemeYlOrBr: () => scheme20,
  schemeYlOrRd: () => scheme21,
  select: () => select_default2,
  selectAll: () => selectAll_default2,
  selection: () => selection_default,
  selector: () => selector_default,
  selectorAll: () => selectorAll_default,
  shuffle: () => shuffle_default,
  shuffler: () => shuffler,
  some: () => some,
  sort: () => sort2,
  stack: () => stack_default2,
  stackOffsetDiverging: () => diverging_default,
  stackOffsetExpand: () => expand_default,
  stackOffsetNone: () => none_default,
  stackOffsetSilhouette: () => silhouette_default,
  stackOffsetWiggle: () => wiggle_default,
  stackOrderAppearance: () => appearance_default,
  stackOrderAscending: () => ascending_default2,
  stackOrderDescending: () => descending_default2,
  stackOrderInsideOut: () => insideOut_default,
  stackOrderNone: () => none_default2,
  stackOrderReverse: () => reverse_default,
  stratify: () => stratify_default,
  style: () => styleValue,
  subset: () => subset,
  sum: () => sum,
  superset: () => superset,
  svg: () => svg,
  symbol: () => Symbol2,
  symbolAsterisk: () => asterisk_default,
  symbolCircle: () => circle_default3,
  symbolCross: () => cross_default2,
  symbolDiamond: () => diamond_default,
  symbolDiamond2: () => diamond2_default,
  symbolPlus: () => plus_default,
  symbolSquare: () => square_default,
  symbolSquare2: () => square2_default,
  symbolStar: () => star_default,
  symbolTimes: () => times_default,
  symbolTriangle: () => triangle_default,
  symbolTriangle2: () => triangle2_default,
  symbolWye: () => wye_default,
  symbolX: () => times_default,
  symbols: () => symbolsFill,
  symbolsFill: () => symbolsFill,
  symbolsStroke: () => symbolsStroke,
  text: () => text_default3,
  thresholdFreedmanDiaconis: () => thresholdFreedmanDiaconis,
  thresholdScott: () => thresholdScott,
  thresholdSturges: () => thresholdSturges,
  tickFormat: () => tickFormat,
  tickIncrement: () => tickIncrement,
  tickStep: () => tickStep,
  ticks: () => ticks,
  timeDay: () => timeDay,
  timeDays: () => timeDays,
  timeFormat: () => timeFormat,
  timeFormatDefaultLocale: () => defaultLocale2,
  timeFormatLocale: () => formatLocale,
  timeFriday: () => timeFriday,
  timeFridays: () => timeFridays,
  timeHour: () => timeHour,
  timeHours: () => timeHours,
  timeInterval: () => timeInterval,
  timeMillisecond: () => millisecond,
  timeMilliseconds: () => milliseconds,
  timeMinute: () => timeMinute,
  timeMinutes: () => timeMinutes,
  timeMonday: () => timeMonday,
  timeMondays: () => timeMondays,
  timeMonth: () => timeMonth,
  timeMonths: () => timeMonths,
  timeParse: () => timeParse,
  timeSaturday: () => timeSaturday,
  timeSaturdays: () => timeSaturdays,
  timeSecond: () => second,
  timeSeconds: () => seconds,
  timeSunday: () => timeSunday,
  timeSundays: () => timeSundays,
  timeThursday: () => timeThursday,
  timeThursdays: () => timeThursdays,
  timeTickInterval: () => timeTickInterval,
  timeTicks: () => timeTicks,
  timeTuesday: () => timeTuesday,
  timeTuesdays: () => timeTuesdays,
  timeWednesday: () => timeWednesday,
  timeWednesdays: () => timeWednesdays,
  timeWeek: () => timeSunday,
  timeWeeks: () => timeSundays,
  timeYear: () => timeYear,
  timeYears: () => timeYears,
  timeout: () => timeout_default,
  timer: () => timer,
  timerFlush: () => timerFlush,
  transition: () => transition,
  transpose: () => transpose,
  tree: () => tree_default,
  treemap: () => treemap_default,
  treemapBinary: () => binary_default,
  treemapDice: () => dice_default,
  treemapResquarify: () => resquarify_default,
  treemapSlice: () => slice_default,
  treemapSliceDice: () => sliceDice_default,
  treemapSquarify: () => squarify_default,
  tsv: () => tsv2,
  tsvFormat: () => tsvFormat,
  tsvFormatBody: () => tsvFormatBody,
  tsvFormatRow: () => tsvFormatRow,
  tsvFormatRows: () => tsvFormatRows,
  tsvFormatValue: () => tsvFormatValue,
  tsvParse: () => tsvParse,
  tsvParseRows: () => tsvParseRows,
  union: () => union,
  unixDay: () => unixDay,
  unixDays: () => unixDays,
  utcDay: () => utcDay,
  utcDays: () => utcDays,
  utcFormat: () => utcFormat,
  utcFriday: () => utcFriday,
  utcFridays: () => utcFridays,
  utcHour: () => utcHour,
  utcHours: () => utcHours,
  utcMillisecond: () => millisecond,
  utcMilliseconds: () => milliseconds,
  utcMinute: () => utcMinute,
  utcMinutes: () => utcMinutes,
  utcMonday: () => utcMonday,
  utcMondays: () => utcMondays,
  utcMonth: () => utcMonth,
  utcMonths: () => utcMonths,
  utcParse: () => utcParse,
  utcSaturday: () => utcSaturday,
  utcSaturdays: () => utcSaturdays,
  utcSecond: () => second,
  utcSeconds: () => seconds,
  utcSunday: () => utcSunday,
  utcSundays: () => utcSundays,
  utcThursday: () => utcThursday,
  utcThursdays: () => utcThursdays,
  utcTickInterval: () => utcTickInterval,
  utcTicks: () => utcTicks,
  utcTuesday: () => utcTuesday,
  utcTuesdays: () => utcTuesdays,
  utcWednesday: () => utcWednesday,
  utcWednesdays: () => utcWednesdays,
  utcWeek: () => utcSunday,
  utcWeeks: () => utcSundays,
  utcYear: () => utcYear,
  utcYears: () => utcYears,
  variance: () => variance,
  window: () => window_default,
  xml: () => xml_default,
  zip: () => zip,
  zoom: () => zoom_default2,
  zoomIdentity: () => identity5,
  zoomTransform: () => transform
});

// node_modules/d3-array/src/ascending.js
function ascending(a4, b) {
  return a4 == null || b == null ? NaN : a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a4, b) {
  return a4 == null || b == null ? NaN : b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x4) => ascending(f(d), x4);
    delta = (d, x4) => f(d) - x4;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left3(a4, x4, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a4[mid], x4) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right3(a4, x4, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a4[mid], x4) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a4, x4, lo = 0, hi = a4.length) {
    const i = left3(a4, x4, lo, hi - 1);
    return i > lo && delta(a4[i - 1], x4) > -delta(a4[i], x4) ? i - 1 : i;
  }
  return { left: left3, center: center2, right: right3 };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x4) {
  return x4 === null ? NaN : +x4;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
function blur(values, r) {
  if (!((r = +r) >= 0)) throw new RangeError("invalid r");
  let length3 = values.length;
  if (!((length3 = Math.floor(length3)) >= 0)) throw new RangeError("invalid length");
  if (!length3 || !r) return values;
  const blur3 = blurf(r);
  const temp = values.slice();
  blur3(values, temp, 0, length3, 1);
  blur3(temp, values, 0, length3, 1);
  blur3(values, temp, 0, length3, 1);
  return values;
}
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values, width, height } = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}
function blurh(blur3, T, S, w, h) {
  for (let y4 = 0, n = w * h; y4 < n; ) {
    blur3(T, S, y4, y4 += w, 1);
  }
}
function blurv(blur3, T, S, w, h) {
  for (let x4 = 0, n = w * h; x4 < w; ++x4) {
    blur3(T, S, x4, x4 + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S, start3, stop, step) => {
    start3 <<= 2, stop <<= 2, step <<= 2;
    blur3(T, S, start3 + 0, stop + 0, step);
    blur3(T, S, start3 + 1, stop + 1, step);
    blur3(T, S, start3 + 2, stop + 2, step);
    blur3(T, S, start3 + 3, stop + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start3, stop, step) => {
    if (!((stop -= step) >= start3)) return;
    let sum4 = radius0 * S[start3];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start3, j = start3 + s0; i < j; i += step) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start3, j = stop; i <= j; i += step) {
      sum4 += S[Math.min(stop, i + s0)];
      T[i] = (sum4 + t * (S[Math.max(start3, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum4 -= S[Math.max(start3, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start3, stop, step) => {
    if (!((stop -= step) >= start3)) return;
    let sum4 = radius * S[start3];
    const s2 = step * radius;
    for (let i = start3, j = start3 + s2; i < j; i += step) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start3, j = stop; i <= j; i += step) {
      sum4 += S[Math.min(stop, i + s2)];
      T[i] = sum4 / w;
      sum4 -= S[Math.max(start3, i - s2)];
    }
  };
}

// node_modules/d3-array/src/count.js
function count(values, valueof) {
  let count3 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count3;
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null && (value = +value) >= value) {
        ++count3;
      }
    }
  }
  return count3;
}

// node_modules/d3-array/src/cross.js
function length(array5) {
  return array5.length | 0;
}
function empty(length3) {
  return !(length3 > 0);
}
function arrayify(values) {
  return typeof values !== "object" || "length" in values ? values : Array.from(values);
}
function reducer(reduce2) {
  return (values) => reduce2(...values);
}
function cross(...values) {
  const reduce2 = typeof values[values.length - 1] === "function" && reducer(values.pop());
  values = values.map(arrayify);
  const lengths = values.map(length);
  const j = values.length - 1;
  const index4 = new Array(j + 1).fill(0);
  const product = [];
  if (j < 0 || lengths.some(empty)) return product;
  while (true) {
    product.push(index4.map((j2, i2) => values[i2][j2]));
    let i = j;
    while (++index4[i] === lengths[i]) {
      if (i === 0) return reduce2 ? product.map(reduce2) : product;
      index4[i--] = 0;
    }
  }
}

// node_modules/d3-array/src/cumsum.js
function cumsum(values, valueof) {
  var sum4 = 0, index4 = 0;
  return Float64Array.from(values, valueof === void 0 ? (v2) => sum4 += +v2 || 0 : (v2) => sum4 += +valueof(v2, index4++, values) || 0);
}

// node_modules/d3-array/src/variance.js
function variance(values, valueof) {
  let count3 = 0;
  let delta;
  let mean2 = 0;
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count3;
        sum4 += delta * (value - mean2);
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count3;
        sum4 += delta * (value - mean2);
      }
    }
  }
  if (count3 > 1) return sum4 / (count3 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values, valueof) {
  const v2 = variance(values, valueof);
  return v2 ? Math.sqrt(v2) : v2;
}

// node_modules/d3-array/src/extent.js
function extent(values, valueof) {
  let min4;
  let max5;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min4 === void 0) {
          if (value >= value) min4 = max5 = value;
        } else {
          if (min4 > value) min4 = value;
          if (max5 < value) max5 = value;
        }
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null) {
        if (min4 === void 0) {
          if (value >= value) min4 = max5 = value;
        } else {
          if (min4 > value) min4 = value;
          if (max5 < value) max5 = value;
        }
      }
    }
  }
  return [min4, max5];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x4) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y4 = p[j], hi = x4 + y4, lo = Math.abs(x4) < Math.abs(y4) ? x4 - (hi - y4) : y4 - (hi - x4);
      if (lo) p[i++] = lo;
      x4 = hi;
    }
    p[i] = x4;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x4, y4, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x4 = hi;
        y4 = p[--n];
        hi = x4 + y4;
        lo = y4 - (hi - x4);
        if (lo) break;
      }
      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y4 = lo * 2;
        x4 = hi + y4;
        if (y4 == x4 - hi) hi = x4;
      }
    }
    return hi;
  }
};
function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index4, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}
function fcumsum(values, valueof) {
  const adder = new Adder();
  let index4 = -1;
  return Float64Array.from(
    values,
    valueof === void 0 ? (v2) => adder.add(+v2 || 0) : (v2) => adder.add(+valueof(v2, ++index4, values) || 0)
  );
}

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
var InternSet = class extends Set {
  constructor(values, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (values != null) for (const value of values) this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/identity.js
function identity(x4) {
  return x4;
}

// node_modules/d3-array/src/group.js
function group(values, ...keys) {
  return nest(values, identity, identity, keys);
}
function groups(values, ...keys) {
  return nest(values, Array.from, identity, keys);
}
function flatten(groups2, keys) {
  for (let i = 1, n = keys.length; i < n; ++i) {
    groups2 = groups2.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));
  }
  return groups2;
}
function flatGroup(values, ...keys) {
  return flatten(groups(values, ...keys), keys);
}
function flatRollup(values, reduce2, ...keys) {
  return flatten(rollups(values, reduce2, ...keys), keys);
}
function rollup(values, reduce2, ...keys) {
  return nest(values, identity, reduce2, keys);
}
function rollups(values, reduce2, ...keys) {
  return nest(values, Array.from, reduce2, keys);
}
function index2(values, ...keys) {
  return nest(values, identity, unique2, keys);
}
function indexes(values, ...keys) {
  return nest(values, Array.from, unique2, keys);
}
function unique2(values) {
  if (values.length !== 1) throw new Error("duplicate key");
  return values[0];
}
function nest(values, map5, reduce2, keys) {
  return function regroup(values2, i) {
    if (i >= keys.length) return reduce2(values2);
    const groups2 = new InternMap();
    const keyof2 = keys[i++];
    let index4 = -1;
    for (const value of values2) {
      const key = keyof2(value, ++index4, values2);
      const group2 = groups2.get(key);
      if (group2) group2.push(value);
      else groups2.set(key, [value]);
    }
    for (const [key, values3] of groups2) {
      groups2.set(key, regroup(values3, i));
    }
    return map5(groups2);
  }(values, 0);
}

// node_modules/d3-array/src/permute.js
function permute(source, keys) {
  return Array.from(keys, (key) => source[key]);
}

// node_modules/d3-array/src/sort.js
function sort2(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f] = F;
  if (f && f.length !== 2 || F.length > 1) {
    const index4 = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map((f2) => values.map(f2));
      index4.sort((i, j) => {
        for (const f2 of F) {
          const c6 = ascendingDefined(f2[i], f2[j]);
          if (c6) return c6;
        }
      });
    } else {
      f = values.map(f);
      index4.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return permute(values, index4);
  }
  return values.sort(compareDefined(f));
}
function compareDefined(compare2 = ascending) {
  if (compare2 === ascending) return ascendingDefined;
  if (typeof compare2 !== "function") throw new TypeError("compare is not a function");
  return (a4, b) => {
    const x4 = compare2(a4, b);
    if (x4 || x4 === 0) return x4;
    return (compare2(b, b) === 0) - (compare2(a4, a4) === 0);
  };
}
function ascendingDefined(a4, b) {
  return (a4 == null || !(a4 >= a4)) - (b == null || !(b >= b)) || (a4 < b ? -1 : a4 > b ? 1 : 0);
}

// node_modules/d3-array/src/groupSort.js
function groupSort(values, reduce2, key) {
  return (reduce2.length !== 2 ? sort2(rollup(values, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort2(group(values, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}

// node_modules/d3-array/src/array.js
var array2 = Array.prototype;
var slice = array2.slice;
var map2 = array2.map;

// node_modules/d3-array/src/constant.js
function constant(x4) {
  return () => x4;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start3, stop, count3) {
  const step = (stop - start3) / Math.max(0, count3), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc2;
  if (power < 0) {
    inc2 = Math.pow(10, -power) / factor;
    i1 = Math.round(start3 * inc2);
    i2 = Math.round(stop * inc2);
    if (i1 / inc2 < start3) ++i1;
    if (i2 / inc2 > stop) --i2;
    inc2 = -inc2;
  } else {
    inc2 = Math.pow(10, power) * factor;
    i1 = Math.round(start3 / inc2);
    i2 = Math.round(stop / inc2);
    if (i1 * inc2 < start3) ++i1;
    if (i2 * inc2 > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count3 && count3 < 2) return tickSpec(start3, stop, count3 * 2);
  return [i1, i2, inc2];
}
function ticks(start3, stop, count3) {
  stop = +stop, start3 = +start3, count3 = +count3;
  if (!(count3 > 0)) return [];
  if (start3 === stop) return [start3];
  const reverse3 = stop < start3, [i1, i2, inc2] = reverse3 ? tickSpec(stop, start3, count3) : tickSpec(start3, stop, count3);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse3) {
    if (inc2 < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc2;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc2;
  } else {
    if (inc2 < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc2;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc2;
  }
  return ticks2;
}
function tickIncrement(start3, stop, count3) {
  stop = +stop, start3 = +start3, count3 = +count3;
  return tickSpec(start3, stop, count3)[2];
}
function tickStep(start3, stop, count3) {
  stop = +stop, start3 = +start3, count3 = +count3;
  const reverse3 = stop < start3, inc2 = reverse3 ? tickIncrement(stop, start3, count3) : tickIncrement(start3, stop, count3);
  return (reverse3 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);
}

// node_modules/d3-array/src/nice.js
function nice(start3, stop, count3) {
  let prestep;
  while (true) {
    const step = tickIncrement(start3, stop, count3);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start3, stop];
    } else if (step > 0) {
      start3 = Math.floor(start3 / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start3 = Math.ceil(start3 * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values) {
  return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/bin.js
function bin() {
  var value = identity, domain = extent, threshold2 = thresholdSturges;
  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    var i, n = data.length, x4, step, values = new Array(n);
    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }
    var xz = domain(values), x06 = xz[0], x12 = xz[1], tz = threshold2(values, x06, x12);
    if (!Array.isArray(tz)) {
      const max5 = x12, tn = +tz;
      if (domain === extent) [x06, x12] = nice(x06, x12, tn);
      tz = ticks(x06, x12, tn);
      if (tz[0] <= x06) step = tickIncrement(x06, x12, tn);
      if (tz[tz.length - 1] >= x12) {
        if (max5 >= x12 && domain === extent) {
          const step2 = tickIncrement(x06, x12, tn);
          if (isFinite(step2)) {
            if (step2 > 0) {
              x12 = (Math.floor(x12 / step2) + 1) * step2;
            } else if (step2 < 0) {
              x12 = (Math.ceil(x12 * -step2) + 1) / -step2;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m3 = tz.length, a4 = 0, b = m3;
    while (tz[a4] <= x06) ++a4;
    while (tz[b - 1] > x12) --b;
    if (a4 || b < m3) tz = tz.slice(a4, b), m3 = b - a4;
    var bins = new Array(m3 + 1), bin2;
    for (i = 0; i <= m3; ++i) {
      bin2 = bins[i] = [];
      bin2.x0 = i > 0 ? tz[i - 1] : x06;
      bin2.x1 = i < m3 ? tz[i] : x12;
    }
    if (isFinite(step)) {
      if (step > 0) {
        for (i = 0; i < n; ++i) {
          if ((x4 = values[i]) != null && x06 <= x4 && x4 <= x12) {
            bins[Math.min(m3, Math.floor((x4 - x06) / step))].push(data[i]);
          }
        }
      } else if (step < 0) {
        for (i = 0; i < n; ++i) {
          if ((x4 = values[i]) != null && x06 <= x4 && x4 <= x12) {
            const j = Math.floor((x06 - x4) * step);
            bins[Math.min(m3, j + (tz[j] <= x4))].push(data[i]);
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x4 = values[i]) != null && x06 <= x4 && x4 <= x12) {
          bins[bisect_default(tz, x4, 0, m3)].push(data[i]);
        }
      }
    }
    return bins;
  }
  histogram.value = function(_14) {
    return arguments.length ? (value = typeof _14 === "function" ? _14 : constant(_14), histogram) : value;
  };
  histogram.domain = function(_14) {
    return arguments.length ? (domain = typeof _14 === "function" ? _14 : constant([_14[0], _14[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_14) {
    return arguments.length ? (threshold2 = typeof _14 === "function" ? _14 : constant(Array.isArray(_14) ? slice.call(_14) : _14), histogram) : threshold2;
  };
  return histogram;
}

// node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max5;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value;
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value;
      }
    }
  }
  return max5;
}

// node_modules/d3-array/src/maxIndex.js
function maxIndex(values, valueof) {
  let max5;
  let maxIndex2 = -1;
  let index4 = -1;
  if (valueof === void 0) {
    for (const value of values) {
      ++index4;
      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value, maxIndex2 = index4;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value, maxIndex2 = index4;
      }
    }
  }
  return maxIndex2;
}

// node_modules/d3-array/src/min.js
function min(values, valueof) {
  let min4;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  }
  return min4;
}

// node_modules/d3-array/src/minIndex.js
function minIndex(values, valueof) {
  let min4;
  let minIndex2 = -1;
  let index4 = -1;
  if (valueof === void 0) {
    for (const value of values) {
      ++index4;
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index4;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index4;
      }
    }
  }
  return minIndex2;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array5, k2, left3 = 0, right3 = Infinity, compare2) {
  k2 = Math.floor(k2);
  left3 = Math.floor(Math.max(0, left3));
  right3 = Math.floor(Math.min(array5.length - 1, right3));
  if (!(left3 <= k2 && k2 <= right3)) return array5;
  compare2 = compare2 === void 0 ? ascendingDefined : compareDefined(compare2);
  while (right3 > left3) {
    if (right3 - left3 > 600) {
      const n = right3 - left3 + 1;
      const m3 = k2 - left3 + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m3 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left3, Math.floor(k2 - m3 * s2 / n + sd));
      const newRight = Math.min(right3, Math.floor(k2 + (n - m3) * s2 / n + sd));
      quickselect(array5, k2, newLeft, newRight, compare2);
    }
    const t = array5[k2];
    let i = left3;
    let j = right3;
    swap(array5, left3, k2);
    if (compare2(array5[right3], t) > 0) swap(array5, left3, right3);
    while (i < j) {
      swap(array5, i, j), ++i, --j;
      while (compare2(array5[i], t) < 0) ++i;
      while (compare2(array5[j], t) > 0) --j;
    }
    if (compare2(array5[left3], t) === 0) swap(array5, left3, j);
    else ++j, swap(array5, j, right3);
    if (j <= k2) left3 = j + 1;
    if (k2 <= j) right3 = j - 1;
  }
  return array5;
}
function swap(array5, i, j) {
  const t = array5[i];
  array5[i] = array5[j];
  array5[j] = t;
}

// node_modules/d3-array/src/greatest.js
function greatest(values, compare2 = ascending) {
  let max5;
  let defined = false;
  if (compare2.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare2(element);
      if (defined ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
        max5 = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined ? compare2(value, max5) > 0 : compare2(value, value) === 0) {
        max5 = value;
        defined = true;
      }
    }
  }
  return max5;
}

// node_modules/d3-array/src/quantile.js
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return min(values);
  if (p >= 1) return max(values);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p, valueof = number) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}
function quantileIndex(values, p, valueof = number) {
  if (isNaN(p = +p)) return;
  numbers2 = Float64Array.from(values, (_14, i2) => number(valueof(values[i2], i2, values)));
  if (p <= 0) return minIndex(numbers2);
  if (p >= 1) return maxIndex(numbers2);
  var numbers2, index4 = Uint32Array.from(values, (_14, i2) => i2), j = numbers2.length - 1, i = Math.floor(j * p);
  quickselect(index4, i, 0, j, (i2, j2) => ascendingDefined(numbers2[i2], numbers2[j2]));
  i = greatest(index4.subarray(0, i + 1), (i2) => numbers2[i2]);
  return i >= 0 ? i : -1;
}

// node_modules/d3-array/src/threshold/freedmanDiaconis.js
function thresholdFreedmanDiaconis(values, min4, max5) {
  const c6 = count(values), d = quantile(values, 0.75) - quantile(values, 0.25);
  return c6 && d ? Math.ceil((max5 - min4) / (2 * d * Math.pow(c6, -1 / 3))) : 1;
}

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values, min4, max5) {
  const c6 = count(values), d = deviation(values);
  return c6 && d ? Math.ceil((max5 - min4) * Math.cbrt(c6) / (3.49 * d)) : 1;
}

// node_modules/d3-array/src/mean.js
function mean(values, valueof) {
  let count3 = 0;
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count3, sum4 += value;
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null && (value = +value) >= value) {
        ++count3, sum4 += value;
      }
    }
  }
  if (count3) return sum4 / count3;
}

// node_modules/d3-array/src/median.js
function median(values, valueof) {
  return quantile(values, 0.5, valueof);
}
function medianIndex(values, valueof) {
  return quantileIndex(values, 0.5, valueof);
}

// node_modules/d3-array/src/merge.js
function* flatten2(arrays) {
  for (const array5 of arrays) {
    yield* array5;
  }
}
function merge(arrays) {
  return Array.from(flatten2(arrays));
}

// node_modules/d3-array/src/mode.js
function mode(values, valueof) {
  const counts = new InternMap();
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index4, values)) != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  }
  let modeValue;
  let modeCount = 0;
  for (const [value, count3] of counts) {
    if (count3 > modeCount) {
      modeCount = count3;
      modeValue = value;
    }
  }
  return modeValue;
}

// node_modules/d3-array/src/pairs.js
function pairs(values, pairof = pair) {
  const pairs2 = [];
  let previous;
  let first = false;
  for (const value of values) {
    if (first) pairs2.push(pairof(previous, value));
    previous = value;
    first = true;
  }
  return pairs2;
}
function pair(a4, b) {
  return [a4, b];
}

// node_modules/d3-array/src/range.js
function range(start3, stop, step) {
  start3 = +start3, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start3, start3 = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start3) / step)) | 0, range4 = new Array(n);
  while (++i < n) {
    range4[i] = start3 + i * step;
  }
  return range4;
}

// node_modules/d3-array/src/rank.js
function rank(values, valueof = ascending) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  let V = Array.from(values);
  const R = new Float64Array(V.length);
  if (valueof.length !== 2) V = V.map(valueof), valueof = ascending;
  const compareIndex = (i, j) => valueof(V[i], V[j]);
  let k2, r;
  values = Uint32Array.from(V, (_14, i) => i);
  values.sort(valueof === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));
  values.forEach((j, i) => {
    const c6 = compareIndex(j, k2 === void 0 ? j : k2);
    if (c6 >= 0) {
      if (k2 === void 0 || c6 > 0) k2 = j, r = i;
      R[j] = r;
    } else {
      R[j] = NaN;
    }
  });
  return R;
}

// node_modules/d3-array/src/least.js
function least(values, compare2 = ascending) {
  let min4;
  let defined = false;
  if (compare2.length === 1) {
    let minValue;
    for (const element of values) {
      const value = compare2(element);
      if (defined ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
        min4 = element;
        minValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined ? compare2(value, min4) < 0 : compare2(value, value) === 0) {
        min4 = value;
        defined = true;
      }
    }
  }
  return min4;
}

// node_modules/d3-array/src/leastIndex.js
function leastIndex(values, compare2 = ascending) {
  if (compare2.length === 1) return minIndex(values, compare2);
  let minValue;
  let min4 = -1;
  let index4 = -1;
  for (const value of values) {
    ++index4;
    if (min4 < 0 ? compare2(value, value) === 0 : compare2(value, minValue) < 0) {
      minValue = value;
      min4 = index4;
    }
  }
  return min4;
}

// node_modules/d3-array/src/greatestIndex.js
function greatestIndex(values, compare2 = ascending) {
  if (compare2.length === 1) return maxIndex(values, compare2);
  let maxValue;
  let max5 = -1;
  let index4 = -1;
  for (const value of values) {
    ++index4;
    if (max5 < 0 ? compare2(value, value) === 0 : compare2(value, maxValue) > 0) {
      maxValue = value;
      max5 = index4;
    }
  }
  return max5;
}

// node_modules/d3-array/src/scan.js
function scan(values, compare2) {
  const index4 = leastIndex(values, compare2);
  return index4 < 0 ? void 0 : index4;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle2(array5, i0 = 0, i1 = array5.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i = random() * m3-- | 0, t = array5[m3 + i0];
      array5[m3 + i0] = array5[i + i0];
      array5[i + i0] = t;
    }
    return array5;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values, valueof) {
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        sum4 += value;
      }
    }
  } else {
    let index4 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index4, values)) {
        sum4 += value;
      }
    }
  }
  return sum4;
}

// node_modules/d3-array/src/transpose.js
function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m3 = min(matrix, length2), transpose2 = new Array(m3); ++i < m3; ) {
    for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {
      row[j] = matrix[j][i];
    }
  }
  return transpose2;
}
function length2(d) {
  return d.length;
}

// node_modules/d3-array/src/zip.js
function zip() {
  return transpose(arguments);
}

// node_modules/d3-array/src/every.js
function every(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  let index4 = -1;
  for (const value of values) {
    if (!test(value, ++index4, values)) {
      return false;
    }
  }
  return true;
}

// node_modules/d3-array/src/some.js
function some(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  let index4 = -1;
  for (const value of values) {
    if (test(value, ++index4, values)) {
      return true;
    }
  }
  return false;
}

// node_modules/d3-array/src/filter.js
function filter(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  const array5 = [];
  let index4 = -1;
  for (const value of values) {
    if (test(value, ++index4, values)) {
      array5.push(value);
    }
  }
  return array5;
}

// node_modules/d3-array/src/map.js
function map3(values, mapper) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
  return Array.from(values, (value, index4) => mapper(value, index4, values));
}

// node_modules/d3-array/src/reduce.js
function reduce(values, reducer2, value) {
  if (typeof reducer2 !== "function") throw new TypeError("reducer is not a function");
  const iterator = values[Symbol.iterator]();
  let done, next, index4 = -1;
  if (arguments.length < 3) {
    ({ done, value } = iterator.next());
    if (done) return;
    ++index4;
  }
  while ({ done, value: next } = iterator.next(), !done) {
    value = reducer2(value, next, ++index4, values);
  }
  return value;
}

// node_modules/d3-array/src/reverse.js
function reverse2(values) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  return Array.from(values).reverse();
}

// node_modules/d3-array/src/difference.js
function difference(values, ...others) {
  values = new InternSet(values);
  for (const other of others) {
    for (const value of other) {
      values.delete(value);
    }
  }
  return values;
}

// node_modules/d3-array/src/disjoint.js
function disjoint(values, other) {
  const iterator = other[Symbol.iterator](), set7 = new InternSet();
  for (const v2 of values) {
    if (set7.has(v2)) return false;
    let value, done;
    while ({ value, done } = iterator.next()) {
      if (done) break;
      if (Object.is(v2, value)) return false;
      set7.add(value);
    }
  }
  return true;
}

// node_modules/d3-array/src/intersection.js
function intersection(values, ...others) {
  values = new InternSet(values);
  others = others.map(set4);
  out: for (const value of values) {
    for (const other of others) {
      if (!other.has(value)) {
        values.delete(value);
        continue out;
      }
    }
  }
  return values;
}
function set4(values) {
  return values instanceof InternSet ? values : new InternSet(values);
}

// node_modules/d3-array/src/superset.js
function superset(values, other) {
  const iterator = values[Symbol.iterator](), set7 = /* @__PURE__ */ new Set();
  for (const o of other) {
    const io = intern(o);
    if (set7.has(io)) continue;
    let value, done;
    while ({ value, done } = iterator.next()) {
      if (done) return false;
      const ivalue = intern(value);
      set7.add(ivalue);
      if (Object.is(io, ivalue)) break;
    }
  }
  return true;
}
function intern(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/subset.js
function subset(values, other) {
  return superset(other, values);
}

// node_modules/d3-array/src/union.js
function union(...others) {
  const set7 = new InternSet();
  for (const other of others) {
    for (const o of other) {
      set7.add(o);
    }
  }
  return set7;
}

// node_modules/d3-axis/src/identity.js
function identity_default(x4) {
  return x4;
}

// node_modules/d3-axis/src/axis.js
var top2 = 1;
var right2 = 2;
var bottom2 = 3;
var left2 = 4;
var epsilon = 1e-6;
function translateX(x4) {
  return "translate(" + x4 + ",0)";
}
function translateY(y4) {
  return "translate(0," + y4 + ")";
}
function number2(scale2) {
  return (d) => +scale2(d);
}
function center(scale2, offset3) {
  offset3 = Math.max(0, scale2.bandwidth() - offset3 * 2) / 2;
  if (scale2.round()) offset3 = Math.round(offset3);
  return (d) => +scale2(d) + offset3;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale2) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset3 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top2 || orient === left2 ? -1 : 1, x4 = orient === left2 || orient === right2 ? "x" : "y", transform2 = orient === top2 || orient === bottom2 ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale2.ticks ? scale2.ticks.apply(scale2, tickArguments) : scale2.domain() : tickValues, format3 = tickFormat2 == null ? scale2.tickFormat ? scale2.tickFormat.apply(scale2, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range4 = scale2.range(), range0 = +range4[0] + offset3, range1 = +range4[range4.length - 1] + offset3, position = (scale2.bandwidth ? center : number2)(scale2.copy(), offset3), selection2 = context.selection ? context.selection() : context, path3 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values, scale2).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
    path3 = path3.merge(path3.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x4 + "2", k2 * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x4, k2 * spacing).attr("dy", orient === top2 ? "0em" : orient === bottom2 ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path3 = path3.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform2(d + offset3) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2((p && isFinite(p = p(d)) ? p : position(d)) + offset3);
      });
    }
    tickExit.remove();
    path3.attr("d", orient === left2 || orient === right2 ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset3 + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset3 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset3 + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset3 + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position(d) + offset3);
    });
    line.attr(x4 + "2", k2 * tickSizeInner);
    text.attr(x4, k2 * spacing).text(format3);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right2 ? "start" : orient === left2 ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_14) {
    return arguments.length ? (scale2 = _14, axis2) : scale2;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_14) {
    return arguments.length ? (tickArguments = _14 == null ? [] : Array.from(_14), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_14) {
    return arguments.length ? (tickValues = _14 == null ? null : Array.from(_14), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_14) {
    return arguments.length ? (tickFormat2 = _14, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_14) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_14, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_14) {
    return arguments.length ? (tickSizeInner = +_14, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_14) {
    return arguments.length ? (tickSizeOuter = +_14, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_14) {
    return arguments.length ? (tickPadding = +_14, axis2) : tickPadding;
  };
  axis2.offset = function(_14) {
    return arguments.length ? (offset3 = +_14, axis2) : offset3;
  };
  return axis2;
}
function axisTop(scale2) {
  return axis(top2, scale2);
}
function axisRight(scale2) {
  return axis(right2, scale2);
}
function axisBottom(scale2) {
  return axis(bottom2, scale2);
}
function axisLeft(scale2) {
  return axis(left2, scale2);
}

// node_modules/d3-dispatch/src/dispatch.js
var noop3 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _14 = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _14 || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _14[t] = [];
  }
  return new Dispatch(_14);
}
function Dispatch(_14) {
  this._ = _14;
}
function parseTypenames(typenames, types2) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types2.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _14 = this._, T = parseTypenames(typename + "", _14), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get3(_14[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _14[t] = set5(_14[t], typename.name, callback);
      else if (callback == null) for (t in _14) _14[t] = set5(_14[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy3 = {}, _14 = this._;
    for (var t in _14) copy3[t] = _14[t].slice();
    return new Dispatch(copy3);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get3(type2, name) {
  for (var i = 0, n = type2.length, c6; i < n; ++i) {
    if ((c6 = type2[i]).name === name) {
      return c6.value;
    }
  }
}
function set5(type2, name, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop3, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null) type2.push({ name, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function") select = selector_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group2[i]) && (subnode = select.call(node, node.__data__, i, group2))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array3(x4) {
  return x4 == null ? [] : Array.isArray(x4) ? x4 : Array.from(x4);
}

// node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array3(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, node, i = 0; i < n; ++i) {
      if (node = group2[i]) {
        subgroups.push(select.call(node, node.__data__, i, group2));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find2 = Array.prototype.find;
function childFind(match) {
  return function() {
    return find2.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter2 = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter2.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group2[i]) && match.call(node, node.__data__, i, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update2) {
  return new Array(update2.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group2, enter, update2, exit, data) {
  var i = 0, node, groupLength = group2.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group2[i]) {
      node.__data__ = data[i];
      update2[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group2[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group2, enter, update2, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group2.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group2[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group2) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update2[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group2[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value !== "function") value = constant_default(value);
  for (var m3 = groups2.length, update2 = new Array(m3), enter = new Array(m3), exit = new Array(m3), j = 0; j < m3; ++j) {
    var parent = parents[j], group2 = groups2[j], groupLength = group2.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group2, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update2 = new Selection(update2, parents);
  update2._enter = enter;
  update2._exit = exit;
  return update2;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update2 = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update2 = onupdate(update2);
    if (update2) update2 = update2.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update2 ? enter.merge(update2).order() : update2;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups2 = this._groups, j = -1, m3 = groups2.length; ++j < m3; ) {
    for (var group2 = groups2[j], i = group2.length - 1, next = group2[i], node; --i >= 0; ) {
      if (node = group2[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare2) {
  if (!compare2) compare2 = ascending2;
  function compareNode(a4, b) {
    return a4 && b ? compare2(a4.__data__, b.__data__) : !a4 - !b;
  }
  for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group2[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a4, b) {
  return a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
    for (var group2 = groups2[j], i = 0, n = group2.length; i < n; ++i) {
      var node = group2[i];
      if (node) return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this) ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
    for (var group2 = groups2[j], i = 0, n = group2.length, node; i < n; ++i) {
      if (node = group2[i]) callback.call(node, node.__data__, i, group2);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) this.removeAttribute(name);
    else this.setAttribute(name, v2);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v2, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) delete this[name];
    else this[name] = v2;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove2() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function remove_default() {
  return this.each(remove2);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m3 = on.length, o; j < m3; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m3 = on.length; j < m3; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on) this.__on = [o];
    else on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m3 = on.length, o; j < m3; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
    for (var group2 = groups2[j], i = 0, n = group2.length, node; i < n; ++i) {
      if (node = group2[i]) yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/create.js
function create_default(name) {
  return select_default2(creator_default(name).call(document.documentElement));
}

// node_modules/d3-selection/src/local.js
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id2 = this._;
    while (!(id2 in node)) if (!(node = node.parentNode)) return;
    return node[id2];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0) node = event.currentTarget;
  if (node) {
    var svg2 = node.ownerSVGElement || node;
    if (svg2.createSVGPoint) {
      var point7 = svg2.createSVGPoint();
      point7.x = event.clientX, point7.y = event.clientY;
      point7 = point7.matrixTransform(node.getScreenCTM().inverse());
      return [point7.x, point7.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/d3-selection/src/pointers.js
function pointers_default(events, node) {
  if (events.target) {
    events = sourceEvent_default(events);
    if (node === void 0) node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, (event) => pointer_default(event, node));
}

// node_modules/d3-selection/src/selectAll.js
function selectAll_default2(selector) {
  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array3(selector)], root);
}

// node_modules/d3-drag/src/noevent.js
var nonpassive = { passive: false };
var nonpassivecapture = { capture: true, passive: false };
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root3.__noselect = root3.style.MozUserSelect;
    root3.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", null);
  } else {
    root3.style.MozUserSelect = root3.__noselect;
    delete root3.__noselect;
  }
}

// node_modules/d3-drag/src/constant.js
var constant_default2 = (x4) => () => x4;

// node_modules/d3-drag/src/event.js
function DragEvent(type2, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x: x4,
  y: y4,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x4, enumerable: true, configurable: true },
    y: { value: y4, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// node_modules/d3-drag/src/drag.js
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d) {
  return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter3 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (touchending || !filter3.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag_default(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent_default(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select_default2(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent_default(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (!filter3.call(this, event, d)) return;
    var touches = event.changedTouches, c6 = container.call(this, event, d), n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c6, event, d, touches[i].identifier, touches[i])) {
        nopropagation(event);
        gesture("start", event, touches[i]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent_default(event);
        gesture("drag", event, touches[i]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i]);
      }
    }
  }
  function beforestart(that, container2, event, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s2;
    if ((s2 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) == null) return;
    dx = s2.x - p[0] || 0;
    dy = s2.y - p[1] || 0;
    return function gesture(type2, event2, touch2) {
      var p02 = p, n;
      switch (type2) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        case "drag":
          p = pointer_default(touch2 || event2, container2), n = active;
          break;
      }
      dispatch2.call(
        type2,
        that,
        new DragEvent(type2, {
          sourceEvent: event2,
          subject: s2,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p02[0],
          dy: p[1] - p02[1],
          dispatch: dispatch2
        }),
        d
      );
    };
  }
  drag.filter = function(_14) {
    return arguments.length ? (filter3 = typeof _14 === "function" ? _14 : constant_default2(!!_14), drag) : filter3;
  };
  drag.container = function(_14) {
    return arguments.length ? (container = typeof _14 === "function" ? _14 : constant_default2(_14), drag) : container;
  };
  drag.subject = function(_14) {
    return arguments.length ? (subject = typeof _14 === "function" ? _14 : constant_default2(_14), drag) : subject;
  };
  drag.touchable = function(_14) {
    return arguments.length ? (touchable = typeof _14 === "function" ? _14 : constant_default2(!!_14), drag) : touchable;
  };
  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };
  drag.clickDistance = function(_14) {
    return arguments.length ? (clickDistance2 = (_14 = +_14) * _14, drag) : Math.sqrt(clickDistance2);
  };
  return drag;
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m3, l;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a4) {
  if (a4 <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a4);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a4 = clampa(this.opacity);
  return `${a4 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? ")" : `, ${a4})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a4) {
  if (a4 <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a4);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max5 = Math.max(r, g, b), h = NaN, s2 = max5 - min4, l = (max5 + min4) / 2;
  if (s2) {
    if (r === max5) h = (g - b) / s2 + (g < b) * 6;
    else if (g === max5) h = (b - r) / s2 + 2;
    else h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max5 + min4 : 2 - max5 - min4;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m22;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),
      hsl2rgb(h, m1, m22),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a4 = clampa(this.opacity);
    return `${a4 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? ")" : `, ${a4})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m22) {
  return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y4 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x4, z;
  if (r === g && g === b) x4 = z = y4;
  else {
    x4 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y4 - 16, 500 * (x4 - y4), 200 * (y4 - z), o.opacity);
}
function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}
function lab(l, a4, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a4, b, opacity == null ? 1 : opacity);
}
function Lab(l, a4, b, opacity) {
  this.l = +l;
  this.a = +a4;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y4 = (this.l + 16) / 116, x4 = isNaN(this.a) ? y4 : y4 + this.a / 500, z = isNaN(this.b) ? y4 : y4 - this.b / 200;
    x4 = Xn * lab2xyz(x4);
    y4 = Yn * lab2xyz(y4);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x4 - 1.6168667 * y4 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x4 + 1.9161415 * y4 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x4 - 0.2289914 * y4 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x4) {
  return 255 * (x4 <= 31308e-7 ? 12.92 * x4 : 1.055 * Math.pow(x4, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x4) {
  return (x4 /= 255) <= 0.04045 ? x4 / 12.92 : Math.pow((x4 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function lch(l, c6, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c6, l, opacity == null ? 1 : opacity);
}
function hcl(h, c6, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c6, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c6, l, opacity) {
  this.h = +h;
  this.c = +c6;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a4 * (A * cosh2 + B * sinh2)),
      255 * (l + a4 * (C * cosh2 + D * sinh2)),
      255 * (l + a4 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x4) => () => x4;

// node_modules/d3-interpolate/src/color.js
function linear(a4, d) {
  return function(t) {
    return a4 + t * d;
  };
}
function exponential(a4, b, y4) {
  return a4 = Math.pow(a4, y4), b = Math.pow(b, y4) - a4, y4 = 1 / y4, function(t) {
    return Math.pow(a4 + t * b, y4);
  };
}
function hue(a4, b) {
  var d = b - a4;
  return d ? linear(a4, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a4) ? b : a4);
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a4, b) {
    return b - a4 ? exponential(a4, b, y4) : constant_default3(isNaN(a4) ? b : a4);
  };
}
function nogamma(a4, b) {
  var d = b - a4;
  return d ? linear(a4, d) : constant_default3(isNaN(a4) ? b : a4);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y4) {
  var color2 = gamma(y4);
  function rgb2(start3, end2) {
    var r = color2((start3 = rgb(start3)).r, (end2 = rgb(end2)).r), g = color2(start3.g, end2.g), b = color2(start3.b, end2.b), opacity = nogamma(start3.opacity, end2.opacity);
    return function(t) {
      start3.r = r(t);
      start3.g = g(t);
      start3.b = b(t);
      start3.opacity = opacity(t);
      return start3 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a4, b) {
  if (!b) b = [];
  var n = a4 ? Math.min(b.length, a4.length) : 0, c6 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c6[i] = a4[i] * (1 - t) + b[i] * t;
    return c6;
  };
}
function isNumberArray(x4) {
  return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function array_default(a4, b) {
  return (isNumberArray(b) ? numberArray_default : genericArray)(a4, b);
}
function genericArray(a4, b) {
  var nb = b ? b.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x4 = new Array(na), c6 = new Array(nb), i;
  for (i = 0; i < na; ++i) x4[i] = value_default(a4[i], b[i]);
  for (; i < nb; ++i) c6[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c6[i] = x4[i](t);
    return c6;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a4, b) {
  var d = /* @__PURE__ */ new Date();
  return a4 = +a4, b = +b, function(t) {
    return d.setTime(a4 * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a4, b) {
  return a4 = +a4, b = +b, function(t) {
    return a4 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a4, b) {
  var i = {}, c6 = {}, k2;
  if (a4 === null || typeof a4 !== "object") a4 = {};
  if (b === null || typeof b !== "object") b = {};
  for (k2 in b) {
    if (k2 in a4) {
      i[k2] = value_default(a4[k2], b[k2]);
    } else {
      c6[k2] = b[k2];
    }
  }
  return function(t) {
    for (k2 in i) c6[k2] = i[k2](t);
    return c6;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a4, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a4 = a4 + "", b = b + "";
  while ((am = reA.exec(a4)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i]) s2[i] += bs;
      else s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i]) s2[i] += bm;
      else s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i]) s2[i] += bs;
    else s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a4, b) {
  var t = typeof b, c6;
  return b == null || t === "boolean" ? constant_default3(b) : (t === "number" ? number_default : t === "string" ? (c6 = color(b)) ? (b = c6, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a4, b);
}

// node_modules/d3-interpolate/src/discrete.js
function discrete_default(range4) {
  var n = range4.length;
  return function(t) {
    return range4[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

// node_modules/d3-interpolate/src/hue.js
function hue_default(a4, b) {
  var i = hue(+a4, +b);
  return function(t) {
    var x4 = i(t);
    return x4 - 360 * Math.floor(x4 / 360);
  };
}

// node_modules/d3-interpolate/src/round.js
function round_default(a4, b) {
  return a4 = +a4, b = +b, function(t) {
    return Math.round(a4 * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a4, b, c6, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a4 * a4 + b * b)) a4 /= scaleX, b /= scaleX;
  if (skewX = a4 * c6 + b * d) c6 -= a4 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c6 * c6 + d * d)) c6 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a4 * d < b * c6) a4 = -a4, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a4) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value) {
  if (value == null) return identity2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity2;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop2(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a4, b, s2, q) {
    if (a4 !== b) {
      if (a4 - b > 180) b += 360;
      else if (b - a4 > 180) a4 += 360;
      q.push({ i: s2.push(pop2(s2) + "rotate(", null, degParen) - 2, x: number_default(a4, b) });
    } else if (b) {
      s2.push(pop2(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a4, b, s2, q) {
    if (a4 !== b) {
      q.push({ i: s2.push(pop2(s2) + "skewX(", null, degParen) - 2, x: number_default(a4, b) });
    } else if (b) {
      s2.push(pop2(s2) + "skewX(" + b + degParen);
    }
  }
  function scale2(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop2(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop2(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a4, b) {
    var s2 = [], q = [];
    a4 = parse(a4), b = parse(b);
    translate(a4.translateX, a4.translateY, b.translateX, b.translateY, s2, q);
    rotate(a4.rotate, b.rotate, s2, q);
    skewX(a4.skewX, b.skewX, s2, q);
    scale2(a4.scaleX, a4.scaleY, b.scaleX, b.scaleY, s2, q);
    a4 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x4) {
  return ((x4 = Math.exp(x4)) + 1 / x4) / 2;
}
function sinh(x4) {
  return ((x4 = Math.exp(x4)) - 1 / x4) / 2;
}
function tanh(x4) {
  return ((x4 = Math.exp(2 * x4)) - 1) / (x4 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p02, p1) {
    var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s2 = t * S, coshr0 = cosh(r0), u4 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u4 * dx,
          uy0 + u4 * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_14) {
    var _1 = Math.max(1e-3, +_14), _22 = _1 * _1, _42 = _22 * _22;
    return zoomRho(_1, _22, _42);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start3, end2) {
    var h = hue2((start3 = hsl(start3)).h, (end2 = hsl(end2)).h), s2 = nogamma(start3.s, end2.s), l = nogamma(start3.l, end2.l), opacity = nogamma(start3.opacity, end2.opacity);
    return function(t) {
      start3.h = h(t);
      start3.s = s2(t);
      start3.l = l(t);
      start3.opacity = opacity(t);
      return start3 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/lab.js
function lab2(start3, end2) {
  var l = nogamma((start3 = lab(start3)).l, (end2 = lab(end2)).l), a4 = nogamma(start3.a, end2.a), b = nogamma(start3.b, end2.b), opacity = nogamma(start3.opacity, end2.opacity);
  return function(t) {
    start3.l = l(t);
    start3.a = a4(t);
    start3.b = b(t);
    start3.opacity = opacity(t);
    return start3 + "";
  };
}

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start3, end2) {
    var h = hue2((start3 = hcl(start3)).h, (end2 = hcl(end2)).h), c6 = nogamma(start3.c, end2.c), l = nogamma(start3.l, end2.l), opacity = nogamma(start3.opacity, end2.opacity);
    return function(t) {
      start3.h = h(t);
      start3.c = c6(t);
      start3.l = l(t);
      start3.opacity = opacity(t);
      return start3 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y4) {
    y4 = +y4;
    function cubehelix3(start3, end2) {
      var h = hue2((start3 = cubehelix(start3)).h, (end2 = cubehelix(end2)).h), s2 = nogamma(start3.s, end2.s), l = nogamma(start3.l, end2.l), opacity = nogamma(start3.opacity, end2.opacity);
      return function(t) {
        start3.h = h(t);
        start3.s = s2(t);
        start3.l = l(Math.pow(t, y4));
        start3.opacity = opacity(t);
        return start3 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate, values) {
  if (values === void 0) values = interpolate, interpolate = value_default;
  var i = 0, n = values.length - 1, v2 = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v2, v2 = values[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}

// node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t = new Timer();
  t.restart(callback, delay, time2);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t03, t13 = taskHead, t22, time2 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time2 > t13._time) time2 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t22 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t22 : taskHead = t22;
    }
  }
  taskTail = t03;
  sleep(time2);
}
function sleep(time2) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity) timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t;
}

// node_modules/d3-timer/src/interval.js
function interval_default(callback, delay, time2) {
  var t = new Timer(), total = delay;
  if (delay == null) return t.restart(callback, delay, time2), t;
  t._restart = t.restart;
  t.restart = function(callback2, delay2, time3) {
    delay2 = +delay2, time3 = time3 == null ? now() : +time3;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay2, time3);
      callback2(elapsed);
    }, delay2, time3);
  };
  t.restart(callback, delay, time2);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index4, group2, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id2 in schedules) return;
  create(node, id2, {
    name,
    index: index4,
    // For context during callback.
    group: group2,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get4(node, id2);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set6(node, id2) {
  var schedule = get4(node, id2);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get4(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start3, self2.delay, self2.time);
    if (self2.delay <= elapsed) start3(elapsed - self2.delay);
  }
  function start3(elapsed) {
    var i, j, n, o;
    if (self2.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name) continue;
      if (o.state === STARTED) return timeout_default(start3);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING) return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules) return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty4 = true, i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty4 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty4) delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set6(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule = set6(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get4(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set6(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get4(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a4, b) {
  var c6;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c6 = color(b)) ? (b = c6, rgb_default) : string_default)(a4, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t03, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t03 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t03, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t03 = (i0 = i) && attrInterpolate(name, i);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get4(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set6(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set6(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get4(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set6(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get4(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 !== "function") throw new Error();
    set6(this, id2).ease = v2;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group2[i]) && match.call(node, node.__data__, i, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start2(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start2(name) ? init : set6;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get4(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id2) return;
    if (parent) parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selector_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group2[i]) && (subnode = select.call(node, node.__data__, i, group2))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get4(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selectorAll_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, node, i = 0; i < n; ++i) {
      if (node = group2[i]) {
        for (var children2 = select.call(node, node.__data__, i, group2), child, inherit3 = get4(node, id2), k2 = 0, l = children2.length; k2 < l; ++k2) {
          if (child = children2[k2]) {
            schedule_default(child, name, id2, k2, children2, inherit3);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove3;
  return function() {
    var schedule = set6(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove3 || (remove3 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t03, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t03 = (i0 = i) && textInterpolate(i);
    return t03;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, node, i = 0; i < n; ++i) {
      if (node = group2[i]) {
        var inherit3 = get4(node, id0);
        schedule_default(node, name, id1, i, group2, {
          time: inherit3.time + inherit3.delay + inherit3.duration,
          delay: 0,
          duration: inherit3.duration,
          ease: inherit3.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end2 = { value: function() {
      if (--size === 0) resolve();
    } };
    that.each(function() {
      var schedule = set6(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end2);
      }
      schedule.on = on1;
    });
    if (size === 0) resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups2, parents, name, id2) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/linear.js
var linear2 = (t) => +t;

// node_modules/d3-ease/src/quad.js
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

// node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;
function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

// node_modules/d3-ease/src/math.js
function tpmt(x4) {
  return (Math.pow(2, -10 * x4) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/exp.js
function expIn(t) {
  return tpmt(1 - +t);
}
function expOut(t) {
  return 1 - tpmt(t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}

// node_modules/d3-ease/src/circle.js
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s2) {
  s2 = +s2;
  function backIn2(t) {
    return (t = +t) * t * (s2 * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s2) {
  s2 = +s2;
  function backOut2(t) {
    return --t * t * ((t + 1) * s2 + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s2) {
  s2 = +s2;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s2 + 1) * t - s2) : (t -= 2) * t * ((s2 + 1) * t + s2) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a4, p) {
  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);
  function elasticIn2(t) {
    return a4 * tpmt(- --t) * Math.sin((s2 - t) / p);
  }
  elasticIn2.amplitude = function(a5) {
    return custom7(a5, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a4, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a4, p) {
  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a4 * tpmt(t = +t) * Math.sin((t + s2) / p);
  }
  elasticOut2.amplitude = function(a5) {
    return custom8(a5, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a4, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a4, p) {
  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a4 * tpmt(-t) * Math.sin((s2 - t) / p) : 2 - a4 * tpmt(t) * Math.sin((s2 + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a5) {
    return custom9(a5, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a4, p2);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit2(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, node, i = 0; i < n; ++i) {
      if (node = group2[i]) {
        schedule_default(node, name, id2, i, group2, timing || inherit2(node, id2));
      }
    }
  }
  return new Transition(groups2, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-transition/src/active.js
var root2 = [null];
function active_default(node, name) {
  var schedules = node.__transition, schedule, i;
  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root2, name, +i);
      }
    }
  }
  return null;
}

// node_modules/d3-brush/src/constant.js
var constant_default4 = (x4) => () => x4;

// node_modules/d3-brush/src/event.js
function BrushEvent(type2, {
  sourceEvent,
  target,
  selection: selection2,
  mode: mode2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    selection: { value: selection2, enumerable: true, configurable: true },
    mode: { value: mode2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/d3-brush/src/noevent.js
function nopropagation2(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-brush/src/brush.js
var MODE_DRAG = { name: "drag" };
var MODE_SPACE = { name: "space" };
var MODE_HANDLE = { name: "handle" };
var MODE_CENTER = { name: "center" };
var { abs, max: max2, min: min2 } = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number22(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x4, e) {
    return x4 == null ? null : [[+x4[0], e[0][1]], [+x4[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y4, e) {
    return y4 == null ? null : [[e[0][0], +y4[0]], [e[1][0], +y4[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number22(xy);
  },
  output: function(xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
};
var signsY = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function type(t) {
  return { type: t };
}
function defaultFilter2(event) {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var svg2 = this.ownerSVGElement || this;
  if (svg2.hasAttribute("viewBox")) {
    svg2 = svg2.viewBox.baseVal;
    return [[svg2.x, svg2.y], [svg2.x + svg2.width, svg2.y + svg2.height]];
  }
  return [[0, 0], [svg2.width.baseVal.value, svg2.height.baseVal.value]];
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local2(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}
function empty3(extent2) {
  return extent2[0][0] === extent2[1][0] || extent2[0][1] === extent2[1][1];
}
function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}
function brushX() {
  return brush(X);
}
function brushY() {
  return brush(Y);
}
function brush_default() {
  return brush(XY);
}
function brush(dim) {
  var extent2 = defaultExtent, filter3 = defaultFilter2, touchable = defaultTouchable2, keys = true, listeners = dispatch_default("start", "brush", "end"), handleSize = 6, touchending;
  function brush2(group2) {
    var overlay = group2.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent3 = local2(this).extent;
      select_default2(this).attr("x", extent3[0][0]).attr("y", extent3[0][1]).attr("width", extent3[1][0] - extent3[0][0]).attr("height", extent3[1][1] - extent3[0][1]);
    });
    group2.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group2.selectAll(".handle").data(dim.handles, function(d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function(d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function(d) {
      return cursors[d.type];
    });
    group2.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush2.move = function(group2, selection2, event) {
    if (group2.tween) {
      group2.on("start.brush", function(event2) {
        emitter(this, arguments).beforestart().start(event2);
      }).on("interrupt.brush end.brush", function(event2) {
        emitter(this, arguments).end(event2);
      }).tween("brush", function() {
        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i = value_default(selection0, selection1);
        function tween(t) {
          state.selection = t === 1 && selection1 === null ? null : i(t);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group2.each(function() {
        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
        interrupt_default(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start(event).brush(event).end(event);
      });
    }
  };
  brush2.clear = function(group2, event) {
    brush2.move(group2, null, event);
  };
  function redraw() {
    var group2 = select_default2(this), selection2 = local2(this).selection;
    if (selection2) {
      group2.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
      group2.selectAll(".handle").style("display", null).attr("x", function(d) {
        return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
      }).attr("y", function(d) {
        return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
      }).attr("width", function(d) {
        return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
      }).attr("height", function(d) {
        return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
      });
    } else {
      group2.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function(event, mode2) {
      if (this.starting) this.starting = false, this.emit("start", event, mode2);
      else this.emit("brush", event);
      return this;
    },
    brush: function(event, mode2) {
      this.emit("brush", event, mode2);
      return this;
    },
    end: function(event, mode2) {
      if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode2);
      return this;
    },
    emit: function(type2, event, mode2) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type2,
        this.that,
        new BrushEvent(type2, {
          sourceEvent: event,
          target: brush2,
          selection: dim.output(this.state.selection),
          mode: mode2,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function started(event) {
    if (touchending && !event.touches) return;
    if (!filter3.apply(this, arguments)) return;
    var that = this, type2 = event.target.__data__.type, mode2 = (keys && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local2(that), extent3 = state.extent, selection2 = state.selection, W = extent3[0][0], w0, w1, N = extent3[0][1], n0, n1, E2 = extent3[1][0], e0, e1, S = extent3[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t) => {
      const i = t.identifier;
      t = pointer_default(t, that);
      t.point0 = t.slice();
      t.identifier = i;
      return t;
    });
    interrupt_default(that);
    var emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection2) moving = true;
      const pts = [points[0], points[1] || points[0]];
      state.selection = selection2 = [[
        w0 = dim === Y ? W : min2(pts[0][0], pts[1][0]),
        n0 = dim === X ? N : min2(pts[0][1], pts[1][1])
      ], [
        e0 = dim === Y ? E2 : max2(pts[0][0], pts[1][0]),
        s0 = dim === X ? S : max2(pts[0][1], pts[1][1])
      ]];
      if (points.length > 1) move(event);
    } else {
      w0 = selection2[0][0];
      n0 = selection2[0][1];
      e0 = selection2[1][0];
      s0 = selection2[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group2 = select_default2(that).attr("pointer-events", "none");
    var overlay = group2.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select_default2(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys) view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      nodrag_default(event.view);
    }
    redraw.call(that);
    emit.start(event, mode2.name);
    function moved(event2) {
      for (const p of event2.changedTouches || [event2]) {
        for (const d of points)
          if (d.identifier === p.identifier) d.cur = pointer_default(p, that);
      }
      if (shifting && !lockX && !lockY && points.length === 1) {
        const point7 = points[0];
        if (abs(point7.cur[0] - point7[0]) > abs(point7.cur[1] - point7[1]))
          lockY = true;
        else
          lockX = true;
      }
      for (const point7 of points)
        if (point7.cur) point7[0] = point7.cur[0], point7[1] = point7.cur[1];
      moving = true;
      noevent_default2(event2);
      move(event2);
    }
    function move(event2) {
      const point7 = points[0], point0 = point7.point0;
      var t;
      dx = point7[0] - point0[0];
      dy = point7[1] - point0[1];
      switch (mode2) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = max2(W - w0, min2(E2 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = max2(N - n0, min2(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (points[1]) {
            if (signX) w1 = max2(W, min2(E2, points[0][0])), e1 = max2(W, min2(E2, points[1][0])), signX = 1;
            if (signY) n1 = max2(N, min2(S, points[0][1])), s1 = max2(N, min2(S, points[1][1])), signY = 1;
          } else {
            if (signX < 0) dx = max2(W - w0, min2(E2 - w0, dx)), w1 = w0 + dx, e1 = e0;
            else if (signX > 0) dx = max2(W - e0, min2(E2 - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0) dy = max2(N - n0, min2(S - n0, dy)), n1 = n0 + dy, s1 = s0;
            else if (signY > 0) dy = max2(N - s0, min2(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          }
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = max2(W, min2(E2, w0 - dx * signX)), e1 = max2(W, min2(E2, e0 + dx * signX));
          if (signY) n1 = max2(N, min2(S, n0 - dy * signY)), s1 = max2(N, min2(S, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type2 in flipX) overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type2 in flipY) overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state.selection) selection2 = state.selection;
      if (lockX) w1 = selection2[0][0], e1 = selection2[1][0];
      if (lockY) n1 = selection2[0][1], s1 = selection2[1][1];
      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush(event2, mode2.name);
      }
    }
    function ended(event2) {
      nopropagation2(event2);
      if (event2.touches) {
        if (event2.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event2.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group2.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection2 = state.selection;
      if (empty3(selection2)) state.selection = null, redraw.call(that);
      emit.end(event2, mode2.name);
    }
    function keydowned(event2) {
      switch (event2.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode2 === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode2 = MODE_CENTER;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode2 === MODE_HANDLE || mode2 === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx;
            else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy;
            else if (signY > 0) n0 = n1 - dy;
            mode2 = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
    function keyupped(event2) {
      switch (event2.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move(event2);
          }
          break;
        }
        case 18: {
          if (mode2 === MODE_CENTER) {
            if (signX < 0) e0 = e1;
            else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1;
            else if (signY > 0) n0 = n1;
            mode2 = MODE_HANDLE;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode2 === MODE_SPACE) {
            if (event2.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode2 = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1;
              else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;
              else if (signY > 0) n0 = n1;
              mode2 = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
  }
  function touchmoved(event) {
    emitter(this, arguments).moved(event);
  }
  function touchended(event) {
    emitter(this, arguments).ended(event);
  }
  function initialize() {
    var state = this.__brush || { selection: null };
    state.extent = number22(extent2.apply(this, arguments));
    state.dim = dim;
    return state;
  }
  brush2.extent = function(_14) {
    return arguments.length ? (extent2 = typeof _14 === "function" ? _14 : constant_default4(number22(_14)), brush2) : extent2;
  };
  brush2.filter = function(_14) {
    return arguments.length ? (filter3 = typeof _14 === "function" ? _14 : constant_default4(!!_14), brush2) : filter3;
  };
  brush2.touchable = function(_14) {
    return arguments.length ? (touchable = typeof _14 === "function" ? _14 : constant_default4(!!_14), brush2) : touchable;
  };
  brush2.handleSize = function(_14) {
    return arguments.length ? (handleSize = +_14, brush2) : handleSize;
  };
  brush2.keyModifiers = function(_14) {
    return arguments.length ? (keys = !!_14, brush2) : keys;
  };
  brush2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush2 : value;
  };
  return brush2;
}

// node_modules/d3-chord/src/math.js
var abs2 = Math.abs;
var cos = Math.cos;
var sin = Math.sin;
var pi2 = Math.PI;
var halfPi2 = pi2 / 2;
var tau2 = pi2 * 2;
var max3 = Math.max;
var epsilon3 = 1e-12;

// node_modules/d3-chord/src/chord.js
function range2(i, j) {
  return Array.from({ length: j - i }, (_14, k2) => i + k2);
}
function compareValue(compare2) {
  return function(a4, b) {
    return compare2(
      a4.source.value + a4.target.value,
      b.source.value + b.target.value
    );
  };
}
function chord_default() {
  return chord(false, false);
}
function chordTranspose() {
  return chord(false, true);
}
function chordDirected() {
  return chord(true, false);
}
function chord(directed, transpose2) {
  var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;
  function chord2(matrix) {
    var n = matrix.length, groupSums = new Array(n), groupIndex = range2(0, n), chords = new Array(n * n), groups2 = new Array(n), k2 = 0, dx;
    matrix = Float64Array.from({ length: n * n }, transpose2 ? (_14, i) => matrix[i % n][i / n | 0] : (_14, i) => matrix[i / n | 0][i % n]);
    for (let i = 0; i < n; ++i) {
      let x4 = 0;
      for (let j = 0; j < n; ++j) x4 += matrix[i * n + j] + directed * matrix[j * n + i];
      k2 += groupSums[i] = x4;
    }
    k2 = max3(0, tau2 - padAngle * n) / k2;
    dx = k2 ? padAngle : tau2 / n;
    {
      let x4 = 0;
      if (sortGroups) groupIndex.sort((a4, b) => sortGroups(groupSums[a4], groupSums[b]));
      for (const i of groupIndex) {
        const x06 = x4;
        if (directed) {
          const subgroupIndex = range2(~n + 1, n).filter((j) => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
          if (sortSubgroups) subgroupIndex.sort((a4, b) => sortSubgroups(a4 < 0 ? -matrix[~a4 * n + i] : matrix[i * n + a4], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
          for (const j of subgroupIndex) {
            if (j < 0) {
              const chord3 = chords[~j * n + i] || (chords[~j * n + i] = { source: null, target: null });
              chord3.target = { index: i, startAngle: x4, endAngle: x4 += matrix[~j * n + i] * k2, value: matrix[~j * n + i] };
            } else {
              const chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });
              chord3.source = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };
            }
          }
          groups2[i] = { index: i, startAngle: x06, endAngle: x4, value: groupSums[i] };
        } else {
          const subgroupIndex = range2(0, n).filter((j) => matrix[i * n + j] || matrix[j * n + i]);
          if (sortSubgroups) subgroupIndex.sort((a4, b) => sortSubgroups(matrix[i * n + a4], matrix[i * n + b]));
          for (const j of subgroupIndex) {
            let chord3;
            if (i < j) {
              chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });
              chord3.source = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };
            } else {
              chord3 = chords[j * n + i] || (chords[j * n + i] = { source: null, target: null });
              chord3.target = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };
              if (i === j) chord3.source = chord3.target;
            }
            if (chord3.source && chord3.target && chord3.source.value < chord3.target.value) {
              const source = chord3.source;
              chord3.source = chord3.target;
              chord3.target = source;
            }
          }
          groups2[i] = { index: i, startAngle: x06, endAngle: x4, value: groupSums[i] };
        }
        x4 += dx;
      }
    }
    chords = Object.values(chords);
    chords.groups = groups2;
    return sortChords ? chords.sort(sortChords) : chords;
  }
  chord2.padAngle = function(_14) {
    return arguments.length ? (padAngle = max3(0, _14), chord2) : padAngle;
  };
  chord2.sortGroups = function(_14) {
    return arguments.length ? (sortGroups = _14, chord2) : sortGroups;
  };
  chord2.sortSubgroups = function(_14) {
    return arguments.length ? (sortSubgroups = _14, chord2) : sortSubgroups;
  };
  chord2.sortChords = function(_14) {
    return arguments.length ? (_14 == null ? sortChords = null : (sortChords = compareValue(_14))._ = _14, chord2) : sortChords && sortChords._;
  };
  return chord2;
}

// node_modules/d3-path/src/path.js
var pi3 = Math.PI;
var tau3 = 2 * pi3;
var epsilon4 = 1e-6;
var tauEpsilon = tau3 - epsilon4;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k2 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x4, y4) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x4, y4) {
    this._append`L${this._x1 = +x4},${this._y1 = +y4}`;
  }
  quadraticCurveTo(x12, y12, x4, y4) {
    this._append`Q${+x12},${+y12},${this._x1 = +x4},${this._y1 = +y4}`;
  }
  bezierCurveTo(x12, y12, x22, y22, x4, y4) {
    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x4},${this._y1 = +y4}`;
  }
  arcTo(x12, y12, x22, y22, r) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon4)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon4) || !r) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon4) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x4, y4, r, a0, a1, ccw) {
    x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x4 + dx, y06 = y4 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x06},${y06}`;
    } else if (Math.abs(this._x1 - x06) > epsilon4 || Math.abs(this._y1 - y06) > epsilon4) {
      this._append`L${x06},${y06}`;
    }
    if (!r) return;
    if (da2 < 0) da2 = da2 % tau3 + tau3;
    if (da2 > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x4 - dx},${y4 - dy}A${r},${r},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;
    } else if (da2 > epsilon4) {
      this._append`A${r},${r},0,${+(da2 >= pi3)},${cw},${this._x1 = x4 + r * Math.cos(a1)},${this._y1 = y4 + r * Math.sin(a1)}`;
    }
  }
  rect(x4, y4, w, h) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;
function pathRound(digits = 3) {
  return new Path(+digits);
}

// node_modules/d3-chord/src/array.js
var slice2 = Array.prototype.slice;

// node_modules/d3-chord/src/constant.js
function constant_default5(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-chord/src/ribbon.js
function defaultSource(d) {
  return d.source;
}
function defaultTarget(d) {
  return d.target;
}
function defaultRadius(d) {
  return d.radius;
}
function defaultStartAngle(d) {
  return d.startAngle;
}
function defaultEndAngle(d) {
  return d.endAngle;
}
function defaultPadAngle() {
  return 0;
}
function defaultArrowheadRadius() {
  return 10;
}
function ribbon(headRadius) {
  var source = defaultSource, target = defaultTarget, sourceRadius = defaultRadius, targetRadius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, padAngle = defaultPadAngle, context = null;
  function ribbon2() {
    var buffer, s2 = source.apply(this, arguments), t = target.apply(this, arguments), ap = padAngle.apply(this, arguments) / 2, argv = slice2.call(arguments), sr = +sourceRadius.apply(this, (argv[0] = s2, argv)), sa0 = startAngle.apply(this, argv) - halfPi2, sa1 = endAngle.apply(this, argv) - halfPi2, tr = +targetRadius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi2, ta1 = endAngle.apply(this, argv) - halfPi2;
    if (!context) context = buffer = path();
    if (ap > epsilon3) {
      if (abs2(sa1 - sa0) > ap * 2 + epsilon3) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
      else sa0 = sa1 = (sa0 + sa1) / 2;
      if (abs2(ta1 - ta0) > ap * 2 + epsilon3) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
      else ta0 = ta1 = (ta0 + ta1) / 2;
    }
    context.moveTo(sr * cos(sa0), sr * sin(sa0));
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) {
      if (headRadius) {
        var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
        context.quadraticCurveTo(0, 0, tr2 * cos(ta0), tr2 * sin(ta0));
        context.lineTo(tr * cos(ta2), tr * sin(ta2));
        context.lineTo(tr2 * cos(ta1), tr2 * sin(ta1));
      } else {
        context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
        context.arc(0, 0, tr, ta0, ta1);
      }
    }
    context.quadraticCurveTo(0, 0, sr * cos(sa0), sr * sin(sa0));
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  if (headRadius) ribbon2.headRadius = function(_14) {
    return arguments.length ? (headRadius = typeof _14 === "function" ? _14 : constant_default5(+_14), ribbon2) : headRadius;
  };
  ribbon2.radius = function(_14) {
    return arguments.length ? (sourceRadius = targetRadius = typeof _14 === "function" ? _14 : constant_default5(+_14), ribbon2) : sourceRadius;
  };
  ribbon2.sourceRadius = function(_14) {
    return arguments.length ? (sourceRadius = typeof _14 === "function" ? _14 : constant_default5(+_14), ribbon2) : sourceRadius;
  };
  ribbon2.targetRadius = function(_14) {
    return arguments.length ? (targetRadius = typeof _14 === "function" ? _14 : constant_default5(+_14), ribbon2) : targetRadius;
  };
  ribbon2.startAngle = function(_14) {
    return arguments.length ? (startAngle = typeof _14 === "function" ? _14 : constant_default5(+_14), ribbon2) : startAngle;
  };
  ribbon2.endAngle = function(_14) {
    return arguments.length ? (endAngle = typeof _14 === "function" ? _14 : constant_default5(+_14), ribbon2) : endAngle;
  };
  ribbon2.padAngle = function(_14) {
    return arguments.length ? (padAngle = typeof _14 === "function" ? _14 : constant_default5(+_14), ribbon2) : padAngle;
  };
  ribbon2.source = function(_14) {
    return arguments.length ? (source = _14, ribbon2) : source;
  };
  ribbon2.target = function(_14) {
    return arguments.length ? (target = _14, ribbon2) : target;
  };
  ribbon2.context = function(_14) {
    return arguments.length ? (context = _14 == null ? null : _14, ribbon2) : context;
  };
  return ribbon2;
}
function ribbon_default() {
  return ribbon();
}
function ribbonArrow() {
  return ribbon(defaultArrowheadRadius);
}

// node_modules/d3-contour/src/array.js
var array4 = Array.prototype;
var slice3 = array4.slice;

// node_modules/d3-contour/src/ascending.js
function ascending_default(a4, b) {
  return a4 - b;
}

// node_modules/d3-contour/src/area.js
function area_default(ring) {
  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
}

// node_modules/d3-contour/src/constant.js
var constant_default6 = (x4) => () => x4;

// node_modules/d3-contour/src/contains.js
function contains_default(ring, hole) {
  var i = -1, n = hole.length, c6;
  while (++i < n) if (c6 = ringContains(ring, hole[i])) return c6;
  return 0;
}
function ringContains(ring, point7) {
  var x4 = point7[0], y4 = point7[1], contains2 = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi6 = ring[i], xi = pi6[0], yi = pi6[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi6, pj, point7)) return 0;
    if (yi > y4 !== yj > y4 && x4 < (xj - xi) * (y4 - yi) / (yj - yi) + xi) contains2 = -contains2;
  }
  return contains2;
}
function segmentContains(a4, b, c6) {
  var i;
  return collinear(a4, b, c6) && within2(a4[i = +(a4[0] === b[0])], c6[i], b[i]);
}
function collinear(a4, b, c6) {
  return (b[0] - a4[0]) * (c6[1] - a4[1]) === (c6[0] - a4[0]) * (b[1] - a4[1]);
}
function within2(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

// node_modules/d3-contour/src/noop.js
function noop_default() {
}

// node_modules/d3-contour/src/contours.js
var cases = [
  [],
  [[[1, 1.5], [0.5, 1]]],
  [[[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [0.5, 1]]],
  [[[1, 0.5], [1.5, 1]]],
  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
  [[[1, 0.5], [1, 1.5]]],
  [[[1, 0.5], [0.5, 1]]],
  [[[0.5, 1], [1, 0.5]]],
  [[[1, 1.5], [1, 0.5]]],
  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [1, 0.5]]],
  [[[0.5, 1], [1.5, 1]]],
  [[[1, 1.5], [1.5, 1]]],
  [[[0.5, 1], [1, 1.5]]],
  []
];
function contours_default() {
  var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;
  function contours(values) {
    var tz = threshold2(values);
    if (!Array.isArray(tz)) {
      const e = extent(values, finite);
      tz = ticks(...nice(e[0], e[1], tz), tz);
      while (tz[tz.length - 1] >= e[1]) tz.pop();
      while (tz[1] < e[0]) tz.shift();
    } else {
      tz = tz.slice().sort(ascending_default);
    }
    return tz.map((value) => contour(values, value));
  }
  function contour(values, value) {
    const v2 = value == null ? NaN : +value;
    if (isNaN(v2)) throw new Error(`invalid value: ${value}`);
    var polygons = [], holes = [];
    isorings(values, v2, function(ring) {
      smooth(ring, values, v2);
      if (area_default(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });
    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains_default((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value,
      coordinates: polygons
    };
  }
  function isorings(values, value, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x4, y4, t03, t13, t22, t32;
    x4 = y4 = -1;
    t13 = above(values[0], value);
    cases[t13 << 1].forEach(stitch);
    while (++x4 < dx - 1) {
      t03 = t13, t13 = above(values[x4 + 1], value);
      cases[t03 | t13 << 1].forEach(stitch);
    }
    cases[t13 << 0].forEach(stitch);
    while (++y4 < dy - 1) {
      x4 = -1;
      t13 = above(values[y4 * dx + dx], value);
      t22 = above(values[y4 * dx], value);
      cases[t13 << 1 | t22 << 2].forEach(stitch);
      while (++x4 < dx - 1) {
        t03 = t13, t13 = above(values[y4 * dx + dx + x4 + 1], value);
        t32 = t22, t22 = above(values[y4 * dx + x4 + 1], value);
        cases[t03 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
      }
      cases[t13 | t22 << 3].forEach(stitch);
    }
    x4 = -1;
    t22 = values[y4 * dx] >= value;
    cases[t22 << 2].forEach(stitch);
    while (++x4 < dx - 1) {
      t32 = t22, t22 = above(values[y4 * dx + x4 + 1], value);
      cases[t22 << 2 | t32 << 3].forEach(stitch);
    }
    cases[t22 << 3].forEach(stitch);
    function stitch(line) {
      var start3 = [line[0][0] + x4, line[0][1] + y4], end2 = [line[1][0] + x4, line[1][1] + y4], startIndex = index4(start3), endIndex = index4(end2), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end2);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end2);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end2);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start3);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start3, end2] };
      }
    }
  }
  function index4(point7) {
    return point7[0] * 2 + point7[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values, value) {
    ring.forEach(function(point7) {
      var x4 = point7[0], y4 = point7[1], xt = x4 | 0, yt = y4 | 0, v1 = valid(values[yt * dx + xt]);
      if (x4 > 0 && x4 < dx && xt === x4) {
        point7[0] = smooth1(x4, valid(values[yt * dx + xt - 1]), v1, value);
      }
      if (y4 > 0 && y4 < dy && yt === y4) {
        point7[1] = smooth1(y4, valid(values[(yt - 1) * dx + xt]), v1, value);
      }
    });
  }
  contours.contour = contour;
  contours.size = function(_14) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.floor(_14[0]), _1 = Math.floor(_14[1]);
    if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };
  contours.thresholds = function(_14) {
    return arguments.length ? (threshold2 = typeof _14 === "function" ? _14 : Array.isArray(_14) ? constant_default6(slice3.call(_14)) : constant_default6(_14), contours) : threshold2;
  };
  contours.smooth = function(_14) {
    return arguments.length ? (smooth = _14 ? smoothLinear : noop_default, contours) : smooth === smoothLinear;
  };
  return contours;
}
function finite(x4) {
  return isFinite(x4) ? x4 : NaN;
}
function above(x4, value) {
  return x4 == null ? false : +x4 >= value;
}
function valid(v2) {
  return v2 == null || isNaN(v2 = +v2) ? -Infinity : v2;
}
function smooth1(x4, v0, v1, value) {
  const a4 = value - v0;
  const b = v1 - v0;
  const d = isFinite(a4) || isFinite(b) ? a4 / b : Math.sign(a4) / Math.sign(b);
  return isNaN(d) ? x4 : x4 + d - 0.5;
}

// node_modules/d3-contour/src/density.js
function defaultX(d) {
  return d[0];
}
function defaultY(d) {
  return d[1];
}
function defaultWeight() {
  return 1;
}
function density_default() {
  var x4 = defaultX, y4 = defaultY, weight = defaultWeight, dx = 960, dy = 500, r = 20, k2 = 2, o = r * 3, n = dx + o * 2 >> k2, m3 = dy + o * 2 >> k2, threshold2 = constant_default6(20);
  function grid(data) {
    var values = new Float32Array(n * m3), pow2k = Math.pow(2, -k2), i = -1;
    for (const d of data) {
      var xi = (x4(d, ++i, data) + o) * pow2k, yi = (y4(d, i, data) + o) * pow2k, wi = +weight(d, i, data);
      if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m3) {
        var x06 = Math.floor(xi), y06 = Math.floor(yi), xt = xi - x06 - 0.5, yt = yi - y06 - 0.5;
        values[x06 + y06 * n] += (1 - xt) * (1 - yt) * wi;
        values[x06 + 1 + y06 * n] += xt * (1 - yt) * wi;
        values[x06 + 1 + (y06 + 1) * n] += xt * yt * wi;
        values[x06 + (y06 + 1) * n] += (1 - xt) * yt * wi;
      }
    }
    blur2({ data: values, width: n, height: m3 }, r * pow2k);
    return values;
  }
  function density(data) {
    var values = grid(data), tz = threshold2(values), pow4k = Math.pow(2, 2 * k2);
    if (!Array.isArray(tz)) {
      tz = ticks(Number.MIN_VALUE, max(values) / pow4k, tz);
    }
    return contours_default().size([n, m3]).thresholds(tz.map((d) => d * pow4k))(values).map((c6, i) => (c6.value = +tz[i], transform2(c6)));
  }
  density.contours = function(data) {
    var values = grid(data), contours = contours_default().size([n, m3]), pow4k = Math.pow(2, 2 * k2), contour = (value) => {
      value = +value;
      var c6 = transform2(contours.contour(values, value * pow4k));
      c6.value = value;
      return c6;
    };
    Object.defineProperty(contour, "max", { get: () => max(values) / pow4k });
    return contour;
  };
  function transform2(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }
  function transformPolygon(coordinates2) {
    coordinates2.forEach(transformRing);
  }
  function transformRing(coordinates2) {
    coordinates2.forEach(transformPoint);
  }
  function transformPoint(coordinates2) {
    coordinates2[0] = coordinates2[0] * Math.pow(2, k2) - o;
    coordinates2[1] = coordinates2[1] * Math.pow(2, k2) - o;
  }
  function resize() {
    o = r * 3;
    n = dx + o * 2 >> k2;
    m3 = dy + o * 2 >> k2;
    return density;
  }
  density.x = function(_14) {
    return arguments.length ? (x4 = typeof _14 === "function" ? _14 : constant_default6(+_14), density) : x4;
  };
  density.y = function(_14) {
    return arguments.length ? (y4 = typeof _14 === "function" ? _14 : constant_default6(+_14), density) : y4;
  };
  density.weight = function(_14) {
    return arguments.length ? (weight = typeof _14 === "function" ? _14 : constant_default6(+_14), density) : weight;
  };
  density.size = function(_14) {
    if (!arguments.length) return [dx, dy];
    var _0 = +_14[0], _1 = +_14[1];
    if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };
  density.cellSize = function(_14) {
    if (!arguments.length) return 1 << k2;
    if (!((_14 = +_14) >= 1)) throw new Error("invalid cell size");
    return k2 = Math.floor(Math.log(_14) / Math.LN2), resize();
  };
  density.thresholds = function(_14) {
    return arguments.length ? (threshold2 = typeof _14 === "function" ? _14 : Array.isArray(_14) ? constant_default6(slice3.call(_14)) : constant_default6(_14), density) : threshold2;
  };
  density.bandwidth = function(_14) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_14 = +_14) >= 0)) throw new Error("invalid bandwidth");
    return r = (Math.sqrt(4 * _14 * _14 + 1) - 1) / 2, resize();
  };
  return density;
}

// node_modules/robust-predicates/esm/util.js
var epsilon5 = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon5) * epsilon5;
function sum2(elen, e, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q = e[0];
  for (let i = 1; i < elen; i++) Q += e[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon5) * epsilon5;
var ccwerrboundB = (2 + 12 * epsilon5) * epsilon5;
var ccwerrboundC = (9 + 64 * epsilon5) * epsilon5 * epsilon5;
var B2 = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D2 = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c6, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t13, t03, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c6 = splitter * acx;
  ahi = c6 - (c6 - acx);
  alo = acx - ahi;
  c6 = splitter * bcy;
  bhi = c6 - (c6 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcx;
  c6 = splitter * acy;
  ahi = c6 - (c6 - acy);
  alo = acy - ahi;
  c6 = splitter * bcx;
  bhi = c6 - (c6 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  B2[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  B2[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B2[3] = u32;
  let det = estimate(4, B2);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c6 = splitter * acxtail;
  ahi = c6 - (c6 - acxtail);
  alo = acxtail - ahi;
  c6 = splitter * bcy;
  bhi = c6 - (c6 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcx;
  c6 = splitter * acytail;
  ahi = c6 - (c6 - acytail);
  alo = acytail - ahi;
  c6 = splitter * bcx;
  bhi = c6 - (c6 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum2(4, B2, 4, u, C1);
  s1 = acx * bcytail;
  c6 = splitter * acx;
  ahi = c6 - (c6 - acx);
  alo = acx - ahi;
  c6 = splitter * bcytail;
  bhi = c6 - (c6 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcxtail;
  c6 = splitter * acy;
  ahi = c6 - (c6 - acy);
  alo = acy - ahi;
  c6 = splitter * bcxtail;
  bhi = c6 - (c6 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum2(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c6 = splitter * acxtail;
  ahi = c6 - (c6 - acxtail);
  alo = acxtail - ahi;
  c6 = splitter * bcytail;
  bhi = c6 - (c6 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcxtail;
  c6 = splitter * acytail;
  ahi = c6 - (c6 - acytail);
  alo = acytail - ahi;
  c6 = splitter * bcxtail;
  bhi = c6 - (c6 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum2(C2len, C2, 4, u, D2);
  return D2[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon5) * epsilon5;
var o3derrboundB = (3 + 28 * epsilon5) * epsilon5;
var o3derrboundC = (26 + 288 * epsilon5) * epsilon5 * epsilon5;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _82 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _122 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon5) * epsilon5;
var iccerrboundB = (4 + 48 * epsilon5) * epsilon5;
var iccerrboundC = (44 + 576 * epsilon5) * epsilon5 * epsilon5;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _83 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon5) * epsilon5;
var isperrboundB = (5 + 72 * epsilon5) * epsilon5;
var isperrboundC = (71 + 1408 * epsilon5) * epsilon5 * epsilon5;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _84 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points, getX = defaultGetX, getY = defaultGetY) {
    const n = points.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY2 = -Infinity;
    for (let i = 0; i < n; i++) {
      const x4 = coords[2 * i];
      const y4 = coords[2 * i + 1];
      if (x4 < minX) minX = x4;
      if (y4 < minY) minY = y4;
      if (x4 > maxX) maxX = x4;
      if (y4 > maxY2) maxY2 = y4;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY2) / 2;
    let i0, i1, i2;
    for (let i = 0, minDist = Infinity; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    for (let i = 0, minDist = Infinity; i < n; i++) {
      if (i === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1) continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id2 = this._ids[i];
        const d = this._dists[id2];
        if (d > d0) {
          hull[j++] = id2;
          d0 = d;
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i = i1;
      const x4 = i1x;
      const y4 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x4;
      i2y = y4;
    }
    const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center2.x;
    this._cy = center2.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k2 = 0, xp, yp; k2 < this._ids.length; k2++) {
      const i = this._ids[k2];
      const x4 = coords[2 * i];
      const y4 = coords[2 * i + 1];
      if (k2 > 0 && Math.abs(x4 - xp) <= EPSILON && Math.abs(y4 - yp) <= EPSILON) continue;
      xp = x4;
      yp = y4;
      if (i === i0 || i === i1 || i === i2) continue;
      let start3 = 0;
      for (let j = 0, key = this._hashKey(x4, y4); j < this._hashSize; j++) {
        start3 = hullHash[(key + j) % this._hashSize];
        if (start3 !== -1 && start3 !== hullNext[start3]) break;
      }
      start3 = hullPrev[start3];
      let e = start3, q;
      while (q = hullNext[e], orient2d(x4, y4, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
        e = q;
        if (e === start3) {
          e = -1;
          break;
        }
      }
      if (e === -1) continue;
      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q = hullNext[n2], orient2d(x4, y4, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e === start3) {
        while (q = hullPrev[e], orient2d(x4, y4, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
          this._legalize(t + 2);
          hullTri[q] = t;
          hullNext[e] = e;
          hullSize--;
          e = q;
        }
      }
      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x4, y4)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x4, y4) {
    return Math.floor(pseudoAngle(x4 - this._cx, y4 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a4) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b = halfedges[a4];
      const a0 = a4 - a4 % 3;
      ar = a0 + (a4 + 2) % 3;
      if (b === -1) {
        if (i === 0) break;
        a4 = EDGE_STACK[--i];
        continue;
      }
      const b02 = b - b % 3;
      const al = a0 + (a4 + 1) % 3;
      const bl = b02 + (b + 2) % 3;
      const p02 = triangles[ar];
      const pr = triangles[a4];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p02],
        coords[2 * p02 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a4] = p1;
        triangles[b] = p02;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a4;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a4, hbl);
        this._link(b, halfedges[ar]);
        this._link(ar, bl);
        const br = b02 + (b + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br;
        }
      } else {
        if (i === 0) break;
        a4 = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a4, b) {
    this._halfedges[a4] = b;
    if (b !== -1) this._halfedges[b] = a4;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a4, b, c6) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a4);
    this._link(t + 1, b);
    this._link(t + 2, c6);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x4 = (ey * bl - dy * cl) * d;
  const y4 = (dx * cl - ex * bl) * d;
  return x4 * x4 + y4 * y4;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x4 = ax + (ey * bl - dy * cl) * d;
  const y4 = ay + (dx * cl - ex * bl) * d;
  return { x: x4, y: y4 };
}
function quicksort(ids, dists, left3, right3) {
  if (right3 - left3 <= 20) {
    for (let i = left3 + 1; i <= right3; i++) {
      const temp = ids[i];
      const tempDist = dists[temp];
      let j = i - 1;
      while (j >= left3 && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
      ids[j + 1] = temp;
    }
  } else {
    const median2 = left3 + right3 >> 1;
    let i = left3 + 1;
    let j = right3;
    swap2(ids, median2, i);
    if (dists[ids[left3]] > dists[ids[right3]]) swap2(ids, left3, right3);
    if (dists[ids[i]] > dists[ids[right3]]) swap2(ids, i, right3);
    if (dists[ids[left3]] > dists[ids[i]]) swap2(ids, left3, i);
    const temp = ids[i];
    const tempDist = dists[temp];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i) break;
      swap2(ids, i, j);
    }
    ids[left3 + 1] = ids[j];
    ids[j] = temp;
    if (right3 - i + 1 >= j - left3) {
      quicksort(ids, dists, i, right3);
      quicksort(ids, dists, left3, j - 1);
    } else {
      quicksort(ids, dists, left3, j - 1);
      quicksort(ids, dists, i, right3);
    }
  }
}
function swap2(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/d3-delaunay/src/path.js
var epsilon6 = 1e-6;
var Path2 = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x4, y4) {
    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x4, y4) {
    this._ += `L${this._x1 = +x4},${this._y1 = +y4}`;
  }
  arc(x4, y4, r) {
    x4 = +x4, y4 = +y4, r = +r;
    const x06 = x4 + r;
    const y06 = y4;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x06},${y06}`;
    else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6) this._ += "L" + x06 + "," + y06;
    if (!r) return;
    this._ += `A${r},${r},0,1,1,${x4 - r},${y4}A${r},${r},0,1,1,${this._x1 = x06},${this._y1 = y06}`;
  }
  rect(x4, y4, w, h) {
    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${+w}v${+h}h${-w}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x4, y4) {
    this._.push([x4, y4]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x4, y4) {
    this._.push([x4, y4]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points, hull, triangles }, vectors } = this;
    let bx, by;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x4, y4; i < n; i += 3, j += 2) {
      const t13 = triangles[i] * 2;
      const t22 = triangles[i + 1] * 2;
      const t32 = triangles[i + 2] * 2;
      const x13 = points[t13];
      const y13 = points[t13 + 1];
      const x22 = points[t22];
      const y22 = points[t22 + 1];
      const x32 = points[t32];
      const y32 = points[t32 + 1];
      const dx = x22 - x13;
      const dy = y22 - y13;
      const ex = x32 - x13;
      const ey = y32 - y13;
      const ab4 = (dx * ey - dy * ex) * 2;
      if (Math.abs(ab4) < 1e-9) {
        if (bx === void 0) {
          bx = by = 0;
          for (const i2 of hull) bx += points[i2 * 2], by += points[i2 * 2 + 1];
          bx /= hull.length, by /= hull.length;
        }
        const a4 = 1e9 * Math.sign((bx - x13) * ey - (by - y13) * ex);
        x4 = (x13 + x32) / 2 - a4 * ey;
        y4 = (y13 + y32) / 2 + a4 * ex;
      } else {
        const d = 1 / ab4;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x4 = x13 + (ey * bl - dy * cl) * d;
        y4 = y13 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j] = x4;
      circumcenters[j + 1] = y4;
    }
    let h = hull[hull.length - 1];
    let p02, p1 = h * 4;
    let x06, x12 = points[2 * h];
    let y06, y12 = points[2 * h + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p02 = p1, x06 = x12, y06 = y12;
      p1 = h * 4, x12 = points[2 * h], y12 = points[2 * h + 1];
      vectors[p02 + 2] = vectors[p1] = y06 - y12;
      vectors[p02 + 3] = vectors[p1 + 1] = x12 - x06;
    }
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x4 = circumcenters[t];
      const y4 = circumcenters[t + 1];
      const v2 = h0 * 4;
      const p = this._project(x4, y4, vectors[v2 + 2], vectors[v2 + 3]);
      if (p) this._renderSegment(x4, y4, p[0], p[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const points = this._clip(i);
    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n = points.length;
    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])
        context.lineTo(points[i2], points[i2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points } } = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) cell.index = i, yield cell;
    }
  }
  cellPolygon(i) {
    const polygon = new Polygon();
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x06, y06, x12, y12, context) {
    let S;
    const c0 = this._regioncode(x06, y06);
    const c1 = this._regioncode(x12, y12);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x06, y06);
      context.lineTo(x12, y12);
    } else if (S = this._clipSegment(x06, y06, x12, y12, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  }
  contains(i, x4, y4) {
    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4)) return false;
    return this.delaunay._step(i, x4, y4) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j);
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
            yield j;
            break loop;
          }
        }
      }
    }
  }
  _cell(i) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i];
    if (e0 === -1) return null;
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i);
    if (points === null) return null;
    const { vectors: V } = this;
    const v2 = i * 4;
    return this._simplify(V[v2] || V[v2 + 1] ? this._clipInfinite(i, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i, points));
  }
  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x06, y06, x12 = points[n - 2], y12 = points[n - 1];
    let c0, c1 = this._regioncode(x12, y12);
    let e0, e1 = 0;
    for (let j = 0; j < n; j += 2) {
      x06 = x12, y06 = y12, x12 = points[j], y12 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x12, y12);
        else P = [x12, y12];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x06, y06, x12, y12, c0, c1) {
    const flip3 = c0 < c1;
    if (flip3) [x06, y06, x12, y12, c0, c1] = [x12, y12, x06, y06, c1, c0];
    while (true) {
      if (c0 === 0 && c1 === 0) return flip3 ? [x12, y12, x06, y06] : [x06, y06, x12, y12];
      if (c0 & c1) return null;
      let x4, y4, c6 = c0 || c1;
      if (c6 & 8) x4 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y4 = this.ymax;
      else if (c6 & 4) x4 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y4 = this.ymin;
      else if (c6 & 2) y4 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x4 = this.xmax;
      else y4 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x4 = this.xmin;
      if (c0) x06 = x4, y06 = y4, c0 = this._regioncode(x06, y06);
      else x12 = x4, y12 = y4, c1 = this._regioncode(x12, y12);
    }
  }
  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x4, y4;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        case 4:
          e0 = 6, x4 = this.xmax, y4 = this.ymin;
          break;
        case 6:
          e0 = 2;
          continue;
        case 2:
          e0 = 10, x4 = this.xmax, y4 = this.ymax;
          break;
        case 10:
          e0 = 8;
          continue;
        case 8:
          e0 = 9, x4 = this.xmin, y4 = this.ymax;
          break;
        case 9:
          e0 = 1;
          continue;
        case 1:
          e0 = 5, x4 = this.xmin, y4 = this.ymin;
          break;
      }
      if ((P[j] !== x4 || P[j + 1] !== y4) && this.contains(i, x4, y4)) {
        P.splice(j, 0, x4, y4), j += 2;
      }
    }
    return j;
  }
  _project(x06, y06, vx, vy) {
    let t = Infinity, c6, x4, y4;
    if (vy < 0) {
      if (y06 <= this.ymin) return null;
      if ((c6 = (this.ymin - y06) / vy) < t) y4 = this.ymin, x4 = x06 + (t = c6) * vx;
    } else if (vy > 0) {
      if (y06 >= this.ymax) return null;
      if ((c6 = (this.ymax - y06) / vy) < t) y4 = this.ymax, x4 = x06 + (t = c6) * vx;
    }
    if (vx > 0) {
      if (x06 >= this.xmax) return null;
      if ((c6 = (this.xmax - x06) / vx) < t) x4 = this.xmax, y4 = y06 + (t = c6) * vy;
    } else if (vx < 0) {
      if (x06 <= this.xmin) return null;
      if ((c6 = (this.xmin - x06) / vx) < t) x4 = this.xmin, y4 = y06 + (t = c6) * vy;
    }
    return [x4, y4];
  }
  _edgecode(x4, y4) {
    return (x4 === this.xmin ? 1 : x4 === this.xmax ? 2 : 0) | (y4 === this.ymin ? 4 : y4 === this.ymax ? 8 : 0);
  }
  _regioncode(x4, y4) {
    return (x4 < this.xmin ? 1 : x4 > this.xmax ? 2 : 0) | (y4 < this.ymin ? 4 : y4 > this.ymax ? 8 : 0);
  }
  _simplify(P) {
    if (P && P.length > 4) {
      for (let i = 0; i < P.length; i += 2) {
        const j = (i + 2) % P.length, k2 = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k2] || P[i + 1] === P[j + 1] && P[j + 1] === P[k2 + 1]) {
          P.splice(j, 2), i -= 2;
        }
      }
      if (!P.length) P = null;
    }
    return P;
  }
};

// node_modules/d3-delaunay/src/delaunay.js
var tau4 = 2 * Math.PI;
var pow = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear2(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a4 = 2 * triangles[i], b = 2 * triangles[i + 1], c6 = 2 * triangles[i + 2], cross2 = (coords[c6] - coords[a4]) * (coords[b + 1] - coords[a4 + 1]) - (coords[b] - coords[a4]) * (coords[c6 + 1] - coords[a4 + 1]);
    if (cross2 > 1e-10) return false;
  }
  return true;
}
function jitter(x4, y4, r) {
  return [x4 + Math.sin(x4 + y4) * r, y4 + Math.cos(x4 - y4) * r];
}
var Delaunay = class _Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new Delaunator(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;
    if (d.hull && d.hull.length > 2 && collinear2(d)) {
      this.collinear = Int32Array.from({ length: points.length / 2 }, (_14, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);
      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }
      this._delaunator = new Delaunator(points);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      inedges[hull[0]] = 1;
      if (hull.length === 2) {
        inedges[hull[1]] = 0;
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
      }
    }
  }
  voronoi(bounds) {
    return new Voronoi(this, bounds);
  }
  *neighbors(i) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;
    if (collinear3) {
      const l = collinear3.indexOf(i);
      if (l > 0) yield collinear3[l - 1];
      if (l < collinear3.length - 1) yield collinear3[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1) return;
    let e = e0, p02 = -1;
    do {
      yield p02 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) return;
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p02) yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x4, y4, i = 0) {
    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4)) return -1;
    const i0 = i;
    let c6;
    while ((c6 = this._step(i, x4, y4)) >= 0 && c6 !== i && c6 !== i0) i = c6;
    return c6;
  }
  _step(i, x4, y4) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c6 = i;
    let dc = pow(x4 - points[i * 2], 2) + pow(y4 - points[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow(x4 - points[t * 2], 2) + pow(y4 - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c6 = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow(x4 - points[e * 2], 2) + pow(y4 - points[e * 2 + 1], 2) < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c6;
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points, halfedges, triangles } = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r) {
    if (r === void 0 && (!context || typeof context.moveTo !== "function")) r = context, context = null;
    r = r == void 0 ? 2 : +r;
    const buffer = context == null ? context = new Path2() : void 0;
    const { points } = this;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x4 = points[i], y4 = points[i + 1];
      context.moveTo(x4 + r, y4);
      context.arc(x4, y4, r, 0, tau4);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { hull, points } = this;
    const h = hull[0] * 2, n = hull.length;
    context.moveTo(points[h], points[h + 1]);
    for (let i = 1; i < n; ++i) {
      const h2 = 2 * hull[i];
      context.lineTo(points[h2], points[h2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points, triangles } = this;
    const t03 = triangles[i *= 3] * 2;
    const t13 = triangles[i + 1] * 2;
    const t22 = triangles[i + 2] * 2;
    context.moveTo(points[t03], points[t03 + 1]);
    context.lineTo(points[t13], points[t13 + 1]);
    context.lineTo(points[t22], points[t22 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new Polygon();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
};
function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array5 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array5[i * 2] = fx.call(that, p, i, points);
    array5[i * 2 + 1] = fy.call(that, p, i, points);
  }
  return array5;
}
function* flatIterable(points, fx, fy, that) {
  let i = 0;
  for (const p of points) {
    yield fx.call(that, p, i, points);
    yield fy.call(that, p, i, points);
    ++i;
  }
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object3 = objectConverter(columns);
  return function(row, i) {
    return f(object3(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad(value, width) {
  var s2 = value + "", length3 = s2.length;
  return length3 < width ? new Array(width - length3 + 1).join(0) + s2 : s2;
}
function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}
function formatDate(date2) {
  var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear(date2.getUTCFullYear(), 4) + "-" + pad(date2.getUTCMonth() + 1, 2) + "-" + pad(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "." + pad(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f) {
    var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;
    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;
      var i, j = I, c6;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) ;
        if ((i = I) >= N) eof = true;
        else if ((c6 = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c6 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c6 = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c6 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c6 !== DELIMITER) continue;
        return text.slice(j, i);
      }
      return eof = true, text.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }
  function format3(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
  }
  return {
    parse,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
function autoType(object3) {
  for (var key in object3) {
    var value = object3[key].trim(), number5, m3;
    if (!value) value = null;
    else if (value === "true") value = true;
    else if (value === "false") value = false;
    else if (value === "NaN") value = NaN;
    else if (!isNaN(number5 = +value)) value = number5;
    else if (m3 = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m3[4] && !m3[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    } else continue;
    object3[key] = value;
  }
  return object3;
}
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/d3-fetch/src/blob.js
function responseBlob(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.blob();
}
function blob_default(input, init2) {
  return fetch(input, init2).then(responseBlob);
}

// node_modules/d3-fetch/src/buffer.js
function responseArrayBuffer(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}
function buffer_default(input, init2) {
  return fetch(input, init2).then(responseArrayBuffer);
}

// node_modules/d3-fetch/src/text.js
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}
function text_default3(input, init2) {
  return fetch(input, init2).then(responseText);
}

// node_modules/d3-fetch/src/dsv.js
function dsvParse(parse) {
  return function(input, init2, row) {
    if (arguments.length === 2 && typeof init2 === "function") row = init2, init2 = void 0;
    return text_default3(input, init2).then(function(response) {
      return parse(response, row);
    });
  };
}
function dsv(delimiter, input, init2, row) {
  if (arguments.length === 3 && typeof init2 === "function") row = init2, init2 = void 0;
  var format3 = dsv_default(delimiter);
  return text_default3(input, init2).then(function(response) {
    return format3.parse(response, row);
  });
}
var csv2 = dsvParse(csvParse);
var tsv2 = dsvParse(tsvParse);

// node_modules/d3-fetch/src/image.js
function image_default(input, init2) {
  return new Promise(function(resolve, reject) {
    var image = new Image();
    for (var key in init2) image[key] = init2[key];
    image.onerror = reject;
    image.onload = function() {
      resolve(image);
    };
    image.src = input;
  });
}

// node_modules/d3-fetch/src/json.js
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}
function json_default(input, init2) {
  return fetch(input, init2).then(responseJson);
}

// node_modules/d3-fetch/src/xml.js
function parser(type2) {
  return (input, init2) => text_default3(input, init2).then((text) => new DOMParser().parseFromString(text, type2));
}
var xml_default = parser("application/xml");
var html = parser("text/html");
var svg = parser("image/svg+xml");

// node_modules/d3-force/src/center.js
function center_default(x4, y4) {
  var nodes, strength = 1;
  if (x4 == null) x4 = 0;
  if (y4 == null) y4 = 0;
  function force() {
    var i, n = nodes.length, node, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n - x4) * strength, sy = (sy / n - y4) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_14) {
    nodes = _14;
  };
  force.x = function(_14) {
    return arguments.length ? (x4 = +_14, force) : x4;
  };
  force.y = function(_14) {
    return arguments.length ? (y4 = +_14, force) : y4;
  };
  force.strength = function(_14) {
    return arguments.length ? (strength = +_14, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x4 = +this._x.call(null, d), y4 = +this._y.call(null, d);
  return add(this.cover(x4, y4), x4, y4, d);
}
function add(tree, x4, y4, d) {
  if (isNaN(x4) || isNaN(y4)) return tree;
  var parent, node = tree._root, leaf = { data: d }, x06 = tree._x0, y06 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right3, bottom3, i, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right3 = x4 >= (xm = (x06 + x12) / 2)) x06 = xm;
    else x12 = xm;
    if (bottom3 = y4 >= (ym = (y06 + y12) / 2)) y06 = ym;
    else y12 = ym;
    if (parent = node, !(node = node[i = bottom3 << 1 | right3])) return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x4 === xp && y4 === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right3 = x4 >= (xm = (x06 + x12) / 2)) x06 = xm;
    else x12 = xm;
    if (bottom3 = y4 >= (ym = (y06 + y12) / 2)) y06 = ym;
    else y12 = ym;
  } while ((i = bottom3 << 1 | right3) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data) {
  var d, i, n = data.length, x4, y4, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x4 = +this._x.call(null, d = data[i])) || isNaN(y4 = +this._y.call(null, d))) continue;
    xz[i] = x4;
    yz[i] = y4;
    if (x4 < x06) x06 = x4;
    if (x4 > x12) x12 = x4;
    if (y4 < y06) y06 = y4;
    if (y4 > y12) y12 = y4;
  }
  if (x06 > x12 || y06 > y12) return this;
  this.cover(x06, y06).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x4, y4) {
  if (isNaN(x4 = +x4) || isNaN(y4 = +y4)) return this;
  var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x06)) {
    x12 = (x06 = Math.floor(x4)) + 1;
    y12 = (y06 = Math.floor(y4)) + 1;
  } else {
    var z = x12 - x06 || 1, node = this._root, parent, i;
    while (x06 > x4 || x4 >= x12 || y06 > y4 || y4 >= y12) {
      i = (y4 < y06) << 1 | x4 < x06;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x12 = x06 + z, y12 = y06 + z;
          break;
        case 1:
          x06 = x12 - z, y12 = y06 + z;
          break;
        case 2:
          x12 = x06 + z, y06 = y12 - z;
          break;
        case 3:
          x06 = x12 - z, y06 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default2() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_14) {
  return arguments.length ? this.cover(+_14[0][0], +_14[0][1]).cover(+_14[1][0], +_14[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x06, y06, x12, y12) {
  this.node = node;
  this.x0 = x06;
  this.y0 = y06;
  this.x1 = x12;
  this.y1 = y12;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x4, y4, radius) {
  var data, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node) quads.push(new quad_default(node, x06, y06, x32, y32));
  if (radius == null) radius = Infinity;
  else {
    x06 = x4 - radius, y06 = y4 - radius;
    x32 = x4 + radius, y32 = y4 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06) continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x12, ym, xm, y22),
        new quad_default(node[1], xm, y12, x22, ym),
        new quad_default(node[0], x12, y12, xm, ym)
      );
      if (i = (y4 >= ym) << 1 | x4 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x06 = x4 - d, y06 = y4 - d;
        x32 = x4 + d, y32 = y4 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default3(d) {
  if (isNaN(x4 = +this._x.call(null, d)) || isNaN(y4 = +this._y.call(null, d))) return this;
  var parent, node = this._root, retainer, previous, next, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x4, y4, xm, ym, right3, bottom3, i, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right3 = x4 >= (xm = (x06 + x12) / 2)) x06 = xm;
    else x12 = xm;
    if (bottom3 = y4 >= (ym = (y06 + y12) / 2)) y06 = ym;
    else y12 = ym;
    if (!(parent = node, node = node[i = bottom3 << 1 | right3])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  }
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default2() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size;
    while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x06, y06, x12, y12;
  if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x12, y12));
      if (child = node[2]) quads.push(new quad_default(child, x06, ym, xm, y12));
      if (child = node[1]) quads.push(new quad_default(child, xm, y06, x12, ym));
      if (child = node[0]) quads.push(new quad_default(child, x06, y06, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child = node[0]) quads.push(new quad_default(child, x06, y06, xm, ym));
      if (child = node[1]) quads.push(new quad_default(child, xm, y06, x12, ym));
      if (child = node[2]) quads.push(new quad_default(child, x06, ym, xm, y12));
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX2(d) {
  return d[0];
}
function x_default(_14) {
  return arguments.length ? (this._x = _14, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY2(d) {
  return d[1];
}
function y_default(_14) {
  return arguments.length ? (this._y = _14, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x4, y4) {
  var tree = new Quadtree(x4 == null ? defaultX2 : x4, y4 == null ? defaultY2 : y4, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x4, y4, x06, y06, x12, y12) {
  this._x = x4;
  this._y = y4;
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node) return copy3;
  if (!node.length) return copy3._root = leaf_copy(node), copy3;
  nodes = [{ source: node, target: copy3._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy3;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default2;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default3;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default2;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default7(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/collide.js
function x(d) {
  return d.x + d.vx;
}
function y(d) {
  return d.y + d.vy;
}
function collide_default(radius) {
  var nodes, radii, random, strength = 1, iterations2 = 1;
  if (typeof radius !== "function") radius = constant_default7(radius == null ? 1 : +radius);
  function force() {
    var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }
    function apply(quad, x06, y06, x12, y12) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x4 = xi - data.x - data.vx, y4 = yi - data.y - data.vy, l = x4 * x4 + y4 * y4;
          if (l < r * r) {
            if (x4 === 0) x4 = jiggle_default(random), l += x4 * x4;
            if (y4 === 0) y4 = jiggle_default(random), l += y4 * y4;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x4 *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y4 *= l) * r;
            data.vx -= x4 * (r = 1 - r);
            data.vy -= y4 * r;
          }
        }
        return;
      }
      return x06 > xi + r || x12 < xi - r || y06 > yi + r || y12 < yi - r;
    }
  }
  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.iterations = function(_14) {
    return arguments.length ? (iterations2 = +_14, force) : iterations2;
  };
  force.strength = function(_14) {
    return arguments.length ? (strength = +_14, force) : strength;
  };
  force.radius = function(_14) {
    return arguments.length ? (radius = typeof _14 === "function" ? _14 : constant_default7(+_14), initialize(), force) : radius;
  };
  return force;
}

// node_modules/d3-force/src/link.js
function index3(d) {
  return d.index;
}
function find3(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id2 = index3, strength = defaultStrength, strengths, distance = constant_default7(30), distances, nodes, count3, bias, random, iterations2 = 1;
  if (links == null) links = [];
  function defaultStrength(link3) {
    return 1 / Math.min(count3[link3.source.index], count3[link3.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n = links.length; k2 < iterations2; ++k2) {
      for (var i = 0, link3, source, target, x4, y4, l, b; i < n; ++i) {
        link3 = links[i], source = link3.source, target = link3.target;
        x4 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
        y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
        l = Math.sqrt(x4 * x4 + y4 * y4);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x4 *= l, y4 *= l;
        target.vx -= x4 * (b = bias[i]);
        target.vy -= y4 * b;
        source.vx += x4 * (b = 1 - b);
        source.vy += y4 * b;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link3;
    for (i = 0, count3 = new Array(n); i < m3; ++i) {
      link3 = links[i], link3.index = i;
      if (typeof link3.source !== "object") link3.source = find3(nodeById, link3.source);
      if (typeof link3.target !== "object") link3.target = find3(nodeById, link3.target);
      count3[link3.source.index] = (count3[link3.source.index] || 0) + 1;
      count3[link3.target.index] = (count3[link3.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m3); i < m3; ++i) {
      link3 = links[i], bias[i] = count3[link3.source.index] / (count3[link3.source.index] + count3[link3.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.links = function(_14) {
    return arguments.length ? (links = _14, initialize(), force) : links;
  };
  force.id = function(_14) {
    return arguments.length ? (id2 = _14, force) : id2;
  };
  force.iterations = function(_14) {
    return arguments.length ? (iterations2 = +_14, force) : iterations2;
  };
  force.strength = function(_14) {
    return arguments.length ? (strength = typeof _14 === "function" ? _14 : constant_default7(+_14), initializeStrength(), force) : strength;
  };
  force.distance = function(_14) {
    return arguments.length ? (distance = typeof _14 === "function" ? _14 : constant_default7(+_14), initializeDistance(), force) : distance;
  };
  return force;
}

// node_modules/d3-force/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a * s2 + c) % m) / m;
}

// node_modules/d3-force/src/simulation.js
function x2(d) {
  return d.x;
}
function y2(d) {
  return d.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
  if (nodes == null) nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations2) {
    var i, n = nodes.length, node;
    if (iterations2 === void 0) iterations2 = 1;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
        node.x = radius * Math.cos(angle2);
        node.y = radius * Math.sin(angle2);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_14) {
      return arguments.length ? (nodes = _14, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_14) {
      return arguments.length ? (alpha = +_14, simulation) : alpha;
    },
    alphaMin: function(_14) {
      return arguments.length ? (alphaMin = +_14, simulation) : alphaMin;
    },
    alphaDecay: function(_14) {
      return arguments.length ? (alphaDecay = +_14, simulation) : +alphaDecay;
    },
    alphaTarget: function(_14) {
      return arguments.length ? (alphaTarget = +_14, simulation) : alphaTarget;
    },
    velocityDecay: function(_14) {
      return arguments.length ? (velocityDecay = 1 - _14, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_14) {
      return arguments.length ? (random = _14, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _14) {
      return arguments.length > 1 ? (_14 == null ? forces.delete(name) : forces.set(name, initializeForce(_14)), simulation) : forces.get(name);
    },
    find: function(x4, y4, radius) {
      var i = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius == null) radius = Infinity;
      else radius *= radius;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x4 - node.x;
        dy = y4 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _14) {
      return arguments.length > 1 ? (event.on(name, _14), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random, alpha, strength = constant_default7(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_14) {
    var i, n = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
    for (alpha = _14, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c6, weight = 0, x4, y4, i;
    if (quad.length) {
      for (x4 = y4 = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c6 = Math.abs(q.value))) {
          strength2 += q.value, weight += c6, x4 += c6 * q.x, y4 += c6 * q.y;
        }
      }
      quad.x = x4 / weight;
      quad.y = y4 / weight;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x12, _14, x22) {
    if (!quad.value) return true;
    var x4 = quad.x - node.x, y4 = quad.y - node.y, w = x22 - x12, l = x4 * x4 + y4 * y4;
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x4 === 0) x4 = jiggle_default(random), l += x4 * x4;
        if (y4 === 0) y4 = jiggle_default(random), l += y4 * y4;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x4 * quad.value * alpha / l;
        node.vy += y4 * quad.value * alpha / l;
      }
      return true;
    } else if (quad.length || l >= distanceMax2) return;
    if (quad.data !== node || quad.next) {
      if (x4 === 0) x4 = jiggle_default(random), l += x4 * x4;
      if (y4 === 0) y4 = jiggle_default(random), l += y4 * y4;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x4 * w;
        node.vy += y4 * w;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.strength = function(_14) {
    return arguments.length ? (strength = typeof _14 === "function" ? _14 : constant_default7(+_14), initialize(), force) : strength;
  };
  force.distanceMin = function(_14) {
    return arguments.length ? (distanceMin2 = _14 * _14, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_14) {
    return arguments.length ? (distanceMax2 = _14 * _14, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_14) {
    return arguments.length ? (theta2 = _14 * _14, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force/src/radial.js
function radial_default(radius, x4, y4) {
  var nodes, strength = constant_default7(0.1), strengths, radiuses;
  if (typeof radius !== "function") radius = constant_default7(+radius);
  if (x4 == null) x4 = 0;
  if (y4 == null) y4 = 0;
  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i], dx = node.x - x4 || 1e-6, dy = node.y - y4 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k2;
      node.vy += dy * k2;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_14) {
    nodes = _14, initialize();
  };
  force.strength = function(_14) {
    return arguments.length ? (strength = typeof _14 === "function" ? _14 : constant_default7(+_14), initialize(), force) : strength;
  };
  force.radius = function(_14) {
    return arguments.length ? (radius = typeof _14 === "function" ? _14 : constant_default7(+_14), initialize(), force) : radius;
  };
  force.x = function(_14) {
    return arguments.length ? (x4 = +_14, force) : x4;
  };
  force.y = function(_14) {
    return arguments.length ? (y4 = +_14, force) : y4;
  };
  return force;
}

// node_modules/d3-force/src/x.js
function x_default2(x4) {
  var strength = constant_default7(0.1), nodes, strengths, xz;
  if (typeof x4 !== "function") x4 = constant_default7(x4 == null ? 0 : +x4);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_14) {
    nodes = _14;
    initialize();
  };
  force.strength = function(_14) {
    return arguments.length ? (strength = typeof _14 === "function" ? _14 : constant_default7(+_14), initialize(), force) : strength;
  };
  force.x = function(_14) {
    return arguments.length ? (x4 = typeof _14 === "function" ? _14 : constant_default7(+_14), initialize(), force) : x4;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y4) {
  var strength = constant_default7(0.1), nodes, strengths, yz;
  if (typeof y4 !== "function") y4 = constant_default7(y4 == null ? 0 : +y4);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_14) {
    nodes = _14;
    initialize();
  };
  force.strength = function(_14) {
    return arguments.length ? (strength = typeof _14 === "function" ? _14 : constant_default7(+_14), initialize(), force) : strength;
  };
  force.y = function(_14) {
    return arguments.length ? (y4 = typeof _14 === "function" ? _14 : constant_default7(+_14), initialize(), force) : y4;
  };
  return force;
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x4) {
  return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString("en").replace(/,/g, "") : x4.toString(10);
}
function formatDecimalParts(x4, p) {
  if ((i = (x4 = p ? x4.toExponential(p - 1) : x4.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x4.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x4.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x4) {
  return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length3 = 0;
    while (i > 0 && g > 0) {
      if (length3 + g + 1 > width) g = Math.max(1, width - length3);
      t.push(value.substring(i -= g, i + g));
      if ((length3 += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s2[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s2[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x4, p) {
  var d = formatDecimalParts(x4, p);
  if (!d) return x4 + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x4, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x4, p) {
  var d = formatDecimalParts(x4, p);
  if (!d) return x4 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x4, p) => (x4 * 100).toFixed(p),
  "b": (x4) => Math.round(x4).toString(2),
  "c": (x4) => x4 + "",
  "d": formatDecimal_default,
  "e": (x4, p) => x4.toExponential(p),
  "f": (x4, p) => x4.toFixed(p),
  "g": (x4, p) => x4.toPrecision(p),
  "o": (x4) => Math.round(x4).toString(8),
  "p": (x4, p) => formatRounded_default(x4 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x4) => Math.round(x4).toString(16).toUpperCase(),
  "x": (x4) => Math.round(x4).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default2(x4) {
  return x4;
}

// node_modules/d3-format/src/locale.js
var map4 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "Âµ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map4.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map4.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "âˆ’" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n") comma = true, type2 = "g";
    else if (!formatTypes_default[type2]) precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero3 || fill === "0" && align === "=") zero3 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c6;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign3 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c6 = value.charCodeAt(i), 48 > c6 || c6 > 57) {
              valueSuffix = (c6 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value = group2(value, Infinity);
      var length3 = valuePrefix.length + value.length + valueSuffix.length, padding = length3 < width ? new Array(width - length3 + 1).join(fill) : "";
      if (comma && zero3) value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length3 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length3);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k2 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format2;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format2 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max5) {
  step = Math.abs(step), max5 = Math.abs(max5) - step;
  return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;
}

// node_modules/d3-geo/src/math.js
var epsilon7 = 1e-6;
var epsilon22 = 1e-12;
var pi4 = Math.PI;
var halfPi3 = pi4 / 2;
var quarterPi = pi4 / 4;
var tau5 = pi4 * 2;
var degrees3 = 180 / pi4;
var radians2 = pi4 / 180;
var abs3 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos2 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var hypot = Math.hypot;
var log = Math.log;
var pow2 = Math.pow;
var sin2 = Math.sin;
var sign = Math.sign || function(x4) {
  return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi4 : Math.acos(x4);
}
function asin(x4) {
  return x4 > 1 ? halfPi3 : x4 < -1 ? -halfPi3 : Math.asin(x4);
}
function haversin(x4) {
  return (x4 = sin2(x4 / 2)) * x4;
}

// node_modules/d3-geo/src/noop.js
function noop4() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object3, stream) {
    streamGeometry(object3.geometry, stream);
  },
  FeatureCollection: function(object3, stream) {
    var features = object3.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object3, stream) {
    stream.sphere();
  },
  Point: function(object3, stream) {
    object3 = object3.coordinates;
    stream.point(object3[0], object3[1], object3[2]);
  },
  MultiPoint: function(object3, stream) {
    var coordinates2 = object3.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) object3 = coordinates2[i], stream.point(object3[0], object3[1], object3[2]);
  },
  LineString: function(object3, stream) {
    streamLine(object3.coordinates, stream, 0);
  },
  MultiLineString: function(object3, stream) {
    var coordinates2 = object3.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) streamLine(coordinates2[i], stream, 0);
  },
  Polygon: function(object3, stream) {
    streamPolygon(object3.coordinates, stream);
  },
  MultiPolygon: function(object3, stream) {
    var coordinates2 = object3.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) streamPolygon(coordinates2[i], stream);
  },
  GeometryCollection: function(object3, stream) {
    var geometries = object3.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates2, stream, closed) {
  var i = -1, n = coordinates2.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates2, stream) {
  var i = -1, n = coordinates2.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates2[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object3, stream) {
  if (object3 && streamObjectType.hasOwnProperty(object3.type)) {
    streamObjectType[object3.type](object3, stream);
  } else {
    streamGeometry(object3, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();
var lambda00;
var phi00;
var lambda0;
var cosPhi0;
var sinPhi0;
var areaStream = {
  point: noop4,
  lineStart: noop4,
  lineEnd: noop4,
  polygonStart: function() {
    areaRingSum = new Adder();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau5 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop4;
  },
  sphere: function() {
    areaSum.add(tau5);
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaRingEnd() {
  areaPoint(lambda00, phi00);
}
function areaPointFirst(lambda, phi2) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians2, phi2 *= radians2;
  lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);
}
function areaPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k2 = sinPhi0 * sinPhi, u4 = cosPhi0 * cosPhi + k2 * cos2(adLambda), v2 = k2 * sdLambda * sin2(adLambda);
  areaRingSum.add(atan2(v2, u4));
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}
function area_default2(object3) {
  areaSum = new Adder();
  stream_default(object3, areaStream);
  return areaSum * 2;
}

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];
}
function cartesianCross(a4, b) {
  return [a4[1] * b[2] - a4[2] * b[1], a4[2] * b[0] - a4[0] * b[2], a4[0] * b[1] - a4[1] * b[0]];
}
function cartesianAddInPlace(a4, b) {
  a4[0] += b[0], a4[1] += b[1], a4[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// node_modules/d3-geo/src/bounds.js
var lambda02;
var phi0;
var lambda1;
var phi1;
var lambda2;
var lambda002;
var phi002;
var p0;
var deltaSum;
var ranges;
var range3;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum = new Adder();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon7) phi1 = 90;
    else if (deltaSum < -epsilon7) phi0 = -90;
    range3[0] = lambda02, range3[1] = lambda1;
  },
  sphere: function() {
    lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};
function boundsPoint(lambda, phi2) {
  ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
  if (phi2 < phi0) phi0 = phi2;
  if (phi2 > phi1) phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p = cartesian([lambda * radians2, phi2 * radians2]);
  if (p0) {
    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign3 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign3, phii, antimeridian = abs3(delta) > 180;
    if (antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
      phii = inflection[1] * degrees3;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
      phii = -inflection[1] * degrees3;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi2 < phi0) phi0 = phi2;
      if (phi2 > phi1) phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda02, lambda) > angle(lambda02, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda02, lambda1)) lambda02 = lambda;
      }
    } else {
      if (lambda1 >= lambda02) {
        if (lambda < lambda02) lambda02 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1)) lambda02 = lambda;
        }
      }
    }
  } else {
    ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0) phi0 = phi2;
  if (phi2 > phi1) phi1 = phi2;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream.point = linePoint;
}
function boundsLineEnd() {
  range3[0] = lambda02, range3[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs3(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda002 = lambda, phi002 = phi2;
  }
  areaStream.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda002, phi002);
  areaStream.lineEnd();
  if (abs3(deltaSum) > epsilon7) lambda02 = -(lambda1 = 180);
  range3[0] = lambda02, range3[1] = lambda1;
  p0 = null;
}
function angle(lambda04, lambda12) {
  return (lambda12 -= lambda04) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a4, b) {
  return a4[0] - b[0];
}
function rangeContains(range4, x4) {
  return range4[0] <= range4[1] ? range4[0] <= x4 && x4 <= range4[1] : x4 < range4[0] || range4[1] < x4;
}
function bounds_default(feature) {
  var i, n, a4, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
  ranges = [];
  stream_default(feature, boundsStream);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i = 1, a4 = ranges[0], merged = [a4]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a4, b[0]) || rangeContains(a4, b[1])) {
        if (angle(a4[0], b[1]) > angle(a4[0], a4[1])) a4[1] = b[1];
        if (angle(b[0], a4[1]) > angle(a4[0], a4[1])) a4[0] = b[0];
      } else {
        merged.push(a4 = b);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a4 = merged[n]; i <= n; a4 = b, ++i) {
      b = merged[i];
      if ((delta = angle(a4[1], b[0])) > deltaMax) deltaMax = delta, lambda02 = b[0], lambda1 = a4[1];
    }
  }
  ranges = range3 = null;
  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
}

// node_modules/d3-geo/src/centroid.js
var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda003;
var phi003;
var x0;
var y0;
var z0;
var centroidStream = {
  sphere: noop4,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};
function centroidPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
}
function centroidPointCartesian(x4, y4, z) {
  ++W0;
  X0 += (x4 - X0) / W0;
  Y0 += (y4 - Y0) / W0;
  Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), w = atan2(sqrt((w = y0 * z - z0 * y4) * w + (w = z0 * x4 - x0 * z) * w + (w = x0 * y4 - y0 * x4) * w), x0 * x4 + y0 * y4 + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x4));
  Y1 += w * (y0 + (y0 = y4));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda003, phi003);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda003 = lambda, phi003 = phi2;
  lambda *= radians2, phi2 *= radians2;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y4, cy = z0 * x4 - x0 * z, cz = x0 * y4 - y0 * x4, m3 = hypot(cx, cy, cz), w = asin(m3), v2 = m3 && -w / m3;
  X2.add(v2 * cx);
  Y2.add(v2 * cy);
  Z2.add(v2 * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x4));
  Y1 += w * (y0 + (y0 = y4));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object3) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X2 = new Adder();
  Y2 = new Adder();
  Z2 = new Adder();
  stream_default(object3, centroidStream);
  var x4 = +X2, y4 = +Y2, z = +Z2, m3 = hypot(x4, y4, z);
  if (m3 < epsilon22) {
    x4 = X1, y4 = Y1, z = Z1;
    if (W1 < epsilon7) x4 = X0, y4 = Y0, z = Z0;
    m3 = hypot(x4, y4, z);
    if (m3 < epsilon22) return [NaN, NaN];
  }
  return [atan2(y4, x4) * degrees3, asin(z / m3) * degrees3];
}

// node_modules/d3-geo/src/constant.js
function constant_default8(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-geo/src/compose.js
function compose_default(a4, b) {
  function compose(x4, y4) {
    return x4 = a4(x4, y4), b(x4[0], x4[1]);
  }
  if (a4.invert && b.invert) compose.invert = function(x4, y4) {
    return x4 = b.invert(x4, y4), x4 && a4.invert(x4[0], x4[1]);
  };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs3(lambda) > pi4) lambda -= Math.round(lambda / tau5) * tau5;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau5) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs3(lambda) > pi4) lambda -= Math.round(lambda / tau5) * tau5;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x4 * sinDeltaPhi;
    return [
      atan2(y4 * cosDeltaGamma - k2 * sinDeltaGamma, x4 * cosDeltaPhi - z * sinDeltaPhi),
      asin(k2 * cosDeltaGamma + y4 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y4 * sinDeltaGamma;
    return [
      atan2(y4 * cosDeltaGamma + z * sinDeltaGamma, x4 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin(k2 * cosDeltaPhi - x4 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates2) {
    coordinates2 = rotate(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
  }
  forward.invert = function(coordinates2) {
    coordinates2 = rotate.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t03, t13) {
  if (!delta) return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction * delta;
  if (t03 == null) {
    t03 = radius + direction * tau5;
    t13 = radius - step / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13) t03 += direction * tau5;
  }
  for (var point7, t = t03; direction > 0 ? t > t13 : t < t13; t -= step) {
    point7 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream.point(point7[0], point7[1]);
  }
}
function circleRadius(cosRadius, point7) {
  point7 = cartesian(point7), point7[0] -= cosRadius;
  cartesianNormalizeInPlace(point7);
  var radius = acos(-point7[1]);
  return ((-point7[2] < 0 ? -radius : radius) + tau5 - epsilon7) % tau5;
}
function circle_default() {
  var center2 = constant_default8([0, 0]), radius = constant_default8(90), precision = constant_default8(2), ring, rotate, stream = { point: point7 };
  function point7(x4, y4) {
    ring.push(x4 = rotate(x4, y4));
    x4[0] *= degrees3, x4[1] *= degrees3;
  }
  function circle() {
    var c6 = center2.apply(this, arguments), r = radius.apply(this, arguments) * radians2, p = precision.apply(this, arguments) * radians2;
    ring = [];
    rotate = rotateRadians(-c6[0] * radians2, -c6[1] * radians2, 0).invert;
    circleStream(stream, r, p, 1);
    c6 = { type: "Polygon", coordinates: [ring] };
    ring = rotate = null;
    return c6;
  }
  circle.center = function(_14) {
    return arguments.length ? (center2 = typeof _14 === "function" ? _14 : constant_default8([+_14[0], +_14[1]]), circle) : center2;
  };
  circle.radius = function(_14) {
    return arguments.length ? (radius = typeof _14 === "function" ? _14 : constant_default8(+_14), circle) : radius;
  };
  circle.precision = function(_14) {
    return arguments.length ? (precision = typeof _14 === "function" ? _14 : constant_default8(+_14), circle) : precision;
  };
  return circle;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default2() {
  var lines = [], line;
  return {
    point: function(x4, y4, m3) {
      line.push([x4, y4, m3]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop4,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a4, b) {
  return abs3(a4[0] - b[0]) < epsilon7 && abs3(a4[1] - b[1]) < epsilon7;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point7, points, other, entry) {
  this.x = point7;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0) return;
    var n2, p02 = segment[0], p1 = segment[n2], x4;
    if (pointEqual_default(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i) stream.point((p02 = segment[i])[0], p02[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon7;
    }
    subject.push(x4 = new Intersection(p02, segment, null, true));
    clip.push(x4.o = new Intersection(p02, null, x4, false));
    subject.push(x4 = new Intersection(p1, segment, null, false));
    clip.push(x4.o = new Intersection(p1, null, x4, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start3 = subject[0], points, point7;
  while (1) {
    var current = start3, isSubject = true;
    while (current.v) if ((current = current.n) === start3) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point7 = points[i])[0], point7[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point7 = points[i])[0], point7[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array5) {
  if (!(n = array5.length)) return;
  var n, i = 0, a4 = array5[0], b;
  while (++i < n) {
    a4.n = b = array5[i];
    b.p = a4;
    a4 = b;
  }
  a4.n = b = array5[0];
  b.p = a4;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point7) {
  return abs3(point7[0]) <= pi4 ? point7[0] : sign(point7[0]) * ((abs3(point7[0]) + pi4) % tau5 - pi4);
}
function polygonContains_default(polygon, point7) {
  var lambda = longitude(point7), phi2 = point7[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  var sum4 = new Adder();
  if (sinPhi === 1) phi2 = halfPi3 + epsilon7;
  else if (sinPhi === -1) phi2 = -halfPi3 - epsilon7;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m3 = (ring = polygon[i]).length)) continue;
    var ring, m3, point0 = ring[m3 - 1], lambda04 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi03 = sin2(phi02), cosPhi03 = cos2(phi02);
    for (var j = 0; j < m3; ++j, lambda04 = lambda12, sinPhi03 = sinPhi1, cosPhi03 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda04, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi4, k2 = sinPhi03 * sinPhi1;
      sum4.add(atan2(k2 * sign3 * sin2(absDelta), cosPhi03 * cosPhi1 + k2 * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign3 * tau5 : delta;
      if (antimeridian ^ lambda04 >= lambda ^ lambda12 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection2 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon7 || angle2 < epsilon7 && sum4 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start3) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default2(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point7;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start3);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point7(lambda, phi2) {
      if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point7;
      line.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m3, segment, point8;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m3 = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m3; ++i) sink.point((point8 = segment[i])[0], point8[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a4, b) {
  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi3 - epsilon7 : halfPi3 - a4[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi3 - epsilon7 : halfPi3 - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi4, -halfPi3]
);
function clipAntimeridianLine(stream) {
  var lambda04 = NaN, phi02 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi4 : -pi4, delta = abs3(lambda12 - lambda04);
      if (abs3(delta - pi4) < epsilon7) {
        stream.point(lambda04, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi3 : -halfPi3);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        stream.point(lambda12, phi02);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi4) {
        if (abs3(lambda04 - sign0) < epsilon7) lambda04 -= sign0 * epsilon7;
        if (abs3(lambda12 - sign1) < epsilon7) lambda12 -= sign1 * epsilon7;
        phi02 = clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        clean = 0;
      }
      stream.point(lambda04 = lambda12, phi02 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda04 = phi02 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12) {
  var cosPhi03, cosPhi1, sinLambda0Lambda1 = sin2(lambda04 - lambda12);
  return abs3(sinLambda0Lambda1) > epsilon7 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi03 = cos2(phi02)) * sin2(lambda04)) / (cosPhi03 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi3;
    stream.point(-pi4, phi2);
    stream.point(0, phi2);
    stream.point(pi4, phi2);
    stream.point(pi4, 0);
    stream.point(pi4, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi4, -phi2);
    stream.point(-pi4, 0);
    stream.point(-pi4, phi2);
  } else if (abs3(from[0] - to[0]) > epsilon7) {
    var lambda = from[0] < to[0] ? pi4 : -pi4;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius) {
  var cr = cos2(radius), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs3(cr) > epsilon7;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c6 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi2) : 0;
        if (!point0 && (v00 = v0 = v2)) stream.lineStart();
        if (v2 !== v0) {
          point22 = intersect2(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point22 = intersect2(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect2(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t;
          if (!(c6 & c0) && (t = intersect2(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c6;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect2(a4, b, two) {
    var pa = cartesian(a4), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a4;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B3);
    var u4 = n1xn2, w = cartesianDot(A5, u4), uu = cartesianDot(u4, u4), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0) return;
    var t = sqrt(t22), q = cartesianScale(u4, (-w - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two) return q;
    var lambda04 = a4[0], lambda12 = b[0], phi02 = a4[1], phi12 = b[1], z;
    if (lambda12 < lambda04) z = lambda04, lambda04 = lambda12, lambda12 = z;
    var delta2 = lambda12 - lambda04, polar = abs3(delta2 - pi4) < epsilon7, meridian = polar || delta2 < epsilon7;
    if (!polar && phi12 < phi02) z = phi02, phi02 = phi12, phi12 = z;
    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs3(q[0] - lambda04) < epsilon7 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi4 ^ (lambda04 <= q[0] && q[0] <= lambda12)) {
      var q1 = cartesianScale(u4, (-w + t) / uu);
      cartesianAddInPlace(q1, A5);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r = smallRadius ? radius : pi4 - radius, code2 = 0;
    if (lambda < -r) code2 |= 1;
    else if (lambda > r) code2 |= 2;
    if (phi2 < -r) code2 |= 4;
    else if (phi2 > r) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi4, radius - pi4]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default(a4, b, x06, y06, x12, y12) {
  var ax = a4[0], ay = a4[1], bx = b[0], by = b[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;
  r = x06 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  } else if (dx > 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  } else if (dx > 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  }
  r = y06 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  } else if (dy > 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  } else if (dy > 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  }
  if (t03 > 0) a4[0] = ax + t03 * dx, a4[1] = ay + t03 * dy;
  if (t13 < 1) b[0] = ax + t13 * dx, b[1] = ay + t13 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x06, y06, x12, y12) {
  function visible(x4, y4) {
    return x06 <= x4 && x4 <= x12 && y06 <= y4 && y4 <= y12;
  }
  function interpolate(from, to, direction, stream) {
    var a4 = 0, a1 = 0;
    if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a4 === 0 || a4 === 3 ? x06 : x12, a4 > 1 ? y12 : y06);
      while ((a4 = (a4 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs3(p[0] - x06) < epsilon7 ? direction > 0 ? 0 : 3 : abs3(p[0] - x12) < epsilon7 ? direction > 0 ? 2 : 1 : abs3(p[1] - y06) < epsilon7 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a4, b) {
    return comparePoint(a4.x, b.x);
  }
  function comparePoint(a4, b) {
    var ca3 = corner(a4, 1), cb = corner(b, 1);
    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b[1] - a4[1] : ca3 === 1 ? a4[0] - b[0] : ca3 === 2 ? a4[1] - b[1] : b[0] - a4[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default2(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point7(x4, y4) {
      if (visible(x4, y4)) activeStream.point(x4, y4);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point8 = ring2[0], a0, a1, b02 = point8[0], b12 = point8[1]; j < m3; ++j) {
          a0 = b02, a1 = b12, point8 = ring2[j], b02 = point8[0], b12 = point8[1];
          if (a1 <= y12) {
            if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x06 - a0)) ++winding;
          } else {
            if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x06 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint2(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point7;
      if (v_) activeStream.lineEnd();
    }
    function linePoint2(x4, y4) {
      var v2 = visible(x4, y4);
      if (polygon) ring.push([x4, y4]);
      if (first) {
        x__ = x4, y__ = y4, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x4, y4);
        }
      } else {
        if (v2 && v_) activeStream.point(x4, y4);
        else {
          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x4 = Math.max(clipMin, Math.min(clipMax, x4)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];
          if (line_default(a4, b, x06, y06, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a4[0], a4[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v2) activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x4, y4);
            clean = false;
          }
        }
      }
      x_ = x4, y_ = y4, v_ = v2;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/clip/extent.js
function extent_default2() {
  var x06 = 0, y06 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip;
  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipRectangle(x06, y06, x12, y12)(cacheStream = stream);
    },
    extent: function(_14) {
      return arguments.length ? (x06 = +_14[0][0], y06 = +_14[0][1], x12 = +_14[1][0], y12 = +_14[1][1], cache = cacheStream = null, clip) : [[x06, y06], [x12, y12]];
    }
  };
}

// node_modules/d3-geo/src/length.js
var lengthSum;
var lambda03;
var sinPhi02;
var cosPhi02;
var lengthStream = {
  sphere: noop4,
  point: noop4,
  lineStart: lengthLineStart,
  lineEnd: noop4,
  polygonStart: noop4,
  polygonEnd: noop4
};
function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}
function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop4;
}
function lengthPointFirst(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  lambda03 = lambda, sinPhi02 = sin2(phi2), cosPhi02 = cos2(phi2);
  lengthStream.point = lengthPoint;
}
function lengthPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var sinPhi = sin2(phi2), cosPhi = cos2(phi2), delta = abs3(lambda - lambda03), cosDelta = cos2(delta), sinDelta = sin2(delta), x4 = cosPhi * sinDelta, y4 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta, z = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x4 * x4 + y4 * y4), z));
  lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;
}
function length_default(object3) {
  lengthSum = new Adder();
  stream_default(object3, lengthStream);
  return +lengthSum;
}

// node_modules/d3-geo/src/distance.js
var coordinates = [null, null];
var object2 = { type: "LineString", coordinates };
function distance_default(a4, b) {
  coordinates[0] = a4;
  coordinates[1] = b;
  return length_default(object2);
}

// node_modules/d3-geo/src/contains.js
var containsObjectType = {
  Feature: function(object3, point7) {
    return containsGeometry(object3.geometry, point7);
  },
  FeatureCollection: function(object3, point7) {
    var features = object3.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point7)) return true;
    return false;
  }
};
var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object3, point7) {
    return containsPoint(object3.coordinates, point7);
  },
  MultiPoint: function(object3, point7) {
    var coordinates2 = object3.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) if (containsPoint(coordinates2[i], point7)) return true;
    return false;
  },
  LineString: function(object3, point7) {
    return containsLine(object3.coordinates, point7);
  },
  MultiLineString: function(object3, point7) {
    var coordinates2 = object3.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) if (containsLine(coordinates2[i], point7)) return true;
    return false;
  },
  Polygon: function(object3, point7) {
    return containsPolygon(object3.coordinates, point7);
  },
  MultiPolygon: function(object3, point7) {
    var coordinates2 = object3.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) if (containsPolygon(coordinates2[i], point7)) return true;
    return false;
  },
  GeometryCollection: function(object3, point7) {
    var geometries = object3.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point7)) return true;
    return false;
  }
};
function containsGeometry(geometry, point7) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point7) : false;
}
function containsPoint(coordinates2, point7) {
  return distance_default(coordinates2, point7) === 0;
}
function containsLine(coordinates2, point7) {
  var ao, bo, ab4;
  for (var i = 0, n = coordinates2.length; i < n; i++) {
    bo = distance_default(coordinates2[i], point7);
    if (bo === 0) return true;
    if (i > 0) {
      ab4 = distance_default(coordinates2[i], coordinates2[i - 1]);
      if (ab4 > 0 && ao <= ab4 && bo <= ab4 && (ao + bo - ab4) * (1 - Math.pow((ao - bo) / ab4, 2)) < epsilon22 * ab4)
        return true;
    }
    ao = bo;
  }
  return false;
}
function containsPolygon(coordinates2, point7) {
  return !!polygonContains_default(coordinates2.map(ringRadians), pointRadians(point7));
}
function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}
function pointRadians(point7) {
  return [point7[0] * radians2, point7[1] * radians2];
}
function contains_default2(object3, point7) {
  return (object3 && containsObjectType.hasOwnProperty(object3.type) ? containsObjectType[object3.type] : containsGeometry)(object3, point7);
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y06, y12, dy) {
  var y4 = range(y06, y12 - epsilon7, dy).concat(y12);
  return function(x4) {
    return y4.map(function(y5) {
      return [x4, y5];
    });
  };
}
function graticuleY(x06, x12, dx) {
  var x4 = range(x06, x12 - epsilon7, dx).concat(x12);
  return function(y4) {
    return x4.map(function(x5) {
      return [x5, y4];
    });
  };
}
function graticule() {
  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x4, y4, X3, Y3, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x5) {
      return abs3(x5 % DX) > epsilon7;
    }).map(x4)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y5) {
      return abs3(y5 % DY) > epsilon7;
    }).map(y4));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates2) {
      return { type: "LineString", coordinates: coordinates2 };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X3(X03).concat(
          Y3(Y13).slice(1),
          X3(X13).reverse().slice(1),
          Y3(Y03).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_14) {
    if (!arguments.length) return graticule2.extentMinor();
    return graticule2.extentMajor(_14).extentMinor(_14);
  };
  graticule2.extentMajor = function(_14) {
    if (!arguments.length) return [[X03, Y03], [X13, Y13]];
    X03 = +_14[0][0], X13 = +_14[1][0];
    Y03 = +_14[0][1], Y13 = +_14[1][1];
    if (X03 > X13) _14 = X03, X03 = X13, X13 = _14;
    if (Y03 > Y13) _14 = Y03, Y03 = Y13, Y13 = _14;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_14) {
    if (!arguments.length) return [[x06, y06], [x12, y12]];
    x06 = +_14[0][0], x12 = +_14[1][0];
    y06 = +_14[0][1], y12 = +_14[1][1];
    if (x06 > x12) _14 = x06, x06 = x12, x12 = _14;
    if (y06 > y12) _14 = y06, y06 = y12, y12 = _14;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_14) {
    if (!arguments.length) return graticule2.stepMinor();
    return graticule2.stepMajor(_14).stepMinor(_14);
  };
  graticule2.stepMajor = function(_14) {
    if (!arguments.length) return [DX, DY];
    DX = +_14[0], DY = +_14[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_14) {
    if (!arguments.length) return [dx, dy];
    dx = +_14[0], dy = +_14[1];
    return graticule2;
  };
  graticule2.precision = function(_14) {
    if (!arguments.length) return precision;
    precision = +_14;
    x4 = graticuleX(y06, y12, 90);
    y4 = graticuleY(x06, x12, precision);
    X3 = graticuleX(Y03, Y13, 90);
    Y3 = graticuleY(X03, X13, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon7], [180, 90 - epsilon7]]).extentMinor([[-180, -80 - epsilon7], [180, 80 + epsilon7]]);
}
function graticule10() {
  return graticule()();
}

// node_modules/d3-geo/src/interpolate.js
function interpolate_default2(a4, b) {
  var x06 = a4[0] * radians2, y06 = a4[1] * radians2, x12 = b[0] * radians2, y12 = b[1] * radians2, cy0 = cos2(y06), sy0 = sin2(y06), cy1 = cos2(y12), sy1 = sin2(y12), kx0 = cy0 * cos2(x06), ky0 = cy0 * sin2(x06), kx1 = cy1 * cos2(x12), ky1 = cy1 * sin2(x12), d = 2 * asin(sqrt(haversin(y12 - y06) + cy0 * cy1 * haversin(x12 - x06))), k2 = sin2(d);
  var interpolate = d ? function(t) {
    var B3 = sin2(t *= d) / k2, A5 = sin2(d - t) / k2, x4 = A5 * kx0 + B3 * kx1, y4 = A5 * ky0 + B3 * ky1, z = A5 * sy0 + B3 * sy1;
    return [
      atan2(y4, x4) * degrees3,
      atan2(z, sqrt(x4 * x4 + y4 * y4)) * degrees3
    ];
  } : function() {
    return [x06 * degrees3, y06 * degrees3];
  };
  interpolate.distance = d;
  return interpolate;
}

// node_modules/d3-geo/src/identity.js
var identity_default3 = (x4) => x4;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x02;
var y02;
var areaStream2 = {
  point: noop4,
  lineStart: noop4,
  lineEnd: noop4,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart2;
    areaStream2.lineEnd = areaRingEnd2;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop4;
    areaSum2.add(abs3(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area = areaSum2 / 2;
    areaSum2 = new Adder();
    return area;
  }
};
function areaRingStart2() {
  areaStream2.point = areaPointFirst2;
}
function areaPointFirst2(x4, y4) {
  areaStream2.point = areaPoint2;
  x00 = x02 = x4, y00 = y02 = y4;
}
function areaPoint2(x4, y4) {
  areaRingSum2.add(y02 * x4 - x02 * y4);
  x02 = x4, y02 = y4;
}
function areaRingEnd2() {
  areaPoint2(x00, y00);
}
var area_default3 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x03 = Infinity;
var y03 = x03;
var x1 = -x03;
var y1 = x1;
var boundsStream2 = {
  point: boundsPoint2,
  lineStart: noop4,
  lineEnd: noop4,
  polygonStart: noop4,
  polygonEnd: noop4,
  result: function() {
    var bounds = [[x03, y03], [x1, y1]];
    x1 = y1 = -(y03 = x03 = Infinity);
    return bounds;
  }
};
function boundsPoint2(x4, y4) {
  if (x4 < x03) x03 = x4;
  if (x4 > x1) x1 = x4;
  if (y4 < y03) y03 = y4;
  if (y4 > y1) y1 = y4;
}
var bounds_default2 = boundsStream2;

// node_modules/d3-geo/src/path/centroid.js
var X02 = 0;
var Y02 = 0;
var Z02 = 0;
var X12 = 0;
var Y12 = 0;
var Z12 = 0;
var X22 = 0;
var Y22 = 0;
var Z22 = 0;
var x002;
var y002;
var x04;
var y04;
var centroidStream2 = {
  point: centroidPoint2,
  lineStart: centroidLineStart2,
  lineEnd: centroidLineEnd2,
  polygonStart: function() {
    centroidStream2.lineStart = centroidRingStart2;
    centroidStream2.lineEnd = centroidRingEnd2;
  },
  polygonEnd: function() {
    centroidStream2.point = centroidPoint2;
    centroidStream2.lineStart = centroidLineStart2;
    centroidStream2.lineEnd = centroidLineEnd2;
  },
  result: function() {
    var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
    return centroid;
  }
};
function centroidPoint2(x4, y4) {
  X02 += x4;
  Y02 += y4;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x4, y4) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x4, y04 = y4);
}
function centroidPointLine(x4, y4) {
  var dx = x4 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);
  X12 += z * (x04 + x4) / 2;
  Y12 += z * (y04 + y4) / 2;
  Z12 += z;
  centroidPoint2(x04 = x4, y04 = y4);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x4, y4) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x4, y002 = y04 = y4);
}
function centroidPointRing(x4, y4) {
  var dx = x4 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);
  X12 += z * (x04 + x4) / 2;
  Y12 += z * (y04 + y4) / 2;
  Z12 += z;
  z = y04 * x4 - x04 * y4;
  X22 += z * (x04 + x4);
  Y22 += z * (y04 + y4);
  Z22 += z * 3;
  centroidPoint2(x04 = x4, y04 = y4);
}
var centroid_default2 = centroidStream2;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_14) {
    return this._radius = _14, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x4, y4) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x4, y4);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x4, y4);
        break;
      }
      default: {
        this._context.moveTo(x4 + this._radius, y4);
        this._context.arc(x4, y4, this._radius, 0, tau5);
        break;
      }
    }
  },
  result: noop4
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum2 = new Adder();
var lengthRing;
var x003;
var y003;
var x05;
var y05;
var lengthStream2 = {
  point: noop4,
  lineStart: function() {
    lengthStream2.point = lengthPointFirst2;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint2(x003, y003);
    lengthStream2.point = noop4;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length3 = +lengthSum2;
    lengthSum2 = new Adder();
    return length3;
  }
};
function lengthPointFirst2(x4, y4) {
  lengthStream2.point = lengthPoint2;
  x003 = x05 = x4, y003 = y05 = y4;
}
function lengthPoint2(x4, y4) {
  x05 -= x4, y05 -= y4;
  lengthSum2.add(sqrt(x05 * x05 + y05 * y05));
  x05 = x4, y05 = y4;
}
var measure_default = lengthStream2;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_14) {
    this._radius = +_14;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x4, y4) {
    switch (this._point) {
      case 0: {
        this._append`M${x4},${y4}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x4},${y4}`;
        break;
      }
      default: {
        this._append`M${x4},${y4}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s2 = this._;
          this._ = "";
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s2;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound2(digits) {
  const d = Math.floor(digits);
  if (!(d >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d > 15) return append2;
  if (d !== cacheDigits) {
    const k2 = 10 ** d;
    cacheDigits = d;
    cacheAppend = function append3(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default(projection2, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path3(object3) {
    if (object3) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object3, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path3.area = function(object3) {
    stream_default(object3, projectionStream(area_default3));
    return area_default3.result();
  };
  path3.measure = function(object3) {
    stream_default(object3, projectionStream(measure_default));
    return measure_default.result();
  };
  path3.bounds = function(object3) {
    stream_default(object3, projectionStream(bounds_default2));
    return bounds_default2.result();
  };
  path3.centroid = function(object3) {
    stream_default(object3, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path3.projection = function(_14) {
    if (!arguments.length) return projection2;
    projectionStream = _14 == null ? (projection2 = null, identity_default3) : (projection2 = _14).stream;
    return path3;
  };
  path3.context = function(_14) {
    if (!arguments.length) return context;
    contextStream = _14 == null ? (context = null, new PathString(digits)) : new PathContext(context = _14);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path3;
  };
  path3.pointRadius = function(_14) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _14 === "function" ? _14 : (contextStream.pointRadius(+_14), +_14);
    return path3;
  };
  path3.digits = function(_14) {
    if (!arguments.length) return digits;
    if (_14 == null) digits = null;
    else {
      const d = Math.floor(_14);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_14}`);
      digits = d;
    }
    if (context === null) contextStream = new PathString(digits);
    return path3;
  };
  return path3.projection(projection2).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transform_default(methods) {
  return {
    stream: transformer(methods)
  };
}
function transformer(methods) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key in methods) s2[key] = methods[key];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x4, y4) {
    this.stream.point(x4, y4);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection2, fitBounds, object3) {
  var clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null) projection2.clipExtent(null);
  stream_default(object3, projection2.stream(bounds_default2));
  fitBounds(bounds_default2.result());
  if (clip != null) projection2.clipExtent(clip);
  return projection2;
}
function fitExtent(projection2, extent2, object3) {
  return fit(projection2, function(b) {
    var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x4 = +extent2[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = +extent2[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x4, y4]);
  }, object3);
}
function fitSize(projection2, size, object3) {
  return fitExtent(projection2, [[0, 0], size], object3);
}
function fitWidth(projection2, width, object3) {
  return fit(projection2, function(b) {
    var w = +width, k2 = w / (b[1][0] - b[0][0]), x4 = (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = -k2 * b[0][1];
    projection2.scale(150 * k2).translate([x4, y4]);
  }, object3);
}
function fitHeight(projection2, height, object3) {
  return fit(projection2, function(b) {
    var h = +height, k2 = h / (b[1][1] - b[0][1]), x4 = -k2 * b[0][0], y4 = (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x4, y4]);
  }, object3);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians2);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x4, y4) {
      x4 = project(x4, y4);
      this.stream.point(x4[0], x4[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x06, y06, lambda04, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {
    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a4 = a0 + a1, b = b02 + b12, c6 = c0 + c1, m3 = sqrt(a4 * a4 + b * b + c6 * c6), phi2 = asin(c6 /= m3), lambda22 = abs3(abs3(c6) - 1) < epsilon7 || abs3(lambda04 - lambda12) < epsilon7 ? (lambda04 + lambda12) / 2 : atan2(b, a4), p = project(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs3((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x06, y06, lambda04, a0, b02, c0, x22, y22, lambda22, a4 /= m3, b /= m3, c6, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda22, a4, b, c6, x12, y12, lambda12, a1, b12, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda004, x004, y004, a00, b00, c00, lambda04, x06, y06, a0, b02, c0;
    var resampleStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point7(x4, y4) {
      x4 = project(x4, y4);
      stream.point(x4[0], x4[1]);
    }
    function lineStart() {
      x06 = NaN;
      resampleStream.point = linePoint2;
      stream.lineStart();
    }
    function linePoint2(lambda, phi2) {
      var c6 = cartesian([lambda, phi2]), p = project(lambda, phi2);
      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x06 = p[0], y06 = p[1], lambda04 = lambda, a0 = c6[0], b02 = c6[1], c0 = c6[2], maxDepth, stream);
      stream.point(x06, y06);
    }
    function lineEnd() {
      resampleStream.point = point7;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint2(lambda004 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b02, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x4, y4) {
    this.stream.point(x4 * radians2, y4 * radians2);
  }
});
function transformRotate(rotate) {
  return transformer({
    point: function(x4, y4) {
      var r = rotate(x4, y4);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform2(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [dx + k2 * x4, dy - k2 * y4];
  }
  transform2.invert = function(x4, y4) {
    return [(x4 - dx) / k2 * sx, (dy - y4) / k2 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k2, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform2(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [a4 * x4 - b * y4 + dx, dy - b * x4 - a4 * y4];
  }
  transform2.invert = function(x4, y4) {
    return [sx * (ai * x4 - bi * y4 + ci), sy * (fi - bi * x4 - ai * y4)];
  };
  return transform2;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x4 = 480, y4 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection2(point7) {
    return projectRotateTransform(point7[0] * radians2, point7[1] * radians2);
  }
  function invert(point7) {
    point7 = projectRotateTransform.invert(point7[0], point7[1]);
    return point7 && [point7[0] * degrees3, point7[1] * degrees3];
  }
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_14) {
    return arguments.length ? (preclip = _14, theta = void 0, reset()) : preclip;
  };
  projection2.postclip = function(_14) {
    return arguments.length ? (postclip = _14, x06 = y06 = x12 = y12 = null, reset()) : postclip;
  };
  projection2.clipAngle = function(_14) {
    return arguments.length ? (preclip = +_14 ? circle_default2(theta = _14 * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
  };
  projection2.clipExtent = function(_14) {
    return arguments.length ? (postclip = _14 == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_14[0][0], y06 = +_14[0][1], x12 = +_14[1][0], y12 = +_14[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection2.scale = function(_14) {
    return arguments.length ? (k2 = +_14, recenter()) : k2;
  };
  projection2.translate = function(_14) {
    return arguments.length ? (x4 = +_14[0], y4 = +_14[1], recenter()) : [x4, y4];
  };
  projection2.center = function(_14) {
    return arguments.length ? (lambda = _14[0] % 360 * radians2, phi2 = _14[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
  };
  projection2.rotate = function(_14) {
    return arguments.length ? (deltaLambda = _14[0] % 360 * radians2, deltaPhi = _14[1] % 360 * radians2, deltaGamma = _14.length > 2 ? _14[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection2.angle = function(_14) {
    return arguments.length ? (alpha = _14 % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection2.reflectX = function(_14) {
    return arguments.length ? (sx = _14 ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_14) {
    return arguments.length ? (sy = _14 ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_14) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _14 * _14), reset()) : sqrt(delta2);
  };
  projection2.fitExtent = function(extent2, object3) {
    return fitExtent(projection2, extent2, object3);
  };
  projection2.fitSize = function(size, object3) {
    return fitSize(projection2, size, object3);
  };
  projection2.fitWidth = function(width, object3) {
    return fitWidth(projection2, width, object3);
  };
  projection2.fitHeight = function(height, object3) {
    return fitHeight(projection2, height, object3);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = scaleTranslateRotate(k2, x4 - center2[0], y4 - center2[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform2);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi02 = 0, phi12 = pi4 / 3, m3 = projectionMutator(projectAt), p = m3(phi02, phi12);
  p.parallels = function(_14) {
    return arguments.length ? m3(phi02 = _14[0] * radians2, phi12 = _14[1] * radians2) : [phi02 * degrees3, phi12 * degrees3];
  };
  return p;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi03 = cos2(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi03, sin2(phi2) / cosPhi03];
  }
  forward.invert = function(x4, y4) {
    return [x4 / cosPhi03, asin(y4 * cosPhi03)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y06, y12) {
  var sy0 = sin2(y06), n = (sy0 + sin2(y12)) / 2;
  if (abs3(n) < epsilon7) return cylindricalEqualAreaRaw(y06);
  var c6 = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c6) / n;
  function project(x4, y4) {
    var r = sqrt(c6 - 2 * n * sin2(y4)) / n;
    return [r * sin2(x4 *= n), r0 - r * cos2(x4)];
  }
  project.invert = function(x4, y4) {
    var r0y = r0 - y4, l = atan2(x4, abs3(r0y)) * sign(r0y);
    if (r0y * n < 0)
      l -= pi4 * sign(x4) * sign(r0y);
    return [l / n, asin((c6 - (x4 * x4 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x4, y4) {
      var i = -1;
      while (++i < n) streams[i].point(x4, y4);
    },
    sphere: function() {
      var i = -1;
      while (++i < n) streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n) streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n) streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n) streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n) streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point7, pointStream = { point: function(x4, y4) {
    point7 = [x4, y4];
  } };
  function albersUsa(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point7 = null, (lower48Point.point(x4, y4), point7) || (alaskaPoint.point(x4, y4), point7) || (hawaiiPoint.point(x4, y4), point7);
  }
  albersUsa.invert = function(coordinates2) {
    var k2 = lower48.scale(), t = lower48.translate(), x4 = (coordinates2[0] - t[0]) / k2, y4 = (coordinates2[1] - t[1]) / k2;
    return (y4 >= 0.12 && y4 < 0.234 && x4 >= -0.425 && x4 < -0.214 ? alaska : y4 >= 0.166 && y4 < 0.234 && x4 >= -0.214 && x4 < -0.115 ? hawaii : lower48).invert(coordinates2);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_14) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_14), alaska.precision(_14), hawaii.precision(_14);
    return reset();
  };
  albersUsa.scale = function(_14) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_14), alaska.scale(_14 * 0.35), hawaii.scale(_14);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_14) {
    if (!arguments.length) return lower48.translate();
    var k2 = lower48.scale(), x4 = +_14[0], y4 = +_14[1];
    lower48Point = lower48.translate(_14).clipExtent([[x4 - 0.455 * k2, y4 - 0.238 * k2], [x4 + 0.455 * k2, y4 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x4 - 0.307 * k2, y4 + 0.201 * k2]).clipExtent([[x4 - 0.425 * k2 + epsilon7, y4 + 0.12 * k2 + epsilon7], [x4 - 0.214 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x4 - 0.205 * k2, y4 + 0.212 * k2]).clipExtent([[x4 - 0.214 * k2 + epsilon7, y4 + 0.166 * k2 + epsilon7], [x4 - 0.115 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object3) {
    return fitExtent(albersUsa, extent2, object3);
  };
  albersUsa.fitSize = function(size, object3) {
    return fitSize(albersUsa, size, object3);
  };
  albersUsa.fitWidth = function(width, object3) {
    return fitWidth(albersUsa, width, object3);
  };
  albersUsa.fitHeight = function(height, object3) {
    return fitHeight(albersUsa, height, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale2) {
  return function(x4, y4) {
    var cx = cos2(x4), cy = cos2(y4), k2 = scale2(cx * cy);
    if (k2 === Infinity) return [2, 0];
    return [
      k2 * cy * sin2(x4),
      k2 * sin2(y4)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x4, y4) {
    var z = sqrt(x4 * x4 + y4 * y4), c6 = angle2(z), sc = sin2(c6), cc2 = cos2(c6);
    return [
      atan2(x4 * sc, z * cc2),
      asin(z && y4 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c6) {
  return (c6 = acos(c6)) && c6 / sin2(c6);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi3 + phi2) / 2))];
}
mercatorRaw.invert = function(x4, y4) {
  return [x4, 2 * atan(exp(y4)) - halfPi3];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau5);
}
function mercatorProjection(project) {
  var m3 = projection(project), center2 = m3.center, scale2 = m3.scale, translate = m3.translate, clipExtent = m3.clipExtent, x06 = null, y06, x12, y12;
  m3.scale = function(_14) {
    return arguments.length ? (scale2(_14), reclip()) : scale2();
  };
  m3.translate = function(_14) {
    return arguments.length ? (translate(_14), reclip()) : translate();
  };
  m3.center = function(_14) {
    return arguments.length ? (center2(_14), reclip()) : center2();
  };
  m3.clipExtent = function(_14) {
    return arguments.length ? (_14 == null ? x06 = y06 = x12 = y12 = null : (x06 = +_14[0][0], y06 = +_14[0][1], x12 = +_14[1][0], y12 = +_14[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  function reclip() {
    var k2 = pi4 * scale2(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));
    return clipExtent(x06 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x06), y06], [Math.min(t[0] + k2, x12), y12]] : [[x06, Math.max(t[1] - k2, y06)], [x12, Math.min(t[1] + k2, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y4) {
  return tan((halfPi3 + y4) / 2);
}
function conicConformalRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y06)), f = cy0 * pow2(tany(y06), n) / n;
  if (!n) return mercatorRaw;
  function project(x4, y4) {
    if (f > 0) {
      if (y4 < -halfPi3 + epsilon7) y4 = -halfPi3 + epsilon7;
    } else {
      if (y4 > halfPi3 - epsilon7) y4 = halfPi3 - epsilon7;
    }
    var r = f / pow2(tany(y4), n);
    return [r * sin2(n * x4), f - r * cos2(n * x4)];
  }
  project.invert = function(x4, y4) {
    var fy = f - y4, r = sign(n) * sqrt(x4 * x4 + fy * fy), l = atan2(x4, abs3(fy)) * sign(fy);
    if (fy * n < 0)
      l -= pi4 * sign(x4) * sign(fy);
    return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi3];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06), g = cy0 / n + y06;
  if (abs3(n) < epsilon7) return equirectangularRaw;
  function project(x4, y4) {
    var gy = g - y4, nx = n * x4;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project.invert = function(x4, y4) {
    var gy = g - y4, l = atan2(x4, abs3(gy)) * sign(gy);
    if (gy * n < 0)
      l -= pi4 * sign(x4) * sign(gy);
    return [l / n, g - sign(n) * sqrt(x4 * x4 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x4, y4) {
  var l = y4, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y4;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs3(delta) < epsilon22) break;
  }
  return [
    M * x4 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin(sin2(l) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x4, y4) {
  var cy = cos2(y4), k2 = cos2(x4) * cy;
  return [cy * sin2(x4) / k2, sin2(y4) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default4() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca3, sa, x06 = null, y06, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer({
    point: function(x4, y4) {
      var p = projection2([x4, y4]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity_default3, cache, cacheStream;
  function reset() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache = cacheStream = null;
    return projection2;
  }
  function projection2(p) {
    var x4 = p[0] * kx2, y4 = p[1] * ky2;
    if (alpha) {
      var t = y4 * ca3 - x4 * sa;
      x4 = x4 * ca3 + y4 * sa;
      y4 = t;
    }
    return [x4 + tx, y4 + ty];
  }
  projection2.invert = function(p) {
    var x4 = p[0] - tx, y4 = p[1] - ty;
    if (alpha) {
      var t = y4 * ca3 + x4 * sa;
      x4 = x4 * ca3 - y4 * sa;
      y4 = t;
    }
    return [x4 / kx2, y4 / ky2];
  };
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
  };
  projection2.postclip = function(_14) {
    return arguments.length ? (postclip = _14, x06 = y06 = x12 = y12 = null, reset()) : postclip;
  };
  projection2.clipExtent = function(_14) {
    return arguments.length ? (postclip = _14 == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_14[0][0], y06 = +_14[0][1], x12 = +_14[1][0], y12 = +_14[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection2.scale = function(_14) {
    return arguments.length ? (k2 = +_14, reset()) : k2;
  };
  projection2.translate = function(_14) {
    return arguments.length ? (tx = +_14[0], ty = +_14[1], reset()) : [tx, ty];
  };
  projection2.angle = function(_14) {
    return arguments.length ? (alpha = _14 % 360 * radians2, sa = sin2(alpha), ca3 = cos2(alpha), reset()) : alpha * degrees3;
  };
  projection2.reflectX = function(_14) {
    return arguments.length ? (sx = _14 ? -1 : 1, reset()) : sx < 0;
  };
  projection2.reflectY = function(_14) {
    return arguments.length ? (sy = _14 ? -1 : 1, reset()) : sy < 0;
  };
  projection2.fitExtent = function(extent2, object3) {
    return fitExtent(projection2, extent2, object3);
  };
  projection2.fitSize = function(size, object3) {
    return fitSize(projection2, size, object3);
  };
  projection2.fitWidth = function(width, object3) {
    return fitWidth(projection2, width, object3);
  };
  projection2.fitHeight = function(height, object3) {
    return fitHeight(projection2, height, object3);
  };
  return projection2;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x4, y4) {
  var phi2 = y4, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs3(delta) > epsilon7 && --i > 0);
  return [
    x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x4, y4) {
  return [cos2(y4) * sin2(x4), sin2(y4)];
}
orthographicRaw.invert = azimuthalInvert(asin);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon7);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x4, y4) {
  var cy = cos2(y4), k2 = 1 + cos2(x4) * cy;
  return [cy * sin2(x4) / k2, sin2(y4) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi3 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x4, y4) {
  return [-y4, 2 * atan(exp(x4)) - halfPi3];
};
function transverseMercator_default() {
  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate = m3.rotate;
  m3.center = function(_14) {
    return arguments.length ? center2([-_14[1], _14[0]]) : (_14 = center2(), [_14[1], -_14[0]]);
  };
  m3.rotate = function(_14) {
    return arguments.length ? rotate([_14[0], _14[1], _14.length > 2 ? _14[2] + 90 : 90]) : (_14 = rotate(), [_14[0], _14[1], _14[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a4, b) {
  return a4.parent === b.parent ? 1 : 2;
}
function meanX(children2) {
  return children2.reduce(meanXReduce, 0) / children2.length;
}
function meanXReduce(x4, c6) {
  return x4 + c6.x;
}
function maxY(children2) {
  return 1 + children2.reduce(maxYReduce, 0);
}
function maxYReduce(y4, c6) {
  return Math.max(y4, c6.y);
}
function leafLeft(node) {
  var children2;
  while (children2 = node.children) node = children2[0];
  return node;
}
function leafRight(node) {
  var children2;
  while (children2 = node.children) node = children2[children2.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root3) {
    var previousNode, x4 = 0;
    root3.eachAfter(function(node) {
      var children2 = node.children;
      if (children2) {
        node.x = meanX(children2);
        node.y = maxY(children2);
      } else {
        node.x = previousNode ? x4 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left3 = leafLeft(root3), right3 = leafRight(root3), x06 = left3.x - separation(left3, right3) / 2, x12 = right3.x + separation(right3, left3) / 2;
    return root3.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root3.x) * dx;
      node.y = (root3.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x06) / (x12 - x06) * dx;
      node.y = (1 - (root3.y ? node.y / root3.y : 1)) * dy;
    });
  }
  cluster.separation = function(x4) {
    return arguments.length ? (separation = x4, cluster) : separation;
  };
  cluster.size = function(x4) {
    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x4) {
    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count2(node) {
  var sum4 = 0, children2 = node.children, i = children2 && children2.length;
  if (!i) sum4 = 1;
  else while (--i >= 0) sum4 += children2[i].value;
  node.value = sum4;
}
function count_default() {
  return this.eachAfter(count2);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index4 = -1;
  for (const node of this) {
    callback.call(that, node, ++index4, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children2, i, index4 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index4, this);
    if (children2 = node.children) {
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children2, i, n, index4 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i = 0, n = children2.length; i < n; ++i) {
        nodes.push(children2[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index4, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index4 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index4, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value) {
  return this.eachAfter(function(node) {
    var sum4 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
    while (--i >= 0) sum4 += children2[i].value;
    node.value = sum4;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default2(compare2) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare2);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default2(end2) {
  var start3 = this, ancestor = leastCommonAncestor(start3, end2), nodes = [start3];
  while (start3 !== ancestor) {
    start3 = start3.parent;
    nodes.push(start3);
  }
  var k2 = nodes.length;
  while (end2 !== ancestor) {
    nodes.splice(k2, 0, end2);
    end2 = end2.parent;
  }
  return nodes;
}
function leastCommonAncestor(a4, b) {
  if (a4 === b) return a4;
  var aNodes = a4.ancestors(), bNodes = b.ancestors(), c6 = null;
  a4 = aNodes.pop();
  b = bNodes.pop();
  while (a4 === b) {
    c6 = a4;
    a4 = aNodes.pop();
    b = bNodes.pop();
  }
  return c6;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root3 = this, links = [];
  root3.each(function(node) {
    if (node !== root3) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default2() {
  var node = this, current, next = [node], children2, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          next.push(children2[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0) children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root3 = new Node2(data), node, nodes = [root3], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node2(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root3.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node2(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node2.prototype = hierarchy.prototype = {
  constructor: Node2,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default2,
  path: path_default2,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default2
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default9(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a2 = 1664525;
var c2 = 1013904223;
var m2 = 4294967296;
function lcg_default2() {
  let s2 = 1;
  return () => (s2 = (a2 * s2 + c2) % m2) / m2;
}

// node_modules/d3-hierarchy/src/array.js
function array_default2(x4) {
  return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
}
function shuffle(array5, random) {
  let m3 = array5.length, t, i;
  while (m3) {
    i = random() * m3-- | 0;
    t = array5[m3];
    array5[m3] = array5[i];
    array5[i] = t;
  }
  return array5;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function enclose_default(circles) {
  return packEncloseRandom(circles, lcg_default2());
}
function packEncloseRandom(circles, random) {
  var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B3 = [], p, e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B3 = extendBasis(B3, p)), i = 0;
  }
  return e;
}
function extendBasis(B3, p) {
  var i, j;
  if (enclosesWeakAll(p, B3)) return [p];
  for (i = 0; i < B3.length; ++i) {
    if (enclosesNot(p, B3[i]) && enclosesWeakAll(encloseBasis2(B3[i], p), B3)) {
      return [B3[i], p];
    }
  }
  for (i = 0; i < B3.length - 1; ++i) {
    for (j = i + 1; j < B3.length; ++j) {
      if (enclosesNot(encloseBasis2(B3[i], B3[j]), p) && enclosesNot(encloseBasis2(B3[i], p), B3[j]) && enclosesNot(encloseBasis2(B3[j], p), B3[i]) && enclosesWeakAll(encloseBasis3(B3[i], B3[j], p), B3)) {
        return [B3[i], B3[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a4, b) {
  var dr = a4.r - b.r, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a4, b) {
  var dr = a4.r - b.r + Math.max(a4.r, b.r, 1) * 1e-9, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a4, B3) {
  for (var i = 0; i < B3.length; ++i) {
    if (!enclosesWeak(a4, B3[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B3) {
  switch (B3.length) {
    case 1:
      return encloseBasis1(B3[0]);
    case 2:
      return encloseBasis2(B3[0], B3[1]);
    case 3:
      return encloseBasis3(B3[0], B3[1], B3[2]);
  }
}
function encloseBasis1(a4) {
  return {
    x: a4.x,
    y: a4.y,
    r: a4.r
  };
}
function encloseBasis2(a4, b) {
  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x22 + x21 / l * r21) / 2,
    y: (y12 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a4, b, c6) {
  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x32 = c6.x, y32 = c6.y, r3 = c6.r, a22 = x12 - x22, a32 = x12 - x32, b22 = y12 - y22, b32 = y12 - y32, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d32 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab4 = a32 * b22 - a22 * b32, xa = (b22 * d32 - b32 * d2) / (ab4 * 2) - x12, xb = (b32 * c22 - b22 * c32) / ab4, ya = (a32 * d2 - a22 * d32) / (ab4 * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab4, A5 = xb * xb + yb * yb - 1, B3 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B3 + Math.sqrt(B3 * B3 - 4 * A5 * C3)) / (2 * A5) : C3 / B3);
  return {
    x: x12 + xa + xb * r,
    y: y12 + ya + yb * r,
    r
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a4, c6) {
  var dx = b.x - a4.x, x4, a22, dy = b.y - a4.y, y4, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a4.r + c6.r, a22 *= a22;
    b22 = b.r + c6.r, b22 *= b22;
    if (a22 > b22) {
      x4 = (d2 + b22 - a22) / (2 * d2);
      y4 = Math.sqrt(Math.max(0, b22 / d2 - x4 * x4));
      c6.x = b.x - x4 * dx - y4 * dy;
      c6.y = b.y - x4 * dy + y4 * dx;
    } else {
      x4 = (d2 + a22 - b22) / (2 * d2);
      y4 = Math.sqrt(Math.max(0, a22 / d2 - x4 * x4));
      c6.x = a4.x + x4 * dx - y4 * dy;
      c6.y = a4.y + x4 * dy + y4 * dx;
    }
  } else {
    c6.x = a4.x + c6.r;
    c6.y = a4.y;
  }
}
function intersects(a4, b) {
  var dr = a4.r + b.r - 1e-6, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a4 = node._, b = node.next._, ab4 = a4.r + b.r, dx = (a4.x * b.r + b.x * a4.r) / ab4, dy = (a4.y * b.r + b.y * a4.r) / ab4;
  return dx * dx + dy * dy;
}
function Node3(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random) {
  if (!(n = (circles = array_default2(circles)).length)) return 0;
  var a4, b, c6, n, aa2, ca3, i, j, k2, sj, sk;
  a4 = circles[0], a4.x = 0, a4.y = 0;
  if (!(n > 1)) return a4.r;
  b = circles[1], a4.x = -b.r, b.x = a4.r, b.y = 0;
  if (!(n > 2)) return a4.r + b.r;
  place(b, a4, c6 = circles[2]);
  a4 = new Node3(a4), b = new Node3(b), c6 = new Node3(c6);
  a4.next = c6.previous = b;
  b.next = a4.previous = c6;
  c6.next = b.previous = a4;
  pack: for (i = 3; i < n; ++i) {
    place(a4._, b._, c6 = circles[i]), c6 = new Node3(c6);
    j = b.next, k2 = a4.previous, sj = b._.r, sk = a4._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c6._)) {
          b = j, a4.next = b, b.previous = a4, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k2._, c6._)) {
          a4 = k2, a4.next = b, b.previous = a4, --i;
          continue pack;
        }
        sk += k2._.r, k2 = k2.previous;
      }
    } while (j !== k2.next);
    c6.previous = a4, c6.next = b, a4.next = b.previous = b = c6;
    aa2 = score(a4);
    while ((c6 = c6.next) !== b) {
      if ((ca3 = score(c6)) < aa2) {
        a4 = c6, aa2 = ca3;
      }
    }
    b = a4.next;
  }
  a4 = [b._], c6 = b;
  while ((c6 = c6.next) !== b) a4.push(c6._);
  c6 = packEncloseRandom(a4, random);
  for (i = 0; i < n; ++i) a4 = circles[i], a4.x -= c6.x, a4.y -= c6.y;
  return c6.r;
}
function siblings_default(circles) {
  packSiblingsRandom(circles, lcg_default2());
  return circles;
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius2(d) {
  return Math.sqrt(d.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack(root3) {
    const random = lcg_default2();
    root3.x = dx / 2, root3.y = dy / 2;
    if (radius) {
      root3.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));
    } else {
      root3.eachBefore(radiusLeaf(defaultRadius2)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root3.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root3.r)));
    }
    return root3;
  }
  pack.radius = function(x4) {
    return arguments.length ? (radius = optional(x4), pack) : radius;
  };
  pack.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], pack) : [dx, dy];
  };
  pack.padding = function(x4) {
    return arguments.length ? (padding = typeof x4 === "function" ? x4 : constant_default9(+x4), pack) : padding;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildrenRandom(padding, k2, random) {
  return function(node) {
    if (children2 = node.children) {
      var children2, i, n = children2.length, r = padding(node) * k2 || 0, e;
      if (r) for (i = 0; i < n; ++i) children2[i].r += r;
      e = packSiblingsRandom(children2, random);
      if (r) for (i = 0; i < n; ++i) children2[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k2) {
  return function(node) {
    var parent = node.parent;
    node.r *= k2;
    if (parent) {
      node.x = parent.x + k2 * node.x;
      node.y = parent.y + k2 * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default2(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (x12 - x06) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y06, node.y1 = y12;
    node.x0 = x06, node.x1 = x06 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round = false;
  function partition(root3) {
    var n = root3.height + 1;
    root3.x0 = root3.y0 = padding;
    root3.x1 = dx;
    root3.y1 = dy / n;
    root3.eachBefore(positionNode(dy, n));
    if (round) root3.eachBefore(round_default2);
    return root3;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x06 = node.x0, y06 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;
      if (x12 < x06) x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06) y06 = y12 = (y06 + y12) / 2;
      node.x0 = x06;
      node.y0 = y06;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition.round = function(x4) {
    return arguments.length ? (round = !!x4, partition) : round;
  };
  partition.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], partition) : [dx, dy];
  };
  partition.padding = function(x4) {
    return arguments.length ? (padding = +x4, partition) : padding;
  };
  return partition;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id2 = defaultId, parentId = defaultParentId, path3;
  function stratify(data) {
    var nodes = Array.from(data), currentId4 = id2, currentParentId = parentId, n, d, i, root3, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path3 != null) {
      const I = nodes.map((d2, i2) => normalize(path3(d2, i2, data)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId4 = (_14, i2) => I[i2];
      currentParentId = (_14, i2) => P[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node2(d);
      if ((nodeId = currentId4(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root3) throw new Error("multiple roots");
        root3 = node;
      }
    }
    if (!root3) throw new Error("no root");
    if (path3 != null) {
      while (root3.data === imputed && root3.children.length === 1) {
        root3 = root3.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed) break;
        node.data = null;
      }
    }
    root3.parent = preroot;
    root3.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root3.parent = null;
    if (n > 0) throw new Error("cycle");
    return root3;
  }
  stratify.id = function(x4) {
    return arguments.length ? (id2 = optional(x4), stratify) : id2;
  };
  stratify.parentId = function(x4) {
    return arguments.length ? (parentId = optional(x4), stratify) : parentId;
  };
  stratify.path = function(x4) {
    return arguments.length ? (path3 = optional(x4), stratify) : path3;
  };
  return stratify;
}
function normalize(path3) {
  path3 = `${path3}`;
  let i = path3.length;
  if (slash(path3, i - 1) && !slash(path3, i - 2)) path3 = path3.slice(0, -1);
  return path3[0] === "/" ? path3 : `/${path3}`;
}
function parentof(path3) {
  let i = path3.length;
  if (i < 2) return "";
  while (--i > 1) if (slash(path3, i)) break;
  return path3.slice(0, i);
}
function slash(path3, i) {
  if (path3[i] === "/") {
    let k2 = 0;
    while (i > 0 && path3[--i] === "\\") ++k2;
    if ((k2 & 1) === 0) return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a4, b) {
  return a4.parent === b.parent ? 1 : 2;
}
function nextLeft(v2) {
  var children2 = v2.children;
  return children2 ? children2[0] : v2.t;
}
function nextRight(v2) {
  var children2 = v2.children;
  return children2 ? children2[children2.length - 1] : v2.t;
}
function moveSubtree(wm, wp, shift3) {
  var change = shift3 / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift3;
  wm.c += change;
  wp.z += shift3;
  wp.m += shift3;
}
function executeShifts(v2) {
  var shift3 = 0, change = 0, children2 = v2.children, i = children2.length, w;
  while (--i >= 0) {
    w = children2[i];
    w.z += shift3;
    w.m += shift3;
    shift3 += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v2, ancestor) {
  return vim.a.parent === v2.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node2.prototype);
function treeRoot(root3) {
  var tree = new TreeNode(root3, 0), node, nodes = [tree], child, children2, i, n;
  while (node = nodes.pop()) {
    if (children2 = node._.children) {
      node.children = new Array(n = children2.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root3) {
    var t = treeRoot(root3);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize) root3.eachBefore(sizeNode);
    else {
      var left3 = root3, right3 = root3, bottom3 = root3;
      root3.eachBefore(function(node) {
        if (node.x < left3.x) left3 = node;
        if (node.x > right3.x) right3 = node;
        if (node.depth > bottom3.depth) bottom3 = node;
      });
      var s2 = left3 === right3 ? 1 : separation(left3, right3) / 2, tx = s2 - left3.x, kx2 = dx / (right3.x + s2 + tx), ky2 = dy / (bottom3.depth || 1);
      root3.eachBefore(function(node) {
        node.x = (node.x + tx) * kx2;
        node.y = node.depth * ky2;
      });
    }
    return root3;
  }
  function firstWalk(v2) {
    var children2 = v2.children, siblings = v2.parent.children, w = v2.i ? siblings[v2.i - 1] : null;
    if (children2) {
      executeShifts(v2);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w) {
        v2.z = w.z + separation(v2._, w._);
        v2.m = v2.z - midpoint;
      } else {
        v2.z = midpoint;
      }
    } else if (w) {
      v2.z = w.z + separation(v2._, w._);
    }
    v2.parent.A = apportion(v2, w, v2.parent.A || siblings[0]);
  }
  function secondWalk(v2) {
    v2._.x = v2.z + v2.parent.m;
    v2.m += v2.parent.m;
  }
  function apportion(v2, w, ancestor) {
    if (w) {
      var vip = v2, vop = v2, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift3;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v2;
        shift3 = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift3 > 0) {
          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift3);
          sip += shift3;
          sop += shift3;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v2;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x4) {
    return arguments.length ? (separation = x4, tree) : separation;
  };
  tree.size = function(x4) {
    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x4) {
    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (y12 - y06) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x06, node.x1 = x12;
    node.y0 = y06, node.y1 = y06 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x06, y06, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x06, dy = y12 - y06;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice) dice_default(row, x06, y06, x12, value ? y06 += dy * sumValue / value : y12);
    else slice_default(row, x06, y06, value ? x06 += dx * sumValue / value : x12, y12);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom10(ratio) {
  function squarify(parent, x06, y06, x12, y12) {
    squarifyRatio(ratio, parent, x06, y06, x12, y12);
  }
  squarify.ratio = function(x4) {
    return custom10((x4 = +x4) > 1 ? x4 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root3) {
    root3.x0 = root3.y0 = 0;
    root3.x1 = dx;
    root3.y1 = dy;
    root3.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root3.eachBefore(round_default2);
    return root3;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x06 = node.x0 + p, y06 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;
    if (x12 < x06) x06 = x12 = (x06 + x12) / 2;
    if (y12 < y06) y06 = y12 = (y06 + y12) / 2;
    node.x0 = x06;
    node.y0 = y06;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x06 += paddingLeft(node) - p;
      y06 += paddingTop(node) - p;
      x12 -= paddingRight(node) - p;
      y12 -= paddingBottom(node) - p;
      if (x12 < x06) x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06) y06 = y12 = (y06 + y12) / 2;
      tile(node, x06, y06, x12, y12);
    }
  }
  treemap.round = function(x4) {
    return arguments.length ? (round = !!x4, treemap) : round;
  };
  treemap.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x4) {
    return arguments.length ? (tile = required(x4), treemap) : tile;
  };
  treemap.padding = function(x4) {
    return arguments.length ? treemap.paddingInner(x4).paddingOuter(x4) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x4) {
    return arguments.length ? (paddingInner = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x4) {
    return arguments.length ? treemap.paddingTop(x4).paddingRight(x4).paddingBottom(x4).paddingLeft(x4) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x4) {
    return arguments.length ? (paddingTop = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x4) {
    return arguments.length ? (paddingRight = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x4) {
    return arguments.length ? (paddingBottom = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x4) {
    return arguments.length ? (paddingLeft = typeof x4 === "function" ? x4 : constant_default9(+x4), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, i, n = nodes.length, sum4, sums = new Array(n + 1);
  for (sums[0] = sum4 = i = 0; i < n; ++i) {
    sums[i + 1] = sum4 += nodes[i].value;
  }
  partition(0, n, parent.value, x06, y06, x12, y12);
  function partition(i2, j, value, x07, y07, x13, y13) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x07, node.y0 = y07;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k2 = i2 + 1, hi = j - 1;
    while (k2 < hi) {
      var mid = k2 + hi >>> 1;
      if (sums[mid] < valueTarget) k2 = mid + 1;
      else hi = mid;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2) --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value - valueLeft;
    if (x13 - x07 > y13 - y07) {
      var xk = value ? (x07 * valueRight + x13 * valueLeft) / value : x13;
      partition(i2, k2, valueLeft, x07, y07, xk, y13);
      partition(k2, j, valueRight, xk, y07, x13, y13);
    } else {
      var yk = value ? (y07 * valueRight + y13 * valueLeft) / value : y13;
      partition(i2, k2, valueLeft, x07, y07, x13, yk);
      partition(k2, j, valueRight, x07, yk, x13, y13);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x06, y06, x12, y12) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x06, y06, x12, y12);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom11(ratio) {
  function resquarify(parent, x06, y06, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m3 = rows.length, value = parent.value;
      while (++j < m3) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) dice_default(row, x06, y06, x12, value ? y06 += (y12 - y06) * row.value / value : y12);
        else slice_default(row, x06, y06, value ? x06 += (x12 - x06) * row.value / value : x12, y12);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x06, y06, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x4) {
    return custom11((x4 = +x4) > 1 ? x4 : 1);
  };
  return resquarify;
}(phi);

// node_modules/d3-polygon/src/area.js
function area_default4(polygon) {
  var i = -1, n = polygon.length, a4, b = polygon[n - 1], area = 0;
  while (++i < n) {
    a4 = b;
    b = polygon[i];
    area += a4[1] * b[0] - a4[0] * b[1];
  }
  return area / 2;
}

// node_modules/d3-polygon/src/centroid.js
function centroid_default3(polygon) {
  var i = -1, n = polygon.length, x4 = 0, y4 = 0, a4, b = polygon[n - 1], c6, k2 = 0;
  while (++i < n) {
    a4 = b;
    b = polygon[i];
    k2 += c6 = a4[0] * b[1] - b[0] * a4[1];
    x4 += (a4[0] + b[0]) * c6;
    y4 += (a4[1] + b[1]) * c6;
  }
  return k2 *= 3, [x4 / k2, y4 / k2];
}

// node_modules/d3-polygon/src/cross.js
function cross_default(a4, b, c6) {
  return (b[0] - a4[0]) * (c6[1] - a4[1]) - (b[1] - a4[1]) * (c6[0] - a4[0]);
}

// node_modules/d3-polygon/src/hull.js
function lexicographicOrder(a4, b) {
  return a4[0] - b[0] || a4[1] - b[1];
}
function computeUpperHullIndexes(points) {
  const n = points.length, indexes2 = [0, 1];
  let size = 2, i;
  for (i = 2; i < n; ++i) {
    while (size > 1 && cross_default(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0) --size;
    indexes2[size++] = i;
  }
  return indexes2.slice(0, size);
}
function hull_default(points) {
  if ((n = points.length) < 3) return null;
  var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
  var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
  var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull = [];
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);
  return hull;
}

// node_modules/d3-polygon/src/contains.js
function contains_default3(polygon, point7) {
  var n = polygon.length, p = polygon[n - 1], x4 = point7[0], y4 = point7[1], x06 = p[0], y06 = p[1], x12, y12, inside = false;
  for (var i = 0; i < n; ++i) {
    p = polygon[i], x12 = p[0], y12 = p[1];
    if (y12 > y4 !== y06 > y4 && x4 < (x06 - x12) * (y4 - y12) / (y06 - y12) + x12) inside = !inside;
    x06 = x12, y06 = y12;
  }
  return inside;
}

// node_modules/d3-polygon/src/length.js
function length_default2(polygon) {
  var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.hypot(xa, ya);
  }
  return perimeter;
}

// node_modules/d3-random/src/defaultSource.js
var defaultSource_default = Math.random;

// node_modules/d3-random/src/uniform.js
var uniform_default = function sourceRandomUniform(source) {
  function randomUniform(min4, max5) {
    min4 = min4 == null ? 0 : +min4;
    max5 = max5 == null ? 1 : +max5;
    if (arguments.length === 1) max5 = min4, min4 = 0;
    else max5 -= min4;
    return function() {
      return source() * max5 + min4;
    };
  }
  randomUniform.source = sourceRandomUniform;
  return randomUniform;
}(defaultSource_default);

// node_modules/d3-random/src/int.js
var int_default = function sourceRandomInt(source) {
  function randomInt(min4, max5) {
    if (arguments.length < 2) max5 = min4, min4 = 0;
    min4 = Math.floor(min4);
    max5 = Math.floor(max5) - min4;
    return function() {
      return Math.floor(source() * max5 + min4);
    };
  }
  randomInt.source = sourceRandomInt;
  return randomInt;
}(defaultSource_default);

// node_modules/d3-random/src/normal.js
var normal_default = function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x4, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y4;
      if (x4 != null) y4 = x4, x4 = null;
      else do {
        x4 = source() * 2 - 1;
        y4 = source() * 2 - 1;
        r = x4 * x4 + y4 * y4;
      } while (!r || r > 1);
      return mu + sigma * y4 * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
  randomNormal.source = sourceRandomNormal;
  return randomNormal;
}(defaultSource_default);

// node_modules/d3-random/src/logNormal.js
var logNormal_default = function sourceRandomLogNormal(source) {
  var N = normal_default.source(source);
  function randomLogNormal() {
    var randomNormal = N.apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }
  randomLogNormal.source = sourceRandomLogNormal;
  return randomLogNormal;
}(defaultSource_default);

// node_modules/d3-random/src/irwinHall.js
var irwinHall_default = function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    if ((n = +n) <= 0) return () => 0;
    return function() {
      for (var sum4 = 0, i = n; i > 1; --i) sum4 += source();
      return sum4 + i * source();
    };
  }
  randomIrwinHall.source = sourceRandomIrwinHall;
  return randomIrwinHall;
}(defaultSource_default);

// node_modules/d3-random/src/bates.js
var bates_default = function sourceRandomBates(source) {
  var I = irwinHall_default.source(source);
  function randomBates(n) {
    if ((n = +n) === 0) return source;
    var randomIrwinHall = I(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }
  randomBates.source = sourceRandomBates;
  return randomBates;
}(defaultSource_default);

// node_modules/d3-random/src/exponential.js
var exponential_default = function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log1p(-source()) / lambda;
    };
  }
  randomExponential.source = sourceRandomExponential;
  return randomExponential;
}(defaultSource_default);

// node_modules/d3-random/src/pareto.js
var pareto_default = function sourceRandomPareto(source) {
  function randomPareto(alpha) {
    if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
    alpha = 1 / -alpha;
    return function() {
      return Math.pow(1 - source(), alpha);
    };
  }
  randomPareto.source = sourceRandomPareto;
  return randomPareto;
}(defaultSource_default);

// node_modules/d3-random/src/bernoulli.js
var bernoulli_default = function sourceRandomBernoulli(source) {
  function randomBernoulli(p) {
    if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
    return function() {
      return Math.floor(source() + p);
    };
  }
  randomBernoulli.source = sourceRandomBernoulli;
  return randomBernoulli;
}(defaultSource_default);

// node_modules/d3-random/src/geometric.js
var geometric_default = function sourceRandomGeometric(source) {
  function randomGeometric(p) {
    if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
    if (p === 0) return () => Infinity;
    if (p === 1) return () => 1;
    p = Math.log1p(-p);
    return function() {
      return 1 + Math.floor(Math.log1p(-source()) / p);
    };
  }
  randomGeometric.source = sourceRandomGeometric;
  return randomGeometric;
}(defaultSource_default);

// node_modules/d3-random/src/gamma.js
var gamma_default = function sourceRandomGamma(source) {
  var randomNormal = normal_default.source(source)();
  function randomGamma(k2, theta) {
    if ((k2 = +k2) < 0) throw new RangeError("invalid k");
    if (k2 === 0) return () => 0;
    theta = theta == null ? 1 : +theta;
    if (k2 === 1) return () => -Math.log1p(-source()) * theta;
    var d = (k2 < 1 ? k2 + 1 : k2) - 1 / 3, c6 = 1 / (3 * Math.sqrt(d)), multiplier = k2 < 1 ? () => Math.pow(source(), 1 / k2) : () => 1;
    return function() {
      do {
        do {
          var x4 = randomNormal(), v2 = 1 + c6 * x4;
        } while (v2 <= 0);
        v2 *= v2 * v2;
        var u4 = 1 - source();
      } while (u4 >= 1 - 0.0331 * x4 * x4 * x4 * x4 && Math.log(u4) >= 0.5 * x4 * x4 + d * (1 - v2 + Math.log(v2)));
      return d * v2 * multiplier() * theta;
    };
  }
  randomGamma.source = sourceRandomGamma;
  return randomGamma;
}(defaultSource_default);

// node_modules/d3-random/src/beta.js
var beta_default = function sourceRandomBeta(source) {
  var G = gamma_default.source(source);
  function randomBeta(alpha, beta) {
    var X3 = G(alpha), Y3 = G(beta);
    return function() {
      var x4 = X3();
      return x4 === 0 ? 0 : x4 / (x4 + Y3());
    };
  }
  randomBeta.source = sourceRandomBeta;
  return randomBeta;
}(defaultSource_default);

// node_modules/d3-random/src/binomial.js
var binomial_default = function sourceRandomBinomial(source) {
  var G = geometric_default.source(source), B3 = beta_default.source(source);
  function randomBinomial(n, p) {
    n = +n;
    if ((p = +p) >= 1) return () => n;
    if (p <= 0) return () => 0;
    return function() {
      var acc = 0, nn = n, pp = p;
      while (nn * pp > 16 && nn * (1 - pp) > 16) {
        var i = Math.floor((nn + 1) * pp), y4 = B3(i, nn - i + 1)();
        if (y4 <= pp) {
          acc += i;
          nn -= i;
          pp = (pp - y4) / (1 - y4);
        } else {
          nn = i - 1;
          pp /= y4;
        }
      }
      var sign3 = pp < 0.5, pFinal = sign3 ? pp : 1 - pp, g = G(pFinal);
      for (var s2 = g(), k2 = 0; s2 <= nn; ++k2) s2 += g();
      return acc + (sign3 ? k2 : nn - k2);
    };
  }
  randomBinomial.source = sourceRandomBinomial;
  return randomBinomial;
}(defaultSource_default);

// node_modules/d3-random/src/weibull.js
var weibull_default = function sourceRandomWeibull(source) {
  function randomWeibull(k2, a4, b) {
    var outerFunc;
    if ((k2 = +k2) === 0) {
      outerFunc = (x4) => -Math.log(x4);
    } else {
      k2 = 1 / k2;
      outerFunc = (x4) => Math.pow(x4, k2);
    }
    a4 = a4 == null ? 0 : +a4;
    b = b == null ? 1 : +b;
    return function() {
      return a4 + b * outerFunc(-Math.log1p(-source()));
    };
  }
  randomWeibull.source = sourceRandomWeibull;
  return randomWeibull;
}(defaultSource_default);

// node_modules/d3-random/src/cauchy.js
var cauchy_default = function sourceRandomCauchy(source) {
  function randomCauchy(a4, b) {
    a4 = a4 == null ? 0 : +a4;
    b = b == null ? 1 : +b;
    return function() {
      return a4 + b * Math.tan(Math.PI * source());
    };
  }
  randomCauchy.source = sourceRandomCauchy;
  return randomCauchy;
}(defaultSource_default);

// node_modules/d3-random/src/logistic.js
var logistic_default = function sourceRandomLogistic(source) {
  function randomLogistic(a4, b) {
    a4 = a4 == null ? 0 : +a4;
    b = b == null ? 1 : +b;
    return function() {
      var u4 = source();
      return a4 + b * Math.log(u4 / (1 - u4));
    };
  }
  randomLogistic.source = sourceRandomLogistic;
  return randomLogistic;
}(defaultSource_default);

// node_modules/d3-random/src/poisson.js
var poisson_default = function sourceRandomPoisson(source) {
  var G = gamma_default.source(source), B3 = binomial_default.source(source);
  function randomPoisson(lambda) {
    return function() {
      var acc = 0, l = lambda;
      while (l > 16) {
        var n = Math.floor(0.875 * l), t = G(n)();
        if (t > l) return acc + B3(n - 1, l / t)();
        acc += n;
        l -= t;
      }
      for (var s2 = -Math.log1p(-source()), k2 = 0; s2 <= l; ++k2) s2 -= Math.log1p(-source());
      return acc + k2;
    };
  }
  randomPoisson.source = sourceRandomPoisson;
  return randomPoisson;
}(defaultSource_default);

// node_modules/d3-random/src/lcg.js
var mul = 1664525;
var inc = 1013904223;
var eps = 1 / 4294967296;
function lcg(seed = Math.random()) {
  let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
  return () => (state = mul * state + inc | 0, eps * (state >>> 0));
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range4) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range4).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index4 = new InternMap(), domain = [], range4 = [], unknown = implicit;
  function scale2(d) {
    let i = index4.get(d);
    if (i === void 0) {
      if (unknown !== implicit) return unknown;
      index4.set(d, i = domain.push(d) - 1);
    }
    return range4[i % range4.length];
  }
  scale2.domain = function(_14) {
    if (!arguments.length) return domain.slice();
    domain = [], index4 = new InternMap();
    for (const value of _14) {
      if (index4.has(value)) continue;
      index4.set(value, domain.push(value) - 1);
    }
    return scale2;
  };
  scale2.range = function(_14) {
    return arguments.length ? (range4 = Array.from(_14), scale2) : range4.slice();
  };
  scale2.unknown = function(_14) {
    return arguments.length ? (unknown = _14, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range4).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale2.unknown;
  function rescale() {
    var n = domain().length, reverse3 = r1 < r0, start3 = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;
    step = (stop - start3) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start3 += (stop - start3 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start3 = Math.round(start3), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i) {
      return start3 + step * i;
    });
    return ordinalRange(reverse3 ? values.reverse() : values);
  }
  scale2.domain = function(_14) {
    return arguments.length ? (domain(_14), rescale()) : domain();
  };
  scale2.range = function(_14) {
    return arguments.length ? ([r0, r1] = _14, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale2.rangeRound = function(_14) {
    return [r0, r1] = _14, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale2.bandwidth = function() {
    return bandwidth;
  };
  scale2.step = function() {
    return step;
  };
  scale2.round = function(_14) {
    return arguments.length ? (round = !!_14, rescale()) : round;
  };
  scale2.padding = function(_14) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_14), rescale()) : paddingInner;
  };
  scale2.paddingInner = function(_14) {
    return arguments.length ? (paddingInner = Math.min(1, _14), rescale()) : paddingInner;
  };
  scale2.paddingOuter = function(_14) {
    return arguments.length ? (paddingOuter = +_14, rescale()) : paddingOuter;
  };
  scale2.align = function(_14) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _14)), rescale()) : align;
  };
  scale2.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale2) {
  var copy3 = scale2.copy;
  scale2.padding = scale2.paddingOuter;
  delete scale2.paddingInner;
  delete scale2.paddingOuter;
  scale2.copy = function() {
    return pointish(copy3());
  };
  return scale2;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-scale/src/constant.js
function constants(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-scale/src/number.js
function number3(x4) {
  return +x4;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x4) {
  return x4;
}
function normalize2(a4, b) {
  return (b -= a4 = +a4) ? function(x4) {
    return (x4 - a4) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a4, b) {
  var t;
  if (a4 > b) t = a4, a4 = b, b = t;
  return function(x4) {
    return Math.max(a4, Math.min(b, x4));
  };
}
function bimap(domain, range4, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range4[0], r1 = range4[1];
  if (d1 < d0) d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);
  return function(x4) {
    return r0(d0(x4));
  };
}
function polymap(domain, range4, interpolate) {
  var j = Math.min(domain.length, range4.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range4 = range4.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize2(domain[i], domain[i + 1]);
    r[i] = interpolate(range4[i], range4[i + 1]);
  }
  return function(x4) {
    var i2 = bisect_default(domain, x4, 1, j) - 1;
    return r[i2](d[i2](x4));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer2() {
  var domain = unit, range4 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range4.length);
    if (clamp !== identity3) clamp = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale2;
  }
  function scale2(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise2(domain.map(transform2), range4, interpolate)))(transform2(clamp(x4)));
  }
  scale2.invert = function(y4) {
    return clamp(untransform((input || (input = piecewise2(range4, domain.map(transform2), number_default)))(y4)));
  };
  scale2.domain = function(_14) {
    return arguments.length ? (domain = Array.from(_14, number3), rescale()) : domain.slice();
  };
  scale2.range = function(_14) {
    return arguments.length ? (range4 = Array.from(_14), rescale()) : range4.slice();
  };
  scale2.rangeRound = function(_14) {
    return range4 = Array.from(_14), interpolate = round_default, rescale();
  };
  scale2.clamp = function(_14) {
    return arguments.length ? (clamp = _14 ? true : identity3, rescale()) : clamp !== identity3;
  };
  scale2.interpolate = function(_14) {
    return arguments.length ? (interpolate = _14, rescale()) : interpolate;
  };
  scale2.unknown = function(_14) {
    return arguments.length ? (unknown = _14, scale2) : unknown;
  };
  return function(t, u4) {
    transform2 = t, untransform = u4;
    return rescale();
  };
}
function continuous() {
  return transformer2()(identity3, identity3);
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start3, stop, count3, specifier) {
  var step = tickStep(start3, stop, count3), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start3), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start3), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format2(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count3) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);
  };
  scale2.tickFormat = function(count3, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);
  };
  scale2.nice = function(count3) {
    if (count3 == null) count3 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start3 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start3) {
      step = start3, start3 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start3, stop, count3);
      if (step === prestep) {
        d[i0] = start3;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start3 = Math.floor(start3 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start3 = Math.ceil(start3 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear3() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy(scale2, linear3());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}

// node_modules/d3-scale/src/identity.js
function identity4(domain) {
  var unknown;
  function scale2(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : x4;
  }
  scale2.invert = scale2;
  scale2.domain = scale2.range = function(_14) {
    return arguments.length ? (domain = Array.from(_14, number3), scale2) : domain.slice();
  };
  scale2.unknown = function(_14) {
    return arguments.length ? (unknown = _14, scale2) : unknown;
  };
  scale2.copy = function() {
    return identity4(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number3) : [0, 1];
  return linearish(scale2);
}

// node_modules/d3-scale/src/nice.js
function nice2(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x12 = domain[i1], t;
  if (x12 < x06) {
    t = i0, i0 = i1, i1 = t;
    t = x06, x06 = x12, x12 = t;
  }
  domain[i0] = interval2.floor(x06);
  domain[i1] = interval2.ceil(x12);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x4) {
  return Math.log(x4);
}
function transformExp(x4) {
  return Math.exp(x4);
}
function transformLogn(x4) {
  return -Math.log(-x4);
}
function transformExpn(x4) {
  return -Math.exp(-x4);
}
function pow10(x4) {
  return isFinite(x4) ? +("1e" + x4) : x4 < 0 ? 0 : x4;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x4) => Math.pow(base, x4);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x4) => Math.log(x4) / base);
}
function reflect(f) {
  return (x4, k2) => -f(-x4, k2);
}
function loggish(transform2) {
  const scale2 = transform2(transformLog, transformExp);
  const domain = scale2.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale2;
  }
  scale2.base = function(_14) {
    return arguments.length ? (base = +_14, rescale()) : base;
  };
  scale2.domain = function(_14) {
    return arguments.length ? (domain(_14), rescale()) : domain();
  };
  scale2.ticks = (count3) => {
    const d = domain();
    let u4 = d[0];
    let v2 = d[d.length - 1];
    const r = v2 < u4;
    if (r) [u4, v2] = [v2, u4];
    let i = logs(u4);
    let j = logs(v2);
    let k2;
    let t;
    const n = count3 == null ? 10 : +count3;
    let z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u4 > 0) for (; i <= j; ++i) {
        for (k2 = 1; k2 < base; ++k2) {
          t = i < 0 ? k2 / pows(-i) : k2 * pows(i);
          if (t < u4) continue;
          if (t > v2) break;
          z.push(t);
        }
      }
      else for (; i <= j; ++i) {
        for (k2 = base - 1; k2 >= 1; --k2) {
          t = i > 0 ? k2 / pows(-i) : k2 * pows(i);
          if (t < u4) continue;
          if (t > v2) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u4, v2, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale2.tickFormat = (count3, specifier) => {
    if (count3 == null) count3 = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format2(specifier);
    }
    if (count3 === Infinity) return specifier;
    const k2 = Math.max(1, base * count3 / scale2.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k2 ? specifier(d) : "";
    };
  };
  scale2.nice = () => {
    return domain(nice2(domain(), {
      floor: (x4) => pows(Math.floor(logs(x4))),
      ceil: (x4) => pows(Math.ceil(logs(x4)))
    }));
  };
  return scale2;
}
function log2() {
  const scale2 = loggish(transformer2()).domain([1, 10]);
  scale2.copy = () => copy(scale2, log2()).base(scale2.base());
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c6) {
  return function(x4) {
    return Math.sign(x4) * Math.log1p(Math.abs(x4 / c6));
  };
}
function transformSymexp(c6) {
  return function(x4) {
    return Math.sign(x4) * Math.expm1(Math.abs(x4)) * c6;
  };
}
function symlogish(transform2) {
  var c6 = 1, scale2 = transform2(transformSymlog(c6), transformSymexp(c6));
  scale2.constant = function(_14) {
    return arguments.length ? transform2(transformSymlog(c6 = +_14), transformSymexp(c6)) : c6;
  };
  return linearish(scale2);
}
function symlog() {
  var scale2 = symlogish(transformer2());
  scale2.copy = function() {
    return copy(scale2, symlog()).constant(scale2.constant());
  };
  return initRange.apply(scale2, arguments);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent2) {
  return function(x4) {
    return x4 < 0 ? -Math.pow(-x4, exponent2) : Math.pow(x4, exponent2);
  };
}
function transformSqrt(x4) {
  return x4 < 0 ? -Math.sqrt(-x4) : Math.sqrt(x4);
}
function transformSquare(x4) {
  return x4 < 0 ? -x4 * x4 : x4 * x4;
}
function powish(transform2) {
  var scale2 = transform2(identity3, identity3), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform2(identity3, identity3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale2.exponent = function(_14) {
    return arguments.length ? (exponent2 = +_14, rescale()) : exponent2;
  };
  return linearish(scale2);
}
function pow3() {
  var scale2 = powish(transformer2());
  scale2.copy = function() {
    return copy(scale2, pow3()).exponent(scale2.exponent());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function sqrt2() {
  return pow3.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/radial.js
function square(x4) {
  return Math.sign(x4) * x4 * x4;
}
function unsquare(x4) {
  return Math.sign(x4) * Math.sqrt(Math.abs(x4));
}
function radial() {
  var squared = continuous(), range4 = [0, 1], round = false, unknown;
  function scale2(x4) {
    var y4 = unsquare(squared(x4));
    return isNaN(y4) ? unknown : round ? Math.round(y4) : y4;
  }
  scale2.invert = function(y4) {
    return squared.invert(square(y4));
  };
  scale2.domain = function(_14) {
    return arguments.length ? (squared.domain(_14), scale2) : squared.domain();
  };
  scale2.range = function(_14) {
    return arguments.length ? (squared.range((range4 = Array.from(_14, number3)).map(square)), scale2) : range4.slice();
  };
  scale2.rangeRound = function(_14) {
    return scale2.range(_14).round(true);
  };
  scale2.round = function(_14) {
    return arguments.length ? (round = !!_14, scale2) : round;
  };
  scale2.clamp = function(_14) {
    return arguments.length ? (squared.clamp(_14), scale2) : squared.clamp();
  };
  scale2.unknown = function(_14) {
    return arguments.length ? (unknown = _14, scale2) : unknown;
  };
  scale2.copy = function() {
    return radial(squared.domain(), range4).round(round).clamp(squared.clamp()).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range4 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range4.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
    return scale2;
  }
  function scale2(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : range4[bisect_default(thresholds, x4)];
  }
  scale2.invertExtent = function(y4) {
    var i = range4.indexOf(y4);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale2.domain = function(_14) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _14) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };
  scale2.range = function(_14) {
    return arguments.length ? (range4 = Array.from(_14), rescale()) : range4.slice();
  };
  scale2.unknown = function(_14) {
    return arguments.length ? (unknown = _14, scale2) : unknown;
  };
  scale2.quantiles = function() {
    return thresholds.slice();
  };
  scale2.copy = function() {
    return quantile2().domain(domain).range(range4).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x06 = 0, x12 = 1, n = 1, domain = [0.5], range4 = [0, 1], unknown;
  function scale2(x4) {
    return x4 != null && x4 <= x4 ? range4[bisect_default(domain, x4, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x12 - (i - n) * x06) / (n + 1);
    return scale2;
  }
  scale2.domain = function(_14) {
    return arguments.length ? ([x06, x12] = _14, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];
  };
  scale2.range = function(_14) {
    return arguments.length ? (n = (range4 = Array.from(_14)).length - 1, rescale()) : range4.slice();
  };
  scale2.invertExtent = function(y4) {
    var i = range4.indexOf(y4);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x06, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];
  };
  scale2.unknown = function(_14) {
    return arguments.length ? (unknown = _14, scale2) : scale2;
  };
  scale2.thresholds = function() {
    return domain.slice();
  };
  scale2.copy = function() {
    return quantize().domain([x06, x12]).range(range4).unknown(unknown);
  };
  return initRange.apply(linearish(scale2), arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range4 = [0, 1], unknown, n = 1;
  function scale2(x4) {
    return x4 != null && x4 <= x4 ? range4[bisect_default(domain, x4, 0, n)] : unknown;
  }
  scale2.domain = function(_14) {
    return arguments.length ? (domain = Array.from(_14), n = Math.min(domain.length, range4.length - 1), scale2) : domain.slice();
  };
  scale2.range = function(_14) {
    return arguments.length ? (range4 = Array.from(_14), n = Math.min(domain.length, range4.length - 1), scale2) : range4.slice();
  };
  scale2.invertExtent = function(y4) {
    var i = range4.indexOf(y4);
    return [domain[i - 1], domain[i]];
  };
  scale2.unknown = function(_14) {
    return arguments.length ? (unknown = _14, scale2) : unknown;
  };
  scale2.copy = function() {
    return threshold().domain(domain).range(range4).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count3, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = (date2) => {
    const d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = (start3, stop, step) => {
    const range4 = [];
    start3 = interval2.ceil(start3);
    step = step == null ? 1 : Math.floor(step);
    if (!(start3 < stop) || !(step > 0)) return range4;
    let previous;
    do
      range4.push(previous = /* @__PURE__ */ new Date(+start3)), offseti(start3, step), floori(start3);
    while (previous < start3 && start3 < stop);
    return range4;
  };
  interval2.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count3) {
    interval2.count = (start3, end2) => {
      t02.setTime(+start3), t12.setTime(+end2);
      floori(t02), floori(t12);
      return Math.floor(count3(t02, t12));
    };
    interval2.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? (d) => field(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
    };
  }
  return interval2;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start3, end2) => {
  return end2 - start3;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0)) return null;
  if (!(k2 > 1)) return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k2);
  }, (start3, end2) => {
    return (end2 - start3) / k2;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start3, end2) => {
  return (end2 - start3) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start3, end2) => {
  return (end2 - start3) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start3, end2) => {
  return (end2 - start3) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start3, end2) => {
  return (end2 - start3) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start3, end2) => {
  return (end2 - start3) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start3, end2) => (end2 - start3 - (end2.getTimezoneOffset() - start3.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start3, end2) => {
  return (end2 - start3) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start3, end2) => {
  return (end2 - start3) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start3, end2) => {
    return (end2 - start3 - (end2.getTimezoneOffset() - start3.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start3, end2) => {
    return (end2 - start3) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start3, end2) => {
  return end2.getMonth() - start3.getMonth() + (end2.getFullYear() - start3.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start3, end2) => {
  return end2.getUTCMonth() - start3.getUTCMonth() + (end2.getUTCFullYear() - start3.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start3, end2) => {
  return end2.getFullYear() - start3.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k2);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start3, end2) => {
  return end2.getUTCFullYear() - start3.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start3, stop, count3) {
    const reverse3 = stop < start3;
    if (reverse3) [start3, stop] = [stop, start3];
    const interval2 = count3 && typeof count3.range === "function" ? count3 : tickInterval(start3, stop, count3);
    const ticks3 = interval2 ? interval2.range(start3, +stop + 1) : [];
    return reverse3 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start3, stop, count3) {
    const target = Math.abs(stop - start3) / count3;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every(tickStep(start3 / durationYear, stop / durationYear, count3));
    if (i === 0) return millisecond.every(Math.max(tickStep(start3, stop, count3), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y4, m3, d) {
  return { y: y4, m: m3, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear2,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c6, pad3, format3;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad3 = pads[c6 = specifier.charAt(++i)]) != null) c6 = specifier.charAt(++i);
          else pad3 = c6 === "e" ? " " : "0";
          if (format3 = formats2[c6]) c6 = format3(date2, pad3);
          string.push(c6);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
      if (i != string.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m3 = string.length, c6, parse;
    while (i < n) {
      if (j >= m3) return -1;
      c6 = specifier.charCodeAt(i++);
      if (c6 === 37) {
        c6 = specifier.charAt(i++);
        parse = parses[c6 in pads ? specifier.charAt(i++) : c6];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c6 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad2(value, fill, width) {
  var sign3 = value < 0 ? "-" : "", string = (sign3 ? -value : value) + "", length3 = string.length;
  return sign3 + (length3 < width ? new Array(width - length3 + 1).join(fill) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad2(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad2(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad2(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad2(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad2(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad2(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad2(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad2(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear2(d, p) {
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad2(z / 60 | 0, "0", 2) + pad2(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad2(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad2(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad2(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad2(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad2(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad2(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad2(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad2(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
var isoFormat_default = formatIso;

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
var isoParse_default = parseIso;

// node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number4(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format3) {
  var scale2 = continuous(), invert = scale2.invert, domain = scale2.domain;
  var formatMillisecond = format3(".%L"), formatSecond = format3(":%S"), formatMinute = format3("%I:%M"), formatHour = format3("%I %p"), formatDay = format3("%a %d"), formatWeek = format3("%b %d"), formatMonth = format3("%B"), formatYear3 = format3("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  scale2.invert = function(y4) {
    return new Date(invert(y4));
  };
  scale2.domain = function(_14) {
    return arguments.length ? domain(Array.from(_14, number4)) : domain().map(date);
  };
  scale2.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale2.tickFormat = function(count3, specifier) {
    return specifier == null ? tickFormat2 : format3(specifier);
  };
  scale2.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function") interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice2(d, interval2)) : scale2;
  };
  scale2.copy = function() {
    return copy(scale2, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format3));
  };
  return scale2;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function transformer3() {
  var x06 = 0, x12 = 1, t03, t13, k10, transform2, interpolator = identity3, clamp = false, unknown;
  function scale2(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : interpolator(k10 === 0 ? 0.5 : (x4 = (transform2(x4) - t03) * k10, clamp ? Math.max(0, Math.min(1, x4)) : x4));
  }
  scale2.domain = function(_14) {
    return arguments.length ? ([x06, x12] = _14, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale2) : [x06, x12];
  };
  scale2.clamp = function(_14) {
    return arguments.length ? (clamp = !!_14, scale2) : clamp;
  };
  scale2.interpolator = function(_14) {
    return arguments.length ? (interpolator = _14, scale2) : interpolator;
  };
  function range4(interpolate) {
    return function(_14) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _14, interpolator = interpolate(r0, r1), scale2) : [interpolator(0), interpolator(1)];
    };
  }
  scale2.range = range4(value_default);
  scale2.rangeRound = range4(round_default);
  scale2.unknown = function(_14) {
    return arguments.length ? (unknown = _14, scale2) : unknown;
  };
  return function(t) {
    transform2 = t, t03 = t(x06), t13 = t(x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);
    return scale2;
  };
}
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale2 = linearish(transformer3()(identity3));
  scale2.copy = function() {
    return copy2(scale2, sequential());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialLog() {
  var scale2 = loggish(transformer3()).domain([1, 10]);
  scale2.copy = function() {
    return copy2(scale2, sequentialLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSymlog() {
  var scale2 = symlogish(transformer3());
  scale2.copy = function() {
    return copy2(scale2, sequentialSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialPow() {
  var scale2 = powish(transformer3());
  scale2.copy = function() {
    return copy2(scale2, sequentialPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/sequentialQuantile.js
function sequentialQuantile() {
  var domain = [], interpolator = identity3;
  function scale2(x4) {
    if (x4 != null && !isNaN(x4 = +x4)) return interpolator((bisect_default(domain, x4, 1) - 1) / (domain.length - 1));
  }
  scale2.domain = function(_14) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _14) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return scale2;
  };
  scale2.interpolator = function(_14) {
    return arguments.length ? (interpolator = _14, scale2) : interpolator;
  };
  scale2.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };
  scale2.quantiles = function(n) {
    return Array.from({ length: n + 1 }, (_14, i) => quantile(domain, i / n));
  };
  scale2.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale2, arguments);
}

// node_modules/d3-scale/src/diverging.js
function transformer4() {
  var x06 = 0, x12 = 0.5, x22 = 1, s2 = 1, t03, t13, t22, k10, k21, interpolator = identity3, transform2, clamp = false, unknown;
  function scale2(x4) {
    return isNaN(x4 = +x4) ? unknown : (x4 = 0.5 + ((x4 = +transform2(x4)) - t13) * (s2 * x4 < s2 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x4)) : x4));
  }
  scale2.domain = function(_14) {
    return arguments.length ? ([x06, x12, x22] = _14, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), t22 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale2) : [x06, x12, x22];
  };
  scale2.clamp = function(_14) {
    return arguments.length ? (clamp = !!_14, scale2) : clamp;
  };
  scale2.interpolator = function(_14) {
    return arguments.length ? (interpolator = _14, scale2) : interpolator;
  };
  function range4(interpolate) {
    return function(_14) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _14, interpolator = piecewise(interpolate, [r0, r1, r2]), scale2) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale2.range = range4(value_default);
  scale2.rangeRound = range4(round_default);
  scale2.unknown = function(_14) {
    return arguments.length ? (unknown = _14, scale2) : unknown;
  };
  return function(t) {
    transform2 = t, t03 = t(x06), t13 = t(x12), t22 = t(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;
    return scale2;
  };
}
function diverging() {
  var scale2 = linearish(transformer4()(identity3));
  scale2.copy = function() {
    return copy2(scale2, diverging());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingLog() {
  var scale2 = loggish(transformer4()).domain([0.1, 1, 10]);
  scale2.copy = function() {
    return copy2(scale2, divergingLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSymlog() {
  var scale2 = symlogish(transformer4());
  scale2.copy = function() {
    return copy2(scale2, divergingSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingPow() {
  var scale2 = powish(transformer4());
  scale2.copy = function() {
    return copy2(scale2, divergingPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c3 = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c3.h = 360 * t - 100;
  c3.s = 1.5 - 1.5 * ts;
  c3.l = 0.8 - 0.9 * ts;
  return c3 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c4 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t) {
  var x4;
  t = (0.5 - t) * Math.PI;
  c4.r = 255 * (x4 = Math.sin(t)) * x4;
  c4.g = 255 * (x4 = Math.sin(t + pi_1_3)) * x4;
  c4.b = 255 * (x4 = Math.sin(t + pi_2_3)) * x4;
  return c4 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range4) {
  var n = range4.length;
  return function(t) {
    return range4[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/d3-shape/src/constant.js
function constant_default10(x4) {
  return function constant2() {
    return x4;
  };
}

// node_modules/d3-shape/src/math.js
var abs4 = Math.abs;
var atan22 = Math.atan2;
var cos3 = Math.cos;
var max4 = Math.max;
var min3 = Math.min;
var sin3 = Math.sin;
var sqrt3 = Math.sqrt;
var epsilon8 = 1e-12;
var pi5 = Math.PI;
var halfPi4 = pi5 / 2;
var tau6 = 2 * pi5;
function acos2(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi5 : Math.acos(x4);
}
function asin2(x4) {
  return x4 >= 1 ? halfPi4 : x4 <= -1 ? -halfPi4 : Math.asin(x4);
}

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_14) {
    if (!arguments.length) return digits;
    if (_14 == null) {
      digits = null;
    } else {
      const d = Math.floor(_14);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_14}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x06, y06, x12, y12, x22, y22, x32, y32) {
  var x10 = x12 - x06, y10 = y12 - y06, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
  if (t * t < epsilon8) return;
  t = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t;
  return [x06 + t * x10, y06 + t * y10];
}
function cornerTangents(x06, y06, x12, y12, r1, rc, cw) {
  var x01 = x06 - x12, y01 = y06 - y12, lo = (cw ? rc : -rc) / sqrt3(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x06 + ox, y11 = y06 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D3 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt3(max4(0, r * r * d2 - D3 * D3)), cx0 = (D3 * dy - dx * d) / d2, cy0 = (-D3 * dx - dy * d) / d2, cx1 = (D3 * dy + dx * d) / d2, cy1 = (-D3 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default10(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path3 = withPath(arc);
  function arc() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi4, a1 = endAngle.apply(this, arguments) - halfPi4, da2 = abs4(a1 - a0), cw = a1 > a0;
    if (!context) context = buffer = path3();
    if (r1 < r0) r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon8)) context.moveTo(0, 0);
    else if (da2 > tau6 - epsilon8) {
      context.moveTo(r1 * cos3(a0), r1 * sin3(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon8) {
        context.moveTo(r0 * cos3(a1), r0 * sin3(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon8 && (padRadius ? +padRadius.apply(this, arguments) : sqrt3(r0 * r0 + r1 * r1)), rc = min3(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;
      if (rp > epsilon8) {
        var p02 = asin2(rp / r0 * sin3(ap)), p1 = asin2(rp / r1 * sin3(ap));
        if ((da0 -= p02 * 2) > epsilon8) p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon8) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos3(a01), y01 = r1 * sin3(a01), x10 = r0 * cos3(a10), y10 = r0 * sin3(a10);
      if (rc > epsilon8) {
        var x11 = r1 * cos3(a11), y11 = r1 * sin3(a11), x004 = r0 * cos3(a00), y004 = r0 * sin3(a00), oc;
        if (da2 < pi5) {
          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin3(acos2((ax * bx + ay * by) / (sqrt3(ax * ax + ay * ay) * sqrt3(bx * bx + by * by))) / 2), lc = sqrt3(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min3(rc, (r0 - lc) / (kc - 1));
            rc1 = min3(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon8)) context.moveTo(x01, y01);
      else if (rc1 > epsilon8) {
        t03 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw);
        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc1 < rc) context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r1, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), !cw);
          context.arc(t13.cx, t13.cy, rc1, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon8) || !(da0 > epsilon8)) context.lineTo(x10, y10);
      else if (rc0 > epsilon8) {
        t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw);
        context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc0 < rc) context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r0, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), cw);
          context.arc(t13.cx, t13.cy, rc0, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
        }
      } else context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi5 / 2;
    return [cos3(a4) * r, sin3(a4) * r];
  };
  arc.innerRadius = function(_14) {
    return arguments.length ? (innerRadius = typeof _14 === "function" ? _14 : constant_default10(+_14), arc) : innerRadius;
  };
  arc.outerRadius = function(_14) {
    return arguments.length ? (outerRadius = typeof _14 === "function" ? _14 : constant_default10(+_14), arc) : outerRadius;
  };
  arc.cornerRadius = function(_14) {
    return arguments.length ? (cornerRadius = typeof _14 === "function" ? _14 : constant_default10(+_14), arc) : cornerRadius;
  };
  arc.padRadius = function(_14) {
    return arguments.length ? (padRadius = _14 == null ? null : typeof _14 === "function" ? _14 : constant_default10(+_14), arc) : padRadius;
  };
  arc.startAngle = function(_14) {
    return arguments.length ? (startAngle = typeof _14 === "function" ? _14 : constant_default10(+_14), arc) : startAngle;
  };
  arc.endAngle = function(_14) {
    return arguments.length ? (endAngle = typeof _14 === "function" ? _14 : constant_default10(+_14), arc) : endAngle;
  };
  arc.padAngle = function(_14) {
    return arguments.length ? (padAngle = typeof _14 === "function" ? _14 : constant_default10(+_14), arc) : padAngle;
  };
  arc.context = function(_14) {
    return arguments.length ? (context = _14 == null ? null : _14, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice4 = Array.prototype.slice;
function array_default3(x4) {
  return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x4, y4);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x3(p) {
  return p[0];
}
function y3(p) {
  return p[1];
}

// node_modules/d3-shape/src/line.js
function line_default2(x4, y4) {
  var defined = constant_default10(true), context = null, curve2 = linear_default, output = null, path3 = withPath(line);
  x4 = typeof x4 === "function" ? x4 : x4 === void 0 ? x3 : constant_default10(x4);
  y4 = typeof y4 === "function" ? y4 : y4 === void 0 ? y3 : constant_default10(y4);
  function line(data) {
    var i, n = (data = array_default3(data)).length, d, defined0 = false, buffer;
    if (context == null) output = curve2(buffer = path3());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x4(d, i, data), +y4(d, i, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line.x = function(_14) {
    return arguments.length ? (x4 = typeof _14 === "function" ? _14 : constant_default10(+_14), line) : x4;
  };
  line.y = function(_14) {
    return arguments.length ? (y4 = typeof _14 === "function" ? _14 : constant_default10(+_14), line) : y4;
  };
  line.defined = function(_14) {
    return arguments.length ? (defined = typeof _14 === "function" ? _14 : constant_default10(!!_14), line) : defined;
  };
  line.curve = function(_14) {
    return arguments.length ? (curve2 = _14, context != null && (output = curve2(context)), line) : curve2;
  };
  line.context = function(_14) {
    return arguments.length ? (_14 == null ? context = output = null : output = curve2(context = _14), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/area.js
function area_default5(x06, y06, y12) {
  var x12 = null, defined = constant_default10(true), context = null, curve2 = linear_default, output = null, path3 = withPath(area);
  x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x3 : constant_default10(+x06);
  y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default10(0) : constant_default10(+y06);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y3 : constant_default10(+y12);
  function area(data) {
    var i, j, k2, n = (data = array_default3(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output = curve2(buffer = path3());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x06(d, i, data), y0z[i] = +y06(d, i, data);
        output.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default2().defined(defined).curve(curve2).context(context);
  }
  area.x = function(_14) {
    return arguments.length ? (x06 = typeof _14 === "function" ? _14 : constant_default10(+_14), x12 = null, area) : x06;
  };
  area.x0 = function(_14) {
    return arguments.length ? (x06 = typeof _14 === "function" ? _14 : constant_default10(+_14), area) : x06;
  };
  area.x1 = function(_14) {
    return arguments.length ? (x12 = _14 == null ? null : typeof _14 === "function" ? _14 : constant_default10(+_14), area) : x12;
  };
  area.y = function(_14) {
    return arguments.length ? (y06 = typeof _14 === "function" ? _14 : constant_default10(+_14), y12 = null, area) : y06;
  };
  area.y0 = function(_14) {
    return arguments.length ? (y06 = typeof _14 === "function" ? _14 : constant_default10(+_14), area) : y06;
  };
  area.y1 = function(_14) {
    return arguments.length ? (y12 = _14 == null ? null : typeof _14 === "function" ? _14 : constant_default10(+_14), area) : y12;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x06).y(y06);
  };
  area.lineY1 = function() {
    return arealine().x(x06).y(y12);
  };
  area.lineX1 = function() {
    return arealine().x(x12).y(y06);
  };
  area.defined = function(_14) {
    return arguments.length ? (defined = typeof _14 === "function" ? _14 : constant_default10(!!_14), area) : defined;
  };
  area.curve = function(_14) {
    return arguments.length ? (curve2 = _14, context != null && (output = curve2(context)), area) : curve2;
  };
  area.context = function(_14) {
    return arguments.length ? (_14 == null ? context = output = null : output = curve2(context = _14), area) : context;
  };
  return area;
}

// node_modules/d3-shape/src/descending.js
function descending_default(a4, b) {
  return b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;
}

// node_modules/d3-shape/src/identity.js
function identity_default5(d) {
  return d;
}

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value = identity_default5, sortValues = descending_default, sort3 = null, startAngle = constant_default10(0), endAngle = constant_default10(tau6), padAngle = constant_default10(0);
  function pie(data) {
    var i, n = (data = array_default3(data)).length, j, k2, sum4 = 0, index4 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau6, Math.max(-tau6, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)), pa = p * (da2 < 0 ? -1 : 1), v2;
    for (i = 0; i < n; ++i) {
      if ((v2 = arcs[index4[i] = i] = +value(data[i], i, data)) > 0) {
        sum4 += v2;
      }
    }
    if (sortValues != null) index4.sort(function(i2, j2) {
      return sortValues(arcs[i2], arcs[j2]);
    });
    else if (sort3 != null) index4.sort(function(i2, j2) {
      return sort3(data[i2], data[j2]);
    });
    for (i = 0, k2 = sum4 ? (da2 - n * pa) / sum4 : 0; i < n; ++i, a0 = a1) {
      j = index4[i], v2 = arcs[j], a1 = a0 + (v2 > 0 ? v2 * k2 : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v2,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie.value = function(_14) {
    return arguments.length ? (value = typeof _14 === "function" ? _14 : constant_default10(+_14), pie) : value;
  };
  pie.sortValues = function(_14) {
    return arguments.length ? (sortValues = _14, sort3 = null, pie) : sortValues;
  };
  pie.sort = function(_14) {
    return arguments.length ? (sort3 = _14, sortValues = null, pie) : sort3;
  };
  pie.startAngle = function(_14) {
    return arguments.length ? (startAngle = typeof _14 === "function" ? _14 : constant_default10(+_14), pie) : startAngle;
  };
  pie.endAngle = function(_14) {
    return arguments.length ? (endAngle = typeof _14 === "function" ? _14 : constant_default10(+_14), pie) : endAngle;
  };
  pie.padAngle = function(_14) {
    return arguments.length ? (padAngle = typeof _14 === "function" ? _14 : constant_default10(+_14), pie) : padAngle;
  };
  return pie;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve2) {
  this._curve = curve2;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a4, r) {
    this._curve.point(r * Math.sin(a4), r * -Math.cos(a4));
  }
};
function curveRadial(curve2) {
  function radial2(context) {
    return new Radial(curve2(context));
  }
  radial2._curve = curve2;
  return radial2;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
  var c6 = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_14) {
    return arguments.length ? c6(curveRadial(_14)) : c6()._curve;
  };
  return l;
}
function lineRadial_default() {
  return lineRadial(line_default2().curve(curveRadialLinear));
}

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a4 = area_default5().curve(curveRadialLinear), c6 = a4.curve, x06 = a4.lineX0, x12 = a4.lineX1, y06 = a4.lineY0, y12 = a4.lineY1;
  a4.angle = a4.x, delete a4.x;
  a4.startAngle = a4.x0, delete a4.x0;
  a4.endAngle = a4.x1, delete a4.x1;
  a4.radius = a4.y, delete a4.y;
  a4.innerRadius = a4.y0, delete a4.y0;
  a4.outerRadius = a4.y1, delete a4.y1;
  a4.lineStartAngle = function() {
    return lineRadial(x06());
  }, delete a4.lineX0;
  a4.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a4.lineX1;
  a4.lineInnerRadius = function() {
    return lineRadial(y06());
  }, delete a4.lineY0;
  a4.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a4.lineY1;
  a4.curve = function(_14) {
    return arguments.length ? c6(curveRadial(_14)) : c6()._curve;
  };
  return a4;
}

// node_modules/d3-shape/src/pointRadial.js
function pointRadial_default(x4, y4) {
  return [(y4 = +y4) * Math.cos(x4 -= Math.PI / 2), y4 * Math.sin(x4)];
}

// node_modules/d3-shape/src/curve/bump.js
var Bump = class {
  constructor(context, x4) {
    this._context = context;
    this._x = x4;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x4, y4);
        else this._context.moveTo(x4, y4);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x4) / 2, this._y0, this._x0, y4, x4, y4);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y4) / 2, x4, this._y0, x4, y4);
        break;
      }
    }
    this._x0 = x4, this._y0 = y4;
  }
};
var BumpRadial = class {
  constructor(context) {
    this._context = context;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
  }
  point(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point === 0) {
      this._point = 1;
    } else {
      const p02 = pointRadial_default(this._x0, this._y0);
      const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y4) / 2);
      const p2 = pointRadial_default(x4, this._y0);
      const p3 = pointRadial_default(x4, y4);
      this._context.moveTo(...p02);
      this._context.bezierCurveTo(...p1, ...p2, ...p3);
    }
    this._x0 = x4, this._y0 = y4;
  }
};
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}
function bumpRadial(context) {
  return new BumpRadial(context);
}

// node_modules/d3-shape/src/link.js
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link2(curve2) {
  let source = linkSource, target = linkTarget, x4 = x3, y4 = y3, context = null, output = null, path3 = withPath(link3);
  function link3() {
    let buffer;
    const argv = slice4.call(arguments);
    const s2 = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null) output = curve2(buffer = path3());
    output.lineStart();
    argv[0] = s2, output.point(+x4.apply(this, argv), +y4.apply(this, argv));
    argv[0] = t, output.point(+x4.apply(this, argv), +y4.apply(this, argv));
    output.lineEnd();
    if (buffer) return output = null, buffer + "" || null;
  }
  link3.source = function(_14) {
    return arguments.length ? (source = _14, link3) : source;
  };
  link3.target = function(_14) {
    return arguments.length ? (target = _14, link3) : target;
  };
  link3.x = function(_14) {
    return arguments.length ? (x4 = typeof _14 === "function" ? _14 : constant_default10(+_14), link3) : x4;
  };
  link3.y = function(_14) {
    return arguments.length ? (y4 = typeof _14 === "function" ? _14 : constant_default10(+_14), link3) : y4;
  };
  link3.context = function(_14) {
    return arguments.length ? (_14 == null ? context = output = null : output = curve2(context = _14), link3) : context;
  };
  return link3;
}
function linkHorizontal() {
  return link2(bumpX);
}
function linkVertical() {
  return link2(bumpY);
}
function linkRadial() {
  const l = link2(bumpRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt32 = sqrt3(3);
var asterisk_default = {
  draw(context, size) {
    const r = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;
    const t = r / 2;
    const u4 = t * sqrt32;
    context.moveTo(0, r);
    context.lineTo(0, -r);
    context.moveTo(-u4, -t);
    context.lineTo(u4, t);
    context.moveTo(-u4, t);
    context.lineTo(u4, -t);
  }
};

// node_modules/d3-shape/src/symbol/circle.js
var circle_default3 = {
  draw(context, size) {
    const r = sqrt3(size / pi5);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau6);
  }
};

// node_modules/d3-shape/src/symbol/cross.js
var cross_default2 = {
  draw(context, size) {
    const r = sqrt3(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt3(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = {
  draw(context, size) {
    const y4 = sqrt3(size / tan30_2);
    const x4 = y4 * tan30;
    context.moveTo(0, -y4);
    context.lineTo(x4, 0);
    context.lineTo(0, y4);
    context.lineTo(-x4, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond2.js
var diamond2_default = {
  draw(context, size) {
    const r = sqrt3(size) * 0.62625;
    context.moveTo(0, -r);
    context.lineTo(r, 0);
    context.lineTo(0, r);
    context.lineTo(-r, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/plus.js
var plus_default = {
  draw(context, size) {
    const r = sqrt3(size - min3(size / 7, 2)) * 0.87559;
    context.moveTo(-r, 0);
    context.lineTo(r, 0);
    context.moveTo(0, r);
    context.lineTo(0, -r);
  }
};

// node_modules/d3-shape/src/symbol/square.js
var square_default = {
  draw(context, size) {
    const w = sqrt3(size);
    const x4 = -w / 2;
    context.rect(x4, x4, w, w);
  }
};

// node_modules/d3-shape/src/symbol/square2.js
var square2_default = {
  draw(context, size) {
    const r = sqrt3(size) * 0.4431;
    context.moveTo(r, r);
    context.lineTo(r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, r);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/star.js
var ka = 0.8908130915292852;
var kr = sin3(pi5 / 10) / sin3(7 * pi5 / 10);
var kx = sin3(tau6 / 10) * kr;
var ky = -cos3(tau6 / 10) * kr;
var star_default = {
  draw(context, size) {
    const r = sqrt3(size * ka);
    const x4 = kx * r;
    const y4 = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x4, y4);
    for (let i = 1; i < 5; ++i) {
      const a4 = tau6 * i / 5;
      const c6 = cos3(a4);
      const s2 = sin3(a4);
      context.lineTo(s2 * r, -c6 * r);
      context.lineTo(c6 * x4 - s2 * y4, s2 * x4 + c6 * y4);
    }
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt33 = sqrt3(3);
var triangle_default = {
  draw(context, size) {
    const y4 = -sqrt3(size / (sqrt33 * 3));
    context.moveTo(0, y4 * 2);
    context.lineTo(-sqrt33 * y4, -y4);
    context.lineTo(sqrt33 * y4, -y4);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt34 = sqrt3(3);
var triangle2_default = {
  draw(context, size) {
    const s2 = sqrt3(size) * 0.6824;
    const t = s2 / 2;
    const u4 = s2 * sqrt34 / 2;
    context.moveTo(0, -s2);
    context.lineTo(u4, t);
    context.lineTo(-u4, t);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/wye.js
var c5 = -0.5;
var s = sqrt3(3) / 2;
var k = 1 / sqrt3(12);
var a3 = (k / 2 + 1) * 3;
var wye_default = {
  draw(context, size) {
    const r = sqrt3(size / a3);
    const x06 = r / 2, y06 = r * k;
    const x12 = x06, y12 = r * k + r;
    const x22 = -x12, y22 = y12;
    context.moveTo(x06, y06);
    context.lineTo(x12, y12);
    context.lineTo(x22, y22);
    context.lineTo(c5 * x06 - s * y06, s * x06 + c5 * y06);
    context.lineTo(c5 * x12 - s * y12, s * x12 + c5 * y12);
    context.lineTo(c5 * x22 - s * y22, s * x22 + c5 * y22);
    context.lineTo(c5 * x06 + s * y06, c5 * y06 - s * x06);
    context.lineTo(c5 * x12 + s * y12, c5 * y12 - s * x12);
    context.lineTo(c5 * x22 + s * y22, c5 * y22 - s * x22);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/times.js
var times_default = {
  draw(context, size) {
    const r = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r, -r);
    context.lineTo(r, r);
    context.moveTo(-r, r);
    context.lineTo(r, -r);
  }
};

// node_modules/d3-shape/src/symbol.js
var symbolsFill = [
  circle_default3,
  cross_default2,
  diamond_default,
  square_default,
  star_default,
  triangle_default,
  wye_default
];
var symbolsStroke = [
  circle_default3,
  plus_default,
  times_default,
  triangle2_default,
  asterisk_default,
  square2_default,
  diamond2_default
];
function Symbol2(type2, size) {
  let context = null, path3 = withPath(symbol);
  type2 = typeof type2 === "function" ? type2 : constant_default10(type2 || circle_default3);
  size = typeof size === "function" ? size : constant_default10(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer;
    if (!context) context = buffer = path3();
    type2.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }
  symbol.type = function(_14) {
    return arguments.length ? (type2 = typeof _14 === "function" ? _14 : constant_default10(_14), symbol) : type2;
  };
  symbol.size = function(_14) {
    return arguments.length ? (size = typeof _14 === "function" ? _14 : constant_default10(+_14), symbol) : size;
  };
  symbol.context = function(_14) {
    return arguments.length ? (context = _14 == null ? null : _14, symbol) : context;
  };
  return symbol;
}

// node_modules/d3-shape/src/noop.js
function noop_default2() {
}

// node_modules/d3-shape/src/curve/basis.js
function point2(that, x4, y4) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x4) / 6,
    (that._y0 + 4 * that._y1 + y4) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basis_default2(context) {
  return new Basis(context);
}

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x4, this._y2 = y4;
        break;
      case 1:
        this._point = 2;
        this._x3 = x4, this._y3 = y4;
        break;
      case 2:
        this._point = 3;
        this._x4 = x4, this._y4 = y4;
        this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
        break;
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basisClosed_default2(context) {
  return new BasisClosed(context);
}

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x06 = (this._x0 + 4 * this._x1 + x4) / 6, y06 = (this._y0 + 4 * this._y1 + y4) / 6;
        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basisOpen_default(context) {
  return new BasisOpen(context);
}

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, j = x4.length - 1;
    if (j > 0) {
      var x06 = x4[0], y06 = y4[0], dx = x4[j] - x06, dy = y4[j] - y06, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x4[i] + (1 - this._beta) * (x06 + t * dx),
          this._beta * y4[i] + (1 - this._beta) * (y06 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
var bundle_default = function custom12(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom12(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x4, y4) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x4),
    that._y2 + that._k * (that._y1 - y4),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        this._x1 = x4, this._y1 = y4;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinal_default = function custom13(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom13(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point3(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalClosed_default = function custom14(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom14(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalOpen_default = function custom15(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom15(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x4, y4) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon8) {
    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon8) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x4 * that._l12_2a) / m3;
    y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point4(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRom_default = function custom16(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom16(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point4(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomClosed_default = function custom17(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom17(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point4(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomOpen_default = function custom18(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom18(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) this._context.lineTo(x4, y4);
    else this._point = 1, this._context.moveTo(x4, y4);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign2(x4) {
  return x4 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point5(that, t03, t13) {
  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    var t13 = NaN;
    x4 = +x4, y4 = +y4;
    if (x4 === this._x1 && y4 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t13 = slope3(this, x4, y4)), t13);
        break;
      default:
        point5(this, this._t0, t13 = slope3(this, x4, y4));
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x4, y4) {
  MonotoneX.prototype.point.call(this, y4, x4);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x4, y4) {
    this._context.moveTo(y4, x4);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x4, y4) {
    this._context.lineTo(y4, x4);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x4, y4) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y4, x4);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, n = x4.length;
    if (n) {
      this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);
      if (n === 2) {
        this._context.lineTo(x4[1], y4[1]);
      } else {
        var px = controlPoints(x4), py = controlPoints(y4);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
function controlPoints(x4) {
  var i, n = x4.length - 1, m3, a4 = new Array(n), b = new Array(n), r = new Array(n);
  a4[0] = 0, b[0] = 2, r[0] = x4[0] + 2 * x4[1];
  for (i = 1; i < n - 1; ++i) a4[i] = 1, b[i] = 4, r[i] = 4 * x4[i] + 2 * x4[i + 1];
  a4[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x4[n - 1] + x4[n];
  for (i = 1; i < n; ++i) m3 = a4[i] / b[i - 1], b[i] -= m3, r[i] -= m3 * r[i - 1];
  a4[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a4[i] = (r[i] - a4[i + 1]) / b[i];
  b[n - 1] = (x4[n] + a4[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x4[i + 1] - a4[i + 1];
  return [a4, b];
}
function natural_default(context) {
  return new Natural(context);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y4);
          this._context.lineTo(x4, y4);
        } else {
          var x12 = this._x * (1 - this._t) + x4 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y4);
        }
        break;
      }
    }
    this._x = x4, this._y = y4;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order2) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order2[0]], n, m3 = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order2[i]];
    for (j = 0; j < m3; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

// node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack_default2() {
  var keys = constant_default10([]), order2 = none_default2, offset3 = none_default, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array_default3(order2(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset3(sz, oz);
    return sz;
  }
  stack.keys = function(_14) {
    return arguments.length ? (keys = typeof _14 === "function" ? _14 : constant_default10(Array.from(_14)), stack) : keys;
  };
  stack.value = function(_14) {
    return arguments.length ? (value = typeof _14 === "function" ? _14 : constant_default10(+_14), stack) : value;
  };
  stack.order = function(_14) {
    return arguments.length ? (order2 = _14 == null ? none_default2 : typeof _14 === "function" ? _14 : constant_default10(Array.from(_14)), stack) : order2;
  };
  stack.offset = function(_14) {
    return arguments.length ? (offset3 = _14 == null ? none_default : _14, stack) : offset3;
  };
  return stack;
}

// node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order2) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m3 = series[0].length, y4; j < m3; ++j) {
    for (y4 = i = 0; i < n; ++i) y4 += series[i][j][1] || 0;
    if (y4) for (i = 0; i < n; ++i) series[i][j][1] /= y4;
  }
  none_default(series, order2);
}

// node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series, order2) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m3 = series[order2[0]].length; j < m3; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order2[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

// node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order2) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order2[0]], n, m3 = s0.length; j < m3; ++j) {
    for (var i = 0, y4 = 0; i < n; ++i) y4 += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y4 / 2;
  }
  none_default(series, order2);
}

// node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order2) {
  if (!((n = series.length) > 0) || !((m3 = (s0 = series[order2[0]]).length) > 0)) return;
  for (var y4 = 0, j = 1, s0, m3, n; j < m3; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order2[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i; ++k2) {
        var sk = series[order2[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y4;
    if (s1) y4 -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y4;
  none_default(series, order2);
}

// node_modules/d3-shape/src/order/appearance.js
function appearance_default(series) {
  var peaks = series.map(peak);
  return none_default2(series).sort(function(a4, b) {
    return peaks[a4] - peaks[b];
  });
}
function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}

// node_modules/d3-shape/src/order/ascending.js
function ascending_default2(series) {
  var sums = series.map(sum3);
  return none_default2(series).sort(function(a4, b) {
    return sums[a4] - sums[b];
  });
}
function sum3(series) {
  var s2 = 0, i = -1, n = series.length, v2;
  while (++i < n) if (v2 = +series[i][1]) s2 += v2;
  return s2;
}

// node_modules/d3-shape/src/order/descending.js
function descending_default2(series) {
  return ascending_default2(series).reverse();
}

// node_modules/d3-shape/src/order/insideOut.js
function insideOut_default(series) {
  var n = series.length, i, j, sums = series.map(sum3), order2 = appearance_default(series), top3 = 0, bottom3 = 0, tops = [], bottoms = [];
  for (i = 0; i < n; ++i) {
    j = order2[i];
    if (top3 < bottom3) {
      top3 += sums[j];
      tops.push(j);
    } else {
      bottom3 += sums[j];
      bottoms.push(j);
    }
  }
  return bottoms.reverse().concat(tops);
}

// node_modules/d3-shape/src/order/reverse.js
function reverse_default(series) {
  return none_default2(series).reverse();
}

// node_modules/d3-zoom/src/constant.js
var constant_default11 = (x4) => () => x4;

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type2, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/d3-zoom/src/transform.js
function Transform(k2, x4, y4) {
  this.k = k2;
  this.x = x4;
  this.y = y4;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k2) {
    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
  },
  translate: function(x4, y4) {
    return x4 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x4, this.y + this.k * y4);
  },
  apply: function(point7) {
    return [point7[0] * this.k + this.x, point7[1] * this.k + this.y];
  },
  applyX: function(x4) {
    return x4 * this.k + this.x;
  },
  applyY: function(y4) {
    return y4 * this.k + this.y;
  },
  invert: function(location2) {
    return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
  },
  invertX: function(x4) {
    return (x4 - this.x) / this.k;
  },
  invertY: function(y4) {
    return (y4 - this.y) / this.k;
  },
  rescaleX: function(x4) {
    return x4.copy().domain(x4.range().map(this.invertX, this).map(x4.invert, x4));
  },
  rescaleY: function(y4) {
    return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity5 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity5;
  return node.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation3(event) {
  event.stopImmediatePropagation();
}
function noevent_default3(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter3(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent2() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity5;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable3() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent2, translateExtent) {
  var dx0 = transform2.invertX(extent2[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent2[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent2[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent2[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter3 = defaultFilter3, extent2 = defaultExtent2, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable3, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection, transform2, point7, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point7, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k2, p, event) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function(selection2, k2, p, event) {
    zoom.transform(selection2, function() {
      var e = extent2.apply(this, arguments), t03 = this.__zoom, p02 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t03.invert(p02), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return constrain(translate(scale2(t03, k1), p02, p1), e, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function(selection2, x4, y4, event) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x4 === "function" ? x4.apply(this, arguments) : x4,
        typeof y4 === "function" ? y4.apply(this, arguments) : y4
      ), extent2.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function(selection2, x4, y4, p, event) {
    zoom.transform(selection2, function() {
      var e = extent2.apply(this, arguments), t = this.__zoom, p02 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity5.translate(p02[0], p02[1]).scale(t.k).translate(
        typeof x4 === "function" ? -x4.apply(this, arguments) : -x4,
        typeof y4 === "function" ? -y4.apply(this, arguments) : -y4
      ), e, translateExtent);
    }, p, event);
  };
  function scale2(transform2, k2) {
    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
    return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
  }
  function translate(transform2, p02, p1) {
    var x4 = p02[0] - p1[0] * transform2.k, y4 = p02[1] - p1[1] * transform2.k;
    return x4 === transform2.x && y4 === transform2.y ? transform2 : new Transform(transform2.k, x4, y4);
  }
  function centroid(extent3) {
    return [(+extent3[0][0] + +extent3[1][0]) / 2, (+extent3[0][1] + +extent3[1][1]) / 2];
  }
  function schedule(transition2, transform2, point7, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent2.apply(that, args), p = point7 == null ? centroid(e) : typeof point7 === "function" ? point7.apply(that, args) : point7, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a4 = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a4.invert(p).concat(w / a4.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1) t = b;
        else {
          var l = i(t), k2 = w / l[2];
          t = new Transform(k2, p[0] - l[0] * k2, p[1] - l[1] * k2);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent2.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type2) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type2,
        this.that,
        new ZoomEvent(type2, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type: type2,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter3.apply(this, arguments)) return;
    var g = gesture(this, args).event(event), t = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k2) return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default3(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale2(t, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter3.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v2 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), x06 = event.clientX, y06 = event.clientY;
    nodrag_default(event.view);
    nopropagation3(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event2) {
      noevent_default3(event2);
      if (!g.moved) {
        var dx = event2.clientX - x06, dy = event2.clientY - y06;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v2.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent_default3(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter3.apply(this, arguments)) return;
    var t03 = this.__zoom, p02 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t03.invert(p02), k1 = t03.k * (event.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale2(t03, k1), p02, p1), extent2.apply(this, args), translateExtent);
    noevent_default3(event);
    if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t13, p02, event);
    else select_default2(this).call(zoom.transform, t13, p02, event);
  }
  function touchstarted(event, ...args) {
    if (!filter3.apply(this, arguments)) return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation3(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent_default3(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p02 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale2(t, Math.sqrt(dp / dl));
      p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation3(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function(_14) {
    return arguments.length ? (wheelDelta = typeof _14 === "function" ? _14 : constant_default11(+_14), zoom) : wheelDelta;
  };
  zoom.filter = function(_14) {
    return arguments.length ? (filter3 = typeof _14 === "function" ? _14 : constant_default11(!!_14), zoom) : filter3;
  };
  zoom.touchable = function(_14) {
    return arguments.length ? (touchable = typeof _14 === "function" ? _14 : constant_default11(!!_14), zoom) : touchable;
  };
  zoom.extent = function(_14) {
    return arguments.length ? (extent2 = typeof _14 === "function" ? _14 : constant_default11([[+_14[0][0], +_14[0][1]], [+_14[1][0], +_14[1][1]]]), zoom) : extent2;
  };
  zoom.scaleExtent = function(_14) {
    return arguments.length ? (scaleExtent[0] = +_14[0], scaleExtent[1] = +_14[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_14) {
    return arguments.length ? (translateExtent[0][0] = +_14[0][0], translateExtent[1][0] = +_14[1][0], translateExtent[0][1] = +_14[0][1], translateExtent[1][1] = +_14[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_14) {
    return arguments.length ? (constrain = _14, zoom) : constrain;
  };
  zoom.duration = function(_14) {
    return arguments.length ? (duration = +_14, zoom) : duration;
  };
  zoom.interpolate = function(_14) {
    return arguments.length ? (interpolate = _14, zoom) : interpolate;
  };
  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function(_14) {
    return arguments.length ? (clickDistance2 = (_14 = +_14) * _14, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function(_14) {
    return arguments.length ? (tapDistance = +_14, zoom) : tapDistance;
  };
  return zoom;
}

// node_modules/@patternfly/react-topology/dist/esm/behavior/useDndDrag.js
var React397 = __toESM(require_react());
var Modifiers = {
  DEFAULT: 0,
  ALT: 1,
  CTRL: 2,
  META: 4,
  SHIFT: 8
};
var getModifiers = (event) => {
  let modifiers2 = Modifiers.DEFAULT;
  if (event.altKey) {
    modifiers2 |= Modifiers.ALT;
  }
  if (event.ctrlKey) {
    modifiers2 |= Modifiers.CTRL;
  }
  if (event.metaKey) {
    modifiers2 |= Modifiers.META;
  }
  if (event.shiftKey) {
    modifiers2 |= Modifiers.SHIFT;
  }
  return modifiers2;
};
var getOperation = (operation, event) => {
  if (!operation) {
    return void 0;
  }
  if (operation.hasOwnProperty("type")) {
    return operation;
  }
  return operation[getModifiers(event)] || operation[Modifiers.DEFAULT];
};
var hasOperation = (operation) => !!(operation && (operation.hasOwnProperty("type") || Object.keys(operation).length > 0));
var EMPTY_PROPS = Object.freeze({});
var useDndDrag = (spec, props) => {
  const specRef = React397.useRef(spec);
  specRef.current = spec;
  const propsRef = React397.useRef(props != null ? props : EMPTY_PROPS);
  propsRef.current = props != null ? props : EMPTY_PROPS;
  const dndManager = useDndManager();
  const element = React397.useContext(ElementContext_default);
  const elementRef = React397.useRef(element);
  elementRef.current = element;
  const idRef = React397.useRef();
  const monitor = React397.useMemo(() => {
    const sourceMonitor = {
      getHandlerId: () => idRef.current,
      receiveHandlerId: (sourceId) => {
        idRef.current = sourceId;
      },
      getDropHints: () => dndManager.getDropHints(),
      canDrag: () => dndManager.canDragSource(idRef.current),
      isDragging: () => dndManager.isDraggingSource(idRef.current),
      getItemType: () => dndManager.getItemType(),
      getItem: () => dndManager.getItem(),
      getDropResult: () => dndManager.getDropResult(),
      didDrop: () => dndManager.didDrop(),
      getDragEvent: () => dndManager.getDragEvent(),
      getOperation: () => dndManager.getOperation(),
      isCancelled: () => dndManager.isCancelled()
    };
    return sourceMonitor;
  }, [dndManager]);
  const createKeyHandlerId = React397.useCallback((event = "") => `${event}.useDndDrag-${monitor.getHandlerId()}`, [monitor]);
  React397.useEffect(
    () => () => {
      if (canUseDOM) {
        select_default2(document).on(createKeyHandlerId(), null);
      }
      if (dndManager.isDragging() && dndManager.getSourceId() === monitor.getHandlerId()) {
        dndManager.endDrag();
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  const refCallback = useCallbackRef(React397.useCallback((node) => {
    let ownerDocument;
    if (node) {
      ownerDocument = node.ownerDocument;
      let operationChangeEvents;
      let operation;
      select_default2(node).call(drag_default().container(
        // TODO bridge the gap between scene tree and dom tree
        () => {
          const selected = node instanceof SVGElement ? select_default2(node.ownerSVGElement) : select_default2(ownerDocument);
          return selected.select('[data-surface="true"]').node();
        }
      ).on("start", function() {
        operation = typeof specRef.current.operation === "function" ? specRef.current.operation(monitor, propsRef.current) : specRef.current.operation;
        const updateOperation = action((event) => __awaiter(this, void 0, void 0, function* () {
          if (operation && idRef.current) {
            const op = getOperation(operation, event);
            if (dndManager.getOperation() !== op) {
              if (dndManager.isDragging()) {
                const event2 = Object.assign({}, dndManager.getDragEvent());
                const cancelled = dndManager.cancel();
                operationChangeEvents = {
                  begin: [
                    cancelled ? event2.initialX : event2.x,
                    cancelled ? event2.initialY : event2.y,
                    cancelled ? event2.initialPageX : event2.pageX,
                    cancelled ? event2.initialPageY : event2.pageY
                  ],
                  drag: [event2.x, event2.y, event2.pageX, event2.pageY]
                };
                yield dndManager.endDrag();
              }
              if (op && operationChangeEvents) {
                runInAction(() => {
                  dndManager.beginDrag(idRef.current, op, ...operationChangeEvents.begin);
                  dndManager.drag(...operationChangeEvents.drag);
                  operationChangeEvents = void 0;
                });
              }
            }
          }
        }));
        select_default2(ownerDocument).on(createKeyHandlerId("keydown"), action((event) => {
          if (event.key === "Escape") {
            if (dndManager.isDragging() && dndManager.cancel()) {
              operationChangeEvents = void 0;
              select_default2(event.view).on(".drag", null);
              select_default2(ownerDocument).on(createKeyHandlerId(), null);
              dndManager.endDrag();
            }
          } else {
            updateOperation(event);
          }
        })).on(createKeyHandlerId("keyup"), updateOperation);
      }).on("drag", action((event) => {
        const { pageX, pageY } = event.sourceEvent instanceof MouseEvent ? event.sourceEvent : { pageX: 0, pageY: 0 };
        const { x: x4, y: y4 } = event;
        if (dndManager.isDragging()) {
          dndManager.drag(x4, y4, pageX, pageY);
        } else if (operationChangeEvents) {
          operationChangeEvents.drag = [x4, y4, pageX, pageY];
        } else {
          const op = getOperation(operation, event.sourceEvent);
          if (op || !hasOperation(operation)) {
            if (idRef.current) {
              dndManager.beginDrag(idRef.current, op, x4, y4, pageX, pageY);
            }
          } else {
            operationChangeEvents = {
              begin: [x4, y4, pageX, pageY],
              drag: [x4, y4, pageX, pageY]
            };
          }
        }
      })).on("end", action(() => {
        operationChangeEvents = void 0;
        operation = void 0;
        select_default2(ownerDocument).on(createKeyHandlerId(), null);
        if (dndManager.isDragging()) {
          dndManager.drop();
          dndManager.endDrag();
        }
      })).filter((event) => !event.ctrlKey && !event.button && dndManager.canDragSource(idRef.current)));
    }
    return () => {
      if (node) {
        select_default2(node).on(".drag", null);
      }
    };
  }, [dndManager, monitor, createKeyHandlerId]));
  React397.useEffect(() => {
    const dragSource = {
      type: spec.item.type,
      canCancel: () => {
        if (typeof specRef.current.canCancel === "boolean") {
          return specRef.current.canCancel;
        }
        if (typeof specRef.current.canCancel === "function") {
          return specRef.current.canCancel(monitor, propsRef.current);
        }
        return true;
      },
      canDrag: () => {
        if (typeof specRef.current.canDrag === "boolean") {
          return specRef.current.canDrag;
        }
        if (typeof specRef.current.canDrag === "function") {
          return specRef.current.canDrag(monitor, propsRef.current);
        }
        return true;
      },
      beginDrag: () => specRef.current.begin ? specRef.current.begin(monitor, propsRef.current) : void 0,
      drag: () => {
        if (specRef.current.drag) {
          const event = monitor.getDragEvent();
          if (event) {
            specRef.current.drag(event, monitor, propsRef.current);
          }
        }
      },
      endDrag: () => specRef.current.end ? specRef.current.end(monitor.getDropResult(), monitor, propsRef.current) : void 0
    };
    const [sourceId, unregister] = dndManager.registerSource(dragSource);
    monitor.receiveHandlerId(sourceId);
    return unregister;
  }, [spec.item.type, dndManager, monitor]);
  const collected = React397.useMemo(() => computed(() => spec.collect ? spec.collect(monitor, propsRef.current) : {}, {
    equals: comparer.shallow
  }), [monitor, spec]);
  return [collected.get(), refCallback];
};
var withDndDrag = (spec) => (WrappedComponent) => {
  const Component50 = (props) => {
    const [dndDragProps, dndDragRef] = useDndDrag(spec, props);
    return React397.createElement(WrappedComponent, Object.assign({}, props, dndDragProps, { dndDragRef }));
  };
  Component50.displayName = `withDndDrag(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/useBendpoint.js
var useBendpoint = (point7, spec, props) => {
  const element = React398.useContext(ElementContext_default);
  if (!isEdge(element)) {
    throw new Error("useBendpoint must be used within the scope of an Edge");
  }
  const elementRef = React398.useRef(element);
  elementRef.current = element;
  const pointRef = React398.useRef(point7);
  pointRef.current = point7;
  const [connect, dragRef] = useDndDrag(React398.useMemo(() => {
    const sourceSpec = {
      item: { type: "#useBendpoint#" },
      begin: (monitor, p) => spec && spec.begin ? spec.begin(monitor, p) : void 0,
      drag: (event, monitor, p) => {
        pointRef.current.translate(event.dx, event.dy);
        elementRef.current.raise();
        spec && spec.drag && spec.drag(event, monitor, p);
      },
      canDrag: spec ? spec.canDrag : void 0,
      end: spec ? spec.end : void 0,
      collect: spec ? spec.collect : void 0
    };
    return sourceSpec;
  }, [spec]), props);
  const ref = React398.useCallback((node) => {
    select_default2(node).on("click", action((event) => {
      if (event.shiftKey) {
        event.stopPropagation();
        elementRef.current.removeBendpoint(pointRef.current);
      }
    }));
    dragRef(node);
  }, [dragRef]);
  return [connect, ref];
};
var withBendpoint = (spec) => (WrappedComponent) => {
  const Component50 = (props) => {
    const [dragProps, bendpointRef] = useBendpoint(props.point, spec, props);
    return React398.createElement(WrappedComponent, Object.assign({}, props, { bendpointRef }, dragProps));
  };
  Component50.displayName = `withBendpoint(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/useDndDrop.js
var React399 = __toESM(require_react());
var import_point_in_svg_path = __toESM(require_point_in_svg_path());
var EMPTY_PROPS2 = Object.freeze({});
var useDndDrop = (spec, props) => {
  const specRef = React399.useRef(spec);
  specRef.current = spec;
  const propsRef = React399.useRef(props != null ? props : EMPTY_PROPS2);
  propsRef.current = props != null ? props : EMPTY_PROPS2;
  const dndManager = useDndManager();
  const nodeRef = React399.useRef(null);
  const idRef = React399.useRef();
  const monitor = React399.useMemo(() => {
    const targetMonitor = {
      getHandlerId: () => idRef.current,
      receiveHandlerId: (sourceId) => {
        idRef.current = sourceId;
      },
      canDrop: () => dndManager.canDropOnTarget(idRef.current),
      isDragging: () => dndManager.isDragging(),
      hasDropTarget: () => dndManager.hasDropTarget(),
      getDropHints: () => dndManager.getDropHints(),
      isOver(options) {
        return dndManager.isOverTarget(idRef.current, options);
      },
      getItemType: () => dndManager.getItemType(),
      getItem: () => dndManager.getItem(),
      getDropResult: () => dndManager.getDropResult(),
      didDrop: () => dndManager.didDrop(),
      getDragEvent: () => dndManager.getDragEvent(),
      getOperation: () => dndManager.getOperation(),
      isCancelled: () => dndManager.isCancelled()
    };
    return targetMonitor;
  }, [dndManager]);
  const element = React399.useContext(ElementContext_default);
  const elementRef = React399.useRef(element);
  elementRef.current = element;
  React399.useEffect(() => {
    const dropTarget = {
      type: spec.accept,
      dropHint: () => {
        if (typeof specRef.current.dropHint === "string") {
          return specRef.current.dropHint;
        }
        if (typeof specRef.current.dropHint === "function") {
          return specRef.current.dropHint(monitor.getItem(), monitor, propsRef.current);
        }
        return elementRef.current.getType();
      },
      hitTest: (x4, y4) => {
        if (specRef.current.hitTest) {
          return specRef.current.hitTest(x4, y4, propsRef.current);
        }
        if (nodeRef.current) {
          if (!(nodeRef.current instanceof SVGGraphicsElement)) {
            return false;
          }
          const point7 = Point.singleUse(Math.round(x4), Math.round(y4));
          elementRef.current.translateFromAbsolute(point7);
          const { x: bboxx, y: bboxy, width, height } = nodeRef.current.getBBox();
          if (point7.x < bboxx || point7.x > bboxx + width || point7.y < bboxy || point7.y > bboxy + height) {
            return false;
          }
          if (nodeRef.current instanceof SVGPathElement) {
            const d = nodeRef.current.getAttribute("d");
            return (0, import_point_in_svg_path.pointInSvgPath)(d, point7.x, point7.y);
          }
          if (nodeRef.current instanceof SVGCircleElement) {
            const { cx, cy, r } = nodeRef.current;
            return Math.sqrt(Math.pow(point7.x - cx.animVal.value, 2) + Math.pow(point7.y - cy.animVal.value, 2)) < r.animVal.value;
          }
          if (nodeRef.current instanceof SVGEllipseElement) {
            const { cx, cy, rx, ry } = nodeRef.current;
            return Math.pow(point7.x - cx.animVal.value, 2) / Math.pow(rx.animVal.value, 2) + Math.pow(point7.y - cy.animVal.value, 2) / Math.pow(ry.animVal.value, 2) <= 1;
          }
          if (nodeRef.current instanceof SVGPolygonElement) {
            const arr = (nodeRef.current.getAttribute("points") || "").replace(/,/g, " ").split(" ").map((s2) => +s2);
            const points = [];
            for (let i = 0; i < arr.length; i += 2) {
              points.push(arr.slice(i, i + 2));
            }
            return contains_default3(points, [point7.x, point7.y]);
          }
          return true;
        }
        return false;
      },
      hover: () => {
        specRef.current.hover && specRef.current.hover(monitor.getItem(), monitor, propsRef.current);
      },
      canDrop: () => {
        if (typeof specRef.current.canDrop === "boolean") {
          return specRef.current.canDrop;
        }
        if (typeof specRef.current.canDrop === "function") {
          return specRef.current.canDrop(monitor.getItem(), monitor, propsRef.current);
        }
        return true;
      },
      drop: () => {
        if (specRef.current.drop) {
          return specRef.current.drop(monitor.getItem(), monitor, propsRef.current);
        }
        if (!monitor.didDrop()) {
          return elementRef.current;
        }
        return void 0;
      }
    };
    const [targetId, unregister] = dndManager.registerTarget(dropTarget);
    monitor.receiveHandlerId(targetId);
    return unregister;
  }, [spec.accept, dndManager, monitor]);
  const collected = React399.useMemo(() => computed(() => spec.collect ? spec.collect(monitor, propsRef.current) : {}, {
    equals: comparer.shallow
  }), [monitor, spec]);
  return [collected.get(), nodeRef];
};
var withDndDrop = (spec) => (WrappedComponent) => {
  const Component50 = (props) => {
    const [dndDropProps, dndDropRef] = useDndDrop(spec, props);
    return React399.createElement(WrappedComponent, Object.assign({}, props, dndDropProps, { dndDropRef }));
  };
  Component50.displayName = `withDndDrop(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/useDragNode.js
var React400 = __toESM(require_react());
var DRAG_NODE_EVENT = "drag_node";
var DRAG_NODE_START_EVENT = `${DRAG_NODE_EVENT}_start`;
var DRAG_NODE_END_EVENT = `${DRAG_NODE_EVENT}_end`;
var DRAG_MOVE_OPERATION = "move.useDragNode";
var defaultOperation = {
  [Modifiers.DEFAULT]: { type: DRAG_MOVE_OPERATION }
};
var useDragNode = (spec, props) => {
  const element = React400.useContext(ElementContext_default);
  if (!isNode(element)) {
    throw new Error("useDragNode must be used within the scope of a Node");
  }
  const elementRef = React400.useRef(element);
  elementRef.current = element;
  const dndManager = useDndManager();
  return useDndDrag(React400.useMemo(() => {
    const sourceSpec = {
      item: spec && spec.item || { type: "#useDragNode#" },
      operation: (monitor, p) => {
        if (spec) {
          const operation = typeof spec.operation === "function" ? spec.operation(monitor, p) : spec.operation;
          if (typeof operation === "object" && Object.keys(operation).length > 0) {
            return Object.assign(Object.assign({}, defaultOperation), operation);
          }
        }
        return defaultOperation;
      },
      begin: (monitor, p) => {
        elementRef.current.raise();
        if (elementRef.current.isGroup()) {
          elementRef.current.getChildren().forEach((c6) => {
            c6.raise();
          });
        }
        const result = spec && spec.begin && spec.begin(monitor, p);
        elementRef.current.getController().fireEvent(DRAG_NODE_START_EVENT, elementRef.current, monitor.getDragEvent(), monitor.getOperation());
        return result || elementRef.current;
      },
      drag: (event, monitor, p) => {
        const { dx, dy } = event;
        function moveElement(e) {
          let moved = true;
          if (e.isGroup()) {
            const nodeChildren = e.getChildren().filter(isNode);
            if (nodeChildren.length) {
              moved = false;
              nodeChildren.forEach(moveElement);
            }
          }
          if (moved) {
            e.setPosition(e.getPosition().clone().translate(dx, dy));
          }
        }
        moveElement(elementRef.current);
        spec && spec.drag && spec.drag(event, monitor, p);
        elementRef.current.getController().fireEvent(DRAG_NODE_EVENT, elementRef.current, event, monitor.getOperation());
      },
      canDrag: spec ? spec.canDrag : void 0,
      end: (dropResult, monitor, p) => __awaiter(void 0, void 0, void 0, function* () {
        let controller;
        try {
          controller = elementRef.current.getController();
        } catch (e) {
          return;
        }
        if (spec && spec.end) {
          try {
            yield spec.end(dropResult, monitor, p);
          } catch (_a2) {
            dndManager.cancel();
          }
        }
        action(() => {
          controller.fireEvent(DRAG_NODE_END_EVENT, elementRef.current, monitor.getDragEvent(), monitor.getOperation());
        })();
      }),
      collect: spec ? spec.collect : void 0,
      canCancel: spec ? spec.canCancel : true
    };
    return sourceSpec;
  }, [spec, dndManager]), props);
};
var withDragNode = (spec) => (WrappedComponent) => {
  const Component50 = (props) => {
    const [dragNodeProps, dragNodeRef] = useDragNode(spec, props);
    return React400.createElement(WrappedComponent, Object.assign({}, props, { dragNodeRef }, dragNodeProps));
  };
  Component50.displayName = `withDragNode(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/usePanZoom.js
var React401 = __toESM(require_react());
var propagatePanZoomMouseEvent = (e) => {
  document.dispatchEvent(new MouseEvent(e.type, e));
};
var usePanZoom = () => {
  const element = React401.useContext(ElementContext_default);
  if (!isGraph(element)) {
    throw new Error("usePanZoom must be used within the scope of a Graph");
  }
  const elementRef = React401.useRef(element);
  elementRef.current = element;
  return useCallbackRef((node) => {
    let disposeListener;
    if (node) {
      const $svg = select_default2(node.ownerSVGElement);
      if (node && node.ownerSVGElement) {
        node.ownerSVGElement.addEventListener("mousedown", propagatePanZoomMouseEvent);
        node.ownerSVGElement.addEventListener("click", propagatePanZoomMouseEvent);
      }
      const zoom = zoom_default2().scaleExtent(elementRef.current.getScaleExtent()).on("zoom", action((event) => {
        elementRef.current.setPosition(new Point(event.transform.x, event.transform.y));
        elementRef.current.setScale(event.transform.k);
      })).filter((event) => {
        if (event.ctrlKey || event.button) {
          return false;
        }
        if (event.type === "dblclick") {
          const svg2 = node.ownerSVGElement;
          let p = event.target;
          while (p && p !== svg2) {
            if (p instanceof Element) {
              const kind = p.getAttribute(ATTR_DATA_KIND);
              if (kind) {
                if (kind !== ModelKind.graph) {
                  return false;
                }
                break;
              }
            }
            p = p instanceof Node ? p.parentNode : void 0;
          }
        }
        return true;
      });
      zoom($svg);
      disposeListener = autorun(() => {
        const scale2 = elementRef.current.getScale();
        const scaleExtent = elementRef.current.getScaleExtent();
        zoom.scaleExtent([Math.min(scale2, scaleExtent[0]), scaleExtent[1]]);
        const b = elementRef.current.getBounds();
        Object.assign($svg.node().__zoom, {
          k: scale2,
          x: b.x,
          y: b.y
        });
      });
    }
    return () => {
      disposeListener && disposeListener();
      if (node) {
        select_default2(node.ownerSVGElement).on(".zoom", null);
        if (node.ownerSVGElement) {
          node.ownerSVGElement.removeEventListener("mousedown", propagatePanZoomMouseEvent);
          node.ownerSVGElement.removeEventListener("click", propagatePanZoomMouseEvent);
        }
      }
    };
  });
};
var withPanZoom = () => (WrappedComponent) => {
  const Component50 = (props) => {
    const panZoomRef = usePanZoom();
    return React401.createElement(WrappedComponent, Object.assign({}, props, { panZoomRef }));
  };
  Component50.displayName = `withPanZoom(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/useReconnect.js
var React402 = __toESM(require_react());
var withSourceDrag = (spec) => (WrappedComponent) => {
  const Component50 = (props) => {
    const [dndDragProps, dndDragRef] = useDndDrag(spec, props);
    return React402.createElement(WrappedComponent, Object.assign({}, props, { sourceDragRef: dndDragRef }, dndDragProps));
  };
  Component50.displayName = `withSourceDrag(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};
var withTargetDrag = (spec) => (WrappedComponent) => {
  const Component50 = (props) => {
    const [dndDragProps, dndDragRef] = useDndDrag(spec, props);
    return React402.createElement(WrappedComponent, Object.assign({}, props, { targetDragRef: dndDragRef }, dndDragProps));
  };
  Component50.displayName = `withTargetDrag(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/useSelection.js
var React403 = __toESM(require_react());
var SELECTION_EVENT = "selection";
var SELECTION_STATE = "selectedIds";
var useSelection = ({ multiSelect, controlled, raiseOnSelect = true } = {}) => {
  const element = React403.useContext(ElementContext_default);
  const elementRef = React403.useRef(element);
  elementRef.current = element;
  const selected = React403.useMemo(() => computed(() => {
    const { selectedIds } = element.getController().getState();
    return !!selectedIds && selectedIds.includes(element.getId());
  }), [element]);
  const onSelect = React403.useCallback((e) => {
    const actionFn = action((e3) => {
      e3.stopPropagation();
      const id2 = elementRef.current.getId();
      const state = elementRef.current.getController().getState();
      const idx = state.selectedIds ? state.selectedIds.indexOf(id2) : -1;
      let selectedIds;
      let raise2 = false;
      if (multiSelect && (e3.ctrlKey || e3.metaKey)) {
        if (!state.selectedIds) {
          raise2 = true;
          selectedIds = [id2];
        } else {
          selectedIds = [...state.selectedIds];
          if (idx === -1) {
            raise2 = true;
            selectedIds.push(id2);
          } else {
            selectedIds.splice(idx, 1);
          }
        }
      } else if (idx === -1 || multiSelect) {
        raise2 = true;
        selectedIds = [id2];
      } else {
        selectedIds = [];
      }
      if (!controlled) {
        state.selectedIds = selectedIds;
      }
      elementRef.current.getController().fireEvent(SELECTION_EVENT, selectedIds);
      if (raiseOnSelect && raise2) {
        elementRef.current.raise();
      }
    });
    actionFn(e);
  }, [multiSelect, controlled, raiseOnSelect]);
  return [selected.get(), onSelect];
};
var withSelection = (options) => (WrappedComponent) => {
  const Component50 = (props) => {
    const [selected, onSelect] = useSelection(options);
    return React403.createElement(WrappedComponent, Object.assign({}, props, { selected, onSelect }));
  };
  Component50.displayName = `withSelection(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/usePolygonAnchor.js
var React404 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/anchors/PolygonAnchor.js
var PolygonAnchor = class extends AbstractAnchor {
  constructor(owner, offset3 = 0) {
    super(owner, offset3);
    this.points = [];
    makeObservable(this, { points: observable.ref });
  }
  setPoints(points) {
    this.points = points === null || points === void 0 ? void 0 : points.map((p) => new Point(p[0], p[1]));
  }
  getLocation(reference2) {
    let bestPoint = new Point(0, 0);
    if (this.points) {
      const translatedRef = reference2.clone();
      this.owner.translateFromParent(translatedRef);
      let bestDistance = Infinity;
      const bbox = this.getBoundingBox();
      for (let i = 0; i < this.points.length; i++) {
        const intersectPoint = getLinesIntersection([this.points[i], this.points[i === this.points.length - 1 ? 0 : i + 1]], [bbox.getCenter(), translatedRef]);
        if (intersectPoint) {
          const intersectDistance = distanceToPoint(intersectPoint, translatedRef);
          if (intersectDistance < bestDistance) {
            bestPoint = intersectPoint;
            bestDistance = intersectDistance;
          }
        }
      }
    }
    this.owner.translateToParent(bestPoint);
    return bestPoint;
  }
  getBoundingBox() {
    var _a2;
    if ((_a2 = this.points) === null || _a2 === void 0 ? void 0 : _a2.length) {
      const bbox = new Rect(this.points[0].x, this.points[0].y);
      for (let i = 1; i < this.points.length; i++) {
        bbox.union(new Rect(this.points[i].x, this.points[i].y));
      }
      return bbox;
    }
    return new Rect(0, 0);
  }
  getReferencePoint() {
    var _a2;
    if ((_a2 = this.points) === null || _a2 === void 0 ? void 0 : _a2.length) {
      const bbox = this.getBoundingBox();
      const ref = bbox.getCenter();
      this.owner.translateToParent(ref);
      this.owner.getBounds();
      return ref;
    }
    return super.getReferencePoint();
  }
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/usePolygonAnchor.js
var usePolygonAnchor = (points, end2 = AnchorEnd.both, type2 = "") => {
  const element = React404.useContext(ElementContext_default);
  if (!isNode(element)) {
    throw new Error("usePolygonAnchor must be used within the scope of a Node");
  }
  React404.useEffect(() => {
    runInAction(() => {
      if (points) {
        const anchor = new PolygonAnchor(element);
        anchor.setPoints(points);
        element.setAnchor(anchor, end2, type2);
      }
    });
  }, [points, end2, type2, element]);
};
var withPolygonAnchor = (getPoints, end2, type2) => (WrappedComponent) => {
  const element = React404.useContext(ElementContext_default);
  const Component50 = (props) => {
    usePolygonAnchor(getPoints(element), end2, type2);
    return React404.createElement(WrappedComponent, Object.assign({}, props));
  };
  Component50.displayName = `withPolygonAnchor(${WrappedComponent.displayName || WrappedComponent.name})`;
  return Component50;
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/useSvgAnchor.js
var React405 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/anchors/SVGAnchor.js
var SVGAnchor = class extends AbstractAnchor {
  constructor(owner, offset3 = 0) {
    super(owner, offset3);
    this.svgElement = void 0;
    makeObservable(this, { svgElement: observable.ref });
  }
  setSVGElement(svgElement) {
    this.svgElement = svgElement;
  }
  getCircleLocation(circle, reference2) {
    const center2 = new Point(circle.cx.baseVal.value, circle.cy.baseVal.value);
    this.owner.translateToParent(center2);
    const diameter = circle.r.baseVal.value * 2 + this.offset * 2;
    return getEllipseAnchorPoint(center2, diameter, diameter, reference2);
  }
  getEllipseLocation(ellipse, reference2) {
    const center2 = new Point(ellipse.cx.baseVal.value, ellipse.cy.baseVal.value);
    this.owner.translateToParent(center2);
    const offset2x = this.offset * 2;
    const width = ellipse.rx.baseVal.value * 2 + offset2x;
    const height = ellipse.ry.baseVal.value * 2 + offset2x;
    return getEllipseAnchorPoint(center2, width, height, reference2);
  }
  getRectLocation(rect, reference2) {
    const width = rect.width.baseVal.value;
    const height = rect.height.baseVal.value;
    const center2 = new Point(rect.x.baseVal.value + width / 2, rect.y.baseVal.value + height / 2);
    this.owner.translateToParent(center2);
    const offset2x = this.offset * 2;
    return getRectAnchorPoint(center2, width + offset2x, height + offset2x, reference2);
  }
  getPathLocation(path3, reference2) {
    const translatedRef = reference2.clone();
    this.owner.translateFromParent(translatedRef);
    const anchorPoint = getPathAnchorPoint(path3, translatedRef);
    this.owner.translateToParent(anchorPoint);
    return anchorPoint;
  }
  getPolygonLocation(polygon, reference2) {
    const translatedRef = reference2.clone();
    this.owner.translateFromParent(translatedRef);
    const anchorPoint = getPolygonAnchorPoint(polygon, translatedRef);
    this.owner.translateToParent(anchorPoint);
    return anchorPoint;
  }
  getLocation(reference2) {
    if (this.svgElement && this.svgElement.viewportElement) {
      if (this.svgElement instanceof SVGCircleElement) {
        return this.getCircleLocation(this.svgElement, reference2);
      }
      if (this.svgElement instanceof SVGEllipseElement) {
        return this.getEllipseLocation(this.svgElement, reference2);
      }
      if (this.svgElement instanceof SVGRectElement) {
        return this.getRectLocation(this.svgElement, reference2);
      }
      if (this.svgElement instanceof SVGPathElement) {
        return this.getPathLocation(this.svgElement, reference2);
      }
      if (this.svgElement instanceof SVGPolygonElement) {
        return this.getPolygonLocation(this.svgElement, reference2);
      }
    }
    return this.owner.getBounds().getCenter();
  }
  getReferencePoint() {
    if (this.svgElement && this.svgElement.viewportElement && (this.svgElement instanceof SVGCircleElement || this.svgElement instanceof SVGEllipseElement || this.svgElement instanceof SVGRectElement || this.svgElement instanceof SVGPathElement || this.svgElement instanceof SVGPolygonElement)) {
      const bbox = this.svgElement.getBBox();
      const ref = new Point(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);
      this.owner.translateToParent(ref);
      this.owner.getBounds();
      return ref;
    }
    return super.getReferencePoint();
  }
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/useSvgAnchor.js
var useSvgAnchor = (end2 = AnchorEnd.both, type2 = "") => {
  const element = React405.useContext(ElementContext_default);
  if (!isNode(element)) {
    throw new Error("useSvgAnchor must be used within the scope of a Node");
  }
  return React405.useCallback((node) => {
    const actionFn = action((node2) => {
      if (node2) {
        const anchor = new SVGAnchor(element);
        anchor.setSVGElement(node2);
        element.setAnchor(anchor, end2, type2);
      }
    });
    actionFn(node);
  }, [element, type2, end2]);
};
var withSvgAnchor = (end2, type2) => () => (WrappedComponent) => {
  const Component50 = (props) => {
    const svgAnchorRef = useSvgAnchor(end2, type2);
    return React405.createElement(WrappedComponent, Object.assign({}, props, { svgAnchorRef }));
  };
  Component50.displayName = `withSvgAnchor(${WrappedComponent.displayName || WrappedComponent.name})`;
  return Component50;
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/withContextMenu.js
var React406 = __toESM(require_react());
var withContextMenu = (actions, container, className, atPoint = true, waitElement = React406.createElement(Spinner, { className: "pf-v6-u-mx-md", size: "md" })) => (WrappedComponent) => {
  const Component50 = (props) => {
    const element = React406.useContext(ElementContext_default);
    const [reference2, setReference] = React406.useState(null);
    const [elementActions, setElementActions] = React406.useState(null);
    const onContextMenu = React406.useCallback((e) => {
      e.preventDefault();
      e.stopPropagation();
      setReference(atPoint ? {
        x: e.pageX,
        y: e.pageY
      } : e.currentTarget);
    }, []);
    React406.useEffect(() => {
      if (reference2) {
        const actionsElements = actions(element);
        Promise.resolve(actionsElements).then((resultActions) => {
          setElementActions(resultActions);
        });
      } else {
        setElementActions(null);
      }
    }, [element, reference2]);
    return React406.createElement(
      React406.Fragment,
      null,
      React406.createElement(WrappedComponent, Object.assign({}, props, { onContextMenu, contextMenuOpen: !!reference2 })),
      reference2 ? React406.createElement(ContextMenu_default, { reference: reference2, container, className, open: true, onRequestClose: () => setReference(null) }, elementActions || waitElement) : null
    );
  };
  Component50.displayName = `withContextMenu(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/withCreateConnector.js
var React407 = __toESM(require_react());
var import_topology_components12 = __toESM(require_topology_components());
var CREATE_CONNECTOR_OPERATION = "#createconnector#";
var CREATE_CONNECTOR_DROP_TYPE = "#createConnector#";
var isReactElementArray = (choices) => React407.isValidElement(choices[0]);
var DEFAULT_HANDLE_ANGLE = Math.PI / 180;
var DEFAULT_HANDLE_ANGLE_TOP = 1.5 * Math.PI;
var DEFAULT_HANDLE_LENGTH = 32;
var CreateConnectorWidget = observer2((props) => {
  const { element, onKeepAlive, onCreate: onCreate2, ConnectorComponent, handleAngle = DEFAULT_HANDLE_ANGLE, handleAngleTop = DEFAULT_HANDLE_ANGLE_TOP, handleLength = DEFAULT_HANDLE_LENGTH, contextMenuClass, dragItem, dragOperation, hideConnectorMenu } = props;
  const [prompt, setPrompt] = React407.useState(null);
  const [active, setActive] = React407.useState(false);
  const hintsRef = React407.useRef();
  const spec = React407.useMemo(() => {
    const dragSourceSpec = {
      item: dragItem || { type: CREATE_CONNECTOR_DROP_TYPE },
      operation: dragOperation || { type: CREATE_CONNECTOR_OPERATION },
      begin: (monitor, dragProps) => {
        setActive(true);
        return dragProps.element;
      },
      drag: (event2, monitor, p) => {
        p.element.raise();
      },
      end: (dropResult, monitor, dragProps) => __awaiter(void 0, void 0, void 0, function* () {
        const event2 = monitor.getDragEvent();
        if ((isNode(dropResult) || isGraph(dropResult)) && event2) {
          const choices = yield dragProps.onCreate(dragProps.element, dropResult, event2, monitor.getDropHints());
          if (choices && choices.length && !hideConnectorMenu) {
            setPrompt({ element: dragProps.element, target: dropResult, event: event2, choices });
            return;
          }
        }
        setActive(false);
        dragProps.onKeepAlive(false);
      }),
      collect: (monitor) => ({
        dragging: !!monitor.getItem(),
        event: monitor.isDragging() ? monitor.getDragEvent() : void 0,
        hints: monitor.getDropHints()
      })
    };
    return dragSourceSpec;
  }, [setActive, dragItem, dragOperation, hideConnectorMenu]);
  const [{ dragging, event, hints }, dragRef] = useDndDrag(spec, props);
  const [hover, hoverRef] = useHover_default();
  const refs = useCombineRefs_default(dragRef, hoverRef);
  if (!active && dragging && !event) {
    return null;
  }
  if (dragging) {
    hintsRef.current = hints;
  }
  const dragEvent = prompt ? prompt.event : event;
  let startPoint;
  let endPoint;
  if (dragEvent) {
    endPoint = new Point(dragEvent.x, dragEvent.y);
    startPoint = element.getAnchor(AnchorEnd.source).getLocation(endPoint);
  } else {
    const bounds = element.getBounds();
    const isRightLabel = element.getLabelPosition() === LabelPosition.right;
    const referencePoint = isRightLabel ? new Point(bounds.x + bounds.width / 2, bounds.y) : new Point(bounds.right(), Math.tan(handleAngle) * (bounds.width / 2) + bounds.y + bounds.height / 2);
    startPoint = element.getAnchor(AnchorEnd.source).getLocation(referencePoint);
    endPoint = new Point(Math.cos(isRightLabel ? handleAngleTop : handleAngle) * handleLength + startPoint.x, Math.sin(isRightLabel ? handleAngleTop : handleAngle) * handleLength + startPoint.y);
  }
  element.translateFromParent(startPoint);
  element.translateFromParent(endPoint);
  return React407.createElement(
    React407.Fragment,
    null,
    React407.createElement(
      Layer_default,
      { id: TOP_LAYER },
      React407.createElement(
        "g",
        { className: css2(import_topology_components12.default.topologyDefaultCreateConnector), ref: refs, onMouseEnter: !active ? () => onKeepAlive(true) : void 0, onMouseLeave: !active ? () => onKeepAlive(false) : void 0 },
        React407.createElement(ConnectorComponent, { startPoint, endPoint, dragging, hints: hintsRef.current || [], hover }),
        React407.createElement("path", { d: hullPath([
          [startPoint.x, startPoint.y],
          [endPoint.x, endPoint.y]
        ], 7), fillOpacity: "0" })
      )
    ),
    prompt && React407.createElement(ContextMenu_default, { reference: { x: prompt.event.pageX, y: prompt.event.pageY }, className: contextMenuClass, open: true, onRequestClose: () => {
      setActive(false);
      onKeepAlive(false);
    } }, isReactElementArray(prompt.choices) ? prompt.choices : prompt.choices.map((c6) => React407.createElement(DropdownItem, { key: c6.label, onClick: () => {
      onCreate2(prompt.element, prompt.target, prompt.event, hintsRef.current, c6);
    } }, c6.label)))
  );
});
var withCreateConnector = (onCreate2, ConnectorComponent = DefaultCreateConnector_default, contextMenuClass, options) => (WrappedComponent) => {
  const Component50 = (props) => {
    const [show, setShow] = React407.useState(false);
    const [alive, setKeepAlive] = React407.useState(false);
    const onShowCreateConnector = React407.useCallback(() => setShow(true), []);
    const onHideCreateConnector = React407.useCallback(() => setShow(false), []);
    const onKeepAlive = React407.useCallback((isAlive) => setKeepAlive(isAlive), [setKeepAlive]);
    return React407.createElement(
      React407.Fragment,
      null,
      React407.createElement(WrappedComponent, Object.assign({}, props, { onShowCreateConnector, onHideCreateConnector })),
      (show || alive) && React407.createElement(CreateConnectorWidget, Object.assign({}, options, { element: props.element, onCreate: onCreate2, onKeepAlive, ConnectorComponent, contextMenuClass }))
    );
  };
  Component50.displayName = `withCreateConnector(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/behavior/withRemoveConnector.js
var React408 = __toESM(require_react());
var defaultRenderRemove = (edge, onRemove2) => {
  const removeEdge = () => {
    onRemove2(edge);
  };
  return React408.createElement(DefaultRemoveConnector_default, { startPoint: edge.getStartPoint(), endPoint: edge.getEndPoint(), onRemove: removeEdge });
};
var withRemoveConnector = (onRemove2, renderRemove = defaultRenderRemove) => (WrappedComponent) => {
  const Component50 = (props) => {
    const [show, setShow] = React408.useState(false);
    const onShowRemoveConnector = React408.useCallback(() => setShow(true), []);
    const onHideRemoveConnector = React408.useCallback(() => setShow(false), []);
    return React408.createElement(WrappedComponent, Object.assign({}, props, { onShowRemoveConnector, onHideRemoveConnector }), show && renderRemove(props.element, onRemove2));
  };
  Component50.displayName = `withRemoveConnector(${WrappedComponent.displayName || WrappedComponent.name})`;
  return observer2(Component50);
};

// node_modules/@patternfly/react-topology/dist/esm/anchors/EllipseAnchor.js
var EllipseAnchor = class extends AbstractAnchor {
  getLocation(reference2) {
    const r = this.owner.getBounds();
    if (r.isEmpty()) {
      return r.getCenter();
    }
    const offset2x = this.offset * 2;
    return getEllipseAnchorPoint(r.getCenter(), r.width + offset2x, r.height + offset2x, reference2);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/anchors/RectAnchor.js
var RectAnchor = class extends AbstractAnchor {
  getLocation(reference2) {
    const r = this.owner.getBounds();
    const center2 = r.getCenter();
    if (r.isEmpty()) {
      return center2;
    }
    const offset2x = this.offset * 2;
    return getRectAnchorPoint(center2, r.width + offset2x, r.height + offset2x, reference2);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/Ellipse.js
var Ellipse = ({ className = css2(import_topology_components13.default.topologyNodeBackground), width, height, filter: filter3, dndDropRef }) => {
  useAnchor(EllipseAnchor);
  return React409.createElement("ellipse", { className, ref: dndDropRef, cx: width / 2, cy: height / 2, rx: Math.max(0, width / 2 - 1), ry: Math.max(0, height / 2 - 1), filter: filter3 });
};
var Ellipse_default = Ellipse;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/Hexagon.js
var React410 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/shapeUtils.js
var TWO_PI = Math.PI * 2;
var HEXAGON_CORNER_RADIUS = 6;
var OCTAGON_CORNER_RADIUS = 4;
var RHOMBUS_CORNER_RADIUS = 10;
var TRAPEZOID_CORNER_RADIUS = 10;
var LOWER_LEFT_RADIANS = 3 * Math.PI / 4;
var LOWER_RIGHT_RADIANS = Math.PI / 4;
var UPPER_LEFT_RADIANS = 5 * Math.PI / 4;
var UPPER_RIGHT_RADIANS = 7 * Math.PI / 4;
var DEFAULT_DECORATOR_RADIUS = 12;
var DEFAULT_DECORATOR_PADDING = 4;
var quadrantRadians = (quadrant) => {
  switch (quadrant) {
    case TopologyQuadrant.upperRight:
      return UPPER_RIGHT_RADIANS;
    case TopologyQuadrant.lowerRight:
      return LOWER_RIGHT_RADIANS;
    case TopologyQuadrant.upperLeft:
      return UPPER_LEFT_RADIANS;
    case TopologyQuadrant.lowerLeft:
      return LOWER_LEFT_RADIANS;
  }
  return UPPER_RIGHT_RADIANS;
};
var getPointsForSides = (numSides, size, padding = 0) => {
  const points = [];
  const angle2 = TWO_PI / numSides;
  const radius = size / 2;
  for (let point7 = 0; point7 < numSides; point7++) {
    points.push([
      radius + (radius - padding) * Math.cos(angle2 * point7),
      radius + (radius - padding) * Math.sin(angle2 * point7)
    ]);
  }
  return points;
};
var getHullPath = (points, padding) => {
  const hullPoints = hull_default(points);
  return hullPath(hullPoints, padding);
};
var getPathForSides = (numSides, size, padding = 0) => {
  const points = getPointsForSides(numSides, size, padding);
  if (!padding) {
    return pointTuplesToPath(points);
  }
  return getHullPath(points, padding);
};
var getShapeComponent = (node) => {
  switch (node.getNodeShape()) {
    case NodeShape.circle:
    case NodeShape.ellipse:
      return Ellipse_default;
    case NodeShape.stadium:
      return Stadium_default;
    case NodeShape.rhombus:
      return Rhombus_default;
    case NodeShape.trapezoid:
      return Trapezoid_default;
    case NodeShape.rect:
      return Rectangle_default;
    case NodeShape.hexagon:
      return Hexagon_default;
    case NodeShape.octagon:
      return Octagon_default;
    default:
      return Ellipse_default;
  }
};
var getDefaultShapeDecoratorCenter = (quadrant, node) => {
  const { width, height } = node.getDimensions();
  const shape = node.getNodeShape();
  const nodeCenterX = width / 2;
  const nodeCenterY = height / 2;
  let deltaX = width / 2;
  let deltaY = height / 2;
  switch (shape) {
    case NodeShape.circle:
    case NodeShape.ellipse:
      return {
        x: nodeCenterX + Math.cos(quadrantRadians(quadrant)) * deltaX,
        y: nodeCenterY + Math.sin(quadrantRadians(quadrant)) * deltaY
      };
    case NodeShape.rect:
      break;
    case NodeShape.rhombus:
      deltaX = width / 3;
      deltaY = height / 3;
      break;
    case NodeShape.trapezoid:
      if (quadrant === TopologyQuadrant.upperRight || quadrant === TopologyQuadrant.upperLeft) {
        deltaX = deltaX * 0.875 - TRAPEZOID_CORNER_RADIUS;
      }
      break;
    case NodeShape.hexagon:
      deltaX = deltaX * 0.75 - HEXAGON_CORNER_RADIUS;
      deltaY = deltaY * 0.75;
      break;
    case NodeShape.octagon:
      deltaX = deltaX - OCTAGON_CORNER_RADIUS;
      deltaY = deltaY - height / 5;
      break;
    default:
      break;
  }
  switch (quadrant) {
    case TopologyQuadrant.upperRight:
      return {
        x: nodeCenterX + deltaX,
        y: nodeCenterY - deltaY
      };
    case TopologyQuadrant.lowerRight:
      return {
        x: nodeCenterX + deltaX,
        y: nodeCenterY + deltaY
      };
    case TopologyQuadrant.upperLeft:
      return {
        x: nodeCenterX - deltaX,
        y: nodeCenterY - deltaY
      };
    case TopologyQuadrant.lowerLeft:
      return {
        x: nodeCenterX - deltaX,
        y: nodeCenterY + deltaY
      };
    default:
      return {
        x: nodeCenterX,
        y: nodeCenterY
      };
  }
};

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/Hexagon.js
var Hexagon = (props) => {
  var _a2;
  return React410.createElement(SidedShape_default, Object.assign({ cornerRadius: (_a2 = props.cornerRadius) !== null && _a2 !== void 0 ? _a2 : HEXAGON_CORNER_RADIUS }, props, { sides: 6 }));
};
var Hexagon_default = Hexagon;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/Octagon.js
var React411 = __toESM(require_react());
var Octagon = (props) => {
  var _a2;
  return React411.createElement(SidedShape_default, Object.assign({ cornerRadius: (_a2 = props.cornerRadius) !== null && _a2 !== void 0 ? _a2 : OCTAGON_CORNER_RADIUS }, props, { sides: 8 }));
};
var Octagon_default = Octagon;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/Rectangle.js
var React412 = __toESM(require_react());
var import_topology_components14 = __toESM(require_topology_components());
var Rectangle = ({ className = css2(import_topology_components14.default.topologyNodeBackground), width, height, filter: filter3, cornerRadius = 15, dndDropRef }) => {
  useAnchor(RectAnchor);
  return React412.createElement("rect", { className, ref: dndDropRef, x: 0, y: 0, rx: cornerRadius, ry: cornerRadius, width, height, filter: filter3 });
};
var Rectangle_default = Rectangle;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/Rhombus.js
var React413 = __toESM(require_react());
var import_topology_components15 = __toESM(require_topology_components());
var getRhombusPoints = (width, height, padding) => [
  [width / 2, -padding],
  [width + padding, height / 2],
  [width / 2, height + padding],
  [-padding, height / 2]
];
var Rhombus = ({ className = css2(import_topology_components15.default.topologyNodeBackground), width, height, filter: filter3, cornerRadius = RHOMBUS_CORNER_RADIUS, dndDropRef }) => {
  const anchorRef = useSvgAnchor();
  const refs = useCombineRefs_default(dndDropRef, anchorRef);
  const points = React413.useMemo(() => {
    const polygonPoints = getRhombusPoints(width, height, cornerRadius / 2);
    return cornerRadius ? getHullPath(getRhombusPoints(width, height, -cornerRadius), cornerRadius) : polygonPoints.map((p) => `${p[0]},${p[1]}`).join(" ");
  }, [cornerRadius, height, width]);
  return cornerRadius ? React413.createElement("path", { className, ref: refs, d: points, filter: filter3 }) : React413.createElement("polygon", { className, ref: refs, points, filter: filter3 });
};
var Rhombus_default = Rhombus;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/Stadium.js
var import_topology_components16 = __toESM(require_topology_components());
var React414 = __toESM(require_react());
var getStadiumPoints = (width, radius) => [
  [radius, radius],
  [width - radius, radius],
  [width - radius, radius],
  [radius, radius]
];
var Stadium = ({ className = css2(import_topology_components16.default.topologyNodeBackground), width, height, filter: filter3, dndDropRef }) => {
  const anchorRef = useSvgAnchor();
  const refs = useCombineRefs_default(dndDropRef, anchorRef);
  const points = React414.useMemo(() => getHullPath(getStadiumPoints(width, height / 2), height / 2), [height, width]);
  return React414.createElement("path", { className, ref: refs, d: points, filter: filter3 });
};
var Stadium_default = Stadium;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/Trapezoid.js
var import_topology_components17 = __toESM(require_topology_components());
var React415 = __toESM(require_react());
var TOP_INSET_AMOUNT = 1 / 8;
var getTrapezoidPoints = (width, height, padding, outline = false) => {
  const yPadding = outline ? 0 : padding;
  const topXPadding = outline ? padding / 4 : padding;
  const bottomXPadding = outline ? -padding / 4 : padding;
  return [
    [width * TOP_INSET_AMOUNT + topXPadding, yPadding],
    [width - width * TOP_INSET_AMOUNT - topXPadding, yPadding],
    [width - bottomXPadding, height - yPadding],
    [bottomXPadding, height - yPadding]
  ];
};
var Trapezoid = ({ className = css2(import_topology_components17.default.topologyNodeBackground), width, height, filter: filter3, cornerRadius = TRAPEZOID_CORNER_RADIUS, dndDropRef }) => {
  const [polygonPoints, points] = React415.useMemo(() => {
    const polygonPoints2 = getTrapezoidPoints(width, height, cornerRadius, true);
    const path3 = cornerRadius ? getHullPath(getTrapezoidPoints(width, height, cornerRadius), cornerRadius) : polygonPoints2.map((p) => `${p[0]},${p[1]}`).join(" ");
    return [polygonPoints2, path3];
  }, [height, cornerRadius, width]);
  usePolygonAnchor(polygonPoints);
  return cornerRadius ? React415.createElement("path", { className, ref: dndDropRef, d: points, filter: filter3 }) : React415.createElement("polygon", { className, ref: dndDropRef, points, filter: filter3 });
};
var Trapezoid_default = Trapezoid;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/shapes/SidedShape.js
var import_topology_components18 = __toESM(require_topology_components());
var React416 = __toESM(require_react());
var SidedShape = ({ className = css2(import_topology_components18.default.topologyNodeBackground), width, height, filter: filter3, sides = 6, cornerRadius = 0, dndDropRef }) => {
  const [polygonPoints, points] = React416.useMemo(() => {
    const polygonPoints2 = getPointsForSides(sides, Math.min(width, height));
    return [
      polygonPoints2,
      cornerRadius ? getPathForSides(sides, Math.min(width, height), cornerRadius) : polygonPoints2.map((p) => `${p[0]},${p[1]}`).join(" ")
    ];
  }, [cornerRadius, height, sides, width]);
  usePolygonAnchor(polygonPoints);
  return cornerRadius ? React416.createElement("path", { className, ref: dndDropRef, d: points, filter: filter3 }) : React416.createElement("polygon", { className, ref: dndDropRef, points, filter: filter3 });
};
var SidedShape_default = SidedShape;

// node_modules/@patternfly/react-topology/dist/esm/components/nodes/DefaultNode.js
var StatusQuadrant = TopologyQuadrant.upperLeft;
var getStatusIcon = (status) => {
  switch (status) {
    case NodeStatus.danger:
      return React417.createElement(exclamation_circle_icon_default2, { className: "pf-m-danger" });
    case NodeStatus.warning:
      return React417.createElement(exclamation_triangle_icon_default2, { className: "pf-m-warning" });
    case NodeStatus.success:
      return React417.createElement(check_circle_icon_default2, { className: "pf-m-success" });
    default:
      return null;
  }
};
var SCALE_UP_TIME = 200;
var DefaultNodeInner = observer2(({ className, element, selected, hover, scaleNode, showLabel = true, label, secondaryLabel, labelClassName, labelPosition, scaleLabel, truncateLength, labelIconClass, labelIcon, labelIconPadding, nodeStatus, showStatusBackground, showStatusDecorator = false, statusDecoratorTooltip, getCustomShape, getShapeDecoratorCenter, onStatusDecoratorClick, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, onSelect, children: children2, attachments, dragNodeRef, dragging, edgeDragging, canDrop, dropTarget, dndDropRef, onHideCreateConnector, onShowCreateConnector, onContextMenu, contextMenuOpen }) => {
  const [hovered, hoverRef] = useHover_default();
  const status = nodeStatus || element.getNodeStatus();
  const refs = useCombineRefs_default(hoverRef, dragNodeRef);
  const { width, height } = element.getDimensions();
  const isHover = hover !== void 0 ? hover : hovered;
  const [nodeScale, setNodeScale] = React417.useState(1);
  const decoratorRef = React417.useRef();
  const statusDecorator = React417.useMemo(() => {
    if (!status || !showStatusDecorator) {
      return null;
    }
    const icon = getStatusIcon(status);
    if (!icon) {
      return null;
    }
    const { x: x4, y: y4 } = getShapeDecoratorCenter ? getShapeDecoratorCenter(StatusQuadrant, element) : getDefaultShapeDecoratorCenter(StatusQuadrant, element);
    const decorator = React417.createElement(Decorator_default, { x: x4, y: y4, radius: DEFAULT_DECORATOR_RADIUS, showBackground: true, onClick: (e) => onStatusDecoratorClick(e, element), icon: React417.createElement("g", { className: css2(import_topology_components19.default.topologyNodeDecoratorStatus) }, icon), ariaLabel: status, innerRef: decoratorRef });
    if (statusDecoratorTooltip) {
      return React417.createElement(Tooltip, { triggerRef: decoratorRef, content: statusDecoratorTooltip, position: TooltipPosition.left }, decorator);
    }
    return decorator;
  }, [status, showStatusDecorator, getShapeDecoratorCenter, element, statusDecoratorTooltip, onStatusDecoratorClick]);
  React417.useEffect(() => {
    if (isHover) {
      onShowCreateConnector && onShowCreateConnector();
    } else {
      onHideCreateConnector && onHideCreateConnector();
    }
  }, [isHover, onShowCreateConnector, onHideCreateConnector]);
  const ShapeComponent = getCustomShape && getCustomShape(element) || getShapeComponent(element);
  const groupClassName = css2(import_topology_components19.default.topologyNode, className, isHover && "pf-m-hover", (dragging || edgeDragging) && "pf-m-dragging", canDrop && "pf-m-highlight", canDrop && dropTarget && "pf-m-drop-target", selected && "pf-m-selected", StatusModifier[status]);
  const backgroundClassName = css2(import_topology_components19.default.topologyNodeBackground, showStatusBackground && StatusModifier[status], showStatusBackground && selected && "pf-m-selected");
  let filter3;
  if (status === "danger") {
    filter3 = createSvgIdUrl(NODE_SHADOW_FILTER_ID_DANGER);
  } else if (isHover || dragging || edgeDragging || dropTarget) {
    filter3 = createSvgIdUrl(NODE_SHADOW_FILTER_ID_HOVER);
  }
  const nodeLabelPosition = labelPosition || element.getLabelPosition();
  const scale2 = element.getGraph().getScale();
  const animationRef = React417.useRef();
  const scaleGoal = React417.useRef(1);
  const nodeScaled = React417.useRef(false);
  React417.useEffect(() => {
    if (!scaleNode || scale2 >= 1) {
      setNodeScale(1);
      nodeScaled.current = false;
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = 0;
      }
    } else {
      scaleGoal.current = 1 / scale2;
      const scaleDelta = scaleGoal.current - scale2;
      const initTime = performance.now();
      const bumpScale = (bumpTime) => {
        const scalePercent = (bumpTime - initTime) / SCALE_UP_TIME;
        const nextScale = Math.min(scale2 + scaleDelta * scalePercent, scaleGoal.current);
        setNodeScale(nextScale);
        if (nextScale < scaleGoal.current) {
          animationRef.current = requestAnimationFrame(bumpScale);
        } else {
          nodeScaled.current = true;
          animationRef.current = 0;
        }
      };
      if (nodeScaled.current) {
        setNodeScale(scaleGoal.current);
      } else if (!animationRef.current) {
        animationRef.current = requestAnimationFrame(bumpScale);
      }
    }
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = 0;
      }
    };
  }, [scale2, scaleNode]);
  const counterScale = (scale3, scaleMin, scaleMax, valueMin, valueMax) => {
    if (scale3 >= scaleMax) {
      return valueMin;
    } else if (scale3 <= scaleMin) {
      return valueMax;
    }
    return valueMin + (1 - (scale3 - scaleMin) / (scaleMax - scaleMin)) * (valueMax - valueMin);
  };
  const labelScale = scaleLabel ? counterScale(scale2, 0.35, 0.85, 1, 1.6) : 1;
  const labelPositionScale = scaleLabel ? Math.min(1, 1 / labelScale) : 1;
  const { translateX: translateX2, translateY: translateY2 } = React417.useMemo(() => {
    if (!scaleNode) {
      return { translateX: 0, translateY: 0 };
    }
    const bounds = element.getBounds();
    const translateX3 = bounds.width / 2 - bounds.width / 2 * nodeScale;
    const translateY3 = bounds.height / 2 - bounds.height / 2 * nodeScale;
    return { translateX: translateX3, translateY: translateY3 };
  }, [element, nodeScale, scaleNode]);
  let labelX;
  let labelY;
  const labelPaddingX = 8;
  const labelPaddingY = 4;
  if (nodeLabelPosition === LabelPosition.right) {
    labelX = (width + labelPaddingX) * labelPositionScale;
    labelY = height / 2;
  } else if (nodeLabelPosition === LabelPosition.left) {
    labelX = 0;
    labelY = height / 2 - labelPaddingY;
  } else if (nodeLabelPosition === LabelPosition.top) {
    labelX = width / 2;
    labelY = labelPaddingY + labelPaddingY / 2;
  } else {
    labelX = width / 2 * labelPositionScale;
    labelY = height + labelPaddingY + labelPaddingY / 2;
  }
  return React417.createElement(
    "g",
    { className: groupClassName, transform: `${scaleNode ? `translate(${translateX2}, ${translateY2})` : ""} scale(${nodeScale})` },
    React417.createElement(NodeShadows_default, null),
    React417.createElement(
      "g",
      { ref: refs, onClick: onSelect, onContextMenu },
      ShapeComponent && React417.createElement(ShapeComponent, { className: backgroundClassName, element, width, height, dndDropRef, filter: filter3 }),
      showLabel && (label || element.getLabel()) && React417.createElement(
        Layer_default,
        { id: isHover ? TOP_LAYER : void 0 },
        React417.createElement(
          "g",
          { className: groupClassName, transform: isHover ? `${scaleNode ? `translate(${translateX2}, ${translateY2})` : ""} scale(${nodeScale})` : void 0 },
          React417.createElement(
            "g",
            { transform: `scale(${labelScale})` },
            React417.createElement(NodeLabel_default, { className: css2(import_topology_components19.default.topologyNodeLabel, labelClassName), x: labelX, y: labelY * labelPositionScale, position: nodeLabelPosition, paddingX: 8, paddingY: 4, secondaryLabel, truncateLength, status, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, onContextMenu, contextMenuOpen, hover: isHover, labelIconClass, labelIcon, labelIconPadding }, label || element.getLabel())
          )
        )
      ),
      children2
    ),
    statusDecorator,
    attachments
  );
});
var DefaultNode = (_a2) => {
  var { element, showLabel = true, showStatusDecorator = false } = _a2, rest = __rest(_a2, ["element", "showLabel", "showStatusDecorator"]);
  if (!isNode(element)) {
    throw new Error("DefaultNode must be used only on Node elements");
  }
  return React417.createElement(DefaultNodeInner, Object.assign({ element, showLabel, showStatusDecorator }, rest));
};
var DefaultNode_default = DefaultNode;

// node_modules/@patternfly/react-topology/dist/esm/components/decorators/Decorator.js
var HOVER_FILTER_ID = "DecoratorDropShadowHoverFilterId";
var Decorator = ({ className, x: x4, y: y4, showBackground, radius, padding = DEFAULT_DECORATOR_PADDING, children: children2, icon, onClick, ariaLabel, circleRef, innerRef }) => {
  const [hover, hoverRef] = useHover_default();
  const iconRadius = radius - padding;
  return React418.createElement(
    "g",
    Object.assign({ ref: useCombineRefs_default(hoverRef, innerRef), className: css2(import_topology_components20.default.topologyNodeDecorator, className) }, onClick ? {
      onClick: (e) => {
        e.stopPropagation();
        onClick(e);
      },
      role: "button",
      "aria-label": ariaLabel
    } : null),
    React418.createElement(SvgDropShadowFilter_default, { id: HOVER_FILTER_ID, dy: 3, stdDeviation: 5, floodOpacity: 0.5 }),
    showBackground && React418.createElement("circle", { key: hover ? "circle-hover" : "circle", ref: circleRef, className: css2(import_topology_components20.default.topologyNodeDecoratorBg), cx: x4, cy: y4, r: radius, filter: hover ? createSvgIdUrl(HOVER_FILTER_ID) : void 0 }),
    React418.createElement(
      "g",
      { transform: `translate(${x4}, ${y4})` },
      icon ? React418.createElement("g", { className: css2(import_topology_components20.default.topologyNodeDecoratorIcon), style: { fontSize: `${iconRadius * 2}px` }, transform: `translate(-${iconRadius}, -${iconRadius})` }, icon) : null,
      children2
    )
  );
};
var Decorator_default = Decorator;

// node_modules/@patternfly/react-topology/dist/esm/components/groups/DefaultGroup.js
var React421 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/components/groups/DefaultGroupExpanded.js
var React419 = __toESM(require_react());
var import_topology_components21 = __toESM(require_topology_components());
function computeLabelLocation(points, labelPosition) {
  let lowPoints;
  let highPoints;
  const threshold2 = 5;
  if (labelPosition === LabelPosition.top) {
    points.forEach((p) => {
      const delta = !highPoints ? -Infinity : Math.round(p[1]) - Math.round(highPoints[0][1]);
      if (delta < -threshold2) {
        highPoints = [p];
      } else if (Math.abs(delta) <= threshold2) {
        if (!highPoints) {
          highPoints = [];
        }
        highPoints.push(p);
      }
    });
    const minX2 = highPoints.reduce((min4, p) => Math.min(min4, p[0]), Infinity);
    const maxX2 = highPoints.reduce((max5, p) => Math.max(max5, p[0]), -Infinity);
    const minY = highPoints.reduce((min4, p) => Math.min(min4, p[1]), Infinity);
    const maxSize2 = highPoints.reduce((max5, p) => Math.max(max5, p[2]), -Infinity);
    return [
      (minX2 + maxX2) / 2,
      minY,
      // use the max size value
      maxSize2
    ];
  }
  points.forEach((p) => {
    const delta = !lowPoints ? Infinity : Math.round(p[1]) - Math.round(lowPoints[0][1]);
    if (delta > threshold2) {
      lowPoints = [p];
    } else if (Math.abs(delta) <= threshold2) {
      lowPoints.push(p);
    }
  });
  const minX = lowPoints.reduce((acc, point7) => {
    return Math.min(acc, point7[0]);
  }, Number.POSITIVE_INFINITY);
  const maxX = lowPoints.reduce((acc, point7) => {
    return Math.max(acc, point7[0]);
  }, Number.NEGATIVE_INFINITY);
  const maxSize = lowPoints.reduce((acc, point7) => {
    return Math.max(acc, point7[2]);
  }, Number.NEGATIVE_INFINITY);
  return [(minX + maxX) / 2, lowPoints[0][1], maxSize];
}
var DefaultGroupExpanded = ({ className, element, collapsible, selected, onSelect, hover, label, secondaryLabel, showLabel = true, showLabelOnHover, truncateLength, dndDropRef, droppable, canDrop, dropTarget, onContextMenu, contextMenuOpen, dragging, dragNodeRef, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, labelIconClass, labelIcon, labelPosition, labelIconPadding, onCollapseChange, hulledOutline = true, borderRadius = 16 }) => {
  var _a2;
  const [hovered, hoverRef] = useHover_default(200, 500);
  const [labelHover, labelHoverRef] = useHover_default(0);
  const dragLabelRef = useDragNode()[1];
  const refs = useCombineRefs_default(hoverRef, dragNodeRef);
  const isHover = hover !== void 0 ? hover : hovered || labelHover;
  const anchorRef = useSvgAnchor();
  const outlineRef = useCombineRefs_default(dndDropRef, anchorRef);
  const labelLocation = React419.useRef();
  const pathRef = React419.useRef();
  const boxRef = React419.useRef(null);
  let parent = element.getParent();
  let altGroup = false;
  while (!isGraph(parent)) {
    altGroup = !altGroup;
    parent = parent.getParent();
  }
  const padding = maxPadding((_a2 = element.getStyle().padding) !== null && _a2 !== void 0 ? _a2 : 17);
  const hullPadding = (point7) => (point7[2] || 0) + padding;
  if (!droppable || hulledOutline && !pathRef.current || !hulledOutline && !boxRef.current || !labelLocation.current) {
    const children2 = element.getNodes().filter((c6) => c6.isVisible());
    if (children2.length === 0) {
      return null;
    }
    const points = [];
    children2.forEach((c6) => {
      if (c6.getNodeShape() === NodeShape.circle) {
        const bounds = c6.getBounds();
        const { width, height } = bounds;
        const { x: x4, y: y4 } = bounds.getCenter();
        const radius = Math.max(width, height) / 2;
        points.push([x4, y4, radius]);
      } else {
        const { width, height, x: x4, y: y4 } = c6.getBounds();
        points.push([x4, y4, 0]);
        points.push([x4 + width, y4, 0]);
        points.push([x4, y4 + height, 0]);
        points.push([x4 + width, y4 + height, 0]);
      }
    });
    if (hulledOutline) {
      const hullPoints = points.length > 2 ? hull_default(points) : points;
      if (!hullPoints) {
        return null;
      }
      pathRef.current = hullPath(hullPoints, hullPadding);
      labelLocation.current = computeLabelLocation(hullPoints, labelPosition);
    } else {
      boxRef.current = element.getBounds();
      labelLocation.current = labelPosition === LabelPosition.top ? [boxRef.current.x + boxRef.current.width / 2, boxRef.current.y, 0] : [boxRef.current.x + boxRef.current.width / 2, boxRef.current.y + boxRef.current.height, 0];
    }
  }
  const groupClassName = css2(import_topology_components21.default.topologyGroup, className, altGroup && "pf-m-alt-group", canDrop && "pf-m-highlight", dragging && "pf-m-dragging", selected && "pf-m-selected");
  const innerGroupClassName = css2(import_topology_components21.default.topologyGroup, className, altGroup && "pf-m-alt-group", canDrop && "pf-m-highlight", dragging && "pf-m-dragging", selected && "pf-m-selected", (isHover || labelHover) && "pf-m-hover", canDrop && dropTarget && "pf-m-drop-target");
  const outlinePadding = hulledOutline ? hullPadding(labelLocation.current) : 0;
  const labelGap = 24;
  const startX = labelLocation.current[0];
  const startY = labelPosition === LabelPosition.top ? labelLocation.current[1] - outlinePadding - labelGap * 2 : labelLocation.current[1] + outlinePadding + labelGap;
  const scale2 = element.getGraph().getScale();
  const medScale = element.getGraph().getDetailsLevelThresholds().medium;
  const labelScale = !showLabel && showLabelOnHover && isHover ? Math.min(1 / scale2, 1 / medScale) : 1;
  const labelPositionScale = 1 / labelScale;
  const groupLabel = (showLabel || showLabelOnHover && isHover) && (label || element.getLabel()) ? React419.createElement(
    "g",
    { ref: labelHoverRef, transform: isHover ? `scale(${labelScale})` : void 0 },
    React419.createElement(NodeLabel_default, { className: import_topology_components21.default.topologyGroupLabel, x: startX * labelPositionScale, y: startY * labelPositionScale, paddingX: 8, paddingY: 5, dragRef: dragNodeRef ? dragLabelRef : void 0, status: element.getNodeStatus(), secondaryLabel, truncateLength, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, labelIconClass, labelIcon, labelIconPadding, onContextMenu, contextMenuOpen, hover: isHover || labelHover, actionIcon: collapsible ? React419.createElement(compress_alt_icon_default, null) : void 0, onActionIconClick: () => onCollapseChange(element, true) }, label || element.getLabel())
  ) : null;
  return React419.createElement(
    "g",
    { onContextMenu, onClick: onSelect, className: groupClassName },
    React419.createElement(
      Layer_default,
      { id: GROUPS_LAYER },
      React419.createElement("g", { ref: refs, onContextMenu, onClick: onSelect, className: innerGroupClassName }, hulledOutline ? React419.createElement("path", { ref: outlineRef, className: import_topology_components21.default.topologyGroupBackground, d: pathRef.current }) : React419.createElement("rect", { ref: outlineRef, className: import_topology_components21.default.topologyGroupBackground, x: boxRef.current.x, y: boxRef.current.y, width: boxRef.current.width, height: boxRef.current.height, rx: borderRadius, ry: borderRadius })),
      groupLabel && isHover ? React419.createElement(
        Layer_default,
        { id: TOP_LAYER },
        React419.createElement("g", { className: innerGroupClassName }, groupLabel)
      ) : groupLabel
    )
  );
};
var DefaultGroupExpanded_default = observer2(DefaultGroupExpanded);

// node_modules/@patternfly/react-topology/dist/esm/components/groups/DefaultGroupCollapsed.js
var React420 = __toESM(require_react());
var import_topology_components22 = __toESM(require_topology_components());
var DefaultGroupCollapsed = ({ className, element, collapsible, selected, onSelect, children: children2, hover, label, secondaryLabel, showLabel = true, truncateLength, collapsedWidth, collapsedHeight, getCollapsedShape, onCollapseChange, collapsedShadowOffset = 8, dndDropRef, dragNodeRef, canDrop, dropTarget, onContextMenu, contextMenuOpen, dragging, labelPosition, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, labelIconClass, labelIcon, labelIconPadding }) => {
  var _a2;
  const [hovered, hoverRef] = useHover_default();
  const [labelHover, labelHoverRef] = useHover_default();
  const dragLabelRef = useDragNode()[1];
  const [shapeSize, shapeRef] = useSize([collapsedWidth, collapsedHeight]);
  const refs = useCombineRefs_default(hoverRef, dragNodeRef, shapeRef);
  const isHover = hover !== void 0 ? hover : hovered;
  const childCount = element.getAllNodeChildren().length;
  const [badgeSize, badgeRef] = useSize([childCount]);
  const groupClassName = css2(import_topology_components22.default.topologyGroup, className, canDrop && "pf-m-highlight", canDrop && dropTarget && "pf-m-drop-target", dragging && "pf-m-dragging", selected && "pf-m-selected");
  const ShapeComponent = getCollapsedShape ? getCollapsedShape(element) : Ellipse_default;
  const filter3 = isHover || dragging || dropTarget ? createSvgIdUrl(NODE_SHADOW_FILTER_ID_HOVER) : void 0;
  return React420.createElement(
    "g",
    { ref: labelHoverRef, onContextMenu, onClick: onSelect, className: groupClassName },
    React420.createElement(
      Layer_default,
      { id: GROUPS_LAYER },
      React420.createElement("g", { ref: refs, onClick: onSelect }, ShapeComponent && React420.createElement(
        React420.Fragment,
        null,
        React420.createElement(
          "g",
          { transform: `translate(${collapsedShadowOffset * 2}, 0)` },
          React420.createElement(ShapeComponent, { className: css2(import_topology_components22.default.topologyNodeBackground, "pf-m-disabled"), element, width: collapsedWidth, height: collapsedHeight })
        ),
        React420.createElement(
          "g",
          { transform: `translate(${collapsedShadowOffset}, 0)` },
          React420.createElement(ShapeComponent, { className: css2(import_topology_components22.default.topologyNodeBackground, "pf-m-disabled"), element, width: collapsedWidth, height: collapsedHeight })
        ),
        React420.createElement(ShapeComponent, { className: css2(import_topology_components22.default.topologyNodeBackground), key: isHover || dragging || dropTarget ? "shape-background-hover" : "shape-background", element, width: collapsedWidth, height: collapsedHeight, dndDropRef, filter: filter3 })
      ))
    ),
    shapeSize && childCount && React420.createElement(LabelBadge_default, { className: import_topology_components22.default.topologyGroupCollapsedBadge, ref: badgeRef, x: shapeSize.width - 8, y: (shapeSize.width - ((_a2 = badgeSize === null || badgeSize === void 0 ? void 0 : badgeSize.height) !== null && _a2 !== void 0 ? _a2 : 0)) / 2, badge: `${childCount}`, badgeColor, badgeTextColor, badgeBorderColor }),
    showLabel && React420.createElement(NodeLabel_default, { className: import_topology_components22.default.topologyGroupLabel, x: collapsedWidth / 2, y: labelPosition === LabelPosition.top ? collapsedHeight / 2 - collapsedHeight : collapsedHeight + 6, paddingX: 8, paddingY: 5, dragRef: dragNodeRef ? dragLabelRef : void 0, status: element.getNodeStatus(), secondaryLabel, truncateLength, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, labelIconClass, labelIcon, labelIconPadding, onContextMenu, contextMenuOpen, hover: isHover || labelHover, actionIcon: collapsible ? React420.createElement(expand_alt_icon_default, null) : void 0, onActionIconClick: () => onCollapseChange(element, false) }, label || element.getLabel()),
    children2
  );
};
var DefaultGroupCollapsed_default = observer2(DefaultGroupCollapsed);

// node_modules/@patternfly/react-topology/dist/esm/components/groups/DefaultGroup.js
var DefaultGroupInner = observer2((_a2) => {
  var { className, element, onCollapseChange } = _a2, rest = __rest(_a2, ["className", "element", "onCollapseChange"]);
  const handleCollapse = (group2, collapsed) => {
    if (collapsed && rest.collapsedWidth !== void 0 && rest.collapsedHeight !== void 0) {
      group2.setDimensions(new Dimensions(rest.collapsedWidth, rest.collapsedHeight));
    }
    group2.setCollapsed(collapsed);
    onCollapseChange && onCollapseChange(group2, collapsed);
  };
  if (element.isCollapsed()) {
    return React421.createElement(DefaultGroupCollapsed_default, Object.assign({ className, element, onCollapseChange: handleCollapse }, rest));
  }
  return React421.createElement(DefaultGroupExpanded_default, Object.assign({ className, element, onCollapseChange: handleCollapse }, rest));
});
var DefaultGroup = (_a2) => {
  var { element } = _a2, rest = __rest(_a2, ["element"]);
  if (!isNode(element)) {
    throw new Error("DefaultGroup must be used only on Node elements");
  }
  return React421.createElement(DefaultGroupInner, Object.assign({ element }, rest));
};
var DefaultGroup_default = DefaultGroup;

// node_modules/@patternfly/react-topology/dist/esm/components/edges/DefaultEdge.js
var React428 = __toESM(require_react());
var import_topology_components29 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/dist/esm/components/edges/terminals/DefaultConnectorTerminal.js
var React426 = __toESM(require_react());
var import_topology_components27 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/dist/esm/components/edges/terminals/ConnectorCross.js
var React422 = __toESM(require_react());
var import_topology_components23 = __toESM(require_topology_components());
var ConnectorCross = ({ startPoint, endPoint, className = "", isTarget = true, size = 14, dragRef }) => {
  if (!startPoint || !endPoint) {
    return null;
  }
  const width = size / 4;
  const yDelta = size / 2;
  const connectorStartPoint = getConnectorStartPoint(startPoint, endPoint, size);
  const angleDeg = getConnectorRotationAngle(startPoint, endPoint);
  const classNames = css2(import_topology_components23.default.topologyConnectorArrow, import_topology_components23.default.topologyConnectorCross, className, !isTarget && "pf-m-source", dragRef && "pf-m-draggable");
  return React422.createElement(
    "g",
    { transform: `translate(${connectorStartPoint[0]}, ${connectorStartPoint[1]}) rotate(${angleDeg})`, ref: dragRef, className: classNames },
    React422.createElement("rect", { x: 0, y: -yDelta, width: size, height: size, fillOpacity: 0, strokeOpacity: 0 }),
    isTarget ? React422.createElement(
      React422.Fragment,
      null,
      React422.createElement("line", { x1: width, y1: yDelta, x2: width, y2: -yDelta }),
      React422.createElement("line", { x1: 2 * width, y1: yDelta, x2: 2 * width, y2: -yDelta })
    ) : React422.createElement("rect", { x: width, y: -yDelta, width, height: size })
  );
};
var ConnectorCross_default = ConnectorCross;

// node_modules/@patternfly/react-topology/dist/esm/components/edges/terminals/ConnectorSquare.js
var React423 = __toESM(require_react());
var import_topology_components24 = __toESM(require_topology_components());
var ConnectorSquare = ({ startPoint, endPoint, className = "", isTarget = true, size = 14, dragRef }) => {
  if (!startPoint || !endPoint) {
    return null;
  }
  const connectorStartPoint = getConnectorStartPoint(startPoint, endPoint, size);
  const angleDeg = getConnectorRotationAngle(startPoint, endPoint);
  const classNames = css2(import_topology_components24.default.topologyConnectorArrow, import_topology_components24.default.topologyConnectorSquare, !isTarget && import_topology_components24.default.modifiers.source, className, dragRef && "pf-m-draggable");
  return React423.createElement(
    "g",
    { transform: `translate(${connectorStartPoint[0]}, ${connectorStartPoint[1]}) rotate(${angleDeg})`, ref: dragRef, className: classNames },
    React423.createElement("rect", { x: 0, y: -size / 2, width: size, height: size })
  );
};
var ConnectorSquare_default = ConnectorSquare;

// node_modules/@patternfly/react-topology/dist/esm/components/edges/terminals/ConnectorCircle.js
var React424 = __toESM(require_react());
var import_topology_components25 = __toESM(require_topology_components());
var ConnectorCircle = ({ startPoint, endPoint, className = "", isTarget = true, size = 14, dragRef }) => {
  if (!startPoint || !endPoint) {
    return null;
  }
  const connectorStartPoint = getConnectorStartPoint(startPoint, endPoint, size / 2);
  const classNames = css2(import_topology_components25.default.topologyConnectorArrow, import_topology_components25.default.topologyConnectorCircle, className, !isTarget && import_topology_components25.default.modifiers.source, dragRef && "pf-m-draggable");
  return React424.createElement(
    "g",
    { transform: `translate(${connectorStartPoint[0]}, ${connectorStartPoint[1]})`, ref: dragRef, className: classNames },
    React424.createElement("circle", { cx: 0, cy: 0, r: size / 2 })
  );
};
var ConnectorCircle_default = ConnectorCircle;

// node_modules/@patternfly/react-topology/dist/esm/components/edges/terminals/ConnectorArrowAlt.js
var React425 = __toESM(require_react());
var import_topology_components26 = __toESM(require_topology_components());
var ConnectorArrowAlt = ({ startPoint, endPoint, className = "", size, dragRef }) => {
  const classes = css2(import_topology_components26.default.topologyConnectorArrow, import_topology_components26.default.modifiers.altConnectorArrow, className, dragRef && "pf-m-draggable");
  return React425.createElement(ConnectorArrow_default, { startPoint, endPoint, className: classes, size, dragRef });
};
var ConnectorArrowAlt_default = ConnectorArrowAlt;

// node_modules/@patternfly/react-topology/dist/esm/components/edges/terminals/DefaultConnectorTerminal.js
var DefaultConnectorTerminal = (_a2) => {
  var { className, edge, isTarget = true, terminalType, status, startPoint, endPoint } = _a2, others = __rest(_a2, ["className", "edge", "isTarget", "terminalType", "status", "startPoint", "endPoint"]);
  let Terminal;
  switch (terminalType) {
    case EdgeTerminalType.directional:
      Terminal = ConnectorArrow_default;
      break;
    case EdgeTerminalType.directionalAlt:
      Terminal = ConnectorArrowAlt_default;
      break;
    case EdgeTerminalType.cross:
      Terminal = ConnectorCross_default;
      break;
    case EdgeTerminalType.square:
      Terminal = ConnectorSquare_default;
      break;
    case EdgeTerminalType.circle:
      Terminal = ConnectorCircle_default;
      break;
    default:
      return null;
  }
  if (!Terminal) {
    return null;
  }
  const bendPoints = edge.getBendpoints();
  const defaultStartPoint = isTarget ? bendPoints[bendPoints.length - 1] || edge.getStartPoint() : bendPoints[0] || edge.getEndPoint();
  const defaultEndPoint = isTarget ? edge.getEndPoint() : edge.getStartPoint();
  const classes = css2(import_topology_components27.default.topologyEdge, className, StatusModifier[status]);
  return React426.createElement(Terminal, Object.assign({ className: classes, startPoint: startPoint !== null && startPoint !== void 0 ? startPoint : defaultStartPoint, endPoint: endPoint !== null && endPoint !== void 0 ? endPoint : defaultEndPoint, isTarget }, others));
};
var DefaultConnectorTerminal_default = observer2(DefaultConnectorTerminal);

// node_modules/@patternfly/react-topology/dist/esm/components/edges/DefaultConnectorTag.js
var React427 = __toESM(require_react());
var import_topology_components28 = __toESM(require_topology_components());
var DefaultConnectorTag = (_a2) => {
  var { className, startPoint, endPoint, tag, status, paddingX = 4, paddingY = 2 } = _a2, other = __rest(_a2, ["className", "startPoint", "endPoint", "tag", "status", "paddingX", "paddingY"]);
  const [textSize, textRef] = useSize([tag, className]);
  const { width, height, startX, startY } = React427.useMemo(() => {
    if (!textSize) {
      return {
        width: 0,
        height: 0,
        startX: 0,
        startY: 0
      };
    }
    const width2 = textSize ? textSize.width + paddingX * 2 : 0;
    const height2 = textSize ? textSize.height + paddingY * 2 : 0;
    const startX2 = -width2 / 2;
    const startY2 = -height2 / 2;
    return {
      width: width2,
      height: height2,
      startX: startX2,
      startY: startY2
    };
  }, [textSize, paddingX, paddingY]);
  return React427.createElement(
    "g",
    { className: css2(import_topology_components28.default.topologyEdgeTag, className, StatusModifier[status]), transform: `translate(${startPoint.x + (endPoint.x - startPoint.x) * 0.5}, ${startPoint.y + (endPoint.y - startPoint.y) * 0.5})` },
    textSize && React427.createElement("rect", { className: css2(import_topology_components28.default.topologyEdgeTagBackground), x: startX, y: startY, width, height, rx: 3, ry: 3 }),
    React427.createElement("text", Object.assign({ dy: "0.35em" }, other, { ref: textRef, x: startX + paddingX, y: 0 }), tag)
  );
};
var DefaultConnectorTag_default = DefaultConnectorTag;

// node_modules/@patternfly/react-topology/dist/esm/components/edges/DefaultEdge.js
var DefaultEdgeInner = observer2(({ element, dragging, sourceDragRef, targetDragRef, edgeStyle, animationDuration, onShowRemoveConnector, onHideRemoveConnector, startTerminalType = EdgeTerminalType.none, startTerminalClass, startTerminalStatus, startTerminalSize = 14, endTerminalType = EdgeTerminalType.directional, endTerminalClass, endTerminalStatus, endTerminalSize = 14, tag, tagClass, tagStatus, children: children2, className, selected, onSelect, onContextMenu }) => {
  const [hover, hoverRef] = useHover_default();
  const startPoint = element.getStartPoint();
  const endPoint = element.getEndPoint();
  React428.useLayoutEffect(() => {
    if (hover && !dragging) {
      onShowRemoveConnector && onShowRemoveConnector();
    } else {
      onHideRemoveConnector && onHideRemoveConnector();
    }
  }, [hover, dragging, onShowRemoveConnector, onHideRemoveConnector]);
  const sourceParent = getClosestVisibleParent(element.getSource());
  const targetParent = getClosestVisibleParent(element.getTarget());
  if (isNode(sourceParent) && sourceParent.isCollapsed() && sourceParent === targetParent) {
    return null;
  }
  const detailsLevel = element.getGraph().getDetailsLevel();
  const groupClassName = css2(import_topology_components29.default.topologyEdge, className, dragging && "pf-m-dragging", hover && !dragging && "pf-m-hover", selected && !dragging && "pf-m-selected", StatusModifier[endTerminalStatus]);
  const edgeAnimationDuration = animationDuration !== null && animationDuration !== void 0 ? animationDuration : getEdgeAnimationDuration(element.getEdgeAnimationSpeed());
  const linkClassName = css2(import_topology_components29.default.topologyEdgeLink, getEdgeStyleClassModifier(edgeStyle || element.getEdgeStyle()));
  const bendpoints = element.getBendpoints();
  const d = `M${startPoint.x} ${startPoint.y} ${bendpoints.map((b) => `L${b.x} ${b.y} `).join("")}L${endPoint.x} ${endPoint.y}`;
  const bgStartPoint = !startTerminalType || startTerminalType === EdgeTerminalType.none ? [startPoint.x, startPoint.y] : getConnectorStartPoint((bendpoints === null || bendpoints === void 0 ? void 0 : bendpoints[0]) || endPoint, startPoint, startTerminalSize);
  const bgEndPoint = !endTerminalType || endTerminalType === EdgeTerminalType.none ? [endPoint.x, endPoint.y] : getConnectorStartPoint((bendpoints === null || bendpoints === void 0 ? void 0 : bendpoints[bendpoints.length - 1]) || startPoint, endPoint, endTerminalSize);
  const backgroundPath = `M${bgStartPoint[0]} ${bgStartPoint[1]} ${bendpoints.map((b) => `L${b.x} ${b.y} `).join("")}L${bgEndPoint[0]} ${bgEndPoint[1]}`;
  const showTag = tag && (detailsLevel === ScaleDetailsLevel.high || hover);
  const scale2 = element.getGraph().getScale();
  const tagScale = hover && !(detailsLevel === ScaleDetailsLevel.high) ? Math.max(1, 1 / scale2) : 1;
  const tagPositionScale = hover && !(detailsLevel === ScaleDetailsLevel.high) ? Math.min(1, scale2) : 1;
  return React428.createElement(
    Layer_default,
    { id: dragging || hover ? TOP_LAYER : void 0 },
    React428.createElement(
      "g",
      { ref: hoverRef, "data-test-id": "edge-handler", className: groupClassName, onClick: onSelect, onContextMenu },
      React428.createElement("path", { className: css2(import_topology_components29.default.topologyEdgeBackground), d: backgroundPath, onMouseEnter: onShowRemoveConnector, onMouseLeave: onHideRemoveConnector }),
      React428.createElement("path", { className: linkClassName, d, style: { animationDuration: `${edgeAnimationDuration}s` } }),
      showTag && React428.createElement(
        "g",
        { transform: `scale(${hover ? tagScale : 1})` },
        React428.createElement(DefaultConnectorTag_default, { className: tagClass, startPoint: element.getStartPoint().scale(tagPositionScale), endPoint: element.getEndPoint().scale(tagPositionScale), tag, status: tagStatus })
      ),
      React428.createElement(DefaultConnectorTerminal_default, { className: startTerminalClass, isTarget: false, edge: element, size: startTerminalSize, dragRef: sourceDragRef, terminalType: startTerminalType, status: startTerminalStatus, highlight: dragging || hover }),
      React428.createElement(DefaultConnectorTerminal_default, { className: endTerminalClass, isTarget: true, dragRef: targetDragRef, edge: element, size: endTerminalSize, terminalType: endTerminalType, status: endTerminalStatus, highlight: dragging || hover }),
      children2
    )
  );
});
var DefaultEdge = (_a2) => {
  var { element, startTerminalType = EdgeTerminalType.none, startTerminalSize = 14, endTerminalType = EdgeTerminalType.directional, endTerminalSize = 14 } = _a2, rest = __rest(_a2, ["element", "startTerminalType", "startTerminalSize", "endTerminalType", "endTerminalSize"]);
  if (!isEdge(element)) {
    throw new Error("DefaultEdge must be used only on Edge elements");
  }
  return React428.createElement(DefaultEdgeInner, Object.assign({ element, startTerminalType, startTerminalSize, endTerminalType, endTerminalSize }, rest));
};
var DefaultEdge_default = DefaultEdge;

// node_modules/@patternfly/react-topology/dist/esm/hooks/useComponentFactory.js
var React429 = __toESM(require_react());
var useComponentFactory = (factory) => {
  const controller = useVisualizationController_default();
  React429.useEffect(() => {
    controller.registerComponentFactory(factory);
  }, [controller, factory]);
};
var useComponentFactory_default = useComponentFactory;

// node_modules/@patternfly/react-topology/dist/esm/components/factories/RegisterComponentFactory.js
var RegisterComponentFactory = ({ factory }) => {
  useComponentFactory_default(factory);
  return null;
};
var RegisterComponentFactory_default = RegisterComponentFactory;

// node_modules/@patternfly/react-topology/dist/esm/hooks/useElementFactory.js
var React430 = __toESM(require_react());
var useElementFactory = (factory) => {
  const controller = useVisualizationController_default();
  React430.useEffect(() => {
    controller.registerElementFactory(factory);
  }, [controller, factory]);
};
var useElementFactory_default = useElementFactory;

// node_modules/@patternfly/react-topology/dist/esm/components/factories/RegisterElementFactory.js
var RegisteElementFactory = ({ factory }) => {
  useElementFactory_default(factory);
  return null;
};
var RegisterElementFactory_default = RegisteElementFactory;

// node_modules/@patternfly/react-topology/dist/esm/hooks/useLayoutFactory.js
var React431 = __toESM(require_react());
var useLayoutFactory = (factory) => {
  const controller = useVisualizationController_default();
  React431.useEffect(() => {
    controller.registerLayoutFactory(factory);
  }, [controller, factory]);
};
var useLayoutFactory_default = useLayoutFactory;

// node_modules/@patternfly/react-topology/dist/esm/components/factories/RegisterLayoutFactory.js
var RegisterLayoutFactory = ({ factory }) => {
  useLayoutFactory_default(factory);
  return null;
};
var RegisterLayoutFactory_default = RegisterLayoutFactory;

// node_modules/@patternfly/react-topology/dist/esm/components/factories/components/componentUtils.js
var MOVE_CONNECTOR_DROP_TYPE = "#moveConnector#";
var NODE_DRAG_TYPE = "#node#";
var EDGE_DRAG_TYPE = "#edge#";
var MOVE_CONNECTOR_OPERATION = "moveconnector";
var REGROUP_OPERATION = "regroup";
var canDropEdgeOnNode = (operation, element, node) => {
  if (!isEdge(element)) {
    return false;
  }
  const edge = element;
  if (edge.getSource() === node) {
    return false;
  }
  if (edge.getTarget() === node) {
    return true;
  }
  return !node.getTargetEdges().find((e) => e.getSource() === edge.getSource());
};
var highlightNode = (monitor, element) => {
  const operation = monitor.getOperation();
  if (!monitor.isDragging() || !operation) {
    return false;
  }
  if (operation.type === CREATE_CONNECTOR_OPERATION) {
    return monitor.getItem() !== element && monitor.getItem().getParent() !== element && !monitor.getItem().getSourceEdges().find((e) => e.getTarget() === element);
  }
  return operation.canDropOnNode && operation.canDropOnNode(operation.type, monitor.getItem(), element);
};
var nodeDragSourceSpec = (type2, allowRegroup = true, canEdit = false) => ({
  item: { type: NODE_DRAG_TYPE },
  operation: (monitor, props) => (canEdit || props.canEdit) && allowRegroup ? {
    [Modifiers.SHIFT]: { type: REGROUP_OPERATION, edit: true }
  } : void 0,
  canCancel: (monitor) => {
    var _a2;
    return ((_a2 = monitor.getOperation()) === null || _a2 === void 0 ? void 0 : _a2.type) === REGROUP_OPERATION;
  },
  begin: (monitor, props) => ({
    element: props.element,
    allowRegroup: (canEdit || props.canEdit) && allowRegroup
  }),
  end: (dropResult, monitor, props) => __awaiter(void 0, void 0, void 0, function* () {
    var _a2;
    if (!monitor.isCancelled() && ((_a2 = monitor.getOperation()) === null || _a2 === void 0 ? void 0 : _a2.type) === REGROUP_OPERATION) {
      if (monitor.didDrop() && dropResult && props && props.element.getParent() !== dropResult) {
        const controller = props.element.getController();
        action(() => {
          if (controller.getNodeById(props.element.getId())) {
            dropResult.appendChild(props.element);
          }
        })();
      } else {
        return Promise.reject();
      }
    }
    return void 0;
  }),
  collect: (monitor) => {
    var _a2;
    return {
      dragging: monitor.isDragging(),
      regrouping: ((_a2 = monitor.getOperation()) === null || _a2 === void 0 ? void 0 : _a2.type) === REGROUP_OPERATION
    };
  }
});
var noRegroupDragSourceSpec = {
  item: { type: NODE_DRAG_TYPE },
  collect: (monitor) => ({
    dragging: monitor.isDragging()
  })
};
var nodesEdgeIsDragging = (monitor, props) => {
  if (!monitor.isDragging()) {
    return false;
  }
  if (monitor.getOperation() === MOVE_CONNECTOR_OPERATION) {
    return monitor.getItem().getSource() === props.element;
  }
  if (monitor.getOperation() === CREATE_CONNECTOR_OPERATION) {
    return monitor.getItem() === props.element;
  }
  return false;
};
var nodeDropTargetSpec = (accept) => ({
  accept: accept || [EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],
  canDrop: (item, monitor, props) => {
    var _a2;
    if (isEdge(item) && isNode(props.element)) {
      return canDropEdgeOnNode((_a2 = monitor.getOperation()) === null || _a2 === void 0 ? void 0 : _a2.type, item, props.element);
    }
    if (item === props.element || !isNode(props.element)) {
      return false;
    }
    return !props.element.getTargetEdges().find((e) => e.getSource() === item);
  },
  collect: (monitor, props) => ({
    canDrop: highlightNode(monitor, props.element),
    dropTarget: monitor.isOver({ shallow: true }),
    edgeDragging: nodesEdgeIsDragging(monitor, Object.assign(Object.assign({}, props), { element: props.element }))
  })
});
var graphDropTargetSpec = (accept) => ({
  accept: accept || [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],
  hitTest: () => true,
  canDrop: (item, monitor, props) => {
    var _a2;
    return monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) && (((_a2 = monitor.getOperation()) === null || _a2 === void 0 ? void 0 : _a2.type) === REGROUP_OPERATION && // FIXME: the hasParent check is necessary due to model updates during async actions
    item.element.hasParent() && item.element.getParent() !== props.element || monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE);
  },
  collect: (monitor) => {
    const operation = monitor.getOperation();
    const dragEditInProgress = monitor.isDragging() && ((operation === null || operation === void 0 ? void 0 : operation.type) === CREATE_CONNECTOR_OPERATION || (operation === null || operation === void 0 ? void 0 : operation.edit));
    const dragCreate = dragEditInProgress && (monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE || monitor.getItemType() === MOVE_CONNECTOR_DROP_TYPE);
    return {
      dragEditInProgress,
      dragCreate,
      hasDropTarget: dragEditInProgress && monitor.hasDropTarget()
    };
  },
  dropHint: "create"
});
var isChildOfGroup = (group2, node) => {
  var _a2;
  return (_a2 = group2 === null || group2 === void 0 ? void 0 : group2.getAllNodeChildren) === null || _a2 === void 0 ? void 0 : _a2.call(group2).map((n) => n.getId()).includes(node.getId());
};
var groupDropTargetSpec = {
  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],
  canDrop: (item, monitor, props) => {
    var _a2;
    return monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) && (((_a2 = monitor.getOperation()) === null || _a2 === void 0 ? void 0 : _a2.type) === REGROUP_OPERATION || monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE && !isChildOfGroup(props === null || props === void 0 ? void 0 : props.element, item));
  },
  collect: (monitor, props) => {
    var _a2, _b, _c;
    return {
      droppable: monitor.isDragging() && ((_a2 = monitor.getOperation()) === null || _a2 === void 0 ? void 0 : _a2.type) === REGROUP_OPERATION,
      dropTarget: monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }),
      canDrop: monitor.isDragging() && (((_b = monitor.getOperation()) === null || _b === void 0 ? void 0 : _b.type) === REGROUP_OPERATION || monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE && !isChildOfGroup(props === null || props === void 0 ? void 0 : props.element, monitor === null || monitor === void 0 ? void 0 : monitor.getItem())),
      dragRegroupable: monitor.isDragging() && ((_c = monitor.getItem()) === null || _c === void 0 ? void 0 : _c.allowRegroup),
      dropHint: "create"
    };
  }
};
var edgeDragSourceSpec = (type2, callback) => ({
  item: { type: EDGE_DRAG_TYPE },
  operation: { type: MOVE_CONNECTOR_OPERATION, edit: true, canDropOnNode: canDropEdgeOnNode },
  begin: (monitor, props) => {
    props.element.raise();
    return props.element;
  },
  drag: (event, monitor, props) => {
    props.element.setEndPoint(event.x, event.y);
  },
  end: (dropResult, monitor, props) => {
    var _a2;
    props.element.setEndPoint();
    if (monitor.didDrop() && dropResult && canDropEdgeOnNode((_a2 = monitor.getOperation()) === null || _a2 === void 0 ? void 0 : _a2.type, props.element, dropResult)) {
      callback(props.element.getSource(), dropResult, props.element.getTarget());
    }
  },
  collect: (monitor) => ({
    dragging: monitor.isDragging()
  })
});
var noDropTargetSpec = {
  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],
  canDrop: () => false
};

// node_modules/@patternfly/react-topology/dist/esm/hooks/useEventListener.js
var React432 = __toESM(require_react());
var useEventListener = (type2, listener) => {
  const controller = useVisualizationController_default();
  React432.useEffect(() => {
    controller.addEventListener(type2, listener);
    return () => {
      controller.removeEventListener(type2, listener);
    };
  }, [controller, type2, listener]);
};
var useEventListener_default = useEventListener;

// node_modules/@patternfly/react-topology/dist/esm/hooks/useModel.js
var React433 = __toESM(require_react());
var useModel = (model) => {
  const controller = useVisualizationController_default();
  React433.useEffect(() => {
    controller.fromModel(model);
  }, [controller, model]);
};
var useModel_default = useModel;

// node_modules/@patternfly/react-topology/dist/esm/hooks/useVisualizationState.js
var React434 = __toESM(require_react());
var useVisualizationState = (key, initialState) => {
  const keyRef = React434.useRef(key);
  if (keyRef.current !== key) {
    throw new Error(`State key change disallowed: ${keyRef.current} => ${key}`);
  }
  const [state, setState] = React434.useState(initialState);
  const controller = useVisualizationController_default();
  const setControllerState = React434.useCallback((value) => {
    controller.setState({ [keyRef.current]: value });
  }, [controller]);
  React434.useEffect(() => {
    setControllerState(initialState);
    return reaction(() => controller.getState()[keyRef.current], (value) => {
      setState(value);
    });
  }, [controller]);
  return [state, setControllerState];
};
var useVisualizationState_default = useVisualizationState;

// node_modules/@patternfly/react-topology/dist/esm/hooks/useDetailsLevel.js
var useDetailsLevel = () => {
  const controller = useVisualizationController_default();
  if (!controller) {
    return ScaleDetailsLevel.high;
  }
  return controller.getGraph().getDetailsLevel();
};
var useDetailsLevel_default = useDetailsLevel;

// node_modules/@patternfly/react-topology/dist/esm/hooks/useScaleNode.js
var React435 = __toESM(require_react());
var useScaleNode = (scaleNode, scale2, scaleUpTime = 200) => {
  const [nodeScale, setNodeScale] = React435.useState(1);
  const animationRef = React435.useRef();
  const scaleGoal = React435.useRef(1);
  const nodeScaled = React435.useRef(false);
  React435.useEffect(() => {
    if (!scaleNode || scale2 >= 1) {
      setNodeScale(1);
      nodeScaled.current = false;
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = 0;
      }
    } else {
      scaleGoal.current = 1 / scale2;
      const scaleDelta = scaleGoal.current - scale2;
      const initTime = performance.now();
      const bumpScale = (bumpTime) => {
        const scalePercent = (bumpTime - initTime) / scaleUpTime;
        const nextScale = Math.min(scale2 + scaleDelta * scalePercent, scaleGoal.current);
        setNodeScale(nextScale);
        if (nextScale < scaleGoal.current) {
          animationRef.current = requestAnimationFrame(bumpScale);
        } else {
          nodeScaled.current = true;
          animationRef.current = 0;
        }
      };
      if (nodeScaled.current) {
        setNodeScale(scaleGoal.current);
      } else if (!animationRef.current) {
        animationRef.current = requestAnimationFrame(bumpScale);
      }
    }
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = 0;
      }
    };
  }, [scale2, scaleNode, scaleUpTime]);
  return nodeScale;
};
var useScaleNode_default = useScaleNode;

// node_modules/@patternfly/react-topology/dist/esm/layouts/ForceSimulation.js
var ForceSimulation = class {
  constructor(options) {
    this.destroyed = false;
    this.options = Object.assign({
      collideDistance: 0,
      simulationSpeed: 10,
      chargeStrength: 0
    }, options);
    this.simulation = simulation_default();
    this.simulation.force("collide", collide_default().radius((d) => d.collisionRadius + this.options.collideDistance));
    this.simulation.force("charge", manyBody_default().strength(this.options.chargeStrength));
    this.simulation.alpha(0);
    this.forceLink = link_default().id((e) => e.id);
    this.simulation.force("link", this.forceLink);
    this.simulation.on("tick", action(() => {
      for (let i = 0; i < this.options.simulationSpeed; i++) {
        this.simulation.tick();
      }
      this.simulation.nodes().forEach((d) => !this.destroyed && d.update());
    }));
    if (options.onSimulationEnd) {
      this.simulation.on("end", this.options.onSimulationEnd);
    }
  }
  destroy() {
    this.destroyed = true;
    this.simulation.stop();
  }
  useForceSimulation(nodes, links, distance) {
    this.forceLink.distance(distance);
    this.forceLink.links([]);
    this.simulation.nodes([...nodes]);
    this.forceLink.links([...links]);
  }
  haltForceSimulation() {
    this.simulation.alpha(0);
    this.simulation.nodes([]);
    this.forceLink.links([]);
  }
  forceCenter(cx, cy) {
    this.simulation.force("center", center_default(cx, cy));
  }
  stopSimulation() {
    this.simulation.stop();
  }
  restart() {
    this.simulation.restart();
  }
  alpha(value) {
    this.simulation.alpha(value);
  }
  alphaTarget(value) {
    this.simulation.alphaTarget(value);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/LayoutNode.js
var LayoutNode = class {
  constructor(node, distance, index4 = -1) {
    this.isFixed = false;
    this.node = node;
    this.distance = distance;
    this.index = index4;
    const bounds = this.nodeBounds;
    this.nodeWidth = bounds.width + this.distance * 2;
    this.nodeHeight = bounds.height + this.distance * 2;
    this.nodeRadius = Math.max(bounds.width, bounds.height) / 2;
  }
  get element() {
    return this.node;
  }
  get id() {
    return this.node.getId();
  }
  get x() {
    return this.xx || this.node.getBounds().getCenter().x;
  }
  set x(x4) {
    if (!Number.isNaN(x4)) {
      this.xx = x4;
    }
  }
  get y() {
    return this.yy || this.node.getBounds().getCenter().y;
  }
  set y(y4) {
    if (!Number.isNaN(y4)) {
      this.yy = y4;
    }
  }
  get fx() {
    return this.isFixed ? this.node.getBounds().getCenter().x : void 0;
  }
  get fy() {
    return this.isFixed ? this.node.getBounds().getCenter().y : void 0;
  }
  setPosition(x4, y4) {
    const bounds = this.node.getBounds();
    this.node.setPosition(new Point(x4 - bounds.width / 2, y4 - bounds.height / 2));
  }
  setFixed(fixed) {
    this.isFixed = fixed;
  }
  get nodeBounds() {
    const { padding } = this.node.getStyle();
    if (!this.node.isGroup() && padding) {
      return this.node.getBounds().clone().padding(padding);
    }
    return this.node.getBounds();
  }
  get width() {
    return this.nodeWidth;
  }
  get height() {
    return this.nodeHeight;
  }
  update() {
    if (!this.isFixed && this.xx != null && this.yy != null) {
      this.setPosition(this.xx, this.yy);
    }
    this.xx = void 0;
    this.yy = void 0;
  }
  get radius() {
    return this.nodeRadius;
  }
  get collisionRadius() {
    return this.radius + this.distance;
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/LayoutGroup.js
var LayoutGroup = class {
  constructor(node, padding, index4) {
    this.leaves = [];
    this.groups = [];
    this.node = node;
    this.padding = padding;
    this.index = index4;
  }
  get element() {
    return this.node;
  }
  get id() {
    return this.node.getId();
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/LayoutLink.js
var LayoutLink = class {
  constructor(edge, source, target, isFalse = false) {
    this.edge = edge;
    this.sourceNode = source;
    this.targetNode = target;
    this.isFalse = isFalse;
  }
  get element() {
    return this.edge;
  }
  get id() {
    return this.edge.getId();
  }
  get source() {
    return this.sourceNode;
  }
  get target() {
    return this.targetNode;
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/BaseLayout.js
var LAYOUT_DEFAULTS = {
  linkDistance: 60,
  nodeDistance: 35,
  groupDistance: 35,
  collideDistance: 0,
  simulationSpeed: 10,
  chargeStrength: 0,
  allowDrag: true,
  layoutOnDrag: true
};
var BaseLayout = class {
  constructor(graph, options) {
    this.scheduleRestart = false;
    this.nodes = [];
    this.edges = [];
    this.groups = [];
    this.nodesMap = {};
    this.onSimulationEnd = () => {
    };
    this.handleDragStart = (element, event, operation) => {
      this.initDrag(element, event, operation);
      if (!this.options.layoutOnDrag) {
        return;
      }
      if (operation.type !== DRAG_MOVE_OPERATION) {
        this.forceSimulation.stopSimulation();
        return;
      }
      const id2 = element.getId();
      let found = false;
      const dragNode = this.nodes.find((node) => node.id === id2);
      if (dragNode) {
        dragNode.isFixed = true;
        found = true;
      } else {
        const dragGroup = this.groups.find((group2) => group2.id === id2);
        if (dragGroup) {
          const groupNodes = dragGroup.leaves;
          groupNodes.forEach((node) => {
            node.isFixed = true;
          });
          found = true;
        }
      }
      if (found) {
        this.forceSimulation.alphaTarget(0.1);
        this.forceSimulation.restart();
      }
    };
    this.handleDragEnd = (element, event, operation) => {
      this.endDrag(element, event, operation);
      if (!this.options.layoutOnDrag) {
        return;
      }
      if (operation.type !== DRAG_MOVE_OPERATION) {
        this.forceSimulation.restart();
        return;
      }
      const id2 = element.getId();
      const dragNode = this.nodes.find((node) => node.id === id2);
      if (dragNode) {
        dragNode.isFixed = false;
      } else {
        const dragGroup = this.groups.find((group2) => group2.id === id2);
        if (dragGroup) {
          const groupNodes = dragGroup.leaves;
          groupNodes.forEach((node) => {
            node.isFixed = false;
          });
        }
      }
      this.forceSimulation.alphaTarget(0);
    };
    this.layout = () => {
      this.stopListening();
      this.runLayout(true);
      this.startListening();
    };
    this.handleChildAdded = ({ child }) => {
      if (!this.nodesMap[child.getId()]) {
        this.scheduleRestart = true;
        this.scheduleLayout();
      }
    };
    this.handleChildRemoved = ({ child }) => {
      if (this.nodesMap[child.getId()]) {
        this.scheduleRestart = true;
        this.scheduleLayout();
      }
    };
    this.handleElementVisibilityChange = (event) => {
      if (event.visible === (this.nodesMap[event.target.getId()] === void 0)) {
        this.scheduleRestart = true;
        this.scheduleLayout();
      }
    };
    this.handleNodeCollapse = ({ node }) => {
      if (!node.isCollapsed()) {
        this.scheduleRestart = true;
        this.scheduleLayout();
      }
    };
    this.scheduleLayout = () => {
      if (!this.scheduleHandle) {
        this.scheduleHandle = requestAnimationFrame(() => {
          delete this.scheduleHandle;
          try {
            this.runLayout(false, this.scheduleRestart);
            this.scheduleRestart = false;
          } catch (e) {
          }
        });
      }
    };
    this.getFixedNodeDistance = (link3) => Math.sqrt(Math.pow(link3.sourceNode.x - link3.targetNode.x, 2) + Math.pow(link3.sourceNode.y - link3.targetNode.y, 2));
    this.initializeEdgeBendpoints = (edge) => {
      if (edge.getBendpoints().length > 0) {
        edge.setBendpoints([]);
      }
    };
    this.getLeafNodes = () => leafNodeElements(this.graph.getNodes()).filter((n) => n.isVisible());
    this.getGroupNodes = () => groupNodeElements(this.graph.getNodes()).filter((g) => g.isVisible());
    this.hasVisibleChildren = (group2) => !!group2.getNodes().find((c6) => isNode(c6) && c6.isVisible());
    makeObservable(this, { runLayout: action });
    this.graph = graph;
    this.options = Object.assign(Object.assign(Object.assign({}, LAYOUT_DEFAULTS), { onSimulationEnd: this.onSimulationEnd, listenForChanges: true }), options);
    if (this.options.allowDrag) {
      graph.getController().addEventListener(DRAG_NODE_START_EVENT, this.handleDragStart).addEventListener(DRAG_NODE_END_EVENT, this.handleDragEnd);
    }
    this.forceSimulation = new ForceSimulation(this.options);
    this.startListening();
  }
  getLayoutOptions() {
    return this.options;
  }
  destroy() {
    if (this.options.allowDrag) {
      this.graph.getController().removeEventListener(DRAG_NODE_START_EVENT, this.handleDragStart).removeEventListener(DRAG_NODE_END_EVENT, this.handleDragEnd);
    }
    this.stopListening();
    this.forceSimulation.destroy();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initDrag(element, event, operation) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  endDrag(element, event, operation) {
  }
  startListening() {
    const controller = this.graph.getController();
    if (controller && this.options.listenForChanges) {
      controller.addEventListener(ADD_CHILD_EVENT, this.handleChildAdded);
      controller.addEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);
      controller.addEventListener(ELEMENT_VISIBILITY_CHANGE_EVENT, this.handleElementVisibilityChange);
      controller.addEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);
    }
  }
  stop() {
    this.stopSimulation();
  }
  stopListening() {
    const controller = this.graph.getController();
    if (this.scheduleHandle) {
      cancelAnimationFrame(this.scheduleHandle);
    }
    if (controller) {
      controller.removeEventListener(ADD_CHILD_EVENT, this.handleChildAdded);
      controller.removeEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);
      controller.removeEventListener(ELEMENT_VISIBILITY_CHANGE_EVENT, this.handleElementVisibilityChange);
      controller.removeEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);
    }
  }
  getLayoutNode(nodes, node) {
    if (!node) {
      return void 0;
    }
    let layoutNode = nodes.find((n) => n.id === node.getId());
    if (!layoutNode && node.getNodes().length) {
      const id2 = node.getChildren()[0].getId();
      layoutNode = nodes.find((n) => n.id === id2);
    }
    if (!layoutNode) {
      layoutNode = this.getLayoutNode(nodes, getClosestVisibleParent(node));
    }
    return layoutNode;
  }
  // Faux Edges are used to layout nodes in a group together, as if they had links between them
  getFauxEdges(groups2, nodes) {
    const fauxEdges = [];
    groups2.forEach((group2) => {
      const groupNodes = group2.element.getNodes();
      for (let i = 0; i < groupNodes.length; i++) {
        for (let j = i + 1; j < groupNodes.length; j++) {
          const fauxEdge = new BaseEdge();
          const source = this.getLayoutNode(nodes, groupNodes[i]);
          const target = this.getLayoutNode(nodes, groupNodes[j]);
          if (source && target) {
            const link3 = this.createLayoutLink(fauxEdge, source, target, true);
            fauxEdge.setController(target.element.getController());
            fauxEdges.push(link3);
          }
        }
      }
    });
    return fauxEdges;
  }
  createLayoutNode(node, nodeDistance, index4) {
    return new LayoutNode(node, nodeDistance, index4);
  }
  createLayoutLink(edge, source, target, isFalse = false) {
    return new LayoutLink(edge, source, target, isFalse);
  }
  createLayoutGroup(node, padding, index4) {
    return new LayoutGroup(node, padding, index4);
  }
  getNodes(leafNodes, nodeDistance) {
    return leafNodes.map((n, index4) => this.createLayoutNode(n, nodeDistance, index4));
  }
  getLinks(edges) {
    const links = [];
    edges.forEach((e) => {
      const source = this.getLayoutNode(this.nodes, e.getSource());
      const target = this.getLayoutNode(this.nodes, e.getTarget());
      if (source && target) {
        this.initializeEdgeBendpoints(e);
        links.push(this.createLayoutLink(e, source, target));
      }
    });
    return links;
  }
  // Turn empty groups into nodes
  getNodesFromGroups(groups2, nodeDistance, nodeCount) {
    let count3 = 0;
    const groupNodes = [];
    groups2.forEach((group2) => {
      if (!this.hasVisibleChildren(group2)) {
        groupNodes.push(this.createLayoutNode(group2, nodeDistance, nodeCount + count3++));
      }
    });
    return groupNodes;
  }
  getGroups(groups2, nodes, padding) {
    let nodeIndex = 2 * nodes.length;
    const layoutGroups = groups2.filter((g) => this.hasVisibleChildren(g)).map((group2) => this.createLayoutGroup(group2, padding, nodeIndex++));
    layoutGroups.forEach((groupNode) => {
      const leaves = [];
      const leafElements = groupNode.element.getNodes().filter((node) => !node.isGroup() || !this.hasVisibleChildren(node));
      leafElements.forEach((leaf) => {
        const layoutLeaf = nodes.find((n) => n.id === leaf.getId());
        if (layoutLeaf) {
          leaves.push(layoutLeaf);
          layoutLeaf.parent = groupNode;
        }
      });
      groupNode.leaves = leaves;
      const childGroups = [];
      const groupElements = groupNode.element.getNodes().filter((node) => node.isGroup() && node.isVisible() && !node.isCollapsed());
      groupElements.forEach((group2) => {
        const layoutGroup = layoutGroups.find((g) => g.id === group2.getId());
        if (layoutGroup) {
          childGroups.push(layoutGroup);
          layoutGroup.parent = groupNode;
        }
      });
      groupNode.groups = childGroups;
    });
    return layoutGroups;
  }
  initializeNodePositions(nodes, graph, force) {
    const { width, height } = graph.getBounds();
    const cx = width / 2;
    const cy = height / 2;
    nodes.forEach((node) => {
      if (force || !node.element.isPositioned()) {
        node.setPosition(cx, cy);
      } else {
        node.setFixed(true);
      }
    });
  }
  setupLayout(graph, nodes, edges, groups2) {
  }
  stopSimulation() {
    this.forceSimulation.haltForceSimulation();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startLayout(graph, initialRun, addingNodes, onEnd) {
  }
  // Interim, remove and update startLayout to public in next breaking change build
  doStartLayout(graph, initialRun, addingNodes, onEnd) {
    return this.startLayout(graph, initialRun, addingNodes, onEnd);
  }
  updateLayout() {
    this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
    this.forceSimulation.alpha(0.2);
  }
  runLayout(initialRun, restart = true) {
    const prevGroups = this.groups;
    const leafNodes = this.getLeafNodes();
    const groups2 = this.getGroupNodes();
    this.nodes = this.getNodes(leafNodes, this.options.nodeDistance);
    const groupNodes = this.getNodesFromGroups(groups2, this.options.nodeDistance, this.nodes.length);
    if (groupNodes) {
      this.nodes.push(...groupNodes);
    }
    this.groups = this.getGroups(groups2, this.nodes, this.options.groupDistance);
    const newNodes = initialRun ? this.nodes : this.nodes.filter((node) => !this.nodesMap[node.element.getId()]);
    let addingNodes = restart && newNodes.length > 0;
    if (!initialRun && restart && !addingNodes) {
      this.groups.forEach((group2) => {
        const prevGroup = prevGroups.find((g) => g.element.getId() === group2.element.getId());
        if (!prevGroup) {
          addingNodes = true;
          newNodes.push(...group2.leaves);
        } else {
          group2.leaves.forEach((node) => {
            if (!prevGroup.leaves.find((l) => l.element.getId() === node.element.getId())) {
              newNodes.push(node);
            }
          });
        }
      });
      addingNodes = newNodes.length > 0;
    }
    this.edges = this.getLinks(this.graph.getEdges());
    this.initializeNodePositions(this.nodes, this.graph, initialRun);
    this.nodesMap = this.nodes.reduce((acc, n) => {
      acc[n.id] = n;
      return acc;
    }, {});
    this.edges.push(...this.getFauxEdges(this.groups, this.nodes));
    this.setupLayout(this.graph, this.nodes, this.edges, this.groups);
    if (initialRun || addingNodes) {
      this.stopSimulation();
      this.startLayout(this.graph, initialRun, addingNodes, () => {
        this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
      });
    } else if (restart && this.options.layoutOnDrag) {
      this.updateLayout();
    }
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/BreadthFirstNode.js
var BreadthFirstNode = class extends LayoutNode {
  constructor(node, distance, index4 = -1) {
    super(node, distance, index4);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/BreadthFirstLink.js
var BreadthFirstLink = class extends LayoutLink {
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/BreadthFirstGroup.js
var BreadthFirstGroup = class extends LayoutGroup {
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/BreadthFirstLayout.js
var BreadthFirstLayout = class extends BaseLayout {
  constructor(graph, options) {
    super(graph, options);
  }
  createLayoutNode(node, nodeDistance, index4) {
    return new BreadthFirstNode(node, nodeDistance, index4);
  }
  createLayoutLink(edge, source, target, isFalse) {
    return new BreadthFirstLink(edge, source, target, isFalse);
  }
  createLayoutGroup(node, padding, index4) {
    return new BreadthFirstGroup(node, padding, index4);
  }
  startLayout(graph, initialRun, addingNodes) {
    if (initialRun || addingNodes) {
      const visited = {};
      const processed = {};
      const roots = {};
      const targetIds = {};
      const sourceIds = {};
      let padX = 0;
      let padY = 0;
      for (const edge of this.edges) {
        if (!edge.isFalse) {
          const sourceId = edge.sourceNode.id;
          const targetId = edge.targetNode.id;
          if (!sourceIds[sourceId]) {
            sourceIds[sourceId] = [];
          }
          sourceIds[sourceId].push(targetId);
          targetIds[targetId] = true;
        }
      }
      for (const node of this.nodes) {
        const id2 = node.id;
        if (!targetIds[id2]) {
          roots[id2] = true;
        }
        if (padX < node.width) {
          padX = node.width;
        }
        if (padY < node.height) {
          padY = node.height;
        }
      }
      const levels = [];
      levels.push(Object.keys(roots));
      let nl = 0;
      while (Object.keys(visited).length < this.nodes.length) {
        const nextLevel = {};
        for (const nodeId of levels[nl]) {
          if (!visited[nodeId]) {
            if (sourceIds[nodeId]) {
              for (const childId of sourceIds[nodeId]) {
                if (!processed[childId]) {
                  nextLevel[childId] = true;
                  processed[childId] = true;
                }
              }
            }
            visited[nodeId] = true;
            processed[nodeId] = true;
          }
        }
        const nextLevelKeys = Object.keys(nextLevel);
        if (nextLevelKeys.length > 0) {
          levels.push(nextLevelKeys);
        }
        nl++;
      }
      let x4 = 0;
      let y4 = 0;
      for (const level of levels) {
        const sortedLevel = level.sort((a4, b) => a4.localeCompare(b));
        for (const nodeId of sortedLevel) {
          const node = this.nodesMap[nodeId];
          node.x = x4;
          node.y = y4;
          node.update();
          x4 += padX;
        }
        y4 += padY;
        x4 = 0;
      }
    }
    this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ColaLayout.js
var webcola = __toESM(require_dist());

// node_modules/@patternfly/react-topology/dist/esm/layouts/ColaNode.js
var ColaNode = class extends LayoutNode {
  constructor(node, distance, index4 = -1) {
    super(node, distance, index4);
    this.fixed = 0;
    const maxDimension = Math.max(this.nodeWidth, this.nodeHeight);
    this.nodeWidth = maxDimension;
    this.nodeHeight = maxDimension;
  }
  setFixed(fixed) {
    super.setFixed(fixed);
    this.fixed = fixed ? 1 : 0;
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ColaGroup.js
var ColaGroup = class extends LayoutGroup {
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ColaLink.js
var ColaLink = class extends LayoutLink {
  constructor(edge, source, target) {
    super(edge, source, target);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ColaLayout.js
var COLA_LAYOUT_DEFAULTS = {
  maxTicks: 1e3,
  initialUnconstrainedIterations: 200,
  initialUserConstraintIterations: 50,
  initialAllConstraintsIterations: 150,
  gridSnapIterations: 10
};
var ColaLayout = class extends BaseLayout {
  constructor(graph, options) {
    var _a2;
    super(graph, options);
    this.tickCount = 0;
    this.destroyed = false;
    this.simulationRunning = false;
    this.simulationStopped = false;
    this.restartOnEnd = void 0;
    this.addingNodes = false;
    this.handleLayoutEnd = () => {
      if (this.onEnd) {
        this.onEnd();
        this.onEnd = void 0;
      }
    };
    this.onSimulationEnd = () => {
      if (this.addingNodes) {
        if (!this.options.layoutOnDrag) {
          this.forceSimulation.stopSimulation();
        }
        this.addingNodes = false;
      }
      this.handleLayoutEnd();
    };
    this.colaOptions = Object.assign(Object.assign({}, COLA_LAYOUT_DEFAULTS), options);
    this.forceSimulation = new ForceSimulation(Object.assign(Object.assign({}, this.options), { onSimulationEnd: (_a2 = options === null || options === void 0 ? void 0 : options.onSimulationEnd) !== null && _a2 !== void 0 ? _a2 : this.onSimulationEnd }));
    this.initializeLayout();
  }
  initializeLayout() {
    this.d3Cola = webcola.d3adaptor(src_exports);
    this.d3Cola.handleDisconnected(true);
    this.d3Cola.avoidOverlaps(true);
    this.d3Cola.on("tick", () => {
      this.tickCount++;
      if (this.tickCount >= 1 || this.tickCount % this.options.simulationSpeed === 0) {
        action(() => this.nodes.forEach((d) => d.update()))();
      }
      if (this.colaOptions.maxTicks >= 0 && this.tickCount > this.colaOptions.maxTicks) {
        this.d3Cola.stop();
      }
    });
    this.d3Cola.on("end", () => {
      this.tickCount = 0;
      this.simulationRunning = false;
      action(() => {
        if (this.destroyed) {
          this.handleLayoutEnd();
          return;
        }
        this.nodes.forEach((d) => {
          if (!this.simulationStopped) {
            d.update();
          }
          d.setFixed(false);
        });
        if (this.options.layoutOnDrag) {
          this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
        }
        if (this.simulationStopped) {
          this.simulationStopped = false;
          if (this.restartOnEnd !== void 0) {
            this.startColaLayout(false, this.restartOnEnd);
            delete this.restartOnEnd;
          } else {
            this.handleLayoutEnd();
          }
        } else if (this.addingNodes) {
          this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
          this.forceSimulation.restart();
        } else {
          this.handleLayoutEnd();
        }
      })();
    });
  }
  destroy() {
    super.destroy();
    this.destroyed = true;
    if (this.d3Cola) {
      this.d3Cola.stop();
    }
  }
  initDrag() {
    if (this.d3Cola) {
      this.d3Cola.alpha(0);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getConstraints(nodes, groups2, edges) {
    return [];
  }
  stopSimulation() {
    if (this.simulationRunning) {
      this.simulationStopped = true;
      if (this.d3Cola) {
        this.d3Cola.stop();
      }
    }
    super.stopSimulation();
  }
  createLayoutNode(node, nodeDistance, index4) {
    return new ColaNode(node, nodeDistance, index4);
  }
  createLayoutLink(edge, source, target) {
    return new ColaLink(edge, source, target);
  }
  createLayoutGroup(node, padding, index4) {
    return new ColaGroup(node, padding, index4);
  }
  getFauxEdges() {
    return [];
  }
  setupLayout(graph, nodes, edges, groups2) {
    const { width, height } = graph.getBounds();
    this.d3Cola.size([width, height]);
    this.d3Cola.constraints(this.getConstraints(nodes, groups2, edges));
    this.d3Cola.nodes(nodes);
    this.d3Cola.links(edges);
    this.d3Cola.groups(groups2);
  }
  startColaLayout(initialRun, addingNodes) {
    this.simulationRunning = true;
    this.d3Cola.alpha(0.2);
    this.tickCount = 0;
    this.addingNodes = addingNodes;
    this.d3Cola.start(addingNodes ? 0 : this.colaOptions.initialUnconstrainedIterations, addingNodes ? 0 : this.colaOptions.initialUserConstraintIterations, addingNodes ? 0 : this.colaOptions.initialAllConstraintsIterations, addingNodes ? 0 : this.colaOptions.gridSnapIterations, false, !addingNodes);
  }
  startLayout(graph, initialRun, addingNodes, onEnd) {
    this.onEnd = onEnd;
    if (!this.simulationStopped) {
      this.startColaLayout(initialRun, addingNodes);
    } else {
      this.restartOnEnd = addingNodes;
    }
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ColaGroupsLayout.js
var webcola2 = __toESM(require_dist());

// node_modules/@patternfly/react-topology/dist/esm/layouts/ColaGroupsNode.js
var ColaGroupsNode = class extends LayoutNode {
  constructor(node, distance, index4 = -1) {
    super(node, distance, index4);
    this.fixed = 0;
  }
  setFixed(fixed) {
    super.setFixed(fixed);
    this.fixed = fixed ? 1 : 0;
  }
  update() {
    if (!this.isFixed && this.xx != null && this.yy != null) {
      if (this.node.isGroup()) {
        const prevLocation = this.node.getBounds().getCenter();
        const xOffset = this.xx - prevLocation.x;
        const yOffset = this.yy - prevLocation.y;
        this.node.getChildren().forEach((child) => {
          if (isNode(child)) {
            const node = child;
            const position = node.getPosition();
            node.setPosition(new Point(position.x + xOffset, position.y + yOffset));
          }
        });
      } else {
        this.setPosition(this.xx, this.yy);
      }
    }
    this.xx = void 0;
    this.yy = void 0;
  }
  get width() {
    return this.nodeBounds.width + this.distance * 2;
  }
  get height() {
    return this.nodeBounds.height + this.distance * 2;
  }
  get radius() {
    const bounds = this.nodeBounds;
    return Math.max(bounds.width, bounds.height) / 2;
  }
  get collisionRadius() {
    return this.radius + this.distance;
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ColaGroupsLayout.js
var ColaGroupsLayout = class _ColaGroupsLayout extends ColaLayout {
  initializeLayout() {
  }
  initializeColaGroupLayout(graph) {
    this.d3Cola = webcola2.d3adaptor(src_exports);
    this.d3Cola.handleDisconnected(true);
    this.d3Cola.avoidOverlaps(true);
    this.d3Cola.jaccardLinkLengths(40, 0.7);
    this.d3Cola.on("tick", () => {
      this.tickCount++;
      if (this.tickCount >= 1 || this.tickCount % this.options.simulationSpeed === 0) {
        action(() => this.nodes.forEach((d) => d.update()))();
      }
      if (this.colaOptions.maxTicks >= 0 && this.tickCount > this.colaOptions.maxTicks) {
        this.d3Cola.stop();
      }
    });
    this.d3Cola.on("end", () => {
      this.tickCount = 0;
      this.simulationRunning = false;
      action(() => {
        if (this.destroyed) {
          this.handleLayoutEnd();
          return;
        }
        this.layoutNodes.forEach((d) => {
          if (!this.simulationStopped) {
            d.update();
          }
          d.setFixed(false);
        });
        if (this.options.layoutOnDrag) {
          this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
        }
        if (this.simulationStopped) {
          this.simulationStopped = false;
          if (this.restartOnEnd !== void 0) {
            this.startColaLayout(false, this.restartOnEnd);
            this.startLayout(graph, false, this.restartOnEnd, this.handleLayoutEnd);
            delete this.restartOnEnd;
          } else {
            this.handleLayoutEnd();
          }
        } else if (this.addingNodes) {
          this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
          this.forceSimulation.restart();
        } else {
          this.handleLayoutEnd();
        }
      })();
    });
  }
  stopSimulation() {
    super.stopSimulation();
    this.childLayouts.forEach((layout3) => layout3.stop());
  }
  createLayoutNode(node, nodeDistance, index4) {
    return new ColaGroupsNode(node, nodeDistance, index4);
  }
  getAllLeaves(group2) {
    var _a2;
    const leaves = [...group2.leaves];
    (_a2 = group2.groups) === null || _a2 === void 0 ? void 0 : _a2.forEach((subGroup) => leaves.push(...this.getAllLeaves(subGroup)));
    return leaves;
  }
  getAllSubGroups(group2) {
    var _a2;
    const groups2 = [...group2.groups];
    (_a2 = group2.groups) === null || _a2 === void 0 ? void 0 : _a2.forEach((subGroup) => groups2.push(...this.getAllSubGroups(subGroup)));
    return groups2;
  }
  isNodeInGroups(node, groups2) {
    return !!groups2.find((group2) => group2.leaves.includes(node) || this.isNodeInGroups(node, group2.groups));
  }
  isNodeInChildGroups(node, groups2) {
    return !!groups2.find((group2) => group2.nodes.includes(node) || this.isNodeInGroups(node, group2.groups));
  }
  isSubGroup(group2, childGroups) {
    return !!childGroups.find((cg) => cg.groups.includes(group2.group));
  }
  getNodeGroup(node, childGroups) {
    return childGroups.find((group2) => group2.nodes.includes(node) || this.isNodeInGroups(node, group2.groups));
  }
  getGroupLayout(graph, group2, nodes, edges, groups2) {
    const layout3 = new _ColaGroupsLayout(graph, Object.assign(Object.assign({}, this.options), { onSimulationEnd: void 0, listenForChanges: false }));
    layout3.setupLayout(graph, nodes, edges, groups2);
    return layout3;
  }
  setupLayout(graph, nodes, edges, groups2) {
    const constraints = this.getConstraints(nodes, groups2, edges);
    let childGroups = groups2.reduce((acc, group2) => {
      if (!groups2.find((g) => {
        var _a2;
        return ((_a2 = group2.element.getParent()) === null || _a2 === void 0 ? void 0 : _a2.getId()) === g.element.getId();
      }) && (group2.groups.length || group2.leaves.length)) {
        const allLeaves = this.getAllLeaves(group2);
        const groupEdges = edges.filter((edge) => allLeaves.includes(edge.sourceNode) && allLeaves.includes(edge.target));
        const groupGroups = this.getAllSubGroups(group2);
        allLeaves.forEach((l, i) => {
          l.index = i;
          if (l.parent && !groupGroups.includes(l.parent)) {
            l.parent = void 0;
          }
        });
        groupGroups.forEach((g, i) => {
          g.index = 2 * allLeaves.length + i;
          g.parent = void 0;
        });
        acc.push({
          group: group2,
          nodes: allLeaves,
          edges: groupEdges,
          groups: groupGroups
        });
      }
      return acc;
    }, []);
    const constrainedGroups = groups2.filter((g) => constraints.find((c6) => c6.group === g.element.getId()));
    this.layerGroups = childGroups.filter((cg) => constrainedGroups.includes(cg.group)).map((cg) => cg.group);
    childGroups = childGroups.filter((cg) => !this.layerGroups.includes(cg.group));
    this.layerNodes = nodes.filter((node) => !this.isNodeInChildGroups(node, childGroups));
    this.layerGroupNodes = childGroups.filter((cg) => !this.isSubGroup(cg, childGroups));
    this.layerEdges = edges.reduce((acc, edge) => {
      const source = this.getNodeGroup(edge.sourceNode, childGroups);
      const target = this.getNodeGroup(edge.targetNode, childGroups);
      if (!source || !target || source !== target) {
        acc.push(edge);
      }
      return acc;
    }, []);
    this.childLayouts = childGroups.map((childGroup) => this.getGroupLayout(graph, childGroup.group, childGroup.nodes, childGroup.edges, childGroup.groups));
  }
  startChildLayout(graph, childLayout, initialRun, addingNodes) {
    return new Promise((resolve) => {
      childLayout.doStartLayout(graph, initialRun, addingNodes, () => {
        resolve();
      });
    });
  }
  startColaLayout(initialRun, addingNodes) {
    var _a2;
    this.simulationRunning = true;
    this.tickCount = 0;
    this.addingNodes = addingNodes;
    const doStart = () => {
      this.initializeColaGroupLayout(this.graph);
      const { width, height } = this.graph.getBounds();
      this.d3Cola.size([width, height]);
      this.layoutNodes = [...this.layerNodes];
      this.layerGroupNodes.forEach((cg) => {
        const layoutNode = this.createLayoutNode(cg.group.element, this.options.nodeDistance, cg.group.index);
        this.layoutNodes.push(layoutNode);
        this.layerEdges.forEach((edge) => {
          if (cg.nodes.find((n) => n.id === edge.sourceNode.id) || this.isNodeInGroups(edge.sourceNode, cg.groups)) {
            edge.sourceNode = layoutNode;
          }
          if (cg.nodes.find((n) => n.id === edge.targetNode.id) || this.isNodeInGroups(edge.targetNode, cg.groups)) {
            edge.targetNode = layoutNode;
          }
        });
      });
      const constraints = this.getConstraints(this.layoutNodes, this.layerGroups, this.layerEdges);
      this.d3Cola.constraints(constraints);
      this.d3Cola.nodes(this.layoutNodes);
      this.d3Cola.groups(this.layerGroups);
      this.d3Cola.links(this.layerEdges);
      this.d3Cola.alpha(0.2);
      this.d3Cola.start(addingNodes ? 0 : this.colaOptions.initialUnconstrainedIterations, addingNodes ? 0 : this.colaOptions.initialUserConstraintIterations, addingNodes ? 0 : this.colaOptions.initialAllConstraintsIterations, addingNodes ? 0 : this.colaOptions.gridSnapIterations, false, !addingNodes);
    };
    if ((_a2 = this.childLayouts) === null || _a2 === void 0 ? void 0 : _a2.length) {
      const runLayouts = (childLayouts) => Promise.all(childLayouts.map((childLayout) => this.startChildLayout(this.graph, childLayout, initialRun, addingNodes)));
      runLayouts(this.childLayouts).then(() => {
        doStart();
      }).catch(() => {
      });
      return;
    }
    doStart();
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ConcentricNode.js
var ConcentricNode = class extends LayoutNode {
  constructor(node, distance, index4 = -1) {
    super(node, distance, index4);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ConcentricLink.js
var ConcentricLink = class extends LayoutLink {
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ConcentricGroup.js
var ConcentricGroup = class extends LayoutGroup {
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ConcentricLayout.js
var ConcentricLayout = class extends BaseLayout {
  constructor(graph, options) {
    super(graph, options);
    this.concentricOptions = Object.assign(Object.assign({}, this.options), options);
  }
  createLayoutNode(node, nodeDistance, index4) {
    return new ConcentricNode(node, nodeDistance, index4);
  }
  createLayoutLink(edge, source, target, isFalse) {
    return new ConcentricLink(edge, source, target, isFalse);
  }
  createLayoutGroup(node, padding, index4) {
    return new ConcentricGroup(node, padding, index4);
  }
  startLayout(graph, initialRun, addingNodes) {
    if (initialRun || addingNodes) {
      const weights = {};
      this.nodes.forEach((node) => {
        weights[node.id] = { in: 0, out: 0, total: 0 };
      });
      this.edges.forEach((edge) => {
        weights[edge.target.id].in++;
        weights[edge.target.id].total++;
        weights[edge.source.id].out++;
        weights[edge.source.id].total++;
      });
      const nodesWeight = Object.keys(weights).map((k2) => ({ id: k2, total: weights[k2].total }));
      nodesWeight.sort((a4, b) => b.total - a4.total);
      const splitLevel = this.concentricOptions.splitLevel ? this.concentricOptions.splitLevel : 4;
      const levelWidth = nodesWeight.length > 0 ? nodesWeight[0].total / splitLevel : 0;
      const levels = [[]];
      let currentLevel = levels[0];
      nodesWeight.forEach((n) => {
        if (currentLevel.length > 0) {
          const diff = Math.abs(currentLevel[0].total - n.total);
          if (diff >= levelWidth) {
            currentLevel = [];
            levels.push(currentLevel);
          }
        }
        currentLevel.push(n);
      });
      let innerR = 0;
      let maxWH = 0;
      const padding = maxWH;
      if (levels.length > 0) {
        let maxWidth = 0;
        let maxHeight = 0;
        levels[0].forEach((n) => {
          const node = this.nodesMap[n.id];
          if (maxWidth < node.width) {
            maxWidth = node.width;
          }
          if (maxHeight < node.height) {
            maxHeight = node.height;
          }
        });
        maxWH = Math.max(maxWidth, maxHeight);
        innerR = Math.round(levels[0].length * maxWH / (2 * Math.PI));
      }
      const outerR = levels.length * (maxWH + padding) + innerR;
      const center2 = {
        x: outerR + maxWH,
        y: outerR + maxWH
      };
      let r = innerR;
      for (const level of levels) {
        const theta = 2 * Math.PI / level.length;
        for (let j = 0; j < level.length; j++) {
          const node = this.nodesMap[level[j].id];
          node.x = center2.x + r * Math.cos(theta * j);
          node.y = center2.y + r * Math.sin(theta * j);
          node.update();
        }
        r += maxWH + padding;
      }
    }
    this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/DagreLayout.js
var dagre = __toESM(require_dagre());

// node_modules/@patternfly/react-topology/dist/esm/layouts/DagreNode.js
var DagreNode = class extends LayoutNode {
  getUpdatableNode() {
    return {
      width: this.width,
      height: this.height,
      x: this.x,
      y: this.y
    };
  }
  updateToNode(updatedNode) {
    if (updatedNode) {
      this.x = updatedNode.x;
      this.y = updatedNode.y;
      this.update();
    }
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/DagreGroup.js
var DagreGroup = class extends LayoutGroup {
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/DagreLink.js
var DagreLink = class extends LayoutLink {
  updateBendpoints() {
    if (this.points && !this.isFalse && this.points.length > 2) {
      this.element.setBendpoints(this.points.slice(1, -1).map((point7) => new Point(point7.x, point7.y)));
    }
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/DagreLayout.js
var TOP_TO_BOTTOM = "TB";
var LEFT_TO_RIGHT = "LR";
var DagreLayout = class extends BaseLayout {
  constructor(graph, options) {
    super(graph, options);
    this.dagreOptions = Object.assign(Object.assign(Object.assign({}, this.options), { layoutOnDrag: false, marginx: 0, marginy: 0, nodesep: this.options.nodeDistance, edgesep: this.options.linkDistance, ranker: "tight-tree", rankdir: TOP_TO_BOTTOM }), options);
  }
  createLayoutNode(node, nodeDistance, index4) {
    return new DagreNode(node, nodeDistance, index4);
  }
  createLayoutLink(edge, source, target, isFalse) {
    return new DagreLink(edge, source, target, isFalse);
  }
  createLayoutGroup(node, padding, index4) {
    return new DagreGroup(node, padding, index4);
  }
  updateEdgeBendpoints(edges) {
    edges.forEach((edge) => {
      const link3 = edge;
      link3.updateBendpoints();
    });
  }
  getFauxEdges() {
    return [];
  }
  startLayout(graph, initialRun, addingNodes) {
    var _a2, _b;
    if (initialRun || addingNodes) {
      const dagreGraph = new dagre.graphlib.Graph({ compound: true });
      const options = Object.assign({}, this.dagreOptions);
      Object.keys(LAYOUT_DEFAULTS).forEach((key) => delete options[key]);
      dagreGraph.setGraph(options);
      if (!this.dagreOptions.ignoreGroups) {
        this.groups.forEach((group2) => {
          dagreGraph.setNode(group2.id, group2);
          dagreGraph.setParent(group2.id, group2.element.getParent().getId());
        });
      }
      (_a2 = this.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach((node) => {
        const updateNode = node.getUpdatableNode();
        dagreGraph.setNode(node.id, updateNode);
        if (!this.dagreOptions.ignoreGroups) {
          dagreGraph.setParent(node.id, node.element.getParent().getId());
        }
      });
      (_b = this.edges) === null || _b === void 0 ? void 0 : _b.forEach((dagreEdge) => {
        dagreGraph.setEdge(dagreEdge.source.id, dagreEdge.target.id, dagreEdge);
      });
      dagre.layout(dagreGraph);
      this.nodes.forEach((node) => {
        node.updateToNode(dagreGraph.node(node.id));
      });
      this.updateEdgeBendpoints(this.edges);
    }
    if (this.dagreOptions.layoutOnDrag) {
      this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
    } else {
      this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
    }
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/DagreGroupsLayout.js
var dagre2 = __toESM(require_dagre());
var DagreGroupsLayout = class extends BaseLayout {
  constructor(graph, options) {
    super(graph, options);
    this.dagreOptions = Object.assign(Object.assign(Object.assign({}, this.options), { layoutOnDrag: false, marginx: 0, marginy: 0, nodesep: this.options.nodeDistance, edgesep: this.options.linkDistance, rankdir: LEFT_TO_RIGHT, ranker: "tight-tree" }), options);
  }
  createLayoutNode(node, nodeDistance, index4) {
    return new DagreNode(node, nodeDistance, index4);
  }
  createLayoutLink(edge, source, target, isFalse = false) {
    return new DagreLink(edge, source, target, isFalse);
  }
  updateEdgeBendpoints(edges) {
    edges.forEach((edge) => {
      const link3 = edge;
      link3.updateBendpoints();
    });
  }
  getFauxEdges() {
    return [];
  }
  getAllLeaves(group2) {
    var _a2;
    const leaves = [...group2.leaves];
    (_a2 = group2.groups) === null || _a2 === void 0 ? void 0 : _a2.forEach((subGroup) => leaves.push(...this.getAllLeaves(subGroup)));
    return leaves;
  }
  getAllSubGroups(group2) {
    var _a2;
    const groups2 = [...group2.groups];
    (_a2 = group2.groups) === null || _a2 === void 0 ? void 0 : _a2.forEach((subGroup) => groups2.push(...this.getAllSubGroups(subGroup)));
    return groups2;
  }
  isNodeInGroups(node, groups2) {
    return !!groups2.find((group2) => group2.leaves.includes(node) || this.isNodeInGroups(node, group2.groups));
  }
  getEdgeLayoutNode(nodes, groups2, node) {
    if (!node) {
      return void 0;
    }
    let layoutNode = nodes.find((n) => n.id === node.getId());
    if (!layoutNode) {
      const groupNode = groups2.find((n) => n.id === node.getId());
      if (groupNode) {
        const dagreNode = new DagreNode(groupNode.element, groupNode.padding);
        if (dagreNode) {
          return dagreNode;
        }
      }
    }
    if (!layoutNode && node.getNodes().length) {
      const id2 = node.getChildren()[0].getId();
      layoutNode = nodes.find((n) => n.id === id2);
    }
    if (!layoutNode) {
      layoutNode = this.getEdgeLayoutNode(nodes, groups2, getClosestVisibleParent(node));
    }
    return layoutNode;
  }
  getLinks(edges) {
    const links = [];
    edges.forEach((e) => {
      const source = this.getEdgeLayoutNode(this.nodes, this.groups, e.getSource());
      const target = this.getEdgeLayoutNode(this.nodes, this.groups, e.getTarget());
      if (source && target) {
        this.initializeEdgeBendpoints(e);
        links.push(this.createLayoutLink(e, source, target));
      }
    });
    return links;
  }
  startLayout(graph, initialRun, addingNodes) {
    if (initialRun || addingNodes) {
      const doLayout = (parentGroup) => {
        const dagreGraph = new dagre2.graphlib.Graph({ compound: true });
        const options = Object.assign({}, this.dagreOptions);
        Object.keys(LAYOUT_DEFAULTS).forEach((key) => delete options[key]);
        dagreGraph.setGraph(options);
        const layerGroups = this.groups.filter((group2) => {
          var _a2, _b;
          return ((_a2 = group2.parent) === null || _a2 === void 0 ? void 0 : _a2.id) === (parentGroup === null || parentGroup === void 0 ? void 0 : parentGroup.id) || !parentGroup && ((_b = group2.parent) === null || _b === void 0 ? void 0 : _b.id) === graph.getId();
        });
        const layerNodes = this.nodes.filter((n) => {
          var _a2, _b;
          return ((_a2 = n.element.getParent()) === null || _a2 === void 0 ? void 0 : _a2.getId()) === (parentGroup === null || parentGroup === void 0 ? void 0 : parentGroup.id) || !parentGroup && ((_b = n.element.getParent()) === null || _b === void 0 ? void 0 : _b.getId()) === graph.getId();
        });
        const layerEdges = this.edges.filter((edge) => (layerGroups.find((n) => n.id === edge.sourceNode.id) || layerNodes.find((n) => n.id === edge.sourceNode.id)) && (layerGroups.find((n) => n.id === edge.targetNode.id) || layerNodes.find((n) => n.id === edge.targetNode.id)));
        layerGroups.forEach((group2) => {
          doLayout(group2);
          const dagreNode = new DagreNode(group2.element, group2.padding);
          const updateNode = dagreNode.getUpdatableNode();
          dagreGraph.setNode(group2.id, updateNode);
        });
        layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.forEach((node) => {
          const updateNode = node.getUpdatableNode();
          dagreGraph.setNode(node.id, updateNode);
        });
        layerEdges === null || layerEdges === void 0 ? void 0 : layerEdges.forEach((dagreEdge) => {
          dagreGraph.setEdge(dagreEdge.source.id, dagreEdge.target.id, dagreEdge);
        });
        dagre2.layout(dagreGraph);
        layerNodes.forEach((node) => {
          node.updateToNode(dagreGraph.node(node.id));
        });
        layerGroups.forEach((node) => {
          const dagreNode = dagreGraph.node(node.id);
          node.element.setPosition(new Point(dagreNode.x, dagreNode.y));
        });
        this.updateEdgeBendpoints(this.edges);
        if (parentGroup) {
          parentGroup.element.setDimensions(getGroupChildrenDimensions(parentGroup.element));
        }
      };
      doLayout();
    }
    if (this.dagreOptions.layoutOnDrag) {
      this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
    } else {
      this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
    }
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/ForceLayout.js
var ForceLayout = class extends BaseLayout {
  constructor(graph, options) {
    super(graph, Object.assign(Object.assign({}, options), { layoutOnDrag: true, onSimulationEnd: () => {
      this.nodes.forEach((n) => n.setFixed(false));
      this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
    } }));
    this.getLinkDistance = (e) => {
      let distance = this.options.linkDistance + e.source.radius + e.target.radius;
      const isFalse = e instanceof LayoutLink && e.isFalse;
      if (!isFalse && e.source.element.getParent() !== e.target.element.getParent()) {
        distance += getGroupPadding(e.source.element.getParent());
        distance += getGroupPadding(e.target.element.getParent());
      }
      return distance;
    };
  }
  startLayout(graph) {
    const { width, height } = graph.getBounds();
    const cx = width / 2;
    const cy = height / 2;
    this.forceSimulation.forceCenter(cx, cy);
    this.forceSimulation.alpha(1);
    this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getLinkDistance);
    this.forceSimulation.restart();
  }
  updateLayout() {
    this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
    this.forceSimulation.alpha(0.2);
    this.forceSimulation.restart();
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/GridNode.js
var GridNode = class extends LayoutNode {
  constructor(node, distance, index4 = -1) {
    super(node, distance, index4);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/GridLink.js
var GridLink = class extends LayoutLink {
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/GridGroup.js
var GridGroup = class extends LayoutGroup {
};

// node_modules/@patternfly/react-topology/dist/esm/layouts/GridLayout.js
var GridLayout = class extends BaseLayout {
  constructor(graph, options) {
    super(graph, options);
  }
  createLayoutNode(node, nodeDistance, index4) {
    return new GridNode(node, nodeDistance, index4);
  }
  createLayoutLink(edge, source, target, isFalse) {
    return new GridLink(edge, source, target, isFalse);
  }
  createLayoutGroup(node, padding, index4) {
    return new GridGroup(node, padding, index4);
  }
  startLayout(graph, initialRun, addingNodes) {
    if (initialRun || addingNodes) {
      this.nodes.sort((a4, b) => a4.id.localeCompare(b.id));
      const totalNodes = this.nodes.length;
      const maxPerRow = Math.round(Math.sqrt(totalNodes));
      let x4 = 0;
      let y4 = 0;
      let rowI = 0;
      let padX = 0;
      let padY = 0;
      for (let i = 0; i < totalNodes; i++) {
        const node = this.nodes[i];
        if (padX < node.width) {
          padX = node.width;
        }
        if (padY < node.height) {
          padY = node.height;
        }
      }
      for (let i = 0; i < totalNodes; i++) {
        const node = this.nodes[i];
        node.x = x4;
        node.y = y4;
        node.update();
        if (rowI < maxPerRow) {
          x4 += padX;
          rowI++;
        } else {
          rowI = 0;
          x4 = 0;
          y4 += padY;
        }
      }
    }
    this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });
  }
};

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/anchors/TaskNodeSourceAnchor.js
var TaskNodeSourceAnchor = class extends AbstractAnchor {
  constructor(owner, detailsLevel, lowDetailsStatusIconSize, vertical = false) {
    super(owner);
    this.lowDetailsStatusIconSize = 0;
    this.vertical = false;
    this.detailsLevel = detailsLevel;
    this.lowDetailsStatusIconSize = lowDetailsStatusIconSize;
    this.vertical = vertical;
  }
  getLocation() {
    return this.getReferencePoint();
  }
  getReferencePoint() {
    const bounds = this.owner.getBounds();
    if (this.detailsLevel !== ScaleDetailsLevel.high) {
      const nodeSize = this.lowDetailsStatusIconSize / this.owner.getGraph().getScale();
      if (this.vertical) {
        return new Point(bounds.x + bounds.width / 2, bounds.y + nodeSize);
      }
      return new Point(bounds.x + nodeSize, bounds.y + bounds.height / 2);
    }
    if (this.vertical) {
      return new Point(bounds.x + bounds.width / 2, bounds.bottom());
    }
    return new Point(bounds.right(), bounds.y + bounds.height / 2);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/anchors/TaskNodeTargetAnchor.js
var TaskNodeTargetAnchor = class extends AbstractAnchor {
  constructor(owner, whenOffset, detailsLevel = ScaleDetailsLevel.high, lowDetailsStatusIconSize = 0, vertical = false) {
    super(owner);
    this.whenOffset = 0;
    this.lowDetailsStatusIconSize = 0;
    this.vertical = false;
    this.whenOffset = whenOffset;
    this.detailsLevel = detailsLevel;
    this.lowDetailsStatusIconSize = lowDetailsStatusIconSize;
    this.vertical = vertical;
  }
  getLocation() {
    return this.getReferencePoint();
  }
  getReferencePoint() {
    const bounds = this.owner.getBounds();
    if (this.vertical) {
      if (this.detailsLevel !== ScaleDetailsLevel.high) {
        return new Point(bounds.x + bounds.width / 2, bounds.y);
      }
      return new Point(bounds.x + bounds.width / 2, bounds.y - this.whenOffset);
    }
    return new Point(bounds.x, bounds.y + bounds.height / 2);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/anchors/TaskGroupSourceAnchor.js
var TaskGroupSourceAnchor = class extends AbstractAnchor {
  constructor(owner, vertical = true, offset3 = 0) {
    super(owner);
    this.vertical = false;
    this.anchorOffset = 0;
    this.vertical = vertical;
    this.anchorOffset = offset3;
  }
  getLocation() {
    return this.getReferencePoint();
  }
  getReferencePoint() {
    const bounds = this.owner.getBounds();
    if (this.vertical) {
      return new Point(bounds.x + bounds.width / 2, bounds.bottom() + this.anchorOffset);
    }
    return new Point(bounds.right() + this.anchorOffset, bounds.y + bounds.height / 2);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/anchors/TaskGroupTargetAnchor.js
var TaskGroupTargetAnchor = class extends AbstractAnchor {
  constructor(owner, vertical = false, offset3 = 0) {
    super(owner);
    this.vertical = false;
    this.anchorOffset = 0;
    this.vertical = vertical;
    this.anchorOffset = offset3;
  }
  getLocation() {
    return this.getReferencePoint();
  }
  getReferencePoint() {
    const bounds = this.owner.getBounds();
    if (this.vertical) {
      return new Point(bounds.x + bounds.width / 2, bounds.y - this.anchorOffset);
    }
    return new Point(bounds.x - this.anchorOffset, bounds.y + bounds.height / 2);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/nodes/FinallyNode.js
var React439 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/nodes/TaskNode.js
var React438 = __toESM(require_react());
var import_topology_pipelines4 = __toESM(require_topology_pipelines());

// node_modules/@patternfly/react-topology/dist/esm/pipelines/types.js
var RunStatus;
(function(RunStatus2) {
  RunStatus2["Succeeded"] = "Succeeded";
  RunStatus2["Failed"] = "Failed";
  RunStatus2["Running"] = "Running";
  RunStatus2["InProgress"] = "InProgress";
  RunStatus2["FailedToStart"] = "FailedToStart";
  RunStatus2["Skipped"] = "Skipped";
  RunStatus2["Cancelled"] = "Cancelled";
  RunStatus2["Pending"] = "Pending";
  RunStatus2["Idle"] = "Idle";
})(RunStatus || (RunStatus = {}));
var WhenStatus;
(function(WhenStatus2) {
  WhenStatus2["Met"] = "Met";
  WhenStatus2["Unmet"] = "Unmet";
  WhenStatus2["Pending"] = "Pending";
  WhenStatus2["InProgress"] = "InProgress";
})(WhenStatus || (WhenStatus = {}));

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/nodes/TaskPill.js
var React437 = __toESM(require_react());
var import_topology_pipelines3 = __toESM(require_topology_pipelines());
var import_topology_components30 = __toESM(require_topology_components());

// node_modules/@patternfly/react-topology/dist/esm/pipelines/const.js
var NODE_SEPARATION_HORIZONTAL = 70;
var NODE_SEPARATION_VERTICAL = 35;
var DrawDesign;
(function(DrawDesign2) {
  DrawDesign2["INTEGRAL_SHAPE"] = "integral-shape";
  DrawDesign2["STRAIGHT"] = "line";
})(DrawDesign || (DrawDesign = {}));
var DEFAULT_TASK_NODE_TYPE = "DEFAULT_TASK_NODE";
var DEFAULT_SPACER_NODE_TYPE = "DEFAULT_SPACER_NODE";
var DEFAULT_EDGE_TYPE = "DEFAULT_EDGE";
var DEFAULT_FINALLY_NODE_TYPE = "DEFAULT_FINALLY_NODE";
var DEFAULT_FINALLY_EDGE_TYPE = "DEFAULT_FINALLY_EDGE";

// node_modules/@patternfly/react-topology/dist/esm/pipelines/utils/draw-utils.js
var join = (...segments) => segments.filter((seg) => !!seg).join(" ");
var leftRight = (p1, p2) => p1.x < p2.x;
var topDown = (p1, p2) => p1.y < p2.y;
var bottomUp = (p1, p2) => p1.y > p2.y;
var point6 = (p) => `${p.x},${p.y}`;
var moveTo = (p) => `M ${point6(p)}`;
var lineTo = (p) => `L ${point6(p)}`;
var quadTo = (corner, end2) => `Q ${point6(corner)} ${point6(end2)}`;
var CURVE_SIZE = { x: 8, y: 10 };
var curve = (fromPoint, cornerPoint, toPoint, curveSize = CURVE_SIZE) => {
  const topToBottom = topDown(fromPoint, toPoint);
  if (topToBottom) {
    const rightAndDown = leftRight(fromPoint, cornerPoint) && topDown(cornerPoint, toPoint);
    const downAndRight = topDown(fromPoint, cornerPoint) && leftRight(cornerPoint, toPoint);
    if (rightAndDown) {
      return join(lineTo(cornerPoint.clone().translate(-curveSize.x, 0)), quadTo(cornerPoint, cornerPoint.clone().translate(0, curveSize.y)));
    }
    if (downAndRight) {
      return join(lineTo(cornerPoint.clone().translate(0, -curveSize.y)), quadTo(cornerPoint, cornerPoint.clone().translate(curveSize.x, 0)));
    }
  } else {
    const rightAndUp = leftRight(fromPoint, cornerPoint) && bottomUp(cornerPoint, toPoint);
    const upAndRight = bottomUp(fromPoint, cornerPoint) && leftRight(cornerPoint, toPoint);
    if (rightAndUp) {
      return join(lineTo(cornerPoint.clone().translate(-curveSize.x, 0)), quadTo(cornerPoint, cornerPoint.clone().translate(0, -curveSize.y)));
    }
    if (upAndRight) {
      return join(lineTo(cornerPoint.clone().translate(0, curveSize.y)), quadTo(cornerPoint, cornerPoint.clone().translate(curveSize.x, 0)));
    }
  }
  return "";
};
var curveVertical = (fromPoint, cornerPoint, toPoint, curveSize = CURVE_SIZE) => {
  const leftToRight = leftRight(fromPoint, toPoint);
  if (leftToRight) {
    const rightAndDown = leftRight(fromPoint, cornerPoint) && topDown(cornerPoint, toPoint);
    const downAndRight = topDown(fromPoint, cornerPoint) && leftRight(cornerPoint, toPoint);
    if (rightAndDown) {
      return join(lineTo(cornerPoint.clone().translate(-curveSize.x, 0)), quadTo(cornerPoint, cornerPoint.clone().translate(0, curveSize.y)));
    }
    if (downAndRight) {
      return join(lineTo(cornerPoint.clone().translate(0, -curveSize.y)), quadTo(cornerPoint, cornerPoint.clone().translate(curveSize.x, 0)));
    }
  } else {
    const leftAndDown = leftRight(toPoint, cornerPoint) && bottomUp(cornerPoint, fromPoint);
    const downAndLeft = bottomUp(toPoint, cornerPoint) && leftRight(cornerPoint, fromPoint);
    if (leftAndDown) {
      return join(lineTo(cornerPoint.clone().translate(0, -curveSize.y)), quadTo(cornerPoint, cornerPoint.clone().translate(-curveSize.x, 0)));
    }
    if (downAndLeft) {
      return join(lineTo(cornerPoint.clone().translate(curveSize.x, 0)), quadTo(cornerPoint, cornerPoint.clone().translate(0, curveSize.y)));
    }
  }
  return "";
};
var straightPath = (start3, finish) => join(moveTo(start3), lineTo(finish));
var integralShapePath = (start3, finish, startIndentX = 0, nodeSeparation = NODE_SEPARATION_HORIZONTAL, verticalLayout = false) => {
  let firstCurve = null;
  let secondCurve = null;
  if (verticalLayout) {
    if (start3.x !== finish.x) {
      const cornerY = Math.floor(start3.y + nodeSeparation / 2);
      const firstCorner = new Point(start3.x, cornerY);
      const secondCorner = new Point(finish.x, cornerY);
      if (Math.abs(start3.x - finish.x) > CURVE_SIZE.x) {
        firstCurve = curveVertical(start3, firstCorner, secondCorner);
        secondCurve = curveVertical(firstCorner, secondCorner, finish);
      } else {
        firstCurve = curveVertical(start3, firstCorner, finish, {
          x: Math.abs(start3.x - finish.x),
          y: CURVE_SIZE.y
        });
      }
    }
  } else if (start3.y !== finish.y) {
    const cornerX = Math.floor(start3.x + nodeSeparation / 2);
    const firstCorner = new Point(cornerX, start3.y);
    const secondCorner = new Point(cornerX, finish.y);
    if (Math.abs(start3.y - finish.y) > CURVE_SIZE.y) {
      firstCurve = curve(start3, firstCorner, secondCorner);
      secondCurve = curve(firstCorner, secondCorner, finish);
    } else {
      firstCurve = curve(start3, firstCorner, finish, { x: CURVE_SIZE.x, y: Math.abs(start3.y - finish.y) });
    }
  }
  const indentedStart = new Point(start3.x - startIndentX, start3.y);
  return join(moveTo(indentedStart), firstCurve, secondCurve, lineTo(finish));
};
var path2 = (start3, finish, drawDesign) => {
  switch (drawDesign) {
    case DrawDesign.INTEGRAL_SHAPE:
      return integralShapePath(start3, finish);
    case DrawDesign.STRAIGHT:
    default:
      return straightPath(start3, finish);
  }
};

// node_modules/@patternfly/react-topology/dist/esm/pipelines/utils/utils.js
var import_topology_pipelines2 = __toESM(require_topology_pipelines());
var nonShadowModifiers = [
  import_topology_pipelines2.default.modifiers.danger,
  import_topology_pipelines2.default.modifiers.warning,
  import_topology_pipelines2.default.modifiers.success,
  import_topology_pipelines2.default.modifiers.skipped,
  import_topology_pipelines2.default.modifiers.inProgress
];
var getRunStatusModifier = (status) => {
  switch (status) {
    case RunStatus.Failed:
    case RunStatus.FailedToStart:
      return import_topology_pipelines2.default.modifiers.danger;
    case RunStatus.Succeeded:
      return import_topology_pipelines2.default.modifiers.success;
    case RunStatus.Cancelled:
      return import_topology_pipelines2.default.modifiers.warning;
    case RunStatus.Skipped:
      return import_topology_pipelines2.default.modifiers.skipped;
    case RunStatus.Running:
      return import_topology_pipelines2.default.modifiers.running;
    case RunStatus.InProgress:
      return import_topology_pipelines2.default.modifiers.inProgress;
    case RunStatus.Pending:
      return import_topology_pipelines2.default.modifiers.pending;
    case RunStatus.Idle:
      return import_topology_pipelines2.default.modifiers.idle;
    default:
      return "";
  }
};
var getWhenStatusModifier = (status) => {
  switch (status) {
    case WhenStatus.Met:
      return import_topology_pipelines2.default.modifiers.success;
    case WhenStatus.Unmet:
      return import_topology_pipelines2.default.modifiers.unmet;
    case WhenStatus.InProgress:
    case WhenStatus.Pending:
      return import_topology_pipelines2.default.modifiers.inProgress;
    default:
      return "";
  }
};
var getSpacerId = (ids) => [...ids].sort((a4, b) => a4.localeCompare(b)).reduce((acc, ref) => {
  if (acc) {
    return `${acc}|${ref}`;
  }
  return ref;
}, "");
var nodeVisible = (node, nodes) => {
  const parentNode = nodes.find((n) => {
    var _a2;
    return (_a2 = n.children) === null || _a2 === void 0 ? void 0 : _a2.includes(node.id);
  });
  if (!parentNode) {
    return true;
  }
  if (parentNode.collapsed) {
    return false;
  }
  return nodeVisible(parentNode, nodes);
};
var getSpacerNodes = (nodes, spacerNodeType = DEFAULT_SPACER_NODE_TYPE, finallyNodeTypes = [DEFAULT_FINALLY_NODE_TYPE]) => {
  const finallyNodes = nodes.filter((n) => finallyNodeTypes.includes(n.type) && nodeVisible(n, nodes));
  const multipleRunBeforeMap = nodes.reduce((acc, node) => {
    const { runAfterTasks } = node;
    if (runAfterTasks && runAfterTasks.length > 1) {
      const id2 = getSpacerId(runAfterTasks);
      if (!Array.isArray(acc[id2])) {
        acc[id2] = [];
      }
      acc[id2].push(node);
    }
    return acc;
  }, {});
  const multiParallelToParallelList = Object.keys(multipleRunBeforeMap).reduce((acc, key) => {
    if (multipleRunBeforeMap[key].length > 1) {
      acc[key] = multipleRunBeforeMap[key];
    }
    return acc;
  }, {});
  const spacerNodes = [];
  Object.keys(multiParallelToParallelList).forEach((key) => {
    spacerNodes.push({
      id: key,
      type: spacerNodeType,
      width: 1,
      height: 1
    });
  });
  if (finallyNodes.length > 1) {
    const finallyId = getSpacerId(finallyNodes.map((n) => n.id));
    spacerNodes.push({
      id: finallyId,
      type: spacerNodeType,
      width: 1,
      height: 1
    });
  }
  return spacerNodes;
};
var addSpacerNodes = (nodes, addSpacersToGroups = true, spacerNodeType = DEFAULT_SPACER_NODE_TYPE, finallyNodeTypes = [DEFAULT_FINALLY_NODE_TYPE]) => {
  const spacerNodes = getSpacerNodes(nodes, spacerNodeType, finallyNodeTypes);
  const newNodes = [...nodes, ...spacerNodes];
  if (addSpacersToGroups) {
    spacerNodes.forEach((spacerNode) => {
      var _a2;
      const nodeIds = spacerNode.id.split("|");
      if (nodeIds[0]) {
        const parent = newNodes.find((n) => {
          var _a3;
          return (_a3 = n.children) === null || _a3 === void 0 ? void 0 : _a3.includes(nodeIds[0]);
        });
        if (parent) {
          (_a2 = parent.children) === null || _a2 === void 0 ? void 0 : _a2.push(spacerNode.id);
        }
      }
    });
  }
  return newNodes;
};
var getEdgesFromNodes = (nodes, spacerNodeType = DEFAULT_SPACER_NODE_TYPE, edgeType = DEFAULT_EDGE_TYPE, spacerEdgeType = DEFAULT_EDGE_TYPE, finallyNodeTypes = [DEFAULT_FINALLY_NODE_TYPE], finallyEdgeType = DEFAULT_EDGE_TYPE) => {
  const edges = [];
  const visibleNodes = nodes.filter((n) => nodeVisible(n, nodes));
  const spacerNodes = visibleNodes.filter((n) => n.type === spacerNodeType);
  const taskNodes = visibleNodes.filter((n) => n.type !== spacerNodeType);
  const finallyNodes = visibleNodes.filter((n) => finallyNodeTypes.includes(n.type));
  const lastTasks = visibleNodes.filter((n) => !finallyNodeTypes.includes(n.type)).filter((n) => spacerNodeType !== n.type).filter((t) => !visibleNodes.find((n) => {
    var _a2;
    return (_a2 = n.runAfterTasks) === null || _a2 === void 0 ? void 0 : _a2.includes(t.id);
  }));
  spacerNodes.forEach((spacer) => {
    const sourceIds = spacer.id.split("|");
    sourceIds.forEach((sourceId) => {
      const node = visibleNodes.find((n) => n.id === sourceId);
      if (node && !finallyNodes.includes(node)) {
        edges.push({
          id: `${sourceId}-${spacer.id}`,
          type: spacerEdgeType,
          source: sourceId,
          target: spacer.id
        });
      }
    });
  });
  taskNodes.forEach((node) => {
    if (node.runAfterTasks) {
      const spacerId = getSpacerId([...node.runAfterTasks]);
      const spacer = spacerNodes.find((n) => n.id === spacerId);
      if (spacer) {
        edges.push({
          id: `${spacer.id}-${node.id}`,
          type: spacerEdgeType,
          source: spacer.id,
          target: node.id
        });
      } else if (node.runAfterTasks) {
        node.runAfterTasks.forEach((afterId) => {
          edges.push({
            id: `${afterId}-${node.id}`,
            type: edgeType,
            source: afterId,
            target: node.id
          });
        });
      }
    }
  });
  if (finallyNodes.length > 1) {
    const finallyId = getSpacerId(finallyNodes.map((n) => n.id));
    finallyNodes.forEach((finallyNode) => {
      edges.push({
        id: `${finallyId}-${finallyNode.id}`,
        type: finallyEdgeType,
        source: finallyId,
        target: finallyNode.id
      });
    });
    lastTasks.forEach((lastTaskNode) => {
      edges.push({
        id: `${lastTaskNode.id}-${finallyId}`,
        type: spacerEdgeType,
        source: lastTaskNode.id,
        target: finallyId
      });
    });
  }
  if (finallyNodes.length === 1) {
    lastTasks.forEach((lastTaskNode) => {
      edges.push({
        id: `finallyId-${lastTaskNode.id}-${finallyNodes[0].id}`,
        type: finallyEdgeType,
        source: lastTaskNode.id,
        target: finallyNodes[0].id
      });
    });
  }
  return edges;
};

// node_modules/@patternfly/react-topology/dist/esm/pipelines/utils/StatusIcon.js
var React436 = __toESM(require_react());

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/angle-double-right-icon.js
var AngleDoubleRightIconConfig2 = {
  name: "AngleDoubleRightIcon",
  height: 512,
  width: 448,
  svgPath: "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34zm192-34l-136-136c-9.4-9.4-24.6-9.4-33.9 0l-22.6 22.6c-9.4 9.4-9.4 24.6 0 33.9l96.4 96.4-96.4 96.4c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l136-136c9.4-9.2 9.4-24.4 0-33.8z",
  yOffset: 0,
  xOffset: 0
};
var AngleDoubleRightIcon2 = createIcon2(AngleDoubleRightIconConfig2);
var angle_double_right_icon_default2 = AngleDoubleRightIcon2;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/circle-icon.js
var CircleIconConfig = {
  name: "CircleIcon",
  height: 512,
  width: 512,
  svgPath: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z",
  yOffset: 0,
  xOffset: 0
};
var CircleIcon = createIcon2(CircleIconConfig);
var circle_icon_default = CircleIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/not-started-icon.js
var NotStartedIconConfig = {
  name: "NotStartedIcon",
  height: 1024,
  width: 1024,
  svgPath: "M512.096,-0.032 C794.336,-0.032 1024.032,229.728 1024.032,511.968 C1024.032,794.336 794.336,1023.968 512.096,1023.968 C229.664,1023.968 0.032,794.336 0.032,511.968 C0.032,229.728 229.664,-0.032 512.096,-0.032 Z M512.096,127.904 C300.32,127.904 128.096,300.192 128.096,511.904 C128.096,723.808 300.32,895.904 512.096,895.904 C723.808,895.904 896.096,723.744 896.096,511.904 C896.032,300.192 723.808,127.904 512.096,127.904 Z M264,432 C308.18278,432 344,467.81722 344,512 C344,556.18278 308.18278,592 264,592 C219.81722,592 184,556.18278 184,512 C184,467.81722 219.81722,432 264,432 Z M513,432 C557.18278,432 593,467.81722 593,512 C593,556.18278 557.18278,592 513,592 C468.81722,592 433,556.18278 433,512 C433,467.81722 468.81722,432 513,432 Z M761,432 C805.18278,432 841,467.81722 841,512 C841,556.18278 805.18278,592 761,592 C716.81722,592 681,556.18278 681,512 C681,467.81722 716.81722,432 761,432 Z",
  yOffset: 0,
  xOffset: 0
};
var NotStartedIcon = createIcon2(NotStartedIconConfig);
var not_started_icon_default = NotStartedIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/hourglass-half-icon.js
var HourglassHalfIconConfig = {
  name: "HourglassHalfIcon",
  height: 512,
  width: 384,
  svgPath: "M360 0H24C10.745 0 0 10.745 0 24v16c0 13.255 10.745 24 24 24 0 90.965 51.016 167.734 120.842 192C75.016 280.266 24 357.035 24 448c-13.255 0-24 10.745-24 24v16c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24v-16c0-13.255-10.745-24-24-24 0-90.965-51.016-167.734-120.842-192C308.984 231.734 360 154.965 360 64c13.255 0 24-10.745 24-24V24c0-13.255-10.745-24-24-24zm-75.078 384H99.08c17.059-46.797 52.096-80 92.92-80 40.821 0 75.862 33.196 92.922 80zm.019-256H99.078C91.988 108.548 88 86.748 88 64h208c0 22.805-3.987 44.587-11.059 64z",
  yOffset: 0,
  xOffset: 0
};
var HourglassHalfIcon = createIcon2(HourglassHalfIconConfig);
var hourglass_half_icon_default = HourglassHalfIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/sync-alt-icon.js
var SyncAltIconConfig = {
  name: "SyncAltIcon",
  height: 512,
  width: 512,
  svgPath: "M370.72 133.28C339.458 104.008 298.888 87.962 255.848 88c-77.458.068-144.328 53.178-162.791 126.85-1.344 5.363-6.122 9.15-11.651 9.15H24.103c-7.498 0-13.194-6.807-11.807-14.176C33.933 94.924 134.813 8 256 8c66.448 0 126.791 26.136 171.315 68.685L463.03 40.97C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.749zM32 296h134.059c21.382 0 32.09 25.851 16.971 40.971l-41.75 41.75c31.262 29.273 71.835 45.319 114.876 45.28 77.418-.07 144.315-53.144 162.787-126.849 1.344-5.363 6.122-9.15 11.651-9.15h57.304c7.498 0 13.194 6.807 11.807 14.176C478.067 417.076 377.187 504 256 504c-66.448 0-126.791-26.136-171.315-68.685L48.97 471.03C33.851 486.149 8 475.441 8 454.059V320c0-13.255 10.745-24 24-24z",
  yOffset: 0,
  xOffset: 0
};
var SyncAltIcon = createIcon2(SyncAltIconConfig);
var sync_alt_icon_default = SyncAltIcon;

// node_modules/@patternfly/react-topology/node_modules/@patternfly/react-icons/dist/esm/icons/in-progress-icon.js
var InProgressIconConfig2 = {
  name: "InProgressIcon",
  height: 1024,
  width: 1024,
  svgPath: "M513.417211,16.013668 L513.417211,112.013668 C513.406007,120.539653 520.082422,127.576718 528.597211,128.013668 C732.697211,136.513668 896.147211,305.013668 896.147211,511.343668 C896.147211,723.013668 724.007211,895.163668 512.417211,895.163668 C437.186239,895.277345 363.602574,873.135095 300.927211,831.523668 C294.58293,827.2982 286.138663,828.135095 280.747211,833.523668 L211.807211,902.353668 C208.502935,905.676185 206.82123,910.280199 207.20607,914.950237 C207.590911,919.620275 210.00361,923.886884 213.807211,926.623668 C300.709573,989.398037 405.213535,1023.13146 512.417211,1023.01398 C794.537211,1023.01398 1023.91724,793.433668 1023.91724,511.413668 C1024.00721,235.103668 804.007211,9.22366802 529.897211,0.00645736761 C525.571205,-0.116171039 521.377128,1.51204372 518.271915,4.52681369 C515.166702,7.54158367 513.415263,11.6857144 513.417211,16.013668 M97.1272107,212.923668 C64.2190689,258.479443 39.0698895,309.162997 22.6972107,362.923668 C21.2705092,367.756559 22.2039184,372.979173 25.2163356,377.018685 C28.2287528,381.058197 32.9681443,383.442545 38.0072107,383.453683 L139.407211,383.453683 C145.970195,383.46249 151.873012,379.462528 154.297211,373.363668 C164.307669,347.593304 177.068112,322.977652 192.357211,299.943668 C196.579666,293.633658 195.741339,285.216847 190.357211,279.863668 L121.497211,211.013668 C118.186635,207.662531 113.567544,205.940538 108.871166,206.30669 C104.174788,206.672841 99.8783994,209.089927 97.1272107,212.913668 M112.907211,511.433663 L17.0072107,511.433663 C12.679257,511.433663 8.5351263,513.183159 5.52035633,516.288373 C2.50558635,519.393586 0.877371594,523.587662 1.00721065,527.913668 C4.13104542,629.408217 37.6085847,727.635936 97.1172107,809.913668 C99.8539943,813.717268 104.120603,816.129968 108.790642,816.514809 C113.46068,816.899649 118.064693,815.217944 121.387211,811.913668 L190.217211,743.073668 C195.605784,737.682216 196.442679,729.237949 192.217211,722.893668 C153.520825,664.580171 131.611534,596.745437 128.887211,526.813668 C128.553964,518.220138 121.487197,511.427209 112.887211,511.433663",
  yOffset: 0,
  xOffset: 0
};
var InProgressIcon2 = createIcon2(InProgressIconConfig2);
var in_progress_icon_default2 = InProgressIcon2;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/utils/StatusIcon.js
var StatusIcon = (_a2) => {
  var { status } = _a2, props = __rest(_a2, ["status"]);
  switch (status) {
    case RunStatus.InProgress:
      return React436.createElement(in_progress_icon_default2, Object.assign({}, props));
    case RunStatus.Running:
      return React436.createElement(sync_alt_icon_default, Object.assign({}, props));
    case RunStatus.Succeeded:
      return React436.createElement(check_circle_icon_default2, Object.assign({}, props));
    case RunStatus.Failed:
    case RunStatus.FailedToStart:
      return React436.createElement(exclamation_circle_icon_default2, Object.assign({}, props));
    case RunStatus.Idle:
      return React436.createElement(not_started_icon_default, Object.assign({}, props));
    case RunStatus.Pending:
      return React436.createElement(hourglass_half_icon_default, Object.assign({}, props));
    case RunStatus.Cancelled:
      return React436.createElement(exclamation_triangle_icon_default2, Object.assign({}, props));
    case RunStatus.Skipped:
      return React436.createElement(angle_double_right_icon_default2, Object.assign({}, props));
    default:
      return React436.createElement(circle_icon_default, Object.assign({}, props));
  }
};
var StatusIcon_default = StatusIcon;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/nodes/TaskPill.js
var STATUS_ICON_SIZE = 16;
var TaskPill = observer2(({ element, taskRef, pillRef, className, width = 0, paddingX = 8, paddingY = 8, status, statusIconSize = STATUS_ICON_SIZE, showStatusState = true, scaleNode, hideDetailsAtMedium, hiddenDetailsShownStatuses = [RunStatus.Failed, RunStatus.FailedToStart, RunStatus.Cancelled], leadIcon, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName = import_topology_pipelines3.default.topologyPipelinesPillBadge, badgeTooltip, badgePopoverParams, nameLabelClass, taskIconClass, taskIcon, taskIconTooltip, taskIconPadding = 4, hover, truncateLength = 14, disableTooltip = false, selected, onSelect, onContextMenu, contextMenuOpen, actionIcon, actionIconClassName, onActionIconClick, shadowCount = 0, shadowOffset = 8, children: children2, x: x4, y: y4 }) => {
  var _a2, _b, _c, _d, _e, _f, _g;
  const [hovered] = useHover_default();
  const taskIconComponentRef = React437.useRef();
  const isHover = hover !== void 0 ? hover : hovered;
  const label = truncateMiddle(element.getLabel(), { length: truncateLength, omission: "..." });
  const [textSize, textRef] = useSize([label, className]);
  const nameLabelTriggerRef = React437.useRef();
  const nameLabelRef = useCombineRefs_default(textRef, nameLabelTriggerRef);
  const [statusSize, statusRef] = useSize([status, showStatusState, statusIconSize]);
  const [leadSize, leadIconRef] = useSize([leadIcon]);
  const [badgeSize, badgeRef] = useSize([badge]);
  const badgeLabelTriggerRef = React437.useRef();
  const [actionSize, actionRef] = useSize([actionIcon, paddingX]);
  const [contextSize, contextRef] = useSize([onContextMenu, paddingX]);
  const detailsLevel = element.getGraph().getDetailsLevel();
  const verticalLayout = ((_c = (_b = (_a2 = element.getGraph()).getLayoutOptions) === null || _b === void 0 ? void 0 : _b.call(_a2)) === null || _c === void 0 ? void 0 : _c.rankdir) === TOP_TO_BOTTOM;
  const textWidth = (_d = textSize === null || textSize === void 0 ? void 0 : textSize.width) !== null && _d !== void 0 ? _d : 0;
  const textHeight = (_e = textSize === null || textSize === void 0 ? void 0 : textSize.height) !== null && _e !== void 0 ? _e : 0;
  const { height, statusStartX, textStartX, actionStartX, contextStartX, pillWidth, badgeStartX, iconWidth, iconStartX, leadIconStartX, offsetX } = React437.useMemo(() => {
    if (!textSize) {
      return {
        height: 0,
        statusStartX: 0,
        textStartX: 0,
        actionStartX: 0,
        contextStartX: 0,
        pillWidth: 0,
        badgeStartX: 0,
        iconWidth: 0,
        iconStartX: 0,
        leadIconStartX: 0,
        offsetX: 0
      };
    }
    const height2 = textHeight + 2 * paddingY;
    const startX = paddingX + paddingX / 2;
    const iconWidth2 = taskIconClass || taskIcon ? height2 - taskIconPadding : 0;
    const iconStartX2 = -(iconWidth2 * 0.75);
    const statusStartX2 = startX - statusIconSize / 4;
    const statusSpace = status && showStatusState && statusSize ? statusSize.width + paddingX : 0;
    const leadIconStartX2 = startX + statusSpace;
    const leadIconSpace = leadIcon ? leadSize.width + paddingX : 0;
    const textStartX2 = leadIconStartX2 + leadIconSpace;
    const textSpace = textWidth + paddingX;
    const badgeStartX2 = textStartX2 + textSpace;
    const badgeSpace = badge && badgeSize ? badgeSize.width + paddingX : 0;
    const actionStartX2 = badgeStartX2 + badgeSpace;
    const actionSpace = actionIcon && actionSize ? actionSize.width + paddingX : 0;
    const contextStartX2 = actionStartX2 + actionSpace;
    const contextSpace = onContextMenu && contextSize ? contextSize.width + paddingX / 2 : 0;
    const pillWidth2 = contextStartX2 + contextSpace + paddingX / 2;
    const offsetX2 = verticalLayout ? (width - pillWidth2) / 2 : 0;
    return {
      height: height2,
      statusStartX: statusStartX2,
      textStartX: textStartX2,
      actionStartX: actionStartX2,
      contextStartX: contextStartX2,
      badgeStartX: badgeStartX2,
      iconWidth: iconWidth2,
      iconStartX: iconStartX2,
      leadIconStartX: leadIconStartX2,
      pillWidth: pillWidth2,
      offsetX: offsetX2
    };
  }, [
    textSize,
    textHeight,
    textWidth,
    paddingY,
    paddingX,
    taskIconClass,
    taskIcon,
    taskIconPadding,
    statusIconSize,
    status,
    showStatusState,
    leadSize,
    leadIcon,
    statusSize,
    badgeSize,
    badge,
    actionIcon,
    actionSize,
    onContextMenu,
    contextSize,
    verticalLayout,
    width
  ]);
  const scale2 = element.getGraph().getScale();
  const nameLabel = React437.createElement("text", { x: offsetX, ref: nameLabelRef, className: css2(nameLabelClass, import_topology_pipelines3.default.topologyPipelinesPillText), dominantBaseline: "middle" }, label);
  const runStatusModifier = getRunStatusModifier(status);
  const pillClasses = css2(import_topology_pipelines3.default.topologyPipelinesPill, className, isHover && import_topology_pipelines3.default.modifiers.hover, runStatusModifier, selected && import_topology_pipelines3.default.modifiers.selected, onSelect && import_topology_pipelines3.default.modifiers.selectable);
  const pillUpdatedRef = React437.useCallback(
    (node) => {
      pillRef(node);
    },
    // dependencies causing the pill rect to resize
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [pillClasses, width, height]
  );
  let filter3;
  if (runStatusModifier === import_topology_pipelines3.default.modifiers.danger) {
    filter3 = createSvgIdUrl(NODE_SHADOW_FILTER_ID_DANGER);
  } else if (isHover && !nonShadowModifiers.includes(runStatusModifier)) {
    filter3 = createSvgIdUrl(NODE_SHADOW_FILTER_ID_HOVER);
  }
  const taskIconComponent = (taskIconClass || taskIcon) && React437.createElement(LabelIcon_default, { x: offsetX + iconStartX + iconWidth, y: (height - iconWidth) / 2, width: iconWidth, height: iconWidth, iconClass: taskIconClass, icon: taskIcon, padding: taskIconPadding, innerRef: taskIconComponentRef });
  const badgeLabel = badge ? React437.createElement(LabelBadge_default, { ref: badgeRef, innerRef: badgeLabelTriggerRef, x: offsetX + badgeStartX, y: (height - ((_f = badgeSize === null || badgeSize === void 0 ? void 0 : badgeSize.height) !== null && _f !== void 0 ? _f : 0)) / 2, badge, badgeClassName, badgeColor, badgeTextColor, badgeBorderColor }) : null;
  let badgeComponent;
  if (badgeLabel && badgeTooltip) {
    badgeComponent = React437.createElement(Tooltip, { triggerRef: badgeLabelTriggerRef, content: badgeTooltip }, badgeLabel);
  } else if (badgeLabel && badgePopoverParams) {
    badgeComponent = React437.createElement(
      "g",
      { onClick: (e) => e.stopPropagation() },
      React437.createElement(Popover, Object.assign({ triggerRef: badgeLabelTriggerRef }, badgePopoverParams), badgeLabel)
    );
  } else {
    badgeComponent = badgeLabel;
  }
  if (showStatusState && !scaleNode && hideDetailsAtMedium && detailsLevel !== ScaleDetailsLevel.high) {
    const statusBackgroundRadius = statusIconSize / 2 + 4;
    const upScale = 1 / scale2;
    const { height: boundsHeight } = element.getBounds();
    const translateX2 = verticalLayout ? width / 2 - statusBackgroundRadius * upScale : 0;
    const translateY2 = verticalLayout ? 0 : (boundsHeight - statusBackgroundRadius * 2 * upScale) / 2;
    return React437.createElement(
      "g",
      { transform: `translate(${translateX2}, ${translateY2}) scale(${upScale})`, ref: taskRef },
      React437.createElement("circle", { className: css2(import_topology_pipelines3.default.topologyPipelinesStatusIconBackground, import_topology_pipelines3.default.topologyPipelinesPillStatus, runStatusModifier, selected && "pf-m-selected"), cx: statusBackgroundRadius, cy: statusBackgroundRadius, r: statusBackgroundRadius }),
      status && (!hiddenDetailsShownStatuses || hiddenDetailsShownStatuses.includes(status)) ? React437.createElement(
        "g",
        { transform: `translate(4, 4)` },
        React437.createElement(
          "g",
          { className: css2(import_topology_pipelines3.default.topologyPipelinesStatusIcon, runStatusModifier, selected && "pf-m-selected", (status === RunStatus.Running || status === RunStatus.InProgress) && import_topology_pipelines3.default.modifiers.spin) },
          React437.createElement(StatusIcon_default, { status })
        )
      ) : null
    );
  }
  const shadows = [];
  for (let i = shadowCount; i > 0; i--) {
    shadows.push(React437.createElement("rect", { key: `shadow-offset-${i}`, x: offsetX + shadowOffset * i, y: 0, width: pillWidth, height, rx: height / 2, className: css2(import_topology_components30.default.topologyNodeBackground, "pf-m-disabled"), filter: filter3 }));
  }
  return React437.createElement(
    "g",
    { className: pillClasses, transform: `translate(${x4},${y4})`, onClick: onSelect, onContextMenu, ref: taskRef },
    React437.createElement(NodeShadows_default, null),
    shadows,
    React437.createElement("rect", { x: offsetX, y: 0, width: pillWidth, ref: pillUpdatedRef, height, rx: height / 2, className: css2(import_topology_pipelines3.default.topologyPipelinesPillBackground), filter: filter3 }),
    React437.createElement("g", { transform: `translate(${textStartX}, ${paddingY + textHeight / 2 + 1})` }, element.getLabel() !== label && !disableTooltip ? React437.createElement(
      Tooltip,
      { triggerRef: nameLabelTriggerRef, content: element.getLabel() },
      React437.createElement("g", null, nameLabel)
    ) : nameLabel),
    status && showStatusState && React437.createElement(
      "g",
      { transform: `translate(${offsetX + statusStartX + paddingX / 2}, ${(height - statusIconSize) / 2})`, ref: statusRef },
      React437.createElement(
        "g",
        { className: css2(import_topology_pipelines3.default.topologyPipelinesPillStatus, runStatusModifier, selected && "pf-m-selected", (status === RunStatus.Running || status === RunStatus.InProgress) && import_topology_pipelines3.default.modifiers.spin) },
        React437.createElement(StatusIcon_default, { status })
      )
    ),
    leadIcon && React437.createElement("g", { transform: `translate(${offsetX + leadIconStartX}, ${((_g = height - (leadSize === null || leadSize === void 0 ? void 0 : leadSize.height)) !== null && _g !== void 0 ? _g : 0) / 2})`, ref: leadIconRef }, leadIcon),
    taskIconComponent && (taskIconTooltip ? React437.createElement(Tooltip, { triggerRef: taskIconComponentRef, content: taskIconTooltip }, taskIconComponent) : taskIconComponent),
    badgeComponent,
    actionIcon && React437.createElement(
      React437.Fragment,
      null,
      React437.createElement("line", { className: css2(import_topology_components30.default.topologyNodeSeparator), x1: offsetX + actionStartX, y1: 0, x2: offsetX + actionStartX, y2: height, shapeRendering: "crispEdges" }),
      React437.createElement(LabelActionIcon_default, { ref: actionRef, x: offsetX + actionStartX, y: 0, height, paddingX, paddingY: 0, icon: actionIcon, className: actionIconClassName, onClick: onActionIconClick })
    ),
    textSize && onContextMenu && React437.createElement(
      React437.Fragment,
      null,
      React437.createElement("line", { className: css2(import_topology_components30.default.topologyNodeSeparator), x1: offsetX + contextStartX, y1: 0, x2: offsetX + contextStartX, y2: height, shapeRendering: "crispEdges" }),
      React437.createElement(LabelContextMenu_default, { ref: contextRef, x: offsetX + contextStartX, y: 0, height, paddingX, paddingY: 0, onContextMenu, contextMenuOpen })
    ),
    children2
  );
});
var TaskPill_default = TaskPill;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/nodes/TaskNode.js
var STATUS_ICON_SIZE2 = 16;
var SCALE_UP_TIME2 = 200;
var TaskNodeInner = observer2((_a2) => {
  var _b, _c, _d;
  var { element, className, statusIconSize = STATUS_ICON_SIZE2, scaleNode, toolTip, toolTipProps, disableTooltip = false, whenSize = 0, whenOffset = 0 } = _a2, rest = __rest(_a2, ["element", "className", "statusIconSize", "scaleNode", "toolTip", "toolTipProps", "disableTooltip", "whenSize", "whenOffset"]);
  const [hovered, hoverRef] = useHover_default();
  const taskRef = React438.useRef();
  const [pillSize, pillRef] = useSize();
  const pillWidth = (pillSize === null || pillSize === void 0 ? void 0 : pillSize.width) || 0;
  const { width } = element.getBounds();
  const detailsLevel = element.getGraph().getDetailsLevel();
  const verticalLayout = ((_d = (_c = (_b = element.getGraph()).getLayoutOptions) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.rankdir) === TOP_TO_BOTTOM;
  useAnchor(React438.useCallback(
    (node) => new TaskNodeSourceAnchor(node, detailsLevel, statusIconSize + 4, verticalLayout),
    // Include scaleNode to cause an update when it changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [detailsLevel, statusIconSize, scaleNode, verticalLayout]
  ), AnchorEnd.source);
  useAnchor(React438.useCallback(
    (node) => new TaskNodeTargetAnchor(node, whenSize + whenOffset, detailsLevel, statusIconSize + 4, verticalLayout),
    // Include scaleNode to cause an update when it changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [whenSize, whenOffset, detailsLevel, statusIconSize, scaleNode, verticalLayout]
  ), AnchorEnd.target);
  React438.useEffect(() => {
    const sourceEdges = element.getSourceEdges();
    action(() => {
      const indent = detailsLevel === ScaleDetailsLevel.high && !verticalLayout ? width - pillWidth : 0;
      sourceEdges.forEach((edge) => {
        var _a3;
        const data = edge.getData();
        if (((_a3 = data === null || data === void 0 ? void 0 : data.indent) !== null && _a3 !== void 0 ? _a3 : 0) !== indent) {
          edge.setData(Object.assign(Object.assign({}, data || {}), { indent }));
        }
      });
    })();
    return action(() => {
      sourceEdges.forEach((edge) => {
        const data = edge.getData();
        if (data === null || data === void 0 ? void 0 : data.indent) {
          edge.setData(Object.assign(Object.assign({}, data || {}), { indent: 0 }));
        }
      });
    });
  }, [detailsLevel, element, pillWidth, verticalLayout, width]);
  const scale2 = element.getGraph().getScale();
  const nodeScale = useScaleNode_default(scaleNode, scale2, SCALE_UP_TIME2);
  const { translateX: translateX2, translateY: translateY2 } = getNodeScaleTranslation(element, nodeScale, scaleNode);
  const taskPill = React438.createElement(TaskPill_default, Object.assign({ x: verticalLayout ? 0 : whenOffset, y: 0, className: css2("pf-topology__pipelines__task-node", className), scaleNode, hover: hovered, statusIconSize, pillRef, width, taskRef, element }, rest));
  return React438.createElement("g", { className: css2("pf-topology__pipelines__task-node", className), transform: `${scaleNode ? `translate(${translateX2}, ${translateY2})` : ""} scale(${nodeScale})`, ref: hoverRef }, !toolTip || disableTooltip ? taskPill : React438.createElement(Tooltip, Object.assign({ triggerRef: taskRef, position: "bottom", enableFlip: false }, toolTipProps !== null && toolTipProps !== void 0 ? toolTipProps : {}, { content: toolTip }), taskPill));
});
var TaskNode = (_a2) => {
  var { element, paddingX = 8, paddingY = 8, statusIconSize = STATUS_ICON_SIZE2, showStatusState = true, hiddenDetailsShownStatuses = [RunStatus.Failed, RunStatus.FailedToStart, RunStatus.Cancelled], badgeClassName = import_topology_pipelines4.default.topologyPipelinesPillBadge, taskIconPadding = 4, truncateLength = 14, disableTooltip = false, whenSize = 0, whenOffset = 0 } = _a2, rest = __rest(_a2, ["element", "paddingX", "paddingY", "statusIconSize", "showStatusState", "hiddenDetailsShownStatuses", "badgeClassName", "taskIconPadding", "truncateLength", "disableTooltip", "whenSize", "whenOffset"]);
  if (!isNode(element)) {
    throw new Error("TaskNode must be used only on Node elements");
  }
  return React438.createElement(TaskNodeInner, Object.assign({ element, paddingX, paddingY, statusIconSize, showStatusState, hiddenDetailsShownStatuses, badgeClassName, taskIconPadding, truncateLength, disableTooltip, whenSize, whenOffset }, rest));
};
var TaskNode_default = TaskNode;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/nodes/FinallyNode.js
var FinallyNode = (props) => React439.createElement(TaskNode_default, Object.assign({ whenOffset: 0, whenSize: 0, truncateLength: 22 }, props));
var FinallyNode_default = FinallyNode;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/nodes/SpacerNode.js
var React440 = __toESM(require_react());
var SpacerNode = () => React440.createElement("g", null);
var SpacerNode_default = observer2(SpacerNode);

// node_modules/@patternfly/react-topology/dist/esm/pipelines/decorators/WhenDecorator.js
var React441 = __toESM(require_react());
var import_topology_pipelines5 = __toESM(require_topology_pipelines());
var import_topology_components31 = __toESM(require_topology_components());
var DEFAULT_WHEN_SIZE = 12;
var DEFAULT_WHEN_OFFSET = 12;
var WhenDecorator = observer2(({ element, width = DEFAULT_WHEN_SIZE, height = DEFAULT_WHEN_SIZE, className, status, leftOffset = DEFAULT_WHEN_OFFSET, topOffset = DEFAULT_WHEN_OFFSET, edgeLength = DEFAULT_WHEN_OFFSET, toolTip, disableTooltip = false }) => {
  var _a2, _b, _c;
  const nodeElement = element;
  const diamondNodeRef = React441.useRef();
  const { height: taskHeight, width: taskWidth } = nodeElement.getBounds();
  const verticalLayout = ((_c = (_b = (_a2 = element.getGraph()).getLayoutOptions) === null || _b === void 0 ? void 0 : _b.call(_a2)) === null || _c === void 0 ? void 0 : _c.rankdir) === TOP_TO_BOTTOM;
  const points = React441.useMemo(() => {
    if (verticalLayout) {
      const y5 = -topOffset;
      const startX2 = taskWidth / 2;
      return `
        ${startX2} ${y5}
        ${startX2 - width / 2} ${y5 - height / 2}
        ${startX2} ${y5 - height}
        ${startX2 + width / 2} ${y5 - height / 2}
      `;
    }
    const y4 = taskHeight / 2 - height / 2;
    const startX = -width - leftOffset;
    return `
      ${startX + width / 2} ${y4}
      ${startX + width} ${y4 + height / 2}
      ${startX + width / 2} ${y4 + height}
      ${startX} ${y4 + height / 2}
    `;
  }, [height, leftOffset, taskHeight, taskWidth, topOffset, verticalLayout, width]);
  const linePoints = verticalLayout ? {
    x1: taskWidth / 2,
    y1: -topOffset,
    x2: taskWidth / 2,
    y2: -topOffset + edgeLength
  } : {
    x1: -leftOffset,
    y1: taskHeight / 2,
    x2: -leftOffset + edgeLength,
    y2: taskHeight / 2
  };
  const diamondNode = React441.createElement(
    "g",
    { className, ref: diamondNodeRef },
    React441.createElement("line", Object.assign({ className: css2(import_topology_components31.default.topologyEdgeBackground) }, linePoints)),
    React441.createElement("line", Object.assign({ className: css2(import_topology_components31.default.topologyEdge, import_topology_pipelines5.default.topologyPipelinesWhenExpressionEdge) }, linePoints)),
    React441.createElement("polygon", { "data-test": "diamond-decorator", className: css2(import_topology_pipelines5.default.topologyPipelinesWhenExpressionBackground, getWhenStatusModifier(status)), points })
  );
  return toolTip && !disableTooltip ? React441.createElement(Tooltip, { triggerRef: diamondNodeRef, position: "bottom", enableFlip: false, content: React441.createElement("div", { "data-test": "when-expression-tooltip" }, toolTip) }, diamondNode) : diamondNode;
});
WhenDecorator.displayName = "WhenDecorator";
var WhenDecorator_default = WhenDecorator;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/edges/TaskEdge.js
var React442 = __toESM(require_react());
var import_topology_components32 = __toESM(require_topology_components());
var TaskEdgeInner = observer2(({ element, startTerminalType = EdgeTerminalType.none, startTerminalClass, startTerminalStatus, startTerminalSize = 14, endTerminalType = EdgeTerminalType.none, endTerminalClass, endTerminalStatus, endTerminalSize = 14, className, nodeSeparation, selected, onSelect }) => {
  var _a2, _b, _c, _d;
  const startPoint = element.getStartPoint();
  const endPoint = element.getEndPoint();
  const groupClassName = css2(import_topology_components32.default.topologyEdge, className, selected && "pf-m-selected", onSelect && "pf-m-selectable");
  const startIndent = ((_a2 = element.getData()) === null || _a2 === void 0 ? void 0 : _a2.indent) || 0;
  const verticalLayout = ((_d = (_c = (_b = element.getGraph()).getLayoutOptions) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.rankdir) === TOP_TO_BOTTOM;
  const edgePath = integralShapePath(startPoint, endPoint, startIndent, nodeSeparation, verticalLayout);
  const edgeBackground = React442.createElement("path", { onClick: onSelect, className: css2(import_topology_components32.default.topologyEdgeBackground, onSelect && "pf-m-selectable"), d: edgePath });
  return React442.createElement(
    "g",
    { "data-test-id": "task-handler", className: groupClassName },
    selected ? edgeBackground : React442.createElement(Layer_default, { id: TOP_LAYER }, edgeBackground),
    React442.createElement("path", { d: edgePath, transform: "translate(0.5,0.5)", shapeRendering: "geometricPrecision", fillOpacity: 0 }),
    React442.createElement(DefaultConnectorTerminal_default, { className: startTerminalClass, isTarget: false, edge: element, size: startTerminalSize, terminalType: startTerminalType, status: startTerminalStatus }),
    React442.createElement(DefaultConnectorTerminal_default, { className: endTerminalClass, isTarget: true, edge: element, size: endTerminalSize, terminalType: endTerminalType, status: endTerminalStatus, startPoint: verticalLayout ? endPoint.clone().translate(0, -1) : endPoint.clone().translate(-1, 0) })
  );
});
var TaskEdge = (_a2) => {
  var { element } = _a2, rest = __rest(_a2, ["element"]);
  if (!isEdge(element)) {
    throw new Error("TaskEdge must be used only on Edge elements");
  }
  return React442.createElement(TaskEdgeInner, Object.assign({ element }, rest));
};
var TaskEdge_default = TaskEdge;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/edges/WhenEdge.js
var React443 = __toESM(require_react());
var WhenEdge = ({ element }) => React443.createElement(DefaultEdge_default, { element, endTerminalType: EdgeTerminalType.none });
var WhenEdge_default = WhenEdge;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/groups/DefaultTaskGroup.js
var React446 = __toESM(require_react());

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/groups/DefaultTaskGroupCollapsed.js
var React444 = __toESM(require_react());
var DefaultTaskGroupCollapsed = (_a2) => {
  var { element, shadowCount = 2, collapsible, onCollapseChange } = _a2, rest = __rest(_a2, ["element", "shadowCount", "collapsible", "onCollapseChange"]);
  return React444.createElement(TaskNode_default, Object.assign({ element }, rest, { actionIcon: collapsible ? React444.createElement(expand_alt_icon_default, null) : void 0, onActionIconClick: () => onCollapseChange(element, false), shadowCount }, rest));
};
var DefaultTaskGroupCollapsed_default = observer2(DefaultTaskGroupCollapsed);

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/groups/DefaultTaskGroupExpanded.js
var React445 = __toESM(require_react());
var import_topology_components33 = __toESM(require_topology_components());
var DefaultTaskGroupExpanded = observer2(({ className, element, collapsible, selected, onSelect, hover, label, secondaryLabel, showLabel = true, showLabelOnHover, hideDetailsAtMedium, status, GroupLabelComponent = NodeLabel_default, truncateLength, canDrop, dropTarget, onContextMenu, contextMenuOpen, dragging, dragNodeRef, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, labelOffset = 17, centerLabelOnEdge, labelIconClass, labelIcon, labelIconPadding, onCollapseChange, labelPosition, borderRadius = 16 }) => {
  var _a2, _b, _c, _d;
  const [hovered, hoverRef] = useHover_default(200, 500);
  const [labelHover, labelHoverRef] = useHover_default(0);
  const dragLabelRef = useDragNode()[1];
  const refs = useCombineRefs_default(hoverRef, dragNodeRef);
  const isHover = hover !== void 0 ? hover : hovered || labelHover;
  const [labelSize, labelRef] = useSize([centerLabelOnEdge]);
  const verticalLayout = ((_c = (_b = (_a2 = element.getGraph()).getLayoutOptions) === null || _b === void 0 ? void 0 : _b.call(_a2)) === null || _c === void 0 ? void 0 : _c.rankdir) === TOP_TO_BOTTOM;
  const groupLabelPosition = (_d = labelPosition !== null && labelPosition !== void 0 ? labelPosition : element.getLabelPosition()) !== null && _d !== void 0 ? _d : LabelPosition.bottom;
  let parent = element.getParent();
  const detailsLevel = element.getGraph().getDetailsLevel();
  let altGroup = false;
  while (!isGraph(parent)) {
    altGroup = !altGroup;
    parent = parent.getParent();
  }
  const labelShown = showLabel && (!hideDetailsAtMedium || detailsLevel === ScaleDetailsLevel.high || isHover && showLabelOnHover) && (label || element.getLabel());
  const anchorOffset = verticalLayout ? (labelSize === null || labelSize === void 0 ? void 0 : labelSize.height) / 2 : (labelSize === null || labelSize === void 0 ? void 0 : labelSize.width) / 2;
  useAnchor(React445.useCallback((node) => new TaskGroupSourceAnchor(node, verticalLayout, labelShown && (centerLabelOnEdge && labelPosition === LabelPosition.bottom && verticalLayout || labelPosition === LabelPosition.right && !verticalLayout) && labelSize ? anchorOffset : 0), [labelShown, anchorOffset, centerLabelOnEdge, labelPosition, labelSize, verticalLayout]), AnchorEnd.source);
  useAnchor(React445.useCallback((node) => new TaskGroupTargetAnchor(node, verticalLayout, labelShown && (centerLabelOnEdge && labelPosition === LabelPosition.top && verticalLayout || labelPosition === LabelPosition.left && !verticalLayout) && labelSize ? anchorOffset : 0), [labelShown, anchorOffset, centerLabelOnEdge, labelPosition, labelSize, verticalLayout]), AnchorEnd.target);
  const bounds = element.getBounds();
  const [labelX, labelY] = React445.useMemo(() => {
    if (!showLabel || !(label || element.getLabel())) {
      return [0, 0];
    }
    switch (groupLabelPosition) {
      case LabelPosition.top:
        return [bounds.x + bounds.width / 2, -bounds.y + (centerLabelOnEdge ? 0 : labelOffset)];
      case LabelPosition.right:
        return [bounds.x + bounds.width + (centerLabelOnEdge ? 0 : labelOffset), bounds.y + bounds.height / 2];
      case LabelPosition.left:
        return [centerLabelOnEdge ? bounds.x : labelOffset, bounds.y + bounds.height / 2];
      case LabelPosition.bottom:
      default:
        return [bounds.x + bounds.width / 2, bounds.y + bounds.height + (centerLabelOnEdge ? 0 : labelOffset)];
    }
  }, [
    showLabel,
    label,
    element,
    groupLabelPosition,
    bounds.x,
    bounds.width,
    bounds.y,
    bounds.height,
    centerLabelOnEdge,
    labelOffset
  ]);
  const children2 = element.getNodes().filter((c6) => c6.isVisible());
  if (children2.length === 0) {
    return null;
  }
  const groupClassName = css2(import_topology_components33.default.topologyGroup, className, altGroup && "pf-m-alt-group", canDrop && "pf-m-highlight", dragging && "pf-m-dragging", selected && "pf-m-selected");
  const innerGroupClassName = css2(import_topology_components33.default.topologyGroup, className, altGroup && "pf-m-alt-group", canDrop && "pf-m-highlight", dragging && "pf-m-dragging", selected && "pf-m-selected", isHover && "pf-m-hover", canDrop && dropTarget && "pf-m-drop-target");
  const scale2 = element.getGraph().getScale();
  const medScale = element.getGraph().getDetailsLevelThresholds().medium;
  const labelScale = detailsLevel !== ScaleDetailsLevel.high ? Math.min(1 / scale2, 1 / medScale) : 1;
  const labelPositionScale = detailsLevel !== ScaleDetailsLevel.high ? 1 / labelScale : 1;
  const groupLabel = labelShown ? React445.createElement(
    "g",
    { ref: labelHoverRef, transform: isHover ? `scale(${labelScale})` : void 0 },
    React445.createElement(GroupLabelComponent, { element, boxRef: labelRef, className: import_topology_components33.default.topologyGroupLabel, x: labelX * labelPositionScale, y: labelY * labelPositionScale, position: labelPosition, centerLabelOnEdge, runStatus: status, paddingX: 8, paddingY: 5, dragRef: dragNodeRef ? dragLabelRef : void 0, status: element.getNodeStatus(), selected, secondaryLabel, truncateLength, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, badgeLocation, labelIconClass, labelIcon, labelIconPadding, onContextMenu, contextMenuOpen, hover: isHover || labelHover, actionIcon: collapsible ? React445.createElement(compress_alt_icon_default, null) : void 0, onActionIconClick: () => onCollapseChange(element, true) }, label || element.getLabel())
  ) : null;
  return React445.createElement(
    "g",
    { onContextMenu, onClick: onSelect, className: groupClassName },
    React445.createElement(
      Layer_default,
      { id: GROUPS_LAYER },
      React445.createElement(
        "g",
        { ref: refs, onContextMenu, onClick: onSelect, className: innerGroupClassName },
        React445.createElement("rect", { x: bounds.x, y: bounds.y, width: bounds.width, height: bounds.height, className: import_topology_components33.default.topologyGroupBackground, rx: borderRadius, ry: borderRadius })
      ),
      groupLabel && isHover ? React445.createElement(
        Layer_default,
        { id: TOP_LAYER },
        React445.createElement("g", { className: innerGroupClassName }, groupLabel)
      ) : groupLabel
    )
  );
});
var DefaultTaskGroupExpanded_default = DefaultTaskGroupExpanded;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/groups/DefaultTaskGroup.js
var DefaultTaskGroupInner = observer2((_a2) => {
  var { element, badge, onCollapseChange, collapsedShadowCount, recreateLayoutOnCollapseChange, getEdgeCreationTypes } = _a2, rest = __rest(_a2, ["element", "badge", "onCollapseChange", "collapsedShadowCount", "recreateLayoutOnCollapseChange", "getEdgeCreationTypes"]);
  const childCount = element.getAllNodeChildren().length;
  const handleCollapse = action((group2, collapsed) => {
    if (collapsed && rest.collapsedWidth !== void 0 && rest.collapsedHeight !== void 0) {
      group2.setDimensions(new Dimensions(rest.collapsedWidth, rest.collapsedHeight));
    }
    group2.setCollapsed(collapsed);
    if (recreateLayoutOnCollapseChange) {
      const controller = group2.hasController() && group2.getController();
      if (controller) {
        const model = controller.toModel();
        const creationTypes = getEdgeCreationTypes ? getEdgeCreationTypes() : {};
        const pipelineNodes = model.nodes.filter((n) => n.type !== (creationTypes.spacerNodeType || DEFAULT_SPACER_NODE_TYPE)).map((n) => Object.assign(Object.assign({}, n), { visible: true }));
        const spacerNodes = getSpacerNodes(pipelineNodes, creationTypes.spacerNodeType, creationTypes.finallyNodeTypes);
        const nodes = [...pipelineNodes, ...spacerNodes];
        const edges = getEdgesFromNodes(pipelineNodes, creationTypes.spacerNodeType, creationTypes.edgeType, creationTypes.edgeType, creationTypes.finallyNodeTypes, creationTypes.finallyEdgeType);
        controller.fromModel({ nodes, edges }, true);
        controller.getGraph().layout();
      }
    }
    const graph = group2.getGraph();
    if (graph) {
      if (!collapsed) {
        graph.fit(80, group2);
      } else {
        let rect;
        graph.getNodes().forEach((c6) => {
          const b = c6.getBounds();
          if (!rect) {
            rect = b.clone();
          } else {
            rect.union(b);
          }
        });
        const graphBounds = graph.getBounds();
        if (rect.width < graphBounds.width || rect.height < graphBounds.height) {
          graph.fit(80);
        }
        graph.centerInView(group2);
      }
    }
    onCollapseChange && onCollapseChange(group2, collapsed);
  });
  if (element.isCollapsed()) {
    return React446.createElement(DefaultTaskGroupCollapsed_default, Object.assign({ element, shadowCount: collapsedShadowCount, onCollapseChange: handleCollapse, badge: badge || `${childCount}` }, rest));
  }
  return React446.createElement(DefaultTaskGroupExpanded_default, Object.assign({ element, badge, onCollapseChange: handleCollapse }, rest));
});
var DefaultTaskGroup = (_a2) => {
  var { element, badgeColor = "#f5f5f5", badgeBorderColor = "#d2d2d2", badgeTextColor = "#000000" } = _a2, rest = __rest(_a2, ["element", "badgeColor", "badgeBorderColor", "badgeTextColor"]);
  if (!isNode(element)) {
    throw new Error("DefaultTaskGroup must be used only on Node elements");
  }
  return React446.createElement(DefaultTaskGroupInner, Object.assign({ element, badgeColor, badgeBorderColor, badgeTextColor }, rest));
};
var DefaultTaskGroup_default = DefaultTaskGroup;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/components/groups/TaskGroupPillLabel.js
var React447 = __toESM(require_react());
var import_topology_components34 = __toESM(require_topology_components());
var TaskGroupPillLabel = (_a2) => {
  var { element, labelOffset = 17, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, runStatus, truncateLength, boxRef, position, centerLabelOnEdge, onContextMenu, contextMenuOpen, actionIcon, onActionIconClick } = _a2, rest = __rest(_a2, ["element", "labelOffset", "badge", "badgeColor", "badgeTextColor", "badgeBorderColor", "badgeClassName", "runStatus", "truncateLength", "boxRef", "position", "centerLabelOnEdge", "onContextMenu", "contextMenuOpen", "actionIcon", "onActionIconClick"]);
  const [labelSize, labelRef] = useSize([]);
  const pillRef = useCombineRefs_default(boxRef, labelRef);
  const labelWidth = (labelSize === null || labelSize === void 0 ? void 0 : labelSize.width) || 0;
  const labelHeight = (labelSize === null || labelSize === void 0 ? void 0 : labelSize.height) || 0;
  const bounds = element.getBounds();
  const detailsLevel = element.getGraph().getDetailsLevel();
  const scale2 = element.getGraph().getScale();
  const medScale = element.getGraph().getDetailsLevelThresholds().medium;
  const labelScale = detailsLevel !== ScaleDetailsLevel.high ? Math.min(1 / scale2, 1 / medScale) : 1;
  const labelPositionScale = detailsLevel !== ScaleDetailsLevel.high ? 1 / labelScale : 1;
  const { startX, startY } = React447.useMemo(() => {
    let startX2;
    let startY2;
    const scaledWidth = labelWidth / labelPositionScale;
    const scaledHeight = labelHeight / labelPositionScale;
    if (position === LabelPosition.top) {
      startX2 = bounds.x + bounds.width / 2 - scaledWidth / 2;
      startY2 = bounds.y - (centerLabelOnEdge ? scaledHeight / 2 : labelOffset);
    } else if (position === LabelPosition.right) {
      startX2 = bounds.x + bounds.width + (centerLabelOnEdge ? -scaledWidth / 2 : labelOffset);
      startY2 = bounds.y + bounds.height / 2;
    } else if (position === LabelPosition.left) {
      startX2 = bounds.x - (centerLabelOnEdge ? scaledWidth / 2 : scaledWidth + labelOffset);
      startY2 = bounds.y + bounds.height / 2;
    } else {
      startX2 = bounds.x + bounds.width / 2 - scaledWidth / 2;
      startY2 = bounds.y + bounds.height + (centerLabelOnEdge ? -scaledHeight / 2 : labelOffset);
    }
    return { startX: startX2, startY: startY2 };
  }, [
    labelPositionScale,
    position,
    bounds.width,
    bounds.x,
    bounds.y,
    bounds.height,
    centerLabelOnEdge,
    labelHeight,
    labelOffset,
    labelWidth
  ]);
  return React447.createElement(TaskPill_default, Object.assign({}, rest, { element, width: labelWidth, pillRef, actionIcon, onActionIconClick, className: import_topology_components34.default.topologyNodeLabel, status: runStatus, x: startX * labelPositionScale, y: startY * labelPositionScale, paddingX: 8, paddingY: 5, scaleNode: false, truncateLength, badge, badgeColor, badgeTextColor, badgeBorderColor, badgeClassName, onContextMenu, contextMenuOpen }));
};
var TaskGroupPillLabel_default = observer2(TaskGroupPillLabel);

// node_modules/@patternfly/react-topology/dist/esm/pipelines/elements/BasePipelineNode.js
var BasePipelineNode = class extends BaseNode {
  constructor() {
    super();
  }
  setModel(model) {
    super.setModel(model);
    if ("runAfterTasks" in model) {
      this.runAfterTasks = model.runAfterTasks;
    }
  }
  toModel() {
    return Object.assign(Object.assign({}, super.toModel()), { runAfterTasks: this.runAfterTasks, children: super.getAllChildren().map((c6) => c6.getId()) });
  }
};
var BasePipelineNode_default = BasePipelineNode;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/elements/pipelineElementFactory.js
var pipelineElementFactory = (kind) => {
  switch (kind) {
    case ModelKind.node:
      return new BasePipelineNode_default();
    default:
      return void 0;
  }
};
var pipelineElementFactory_default = pipelineElementFactory;

// node_modules/@patternfly/react-topology/dist/esm/pipelines/layouts/PipelineDagreLayout.js
var PipelineDagreLayout = class extends DagreLayout {
  constructor(graph, options) {
    super(graph, Object.assign({ linkDistance: 0, nodeDistance: 0, groupDistance: 0, collideDistance: 0, simulationSpeed: 0, chargeStrength: 0, allowDrag: false, layoutOnDrag: false, nodesep: NODE_SEPARATION_VERTICAL, ranksep: NODE_SEPARATION_HORIZONTAL, edgesep: 50, ranker: "longest-path", rankdir: LEFT_TO_RIGHT, marginx: 20, marginy: 20 }, options));
  }
  set nodesep(nodesep) {
    this.dagreOptions.nodesep = nodesep;
  }
  set ranksep(ranksep) {
    this.dagreOptions.ranksep = ranksep;
  }
};

// node_modules/@patternfly/react-topology/dist/esm/pipelines/layouts/PipelineDagreGroupsLayout.js
var PipelineDagreGroupsLayout = class extends DagreGroupsLayout {
  constructor(graph, options) {
    super(graph, Object.assign({ linkDistance: 0, nodeDistance: 0, groupDistance: 0, collideDistance: 0, simulationSpeed: 0, chargeStrength: 0, allowDrag: false, layoutOnDrag: false, nodesep: NODE_SEPARATION_VERTICAL, ranksep: NODE_SEPARATION_HORIZONTAL, edgesep: 50, ranker: "tight-tree", rankdir: LEFT_TO_RIGHT, marginx: 20, marginy: 20 }, options));
  }
  set nodesep(nodesep) {
    this.dagreOptions.nodesep = nodesep;
  }
  set ranksep(ranksep) {
    this.dagreOptions.ranksep = ranksep;
  }
};

// node_modules/@patternfly/react-topology/dist/esm/css/index.js
var css_exports = {};
__reExport(css_exports, __toESM(require_topology_components()));
__reExport(css_exports, __toESM(require_topology_controlbar()));
__reExport(css_exports, __toESM(require_topology_pipelines()));
__reExport(css_exports, __toESM(require_topology_side_bar()));
__reExport(css_exports, __toESM(require_topology_view()));

// node_modules/@patternfly/react-topology/dist/esm/index.js
__reExport(esm_exports, css_exports);
export {
  ADD_CHILD_EVENT,
  ATTR_DATA_ID,
  ATTR_DATA_KIND,
  ATTR_DATA_TYPE,
  AbstractAnchor,
  AnchorEnd,
  BOTTOM_LAYER,
  BadgeLocation,
  BaseEdge,
  BaseElement,
  BaseGraph,
  BaseLayout,
  BaseNode,
  BasePipelineNode_default as BasePipelineNode,
  BreadthFirstLayout,
  COLLAPSE_ALL,
  CREATE_CONNECTOR_DROP_TYPE,
  CREATE_CONNECTOR_OPERATION,
  CenterAnchor,
  ColaGroup,
  ColaGroupsLayout,
  ColaGroupsNode,
  ColaLayout,
  ColaLink,
  ColaNode,
  ConcentricLayout,
  ConnectorArrow_default as ConnectorArrow,
  ConnectorArrowAlt_default as ConnectorArrowAlt,
  ConnectorCircle_default as ConnectorCircle,
  ConnectorCross_default as ConnectorCross,
  ConnectorSquare_default as ConnectorSquare,
  ContextMenu_default as ContextMenu,
  DropdownItem as ContextMenuItem,
  Divider as ContextMenuSeparator,
  ContextSubMenuItem_default as ContextSubMenuItem,
  ControllerContext_default as ControllerContext,
  DEFAULT_DECORATOR_PADDING,
  DEFAULT_DECORATOR_RADIUS,
  DEFAULT_EDGE_TYPE,
  DEFAULT_FINALLY_EDGE_TYPE,
  DEFAULT_FINALLY_NODE_TYPE,
  DEFAULT_LAYER,
  DEFAULT_LAYERS,
  DEFAULT_SPACER_NODE_TYPE,
  DEFAULT_TASK_NODE_TYPE,
  DEFAULT_WHEN_OFFSET,
  DEFAULT_WHEN_SIZE,
  DRAG_MOVE_OPERATION,
  DRAG_NODE_END_EVENT,
  DRAG_NODE_EVENT,
  DRAG_NODE_START_EVENT,
  DagreGroupsLayout,
  DagreLayout,
  Decorator_default as Decorator,
  DefaultConnectorTerminal_default as DefaultConnectorTerminal,
  DefaultConnectorTag_default as DefaultConntectorTag,
  DefaultCreateConnector_default as DefaultCreateConnector,
  DefaultEdge_default as DefaultEdge,
  DefaultGroup_default as DefaultGroup,
  DefaultNode_default as DefaultNode,
  DefaultRemoveConnector_default as DefaultRemoveConnector,
  DefaultTaskGroup_default as DefaultTaskGroup,
  DefaultTaskGroupCollapsed_default as DefaultTaskGroupCollapsed,
  DefaultTaskGroupExpanded_default as DefaultTaskGroupExpanded,
  Dimensions,
  DndManagerImpl,
  DrawDesign,
  EDGE_DRAG_TYPE,
  ELEMENT_VISIBILITY_CHANGE_EVENT,
  EXPAND_ALL,
  EdgeAnimationSpeed,
  DefaultConnectorTerminal_default as EdgeConnectorArrow,
  EdgeStyle,
  EdgeTerminalType,
  ElementContext_default as ElementContext,
  ElementWrapper_default as ElementWrapper,
  Ellipse_default as Ellipse,
  EllipseAnchor,
  FIT_TO_SCREEN,
  FinallyNode_default as FinallyNode,
  ForceLayout,
  GRAPH_LAYOUT_END_EVENT,
  GRAPH_POSITION_CHANGE_EVENT,
  GROUPS_LAYER,
  GraphComponent_default as GraphComponent,
  GridLayout,
  HEXAGON_CORNER_RADIUS,
  Hexagon_default as Hexagon,
  LAYOUT_DEFAULTS,
  LEFT_TO_RIGHT,
  LEGEND,
  LOWER_LEFT_RADIANS,
  LOWER_RIGHT_RADIANS,
  LabelActionIcon_default as LabelActionIcon,
  LabelBadge_default as LabelBadge,
  LabelContextMenu_default as LabelContextMenu,
  LabelIcon_default as LabelIcon,
  LabelPosition,
  Layer_default as Layer,
  LayersProvider,
  LayoutGroup,
  LayoutLink,
  LayoutNode,
  MOVE_CONNECTOR_DROP_TYPE,
  ModelKind,
  Modifiers,
  NODE_COLLAPSE_CHANGE_EVENT,
  NODE_DRAG_TYPE,
  NODE_POSITIONED_EVENT,
  NODE_SEPARATION_HORIZONTAL,
  NODE_SEPARATION_VERTICAL,
  NodeLabel_default as NodeLabel,
  NodeShadows_default as NodeShadows,
  NodeShape,
  NodeStatus,
  OCTAGON_CORNER_RADIUS,
  Octagon_default as Octagon,
  PipelineDagreGroupsLayout,
  PipelineDagreLayout,
  Point,
  PolygonAnchor,
  REGROUP_OPERATION,
  REMOVE_CHILD_EVENT,
  RESET_VIEW,
  RHOMBUS_CORNER_RADIUS,
  Rect,
  RectAnchor,
  Rectangle_default as Rectangle,
  RegisterComponentFactory_default as RegisterComponentFactory,
  RegisterElementFactory_default as RegisterElementFactory,
  RegisterLayoutFactory_default as RegisterLayoutFactory,
  Rhombus_default as Rhombus,
  RunStatus,
  SELECTION_EVENT,
  SELECTION_STATE,
  SVGAnchor,
  SVGArrowMarker_default as SVGArrowMarker,
  SVGDefs,
  SVGDefsProvider_default as SVGDefsProvider,
  ScaleDetailsLevel,
  SidedShape_default as SidedShape,
  SpacerNode_default as SpacerNode,
  Stadium_default as Stadium,
  StatusIcon_default as StatusIcon,
  StatusModifier,
  TOP_LAYER,
  TOP_TO_BOTTOM,
  TRAPEZOID_CORNER_RADIUS,
  TaskEdge_default as TaskEdge,
  TaskGroupPillLabel_default as TaskGroupPillLabel,
  TaskGroupSourceAnchor,
  TaskGroupTargetAnchor,
  TaskNode_default as TaskNode,
  TaskNodeSourceAnchor,
  TaskNodeTargetAnchor,
  TaskPill_default as TaskPill,
  TopologyControlBar,
  TopologyQuadrant,
  TopologySideBar,
  TopologyView,
  Trapezoid_default as Trapezoid,
  UPPER_LEFT_RADIANS,
  UPPER_RIGHT_RADIANS,
  Visualization,
  VisualizationProvider_default as VisualizationProvider,
  VisualizationSurface_default as VisualizationSurface,
  WhenDecorator_default as WhenDecorator,
  WhenEdge_default as WhenEdge,
  WhenDecorator_default as WhenNode,
  WhenStatus,
  ZOOM_IN,
  ZOOM_OUT,
  action,
  addSpacerNodes,
  boundingBoxForLine,
  canDropEdgeOnNode,
  createAggregateEdges,
  createSvgIdUrl,
  createTopologyControlButtons,
  defaultControlButtonsOptions,
  defaultElementFactory_default as defaultElementFactory,
  distanceToPoint,
  edgeDragSourceSpec,
  getClosestVisibleParent,
  getDefaultShapeDecoratorCenter,
  getEdgeAnimationDuration,
  getEdgeStyleClassModifier,
  getEdgesFromNodes,
  getElementPadding,
  getEllipseAnchorPoint,
  getGroupChildrenDimensions,
  getGroupPadding,
  getHullPath,
  getLinesIntersection,
  getNodeScaleTranslation,
  getPathAnchorPoint,
  getPathForSides,
  getPointsForSides,
  getPolygonAnchorPoint,
  getRectAnchorPoint,
  getRunStatusModifier,
  getShapeComponent,
  getSpacerNodes,
  getTopCollapsedParent,
  getWhenStatusModifier,
  graphDropTargetSpec,
  groupDropTargetSpec,
  groupNodeElements,
  highlightNode,
  hullPath,
  integralShapePath,
  isEdge,
  isGraph,
  isNode,
  leafNodeElements,
  matchesType,
  maxPadding,
  noDropTargetSpec,
  noRegroupDragSourceSpec,
  nodeDragSourceSpec,
  nodeDropTargetSpec,
  nodesEdgeIsDragging,
  nonShadowModifiers,
  observer2 as observer,
  path2 as path,
  pipelineElementFactory_default as pipelineElementFactory,
  pointTuplesToPath,
  straightPath,
  unitNormal,
  useAnchor,
  useBendpoint,
  useCallbackRef,
  useCombineRefs_default as useCombineRefs,
  useComponentFactory_default as useComponentFactory,
  useDetailsLevel_default as useDetailsLevel,
  useDndDrag,
  useDndDrop,
  useDndManager,
  useDragNode,
  useElementFactory_default as useElementFactory,
  useEventListener_default as useEventListener,
  useHover_default as useHover,
  useLayoutFactory_default as useLayoutFactory,
  useModel_default as useModel,
  usePanZoom,
  usePolygonAnchor,
  useScaleNode_default as useScaleNode,
  useSelection,
  useSize,
  useSvgAnchor,
  useVisualizationController_default as useVisualizationController,
  useVisualizationState_default as useVisualizationState,
  vecScale,
  vecSum,
  withAnchor,
  withBendpoint,
  withContextMenu,
  withCreateConnector,
  withDndDrag,
  withDndDrop,
  withDragNode,
  withPanZoom,
  withPolygonAnchor,
  withRemoveConnector,
  withSelection,
  withSourceDrag,
  withSvgAnchor,
  withTargetDrag
};
/*! Bundled license information:

popper.js/dist/esm/popper.js:
  (**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)
*/
//# sourceMappingURL=@patternfly_react-topology.js.map
