"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VictorySharedEvents = void 0;
var _fromPairs2 = _interopRequireDefault(require("lodash/fromPairs"));
var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));
var _defaults2 = _interopRequireDefault(require("lodash/defaults"));
var _react = _interopRequireDefault(require("react"));
var _victoryCore = require("victory-core");
var _reactFastCompare = _interopRequireDefault(require("react-fast-compare"));
var _jsonStringifySafe = _interopRequireDefault(require("json-stringify-safe"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// DISCLAIMER:
// This file is not currently tested, and it is first on the list of files
// to refactor in our current refactoring effort. Please do not make changes
// to this file without manual testing and/or refactoring and adding tests.

// eslint-disable-next-line @typescript-eslint/no-empty-interface

class VictorySharedEvents extends _react.default.Component {
  static displayName = "VictorySharedEvents";
  static role = "shared-event-wrapper";
  static contextType = _victoryCore.TimerContext;
  static defaultProps = {
    groupComponent: /*#__PURE__*/_react.default.createElement("g", null)
  };
  constructor(props) {
    super(props);
    this.getScopedEvents = _victoryCore.Events.getScopedEvents.bind(this);
    this.getEventState = _victoryCore.Events.getEventState.bind(this);
    this.state = this.state || {};
    this.sharedEventsCache = {};
    this.globalEvents = {};
    this.prevGlobalEventKeys = [];
    this.boundGlobalEvents = {};
    this.baseProps = this.getBaseProps(props);
  }
  shouldComponentUpdate(nextProps) {
    if (!(0, _reactFastCompare.default)(this.props, nextProps)) {
      this.baseProps = this.getBaseProps(nextProps);
      const externalMutations = this.getExternalMutations(nextProps, this.baseProps);
      this.applyExternalMutations(nextProps, externalMutations);
    }
    return true;
  }
  componentDidMount() {
    const globalEventKeys = Object.keys(this.globalEvents);
    globalEventKeys.forEach(key => this.addGlobalListener(key));
    this.prevGlobalEventKeys = globalEventKeys;
  }
  componentDidUpdate() {
    const globalEventKeys = Object.keys(this.globalEvents);
    const removedGlobalEventKeys = _victoryCore.Collection.difference(this.prevGlobalEventKeys, globalEventKeys);
    removedGlobalEventKeys.forEach(key => this.removeGlobalListener(key));
    const addedGlobalEventKeys = _victoryCore.Collection.difference(globalEventKeys, this.prevGlobalEventKeys);
    addedGlobalEventKeys.forEach(key => this.addGlobalListener(key));
    this.prevGlobalEventKeys = globalEventKeys;
  }
  componentWillUnmount() {
    this.prevGlobalEventKeys.forEach(key => this.removeGlobalListener(key));
  }
  addGlobalListener(key) {
    const boundListener = event => {
      const listener = this.globalEvents[key];
      return listener && listener(_victoryCore.Events.emulateReactEvent(event));
    };
    this.boundGlobalEvents[key] = boundListener;
    window.addEventListener(_victoryCore.Events.getGlobalEventNameFromKey(key), boundListener);
  }
  removeGlobalListener(key) {
    window.removeEventListener(_victoryCore.Events.getGlobalEventNameFromKey(key), this.boundGlobalEvents[key]);
  }
  getAllEvents(props) {
    const components = ["container", "groupComponent"];
    const componentEvents = _victoryCore.Events.getComponentEvents(props, components);
    if (Array.isArray(componentEvents)) {
      return Array.isArray(props.events) ? componentEvents.concat(...props.events) : componentEvents;
    }
    return props.events;
  }
  applyExternalMutations(props, externalMutations) {
    if (!(0, _isEmpty2.default)(externalMutations)) {
      const callbacks = props.externalEventMutations.reduce((memo, mutation) => _victoryCore.Helpers.isFunction(mutation.callback) ? memo.concat(mutation.callback) : memo, []);
      const compiledCallbacks = callbacks.length ? () => {
        callbacks.forEach(c => c());
      } : undefined;
      this.setState(externalMutations, compiledCallbacks);
    }
  }
  getExternalMutations(props, baseProps) {
    return !(0, _isEmpty2.default)(props.externalEventMutations) ? _victoryCore.Events.getExternalMutationsWithChildren(props.externalEventMutations, baseProps, this.state, Object.keys(baseProps)) : undefined;
  }
  cacheSharedEvents(name, sharedEvents, cacheValues) {
    this.sharedEventsCache[name] = [sharedEvents, cacheValues];
  }
  getCachedSharedEvents(name, cacheValues) {
    const [sharedEvents, prevCacheValues] = this.sharedEventsCache[name] || [];
    if (sharedEvents && (0, _reactFastCompare.default)(cacheValues, prevCacheValues)) {
      return sharedEvents;
    }
    return undefined;
  }
  getBaseProps(props) {
    const {
      container
    } = props;
    const children = _react.default.Children.toArray(this.props.children);
    const childBaseProps = this.getBasePropsFromChildren(children);
    const parentBaseProps = container ? container.props : {};
    return Object.assign({}, childBaseProps, {
      parent: parentBaseProps
    });
  }
  getBasePropsFromChildren(childComponents) {
    const iteratee = (child, childName) => {
      if (child.type && _victoryCore.Helpers.isFunction(child.type.getBaseProps)) {
        const baseProps = child.props && child.type.getBaseProps(child.props);
        return baseProps ? [[childName, baseProps]] : null;
      }
      return null;
    };
    const baseProps = _victoryCore.Helpers.reduceChildren(childComponents, iteratee);
    return (0, _fromPairs2.default)(baseProps);
  }
  getNewChildren(props, baseProps) {
    const {
      events,
      eventKey
    } = props;
    const alterChildren = (children, childNames) => {
      return children.reduce((memo, child, index) => {
        if (child.props.children) {
          const newChildren = _react.default.Children.toArray(child.props.children);
          const names = childNames.slice(index, index + newChildren.length);
          const results = /*#__PURE__*/_react.default.cloneElement(child, child.props, alterChildren(newChildren, names));
          return memo.concat(results);
        } else if (childNames[index] !== "parent" && child.type && _victoryCore.Helpers.isFunction(child.type.getBaseProps)) {
          const name = child.props.name || childNames[index];
          const childEvents = Array.isArray(events) && events.filter(event => {
            if (event.target === "parent") {
              return false;
            }
            return Array.isArray(event.childName) ? event.childName.indexOf(name) > -1 : event.childName === name || event.childName === "all";
          });
          const sharedEventsCacheValues = [name, baseProps, childEvents, (0, _jsonStringifySafe.default)(this.state[name])];
          const sharedEvents = this.getCachedSharedEvents(name, sharedEventsCacheValues) || {
            events: childEvents,
            // partially apply child name and baseProps,
            getEvents: (evts, target) => this.getScopedEvents(evts, target, name, baseProps),
            // partially apply child name
            getEventState: (key, target) => this.getEventState(key, target, name)
          };
          this.cacheSharedEvents(name, sharedEvents, sharedEventsCacheValues);
          return memo.concat( /*#__PURE__*/_react.default.cloneElement(child, Object.assign({
            key: `events-${name}`,
            sharedEvents,
            eventKey,
            name
          }, child.props)));
        }
        return memo.concat(child);
      }, []);
    };
    const childNames = Object.keys(baseProps);
    const childComponents = _react.default.Children.toArray(props.children);
    return alterChildren(childComponents, childNames);
  }
  getContainer(props, baseProps, events) {
    const children = this.getNewChildren(props, baseProps);
    const parents = Array.isArray(events) ? events.filter(event => event.target === "parent") : [];
    const sharedEvents = parents.length > 0 ? {
      events: parents,
      // partially apply childName (null) and baseProps,
      getEvents: (evts, target) => this.getScopedEvents(evts, target, null, baseProps),
      getEventState: this.getEventState
    } : null;
    const container = props.container || props.groupComponent;
    const role = container.type && container.type.role;
    const containerProps = container.props || {};
    const boundGetEvents = _victoryCore.Events.getEvents.bind(this);
    const parentEvents = sharedEvents && boundGetEvents({
      sharedEvents
    }, "parent");
    const parentProps = (0, _defaults2.default)({}, this.getEventState("parent", "parent"), containerProps, baseProps.parent, {
      children
    });
    const containerEvents = (0, _defaults2.default)({}, _victoryCore.Events.getPartialEvents(parentEvents, "parent", parentProps), containerProps.events);
    this.globalEvents = _victoryCore.Events.getGlobalEvents(containerEvents);
    const localEvents = _victoryCore.Events.omitGlobalEvents(containerEvents);
    return role === "container" ? /*#__PURE__*/_react.default.cloneElement(container, Object.assign({}, parentProps, {
      events: localEvents
    })) : /*#__PURE__*/_react.default.cloneElement(container, localEvents, children);
  }
  render() {
    const events = this.getAllEvents(this.props);
    if (events) {
      return this.getContainer(this.props, this.baseProps, events);
    }
    return /*#__PURE__*/_react.default.cloneElement(this.props.container, {
      children: this.props.children
    });
  }
}
exports.VictorySharedEvents = VictorySharedEvents;