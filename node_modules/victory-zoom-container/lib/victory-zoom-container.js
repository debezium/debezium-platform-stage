"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VictoryZoomContainer = void 0;
exports.zoomContainerMixin = zoomContainerMixin;
var _defaults2 = _interopRequireDefault(require("lodash/defaults"));
var _react = _interopRequireDefault(require("react"));
var _zoomHelpers = require("./zoom-helpers");
var _victoryCore = require("victory-core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_DOWNSAMPLE = 150;
function zoomContainerMixin(Base) {
  // @ts-expect-error "TS2545: A mixin class must have a constructor with a single rest parameter of type 'any[]'."
  return class VictoryZoomContainer extends Base {
    static displayName = "VictoryZoomContainer";
    static defaultProps = {
      ..._victoryCore.VictoryContainer.defaultProps,
      clipContainerComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryClipContainer, null),
      allowPan: true,
      allowZoom: true,
      zoomActive: false
    };
    static defaultEvents(props) {
      return [{
        target: "parent",
        eventHandlers: {
          onMouseDown: (evt, targetProps) => {
            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseDown(evt, targetProps);
          },
          onTouchStart: (evt, targetProps) => {
            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseDown(evt, targetProps);
          },
          onMouseUp: (evt, targetProps) => {
            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseUp(evt, targetProps);
          },
          onTouchEnd: (evt, targetProps) => {
            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseUp(evt, targetProps);
          },
          onMouseLeave: (evt, targetProps) => {
            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseLeave(evt, targetProps);
          },
          onTouchCancel: (evt, targetProps) => {
            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseLeave(evt, targetProps);
          },
          // eslint-disable-next-line max-params
          onMouseMove: (evt, targetProps, eventKey, ctx) => {
            if (props.disable) {
              return {};
            }
            return _zoomHelpers.ZoomHelpers.onMouseMove(evt, targetProps, eventKey, ctx);
          },
          // eslint-disable-next-line max-params
          onTouchMove: (evt, targetProps, eventKey, ctx) => {
            if (props.disable) {
              return {};
            }
            evt.preventDefault();
            return _zoomHelpers.ZoomHelpers.onMouseMove(evt, targetProps, eventKey, ctx);
          },
          ...(props.disable || !props.allowZoom ? {} : {
            onWheel: _zoomHelpers.ZoomHelpers.onWheel
          })
        }
      }];
    }
    clipDataComponents(children, props) {
      const {
        scale,
        clipContainerComponent,
        polar,
        origin,
        horizontal
      } = props;
      const rangeX = horizontal ? scale.y.range() : scale.x.range();
      const rangeY = horizontal ? scale.x.range() : scale.y.range();
      const plottableWidth = Math.abs(rangeX[0] - rangeX[1]);
      const plottableHeight = Math.abs(rangeY[0] - rangeY[1]);
      const radius = Math.max(...rangeY);
      const groupComponent = /*#__PURE__*/_react.default.cloneElement(clipContainerComponent, {
        clipWidth: plottableWidth,
        clipHeight: plottableHeight,
        translateX: Math.min(...rangeX),
        translateY: Math.min(...rangeY),
        polar,
        origin: polar ? origin : undefined,
        radius: polar ? radius : undefined,
        ...clipContainerComponent.props
      });
      return _react.default.Children.toArray(children).map(child => {
        if (!_victoryCore.Data.isDataComponent(child)) {
          return child;
        }
        return /*#__PURE__*/_react.default.cloneElement(child, {
          groupComponent
        });
      });
    }
    modifyPolarDomain(domain, originalDomain) {
      // Only zoom the radius of polar charts. Zooming angles is very confusing
      return {
        x: originalDomain.x,
        y: [0, domain.y[1]]
      };
    }
    downsampleZoomData(props, child, domain) {
      const {
        downsample
      } = props;
      const getData = childProps => {
        const {
          data,
          x,
          y
        } = childProps;
        const defaultGetData = child.type && _victoryCore.Helpers.isFunction(child.type.getData) ? child.type.getData : () => undefined;
        // skip costly data formatting if x and y accessors are not present
        return Array.isArray(data) && !x && !y ? data : defaultGetData(childProps);
      };
      const data = getData(child.props);

      // return undefined if downsample is not run, then default() will replace with child.props.data
      if (!downsample || !domain || !data) {
        return undefined;
      }
      const maxPoints = downsample === true ? DEFAULT_DOWNSAMPLE : downsample;
      const dimension = props.zoomDimension || "x";

      // important: assumes data is ordered by dimension
      // get the start and end of the data that is in the current visible domain
      let startIndex = data.findIndex(d => d[dimension] >= domain[dimension][0]);
      let endIndex = data.findIndex(d => d[dimension] > domain[dimension][1]);
      // pick one more point (if available) at each end so that VictoryLine, VictoryArea connect
      if (startIndex !== 0) {
        startIndex -= 1;
      }
      if (endIndex !== -1) {
        endIndex += 1;
      }
      const visibleData = data.slice(startIndex, endIndex);
      return _victoryCore.Data.downsample(visibleData, maxPoints, startIndex);
    }
    modifyChildren(props) {
      const childComponents = _react.default.Children.toArray(props.children);
      return childComponents.map(child => {
        const role = child.type && child.type.role;
        const isDataComponent = _victoryCore.Data.isDataComponent(child);
        const {
          currentDomain,
          zoomActive,
          allowZoom
        } = props;
        const originalDomain = (0, _defaults2.default)({}, props.originalDomain, props.domain);
        const zoomDomain = (0, _defaults2.default)({}, props.zoomDomain, props.domain);
        const cachedZoomDomain = (0, _defaults2.default)({}, props.cachedZoomDomain, props.domain);
        let domain;
        if (!_zoomHelpers.ZoomHelpers.checkDomainEquality(zoomDomain, cachedZoomDomain)) {
          // if zoomDomain has been changed, use it
          domain = zoomDomain;
        } else if (allowZoom && !zoomActive) {
          // if user has zoomed all the way out, use the child domain
          domain = child.props.domain;
        } else {
          // default: use currentDomain, set by the event handlers
          domain = (0, _defaults2.default)({}, currentDomain, originalDomain);
        }
        let newDomain = props.polar ? this.modifyPolarDomain(domain, originalDomain) : domain;
        if (newDomain && props.zoomDimension) {
          // if zooming is restricted to a dimension, don't squash changes to zoomDomain in other dim
          newDomain = {
            ...zoomDomain,
            [props.zoomDimension]: newDomain[props.zoomDimension]
          };
        }
        // don't downsample stacked data
        const newProps = isDataComponent && role !== "stack" ? {
          domain: newDomain,
          data: this.downsampleZoomData(props, child, newDomain)
        } : {
          domain: newDomain
        };
        return /*#__PURE__*/_react.default.cloneElement(child, (0, _defaults2.default)(newProps, child.props));
      });
    }

    // Overrides method in VictoryContainer
    getChildren(props) {
      const children = this.modifyChildren(props);
      return this.clipDataComponents(children, props);
    }
  };
}
const VictoryZoomContainer = exports.VictoryZoomContainer = zoomContainerMixin(_victoryCore.VictoryContainer);